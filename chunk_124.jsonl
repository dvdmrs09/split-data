{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nvalidates a string input", "response": "def validateStringInput(input_key,input_data, read=False):\n    \"\"\"\n    To check if a string has the required format. This is only used for POST APIs.\n    \"\"\"\n    log = clog.error_log\n    func = None\n    if '*' in input_data or '%' in input_data:\n        func = validationFunctionWildcard.get(input_key)\n        if func is None:\n            func = searchstr\n    elif input_key == 'migration_input' :\n        if input_data.find('#') != -1 : func = block\n        else : func = dataset\n    else:\n        if not read:\n            func = validationFunction.get(input_key)\n            if func is None:\n                func = namestr\n        else:\n            if input_key == 'dataset':\n                func = reading_dataset_check\n            elif input_key == 'block_name':\n                func = reading_block_check\n            elif input_key == 'logical_file_name':\n                func = reading_lfn_check\n            else:\n                func = namestr\n    try:\n        func(input_data)\n    except AssertionError as ae:\n        serverLog = str(ae) + \" key-value pair (%s, %s) cannot pass input checking\" %(input_key, input_data)\n        #print serverLog\n        dbsExceptionHandler(\"dbsException-invalid-input2\", message=\"Invalid Input Data %s...:  Not Match Required Format\" %input_data[:10], \\\n            logger=log.error, serverError=serverLog)\n    return input_data"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a list of all primary datasets if pattern is not provided.", "response": "def execute(self, conn, transaction=False):\n        \"\"\"\n        Lists all primary datasets if pattern is not provided.\n        \"\"\"\n        sql = self.sql\n        binds = {}\n        \n\tcursors = self.dbi.processData(sql, binds, conn, transaction, returnCursor=True)\n        result = []\n        for c in cursors:\n            result.extend(self.formatCursor(c, size=100))\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef execute(self, conn, daoinput, transaction = False):\n        if not conn:\n\t    dbsExceptionHandler(\"dbsException-failed-connect2host\", \"Oracle/MigrationRequests/Remove. Expects db connection from upper layer.\",\n                                self.logger.exception)\n        daoinput['create_by'] = dbsUtils().getCreateBy()\n\ttry:\n            msg = \"DBSMigration: Invalid request. Sucessfully processed or processing requests cannot be removed,\\\n                    or the requested migration did not exist, or the requestor for removing and creating has to be the same user. \"\n            checkit = self.dbi.processData(self.select, daoinput, conn, transaction)\n            if self.formatDict(checkit)[0][\"count\"] >= 1:\n\t\treqID = {'migration_rqst_id':daoinput['migration_rqst_id']}\n\t        result = self.dbi.processData(self.sql, reqID, conn, transaction)\n            else:\n                dbsExceptionHandler('dbsException-invalid-input', msg, self.logger.exception)\n\texcept:\n            raise", "response": "Executes the SQL DELETE command."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef listDatasetAccessTypes(self, dataset_access_type=\"\"):\n        if isinstance(dataset_access_type, basestring):\n            try:\n                dataset_access_type = str(dataset_access_type)\n            except:    \n                dbsExceptionHandler('dbsException-invalid-input', 'dataset_access_type given is not valid : %s' %dataset_access_type)\n        else:\n            dbsExceptionHandler('dbsException-invalid-input', 'dataset_access_type given is not valid : %s' %dataset_access_type)\n        conn = self.dbi.connection()\n        try:\n            plist = self.datasetAccessType.execute(conn, dataset_access_type.upper())\n            result = [{}]\n            if plist:\n                t = []\n                for i in plist:\n                    for k, v in i.iteritems():\n                        t.append(v)\n                result[0]['dataset_access_type'] = t\n            return result\n        finally:\n            if conn:\n                conn.close()", "response": "List dataset access types."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef block_before(self):\n        # To avoid unnecessary database queries, ignore the IP check for\n        # requests for static files\n        if request.path.startswith(url_for('static', filename='')):\n            return\n\n        # Some static files might be served from the root path (e.g.\n        # favicon.ico, robots.txt, etc.). Ignore the IP check for most\n        # common extensions of those files.\n        ignored_extensions = ('ico', 'png', 'txt', 'xml')\n        if request.path.rsplit('.', 1)[-1] in ignored_extensions:\n            return\n\n        ips = request.headers.getlist('X-Forwarded-For')\n        if not ips:\n            return\n\n        # If the X-Forwarded-For header contains multiple comma-separated\n        # IP addresses, we're only interested in the last one.\n        ip = ips[0].strip()\n        if ip[-1] == ',':\n            ip = ip[:-1]\n        ip = ip.rsplit(',', 1)[-1].strip()\n\n        if self.matches_ip(ip):\n            if self.logger is not None:\n                self.logger.info(\"IPBlock: matched {}, {}\".format(ip, self.block_msg))\n            if self.blocking_enabled:\n                return 'IP Blocked', 200", "response": "Check the current request and block it if the IP address it s coming from is blacklisted."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns True if the given IP is blacklisted False otherwise.", "response": "def matches_ip(self, ip):\n        \"\"\"Return True if the given IP is blacklisted, False otherwise.\"\"\"\n\n        # Check the cache if caching is enabled\n        if self.cache is not None:\n            matches_ip = self.cache.get(ip)\n            if matches_ip is not None:\n                return matches_ip\n\n        # Query MongoDB to see if the IP is blacklisted\n        matches_ip = IPNetwork.matches_ip(\n            ip, read_preference=self.read_preference)\n\n        # Cache the result if caching is enabled\n        if self.cache is not None:\n            self.cache[ip] = matches_ip\n\n        return matches_ip"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef execute(self, conn, logical_file_name, block_name, block_id, transaction=False):\n        binds = {}\n        sql = ''\n\n        if logical_file_name:\n            if isinstance(logical_file_name, basestring):\n                wheresql = \"WHERE F.LOGICAL_FILE_NAME = :logical_file_name\"\n                binds = {\"logical_file_name\": logical_file_name}\n                sql = \"{sql} {wheresql}\".format(sql=self.sql, wheresql=wheresql)\n            elif isinstance(logical_file_name, list):\n                wheresql = \"WHERE F.LOGICAL_FILE_NAME in (SELECT TOKEN FROM TOKEN_GENERATOR)\"\n                lfn_generator, binds = create_token_generator(logical_file_name)\n                sql = \"{lfn_generator} {sql} {wheresql}\".format(lfn_generator=lfn_generator, sql=self.sql,\n                                                                wheresql=wheresql)\n        elif block_name:\n            joins = \"JOIN {owner}BLOCKS B on B.BLOCK_ID = F.BLOCK_ID\".format(owner=self.owner)\n            wheresql = \"WHERE B.BLOCK_NAME = :block_name\"\n            binds = {\"block_name\": block_name}\n            sql = \"{sql} {joins} {wheresql}\".format(sql=self.sql, joins=joins, wheresql=wheresql)\n        elif block_id:\n            wheresql = \"WHERE F.BLOCK_ID = :block_id\"\n            binds = {\"block_id\": block_id}\n            sql = \"{sql} {wheresql}\".format(sql=self.sql, wheresql=wheresql)\n        else:\n            dbsExceptionHandler('dbsException-invalid-input', \"Logical_file_names is required for listChild dao.\", self.logger.exception)\n\n        cursors = self.dbi.processData(sql, binds, conn, transaction=transaction, returnCursor=True)\n        result = []\n        for c in cursors:\n            result.extend(self.formatCursor(c, size=100))\n        return result", "response": "List all primary datasets of a given logical file name and block id."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef listAcquisitionEras(self, acq=''):\n        try:\n            acq = str(acq)\n        except:\n            dbsExceptionHandler('dbsException-invalid-input', 'acquistion_era_name given is not valid : %s' %acq)\n        conn = self.dbi.connection()\n        try:\n            result = self.acqlst.execute(conn, acq)\n            return result\n        finally:\n            if conn:conn.close()", "response": "List all acquistion eras in DBS."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nlisting all acquisition eras in DBS.", "response": "def listAcquisitionEras_CI(self, acq=''):\n        \"\"\"\n        Returns all acquistion eras in dbs\n        \"\"\"\n        try:\n            acq = str(acq)\n        except:\n            dbsExceptionHandler('dbsException-invalid-input', 'aquistion_era_name given is not valid : %s'%acq)\n        conn = self.dbi.connection()\n        try:\n            result = self.acqlst_ci.execute(conn, acq)\n            return result\n        finally:\n            if conn:conn.close()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef insertAcquisitionEra(self, businput):\n        conn = self.dbi.connection()\n        tran = conn.begin()\n        try:\n            businput[\"acquisition_era_id\"] = self.sm.increment(conn, \"SEQ_AQE\", tran)\n            businput[\"acquisition_era_name\"] = businput[\"acquisition_era_name\"]\n            #self.logger.warning(businput)\n            self.acqin.execute(conn, businput, tran)\n            tran.commit()\n            tran = None\n        except KeyError as ke:\n            dbsExceptionHandler('dbsException-invalid-input', \"Invalid input:\"+ke.args[0])\n        except Exception as ex:\n            if str(ex).lower().find(\"unique constraint\") != -1 or str(ex).lower().find(\"duplicate\") != -1:\n                dbsExceptionHandler('dbsException-invalid-input2', \"Invalid input: acquisition_era_name already exists in DB\",  serverError=\"%s\" %ex)\n            else:\n                raise\n        finally:\n            if tran:\n                tran.rollback()\n            if conn:\n                conn.close()", "response": "Insert a new acquisition era into DB."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef UpdateAcqEraEndDate(self, acquisition_era_name =\"\", end_date=0):\n        if acquisition_era_name ==\"\" or end_date==0:\n            dbsExceptionHandler('dbsException-invalid-input', \"acquisition_era_name and end_date are required\")\n        conn = self.dbi.connection()\n        tran = conn.begin()\n        try:\n            self.acqud.execute(conn, acquisition_era_name, end_date, tran)\n            if tran:tran.commit()\n            tran = None\n        finally:\n            if tran:tran.rollback()\n            if conn:conn.close()", "response": "Update the end date of a acquisitionera."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef execute(self, conn, app=\"\", release_version=\"\", pset_hash=\"\", output_label=\"\", \n                global_tag='', transaction = False):\n        \"\"\"\n        returns id for a given application\n        \"\"\"\n\tsql = self.sql\n        binds = {}\n\tsetAnd=False\n\tif not app == \"\":\n\t\tsql += \" A.APP_NAME=:app_name\"\n        \tbinds[\"app_name\"]=app\n\t\tsetAnd=True\n\tif not release_version == \"\":\n\t\tif setAnd : sql += \" AND \"\n\t\tsql += \" R.RELEASE_VERSION=:release_version\"\n\t\tbinds[\"release_version\"]=release_version\n\t\tsetAnd=True\n\tif not pset_hash == \"\":\n\t\tif setAnd : sql += \" AND \"\n\t\tsql += \" P.PSET_HASH=:pset_hash\"\n\t\tbinds[\"pset_hash\"]=pset_hash\n\t\tsetAnd=True\n\tif not output_label == \"\":\n\t\tif setAnd : sql += \" AND \"\n\t\tsql += \" O.OUTPUT_MODULE_LABEL=:output_module_label\"\n\t\tbinds[\"output_module_label\"]=output_label\n                setAnd=True\n        if not global_tag == \"\":\n                if setAnd : sql += \" AND \"\n                sql += \" O.GLOBAL_TAG=:global_tag\"\n                binds[\"global_tag\"]=global_tag\n\tif app == release_version == pset_hash  == global_tag == \"\":\n            dbsExceptionHandler('dbsException-invalid-input', \"%s Either app_name, release_version, pset_hash or global_tag must be provided\", self.logger.exception)\t\n\n        result = self.dbi.processData(sql, binds, conn, transaction)\n        plist = self.formatDict(result)\n\tif len(plist) < 1: return -1\n        return plist[0][\"output_mod_config_id\"]", "response": "returns the id of a given application and release version"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nprepare the ordered list of blocks from source dataset and the parent dataset.", "response": "def prepareDatasetMigrationList(self, conn, request):\n        \"\"\"\n        Prepare the ordered lists of blocks based on input DATASET (note Block is different)\n            1. Get list of blocks from source\n            2. Check and see if these blocks are already at DST\n            3. Check if dataset has parents\n            4. Check if parent blocks are already at DST\n\n        \"\"\"\n        ordered_dict = {}\n        order_counter = 0\n        srcdataset = request[\"migration_input\"]\n        url = request[\"migration_url\"]\n        try:\n            tmp_ordered_dict = self.processDatasetBlocks(url, conn,\n                                            srcdataset, order_counter)\n            if tmp_ordered_dict != {}:\n                ordered_dict.update(tmp_ordered_dict)\n\t\tself.logger.debug(\"ordered_dict length at level %s\" %order_counter)\n\t\tself.logger.debug(len(ordered_dict))\n            else:\n                #return {}\n                m = 'Requested dataset %s is already in destination' %srcdataset\n                dbsExceptionHandler('dbsException-invalid-input2', message=m, serverError=m)\n            # Now process the parent datasets\n            parent_ordered_dict = self.getParentDatasetsOrderedList(url, conn,\n                                                srcdataset, order_counter+1)\n            if parent_ordered_dict != {}:\n                ordered_dict.update(parent_ordered_dict)\n\t\tself.logger.debug(\"***** parent ordered_dict length at level %s ******\" %(order_counter+1))\n\t\tself.logger.debug(len(ordered_dict))\n            return remove_duplicated_items(ordered_dict)\n        except dbsException:\n            raise\n        except Exception as ex:\n            if 'urlopen error' in str(ex):\n                message='Connection to source DBS server refused. Check your source url.'\n            elif 'Bad Request' in str(ex):\n                message='cannot get data from the source DBS server. Check your migration input.'\n            else:\n                message='Failed to make a dataset migration list.'\n            dbsExceptionHandler('dbsException-invalid-input2', \\\n                serverError=\"\"\"DBSMigrate/prepareDatasetMigrationList failed\n                to prepare ordered block list: %s\"\"\" %str(ex), message=message)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef getParentDatasetsOrderedList(self, url, conn, dataset, order_counter):\n        ordered_dict = {}\n        parentSrcDatasets = self.getSrcDatasetParents(url, dataset)\n        if len(parentSrcDatasets) > 0:\n            parentSrcDatasetNames = [y['parent_dataset']\n                                        for y in parentSrcDatasets]\n            for aparentDataset in parentSrcDatasetNames:\n                parent_ordered_dict = self.processDatasetBlocks(url, conn,\n                                            aparentDataset, order_counter)\n\t\tself.logger.debug(\"************ dict length of parent blocks for the parent dataset %s at level %s\" %(aparentDataset, order_counter))\n\t\tself.logger.debug(len(parent_ordered_dict))\n                if parent_ordered_dict != {}:\n                    ordered_dict.update(parent_ordered_dict)\n\t\t    self.logger.debug(\"**** ordered_dict length ****\")\n\t\t    self.logger.debug(len(ordered_dict))\t\n                # parents of parent\n                pparent_ordered_dict = self.getParentDatasetsOrderedList(url,\n                                    conn, aparentDataset, order_counter+1)\n\t\tself.logger.debug(\"************dict length parent parent blocks for the parent dataset %s at level %s\" %(aparentDataset, order_counter+1))\n\t\tself.logger.debug(len(pparent_ordered_dict))\n                if pparent_ordered_dict != {}:\n                    ordered_dict.update(pparent_ordered_dict)\n\t            self.logger.debug(\"**** ordered_dict length ****\")\n\t\t    self.logger.debug(len(ordered_dict))\t\n        return ordered_dict", "response": "get the ordered list of all parent datasets"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nprepare the ordered list of blocks based on input BLOCKNUM", "response": "def prepareBlockMigrationList(self, conn, request):\n        \"\"\"\n        Prepare the ordered lists of blocks based on input BLOCK\n            1. see if block already exists at dst (no need to migrate),\n               raise \"ALREADY EXISTS\"\n            2. see if block exists at src & make sure the block's open_for_writing=0\n            3. see if block has parents\n            4. see if parent blocks are already at dst\n            5. add 'order' to parent and then this block (ascending)\n            6. return the ordered list\n        \"\"\"\n        ordered_dict = {}\n        block_name = request[\"migration_input\"]\n        url = request[\"migration_url\"]\n        order_counter = 0\n        try:\n            #1.\n            dstblock = self.blocklist.execute(conn, block_name=block_name)\n\t    for item in dstblock:\n\t\tif item:\n\t\t    dbsExceptionHandler('dbsException-invalid-input', 'ALREADY EXISTS: \\\n\t\t\tRequired block (%s) migration is already at destination' %block_name, self.logger.exception)\n            #2.\n            srcblock = self.getSrcBlocks(url, block=block_name)\n            if len(srcblock) < 1:\n                e = 'DBSMigration: Invalid input. Required Block %s not found at source %s.' %(block_name, url)\n                dbsExceptionHandler('dbsException-invalid-input2', e, self.logger.exception, e)\n            ##This block has to be migrated\n            ordered_dict[order_counter] = []\n            ordered_dict[order_counter].append(block_name)\n            parent_ordered_dict = self.getParentBlocksOrderedList(url, conn,\n                                                block_name, order_counter+1)\n            if parent_ordered_dict != {}:\n                ordered_dict.update(parent_ordered_dict)\n            #6.\n            #check for duplicates\n\n            return remove_duplicated_items(ordered_dict)\n        except Exception as ex:\n\t    if '500 Internal Server Error' in str(ex):\t\n\t\t#\"Server Error\" is the default in dbsExceptionHandler\n\t        dbsExceptionHandler('Server Error', str(ex), self.logger.exception, \"DBSMigrate/prepareBlockMigrationList: \"+str(ex))\n\t    if isinstance(ex, pycurl.error):\n\t\tif ex.args[0] == 7:\n\t\t    message = ex.args[1]\n\t\t    dbsExceptionHandler('dbsException-failed-connect2host', message, self.logger.exception, message)\t\n\t    if 'urlopen error' in str(ex):\n                message='Connection to source DBS server refused. Check your source url.'\n            elif 'Bad Request' in str(ex):\n                message='cannot get data from the source DBS server. Check your migration input.'\n            else:\n                message='Failed to make a block migration list.'\n            dbsExceptionHandler('dbsException-invalid-input2', \\\n                \"\"\"DBSMigrate/prepareBlockMigrationList failed\n                to prepare ordered block list: %s\"\"\" %str(ex), self.logger.exception, message)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef removeMigrationRequest(self, migration_rqst):\n        conn = self.dbi.connection()\n        try:\n            tran = conn.begin()\n            self.mgrremove.execute(conn, migration_rqst)\n            tran.commit()\n        except dbsException as he:\n            if conn: conn.close()\n            raise\n        except Exception as ex:\n            if conn: conn.close()\n            raise\n        if conn: conn.close()", "response": "Method to remove pending or failed migration request from the queue."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef insertMigrationRequest(self, request):\n        conn = self.dbi.connection()\n        # check if already queued.\n        #If the migration_input is the same, but the src url is different,\n        #We will consider it as a submitted request. YG 05-18-2012\n        try:\n            alreadyqueued = self.mgrlist.execute(conn,\n                                                 migration_input=request[\"migration_input\"])\n            is_already_queued = len(alreadyqueued) > 0\n            # close connection before returning json object\n            if is_already_queued and conn:\n                conn.close()\n            #if the queued is not failed, then we don't need to do it again.\n            #add a new migration_status=9 (terminal failure)\n\t    if is_already_queued and alreadyqueued[0]['migration_status'] == 2:\n                return {\"migration_report\" : \"REQUEST ALREADY QUEUED. Migration is finished\",\n                        \"migration_details\" : alreadyqueued[0] }\n            elif is_already_queued and alreadyqueued[0]['migration_status'] != 9:\n                return {\"migration_report\" : \"REQUEST ALREADY QUEUED. Migration in progress\",\n                        \"migration_details\" : alreadyqueued[0] }\n            elif is_already_queued and alreadyqueued[0]['migration_status'] == 9:\n                return {\"migration_report\" : \"REQUEST ALREADY QUEUED. Migration terminally failed. \",\n                        \"migration_details\" : alreadyqueued[0] }\n            else:\n                # not already queued\n                #Determine if its a dataset or block migration\n                #The prepare list calls will check if the requested blocks/dataset already in destination.\n                if request[\"migration_input\"].find(\"#\") != -1:\n                    ordered_list = self.prepareBlockMigrationList(conn, request)\n                else:\n                    ordered_list = self.prepareDatasetMigrationList(conn, request)\n            # now we have the blocks that need to be queued (ordered)\n        except Exception as ex:\n            if conn: conn.close()\n            raise\n\n        tran = conn.begin()\n        try:\n            # insert the request\n            #request.update(migration_status=0)\n            request['migration_request_id'] = self.sm.increment(conn, \"SEQ_MR\", tran)\n            self.mgrin.execute(conn, request, tran)\n            # INSERT the ordered_list\n            totalQueued = 0\n\t    k = ordered_list.keys()\n\t    k.sort()\n\t    k.reverse()\t\n\t    self.logger.debug(\"****************** ordered_list keys **********\")\n            self.logger.debug(k)\n            #for iter in reversed(range(len(ordered_list))):\n\t    for iter in k:\t\n\t\tself.logger.debug(\"length for Key: %s\" %iter)\n\t        self.logger.debug(len(ordered_list[iter]))\t\n                if len(ordered_list[iter]) > 0:\n                    daoinput = [{\n                        \"migration_block_id\" :\n                            self.sm.increment(conn, \"SEQ_MB\", tran),\n                        \"migration_request_id\" :\n                            request[\"migration_request_id\"],\n                        \"migration_block_name\" : blk,\n                        \"migration_order\" : iter,\n                        \"migration_status\" : 0,\n                        \"creation_date\" : request['creation_date'],\n                        \"last_modification_date\" : request['last_modification_date'],\n                        \"create_by\" : request['create_by'],\n                        \"last_modified_by\" : request['last_modified_by']\n                        }\n                             for blk in ordered_list[iter]]\n                    self.mgrblkin.execute(conn, daoinput, tran)\n                    totalQueued += len(ordered_list[iter])\n            # all good ?, commit the transaction\n            tran.commit()\n            if conn: conn.close()\n            # return things like (X blocks queued for migration)\n            return {\n                \"migration_report\" : \"REQUEST QUEUED with total %d blocks to be migrated\" %totalQueued,\n                \"migration_details\" : request }\n        except SQLAlchemyIntegrityError as ex:\n\t    e = \"DBSMigration:  ENQUEUEING_FAILED1 from SQLAichemy Integrity Error. Reason may be (%s)\" %(ex.statement + \"; \" + str(ex.params) + \"; \" + str(ex.orig))\n\t    self.logger.debug(e)\t\t\n\t    import traceback\n            tk = traceback.format_exc() \t\t\n\t    self.logger.debug(tk) \t\n            tran.rollback()\n            if conn: conn.close()\n            if (str(ex).find(\"unique constraint\") != -1 or\n                str(ex).lower().find(\"duplicate\") != -1):\n                #FIXME: Need to check which unique key. YG 2/11/13\n                #The unique constraints are: MIGRATION_REQUESTS(MIGRATION_INPUT)\n                #MIGRATION_BLOCKS(MIGRATION_BLOCK_NAME, MIGRATION_REQUEST_ID)\n                return {\n                    \"migration_report\" : \"REQUEST ALREADY QUEUED\",\n                    \"migration_details\" : request }\n            else:\n                if conn: conn.close()\n\t\tself.logger.error(tk)\n                m = \"DBSMigration:  ENQUEUEING_FAILED1.\"\n                dbsExceptionHandler('dbsException-invalid-input2', m, self.logger.exception, e)\n\texcept HTTPError as he:\n\t    raise he\t\n        except Exception as ex:\n\t    import traceback\n            self.logger.error(traceback.format_exc())\t\n            if tran: tran.rollback()\n            if conn: conn.close()\n            m = \"DBSMigration:  ENQUEUEING_FAILED.\"\n            e = \"DBSMigration:  ENQUEUEING_FAILED. General exception caught: Reason may be (%s)\" %str(ex)\n            dbsExceptionHandler('dbsException-invalid-input2', m, self.logger.exception, e)\n        finally:\n            if conn: conn.close()", "response": "Method to insert a migration request into the MIGRATION_REQUESTS table."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nlists the status of the migration request", "response": "def listMigrationRequests(self, migration_request_id=\"\", block_name=\"\",\n                              dataset=\"\", user=\"\", oldest=False):\n        \"\"\"\n        get the status of the migration\n        migratee : can be dataset or block_name\n        \"\"\"\n\n        conn = self.dbi.connection()\n        migratee = \"\"\n        try:\n            if block_name:\n                migratee = block_name\n            elif dataset:\n                migratee = dataset\n            result = self.mgrlist.execute(conn, migration_url=\"\",\n                    migration_input=migratee, create_by=user,\n                    migration_request_id=migration_request_id, oldest=oldest)\n            return result\n\n        finally:\n            if conn: conn.close()"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nlists all migration blocks", "response": "def listMigrationBlocks(self, migration_request_id=\"\"):\n        \"\"\"\n        get eveything of block that is has status = 0 and migration_request_id as specified.\n        \"\"\"\n\n        conn = self.dbi.connection()\n        try:\n            return self.mgrblklist.execute(conn, migration_request_id=migration_request_id)\n        finally:\n            if conn: conn.close()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nupdating the status of a migration request.", "response": "def updateMigrationRequestStatus(self, migration_status, migration_request_id):\n        \"\"\"\n        migration_status:\n        0=PENDING\n        1=IN PROGRESS\n        2=COMPLETED\n        3=FAILED (will be retried)\n        9=Terminally FAILED \n        status change:\n        0 -> 1\n        1 -> 2\n        1 -> 3\n        1 -> 9\n        are only allowed changes for working through migration.\n        3 -> 1 is allowed for retrying and retry count +1.\n\n        \"\"\"\n\n        conn = self.dbi.connection()\n        tran = conn.begin()\n        try:\n            upst = dict(migration_status=migration_status,\n                        migration_request_id=migration_request_id,\n                        last_modification_date=dbsUtils().getTime())\n            self.mgrRqUp.execute(conn, upst)\n        except:\n            if tran:tran.rollback()\n            raise\n        else:\n            if tran:tran.commit()\n        finally:\n            #open transaction is committed when conn closed.\n            if conn:conn.close()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef updateMigrationBlockStatus(self, migration_status=0, migration_block=None, migration_request=None):\n\n        conn = self.dbi.connection()\n        tran = conn.begin()\n        try:\n            if migration_block:\n                upst = dict(migration_status=migration_status,\n                        migration_block_id=migration_block, last_modification_date=dbsUtils().getTime())\n            elif migration_request:\n                upst = dict(migration_status=migration_status, migration_request_id=migration_request,\n                            last_modification_date=dbsUtils().getTime())\n            self.mgrup.execute(conn, upst)\n        except:\n            if tran:tran.rollback()\n            raise\n        else:\n            if tran:tran.commit()\n        finally:\n            if conn:conn.close()", "response": "Update the status of a migration block."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef getSrcDatasetParents(self, url, dataset):\n        #resturl = \"%s/datasetparents?dataset=%s\" % (url, dataset)\n        params={'dataset':dataset}\n        return cjson.decode(self.callDBSService(url, 'datasetparents', params, {}))", "response": "Get list of parents of a dataset at a given URL"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the parents of a block at a given URL.", "response": "def getSrcBlockParents(self, url, block):\n        \"\"\"\n        List block at src DBS\n        \"\"\"\n        #blockname = block.replace(\"#\", urllib.quote_plus('#'))\n        #resturl = \"%s/blockparents?block_name=%s\" % (url, blockname)\n        params={'block_name':block}\n        return cjson.decode(self.callDBSService(url, 'blockparents', params, {}))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget all source blocks from a dataset", "response": "def getSrcBlocks(self, url, dataset=\"\", block=\"\"):\n        \"\"\"\n        Need to list all blocks of the dataset and its parents starting from the top\n        For now just list the blocks from this dataset.\n        Client type call...\n        \"\"\"\n        if block:\n            params={'block_name':block, 'open_for_writing':0}\n        elif dataset:\n            params={'dataset':dataset, 'open_for_writing':0}\n        else:\n            m = 'DBSMigration: Invalid input.  Either block or dataset name has to be provided'\n            e = 'DBSMigrate/getSrcBlocks: Invalid input.  Either block or dataset name has to be provided'\n            dbsExceptionHandler('dbsException-invalid-input2', m, self.logger.exception, e )\n\n        return cjson.decode(self.callDBSService(url, 'blocks', params, {}))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nbuild dynamic sql based on daoinput", "response": "def executeSingle( self, conn, daoinput, tablename, transaction = False):\t\t\t\n\t\"\"\"build dynamic sql based on daoinput\"\"\"\n\tsql1 = \" insert into %s%s( \" %(self.owner, tablename)\n\tsql2 =\" values(\"\n\t\"Now loop over all the input keys. We need to check if all the keys are valid !!!\"\n        for key in daoinput:\n            sql1 += \"%s,\" %key.upper()\n            sql2 += \":%s,\" %key.lower()\n        \n        sql = sql1.strip(',') + ') ' + sql2.strip(',') + ' )'\n\n        self.dbi.processData(sql, daoinput, conn, transaction)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the value for the option or default if not defined.", "response": "def get(self, option, default=undefined, cast=undefined):\n        \"\"\"\n        Return the value for option or default if defined.\n        \"\"\"\n        if option in self.repository:\n            value = self.repository.get(option)\n        else:\n            value = default\n\n        if isinstance(value, Undefined):\n            raise UndefinedValueError('%s option not found and default value was not defined.' % option)\n\n        if isinstance(cast, Undefined):\n            cast = lambda v: v  # nop\n        elif cast is bool:\n            cast = self._cast_boolean\n\n        return cast(value)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nparsing a requirements file and return a list of the install_requires components", "response": "def parse_requirements(requirements_file):\n    \"\"\"\n      Create a list for the 'install_requires' component of the setup function\n      by parsing a requirements file\n    \"\"\"\n\n    if os.path.exists(requirements_file):\n        # return a list that contains each line of the requirements file\n        return open(requirements_file, 'r').read().splitlines()\n    else:\n        print(\"ERROR: requirements file \" + requirements_file + \" not found.\")\n        sys.exit(1)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nexecute the SQL query.", "response": "def execute(self, conn, dataset=\"\", block_name=\"\", data_tier_name=\"\", origin_site_name=\"\", logical_file_name=\"\",\n                run_num=-1, min_cdate=0, max_cdate=0, min_ldate=0, max_ldate=0, cdate=0,\n                ldate=0, open_for_writing=-1, transaction = False):\n        \"\"\"\n        dataset: /a/b/c\n        block: /a/b/c#d\n        \"\"\"\n        binds = {}\n\n        basesql = self.sql\n        joinsql = \"\"\n        wheresql = \"\"\n        generatedsql = \"\"\n\n        if logical_file_name and logical_file_name != \"%\":\n            joinsql +=  \" JOIN %sFILES FL ON FL.BLOCK_ID = B.BLOCK_ID \" %(self.owner)\n            op =  (\"=\", \"like\")[\"%\" in logical_file_name]\n            wheresql +=  \" WHERE LOGICAL_FILE_NAME %s :logical_file_name \" % op\n            binds.update( logical_file_name = logical_file_name )\n\n        if  block_name and  block_name !=\"%\":\n            andorwhere = (\"WHERE\", \"AND\")[bool(wheresql)]\n            op =  (\"=\", \"like\")[\"%\" in block_name]\n            wheresql +=  \" %s B.BLOCK_NAME %s :block_name \" % ((andorwhere, op))\n            binds.update( block_name = block_name )\n\n        if data_tier_name or (dataset and dataset!=\"%\"):\n            joinsql += \"JOIN %sDATASETS DS ON DS.DATASET_ID = B.DATASET_ID \"  % (self.owner)\n            andorwhere = (\"WHERE\", \"AND\")[bool(wheresql)]\n            if dataset:\n                op = (\"=\", \"like\")[\"%\" in dataset]\n                wheresql += \" %s DS.DATASET %s :dataset \" % ((andorwhere, op))\n                binds.update(dataset=dataset)\n            if data_tier_name:\n                joinsql += \"JOIN {owner}DATA_TIERS DT ON DS.DATA_TIER_ID=DT.DATA_TIER_ID \".format(owner=self.owner)\n                wheresql += \" %s DT.DATA_TIER_NAME=:data_tier_name \" % (andorwhere)\n                binds.update(data_tier_name=data_tier_name)\n\n        if origin_site_name and  origin_site_name != \"%\":\n            op = (\"=\", \"like\")[\"%\" in origin_site_name]\n            wheresql += \" AND B.ORIGIN_SITE_NAME %s :origin_site_name \" % op\n            binds.update(origin_site_name = origin_site_name)\n\n        if open_for_writing == 0 or open_for_writing == 1:\n            wheresql += \" AND B.OPEN_FOR_WRITTING = :open_for_writing \"\n\n        if cdate != 0:\n            wheresql += \"AND B.CREATION_DATE = :cdate \"\n            binds.update(cdate = cdate)\n        elif min_cdate != 0 and max_cdate != 0:\n            wheresql += \"AND B.CREATION_DATE BETWEEN :min_cdate and :max_cdate \"\n            binds.update(min_cdate = min_cdate)\n            binds.update(max_cdate = max_cdate)\n        elif min_cdate != 0 and max_cdate == 0:\n            wheresql += \"AND B.CREATION_DATE > :min_cdate \"\n            binds.update(min_cdate = min_cdate)\n        elif min_cdate ==0 and max_cdate != 0:\n            wheresql += \"AND B.CREATION_DATE < :max_cdate \"\n            binds.update(max_cdate = max_cdate)\n        else:\n            pass\n        if ldate != 0:\n            wheresql += \"AND B.LAST_MODIFICATION_DATE = :ldate \"\n            binds.update(ldate = ldate)\n        elif min_ldate != 0 and max_ldate != 0:\n            wheresql += \"AND B.LAST_MODIFICATION_DATE BETWEEN :min_ldate and :max_ldate \"\n            binds.update(min_ldate = min_ldate)\n            binds.update(max_ldate = max_ldate)\n        elif min_ldate != 0 and max_ldate == 0:\n            wheresql += \"AND B.LAST_MODIFICATION_DATE > :min_ldate \"\n            binds.update(min_ldate = min_ldate)\n        elif min_cdate ==0 and max_cdate != 0:\n            wheresql += \"AND B.LAST_MODIFICATION_DATE < :max_ldate \"\n            binds.update(max_ldate = max_ldate)\n        else:\n            pass\n\n        #one may provide a list of runs , so it has to be the last one in building the bind.\n        if run_num !=-1 :\n            basesql = basesql.replace(\"SELECT\", \"SELECT DISTINCT\") + \" , FLM.RUN_NUM  \"\n            if not logical_file_name:\n                joinsql +=  \" JOIN %sFILES FL ON FL.BLOCK_ID = B.BLOCK_ID \" %(self.owner)\n            joinsql += \" JOIN %sFILE_LUMIS FLM on FLM.FILE_ID = FL.FILE_ID \" %(self.owner)\n            run_list=[]\n            wheresql_run_list=''\n            wheresql_run_range=''\n            #\n            for r in parseRunRange(run_num):\n                if isinstance(r, basestring) or isinstance(r, int) or isinstance(r, long):\n                    run_list.append(str(r))\n                if isinstance(r, run_tuple):\n                    if r[0] == r[1]:\n                        dbsExceptionHandler('dbsException-invalid-input', \"DBS run_num range must be apart at least by 1.\", self.logger.exception)\n                    wheresql_run_range = \" FLM.RUN_NUM between :minrun and :maxrun \"\n                    binds.update({\"minrun\":r[0]})\n                    binds.update({\"maxrun\":r[1]})\n            #\n            if run_list:\n                wheresql_run_list = \" FLM.RUN_NUM in (SELECT TOKEN FROM TOKEN_GENERATOR) \"\n                generatedsql, run_binds = create_token_generator(run_list)\n                binds.update(run_binds)\n            #  \n            if wheresql_run_range and wheresql_run_list:\n                wheresql += \" and (\" + wheresql_run_range + \" or \" +  wheresql_run_list + \" )\"\n            elif wheresql_run_range and not wheresql_run_list:\n                wheresql +=  \" and \" + wheresql_run_range\n            elif not wheresql_run_range and wheresql_run_list:\n                wheresql += \" and \"  + wheresql_run_list\n        #\n        sql = \" \".join((generatedsql, basesql, self.fromsql, joinsql, wheresql))\n\n        cursors = self.dbi.processData(sql, binds, conn, transaction, returnCursor=True)\n        for i in cursors:\n            d = self.formatCursor(i, size=100)\n            if isinstance(d, list) or isinstance(d, GeneratorType):\n                for elem in d:\n                    yield elem\n            elif d:\n                yield d"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef execute(self, conn, dsType = \"\", dataset=\"\", transaction = False):\n        sql = self.sql\n        binds={}\n        if not dsType  and not dataset:\n            pass\n        elif dsType and dataset in (\"\", None, '%'):\n            op = (\"=\", \"like\")[\"%\" in dsType]\n            sql += \"WHERE PDT.PRIMARY_DS_TYPE %s :primdstype\"%op \n            binds = {\"primdstype\":dsType}\n\telif dataset and dsType in (\"\", None, '%'):\n\t    op = (\"=\", \"like\")[\"%\" in dataset]\n\t    sql += \"JOIN %sPRIMARY_DATASETS PDS on PDS.PRIMARY_DS_TYPE_ID = PDT.PRIMARY_DS_TYPE_ID \\\n\t            JOIN %sDATASETS DS ON DS.PRIMARY_DS_ID = PDS.PRIMARY_DS_ID \\\n\t            WHERE DS.DATASET %s :dataset\"  %(self.owner, self.owner, op)\n\t    binds={\"dataset\":dataset}\n        elif dataset and dsType:\n            op = (\"=\", \"like\")[\"%\" in dsType]\n            op1 = (\"=\", \"like\")[\"%\" in dataset]\n            sql += \"JOIN %sPRIMARY_DATASETS PDS on PDS.PRIMARY_DS_TYPE_ID = PDT.PRIMARY_DS_TYPE_ID \\\n                    JOIN %sDATASETS DS ON DS.PRIMARY_DS_ID = PDS.PRIMARY_DS_ID \\\n                    WHERE DS.DATASET %s :dataset and PDT.PRIMARY_DS_TYPE %s :primdstype\" \\\n                    %(self.owner, self.owner, op1, op)\n            binds = {\"primdstype\":dsType, \"dataset\":dataset}\n\telse:\n\t    dbsExceptionHandler('dbsException-invalid-input', \"DAO Primary_DS_TYPE List accepts no input, or\\\n            dataset,primary_ds_type as input.\", self.logger.exception)\n        cursors = self.dbi.processData(sql, binds, conn, transaction, returnCursor=True)\n        result = []\n        for c in cursors:\n            result.extend(self.formatCursor(c, size=100))\n        return result", "response": "List all primary dataset types."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nexecuting a single query for the application", "response": "def execute(self, conn, dataset=\"\",  logical_file_name=\"\", app=\"\", release_version=\"\", pset_hash=\"\", \n                output_label =\"\", block_id=0, global_tag='', transaction = False):\n        \"\"\"\n        returns id for a given application\n        \"\"\"\n\t#sql=self.sql\t\n        binds = {}\n\tsetAnd=False\n\t#add search only block id only for migration dump block. \n\tif block_id==0:\n\t    sql = self.sql1 + self.sql2\n\t    if dataset:\n\t\tsql += \" JOIN %sDATASET_OUTPUT_MOD_CONFIGS DC ON DC.OUTPUT_MOD_CONFIG_ID=O.OUTPUT_MOD_CONFIG_ID\" % self.owner\n\t\tsql += \" JOIN %sDATASETS DS ON DS.DATASET_ID=DC.DATASET_ID\" % self.owner\n\t    if logical_file_name:\n\t\tsql += \" JOIN %sFILE_OUTPUT_MOD_CONFIGS FC ON FC.OUTPUT_MOD_CONFIG_ID=O.OUTPUT_MOD_CONFIG_ID\" % self.owner\n\t\tsql += \" JOIN %sFILES FS ON FS.FILE_ID=FC.FILE_ID\" % self.owner\n\t    if not app == \"\":\n\t\top = (\"=\", \"like\")[\"%\" in app]\n\t\tsql += \" WHERE A.APP_NAME %s :app_name\" % op\n        \tbinds[\"app_name\"]=app\n\t\tsetAnd=True\n\t    if not release_version == \"\":\n\t\top = (\"=\", \"like\")[\"%\" in release_version]\n\t\tif setAnd : sql += \" AND \" \n\t\telse : sql += \" WHERE \"\n\t\tsql += \" R.RELEASE_VERSION %s :release_version\" % op\n\t\tbinds[\"release_version\"]=release_version\n\t\tsetAnd=True\n\t    if not pset_hash == \"\":\n\t\top = (\"=\", \"like\")[\"%\" in pset_hash]\n\t\tif setAnd : sql += \" AND \"\n\t\telse : sql += \" WHERE \"\n\t\tsql += \" P.PSET_HASH %s :pset_hash\" % op\n\t\tbinds[\"pset_hash\"]=pset_hash\n\t\tsetAnd=True\n\t    if not output_label == \"\":\n\t\top = (\"=\", \"like\")[\"%\" in output_label]\n                if setAnd : sql += \" AND \"\n\t\telse : sql += \" WHERE \"\n\t        sql += \" O.OUTPUT_MODULE_LABEL %s :output_module_label\" % op\n\t        binds[\"output_module_label\"]=output_label\n\t\tsetAnd=True\n            if not global_tag == \"\":\n                op = (\"=\", \"like\")[\"%\" in global_tag]\n                if setAnd : sql += \" AND \"\n                else : sql += \" WHERE \"\n                sql += \" O.GLOBAL_TAG %s :global_tag\" % op\n                binds[\"global_tag\"]=global_tag\n                setAnd=True\n\t    if dataset:\n\t\tif setAnd : sql += \" AND \"\n\t\telse : sql += \" WHERE \"\n\t\tsql += \"DS.DATASET=:dataset\"\n\t\tbinds[\"dataset\"]=dataset\n\t\tsetAnd=True\n\t    if logical_file_name:\n\t\tif setAnd : sql += \" AND \"\n\t\telse : sql += \" WHERE \"\n\t\tsql += \"FS.LOGICAL_FILE_NAME=:logical_file_name\"\n\t\tbinds[\"logical_file_name\"]=logical_file_name\n\t\tsetAnd=True\n\telse:\n\t    #select by block id and return config along with LFN\n\t    sql=  self.sql1 + \" , FS.LOGICAL_FILE_NAME LFN \" +  self.sql2 \\\n\t          + \" JOIN %sFILE_OUTPUT_MOD_CONFIGS FC ON FC.OUTPUT_MOD_CONFIG_ID=O.OUTPUT_MOD_CONFIG_ID\" % self.owner \\\n\t\t  +  \" JOIN %sFILES FS ON FS.FILE_ID=FC.FILE_ID\" % self.owner \\\n\t\t  +  \"  WHERE FS.BLOCK_ID = :block_id \"\n\t    binds[\"block_id\"]=block_id\n\tcursors = self.dbi.processData(sql, binds, conn, transaction=False, returnCursor=True)\n\t#assert len(cursors) == 1, \"output module config does not exist\"\n        result = []\n\tfor c in cursors:\n            result.extend(self.formatCursor(c, size=100))\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef execute(self, conn, block_name=\"\", transaction = False):\n        if not conn:\n            msg='Oracle/BlockParent/List. No DB connection found'\n            dbsExceptionHandler('dbsException-failed-connect2host', msg, self.logger.exception)\n\n        sql = self.sql\n        binds = {}\n\tif block_name:\n\t    binds.update(block_name = block_name)\n        else:\n            dbsExceptionHandler(\"dbsException-invalid-input\", \"Oracle/BlockParent/ListChild. block_name must be provided.\", self.logger.exception)\n\n\tcursors = self.dbi.processData(sql, binds, conn, transaction, returnCursor=True)\n        result = []\n        for c in cursors:\n            result.extend(self.formatCursor(c, size=100))\n        return result", "response": "List all the related entries in a specific block."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nrequires parameter: full block_name or dataset name. No wildcards allowed. run_num is optional.", "response": "def listFileSummary(self, block_name=\"\", dataset=\"\", run_num=-1, validFileOnly=0, sumOverLumi=0):\n        \"\"\"\n        required parameter: full block_name or dataset name. No wildcards allowed. run_num is optional.\n        \"\"\"\n        if not block_name and not dataset:\n            msg =  \"Block_name or dataset is required for listFileSummary API\"\n            dbsExceptionHandler('dbsException-invalid-input', msg, self.logger.exception)\n        if '%' in block_name or '*' in block_name or '%' in dataset or '*' in dataset:\n            msg = \"No wildcard is allowed in block_name or dataset for filesummaries API\"\n            dbsExceptionHandler('dbsException-invalid-input', msg, self.logger.exception)\n        #\n        with self.dbi.connection() as conn:\n            for item in self.filesummarylist.execute(conn, block_name, dataset, run_num,\n                validFileOnly=validFileOnly, sumOverLumi=sumOverLumi):\n                if item['num_file']==0 and item['num_block']==0 \\\n                        and item['num_event']==0 and item['file_size']==0:\n                    pass\n                else:\n                    yield item"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nlists all file parents of a given logical file", "response": "def listFileParents(self, logical_file_name=\"\", block_id=0, block_name=\"\"):\n        \"\"\"\n        required parameter: logical_file_name or block_name\n        returns: this_logical_file_name, parent_logical_file_name, parent_file_id\n        \"\"\"\n        #self.logger.debug(\"lfn %s, block_name %s, block_id :%s\" % (logical_file_name, block_name, block_id))\n        if not logical_file_name and not block_name and not block_id:\n            dbsExceptionHandler('dbsException-invalid-input', \\\n                \"Logical_file_name, block_id or block_name is required for fileparents api\", self.logger.exception )\n        with self.dbi.connection() as conn:\n            sqlresult = self.fileparentlist.execute(conn, logical_file_name, block_id, block_name)\n            d = {}\n            #self.logger.debug(sqlresult)\n            for i in sqlresult:\n                k = i['this_logical_file_name']\n                v = i['parent_logical_file_name']\n                d.setdefault(k, []).append(v)\n            for k, v in d.iteritems():\n                yield {'logical_file_name':k, 'parent_logical_file_name': v}\n            del d"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef listFileParentsByLumi(self, block_name='', logical_file_name=[]):\n        #self.logger.debug(\"lfn %s, block_name %s\" % (logical_file_name, block_name))\n        if not block_name:\n            dbsExceptionHandler('dbsException-invalid-input', \\\n                \"Child block_name is required for fileparents/listFileParentsByLumi api\", self.logger.exception )\n        with self.dbi.connection() as conn:\n            sqlresult = self.fileparentbylumi.execute(conn, block_name, logical_file_name)\n            return [{\"child_parent_id_list\":sqlresult}]", "response": "List all child parent IDs of a file."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef listFileChildren(self, logical_file_name='', block_name='', block_id=0):\n        conn = self.dbi.connection()\n        try:\n            if not logical_file_name and not block_name and not block_id:\n                dbsExceptionHandler('dbsException-invalid-input',\\\n                        \"Logical_file_name, block_id or block_name is required for listFileChildren api\")\n            sqlresult = self.filechildlist.execute(conn, logical_file_name, block_name, block_id)\n            d = {}\n            result = []\n            for i in range(len(sqlresult)):\n                k = sqlresult[i]['logical_file_name']\n                v = sqlresult[i]['child_logical_file_name']\n                if k in d:\n                    d[k].append(v)\n                else:\n                    d[k] = [v]\n            for k, v in d.iteritems():\n                r = {'logical_file_name':k, 'child_logical_file_name': v}\n                result.append(r)\n            return result\n        finally:\n            if conn:\n                conn.close()", "response": "List all file children of a file."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef updateStatus(self, logical_file_name, is_file_valid, lost, dataset):\n\n        conn = self.dbi.connection()\n        trans = conn.begin()\n        try :\n            self.updatestatus.execute(conn, logical_file_name, is_file_valid, lost, dataset, trans)\n            trans.commit()\n            trans = None\n        except Exception as ex:\n            if trans:\n                trans.rollback()\n                trans = None\n            raise ex\n\n        finally:\n            if trans:\n                trans.rollback()\n            if conn:\n                conn.close()", "response": "Update the status of a file in the database."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef listFiles(self, dataset=\"\", block_name=\"\", logical_file_name=\"\",\n                  release_version=\"\", pset_hash=\"\", app_name=\"\",\n                  output_module_label=\"\",  run_num=-1,\n                  origin_site_name=\"\", lumi_list=[], detail=False, validFileOnly=0, sumOverLumi=0, input_body=-1):\n        \"\"\"\n        One of below parameter groups must be present:\n        non-patterned dataset, non-patterned block, non-patterned dataset with lfn,  non-patterned block with lfn,\n        non-patterned lfn\n\tnon-patterned lfn list\n        \"\"\"\n        if input_body != -1 :\n\t    try:\n                logical_file_name = input_body.get(\"logical_file_name\", \"\")\n                run_num = input_body.get(\"run_num\", -1)\n                validFileOnly = input_body.get(\"validFileOnly\", 0)\n                sumOverLumi = input_body.get(\"sumOverLumi\", 0)  \n\t\tdetail = input_body.get(\"detail\", False)\n                block_name = input_body.get(\"block_name\", \"\")\n\t\tdataset = input_body.get(\"dataset\", \"\") \n\t\trelease_version = input_body.get(\"release_version\", \"\")\n\t\tpset_hash = input_body.get(\"pset_hash\", \"\")\n\t        app_name = input_body.get(\"app_name\", \"\")\n\t\toutput_module_label = input_body.get(\"output_module_label\", \"\")\n\t\torigin_site_name = input_body.get(\"origin_site_name\", \"\")\n\t\tlumi_list = input_body.get(\"lumi_list\", [])\t\n            except cjson.DecodeError as de:\n                msg = \"business/listFilss POST call requires at least dataset, block_name, or a list of logical_file_name %s\" % de\n                dbsExceptionHandler('dbsException-invalid-input', \"Invalid input\", self.logger.exception, msg)\n\n        if ('%' in block_name):\n            dbsExceptionHandler('dbsException-invalid-input', \"You must specify exact block name not a pattern\", self.logger.exception)\n        elif ('%' in dataset):\n\t    print(\"***** in dataset name\")\n            dbsExceptionHandler('dbsException-invalid-input', \" You must specify exact dataset name not a pattern\", self.logger.exception)\n        elif (not dataset  and not block_name and (not logical_file_name or '%'in logical_file_name) ):\n            dbsExceptionHandler('dbsException-invalid-input', \"\"\"You must specify one of the parameter groups:  \\\n                    non-pattern dataset, \\\n                    non-pattern block , non-pattern dataset with lfn ,\\\n                    non-pattern block with lfn or no-pattern lfn, \\\n\t\t    non-patterned lfn list .\"\"\", self.logger.exception)\n        elif (lumi_list and len(lumi_list) != 0):\n            if run_num==-1:\n                dbsExceptionHandler('dbsException-invalid-input', \"Lumi list must accompany A single run number, \\\n                        use run_num=123\", self.logger.exception)\n            elif isinstance(run_num, basestring):\n                try:\n                    run_num = int(run_num)\n                except:\n                    dbsExceptionHandler('dbsException-invalid-input', \"Lumi list must accompany A single run number,\\\n                        use run_num=123\", self.logger.exception)\n            elif isinstance(run_num, list):\n                if len(run_num) == 1:\n                    try:\n                        run_num = int(run_num[0])\n                    except:\n                        dbsExceptionHandler('dbsException-invalid-input', \"Lumi list must accompany A single run number,\\\n                            use run_num=123\", self.logger.exception)\n                else:\n                    dbsExceptionHandler('dbsException-invalid-input', \"Lumi list must accompany A single run number,\\\n                        use run_num=123\", self.logger.exception)\n\telse:\n            pass\n        with self.dbi.connection() as conn:\n            dao = (self.filebrieflist, self.filelist)[detail]\n            for item in dao.execute(conn, dataset, block_name, logical_file_name, release_version, pset_hash, app_name,\n                            output_module_label, run_num, origin_site_name, lumi_list, validFileOnly, sumOverLumi):\n\n                yield item      # we need to yield while connection is open", "response": "This method returns a list of files in a dataset."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef insertFile(self, businput, qInserts=False):\n\n        # We do not want to go be beyond 10 files at a time\n        # If user wants to insert over 10 files in one shot, we run into risks of locking the database\n        # tables for longer time, and in case of error, it will be hard to see where error occured\n        if len(businput) > 10:\n            dbsExceptionHandler('dbsException-input-too-large', \"DBS cannot insert \\\n                    more than 10 files in one bulk call\")\n            return\n\n        conn = self.dbi.connection()\n        tran = conn.begin()\n        try:\n            #Now we are dealing with independent files that have different dataset/block and so on.\n            #See Trac #358.\n            #The expected input data format is a list of dictionary to insert independent files into DBS,\n            #inputdata={'files':[{}, {}, {}]}\n            #YG  09/15/2011\n\n            # AA- 01/06/2010 -- we have to do this file-by-file, there is no real good way to do this complex operation otherwise\n            #files2insert = []\n            #fidl = []\n            fileInserted = False\n            dataset = \"\"\n            block_name = \"\"\n            dataset_id = -1\n            block_id = -1\n            dsconfigs = []\n            for f in businput:\n                if not (\"logical_file_name\" in f and \"block_name\" in f and \"dataset\" in f ):\n                    dbsExceptionHandler('dbsException-invalid-input', \"DBSFile/insertFile must have logical_file_name, block_name and dataset as input\")\n                if f[\"block_name\"].split('#')[0] != f[\"dataset\"]:\n                    dbsExceptionHandler('dbsException-invalid-input', \"DBSFile/insertFile: dataset and block_name NOT match\")\n                # first check if the dataset exists\n                # and block exists that files are suppose to be going to and is OPEN for writing\n                if dataset != f[\"dataset\"]:\n                    dataset_id = self.datasetid.execute(conn, dataset=f[\"dataset\"])\n                    dataset = f[\"dataset\"]\n                    if dataset_id == -1 :\n                        dbsExceptionHandler('dbsException-missing-data', \"Required Dataset Not Found.\", None,\n                        \"Required Dataset %s does not exist\"%f[\"dataset\"] )\n                    # get the list of configs in for this dataset\n                    dsconfigs = [x['output_mod_config_id'] for x in self.dsconfigids.execute(conn, dataset=f[\"dataset\"])]\n                fileconfigs = [] # this will hold file configs that we will list in the insert file logic below\n                if block_name != f[\"block_name\"]:\n                    block_info = self.blocklist.execute(conn, block_name=f[\"block_name\"])\n\t\t    for b in block_info:\n\t\t\tif not b  : \n\t\t\t    dbsExceptionHandler( \"dbsException-missing-data\", \"Required block not found\", None,\n                                                          \"Cannot found required block %s in DB\" %f[\"block_name\"])\n\t\t\telse:\t\n\t\t\t    if  b[\"open_for_writing\"] != 1 : \n\t\t\t\tdbsExceptionHandler(\"dbsException-conflict-data\", \"Block closed\", None,\n\t\t\t\t    \"Block %s is not open for writting\" %f[\"block_name\"])\n\t\t\t    if \"block_id\" in b:\n\t\t\t\tblock_id = b[\"block_id\"]\n\t\t\t    else:\n\t\t\t\tdbsExceptionHandler(\"dbsException-missing-data\", \"Block not found\", None,\n                                          \"Cannot found required block %s in DB\" %f[\"block_name\"])\n                else: dbsExceptionHandler('dbsException-missing-data', \"Required block name Not Found in input.\",\n                                            None, \"Required block Not Found in input.\")\n                #make the default file_type=EDM\n                file_type_id = self.ftypeid.execute( conn, f.get(\"file_type\", \"EDM\"))\n                if file_type_id == -1:\n                    dbsExceptionHandler('dbsException-missing-data', \"File type not found.\", None,\n                                        \"Required file type %s not found in DBS\"%f.get(\"file_type\", \"EDM\") )\n\n                iFile = 0\n                fileIncrement = 40\n                fID = self.sm.increment(conn, \"SEQ_FL\", incCount=fileIncrement)\n                #looping over the files, everytime create a new object 'filein' as you never know\n                #whats in the original object and we do not want to know\n                #for f in businput:\n                file_clob = {}\n                fparents2insert = []\n                flumis2insert = []\n                fconfigs2insert = []\n                # create the file object from the original\n                # taking care of defaults, and required\n                filein = {\n                    \"logical_file_name\" : f[\"logical_file_name\"],\n                    \"is_file_valid\" : f.get(\"is_file_valid\", 1),\n                    \"check_sum\" : f.get(\"check_sum\", None),\n                    \"event_count\" : f.get(\"event_count\", -1),\n                    \"file_size\" : f.get(\"file_size\", -1),\n                    \"adler32\" : f.get(\"adler32\", None),\n                    \"md5\" : f.get(\"md5\", None),\n                    \"auto_cross_section\" : f.get(\"auto_cross_section\", -1),\n                    #\"creation_date\" : f.get(\"creation_date\", None),  See Ticket #965 YG.\n                    #\"create_by\": f.get(\"create_by\", None),\n                    \"last_modification_date\": f.get(\"last_modification_date\", None),\n                    #\"last_modified_by\" : f.get(\"last_modified_by\", None)\n                    \"last_modified_by\" : dbsUtils().getCreateBy()\n                }\n                if filein[\"md5\"] is None  and filein[\"check_sum\"] is None and filein[\"adler32\"] is None:\n                    dbsExceptionHandler('dbsException-invalid-input', \"Missing check_sum or adler32, or md5\")\n                if iFile == fileIncrement:\n                    fID = self.sm.increment(conn, \"SEQ_FL\", incCount=fileIncrement)\n                    iFile = 0\n                filein[\"file_id\"] = fID + iFile\n                iFile += 1\n                filein[\"dataset_id\"] = dataset_id\n                filein[\"block_id\"] = block_id\n                filein[\"file_type_id\"] = file_type_id\n                #FIXME: Add this later if f.get(\"branch_hash\", \"\") not in (\"\", None):\n                #filein[\"branch_hash\"]=self.fbranchid.execute( f.get(\"branch_hash\"), conn, transaction=tran)\n                # insert file  -- as decided, one file at a time\n                # filein will be what goes into database\n                try:\n                    if not qInserts:\n                        self.filein.execute(conn, filein, transaction=tran)\n                        fileInserted = True\n                    else:\n                        file_clob['file'] = filein\n                except SQLAlchemyIntegrityError as ex:\n                    if str(ex).find(\"unique constraint\") != -1 or str(ex).lower().find(\"duplicate\") != -1:\n                        # Lets move on to NEXT file, we do not want to continue processing this file\n\n                        #Nothing about this file is updated when it is already in DB. No file parentage, block parentage, dataset parentage and so on.\n                        #Is this right?  YG  Oct. 24\n                        self.logger.warning(\"DBSFile/insertFile. File already exists in DBS, not changing it: %s\"\n                                            %filein[\"logical_file_name\"] )\n                        continue\n                    else:\n                        raise\n\n                #process file parents, file lumi, file outputmodconfigs, ...\n                #file lumi sections\n                if \"file_lumi_list\" in f:\n                    fllist = f[\"file_lumi_list\"]\n                    if len(fllist) > 0:\n                        for fl in fllist:\n                            fldao = {\n                                \"run_num\" : fl[\"run_num\"],\n                                \"lumi_section_num\" : fl[\"lumi_section_num\"]\n                            }\n                            if \"event_count\" in fl:\n                                fldao[\"event_count\"] = fl[\"event_count\"]\n                            fldao[\"file_id\"] = filein[\"file_id\"]\n                            flumis2insert.append(fldao)\n\n                if \"file_parent_list\" in f:\n                    #file parents\n                    fplist = f[\"file_parent_list\"]\n\n                    for fp in fplist:\n                        fpdao = {}\n                        fpdao[\"this_file_id\"] = filein[\"file_id\"]\n                        fpdao[\"parent_logical_file_name\"] = fp[\"file_parent_lfn\"]\n                        fparents2insert.append(fpdao)\n                if \"file_output_config_list\" in f:\n                    #file output config modules\n                    foutconfigs = f[\"file_output_config_list\"]\n                    if(len(foutconfigs) > 0):\n                        for fc in foutconfigs:\n                            fcdao = {}\n                            fcdao[\"file_id\"] = filein[\"file_id\"]\n                            fcdao[\"output_mod_config_id\"] = self.outconfigid.execute(conn, fc[\"app_name\"],\n                                    fc[\"release_version\"], fc[\"pset_hash\"], fc[\"output_module_label\"],\n                                    fc[\"global_tag\"])\n                            if fcdao[\"output_mod_config_id\"] == -1 :\n                                dbsExceptionHandler('dbsException-missing-data', 'Config Not found.', None, \"DBSFile/insertFile.\\\n                                        Output module config (%s, %s, %s, %s) \\\n                                        not found\" % (fc[\"app_name\"],\n                                        fc[\"release_version\"], fc[\"pset_hash\"], fc[\"output_module_label\"]) )\n                            fileconfigs.append(fcdao[\"output_mod_config_id\"])\n                            fconfigs2insert.append(fcdao)\n                #FIXME: file associations?-- in a later release\n                #\n                # insert file - lumi\n                if flumis2insert:\n                    file_clob['file_lumi_list'] = flumis2insert\n                    if not qInserts:\n                        self.flumiin.execute(conn, flumis2insert, transaction=tran)\n                # insert file parent mapping\n                if fparents2insert:\n                    file_clob['file_parent_list'] = fparents2insert\n                    if not qInserts:\n                        self.fparentin.execute(conn, fparents2insert, transaction=tran)\n                # First check to see if these output configs are mapped to THIS dataset as well, if not raise an exception\n                if not set(fileconfigs).issubset(set(dsconfigs)) :\n                    dbsExceptionHandler('dbsException-conflict-data', 'Mismatched configure. ', None, \"DBSFile/insertFile. Output configs mismatch, \\\n                            output configs known to dataset: \\\n                            %s are different from what are being mapped to file : %s \" \\\n                            %(f[\"dataset\"], filein[\"logical_file_name\"]) )\n                # insert output module config mapping\n                if fconfigs2insert:\n                    file_clob['file_output_config_list'] = fconfigs2insert\n                    if not qInserts:\n                        self.fconfigin.execute(conn, fconfigs2insert, transaction=tran)\n                if qInserts:\n                    try:\n                        self.logger.warning(file_clob)\n                        self.filebufin.execute(conn, filein['logical_file_name'], block_id, file_clob, transaction=tran)\n                    except SQLAlchemyIntegrityError as ex:\n                        if str(ex).find(\"unique constraint\") != -1 or str(ex).lower().find(\"duplicate\") != -1:\n                            pass\n                        else:\n                            raise\n\n                #insert block parentages and dataset parentages based on file parentages\n                # Do this one by one, as it is sure to have duplicate in dest table\n                if fileInserted and fparents2insert:\n                    for fp in fparents2insert:\n                        try:\n                            bkParentage2insert={'this_block_id' : filein[\"block_id\"], 'parent_logical_file_name': fp['parent_logical_file_name']}\n                            self.blkparentin.execute(conn, bkParentage2insert, transaction=tran)\n                            dsParentage2insert={'this_dataset_id': filein[\"dataset_id\"], 'parent_logical_file_name' : fp['parent_logical_file_name']}\n                            self.dsparentin.execute(conn, dsParentage2insert, transaction=tran)\n                        except SQLAlchemyIntegrityError as ex:\n                            #ORA-00001\n                            if (str(ex).find(\"ORA-00001\") != -1 and str(ex).find(\"PK_DP\") != -1) or str(ex).find(\"PK_BP\") != -1 or str(ex).lower().find(\"duplicate\") != -1:\n                                pass\n                            elif str(ex).find(\"ORA-01400\") != -1:\n                                raise\n                            else:\n                                raise\n\n                # Update block parameters, file_count, block_size\n                if not qInserts:\n                    blkParams = self.blkstats.execute(conn, block_id,\n                                                      transaction=tran)\n                    blkParams['block_size'] = long(blkParams['block_size'])\n                    self.blkstatsin.execute(conn, blkParams, transaction=tran)\n\n            # All good ?\n            tran.commit()\n            tran = None\n\n        except Exception as ex:\n            if tran:\n                tran.rollback()\n                tran = None\n            raise\n\n        finally:\n            if tran:\n                tran.rollback()\n            if conn:\n                conn.close()", "response": "This method inserts a file into the database."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef insertFileParents(self, businput):\n        if \"block_name\" not in businput.keys() or \"child_parent_id_list\" not in businput.keys() or not businput[\"child_parent_id_list\"] or not businput[\"block_name\"]:\n            dbsExceptionHandler(\"dbsException-invalid-input2\", \"DBSFile/insertFileParents: require child block_name and list of child/parent file id pairs\" , self.logger.exception, \"DBSFile/insertFileParents: require child block_name and list of child/parent file id pairs\")\n        tran = None\n        conn = None  \n        try:\n            #We should get clean insert for both file/block parentage.\n            #block parent duplication is handled at dao level. File parent should not have deplication.  \n            conn = self.dbi.connection()\n            tran = conn.begin()\n            self.logger.info(\"Insert File parentage mapping\") \n            self.fparentin2.execute(conn, businput, tran)\n            self.logger.info(\"Insert block parentage mapping\")\n            self.blkparentin3.execute(conn, businput, tran)\n            if tran:tran.commit()\n            if conn:conn.close()\n        except SQLAlchemyIntegrityError as ex:\n                if tran:tran.rollback()\n                if conn:conn.close()\n                if str(ex).find(\"ORA-01400\") > -1:\n                    dbsExceptionHandler('dbsException-missing-data',\n                        'Missing data when insert filei/block parent. ', self.logger.exception,\n                        'Missing data when insert file/block parent. '+ str(ex))\n                else:\n                    dbsExceptionHandler('dbsException-invalid-input2',\n                        'Invalid data when insert file/block parent.  ', self.logger.exception,\n                        'Invalid data when insert file/block parent. '+ str(ex))\n        finally:\n            if tran:tran.rollback()\n            if conn:conn.close()", "response": "Insert File Parents into DBS."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef increment(self, conn, seqName, transaction = False, incCount=1):\n\n        #FIXME: Do we need to lock the tables here?\n\n        sql = \"select %s%s.nextval as val from dual\" % (self.owner, seqName)\n        result = self.dbi.processData(sql, conn=conn, transaction=transaction)\n        resultlist = self.formatDict(result)\n        return resultlist[0]['val']", "response": "Increment the sequence seqName by default Incremented by\n        returns its value"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nlist release versions of a specific release version.", "response": "def listReleaseVersions(self, release_version=\"\", dataset='', logical_file_name=''):\n        \"\"\"\n        List release versions\n        \"\"\"\n        if dataset and ('%' in dataset or '*' in dataset):\n            dbsExceptionHandler('dbsException-invalid-input',\n                \" DBSReleaseVersion/listReleaseVersions. No wildcards are\" +\n                \" allowed in dataset.\\n.\")\n\n        if logical_file_name and ('%' in logical_file_name or '*' in logical_file_name):\n            dbsExceptionHandler('dbsException-invalid-input',\n                \" DBSReleaseVersion/listReleaseVersions. No wildcards are\" +\n                \" allowed in logical_file_name.\\n.\")\n\n        conn = self.dbi.connection()\n        try:\n            plist = self.releaseVersion.execute(conn, release_version.upper(), dataset, logical_file_name)\n            result = [{}]\n            if plist:\n                t = []\n                for i in plist:\n                    for k, v in i.iteritems():\n                        t.append(v)\n                result[0]['release_version'] = t\n            return result\n        finally:\n            if conn:\n                conn.close()"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsearches the path to the CA file that is used to authenticate the client side.", "response": "def __search_ca_path(self):\n        \"\"\"\n        Get CA Path to check the validity of the server host certificate on the client side\n        \"\"\"\n        if \"X509_CERT_DIR\" in os.environ:\n            self._ca_path = os.environ['X509_CERT_DIR']\n\n        elif os.path.exists('/etc/grid-security/certificates'):\n            self._ca_path = '/etc/grid-security/certificates'\n\n        else:\n            raise ClientAuthException(\"Could not find a valid CA path\")"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef __search_cert_key(self):\n        # Now we're trying to guess what the right cert/key combo is...\n        # First preference to HOST Certificate, This is how it set in Tier0\n        if 'X509_HOST_CERT' in os.environ:\n            self._ssl_cert = os.environ['X509_HOST_CERT']\n            self._ssl_key = os.environ['X509_HOST_KEY']\n\n        # Second preference to User Proxy, very common\n        elif 'X509_USER_PROXY' in os.environ and os.path.exists(os.environ['X509_USER_PROXY']):\n            self._ssl_cert = os.environ['X509_USER_PROXY']\n            self._ssl_key = self._ssl_cert\n\n        # Third preference to User Cert/Proxy combinition\n        elif 'X509_USER_CERT' in os.environ and 'X509_USER_KEY' in os.environ:\n            self._ssl_cert = os.environ['X509_USER_CERT']\n            self._ssl_key = os.environ['X509_USER_KEY']\n\n        # TODO: only in linux, unix case, add other os case\n        # look for proxy at default location /tmp/x509up_u$uid\n        elif os.path.exists('/tmp/x509up_u%s' % str(os.getuid())):\n            self._ssl_cert = '/tmp/x509up_u%s' % str(os.getuid())\n            self._ssl_key = self._ssl_cert\n\n        elif sys.stdin.isatty():\n            home_dir = os.environ['HOME']\n            user_cert = os.path.join(home_dir, '.globus/usercert.pem')\n            user_key = os.path.join(home_dir, '.globus/userkey.pem')\n\n            if os.path.exists(user_cert):\n                self._ssl_cert = user_cert\n                if os.path.exists(user_key):\n                    self._ssl_key = user_key\n                    #store password for convenience\n                    self._ssl_key_pass = getpass(\"Password for %s: \" % self._ssl_key)\n                else:\n                    self._ssl_key = self._ssl_cert\n            else:\n                raise ClientAuthException(\"No valid X509 cert-key-pair found.\")    \n\n        else:\n            raise ClientAuthException(\"No valid X509 cert-key-pair found.\")", "response": "Search the user credentials if they exist otherwise throw an exception."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ninterface for submitting a migration request. Required input keys: MIGRATION_URL: The source DBS url for migration. MIGRATION_INPUT: The block or dataset names to be migrated.", "response": "def submit(self):\n        \"\"\"\n        Interface for submitting a migration request.\n        Required input keys:\n        MIGRATION_URL: The source DBS url for migration.\n        MIGRATION_INPUT: The block or dataset names to be migrated.\n        \"\"\"\n        body = request.body.read()\n        indata = cjson.decode(body)\n        try:\n            indata = validateJSONInputNoCopy(\"migration_rqst\", indata)\n            indata.update({\"creation_date\": dbsUtils().getTime(),\n                \"last_modification_date\" : dbsUtils().getTime(),\n                \"create_by\" : dbsUtils().getCreateBy() ,\n                \"last_modified_by\" : dbsUtils().getCreateBy(),\n                \"migration_status\": 0})\n            return self.dbsMigrate.insertMigrationRequest(indata)\n        except dbsException as de:\n            dbsExceptionHandler(de.eCode, de.message, self.logger.exception, de.serverError)\n        except Exception as ex:\n            sError = \"DBSMigrateModle/submit. %s\\n Exception trace: \\n %s.\" \\\n                     % (ex, traceback.format_exc() )\n            if hasattr(ex, 'status') and ex.status == 400:\n\t\tdbsExceptionHandler('dbsException-invalid-input2', str(ex), self.logger.exception, sError)\n\t    else:\t\n\t\tdbsExceptionHandler('dbsException-server-error',  str(ex), self.logger.exception, sError)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ninterfacing to query status of a migration request In this preference order of input parameters : migration_rqst_id, block, dataset, user (if multi parameters are provided, only the precedence order is followed)", "response": "def status(self, migration_rqst_id=\"\", block_name=\"\", dataset=\"\", user=\"\"):\n        \"\"\"\n        Interface to query status of a migration request\n        In this preference order of input parameters :\n            migration_rqst_id, block, dataset, user\n            (if multi parameters are provided, only the precedence order is followed)\n        \"\"\"\n        try:\n            return self.dbsMigrate.listMigrationRequests(migration_rqst_id,\n                block_name, dataset, user)\n        except dbsException as de:\n            dbsExceptionHandler(de.eCode, de.message, self.logger.exception, de.serverError)\n        except Exception as ex:\n            sError = \"DBSMigrateModle/status. %s\\n Exception trace: \\n %s.\" \\\n                     % (ex, traceback.format_exc() )\n\t    if hasattr(ex, 'status') and ex.status == 400:\n\t\tdbsExceptionHandler('dbsException-invalid-input2', str(ex), self.logger.exception, sError)\t\n            else:\n\t\tdbsExceptionHandler('dbsException-server-error',  str(ex), self.logger.exception, sError)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ninterfacing to remove a migration request from the queue. Only Permanent FAILED/9 and PENDING/0 requests can be removed (running and sucessed requests cannot be removed)", "response": "def remove(self):\n        \"\"\"\n        Interface to remove a migration request from the queue.\n        Only Permanent FAILED/9 and PENDING/0 requests can be removed\n        (running and sucessed requests cannot be removed)\n\n        \"\"\"\n        body = request.body.read()\n        indata = cjson.decode(body)\n        try:\n            indata = validateJSONInputNoCopy(\"migration_rqst\", indata)\n            return self.dbsMigrate.removeMigrationRequest(indata)\n        except dbsException as he:\n            dbsExceptionHandler(he.eCode, he.message, self.logger.exception, he.message)\n        except Exception as e:\n            if e.code == 400:\n                dbsExceptionHandler('dbsException-invalid-input2', str(e), self.logger.exception, str(e))    \n            else:\n                dbsExceptionHandler('dbsException-server-error', dbsExceptionCode['dbsException-server-error'], self.logger.exception, str(e))"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nexecutes the SQL SELECT query and returns the result as a generator.", "response": "def execute(self, conn, logical_file_name='', block_id=0, block_name='', transaction=False):\n        \"\"\"\n        return {} if condition is not provided.\n        \"\"\"\n        sql = ''\n        binds = {}\n\n        if logical_file_name:\n            if isinstance(logical_file_name, basestring):\n                wheresql = \"WHERE F.LOGICAL_FILE_NAME = :logical_file_name\"\n                binds = {\"logical_file_name\": logical_file_name}\n                sql = \"{sql} {wheresql}\".format(sql=self.sql, wheresql=wheresql)\n            elif isinstance(logical_file_name, list): \n                wheresql = \"WHERE F.LOGICAL_FILE_NAME in (SELECT TOKEN FROM TOKEN_GENERATOR)\"\n                lfn_generator, binds = create_token_generator(logical_file_name)\n                sql = \"{lfn_generator} {sql} {wheresql}\".format(lfn_generator=lfn_generator, sql=self.sql,\n                        wheresql=wheresql)\n        elif block_id != 0:\n            wheresql = \"WHERE F.BLOCK_ID = :block_id\"\n            binds ={'block_id': block_id}\n            sql = \"{sql} {wheresql}\".format(sql=self.sql, wheresql=wheresql)\n        elif block_name:\n            joins = \"JOIN {owner}BLOCKS B on B.BLOCK_ID = F.BLOCK_ID\".format(owner=self.owner)\n            wheresql = \"WHERE B.BLOCK_NAME= :block_name\"\n            binds ={'block_name': block_name}\n            sql = \"{sql} {joins} {wheresql}\".format(sql=self.sql, joins=joins, wheresql=wheresql)\n        else:\n            return\n\n        cursors = self.dbi.processData(sql, binds, conn, transaction=transaction, returnCursor=True)\n        for i in cursors:\n            d = self.formatCursor(i, size=100)\n            if isinstance(d, list) or isinstance(d, GeneratorType):\n                for elem in d:\n                    yield elem\n            elif d: \n                yield d"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef listDatasetParents(self, dataset=\"\"):\n        if( dataset == \"\" ):\n            dbsExceptionHandler(\"dbsException-invalid-input\", \"DBSDataset/listDatasetParents. Child Dataset name is required.\")\n        conn = self.dbi.connection()\n        try:\n            result = self.datasetparentlist.execute(conn, dataset)\n            return result\n        finally:\n            if conn:\n                conn.close()", "response": "returns only parent dataset name"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef listDatasetChildren(self, dataset):\n        if( dataset == \"\" ):\n            dbsExceptionHandler(\"dbsException-invalid-input\", \"DBSDataset/listDatasetChildren. Parent Dataset name is required.\")\n        conn = self.dbi.connection()\n        try:\n            result = self.datasetchildlist.execute(conn, dataset)\n            return result\n        finally:\n            if conn:\n                conn.close()", "response": "returns only children dataset name"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef updateStatus(self, dataset, is_dataset_valid):\n        if( dataset == \"\" ):\n            dbsExceptionHandler(\"dbsException-invalid-input\", \"DBSDataset/updateStatus. dataset is required.\")\n\n        conn = self.dbi.connection()\n        trans = conn.begin()\n\n        try:\n            self.updatestatus.execute(conn, dataset, is_dataset_valid, trans)\n            trans.commit()\n            trans = None\n        except Exception as ex:\n            if trans:\n                trans.rollback()\n            raise ex\n        finally:\n            if trans:\n                trans.rollback()\n            if conn:\n                conn.close()", "response": "Update the status of a dataset"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef updateType(self, dataset, dataset_access_type):\n        if( dataset == \"\" ):\n            dbsExceptionHandler(\"dbsException-invalid-input\", \"DBSDataset/updateType. dataset is required.\")\n\n        conn = self.dbi.connection()\n        trans = conn.begin()\n\n        try :\n            self.updatetype.execute(conn, dataset, dataset_access_type.upper(), trans)\n            trans.commit()\n            trans = None\n        except SQLAlchemyDatabaseError as ex:\n            if str(ex).find(\"ORA-01407\") != -1:\n                dbsExceptionHandler(\"dbsException-invalid-input2\", \"Invalid Input\", None, \"DBSDataset/updateType. A Valid dataset_access_type is required.\")\n        finally:\n            if trans:\n                trans.rollback()\n            if conn:\n                conn.close()", "response": "Update the type of a dataset."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nlist all datasets if dataset parameter is not given. The parameter can include % character. all other parameters are not wild card ones.", "response": "def listDatasets(self, dataset=\"\", parent_dataset=\"\", is_dataset_valid=1,\n                     release_version=\"\", pset_hash=\"\", app_name=\"\",\n                     output_module_label=\"\", global_tag=\"\", processing_version=0, \n                     acquisition_era=\"\", run_num=-1, physics_group_name=\"\",\n                     logical_file_name=\"\", primary_ds_name=\"\",\n                     primary_ds_type=\"\", processed_ds_name=\"\", data_tier_name=\"\",\n                     dataset_access_type=\"VALID\", prep_id=\"\", create_by='', last_modified_by='', min_cdate=0, max_cdate=0,\n                     min_ldate=0, max_ldate=0, cdate=0, ldate=0, detail=False, dataset_id=-1):\n        \"\"\"\n        lists all datasets if dataset parameter is not given.\n        The parameter can include % character. \n        all other parameters are not wild card ones.\n        \"\"\"\n        if(logical_file_name and logical_file_name.find(\"%\")!=-1):\n            dbsExceptionHandler('dbsException-invalid-input', 'DBSDataset/listDatasets API requires \\\n                fullly qualified logical_file_name. NO wildcard is allowed in logical_file_name.')\n        if(dataset and dataset.find(\"/%/%/%\")!=-1):\n            dataset=''\n\twith self.dbi.connection() as conn:\n            dao = (self.datasetbrieflist, self.datasetlist)[detail]\n            if dataset_access_type: dataset_access_type = dataset_access_type.upper()\n            if data_tier_name: data_tier_name = data_tier_name.upper()\n            #if  processing_version:  processing_version =  processing_version.upper()\n            #if acquisition_era: acquisition_era = acquisition_era.upper()\n            for item in dao.execute(conn, \n                                 dataset, is_dataset_valid,\n                                 parent_dataset,\n                                 release_version,\n                                 pset_hash,\n                                 app_name,\n                                 output_module_label,\n                                 global_tag,\n                                 processing_version,\n                                 acquisition_era, \n                                 run_num, physics_group_name,\n                                 logical_file_name,\n                                 primary_ds_name, primary_ds_type,\n                                 processed_ds_name, data_tier_name,\n                                 dataset_access_type, prep_id, create_by, last_modified_by, \n                                 min_cdate, max_cdate, min_ldate, max_ldate,\n                                 cdate, ldate, dataset_id):\n\t        yield item"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef insertDataset(self, businput):\n        if not (\"primary_ds_name\" in businput and \"dataset\" in businput\n                and \"dataset_access_type\" in businput and \"processed_ds_name\" in businput ):\n            dbsExceptionHandler('dbsException-invalid-input', \"business/DBSDataset/insertDataset must have dataset,\\\n                dataset_access_type, primary_ds_name, processed_ds_name as input\")\n\n        if \"data_tier_name\" not in businput:\n            dbsExceptionHandler('dbsException-invalid-input', \"insertDataset must have data_tier_name as input.\")\n\n        conn = self.dbi.connection()\n        tran = conn.begin()\n        try:\n\n            dsdaoinput = {}\n            dsdaoinput[\"primary_ds_name\"] = businput[\"primary_ds_name\"]\n            dsdaoinput[\"data_tier_name\"] =  businput[\"data_tier_name\"].upper()\n            dsdaoinput[\"dataset_access_type\"] = businput[\"dataset_access_type\"].upper()\n            #not required pre-exist in the db. will insert with the dataset if not in yet\n            #processed_ds_name=acquisition_era_name[-fileter_name][-processing_str]-vprocessing_version   Changed as 4/30/2012 YG.\n            #althrough acquisition era and processing version is not required for a dataset in the schema(the schema is build this way because\n            #we need to accomdate the DBS2 data), but we impose the requirement on the API. So both acquisition and processing eras are required \n            #YG 12/07/2011  TK-362\n            if \"acquisition_era_name\" in businput and \"processing_version\" in businput:\n                erals=businput[\"processed_ds_name\"].rsplit('-')\n                if erals[0]==businput[\"acquisition_era_name\"] and erals[len(erals)-1]==\"%s%s\"%(\"v\", businput[\"processing_version\"]):\n                    dsdaoinput[\"processed_ds_name\"] = businput[\"processed_ds_name\"]\n                else:\n                    dbsExceptionHandler('dbsException-invalid-input', \"insertDataset:\\\n                    processed_ds_name=acquisition_era_name[-filter_name][-processing_str]-vprocessing_version must be satisified.\")\n            else:\n                dbsExceptionHandler(\"dbsException-missing-data\",  \"insertDataset: Required acquisition_era_name or processing_version is not found in the input\")\n            \n            if \"physics_group_name\" in businput:\n                dsdaoinput[\"physics_group_id\"] = self.phygrpid.execute(conn, businput[\"physics_group_name\"])\n                if dsdaoinput[\"physics_group_id\"]  == -1:\n                    dbsExceptionHandler(\"dbsException-missing-data\",  \"insertDataset. physics_group_name not found in DB\")\n            else:\n                dsdaoinput[\"physics_group_id\"] = None\n\n            dsdaoinput[\"dataset_id\"] = self.sm.increment(conn, \"SEQ_DS\")\n            # we are better off separating out what we need for the dataset DAO\n            dsdaoinput.update({ \n                               \"dataset\" : \"/%s/%s/%s\" %\n                               (businput[\"primary_ds_name\"],\n                                businput[\"processed_ds_name\"],\n                                businput[\"data_tier_name\"].upper()),\n                               \"prep_id\" : businput.get(\"prep_id\", None),\n                               \"xtcrosssection\" : businput.get(\"xtcrosssection\", None),\n                               \"creation_date\" : businput.get(\"creation_date\", dbsUtils().getTime() ),\n                               \"create_by\" : businput.get(\"create_by\", dbsUtils().getCreateBy()) ,\n                               \"last_modification_date\" : businput.get(\"last_modification_date\", dbsUtils().getTime()),\n                               #\"last_modified_by\" : businput.get(\"last_modified_by\", dbsUtils().getModifiedBy())\n                               \"last_modified_by\" : dbsUtils().getModifiedBy()\n                               })\n            \"\"\"\n            repeated again, why?  comment out by YG 3/14/2012\n            #physics group\n            if \"physics_group_name\" in businput:\n                dsdaoinput[\"physics_group_id\"] = self.phygrpid.execute(conn, businput[\"physics_group_name\"])\n                if dsdaoinput[\"physics_group_id\"]  == -1:\n                    dbsExceptionHandler(\"dbsException-missing-data\",  \"insertDataset. Physics Group : %s Not found\"\n                                                                                    % businput[\"physics_group_name\"])\n            else: dsdaoinput[\"physics_group_id\"] = None\n            \"\"\"\n            # See if Processing Era exists\n            if \"processing_version\" in businput and businput[\"processing_version\"] != 0:\n                dsdaoinput[\"processing_era_id\"] = self.proceraid.execute(conn, businput[\"processing_version\"])\n                if dsdaoinput[\"processing_era_id\"] == -1 :\n                    dbsExceptionHandler(\"dbsException-missing-data\", \"DBSDataset/insertDataset: processing_version not found in DB\") \n            else:\n                dbsExceptionHandler(\"dbsException-invalid-input\", \"DBSDataset/insertDataset: processing_version is required\")\n\n            # See if Acquisition Era exists\n            if \"acquisition_era_name\" in businput:\n                dsdaoinput[\"acquisition_era_id\"] = self.acqeraid.execute(conn, businput[\"acquisition_era_name\"])\n                if dsdaoinput[\"acquisition_era_id\"] == -1:\n                    dbsExceptionHandler(\"dbsException-missing-data\", \"DBSDataset/insertDataset: acquisition_era_name not found in DB\")\n            else:\n                dbsExceptionHandler(\"dbsException-invalid-input\", \"DBSDataset/insertDataset:  acquisition_era_name is required\")\n            try:\n                # insert the dataset\n                self.datasetin.execute(conn, dsdaoinput, tran)\n            except SQLAlchemyIntegrityError as ex:\n                if (str(ex).lower().find(\"unique constraint\") != -1 or\n                    str(ex).lower().find(\"duplicate\") != -1):\n                    # dataset already exists, lets fetch the ID\n                    self.logger.warning(\n                            \"Unique constraint violation being ignored...\")\n                    self.logger.warning(\"%s\" % ex)\n                    ds = \"/%s/%s/%s\" % (businput[\"primary_ds_name\"], businput[\"processed_ds_name\"], businput[\"data_tier_name\"].upper())\n                    dsdaoinput[\"dataset_id\"] = self.datasetid.execute(conn, ds )\n                    if dsdaoinput[\"dataset_id\"] == -1 :\n                        dbsExceptionHandler(\"dbsException-missing-data\", \"DBSDataset/insertDataset. Strange error, the dataset %s does not exist ?\" \n                                                    % ds )\n                if (str(ex).find(\"ORA-01400\") ) != -1 :\n                    dbsExceptionHandler(\"dbsException-missing-data\", \"insertDataset must have: dataset,\\\n                                          primary_ds_name, processed_ds_name, data_tier_name \")\n            except Exception as e:\n                raise       \n\n            #FIXME : What about the READ-only status of the dataset\n            #There is no READ-oly status for a dataset.\n\n            # Create dataset_output_mod_mod_configs mapping\n            if \"output_configs\" in businput:\n                for anOutConfig in businput[\"output_configs\"]:\n                    dsoutconfdaoin = {}\n                    dsoutconfdaoin[\"dataset_id\"] = dsdaoinput[\"dataset_id\"]\n                    dsoutconfdaoin[\"output_mod_config_id\"] = self.outconfigid.execute(conn, anOutConfig[\"app_name\"],\n                                                                                anOutConfig[\"release_version\"],\n                                                                                anOutConfig[\"pset_hash\"],\n                                                                                anOutConfig[\"output_module_label\"],\n                                                                                anOutConfig[\"global_tag\"]) \n                    if dsoutconfdaoin[\"output_mod_config_id\"] == -1 : \n\n                        dbsExceptionHandler(\"dbsException-missing-data\", \"DBSDataset/insertDataset: Output config (%s, %s, %s, %s, %s) not found\"\n                                                                                % (anOutConfig[\"app_name\"],\n                                                                                   anOutConfig[\"release_version\"],\n                                                                                   anOutConfig[\"pset_hash\"],\n                                                                                   anOutConfig[\"output_module_label\"],\n                                                                                   anOutConfig[\"global_tag\"]))\n                    try:\n                        self.datasetoutmodconfigin.execute(conn, dsoutconfdaoin, tran)\n                    except Exception as ex:\n                        if str(ex).lower().find(\"unique constraint\") != -1 or str(ex).lower().find(\"duplicate\") != -1:\n                            pass\n                        else:\n                            raise\n            # Dataset parentage will NOT be added by this API it will be set by insertFiles()--deduced by insertFiles\n            # Dataset  runs will NOT be added by this API they will be set by insertFiles()--deduced by insertFiles OR insertRun API call\n            tran.commit()\n            tran = None\n        except Exception:\n            if tran:\n                tran.rollback()\n                tran = None\n            raise\n        finally:\n            if tran:\n                tran.rollback()\n            if conn:\n                conn.close()", "response": "Insert a new dataset into DBS."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nupdates origin_site_name for a given block_name", "response": "def execute(self, conn, block_name, origin_site_name, transaction=False):\n        \"\"\"\n        Update origin_site_name for a given block_name\n        \"\"\"\n        if not conn:\n            dbsExceptionHandler(\"dbsException-failed-connect2host\", \"Oracle/Block/UpdateStatus. \\\nExpects db connection from upper layer.\", self.logger.exception)\n        binds = {\"block_name\": block_name, \"origin_site_name\": origin_site_name, \"mtime\": dbsUtils().getTime(),\n                 \"myuser\": dbsUtils().getCreateBy()}\n        self.dbi.processData(self.sql, binds, conn, transaction)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nincrementing the sequence seqName by default Incremented by one and returns its value", "response": "def increment(self, conn, seqName, transaction = False, incCount=1):\n        \"\"\"\n        increments the sequence `seqName` by default `Incremented by one`\n        and returns its value\n        \"\"\"\n\ttry:\n\t    seqTable = \"%sS\" %seqName\n\t    tlock = \"lock tables %s write\" %seqTable\n\t    self.dbi.processData(tlock, [], conn, transaction)\n\t    sql = \"select ID from %s\" % seqTable\n\t    result = self.dbi.processData(sql, [], conn, transaction)\n\t    resultlist = self.formatDict(result)\n\t    newSeq = resultlist[0]['id']+incCount\n\t    sql = \"UPDATE %s SET ID=:seq_count\" % seqTable\n\t    seqparms={\"seq_count\" : newSeq}\n\t    self.dbi.processData(sql, seqparms, conn, transaction)\n\t    tunlock = \"unlock tables\"\n\t    self.dbi.processData(tunlock, [], conn, transaction)\n\t    return newSeq\n\texcept:\n\t    #FIXME\n\t    tunlock = \"unlock tables\"\n\t    self.dbi.processData(tunlock, [], conn, transaction)\n\t    raise"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef listRuns(self, run_num=-1, logical_file_name=\"\",\n                 block_name=\"\", dataset=\"\"):\n        \"\"\"\n        List run known to DBS.\n        \"\"\"\n        if( '%' in logical_file_name or '%' in block_name or '%' in dataset ):\n            dbsExceptionHandler('dbsException-invalid-input', \n                                \" DBSDatasetRun/listRuns. No wildcards are allowed in logical_file_name, block_name or dataset.\\n.\")\n        conn = self.dbi.connection()\n        tran = False\n        try:\n            ret = self.runlist.execute(conn, run_num, logical_file_name, block_name, dataset, tran)\n            result = []\n            rnum = []\n            for i in ret:\n                rnum.append(i['run_num'])\n            result.append({'run_num' : rnum})\n            return result\n\n        finally:\n            if conn:\n                conn.close()", "response": "List all runs known to DBS."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef insertPrimaryDataset(self):\n        try :\n            body = request.body.read()\n            indata = cjson.decode(body)\n            indata = validateJSONInputNoCopy(\"primds\", indata)\n            indata.update({\"creation_date\": dbsUtils().getTime(), \"create_by\": dbsUtils().getCreateBy() })\n            self.dbsPrimaryDataset.insertPrimaryDataset(indata)\n        except cjson.DecodeError as dc:\n            dbsExceptionHandler(\"dbsException-invalid-input2\", \"Wrong format/data from insert PrimaryDataset input\",  self.logger.exception, str(dc))\n        except dbsException as de:\n            dbsExceptionHandler(de.eCode, de.message, self.logger.exception, de.message)\n        except HTTPError as he:\n            raise he\n        except Exception as ex:\n            sError = \"DBSWriterModel/insertPrimaryDataset. %s\\n Exception trace: \\n %s\" \\\n                        % (ex, traceback.format_exc())\n            dbsExceptionHandler('dbsException-server-error',  dbsExceptionCode['dbsException-server-error'], self.logger.exception, sError)", "response": "API to insert A primary dataset in DBS."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef updateAcqEraEndDate(self, acquisition_era_name =\"\", end_date=0):\n        try:\n            self.dbsAcqEra.UpdateAcqEraEndDate( acquisition_era_name, end_date)\n        except dbsException as de:\n            dbsExceptionHandler(de.eCode, de.message, self.logger.exception, de.message)\n        except HTTPError as he:\n            raise he\n        except Exception as ex:\n            sError = \"DBSWriterModel/update.AcqEraEndDate %s\\n. Exception trace: \\n %s\" \\\n                    % (ex, traceback.format_exc())\n            dbsExceptionHandler('dbsException-server-error',  dbsExceptionCode['dbsException-server-error'], self.logger.exception, sError)", "response": "API to update the end_date of an acquisition era"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef insertBulkBlock(self):\n        try:\n            body = request.body.read()\n            indata = cjson.decode(body)\n            if (indata.get(\"file_parent_list\", []) and indata.get(\"dataset_parent_list\", [])): \n                dbsExceptionHandler(\"dbsException-invalid-input2\", \"insertBulkBlock: dataset and file parentages cannot be in the input at the same time\",  \n                    self.logger.exception, \"insertBulkBlock: datset and file parentages cannot be in the input at the same time.\")    \n            indata = validateJSONInputNoCopy(\"blockBulk\", indata)\n            self.dbsBlockInsert.putBlock(indata)\n        except cjson.DecodeError as dc:\n            dbsExceptionHandler(\"dbsException-invalid-input2\", \"Wrong format/data from insert BulkBlock input\",  self.logger.exception, str(dc))\n        except dbsException as de:\n            dbsExceptionHandler(de.eCode, de.message, self.logger.exception, de.message)\n        except HTTPError as he:\n            raise he\n        except Exception as ex:\n            #illegal variable name/number\n            if str(ex).find(\"ORA-01036\") != -1:\n                dbsExceptionHandler(\"dbsException-invalid-input2\", \"illegal variable name/number from input\",  self.logger.exception, str(ex))\n            else:\n                sError = \"DBSWriterModel/insertBulkBlock. %s\\n. Exception trace: \\n %s\" \\\n                    % (ex, traceback.format_exc())\n                dbsExceptionHandler('dbsException-server-error',  dbsExceptionCode['dbsException-server-error'], self.logger.exception, sError)", "response": "API to insert a bulk block of datset and file parentages."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef insertBlock(self):\n        try:\n            body = request.body.read()\n            indata = cjson.decode(body)\n            indata = validateJSONInputNoCopy(\"block\", indata)\n            self.dbsBlock.insertBlock(indata)\n        except cjson.DecodeError as dc:\n            dbsExceptionHandler(\"dbsException-invalid-input2\", \"Wrong format/data from insert Block input\",  self.logger.exception, str(dc))\n        except dbsException as de:\n            dbsExceptionHandler(de.eCode, de.message, self.logger.exception, de.message)\n        except Exception as ex:\n            sError = \"DBSWriterModel/insertBlock. %s\\n. Exception trace: \\n %s\" \\\n                    % (ex, traceback.format_exc())\n            dbsExceptionHandler('dbsException-server-error',  dbsExceptionCode['dbsException-server-error'], self.logger.exception, sError)", "response": "API to insert a block into DBS"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ninsert a list of files into DBS.", "response": "def insertFile(self, qInserts=False):\n        \"\"\"\n        API to insert a list of file into DBS in DBS. Up to 10 files can be inserted in one request.\n\n        :param qInserts: True means that inserts will be queued instead of done immediately. INSERT QUEUE Manager will perform the inserts, within few minutes.\n        :type qInserts: bool\n        :param filesList: List of dictionaries containing following information\n        :type filesList: list of dicts\n        :key logical_file_name: File to be inserted (str) (Required)\n        :key is_file_valid: (optional, default = 1): (bool)\n        :key block: required: /a/b/c#d (str)\n        :key dataset: required: /a/b/c (str)\n        :key file_type: (optional, default = EDM) one of the predefined types, (str)\n        :key check_sum: (optional, default = '-1') (str)\n        :key event_count: (optional, default = -1) (int)\n        :key file_size: (optional, default = -1.) (float)\n        :key adler32: (optional, default = '') (str)\n        :key md5: (optional, default = '') (str)\n        :key auto_cross_section: (optional, default = -1.) (float)\n        :key file_lumi_list: (optional, default = []) [{'run_num': 123, 'lumi_section_num': 12},{}....]\n        :key file_parent_list: (optional, default = []) [{'file_parent_lfn': 'mylfn'},{}....]\n        :key file_assoc_list: (optional, default = []) [{'file_parent_lfn': 'mylfn'},{}....]\n        :key file_output_config_list: (optional, default = []) [{'app_name':..., 'release_version':..., 'pset_hash':...., output_module_label':...},{}.....]\n\n        \"\"\"\n        if qInserts in (False, 'False'): qInserts=False\n        try:\n            body = request.body.read()\n            indata = cjson.decode(body)[\"files\"]\n            if not isinstance(indata, (list, dict)):\n                dbsExceptionHandler(\"dbsException-invalid-input\", \"Invalid Input DataType\", self.logger.exception, \\\n                                      \"insertFile expects input as list or dirc\")\n            businput = []\n            if isinstance(indata, dict):\n                indata = [indata]\n            indata = validateJSONInputNoCopy(\"files\", indata)\n            for f in indata:\n                f.update({\n                     #\"dataset\":f[\"dataset\"],\n                     \"creation_date\": f.get(\"creation_date\", dbsUtils().getTime()),\n                     \"create_by\" : dbsUtils().getCreateBy(),\n                     \"last_modification_date\": f.get(\"last_modification_date\", dbsUtils().getTime()),\n                     \"last_modified_by\": f.get(\"last_modified_by\", dbsUtils().getCreateBy()),\n                     \"file_lumi_list\":f.get(\"file_lumi_list\", []),\n                     \"file_parent_list\":f.get(\"file_parent_list\", []),\n                     \"file_assoc_list\":f.get(\"assoc_list\", []),\n                     \"file_output_config_list\":f.get(\"file_output_config_list\", [])})\n                businput.append(f)\n            self.dbsFile.insertFile(businput, qInserts)\n        except cjson.DecodeError as dc:\n            dbsExceptionHandler(\"dbsException-invalid-input2\", \"Wrong format/data from insert File input\",  self.logger.exception, str(dc))\n        except dbsException as de:\n            dbsExceptionHandler(de.eCode, de.message, self.logger.exception, de.message)\n        except HTTPError as he:\n            raise he\n        except Exception as ex:\n            sError = \"DBSWriterModel/insertFile. %s\\n. Exception trace: \\n %s\" \\\n                    % (ex, traceback.format_exc())\n            dbsExceptionHandler('dbsException-server-error',  dbsExceptionCode['dbsException-server-error'], self.logger.exception, sError)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef updateFile(self, logical_file_name=[], is_file_valid=1, lost=0, dataset=''):\n        if lost in [1, True, 'True', 'true', '1', 'y', 'yes']:\n            lost = 1\n            if is_file_valid in [1, True, 'True', 'true', '1', 'y', 'yes']:\n                dbsExceptionHandler(\"dbsException-invalid-input2\", dbsExceptionCode[\"dbsException-invalid-input2\"], self.logger.exception,\\\n                                    \"Lost file must set to invalid\" )\n        else: lost = 0\n        \n        for f in logical_file_name, dataset:\n            if '*' in f or '%' in f:\n                dbsExceptionHandler(\"dbsException-invalid-input2\", dbsExceptionCode[\"dbsException-invalid-input2\"], self.logger.exception, \"No \\\n                    wildcard allow in LFN or dataset for updatefile API.\" )\n        try:\n            self.dbsFile.updateStatus(logical_file_name, is_file_valid, lost, dataset)\n        except HTTPError as he:\n            raise he\n        except Exception as ex:\n            sError = \"DBSWriterModel/updateFile. %s\\n. Exception trace: \\n %s\" \\\n                    % (ex, traceback.format_exc())\n            dbsExceptionHandler('dbsException-server-error',  dbsExceptionCode['dbsException-server-error'], self.logger.exception, sError)", "response": "API to update status of a file."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncreates a new record set from a CIDR string.", "response": "def create_from_string(cls, cidr, label=None, whitelist=False):\n        \"\"\"\n        Converts a CIDR like 192.168.0.0/24 into 2 parts:\n            start: 3232235520\n            stop: 3232235775\n        \"\"\"\n        network = netaddr.IPNetwork(cidr)\n        start = network.first\n        stop = start + network.size - 1\n        obj = cls.objects.create(label=label, start=start, stop=stop,\n                                 whitelist=whitelist)\n        return obj"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef qs_for_ip(cls, ip_str):\n        ip = int(netaddr.IPAddress(ip_str))\n\n        # ignore IPv6 addresses for now (4294967295 is 0xffffffff, aka the\n        # biggest 32-bit number)\n        if ip > 4294967295:\n            return cls.objects.none()\n\n        ip_range_query = {\n            'start__lte': ip,\n            'stop__gte': ip\n        }\n\n        return cls.objects.filter(**ip_range_query)", "response": "Returns a queryset with matching IPNetwork objects for the given IP."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns True if the provided IP is in the blacklist and does not exist in the whitelist. Otherwise return False.", "response": "def matches_ip(cls, ip_str, read_preference=None):\n        \"\"\"\n        Return True if provided IP exists in the blacklist and doesn't exist\n        in the whitelist. Otherwise, return False.\n        \"\"\"\n        qs = cls.qs_for_ip(ip_str).only('whitelist')\n        if read_preference:\n            qs = qs.read_preference(read_preference)\n\n        # Return True if any docs match the IP and none of them represent\n        # a whitelist\n        return bool(qs) and not any(obj.whitelist for obj in qs)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef execute(self, conn, block_id=\"\", transaction=False):\n        if not conn:\n            dbsExceptionHandler(\"dbsException-db-conn-failed\", \"Oracle/FileBuffer/List. Expects db connection from upper layer.\")\n\n\tsql = self.sql\n        binds = { \"block_id\" : block_id}\n        cursors = self.dbi.processData(sql, binds, conn, transaction, returnCursor=True)\n        result = self.formatCursor(cursors[0])\n        return result", "response": "Execute a read - only command."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a list of all primary datasets that match the given pattern.", "response": "def execute(self, conn, primary_ds_name=\"\", primary_ds_type=\"\", transaction=False):\n        \"\"\"\n        Lists all primary datasets if pattern is not provided.\n        \"\"\"\t\n        sql = self.sql\n        binds = {}\n        #import pdb\n        #pdb.set_trace()\n        if primary_ds_name and primary_ds_type in ('', None, '%'):\n            op = (\"=\", \"like\")[\"%\" in primary_ds_name]\n            sql += \"WHERE P.PRIMARY_DS_NAME %s :primary_ds_name\" % op\n            binds.update(primary_ds_name=primary_ds_name)\n        elif primary_ds_type and primary_ds_name in ('', None, '%'):\n            op = (\"=\", \"like\")[\"%\" in primary_ds_type]\n            sql += \"WHERE PT.PRIMARY_DS_TYPE %s :primary_ds_type\" % op\n            binds.update(primary_ds_type=primary_ds_type)\n        elif primary_ds_name and primary_ds_type:\n            op = (\"=\", \"like\")[\"%\" in primary_ds_name]\n            op1 = (\"=\", \"like\")[\"%\" in primary_ds_type]\n            sql += \"WHERE P.PRIMARY_DS_NAME %s :primary_ds_name and PT.PRIMARY_DS_TYPE %s :primary_ds_type\"\\\n                %(op, op1)\n            binds.update(primary_ds_name=primary_ds_name)\n            binds.update(primary_ds_type=primary_ds_type)\n        else:\n            pass\n\tcursors = self.dbi.processData(sql, binds, conn, transaction, returnCursor=True)\n        result = []\n        for c in cursors:\n            result.extend(self.formatCursor(c, size=100))\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef configure_proxy(self, curl_object):\n        curl_object.setopt(curl_object.PROXY, self._proxy_hostname)\n        curl_object.setopt(curl_object.PROXYPORT, self._proxy_port)\n        curl_object.setopt(curl_object.PROXYTYPE, curl_object.PROXYTYPE_SOCKS5)\n        if self._proxy_user and self._proxy_passwd:\n            curl_object.setopt(curl_object.PROXYUSERPWD, '%s:%s' % (self._proxy_user, self._proxy_port))", "response": "configure pycurl proxy settings"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ninsert a new entry in DB.", "response": "def execute( self, conn, daoinput, transaction = False ):\n        \"\"\"\n        daoinput must be validated to have the following keys:\n        child_parent_id__list[[cid, pid],...], block_name\n        \"\"\"\n        binds = {} \n        bindlist=[]\n        \n        if isinstance(daoinput, dict) and \"block_name\" in daoinput.keys():\n            binds = {\"block_name\": daoinput[\"block_name\"]}\n            r = self.dbi.processData(self.sql_sel, binds, conn, False)\n            bfile = self.format(r)\n            bfile_list = []\n            for f in bfile:\n                bfile_list.append(f[0])           \n            if \"child_parent_id_list\" in daoinput.keys():\n                files = []\n                for i in daoinput[\"child_parent_id_list\"]:\n                    files.append(i[0])\n                if set(files)-set(bfile_list):\n                    dbsExceptionHandler('dbsException-invalid-input2', \"Files required in the same block for FileParent/insert2 dao.\", self.logger.exception) \n            else:\n                dbsExceptionHandler('dbsException-invalid-input2', \"child_parent_id_list required for FileParent/insert2 dao.\", self.logger.exception) \n        else:\n            dbsExceptionHandler('dbsException-invalid-input2', \"Block_name required in the same block for FileParent/insert2 dao.\", self.logger.exception)\n        binds = {} \n        for pf in daoinput[\"child_parent_id_list\"]:\n            binds = {\"this_file_id\":pf[0], \"parent_file_id\": pf[1]}\n            bindlist.append(binds) \n        self.dbi.processData(self.sql, bindlist, conn, transaction)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef execute(self, conn, acquisition_era_name,end_date, transaction = False):\n\tif not conn:\n\t    dbsExceptionHandler(\"dbsException-failed-connect2host\", \"dbs/dao/Oracle/AcquisitionEra/updateEndDate expects db connection from upper layer.\", self.logger.exception)\n        binds = { \"acquisition_era_name\" :acquisition_era_name  , \"end_date\" : end_date  }\n        result = self.dbi.processData(self.sql, binds, conn, transaction)", "response": "Update the end date of a given acquisitionera"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nupdates the migration block and the related resources.", "response": "def execute(self, conn, daoinput, transaction = False):\n        \"\"\"\n\t    daoinput keys:\n\t    migration_status, migration_block_id, migration_request_id\n        \"\"\"\n        #print daoinput['migration_block_id']\n        if not conn:\n\t    dbsExceptionHandler(\"dbsException-failed-connect2host\", \"Oracle/MigrationBlock/Update. Expects db connection from upper layer.\" ,self.logger.exception)\n        if daoinput['migration_status'] == 1:\n           sql = self.sql + \"  (MIGRATION_STATUS = 0  or MIGRATION_STATUS = 3)\" \n        elif daoinput['migration_status'] == 2 or daoinput['migration_status'] == 3 or daoinput['migration_status'] == 9:\n            sql = self.sql + \" MIGRATION_STATUS = 1 \"\n        else: \n            dbsExceptionHandler(\"dbsException-conflict-data\", \"Oracle/MigrationBlock/Update. Expected migration status to be 1, 2, 3, 0r 9\" ,self.logger.exception ) \n        #print sql\n        if 'migration_request_id' in daoinput:\n            sql3 = sql + \"and MIGRATION_REQUEST_ID =:migration_request_id\"\n            result = self.dbi.processData(sql3, daoinput, conn, transaction)\n        elif 'migration_block_id' in daoinput:\n            if type(daoinput['migration_block_id']) is not list:\n                sql2 = sql+ \" and MIGRATION_BLOCK_ID =:migration_block_id\"\n                result = self.dbi.processData(sql2, daoinput, conn, transaction)\n            else:\n                bk_id_generator, binds2 =  create_token_generator(daoinput['migration_block_id']) \n                newdaoinput = {}\n                newdaoinput.update({\"migration_status\":daoinput[\"migration_status\"],\n                    \"last_modification_date\":daoinput[\"last_modification_date\"]})\n                newdaoinput.update(binds2)\n                sql2 = sql+ \"\"\" and MIGRATION_BLOCK_ID in ({bk_id_generator} SELECT TOKEN FROM TOKEN_GENERATOR)\n                            \"\"\".format(bk_id_generator=bk_id_generator)\n                result = self.dbi.processData(sql2, newdaoinput, conn, transaction)\n        else:\n            dbsExceptionHandler(\"dbsException-conflict-data\", \"Oracle/MigrationBlock/Update. Required IDs not in the input\", self.logger.exception)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets list of file_id from DB.", "response": "def execute(self, conn, file_id_list, transaction=False):\n\t\"\"\"\n\tfile_id_list : file_id_list \n\t\"\"\"\n\tsql=self.sql\n\tbinds={}\n\tif file_id_list:\n\t    count=0\n\t    for an_id in file_id_list:\n\t\tif count > 0: sql += \", \"\n\t\tsql += \":file_id_%s\" %count\n\t\tbinds.update({\"file_id_%s\" %count : an_id})\n\t\tcount+=1\n\t    sql += \")\"\n\telse:\n            dbsExceptionHandler('dbsException-invalid-input', \"Oracle/FileParentBlock/List. this_file_id not provided\", self.logger.exception)\n            \n        result = self.dbi.processData(sql, binds, conn, transaction)\n        plist = self.formatDict(result)\n\treturn plist"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nexecute the SQL query and returns the output module config id for the given application release version and global tag.", "response": "def execute(self, conn, app, release_version, pset_hash, output_label, global_tag, transaction = False):\n        \"\"\"\n        returns id for a given application\n\n        This always requires all four variables to be set, because\n        you better have them in blockInsert\n        \"\"\"\n        binds = {}\n        binds[\"app_name\"]=app\n        binds[\"release_version\"]=release_version\n        binds[\"pset_hash\"]=pset_hash\n        binds[\"output_module_label\"]=output_label\n        binds[\"global_tag\"]=global_tag\n\n        result = self.dbi.processData(self.sql, binds, conn, transaction)\n\n        plist = self.formatDict(result)\n\n\tif len(plist) < 1: return -1\n        return plist[0][\"output_mod_config_id\"]"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef updateStatus(self, block_name=\"\", open_for_writing=0):\n        if open_for_writing not in [1, 0, '1', '0']:\n            msg = \"DBSBlock/updateStatus. open_for_writing can only be 0 or 1 : passed %s.\"\\\n                   % open_for_writing \n            dbsExceptionHandler('dbsException-invalid-input', msg)\n        conn = self.dbi.connection()\n        trans = conn.begin()\n        try :\n            open_for_writing = int(open_for_writing)\n            self.updatestatus.execute(conn, block_name, open_for_writing, dbsUtils().getTime(), trans)\n            trans.commit()\n            trans = None\n        except Exception as ex:\n            if trans:\n                trans.rollback()\n            if conn:conn.close()\n            raise ex\n        finally:\n            if conn:conn.close()", "response": "Update status of a specific entry in DBS."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nupdates the origin_site_name for a given block name", "response": "def updateSiteName(self, block_name, origin_site_name):\n        \"\"\"\n        Update the origin_site_name for a given block name\n        \"\"\"\n        if not origin_site_name:\n            dbsExceptionHandler('dbsException-invalid-input',\n                                \"DBSBlock/updateSiteName. origin_site_name is mandatory.\")\n        conn = self.dbi.connection()\n        trans = conn.begin()\n        try:\n            self.updatesitename.execute(conn, block_name, origin_site_name)\n        except:\n            if trans:\n                trans.rollback()\n            raise\n        else:\n            if trans:\n                trans.commit()\n        finally:\n            if conn:\n                conn.close()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef listBlockParents(self, block_name=\"\"):\n        if not block_name:\n            msg = \" DBSBlock/listBlockParents. Block_name must be provided as a string or a list. \\\n                No wildcards allowed in block_name/s.\"\n            dbsExceptionHandler('dbsException-invalid-input', msg)\n        elif isinstance(block_name, basestring):\n            try:\n                block_name = str(block_name)\n                if '%' in block_name or '*' in block_name:\n                    dbsExceptionHandler(\"dbsException-invalid-input\", \"DBSReaderModel/listBlocksParents: \\\n                    NO WILDCARDS allowed in block_name.\")\n            except:\n                dbsExceptionHandler(\"dbsException-invalid-input\", \"DBSBlock/listBlockParents. Block_name must be \\\n                provided as a string or a list. No wildcards allowed in block_name/s .\")\n        elif type(block_name) is list:\n            for b in block_name:\n                if '%' in b or '*' in b:\n                    dbsExceptionHandler(\"dbsException-invalid-input\", \"DBSReaderModel/listBlocksParents: \\\n                            NO WILDCARDS allowed in block_name.\")\n        else:\n            msg = \"DBSBlock/listBlockParents. Block_name must be provided as a string or a list. \\\n                No wildcards allowed in block_name/s .\"\n            dbsExceptionHandler(\"dbsException-invalid-input\", msg)\n        conn = self.dbi.connection()\n        try:\n            results = self.blockparentlist.execute(conn, block_name)\n            return results\n        finally:\n            if conn:\n                conn.close()", "response": "API to list parents of a block."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nlists all parents of a block", "response": "def listBlockChildren(self, block_name=\"\"):\n        \"\"\"\n        list parents of a block\n        \"\"\"\n        if (not block_name) or re.search(\"['%','*']\", block_name):\n            dbsExceptionHandler(\"dbsException-invalid-input\", \"DBSBlock/listBlockChildren. Block_name must be provided.\" )\n        conn = self.dbi.connection()\n        try:\n            results = self.blockchildlist.execute(conn, block_name)\n            return results\n        finally:\n            if conn:\n                conn.close()"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef listBlocks(self, dataset=\"\", block_name=\"\", data_tier_name=\"\", origin_site_name=\"\",\n                   logical_file_name=\"\", run_num=-1, min_cdate=0, max_cdate=0,\n                   min_ldate=0, max_ldate=0, cdate=0,  ldate=0, open_for_writing=-1, detail=False):\n        \"\"\"\n        dataset, block_name, data_tier_name or logical_file_name must be passed.\n        \"\"\"\n        if (not dataset) or re.search(\"['%','*']\", dataset):\n            if (not block_name) or re.search(\"['%','*']\", block_name):\n                if (not logical_file_name) or re.search(\"['%','*']\", logical_file_name):\n                    if not data_tier_name or re.search(\"['%','*']\", data_tier_name):\n                        msg = \"DBSBlock/listBlock. You must specify at least one parameter(dataset, block_name,\\\n\t\t\t       \tdata_tier_name, logical_file_name) with listBlocks api\"\n                        dbsExceptionHandler('dbsException-invalid-input2', msg, self.logger.exception, msg)\n\n        if data_tier_name:\n            if not (min_cdate and max_cdate) or (max_cdate-min_cdate)>32*24*3600:\n                msg = \"min_cdate and max_cdate are mandatory parameters. If data_tier_name parameter is used \\\n                       the maximal time range allowed is 31 days\"\n                dbsExceptionHandler('dbsException-invalid-input2', msg, self.logger.exception, msg)\n            if detail:\n                msg = \"DBSBlock/listBlock. Detail parameter not allowed togther with data_tier_name\"\n                dbsExceptionHandler('dbsException-invalid-input2', msg, self.logger.exception, msg)\n\n        with self.dbi.connection() as conn:\n            dao = (self.blockbrieflist, self.blocklist)[detail]\n            for item in dao.execute(conn, dataset, block_name, data_tier_name, origin_site_name, logical_file_name, run_num,\n                                 min_cdate, max_cdate, min_ldate, max_ldate, cdate,  ldate):\n                yield item", "response": "API to list all blocks in DBS."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef insertBlock(self, businput):\n        if not (\"block_name\" in businput and \"origin_site_name\" in businput  ):\n            dbsExceptionHandler('dbsException-invalid-input', \"business/DBSBlock/insertBlock must have block_name and origin_site_name as input\")\n        conn = self.dbi.connection()\n        tran = conn.begin()\n        try:\n            blkinput = {\n                \"last_modification_date\":businput.get(\"last_modification_date\",  dbsUtils().getTime()),\n                #\"last_modified_by\":businput.get(\"last_modified_by\", dbsUtils().getCreateBy()),\n                \"last_modified_by\":dbsUtils().getCreateBy(),\n                #\"create_by\":businput.get(\"create_by\", dbsUtils().getCreateBy()),\n                \"create_by\":dbsUtils().getCreateBy(),\n                \"creation_date\":businput.get(\"creation_date\", dbsUtils().getTime()),\n                \"open_for_writing\":businput.get(\"open_for_writing\", 1),\n                \"block_size\":businput.get(\"block_size\", 0),\n                \"file_count\":businput.get(\"file_count\", 0),\n                \"block_name\":businput.get(\"block_name\"),\n                \"origin_site_name\":businput.get(\"origin_site_name\")\n            }\n            ds_name = businput[\"block_name\"].split('#')[0]\n            blkinput[\"dataset_id\"] = self.datasetid.execute(conn,  ds_name, tran)\n            if blkinput[\"dataset_id\"] == -1 : \n                msg = \"DBSBlock/insertBlock. Dataset %s does not exists\" % ds_name\n                dbsExceptionHandler('dbsException-missing-data', msg)\n            blkinput[\"block_id\"] =  self.sm.increment(conn, \"SEQ_BK\", tran)\n            self.blockin.execute(conn, blkinput, tran)\n\n            tran.commit()\n            tran = None\n        except Exception as e:\n            if str(e).lower().find(\"unique constraint\") != -1 or str(e).lower().find(\"duplicate\") != -1:\n                pass\n            else:\n                if tran:\n                    tran.rollback()\n                if conn: conn.close()\n                raise\n                \n        finally:\n            if tran:\n                tran.rollback()\n            if conn:\n                conn.close()", "response": "Insert a new block into DBS."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nlisting all data tiers in DBS.", "response": "def listDataTiers(self, data_tier_name=\"\"):\n        \"\"\"\n        List data tier(s)\n        \"\"\"\n        if not isinstance(data_tier_name, basestring) :\n            dbsExceptionHandler('dbsException-invalid-input',\n                                'data_tier_name given is not valid : %s' % data_tier_name)\n        else:\n            try:\n                data_tier_name = str(data_tier_name)\n            except:\n                dbsExceptionHandler('dbsException-invalid-input',\n                                    'data_tier_name given is not valid : %s' % data_tier_name)\n        conn = self.dbi.connection()\n        try:\n            result = self.dataTier.execute(conn, data_tier_name.upper())\n            return result\n        finally:\n            if conn:\n                conn.close()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a list of all the available types for the given site.", "response": "def execute(self, conn, site_name= \"\", transaction = False):\n        \"\"\"\n        Lists all sites types if site_name is not provided.\n        \"\"\"\n        sql = self.sql\n        if site_name == \"\":\n            result = self.dbi.processData(sql, conn=conn, transaction=transaction)\n        else:\n            sql += \"WHERE S.SITE_NAME = :site_name\" \n            binds = { \"site_name\" : site_name }\n            result = self.dbi.processData(sql, binds, conn, transaction)\n        return self.formatDict(result)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef listDataType(self, dataType=\"\", dataset=\"\"):\n        conn = self.dbi.connection()\n        try:\n            if dataset and dataType:\n                dbsExceptionHandler('dbsException-invalid-input',\n                    \"DBSDataType/listDataType. Data Type can be only searched by data_type or by dataset, not both.\")\n            else:\n                result = self.dataType.execute(conn, dataType, dataset)\n                return result\n        finally:\n            if conn:\n                conn.close()", "response": "List data type of a specific resource."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef getBlocks(self):\n        try:\n            conn = self.dbi.connection()\n            result = self.buflistblks.execute(conn)\n            return result\n        finally:\n            if conn:\n                conn.close()", "response": "Get the blocks that need to be migrated"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef getBufferedFiles(self, block_id):\n            \n        try:\n            conn = self.dbi.connection()\n            result = self.buflist.execute(conn, block_id)\n            return result\n        finally:\n            if conn:\n                conn.close()", "response": "Get some files from the insert buffer"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a list of all the items in the database that match the given datatier name", "response": "def execute(self, conn, data_tier_name='', transaction = False, cache=None):\n        \"\"\"\n        returns id for a given datatier name\n        \"\"\"\n\tif cache:\n            ret=cache.get(\"DATA_TIERS\")\n            if not ret==None:\n                return ret\n        sql = self.sql\n\tbinds={}\n\tif data_tier_name:\n            op = ('=', 'like')['%' in data_tier_name]\n\t    sql += \"WHERE DT.DATA_TIER_NAME %s :datatier\" %op \n\t    binds = {\"datatier\":data_tier_name}\n        result = self.dbi.processData(sql, binds, conn, transaction)\n        plist = self.formatDict(result)\n        return plist"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef execute(self, conn, migration_url=\"\", migration_input=\"\", create_by=\"\", migration_request_id=\"\", transaction=False):\n        binds = {}\n\tresult = self.dbi.processData(self.sql, binds, conn, transaction)\n        result = self.formatDict(result)\n\tif len(result) == 0 :\n\t    return []\n\tif result[0][\"migration_request_id\"] in ('', None) :\n\t    return []\n        return result", "response": "Executes the SQL query and returns the result."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a list of all processing eras in the database.", "response": "def listProcessingEras(self, processing_version=''):\n        \"\"\"\n        Returns all processing eras in dbs\n        \"\"\"\n        conn = self.dbi.connection()\n        try:\n            result = self.pelst.execute(conn, processing_version)\n            return result\n        finally:\n            if conn:\n                conn.close()"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef insertProcessingEra(self, businput):\n        conn = self.dbi.connection()\n        tran = conn.begin()\n        try:\n            businput[\"processing_era_id\"] = self.sm.increment(conn, \"SEQ_PE\", tran)\n            businput[\"processing_version\"] = businput[\"processing_version\"]\n            self.pein.execute(conn, businput, tran)\n            tran.commit()\n            tran = None\n        except KeyError as ke:\n            dbsExceptionHandler('dbsException-invalid-input',\n                                \"Invalid input:\" + ke.args[0])\n        except Exception as ex:\n            if (str(ex).lower().find(\"unique constraint\") != -1 or\n                str(ex).lower().find(\"duplicate\") != -1):\n                        # already exist\n                self.logger.warning(\"DBSProcessingEra/insertProcessingEras. \" +\n                                \"Unique constraint violation being ignored...\")\n                self.logger.warning(ex)\n            else:\n                if tran:\n                    tran.rollback()\n                    tran = None\n                raise\n        finally:\n            if tran:\n                tran.rollback()\n            if conn:\n                conn.close()", "response": "Insert a new processingEra into the database."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef listPhysicsGroups(self, physics_group_name=\"\"):\n        if not isinstance(physics_group_name, basestring):\n            dbsExceptionHandler('dbsException-invalid-input',\n                'physics group name given is not valid : %s' %\n                 physics_group_name)\n        else:\n            try:\n                physics_group_name = str(physics_group_name)\n            except:\n                 dbsExceptionHandler('dbsException-invalid-input',\n                                 'physics group name given is not valid : %s' %\n                                  physics_group_name)\n\n        conn = self.dbi.connection()\n        try:\n            result = self.pglist.execute(conn, physics_group_name)\n            return result\n        finally:\n            if conn:\n                conn.close()", "response": "Get all physics groups in DBS."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef create_token_generator(input_list):\n    ###Generator trick from http://betteratoracle.com/posts/20-how-do-i-bind-a-variable-in-list\n    ###The maximum length of the comma separated list is 4000 characters, therefore we need to split the list\n    ###ORA-01460: unimplemented or unreasonable conversion requested will thrown if list is larger\n    oracle_limit = 4000\n    grp_list = []\n    if type(input_list[0]) == int :\n        input_str = ','.join(map(str, input_list))\n    else:\n        input_str = ','.join(input_list) \n\n    if len(input_str) >= oracle_limit:\n        index = 0\n        while True:\n            begin, end = index, index+oracle_limit\n\t    if end > len(input_str):\n                end = len(input_str)\n                grp_list.append(input_str[begin:end])\n                break\n\t    else: \t\n\t\tindex = input_str.rfind(',', begin, end)\n\t\tif index == -1:\n\t\t\tbreak\n\t\tgrp_list.append(input_str[begin:index])\n\t\tindex += 1 #to remove the leading comma\n    else:\n        grp_list.append(input_str)\n\n    token_generator = \"\"\"\n    WITH TOKEN_GENERATOR AS (\n    \"\"\"\n    binds = {}\n    for index, chunk in enumerate(grp_list):\n        if index:\n            token_generator += \"\"\"\n            UNION ALL\n            \"\"\"\n        bind = \"token_%s\" % index\n        token_generator += \"\"\"SELECT REGEXP_SUBSTR(:{bind}, '[^,]+', 1, LEVEL) token\n        FROM DUAL\n        CONNECT BY LEVEL <= LENGTH(:{bind}) - LENGTH(REPLACE(:{bind}, ',', '')) + 1\n        \"\"\".format(bind=bind)\n        binds.update({bind: chunk})\n    token_generator += \")\"\n\n    return token_generator, binds", "response": "Create SQL Generator to select from list of values in Oracle"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef getServices(self):\n        try:\n            conn = self.dbi.connection()\n            result = self.serviceslist.execute(conn)\n            return result\n        except Exception as ex:\n            msg = ((\"%s DBSServicesRegistry/getServices.\" + \n                    \" %s\\n. Exception trace: \\n %s\") %\n                   (DBSEXCEPTIONS['dbsException-3'], ex,\n                    traceback.format_exc()))\n            self.logger.exception(msg )\n            raise Exception (\"dbsException-3\", msg )\n        finally:\n            conn.close()", "response": "Simple method that returns list of all known DBS instances"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nadds a service to the service registry", "response": "def addService(self):\n        \"\"\"\n        Add a service to service registry\n        \"\"\"\n\n        conn = self.dbi.connection()\n        tran = conn.begin()\n        try:\n            \n            body = request.body.read()\n            service = cjson.decode(body)\n            addthis = {}\n            addthis['service_id'] = self.sm.increment(conn, \"SEQ_RS\", tran)\n            addthis['name'] = service.get('NAME', '')\n            if addthis['name'] == '':\n                msg = ((\"%s DBSServicesRegistry/addServices.\" +\n                        \" Service Must be Named\\n\") %\n                       DBSEXCEPTIONS['dbsException-3'])\n                raise Exception(\"dbsException-3\", msg)\n            addthis['type'] = service.get('TYPE', 'GENERIC')\n            addthis['location'] = service.get('LOCATION', 'HYPERSPACE')\n            addthis['status'] = service.get('STATUS', 'UNKNOWN')\n            addthis['admin'] = service.get('ADMIN', 'UNADMINISTRATED')\n            addthis['uri'] = service.get('URI', '')\n            if addthis['uri'] == '':\n                msg = ((\"%s DBSServicesRegistry/addServices.\" + \n                        \" Service URI must be provided.\\n\") %\n                       DBSEXCEPTIONS['dbsException-3'])\n                self.logger.exception(msg)\n                raise Exception(\"dbsException-3\", msg)\n            addthis['db'] = service.get('DB', 'NO_DATABASE')\n            addthis['version'] = service.get('VERSION', 'UNKNOWN' )\n            addthis['last_contact'] = dbsUtils().getTime()\n            addthis['comments'] = service.get('COMMENTS', 'NO COMMENTS')\n            addthis['alias'] = service.get('ALIAS', 'No Alias')\n            self.servicesadd.execute(conn, addthis, tran)\n            tran.commit()\n        except exceptions.IntegrityError as ex:\n            if (str(ex).find(\"unique constraint\") != -1 or\n                str(ex).lower().find(\"duplicate\") != -1) :\n                #Update the service instead\n                try:\n                    self.servicesupdate.execute(conn, addthis, tran)\n                    tran.commit()\n                except Exception as ex:\n                    msg = ((\"%s DBSServiceRegistry/addServices.\" + \n                            \" %s\\n. Exception trace: \\n %s\") %\n                           (DBSEXCEPTIONS['dbsException-3'], ex,\n                            traceback.format_exc()))\n                    self.logger.exception(msg ) \n                    raise Exception (\"dbsException-3\", msg )\n        except Exception as ex:\n            tran.rollback()\n            msg = ((\"%s DBSServiceRegistry/addServices.\" + \n                    \" %s\\n. Exception trace: \\n %s\") %\n                   (DBSEXCEPTIONS['dbsException-3'], ex,\n                    traceback.format_exc()))\n            self.logger.exception(msg )\n            raise Exception (\"dbsException-3\", msg )\n        finally:\n            conn.close()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef execute(self, conn, daoinput, transaction = False):\n        if not conn:\n\t    dbsExceptionHandler(\"dbsException-failed-connect2host\", \"Oracle/MigrationRequests/UpdateRequestStatus. Expects db connection from upper layer.\", \n                                self.logger.exception)\n        if daoinput['migration_status'] == 1:\n           sql = self.sql2 \n        elif daoinput['migration_status'] == 2:\n            sql = self.sql + \" and MIGRATION_STATUS = 1 \"\n        elif daoinput['migration_status'] == 3:\n            sql = self.sql3 + \" and MIGRATION_STATUS = 1 \" \n        else:\n            dbsExceptionHandler(\"dbsException-conflict-data\", \"Oracle/MigrationRequest/UpdateRequestStatus. Expected migration status to be 1, 2 or 3\",\n                                self.logger.exception)\n        \n\tresult = self.dbi.processData(sql, daoinput, conn, transaction)", "response": "Update the migration request status."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nlists all the available migration resources.", "response": "def execute(self, conn, migration_url=\"\", migration_input=\"\", create_by=\"\", migration_request_id=\"\", oldest= False, transaction=False):\n        \"\"\"\n        Lists all requests if pattern is not provided.\n        \"\"\"\n        sql = self.sql\n        binds = {}\n\tif migration_request_id:\n\t    sql += \" WHERE MR.MIGRATION_REQUEST_ID=:migration_request_id\"\n\t    binds['migration_request_id']=migration_request_id\n        elif oldest:\n            #FIXME: Need to write the sql.YG\n            #current_date = dbsUtils().getTime()\n            #we require waiting time for \n            #retry_count=0 is 1 minutes\n            #retry_count=1 is 2 minutes\n            #retyr_count=2 is 4 minutes\n\n            sql += \"\"\"\n                       WHERE MR.MIGRATION_STATUS=0 \n                       or (MR.migration_status=3 and MR.retry_count=0 and MR.last_modification_date <= :current_date-60)    \n                       or (MR.migration_status=3 and MR.retry_count=1 and MR.last_modification_date <= :current_date-120)  \n                       or (MR.migration_status=3 and MR.retry_count=2 and MR.last_modification_date <= :current_date-240)\n                       ORDER BY MR.creation_date\n                   \"\"\" \n            binds['current_date'] = dbsUtils().getTime()\n            #print \"time= \" + str(binds['current_date'])\n        else:    \n\t    if  migration_url or migration_input or create_by:\n\t\tsql += \" WHERE \"\n\t    if migration_url:\n\t\tsql += \" MR.MIGRATION_URL=:migration_url\"\n\t\tbinds['migration_url']=migration_url\n\t    if  migration_input:\n\t\tif migration_url:\n\t\t    sql += \" AND \"\n\t\top = (\"=\", \"like\")[\"%\" in migration_input]\n\t\tsql += \" MR.MIGRATION_INPUT %s :migration_input\" % op\n\t\tbinds['migration_input']=migration_input\n\t    if create_by:\n\t\tif  migration_url or migration_input:\n\t\t    sql += \" AND \"\n\t\tsql += \" MR.CREATE_BY=:create_by\" %create_by\n\t\tbinds['create_by']=create_by\n\tcursors = self.dbi.processData(sql, binds, conn, transaction, returnCursor=True)\n        result = []\n        for c in cursors:\n            result.extend(self.formatCursor(c, size=100))\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef execute(self, conn, logical_file_name, transaction=False):\n\tif not conn:\n\t    dbsExceptionHandler(\"dbsException-db-conn-failed\", \"Oracle/FileBuffer/DeleteDupicates. Expects db connection from upper layer.\")\n\n\tprint(self.sql)\n        self.dbi.processData(self.sql, logical_file_name, conn, transaction)", "response": "Delete duplicate entries from DB."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets all the related resources for a given block.", "response": "def execute(self, conn, block_name=\"\", transaction = False):\n        \"\"\"\n        block: /a/b/c#d\n        \"\"\"\n        if not conn:\n\t    dbsExceptionHandler(\"dbsException-failed-connect2host\", \"Oracle/BlockParent/List. Expects db connection from upper layer.\", self.logger.exception)\n\n        sql = self.sql\n        \n\tif isinstance(block_name, basestring):\n\t    binds = {'block_name' :block_name}\n        elif type(block_name) is list:\n            binds = [{'block_name':x} for x in block_name]\n        else: \n            msg = \"Oracle/BlockParent/List. Block_name must be provided either as a string or as a list.\"\n            dbsExceptionHandler('dbsException-invalid-input', msg, self.logger.exception)\n\tresult = self.dbi.processData(sql, binds, conn, transaction)\n        return self.formatDict(result)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef execute(self, conn,  origin_site_name=\"\", dataset=\"\", block_name=\"\", transaction = False):\n        if not conn:\n            dbsExceptionHandler(\"dbsException-db-conn-failed\",\n                                \"Oracle/Block/List.  Expects db connection from upper layer.\", self.logger.exception)\n        binds = {}\n        if origin_site_name:\n            wheresql = 'WHERE B.ORIGIN_SITE_NAME = :origin_site_name'\n            binds.update(origin_site_name=origin_site_name)\n\n        if dataset:\n            if 'wheresql' in locals():\n                wheresql += ' AND DS.DATASET = :dataset'\n            else:\n                wheresql = 'WHERE DS.DATASET = :dataset'\n            binds.update(dataset=dataset)\n\n        if block_name:\n            if 'wheresql' in locals():\n                wheresql += ' AND B.BLOCK_NAME = :block_name'\n            else:\n                wheresql = 'WHERE B.BLOCK_NAME = :block_name'\n            binds.update(block_name=block_name)\n\n        sql = '{sql} {wheresql}'.format(sql=self.sql, wheresql=wheresql)\n\n        cursors = self.dbi.processData(sql, binds, conn, transaction, returnCursor=True)\n        result = []\n        for cursor in cursors:\n            result.extend(self.formatCursor(cursor, size=100))\n        return result", "response": "Returns list of all available buffer entries for a given origin site name dataset and block name."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef listPrimaryDatasets(self, primary_ds_name=\"\", primary_ds_type=\"\"):\n        conn = self.dbi.connection()\n        try:\n            result = self.primdslist.execute(conn, primary_ds_name, primary_ds_type)\n            if conn: conn.close()\n            return result\n        finally:\n            if conn:\n                conn.close()", "response": "Returns a list of all primary datasets."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef listPrimaryDSTypes(self, primary_ds_type=\"\", dataset=\"\"):\n        conn = self.dbi.connection()\n        try:\n            result = self.primdstypeList.execute(conn, primary_ds_type, dataset)\n            if conn: conn.close()\n            return result\n        finally:\n            if conn:\n                conn.close()", "response": "Returns a list of primary dataset types."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef insertPrimaryDataset(self, businput):\n        conn = self.dbi.connection()\n        tran = conn.begin()\n        #checking for required fields\n        if \"primary_ds_name\" not in businput:\n            dbsExceptionHandler(\"dbsException-invalid-input\",\n                \" DBSPrimaryDataset/insertPrimaryDataset. \" +\n                \"Primary dataset Name is required for insertPrimaryDataset.\")\n        try:\n            businput[\"primary_ds_type_id\"] = (self.primdstypeList.execute(conn, businput[\"primary_ds_type\"]\n                ))[0][\"primary_ds_type_id\"]\n            del businput[\"primary_ds_type\"]\n            businput[\"primary_ds_id\"] = self.sm.increment(conn, \"SEQ_PDS\")\n            self.primdsin.execute(conn, businput, tran)\n            tran.commit()\n            tran = None\n        except KeyError as ke:\n            dbsExceptionHandler(\"dbsException-invalid-input\",\n                \" DBSPrimaryDataset/insertPrimaryDataset. Missing: %s\" % ke)\n            self.logger.warning(\" DBSPrimaryDataset/insertPrimaryDataset. Missing: %s\" % ke)\n        except IndexError as ie:\n            dbsExceptionHandler(\"dbsException-missing-data\",\n                \" DBSPrimaryDataset/insertPrimaryDataset. %s\" % ie)\n            self.logger.warning(\" DBSPrimaryDataset/insertPrimaryDataset. Missing: %s\" % ie)\n        except Exception as ex:\n            if (str(ex).lower().find(\"unique constraint\") != -1 or\n                str(ex).lower().find(\"duplicate\") != -1):\n                self.logger.warning(\"DBSPrimaryDataset/insertPrimaryDataset:\" +\n                        \" Unique constraint violation being ignored...\")\n                self.logger.warning(ex)\n            else:\n                if tran:\n                    tran.rollback()\n                if conn: conn.close()\n                raise\n        finally:\n            if tran:\n                tran.rollback()\n            if conn:\n                conn.close()", "response": "Insert a new primary dataset into the database."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef execute(self, conn, name='', transaction = False):\n        binds={}\n        if name:\n            op = ('=', 'like')['%' in name]\n            sql = self.sql + \"  WHERE pg.physics_group_name %s :physicsgroup\" % (op)\n            binds = {\"physicsgroup\": name}\n        else:\n            sql = self.sql\n        self.logger.debug(sql)    \n        result = self.dbi.processData(sql, binds, conn, transaction)\n        plist = self.formatDict(result)\n        self.logger.debug(plist)\n\tif len(plist) < 1: return []\n        return plist", "response": "returns a list of physics group names"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef insertOutputConfig(self, businput):\n        if not (\"app_name\" in businput  and \"release_version\" in businput\\\n            and \"pset_hash\" in businput and \"output_module_label\" in businput\n            and \"global_tag\" in businput):\n            dbsExceptionHandler('dbsException-invalid-input', \"business/DBSOutputConfig/insertOutputConfig require:\\\n                app_name, release_version, pset_hash, output_module_label and global_tag\")\n\n        conn = self.dbi.connection()\n        tran = conn.begin()\n        try:\n            # Proceed with o/p module insertion\n            businput['scenario'] = businput.get(\"scenario\", None)\n            businput['pset_name'] = businput.get(\"pset_name\", None)\n            self.outmodin.execute(conn, businput, tran)\n            tran.commit()\n            tran = None\n        except SQLAlchemyIntegrityError as ex:\n            if str(ex).find(\"unique constraint\") != -1 or str(ex).lower().find(\"duplicate\") != -1:\n                #if the validation is due to a unique constrain break in OUTPUT_MODULE_CONFIGS\n                if str(ex).find(\"TUC_OMC_1\") != -1: pass\n                #otherwise, try again\n                else:\n                    try:\n                        self.outmodin.execute(conn, businput, tran)\n                        tran.commit()\n                        tran =  None\n                    except SQLAlchemyIntegrityError as ex1:\n                        if str(ex1).find(\"unique constraint\") != -1 and str(ex1).find(\"TUC_OMC_1\") != -1: pass\n                    except Exception as e1:\n                        if tran:\n                            tran.rollback()\n                            tran = None\n                        raise\n            else:\n                raise\n        except Exception as e:\n            if tran:\n                tran.rollback()\n            raise\n        finally:\n            if tran:\n                tran.rollback()\n            if conn:\n                conn.close()", "response": "Insert the Output Config into DBS."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets a list of supported REST APIs.", "response": "def getHelp(self, call=\"\"):\n        \"\"\"\n        API to get a list of supported REST APIs. In the case a particular API is specified,\n        the docstring of that API is displayed.\n\n        :param call: call to get detailed information about (Optional)\n        :type call: str\n        :return: List of APIs or detailed information about a specific call (parameters and docstring)\n        :rtype: List of strings or a dictionary containing params and doc keys depending on the input parameter\n\n        \"\"\"\n        if call:\n            params = self.methods['GET'][call]['args']\n            doc = self.methods['GET'][call]['call'].__doc__\n            return dict(params=params, doc=doc)\n        else:\n            return self.methods['GET'].keys()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef listDatasets(self, dataset=\"\", parent_dataset=\"\", is_dataset_valid=1,\n        release_version=\"\", pset_hash=\"\", app_name=\"\", output_module_label=\"\", global_tag=\"\",\n        processing_version=0, acquisition_era_name=\"\", run_num=-1,\n        physics_group_name=\"\", logical_file_name=\"\", primary_ds_name=\"\", primary_ds_type=\"\",\n        processed_ds_name='', data_tier_name=\"\", dataset_access_type=\"VALID\", prep_id='', create_by=\"\", last_modified_by=\"\",\n        min_cdate='0', max_cdate='0', min_ldate='0', max_ldate='0', cdate='0',\n        ldate='0', detail=False, dataset_id=-1):\n        \"\"\"\n        API to list dataset(s) in DBS\n        * You can use ANY combination of these parameters in this API\n        * In absence of parameters, all valid datasets known to the DBS instance will be returned\n\n        :param dataset:  Full dataset (path) of the dataset.\n        :type dataset: str\n        :param parent_dataset: Full dataset (path) of the dataset\n        :type parent_dataset: str\n        :param release_version: cmssw version\n        :type release_version: str\n        :param pset_hash: pset hash\n        :type pset_hash: str\n        :param app_name: Application name (generally it is cmsRun)\n        :type app_name: str\n        :param output_module_label: output_module_label\n        :type output_module_label: str\n        :param global_tag: global_tag\n        :type global_tag: str\n        :param processing_version: Processing Version\n        :type processing_version: str\n        :param acquisition_era_name: Acquisition Era\n        :type acquisition_era_name: str\n        :param run_num: Specify a specific run number or range. Possible format are: run_num, 'run_min-run_max' or ['run_min-run_max', run1, run2, ...]. run_num=1 is not allowed.\n        :type run_num: int,list,str\n        :param physics_group_name: List only dataset having physics_group_name attribute\n        :type physics_group_name: str\n        :param logical_file_name: List dataset containing the logical_file_name\n        :type logical_file_name: str\n        :param primary_ds_name: Primary Dataset Name\n        :type primary_ds_name: str\n        :param primary_ds_type: Primary Dataset Type (Type of data, MC/DATA)\n        :type primary_ds_type: str\n        :param processed_ds_name: List datasets having this processed dataset name\n        :type processed_ds_name: str\n        :param data_tier_name: Data Tier\n        :type data_tier_name: str\n        :param dataset_access_type: Dataset Access Type ( PRODUCTION, DEPRECATED etc.)\n        :type dataset_access_type: str\n        :param prep_id: prep_id\n        :type prep_id: str\n        :param create_by: Creator of the dataset\n        :type create_by: str\n        :param last_modified_by: Last modifier of the dataset\n        :type last_modified_by: str\n        :param min_cdate: Lower limit for the creation date (unixtime) (Optional)\n        :type min_cdate: int, str\n        :param max_cdate: Upper limit for the creation date (unixtime) (Optional)\n        :type max_cdate: int, str\n        :param min_ldate: Lower limit for the last modification date (unixtime) (Optional)\n        :type min_ldate: int, str\n        :param max_ldate: Upper limit for the last modification date (unixtime) (Optional)\n        :type max_ldate: int, str\n        :param cdate: creation date (unixtime) (Optional)\n        :type cdate: int, str\n        :param ldate: last modification date (unixtime) (Optional)\n        :type ldate: int, str\n        :param detail: List all details of a dataset\n        :type detail: bool\n        :param dataset_id: dataset table primary key used by CMS Computing Analytics.\n        :type dataset_id: int, long, str\n        :returns: List of dictionaries containing the following keys (dataset). If the detail option is used. The dictionary contain the following keys (primary_ds_name, physics_group_name, acquisition_era_name, create_by, dataset_access_type, data_tier_name, last_modified_by, creation_date, processing_version, processed_ds_name, xtcrosssection, last_modification_date, dataset_id, dataset, prep_id, primary_ds_type)\n        :rtype: list of dicts\n\n        \"\"\"\n        dataset = dataset.replace(\"*\", \"%\")\n        parent_dataset = parent_dataset.replace(\"*\", \"%\")\n        release_version = release_version.replace(\"*\", \"%\")\n        pset_hash = pset_hash.replace(\"*\", \"%\")\n        app_name = app_name.replace(\"*\", \"%\")\n        output_module_label = output_module_label.replace(\"*\", \"%\")\n        global_tag = global_tag.replace(\"*\", \"%\")\n        logical_file_name = logical_file_name.replace(\"*\", \"%\")\n        physics_group_name = physics_group_name.replace(\"*\", \"%\")\n        primary_ds_name = primary_ds_name.replace(\"*\", \"%\")\n        primary_ds_type = primary_ds_type.replace(\"*\", \"%\")\n        data_tier_name = data_tier_name.replace(\"*\", \"%\")\n        dataset_access_type = dataset_access_type.replace(\"*\", \"%\")\n        processed_ds_name = processed_ds_name.replace(\"*\", \"%\")\n        acquisition_era_name = acquisition_era_name.replace(\"*\", \"%\")\n        #processing_version =  processing_version.replace(\"*\", \"%\")\n        #create_by and last_modified_by have be full spelled, no wildcard will allowed.\n        #We got them from request head so they can be either HN account name or DN.\n        #This is depended on how an user's account is set up.\n        #\n        # In the next release we will require dataset has no wildcard in it. \n        # DBS will reject wildcard search with dataset name with listDatasets call. \n        # One should seperate the dataset into primary , process and datatier if any wildcard.\n        # YG Oct 26, 2016\n        # Some of users were overwhiled by the API change. So we split the wildcarded dataset in the server instead of by the client.\n        # YG Dec. 9 2016\n        #\n        # run_num=1 caused full table scan and CERN DBS reported some of the queries ran more than 50 hours\n        # We will disbale all the run_num=1 calls in DBS. Run_num=1 will be OK when logical_file_name is given.\n        # YG Jan. 15 2019\n        #\n        if (run_num != -1 and logical_file_name ==''):\n            for r in parseRunRange(run_num):\n                if isinstance(r, basestring) or isinstance(r, int) or isinstance(r, long):    \n                    if r == 1 or r == '1':\n                        dbsExceptionHandler(\"dbsException-invalid-input\", \"Run_num=1 is not a valid input.\",\n                                self.logger.exception)\n                elif isinstance(r, run_tuple):\n                    if r[0] == r[1]:\n                        dbsExceptionHandler('dbsException-invalid-input', \"DBS run range must be apart at least by 1.\", \n                          self.logger.exception)\n                    elif r[0] <= 1 <= r[1]:\n                        dbsExceptionHandler(\"dbsException-invalid-input\", \"Run_num=1 is not a valid input.\",\n                                self.logger.exception)     \n\n        if( dataset and ( dataset == \"/%/%/%\" or dataset== \"/%\" or dataset == \"/%/%\" ) ):\n            dataset=''\n        elif( dataset and ( dataset.find('%') != -1 ) ) :\n            junk, primary_ds_name, processed_ds_name, data_tier_name = dataset.split('/')\n            dataset = ''\n        if ( primary_ds_name == '%' ):\n            primary_ds_name = ''\n        if( processed_ds_name == '%' ):\n            processed_ds_name = ''\n        if ( data_tier_name == '%' ):\n            data_tier_name = ''\n\n        try:\n            dataset_id = int(dataset_id)\n        except:\n            dbsExceptionHandler(\"dbsException-invalid-input2\", \"Invalid Input for dataset_id that has to be an int.\",\n                                self.logger.exception, 'dataset_id has to be an int.')\n        if create_by.find('*')!=-1 or create_by.find('%')!=-1 or last_modified_by.find('*')!=-1\\\n                or last_modified_by.find('%')!=-1:\n            dbsExceptionHandler(\"dbsException-invalid-input2\", \"Invalid Input for create_by or last_modified_by.\\\n            No wildcard allowed.\",  self.logger.exception, 'No wildcards allowed for create_by or last_modified_by')\n        try:\n            if isinstance(min_cdate, basestring) and ('*' in min_cdate or '%' in min_cdate):\n                min_cdate = 0\n            else:\n                try:\n                    min_cdate = int(min_cdate)\n                except:\n                    dbsExceptionHandler(\"dbsException-invalid-input\", \"invalid input for min_cdate\")\n            \n            if isinstance(max_cdate, basestring) and ('*' in max_cdate or '%' in max_cdate):\n                max_cdate = 0\n            else:\n                try:\n                    max_cdate = int(max_cdate)\n                except:\n                    dbsExceptionHandler(\"dbsException-invalid-input\", \"invalid input for max_cdate\")\n            \n            if isinstance(min_ldate, basestring) and ('*' in min_ldate or '%' in min_ldate):\n                min_ldate = 0\n            else:\n                try:\n                    min_ldate = int(min_ldate)\n                except:\n                    dbsExceptionHandler(\"dbsException-invalid-input\", \"invalid input for min_ldate\")\n            \n            if isinstance(max_ldate, basestring) and ('*' in max_ldate or '%' in max_ldate):\n                max_ldate = 0\n            else:\n                try:\n                    max_ldate = int(max_ldate)\n                except:\n                    dbsExceptionHandler(\"dbsException-invalid-input\", \"invalid input for max_ldate\")\n            \n            if isinstance(cdate, basestring) and ('*' in cdate or '%' in cdate):\n                cdate = 0\n            else:\n                try:\n                    cdate = int(cdate)\n                except:\n                    dbsExceptionHandler(\"dbsException-invalid-input\", \"invalid input for cdate\")\n            \n            if isinstance(ldate, basestring) and ('*' in ldate or '%' in ldate):\n                ldate = 0\n            else:\n                try:\n                    ldate = int(ldate)\n                except:\n                    dbsExceptionHandler(\"dbsException-invalid-input\", \"invalid input for ldate\")\n        except dbsException as de:\n            dbsExceptionHandler(de.eCode, de.message, self.logger.exception, de.serverError)\n        except Exception as ex:\n            sError = \"DBSReaderModel/listDatasets.  %s \\n. Exception trace: \\n %s\" \\\n                % (ex, traceback.format_exc())\n            dbsExceptionHandler('dbsException-server-error', dbsExceptionCode['dbsException-server-error'], self.logger.exception, sError)\n\n        detail = detail in (True, 1, \"True\", \"1\", 'true')\n        try: \n            return self.dbsDataset.listDatasets(dataset, parent_dataset, is_dataset_valid, release_version, pset_hash,\n                app_name, output_module_label, global_tag, processing_version, acquisition_era_name, \n                run_num, physics_group_name, logical_file_name, primary_ds_name, primary_ds_type, processed_ds_name,\n                data_tier_name, dataset_access_type, prep_id, create_by, last_modified_by,\n                min_cdate, max_cdate, min_ldate, max_ldate, cdate, ldate, detail, dataset_id)\n        except dbsException as de:\n            dbsExceptionHandler(de.eCode, de.message, self.logger.exception, de.serverError)\n        except Exception as ex:\n            sError = \"DBSReaderModel/listdatasets. %s.\\n Exception trace: \\n %s\" % (ex, traceback.format_exc())\n            dbsExceptionHandler('dbsException-server-error', dbsExceptionCode['dbsException-server-error'], self.logger.exception, sError)", "response": "This function returns a list of all valid datasets in the DBS instance."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef listDatasetArray(self):\n        ret = []\n        try :\n            body = request.body.read()\n            if body:\n                data = cjson.decode(body)\n                data = validateJSONInputNoCopy(\"dataset\", data, read=True)\n                #Because CMSWEB has a 300 seconds responding time. We have to limit the array siz to make sure that\n                #the API can be finished in 300 second. \n                # YG Nov-05-2015\n                max_array_size = 1000\n                if ( 'dataset' in data.keys() and isinstance(data['dataset'], list) and len(data['dataset'])>max_array_size)\\\n                    or ('dataset_id' in data.keys() and isinstance(data['dataset_id'], list) and len(data['dataset_id'])>max_array_size):\n                    dbsExceptionHandler(\"dbsException-invalid-input\",\n                                        \"The Max list length supported in listDatasetArray is %s.\" %max_array_size, self.logger.exception)    \n                ret = self.dbsDataset.listDatasetArray(data)\n        except cjson.DecodeError as De:\n            dbsExceptionHandler('dbsException-invalid-input2', \"Invalid input\", self.logger.exception, str(De))\n        except dbsException as de:\n            dbsExceptionHandler(de.eCode, de.message, self.logger.exception, de.serverError)\n        except HTTPError as he:\n            raise he\n        except Exception as ex:\n            sError = \"DBSReaderModel/listDatasetArray. %s \\n Exception trace: \\n %s\" \\\n                    % (ex, traceback.format_exc())\n            dbsExceptionHandler('dbsException-server-error', dbsExceptionCode['dbsException-server-error'], self.logger.exception, sError)\n        for item in ret:\n                    yield item", "response": "API to list datasets in DBS."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef listBlocks(self, dataset=\"\", block_name=\"\", data_tier_name=\"\", origin_site_name=\"\",\n                   logical_file_name=\"\",run_num=-1, min_cdate='0', max_cdate='0',\n                   min_ldate='0', max_ldate='0', cdate='0',  ldate='0', open_for_writing=-1, detail=False):\n\n        \"\"\"\n        API to list a block in DBS. At least one of the parameters block_name, dataset, data_tier_name or\n        logical_file_name are required. If data_tier_name is provided, min_cdate and max_cdate have to be specified and\n        the difference in time have to be less than 31 days.\n\n        :param block_name: name of the block\n        :type block_name: str\n        :param dataset: dataset\n        :type dataset: str\n        :param data_tier_name: data tier\n        :type data_tier_name: str\n        :param logical_file_name: Logical File Name\n        :type logical_file_name: str\n        :param origin_site_name: Origin Site Name (Optional)\n        :type origin_site_name: str\n        :param open_for_writing: Open for Writting (Optional)\n        :type open_for_writing: int (0 or 1)\n        :param run_num: run_num numbers (Optional). Possible format are: run_num, 'run_min-run_max' or ['run_min-run_max', run1, run2, ...].\n        :type run_num: int, list of runs or list of run ranges\n        :param min_cdate: Lower limit for the creation date (unixtime) (Optional)\n        :type min_cdate: int, str\n        :param max_cdate: Upper limit for the creation date (unixtime) (Optional)\n        :type max_cdate: int, str\n        :param min_ldate: Lower limit for the last modification date (unixtime) (Optional)\n        :type min_ldate: int, str\n        :param max_ldate: Upper limit for the last modification date (unixtime) (Optional)\n        :type max_ldate: int, str\n        :param cdate: creation date (unixtime) (Optional)\n        :type cdate: int, str\n        :param ldate: last modification date (unixtime) (Optional)\n        :type ldate: int, str\n        :param detail: Get detailed information of a block (Optional)\n        :type detail: bool\n        :returns: List of dictionaries containing following keys (block_name). If option detail is used the dictionaries contain the following keys (block_id, create_by, creation_date, open_for_writing, last_modified_by, dataset, block_name, file_count, origin_site_name, last_modification_date, dataset_id and block_size)\n        :rtype: list of dicts\n\n        \"\"\"\n        # run_num=1 caused full table scan and CERN DBS reported some of the queries ran more than 50 hours\n        # We will disbale all the run_num=1 calls in DBS. Run_num=1 will be OK while logical_file_name is given.\n        # YG Jan. 15 2019\n        # \n        if (run_num != -1 and logical_file_name ==''):\n            for r in parseRunRange(run_num):\n                if isinstance(r, basestring) or isinstance(r, int) or isinstance(r, long):    \n                    if r == 1 or r == '1':\n                        dbsExceptionHandler(\"dbsException-invalid-input\", \"Run_num=1 is not a valid input.\",\n                                self.logger.exception)\n                elif isinstance(r, run_tuple):\n                    if r[0] == r[1]:\n                        dbsExceptionHandler(\"dbsException-invalid-input\", \"DBS run range must be apart at least by 1.\",\n                          self.logger.exception)\n                    elif r[0] <= 1 <= r[1]:\n                        dbsExceptionHandler(\"dbsException-invalid-input2\", \"Run_num=1 is not a valid input.\",\n                                self.logger.exception)\n        \n        dataset = dataset.replace(\"*\", \"%\")\n        block_name = block_name.replace(\"*\", \"%\")\n        logical_file_name = logical_file_name.replace(\"*\", \"%\")\n        origin_site_name = origin_site_name.replace(\"*\", \"%\")\n        #\n\tif isinstance(min_cdate, basestring) and ('*' in min_cdate or '%' in min_cdate):\n            min_cdate = 0\n        else:\n            try:\n                min_cdate = int(min_cdate)\n            except:\n                dbsExceptionHandler(\"dbsException-invalid-input\", \"invalid input for min_cdate\")\n        #\n        if isinstance(max_cdate, basestring) and ('*' in max_cdate or '%' in max_cdate):\n            max_cdate = 0\n        else:\n            try:\n                max_cdate = int(max_cdate)\n            except:\n                dbsExceptionHandler(\"dbsException-invalid-input\", \"invalid input for max_cdate\")\n        #\n        if isinstance(min_ldate, basestring) and ('*' in min_ldate or '%' in min_ldate):\n            min_ldate = 0\n        else:\n            try:\n                min_ldate = int(min_ldate)\n            except:\n                dbsExceptionHandler(\"dbsException-invalid-input\", \"invalid input for max_cdate\")\n        #\n\tif isinstance(max_ldate, basestring) and ('*' in max_ldate or '%' in max_ldate):\n            max_ldate = 0\n        else:\n            try:\n                max_ldate = int(max_ldate)\n            except:\n                dbsExceptionHandler(\"dbsException-invalid-input\", \"invalid input for max_ldate\")\n        #\n        if isinstance(cdate, basestring) and ('*' in cdate or '%' in cdate):\n            cdate = 0\n        else:\n            try:\n                cdate = int(cdate)\n            except:\n                dbsExceptionHandler(\"dbsException-invalid-input\", \"invalid input for cdate\")\n        #\n        if isinstance(cdate, basestring) and ('*' in ldate or '%' in ldate):\n            ldate = 0\n        else:\n            try:\n                ldate = int(ldate)\n            except:\n                dbsExceptionHandler(\"dbsException-invalid-input\", \"invalid input for ldate\")\n        #\n        detail = detail in (True, 1, \"True\", \"1\", 'true')\n        try:\n            b= self.dbsBlock.listBlocks(dataset, block_name, data_tier_name, origin_site_name, logical_file_name,\n                                  run_num, min_cdate, max_cdate, min_ldate, max_ldate, cdate, ldate, open_for_writing, detail)\n\t    #for item in b:\n\t\t#yield item\n\t    return b\t\n\texcept HTTPError:\n\t    raise\t\n\texcept dbsException as de:\n            dbsExceptionHandler(de.eCode, de.message, self.logger.exception, de.serverError)\n        except Exception as ex:\n            sError = \"DBSReaderModel/listBlocks. %s\\n. Exception trace: \\n %s\" \\\n                    % (ex, traceback.format_exc())\n            dbsExceptionHandler('dbsException-server-error', dbsExceptionCode['dbsException-server-error'], self.logger.exception, sError)", "response": "This method returns a list of all blocks in DBS."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef listBlockOrigin(self, origin_site_name=\"\",  dataset=\"\", block_name=\"\"):\n        try:\n            return self.dbsBlock.listBlocksOrigin(origin_site_name, dataset, block_name)\n        except dbsException as de:\n            dbsExceptionHandler(de.eCode, de.message, self.logger.exception, de.serverError)\n        except Exception as ex:\n            sError = \"DBSReaderModel/listBlocks. %s\\n. Exception trace: \\n %s\" \\\n                    % (ex, traceback.format_exc())\n            dbsExceptionHandler('dbsException-server-error', dbsExceptionCode['dbsException-server-error'],\n                                self.logger.exception, sError)", "response": "API to list blocks in origin_site_name."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef listBlockChildren(self, block_name=\"\"):\n        block_name = block_name.replace(\"*\", \"%\")\n        try:\n            return self.dbsBlock.listBlockChildren(block_name)\n        except dbsException as de:\n            dbsExceptionHandler(de.eCode, de.message, self.logger.exception, de.serverError)\n        except Exception as ex:\n            sError = \"DBSReaderModel/listBlockChildren. %s\\n. Exception trace: \\n %s\" % (ex, traceback.format_exc())\n            dbsExceptionHandler('dbsException-server-error', dbsExceptionCode['dbsException-server-error'], self.logger.exception, sError)", "response": "API to list block children."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef listBlockSummaries(self, block_name=\"\", dataset=\"\", detail=False):\n        if bool(dataset)+bool(block_name)!=1:\n            dbsExceptionHandler(\"dbsException-invalid-input2\",\n                                dbsExceptionCode[\"dbsException-invalid-input2\"],\n                                self.logger.exception,\n                                \"Dataset or block_names must be specified at a time.\")\n\n        if block_name and isinstance(block_name, basestring):\n            try:\n                block_name = [str(block_name)]\n            except:\n                dbsExceptionHandler(\"dbsException-invalid-input\", \"Invalid block_name for listBlockSummaries. \")\n\n        for this_block_name in block_name:\n            if re.search(\"[*, %]\", this_block_name):\n                dbsExceptionHandler(\"dbsException-invalid-input2\",\n                                    dbsExceptionCode[\"dbsException-invalid-input2\"],\n                                    self.logger.exception,\n                                    \"No wildcards are allowed in block_name list\")\n\n        if re.search(\"[*, %]\", dataset):\n            dbsExceptionHandler(\"dbsException-invalid-input2\",\n                                dbsExceptionCode[\"dbsException-invalid-input2\"],\n                                self.logger.exception,\n                                \"No wildcards are allowed in dataset\")\n        data = [] \n        try:\n            with self.dbi.connection() as conn:\n                data = self.dbsBlockSummaryListDAO.execute(conn, block_name, dataset, detail)\n        except dbsException as de:\n            dbsExceptionHandler(de.eCode, de.message, self.logger.exception, de.serverError)\n        except Exception as ex:\n            sError = \"DBSReaderModel/listBlockSummaries. %s\\n. Exception trace: \\n %s\" % (ex, traceback.format_exc())\n            dbsExceptionHandler('dbsException-server-error',\n                                dbsExceptionCode['dbsException-server-error'],\n                                self.logger.exception,\n                                sError)\n        for item in data:\n                    yield item", "response": "API that returns total size file count and event counts of a dataset or a list of blocks."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef listFiles(self, dataset = \"\", block_name = \"\", logical_file_name = \"\",\n        release_version=\"\", pset_hash=\"\", app_name=\"\", output_module_label=\"\",\n        run_num=-1, origin_site_name=\"\", lumi_list=\"\", detail=False, validFileOnly=0, sumOverLumi=0):\n        \"\"\"\n        API to list files in DBS. Either non-wildcarded logical_file_name, non-wildcarded dataset or non-wildcarded block_name is required.\n        The combination of a non-wildcarded dataset or block_name with an wildcarded logical_file_name is supported.\n\n        * For lumi_list the following two json formats are supported:\n            - [a1, a2, a3,]\n            - [[a,b], [c, d],]\n\t* lumi_list can be either a list of lumi section numbers as [a1, a2, a3,] or a list of lumi section range as [[a,b], [c, d],]. Thay cannot be mixed.\n        * If lumi_list is provided run only run_num=single-run-number is allowed\n\t* When lfn list is present, no run or lumi list is allowed.\n\n        *There are five dataset access types: VALID, INVALID, PRODUCTION, DEPRECATED and DELETED. \n        * One file status: IS_FILE_VALID: 1 or 0.\n        * When a dataset is INVALID/ DEPRECATED/ DELETED, DBS will consider all the files under it is invalid not matter what value is_file_valid has. \n          In general, when the dataset is in one of INVALID/ DEPRECATED/ DELETED, is_file_valid should all marked as 0, but some old DBS2 data was not.\n        * When Dataset is VALID/PRODUCTION, by default is_file_valid is all 1. But if individual file is invalid, then the file's is_file_valid is set to 0.\n        * DBS use this logical in its APIs that have validFileOnly variable.\n  \n        *There are five dataset access types: VALID, INVALID, PRODUCTION, DEPRECATED and DELETED. \n        * One file status: IS_FILE_VALID: 1 or 0.\n        * When a dataset is INVALID/ DEPRECATED/ DELETED, DBS will consider all the files under it is invalid not matter what value is_file_valid has. \n          In general, when the dataset is in one of INVALID/ DEPRECATED/ DELETED, is_file_valid should all marked as 0, but some old DBS2 data was not.\n        * When Dataset is VALID/PRODUCTION, by default is_file_valid is all 1. But if individual file is invalid, then the file's is_file_valid is set to 0.\n        * DBS use this logical in its APIs that have validFileOnly variable.\n\n        :param logical_file_name: logical_file_name of the file\n        :type logical_file_name: str\n        :param dataset: dataset\n        :type dataset: str\n        :param block_name: block name\n        :type block_name: str\n        :param release_version: release version\n        :type release_version: str\n        :param pset_hash: parameter set hash\n        :type pset_hash: str\n        :param app_name: Name of the application\n        :type app_name: str\n        :param output_module_label: name of the used output module\n        :type output_module_label: str\n        :param run_num: run , run ranges, and run list. Possible format are: run_num, 'run_min-run_max' or ['run_min-run_max', run1, run2, ...].\n        :type run_num: int, list, string\n        :param origin_site_name: site where the file was created\n        :type origin_site_name: str\n        :param lumi_list: List containing luminosity sections\n        :type lumi_list: list\n        :param detail: Get detailed information about a file\n        :type detail: bool\n        :param validFileOnly: default=0 return all the files. when =1, only return files with is_file_valid=1 or dataset_access_type=PRODUCTION or VALID\n        :type validFileOnly: int\n        :param sumOverLumi: default=0 event_count is the event_count/file.  When sumOverLumi=1 and run_num is specified, the event_count is sum of the event_count/lumi for that run; When sumOverLumi = 1, no other input can be a list, for example no run_num list, lumi list or lfn list.\n        :type sumOverLumi: int\n        :returns: List of dictionaries containing the following keys (logical_file_name). If detail parameter is true, the dictionaries contain the following keys (check_sum, branch_hash_id, adler32, block_id, event_count, file_type, create_by, logical_file_name, creation_date, last_modified_by, dataset, block_name, file_id, file_size, last_modification_date, dataset_id, file_type_id, auto_cross_section, md5, is_file_valid)\n        :rtype: list of dicts\n\n        \"\"\"\n        logical_file_name = logical_file_name.replace(\"*\", \"%\")\n        release_version = release_version.replace(\"*\", \"%\")\n        pset_hash = pset_hash.replace(\"*\", \"%\")\n        app_name = app_name.replace(\"*\", \"%\")\n        block_name = block_name.replace(\"*\", \"%\")\n        origin_site_name = origin_site_name.replace(\"*\", \"%\")\n        dataset = dataset.replace(\"*\", \"%\")\n        #\n        # run_num=1 caused full table scan and CERN DBS reported some of the queries ran more than 50 hours\n        # We will disbale all the run_num=1 calls in DBS. Run_num=1 will be OK when logical_file_name is given.\n        # YG Jan. 15 2019\n        #\n        if (run_num != -1 and logical_file_name ==''):\n            for r in parseRunRange(run_num):\n                if isinstance(r, basestring) or isinstance(r, int) or isinstance(r, long):    \n                    if r == 1 or r == '1':\n                        dbsExceptionHandler(\"dbsException-invalid-input\", \"Run_num=1 is not a valid input.\",\n                                self.logger.exception)\n                elif isinstance(r, run_tuple):\n                    if r[0] == r[1]:\n                        dbsExceptionHandler(\"dbsException-invalid-input\", \"DBS run range must be apart at least by 1.\",\n                          self.logger.exception)\n                    elif r[0] <= 1 <= r[1]:\n                        dbsExceptionHandler(\"dbsException-invalid-input\", \"Run_num=1 is not a valid input.\",\n                                self.logger.exception)\n        if lumi_list:\n            if run_num ==-1 or not run_num :\n                dbsExceptionHandler(\"dbsException-invalid-input\", \"When lumi_list is given, require a single run_num.\", self.logger.exception)\n            elif sumOverLumi == 1:\n                 dbsExceptionHandler(\"dbsException-invalid-input\", \"lumi_list and sumOverLumi=1 cannot be set at the same time becaue nesting of WITH clause within WITH clause not supported yet by Oracle. \", self.logger.exception)\n            else:\n                try:\n                    lumi_list = self.dbsUtils2.decodeLumiIntervals(lumi_list)\n                except Exception as de:\n                    dbsExceptionHandler(\"dbsException-invalid-input\", \"Invalid lumi_list input: \"+ str(de), self.logger.exception)\n        else:\n            if not isinstance(run_num, list):\n                if run_num ==1 or run_num == '1':\n                    dbsExceptionHandler(\"dbsException-invalid-input\", \"files API does not supprt run_num=1 when no lumi.\", self.logger.exception)\n            else:\n                if 1 in run_num or '1' in run_num :\n                 dbsExceptionHandler(\"dbsException-invalid-input\", \"files API does not supprt run_num=1 when no lumi.\", self.logger.exception)\n        if int(sumOverLumi) == 1 and (isinstance(run_num, list) or isinstance(logical_file_name, list)):\n            dbsExceptionHandler(\"dbsException-invalid-input\", \"When sumOverLumi=1, no lfn list or run_num list allowed  becaue nesting of WITH clause within WITH clause not supported yet by Oracle. \", self.logger.exception)\n        detail = detail in (True, 1, \"True\", \"1\", 'true')\n        output_module_label = output_module_label.replace(\"*\", \"%\")\n        try:\n            result =  self.dbsFile.listFiles(dataset, block_name, logical_file_name, release_version, pset_hash, app_name,\n                                        output_module_label, run_num, origin_site_name, lumi_list, detail, \n                                        validFileOnly, sumOverLumi)\n    \t    for item in result:\n\t\tyield item\t\n\texcept HTTPError as he:\n\t    raise he\n        except dbsException as de:\n            dbsExceptionHandler(de.eCode, de.message, self.logger.exception, de.serverError)\n        except Exception as ex:\n            sError = \"DBSReaderModel/listFiles. %s \\n Exception trace: \\n %s\" % (ex, traceback.format_exc())\n            dbsExceptionHandler('dbsException-server-error', ex.message,\n                    self.logger.exception, sError)", "response": "This is a helper method to list files in DBS."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef listFileSummaries(self, block_name='', dataset='', run_num=-1, validFileOnly=0, sumOverLumi=0):\n        # run_num=1 caused full table scan and CERN DBS reported some of the queries ran more than 50 hours\n        # We will disbale all the run_num=1 calls in DBS.\n        # YG Jan. 16 2019\n        #\n        if (run_num != -1)  :\n            for r in parseRunRange(run_num):\n                if isinstance(r, basestring) or isinstance(r, int) or isinstance(r, long):    \n                    if r == 1 or r == '1':\n                        dbsExceptionHandler(\"dbsException-invalid-input\", \"Run_num=1 is not a valid input.\",\n                                self.logger.exception)\n                elif isinstance(r, run_tuple):\n                    if r[0] == r[1]:\n                        dbsExceptionHandler('dbsException-invalid-input', \"DBS run range must be apart at least by 1.\",\n                          self.logger.exception)\n                    elif r[0] <= 1 <= r[1]:\n                        dbsExceptionHandler(\"dbsException-invalid-input\", \"Run_num=1 is not a valid input.\",\n                                self.logger.exception)\n        try:\n            r = self.dbsFile.listFileSummary(block_name, dataset, run_num, validFileOnly=validFileOnly, sumOverLumi=sumOverLumi)\n\t    for item in r:\n\t\tyield item\t\n\texcept HTTPError as he:\n\t    raise he\n        except dbsException as de:\n            dbsExceptionHandler(de.eCode, de.message, self.logger.exception, de.serverError)\n\texcept HTTPerror as he:\n\t    raise he\n        except Exception as ex:\n            sError = \"DBSReaderModel/listFileSummaries. %s\\n. Exception trace: \\n %s\" \\\n                    % (ex, traceback.format_exc())\n            dbsExceptionHandler('dbsException-server-error', ex.message, self.logger.exception, sError)", "response": "This function returns a list of dicts containing the number of files event counts and number of lumis in a given block or dataset."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef listDatasetParents(self, dataset=''):\n        try:\n            return self.dbsDataset.listDatasetParents(dataset)\n        except dbsException as de:\n            dbsExceptionHandler(de.eCode, de.message, self.logger.exception, de.serverError)\n        except Exception as ex:\n            sError = \"DBSReaderModel/listDatasetParents. %s\\n. Exception trace: \\n %s\" \\\n                    % (ex, traceback.format_exc())\n            dbsExceptionHandler('dbsException-server-error', dbsExceptionCode['dbsException-server-error'], self.logger.exception, sError)", "response": "API to list Dataset Parents in DBS."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef listFileParents(self, logical_file_name='', block_id=0, block_name=''):\n        try:\n            r = self.dbsFile.listFileParents(logical_file_name, block_id, block_name)\n\t    for item in r:\n\t\tyield item\t\n        except HTTPError as he:\n\t    raise he\n        except dbsException as de:\n            dbsExceptionHandler(de.eCode, de.message, self.logger.exception, de.serverError)\n        except Exception as ex:\n            sError = \"DBSReaderModel/listFileParents. %s\\n. Exception trace: \\n %s\" \\\n                    % (ex, traceback.format_exc())\n            dbsExceptionHandler('dbsException-server-error', ex.message,  self.logger.exception, sError)", "response": "API to list file parents of a file"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef listFileParentsByLumi(self):\n        try :\n            body = request.body.read()\n            if body:\n                data = cjson.decode(body)\n                data = validateJSONInputNoCopy('file_parent_lumi', data, read=True)\n            else:\n                data = {}\n\n            #Because CMSWEB has a 300 seconds responding time. We have to limit the array siz to make sure that\n            #the API can be finished in 300 second. \n            max_array_size = 1000\n            if ('logical_file_name' in data.keys() and isinstance(data['logical_file_name'], list) and len(data['logical_file_name'])>max_array_size):\n                dbsExceptionHandler(\"dbsException-invalid-input\",\n                                        \"The Max list length supported in listFilePArentsByLumi is %s.\" %max_array_size, self.logger.exception)\n\n            lfn = []\n            if \"block_name\" not in data.keys():\n                 dbsExceptionHandler('dbsException-invalid-input', \"block_name is required for fileparentsbylumi\")\n            else:\n                if \"logical_file_name\" in data.keys():\n                    lfn = data[\"logical_file_name\"]\n            result = self.dbsFile.listFileParentsByLumi(block_name=data[\"block_name\"], logical_file_name=lfn)\n            for r in result:\n                yield r\n        except cjson.DecodeError as De:\n            dbsExceptionHandler('dbsException-invalid-input2', \"Invalid input\", self.logger.exception, str(De))\n        except dbsException as de:\n            dbsExceptionHandler(de.eCode, de.message, self.logger.exception, de.serverError)\n        except HTTPError as he:\n            raise he\n        except Exception as ex:\n            sError = \"DBSReaderModel/listFileParentsByLumi. %s \\n Exception trace: \\n %s\" \\\n            % (ex, traceback.format_exc())\n            dbsExceptionHandler('dbsException-server-error', ex.message, self.logger.exception, sError)", "response": "This method returns a list of file parents for a given block with or w/o a list of LFN."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef listFileChildren(self, logical_file_name='', block_name='', block_id=0):\n        if isinstance(logical_file_name, list):\n            for f in logical_file_name:\n                if '*' in f or '%' in f:\n                    dbsExceptionHandler(\"dbsException-invalid-input2\", dbsExceptionCode[\"dbsException-invalid-input2\"], self.logger.exception, \"No \\\n                                         wildcard allow in LFN list\" )\n\n        try:\n            return self.dbsFile.listFileChildren(logical_file_name, block_name, block_id)\n        except dbsException as de:\n            dbsExceptionHandler(de.eCode, de.message, self.logger.exception, de.serverError)\n        except Exception as ex:\n            sError = \"DBSReaderModel/listFileChildren. %s\\n. Exception trace: \\n %s\" \\\n                    % (ex, traceback.format_exc())\n            dbsExceptionHandler('dbsException-server-error', dbsExceptionCode['dbsException-server-error'], self.logger.exception, sError)", "response": "API to list file children. One of the parameters in mandatory."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef listFileLumis(self, logical_file_name=\"\", block_name=\"\", run_num=-1, validFileOnly=0):\n        # run_num=1 caused full table scan and CERN DBS reported some of the queries ran more than 50 hours\n        # We will disbale all the run_num=1 calls in DBS. Run_num=1 will be OK when logical_file_name is given.\n        # YG Jan. 16 2019\n        if (run_num != -1  and logical_file_name ==''):\n            for r in parseRunRange(run_num):\n                if isinstance(r, basestring) or isinstance(r, int) or isinstance(r, long):    \n                    if r == 1 or r == '1':\n                        dbsExceptionHandler(\"dbsException-invalid-input\", \"Run_num=1 is not a valid input.\",\n                                self.logger.exception)\n                elif isinstance(r, run_tuple):\n                    if r[0] == r[1]:\n                        dbsExceptionHandler(\"dbsException-invalid-input\", \"DBS run range must be apart at least by 1.\",self.logger.exception)\n                    elif r[0] <= 1 <= r[1]:\n                        dbsExceptionHandler(\"dbsException-invalid-input\", \"Run_num=1 is not a valid input.\",\n                                self.logger.exception) \n        try:\n            return self.dbsFile.listFileLumis(logical_file_name, block_name, run_num, validFileOnly )\n        except dbsException as de:\n            dbsExceptionHandler(de.eCode, de.message, self.logger.exception, de.serverError)\n        except Exception as ex:\n            sError = \"DBSReaderModel/listFileLumis. %s\\n. Exception trace: \\n %s\" \\\n                    % (ex, traceback.format_exc())\n            dbsExceptionHandler('dbsException-server-error', dbsExceptionCode['dbsException-server-error'], self.logger.exception, sError)", "response": "API to list Lumi for files."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef listDataTypes(self, datatype=\"\", dataset=\"\"):\n        try:\n            return  self.dbsDataType.listDataType(dataType=datatype, dataset=dataset)\n        except dbsException as de:\n            dbsExceptionHandler(de.eCode, de.message, self.logger.exception, de.serverError)\n        except Exception as ex:\n            sError = \"DBSReaderModel/listDataTypes. %s\\n. Exception trace: \\n %s\" \\\n                    % (ex, traceback.format_exc())\n            dbsExceptionHandler('dbsException-server-error', dbsExceptionCode['dbsException-server-error'], self.logger.exception, sError)", "response": "API to list data types known to DBS."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef listDatasetAccessTypes(self, dataset_access_type=''):\n        if dataset_access_type:\n            dataset_access_type = dataset_access_type.replace(\"*\", \"%\")\n        try:\n            return self.dbsDatasetAccessType.listDatasetAccessTypes(dataset_access_type)\n        except dbsException as de:\n            dbsExceptionHandler(de.eCode, de.message, self.logger.exception, de.serverError)\n        except Exception as ex:\n            sError = \"DBSReaderModel/listDatasetAccessTypes. %s\\n. Exception trace: \\n %s\" \\\n                    % (ex, traceback.format_exc())\n            dbsExceptionHandler('dbsException-server-error', dbsExceptionCode['dbsException-server-error'], self.logger.exception, sError)", "response": "API to list dataset access types."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef list():\n    entries = lambder.list_events()\n    for e in entries:\n        click.echo(str(e))", "response": "List all events in a resource group"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef add(name, function_name, cron):\n    lambder.add_event(name=name, function_name=function_name, cron=cron)", "response": "Add an event to the current container."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nloading events from a json file", "response": "def load(file):\n    \"\"\" Load events from a json file \"\"\"\n    with open(file, 'r') as f:\n        contents = f.read()\n    lambder.load_events(contents)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef functions(context):\n    # find lambder.json in CWD\n    config_file = \"./lambder.json\"\n    if os.path.isfile(config_file):\n        context.obj = FunctionConfig(config_file)\n    pass", "response": "Manage AWS Lambda functions"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef new(\n    name,\n    bucket,\n    timeout,\n    memory,\n    description,\n    subnet_ids,\n    security_group_ids\n):\n    \"\"\" Create a new lambda project \"\"\"\n    config = {}\n    if timeout:\n        config['timeout'] = timeout\n    if memory:\n        config['memory'] = memory\n    if description:\n        config['description'] = description\n    if subnet_ids:\n        config['subnet_ids'] = subnet_ids\n    if security_group_ids:\n        config['security_group_ids'] = security_group_ids\n\n    lambder.create_project(name, bucket, config)", "response": "Create a new lambda project"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef deploy(\n    config,\n    name,\n    bucket,\n    timeout,\n    memory,\n    description,\n    subnet_ids,\n    security_group_ids\n):\n    \"\"\" Deploy/Update a function from a project directory \"\"\"\n    # options should override config if it is there\n    myname = name or config.name\n    mybucket = bucket or config.bucket\n    mytimeout = timeout or config.timeout\n    mymemory = memory or config.memory\n    mydescription = description or config.description\n    mysubnet_ids = subnet_ids or config.subnet_ids\n    mysecurity_group_ids = security_group_ids or config.security_group_ids\n\n    vpc_config = {}\n    if mysubnet_ids and mysecurity_group_ids:\n        vpc_config = {\n            'SubnetIds': mysubnet_ids.split(','),\n            'SecurityGroupIds': mysecurity_group_ids.split(',')\n        }\n\n    click.echo('Deploying {} to {}'.format(myname, mybucket))\n    lambder.deploy_function(\n        myname,\n        mybucket,\n        mytimeout,\n        mymemory,\n        mydescription,\n        vpc_config\n    )", "response": "Deploy a function from a project directory"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ndeletes lambda function role and zipfile", "response": "def rm(config, name, bucket):\n    \"\"\" Delete lambda function, role, and zipfile \"\"\"\n    # options should override config if it is there\n    myname = name or config.name\n    mybucket = bucket or config.bucket\n\n    click.echo('Deleting {} from {}'.format(myname, mybucket))\n    lambder.delete_function(myname, mybucket)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef invoke(config, name, input):\n    # options should override config if it is there\n    myname = name or config.name\n\n    click.echo('Invoking ' + myname)\n    output = lambder.invoke_function(myname, input)\n    click.echo(output)", "response": "Invoke a function in AWS"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef putBlock(self, blockcontent, migration=False):\n        #YG\n        try:\n            #1 insert configuration\n            self.logger.debug(\"insert configuration\")\n            configList = self.insertOutputModuleConfig(\n                            blockcontent['dataset_conf_list'], migration)\n            #2 insert dataset\n            self.logger.debug(\"insert dataset\")\n            datasetId = self.insertDataset(blockcontent, configList, migration)\n            #3 insert block & files\n            self.logger.debug(\"insert block & files.\")\n            self.insertBlockFile(blockcontent, datasetId, migration)\n        except KeyError as ex:\n            dbsExceptionHandler(\"dbsException-invalid-input2\", \"DBSBlockInsert/putBlock: \\\n                KeyError exception: %s. \" %ex.args[0], self.logger.exception, \n\t        \"DBSBlockInsert/putBlock: KeyError exception: %s. \" %ex.args[0]\t)\n        except Exception as ex:\n            raise", "response": "Insert the data in sereral steps and commit when each step finishes or rollback when there is a problem."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ninsert the output module config into the database.", "response": "def insertOutputModuleConfig(self, remoteConfig, migration=False):\n        \"\"\"\n        Insert Release version, application, parameter set hashes and the map(output module config).\n\n        \"\"\"\n        otptIdList = []\n        missingList = []\n        conn = self.dbi.connection()\n        try:\n            for c in remoteConfig:\n                cfgid = self.otptModCfgid.execute(conn, app = c[\"app_name\"],\n                                      release_version = c[\"release_version\"],\n                                      pset_hash = c[\"pset_hash\"],\n                                      output_label = c[\"output_module_label\"],\n                                      global_tag=c['global_tag'])\n                if cfgid <= 0 :\n                    missingList.append(c)\n                else:\n                    key = (c['app_name'] + ':' + c['release_version'] + ':' +\n                           c['pset_hash'] + ':' +\n                           c['output_module_label'] + ':' + c['global_tag'])\n                    self.datasetCache['conf'][key] = cfgid\n                    otptIdList.append(cfgid)\n                    #print \"About to set cfgid: %s\" % str(cfgid)\n        except KeyError as ex:\n            if conn:conn.close()\n            dbsExceptionHandler(\"dbsException-invalid-input2\", \"DBSBlockInsert/insertOutputModuleConfig: \\\n                KeyError exception: %s. \" %ex.args[0], self.logger.exception,\n\t        \"DBSBlockInsert/insertOutputModuleConfig: KeyError exception: %s. \" %ex.args[0]\t)\n        except Exception as ex:\n            if conn:conn.close()\n            raise\n\n        if len(missingList)==0:\n            if conn:conn.close()\n            return otptIdList\n        #Now insert the missing configs\n        try:\n            #tran = conn.begin()\n            for m in missingList:\n                # Start a new transaction\n                # This is to see if we can get better results\n                # by committing early if we're submitting\n                # multiple blocks with similar features\n                tran = conn.begin()\n                #Now insert the config\n                # Sort out the mess\n                # We're having some problems with different threads\n                # committing different pieces at the same time\n                # This makes the output module config ID wrong\n                # Trying to catch this via exception handling on duplication\n                # Start a new transaction\n                #global_tag is now required. YG 03/08/2011\n                try:\n                    cfgid = 0\n                    if not migration:\n                        m['create_by'] = dbsUtils().getCreateBy()\n                        m['creation_date'] = dbsUtils().getTime()\n                    configObj = {\"release_version\": m[\"release_version\"],\n                                 \"pset_hash\": m[\"pset_hash\"], \"pset_name\":m.get('pset_name', None),\n                                 \"app_name\": m[\"app_name\"],\n                                 'output_module_label' : m['output_module_label'],\n                                 'global_tag' : m['global_tag'],\n                                 'scenario' : m.get('scenario', None),\n                                 'creation_date' : m['creation_date'],\n                                 'create_by':m['create_by']\n                                  }\n                    self.otptModCfgin.execute(conn, configObj, tran)\n                    tran.commit()\n                    tran = None\n                except KeyError as ex:\n                    if tran:tran.rollback()\n                    if conn:conn.close()\n                    dbsExceptionHandler(\"dbsException-invalid-input2\", \"DBSBlockInsert/insertOutputModuleConfig: \\\n                                         KeyError exception: %s. \" %ex.args[0],\n\t\t\t\t\t self.logger.exception, \n\t\t\t\t\t\"DBSBlockInsert/insertOutputModuleConfig: KeyError exception: %s. \" %ex.args[0])\n                except exceptions.IntegrityError as ex:\n                    #Another job inserted it just 1/100000 second earlier than\n                    #you!!  YG 11/17/2010\n                    if str(ex).find(\"ORA-00001\") != -1 or str(ex).lower().find(\"duplicate\") !=-1:\n                        if str(ex).find(\"TUC_OMC_1\") != -1:\n                            #the config is already in db, get the ID later\n                            pass\n                        else:\n                            #reinsert it if one or two or three of the three attributes (vresion, hash and app) are inserted\n                            #just 1/100000 second eailer.\n                            try:\n                                self.otptModCfgin.execute(conn, configObj, tran)\n                                tran.commit()\n                                tran = None\n                            except exceptions.IntegrityError as ex:\n                                if (str(ex).find(\"ORA-00001\") != -1 and str(ex).find(\"TUC_OMC_1\"))\\\n                                        or str(ex).lower().find(\"duplicate\") != -1:\n                                    pass\n                                else:\n                                    if tran:tran.rollback()\n                                    if conn:conn.close()\n                                    dbsExceptionHandler('dbsException-invalid-input2',\n                                        'Invalid data when insert Configure. ',\n                                        self.logger.exception,\n                                        'Invalid data when insert Configure. '+ str(ex))\n                    elif str(ex).find(\"ORA-01400\") > -1:\n                        if tran:tran.rollback()\n                        if conn:conn.close()\n                        dbsExceptionHandler(\"dbsException-missing-data\", \"Missing data when inserting Configure. \", \n\t\t\t\tself.logger.exception, str(ex))\n                    else:\n                        if tran:tran.rollback()\n                        if conn:conn.close()\n                        dbsExceptionHandler('dbsException-invalid-input2',\n                            'Invalid data when insert Configure. ',\n                            self.logger.exception,\n                            'Invalid data when insert Configure. '+ str(ex))\n                except exceptions as ex3:\n                    if tran:tran.rollback()\n                    if conn:conn.close()\n                    raise ex3\n                cfgid = self.otptModCfgid.execute(conn,\n                                    app = m[\"app_name\"],\n                                    release_version = m[\"release_version\"],\n                                    pset_hash = m[\"pset_hash\"],\n                                    output_label = m[\"output_module_label\"],\n                                    global_tag=m['global_tag'])\n                otptIdList.append(cfgid)\n                key = (m['app_name'] + ':' + m['release_version'] + ':' +\n                       m['pset_hash'] + ':' +m['output_module_label'] + ':' +\n                       m['global_tag'])\n                self.datasetCache['conf'][key] = cfgid\n        finally:\n            if tran:tran.rollback()\n            if conn:conn.close()\n        return otptIdList"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ninsert a new dataset and only the ones that are not already in the database.", "response": "def insertDatasetWOannex(self, dataset, blockcontent, otptIdList, conn,\n                             insertDataset = True, migration = False):\n        \"\"\"\n        _insertDatasetOnly_\n\n        Insert the dataset and only the dataset\n        Meant to be called after everything else is put into place.\n\n        The insertDataset flag is set to false if the dataset already exists\n        \"\"\"\n\n        tran = conn.begin()\n        try:\n            #8 Finally, we have everything to insert a dataset\n            if insertDataset:\n                # Then we have to get a new dataset ID\n                dataset['dataset_id'] = self.datasetid.execute(conn,\n                                                dataset['dataset'])\n                if dataset['dataset_id'] <= 0:\n                    dataset['dataset_id'] = self.sm.increment(conn, \"SEQ_DS\")\n                    if not migration:\n                        dataset['last_modified_by'] = dbsUtils().getCreateBy()\n                        dataset['create_by'] = dbsUtils().getCreateBy()\n                        dataset['creation_date'] = dataset.get('creation_date', dbsUtils().getTime())\n                        dataset['last_modification_date'] = dataset.get('last_modification_date', dbsUtils().getTime())\n                    dataset['xtcrosssection'] = dataset.get('xtcrosssection', None)\n                    dataset['prep_id'] = dataset.get('prep_id', None)\n                    try:\n                        self.datasetin.execute(conn, dataset, tran)\n                    except exceptions.IntegrityError as ei:\n                        if str(ei).find(\"ORA-00001\") != -1 or str(ei).lower().find(\"duplicate\") !=-1:\n                            if conn.closed:\n                                conn = self.dbi.connection()\n                            dataset['dataset_id'] = self.datasetid.execute(conn, dataset['dataset'])\n                            if dataset['dataset_id'] <= 0:\n                                if tran:tran.rollback()\n                                if conn:conn.close()\n                                dbsExceptionHandler('dbsException-conflict-data',\n                                                    'Dataset/[processed DS]/[dataset access type] not yet inserted by concurrent insert. ',\n                                                    self.logger.exception,\n                                                    'Dataset/[processed DS]/[dataset access type] not yet inserted by concurrent insert. '+ str(ei))\n                        elif str(ei).find(\"ORA-01400\") > -1:\n                            if tran:tran.rollback()\n                            if conn:conn.close()\n                            dbsExceptionHandler('dbsException-missing-data',\n                                'Missing data when insert Datasets. ',\n                                self.logger.exception,\n                                'Missing data when insert Datasets. '+ str(ei))\n                        else:\n                            if tran: tran.rollback()\n                            if conn: conn.close()\n                            dbsExceptionHandler('dbsException-invalid-input2',\n                            'Invalid data when insert Datasets. ',\n                            self.logger.exception,\n                            'Invalid data when insert Datasets. '+ str(ei))\n\n                    except Exception:\n                        #should catch all above exception to rollback. YG Jan 17, 2013\n                        if tran:tran.rollback()\n                        if conn:conn.close()\n                        raise\n\n            #9 Fill Dataset Parentage\n            #All parentage are deduced from file parentage.\n\n            #10 Before we commit, make dataset and output module configuration\n            #mapping.  We have to try to fill the map even if dataset is\n            #already in dest db\n            for c in otptIdList:\n                try:\n                    dcObj = {\n                             'dataset_id' : dataset['dataset_id'],\n                             'output_mod_config_id' : c }\n                    self.dcin.execute(conn, dcObj, tran)\n                except exceptions.IntegrityError as ei:\n                    #FIXME YG 01/17/2013\n                    if (str(ei).find(\"ORA-00001\") != -1 and str(ei).find(\"TUC_DC_1\") != -1) or \\\n                            str(ei).lower().find(\"duplicate\")!=-1:\n                    #ok, already in db\n                    #FIXME: What happens when there are partially in db?\n                    #YG 11/17/2010\n                        pass\n                    else:\n                        if tran:tran.rollback()\n                        if conn:conn.close()\n                        dbsExceptionHandler('dbsException-invalid-input2',\n                            'Invalid data when insert dataset_configs. ',\n                            self.logger.exception,\n                            'Invalid data when insert dataset_configs. '+ str(ei))\n                except Exception as ex:\n                    if tran:tran.rollback()\n                    if conn:conn.close()\n                    raise\n            #Now commit everything.\n            tran.commit()\n        except exceptions.IntegrityError as ei:\n            # Then is it already in the database?\n            # Not really. We have to check it again. YG Jan 17, 2013\n            # we don't check the unique key here, since there are more than one unique key might\n            # be violated: such as data_tier, processed_dataset, dataset_access_types.\n            if str(ei).find(\"ORA-00001\") != -1 or str(ei).lower().find(\"duplicate\")!=-1:\n                # For now, we assume most cases are the same dataset was instered by different thread. If not,\n                # one has to call the insert dataset again. But we think this is a rare case and let the second\n                # DBSBlockInsert call fix it if it happens.\n                if conn.closed:\n                    conn = self.dbi.connection()\n                dataset_id = self.datasetid.execute(conn, dataset['dataset'])\n                if dataset_id <= 0:\n                    dbsExceptionHandler('dbsException-conflict-data',\n                                        'Dataset not yet inserted by concurrent insert',\n                                        self.logger.exception,\n                                        'Dataset not yet inserted by concurrent insert')\n\n                else:\n                    dataset['dataset_id'] = dataset_id\n            else:\n                if tran:tran.rollback()\n                if conn:conn.close()\n                dbsExceptionHandler('dbsException-invalid-input2',\n                    'Invalid data when insert Datasets. ',\n                    self.logger.exception,\n                    'Invalid data when insert Datasets. '+ str(ei))\n        except Exception as ex:\n            if tran:tran.rollback()\n            if conn:conn.close()\n            raise\n        finally:\n            if tran:tran.rollback()\n            if conn:conn.close()\n        return dataset['dataset_id']"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a list of all the sites in the database.", "response": "def listSites(self, block_name=\"\", site_name=\"\"):\n        \"\"\"\n        Returns sites.\n        \"\"\"\n        try:\n            conn = self.dbi.connection()\n            if block_name:\n                result = self.blksitelist.execute(conn, block_name)\n            else:\n                result = self.sitelist.execute(conn, site_name)\n            return result\n        finally:\n            if conn:\n                conn.close()"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ninserts a new site into the database.", "response": "def insertSite(self, businput):\n        \"\"\"\n        Input dictionary has to have the following keys:\n        site_name\n        it builds the correct dictionary for dao input and executes the dao\n        \"\"\"\n        conn = self.dbi.connection()\n        tran = conn.begin()\n        try:\n            siteobj = { # FIXME: unused?\n                \"site_name\" : businput[\"site_name\"]\n            }\n            businput[\"site_id\"] = self.sm.increment(conn, \"SEQ_SI\", tran)\n            self.sitein.execute(conn, businput, tran)\n            tran.commit()\n        except Exception as ex:\n            if (str(ex).lower().find(\"unique constraint\") != -1 or\n                str(ex).lower().find(\"duplicate\") != -1):\n                # already exists, lets fetch the ID\n                self.logger.warning(\"Ignoring unique constraint violation\")\n                self.logger.warning(ex)\n            else:\n                if tran:\n                    tran.rollback()\n                self.logger.exception(ex)\n                raise\n        finally:\n            if tran:\n                tran.close()\n            if conn:\n                conn.close()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate the DAS mapping for the current user.", "response": "def _create_das_mapping(self):\n        \"\"\"\n        das_map = {'lookup' : [{params : {'param1' : 'required', 'param2' : 'optional', 'param3' : 'default_value' ...},\n                                url : 'https://cmsweb.cern.ch:8443/dbs/prod/global/DBSReader/acquisitioneras/',\n                                das_map : {'das_param1' : dbs_param1, ...}\n                                }]\n                                }\n        \"\"\"\n        with open(self._mapfile, 'r') as f:\n            for entry in yaml.load_all(f):\n                das2dbs_param_map = {}\n                if 'lookup' not in entry:\n                    continue\n                for param_map in entry['das_map']:\n                    if 'api_arg' in param_map:\n                        das2dbs_param_map[param_map['das_key']] = param_map['api_arg']\n\n                self._das_map.setdefault(entry['lookup'], []).append({'params' : entry['params'],\n                                                                     'url' : entry['url'],\n                                                                     'das2dbs_param_map' : das2dbs_param_map})"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn an iterator of the list of the specified size", "response": "def slicedIterator(sourceList, sliceSize):\n    \"\"\"\n    :param: sourceList: list which need to be sliced\n    :type: list\n    :param: sliceSize: size of the slice\n    :type: int\n    :return: iterator of the sliced list\n    \"\"\"\n    start = 0\n    end = 0\n\n    while len(sourceList) > end:\n        end = start + sliceSize\n        yield sourceList[start: end]\n        start = end"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nchecking input parameters for the API call.", "response": "def checkInputParameter(method, parameters, validParameters, requiredParameters=None):\n    \"\"\"\n    Helper function to check input by using before sending to the server\n\n    :param method: Name of the API\n    :type method: str\n    :param validParameters: Allow parameters for the API call\n    :type validParameters: list\n    :param requiredParameters: Required parameters for the API call (Default: None)\n    :type requiredParameters: list\n\n    \"\"\"\n    for parameter in parameters:\n        if parameter not in validParameters:\n            raise dbsClientException(\"Invalid input\",\n                                     \"API %s does not support parameter %s. Supported parameters are %s\" \\\n                                     % (method, parameter, validParameters))\n\n    if requiredParameters is not None:\n        if 'multiple' in requiredParameters:\n            match = False\n            for requiredParameter in requiredParameters['multiple']:\n                if requiredParameter!='detail' and requiredParameter in parameters:\n                    match = True\n                    break\n            if not match:\n                raise dbsClientException(\"Invalid input\",\n                                         \"API %s does require one of the parameters %s\" \\\n                                         % (method, requiredParameters['multiple']))\n\n        if 'forced' in requiredParameters:\n            for requiredParameter in requiredParameters['forced']:\n                if requiredParameter not in parameters:\n                    raise dbsClientException(\"Invalid input\",\n                                             \"API %s does require the parameter %s. Forced required parameters are %s\" \\\n                                             % (method, requiredParameter, requiredParameters['forced']))\n\n        if 'standalone' in requiredParameters:\n            overlap = []\n            for requiredParameter in requiredParameters['standalone']:\n                if requiredParameter in parameters:\n                    overlap.append(requiredParameter)\n            if len(overlap) !=  1:\n                raise dbsClientException(\"Invalid input\",\n                                         \"API %s does requires only *one* of the parameters %s.\" \\\n                                         % (method, requiredParameters['standalone']))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef list_parameter_splitting(data, key, size_limit=8000, method='GET'):\n    values = list(data[key])\n    data[key] = []\n\n    for element in values:\n        data[key].append(element)\n        if method =='GET':\n            size = len(urllib.urlencode(data))\n        else:\n            size = len(data)\n        if size > size_limit:\n            last_element = data[key].pop()\n            yield data\n            data[key] = [last_element]\n\n    yield data", "response": "Helper function to split list of url parameters into list of lists of url parameters."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef __callServer(self, method=\"\", params={}, data={}, callmethod='GET', content='application/json'):\n        UserID = os.environ['USER']+'@'+socket.gethostname()\n        try:\n            UserAgent = \"DBSClient/\"+os.environ['DBS3_CLIENT_VERSION']+\"/\"+ self.userAgent\n        except:\n            UserAgent = \"DBSClient/Unknown\"+\"/\"+ self.userAgent\n        request_headers =  {\"Content-Type\": content, \"Accept\": content, \"UserID\": UserID, \"User-Agent\":UserAgent }\n\n        method_func = getattr(self.rest_api, callmethod.lower())\n\n        data = cjson.encode(data)\n\n        try:\n            self.http_response = method_func(self.url, method, params, data, request_headers)\n        except HTTPError as http_error:\n            self.__parseForException(http_error)\n\n        if content != \"application/json\":\n            return self.http_response.body\n\n        try:\n            json_ret=cjson.decode(self.http_response.body)\n        except cjson.DecodeError:\n            print(\"The server output is not a valid json, most probably you have a typo in the url.\\n%s.\\n\" % self.url, file=sys.stderr)\n            raise dbsClientException(\"Invalid url\", \"Possible urls are %s\" %self.http_response.body)\n\n        return json_ret", "response": "This method is used to make a HTTP call to the DBS Server."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nparse the response from the server to raise an exception.", "response": "def __parseForException(self, http_error):\n        \"\"\"\n        An internal method, should not be used by clients\n\n        :param httperror: Thrown httperror by the server\n        \"\"\"\n        data = http_error.body\n        try:\n            if isinstance(data, str):\n                data = cjson.decode(data)\n        except:\n            raise http_error\n\n        if isinstance(data, dict) and 'exception' in data:# re-raise with more details\n            raise HTTPError(http_error.url, data['exception'], data['message'], http_error.header, http_error.body)\n\n        raise http_error"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the time needed to process the request by the frontend server in microseconds and the EPOC timestamp of the request.", "response": "def requestTimingInfo(self):\n        \"\"\"\n        Returns the time needed to process the request by the frontend server in microseconds\n        and the EPOC timestamp of the request in microseconds.\n\n        :rtype: tuple containing processing time and timestamp\n        \"\"\"\n        try:\n            return tuple(item.split('=')[1] for item in self.http_response.header.get('CMS-Server-Time').split())\n        except AttributeError:\n            return None, None"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef listFileParentsByLumi(self, **kwargs):\n        validParameters = ['block_name', 'logical_file_name']\n\n        requiredParameters = {'forced': ['block_name']}\n        checkInputParameter(method=\"listFileParentsByLumi\", parameters=kwargs.keys(), validParameters=validParameters,\n                            requiredParameters=requiredParameters)\n        return self.__callServer(\"fileparentsbylumi\", data=kwargs, callmethod='POST')", "response": "This method returns a list of dicts containing the cid and pid of the files who s parents need to be found under the specified lumi section info."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef listBlockParents(self, **kwargs):\n        validParameters = ['block_name']\n\n        requiredParameters = {'forced': validParameters}\n        checkInputParameter(method=\"listBlockParents\", parameters=kwargs.keys(), validParameters=validParameters,\n                            requiredParameters=requiredParameters)\n        if isinstance(kwargs[\"block_name\"], list):\n            return self.__callServer(\"blockparents\", data=kwargs, callmethod='POST')\n        else:\n            return self.__callServer(\"blockparents\", params=kwargs)", "response": "API to list block parents."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef listBlocks(self, **kwargs):\n        validParameters = ['dataset', 'block_name', 'data_tier_name', 'origin_site_name',\n                           'logical_file_name', 'run_num', 'open_for_writing', 'min_cdate',\n                           'max_cdate', 'min_ldate', 'max_ldate',\n                           'cdate', 'ldate', 'detail']\n\n        #requiredParameters = {'multiple': validParameters}\n        requiredParameters = {'multiple': ['dataset', 'block_name', 'data_tier_name', 'logical_file_name']}\n\n        #set defaults\n        if 'detail' not in kwargs.keys():\n            kwargs['detail'] = False\n\n        checkInputParameter(method=\"listBlocks\", parameters=kwargs.keys(), validParameters=validParameters,\n                            requiredParameters=requiredParameters)\n\n        return self.__callServer(\"blocks\", params=kwargs)", "response": "This method returns a list of all the blocks in DBS."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef listDatasets(self, **kwargs):\n        validParameters = ['dataset', 'parent_dataset', 'is_dataset_valid',\n                           'release_version', 'pset_hash', 'app_name',\n                           'output_module_label', 'processing_version', 'acquisition_era_name',\n                           'run_num', 'physics_group_name', 'logical_file_name',\n                           'primary_ds_name', 'primary_ds_type', 'processed_ds_name', 'data_tier_name',\n                           'dataset_access_type', 'prep_id', 'create_by', 'last_modified_by',\n                           'min_cdate', 'max_cdate', 'min_ldate', 'max_ldate', 'cdate', 'ldate',\n                           'detail', 'dataset_id']\n\n        #set defaults\n        if 'detail' not in kwargs.keys():\n            kwargs['detail'] = False\n\n        checkInputParameter(method=\"listDatasets\", parameters=kwargs.keys(), validParameters=validParameters)\n\n        return self.__callServer(\"datasets\", params=kwargs)", "response": "This method returns a list of all the datasets in the DBS instance."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef listDatasetArray(self, **kwargs):\n        validParameters = ['dataset', 'dataset_access_type', 'detail', 'dataset_id']\n\trequiredParameters = {'multiple': ['dataset', 'dataset_id']}\n\n        checkInputParameter(method=\"listDatasetArray\", parameters=kwargs.keys(), validParameters=validParameters,\n                            requiredParameters=requiredParameters)\n\n        #set defaults\n        if 'detail' not in kwargs.keys():\n            kwargs['detail'] = False\n\n        return self.__callServer(\"datasetlist\", data=kwargs, callmethod='POST')", "response": "This method returns a list of datasets in DBS."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef listFileArray(self, **kwargs):\n        validParameters = ['dataset', 'block_name', 'logical_file_name',\n                          'release_version', 'pset_hash', 'app_name',\n                          'output_module_label', 'run_num',\n                          'origin_site_name', 'lumi_list', 'detail', 'validFileOnly', 'sumOverLumi']\n\n        requiredParameters = {'multiple': ['dataset', 'block_name', 'logical_file_name']}\n\n        #set defaults\n        if 'detail' not in kwargs.keys():\n            kwargs['detail'] = False\n\n        checkInputParameter(method=\"listFileArray\", parameters=kwargs.keys(), validParameters=validParameters,\n                            requiredParameters=requiredParameters)\n        # In order to protect DB and make sure the query can be return in 300 seconds, we limit the length of \n        # logical file names, lumi and run num to 1000. These number may be adjusted later if \n        # needed. YG   May-20-2015.\n\n        # CMS has all MC data with run_num=1. It almost is a full table scan if run_num=1 without lfn. So we will request lfn\n        # to be present when run_num=1. YG Jan 14, 2016\n        if 'logical_file_name' in kwargs.keys() and isinstance(kwargs['logical_file_name'], list)\\\n            and len(kwargs['logical_file_name']) > 1:\n            if 'run_num' in kwargs.keys() and isinstance(kwargs['run_num'],list) and len(kwargs['run_num']) > 1 :\n                raise dbsClientException('Invalid input', 'files API does not supprt two lists: run_num and lfn. ')\n            elif 'lumi_list' in kwargs.keys() and kwargs['lumi_list'] and len(kwargs['lumi_list']) > 1 :\n                raise dbsClientException('Invalid input', 'files API does not supprt two lists: lumi_lis and lfn. ')\n                \n        elif 'lumi_list' in kwargs.keys() and kwargs['lumi_list']:\n            if 'run_num' not in kwargs.keys() or not kwargs['run_num'] or kwargs['run_num'] ==-1 :\n                raise dbsClientException('Invalid input', 'When Lumi section is present, a single run is required. ')\n        else:\n            if 'run_num' in kwargs.keys():\n                if isinstance(kwargs['run_num'], list):\n                    if 1 in kwargs['run_num'] or '1' in kwargs['run_num']:\n                        raise dbsClientException('Invalid input', 'files API does not supprt run_num=1 when no lumi.')\n                else:\n                    if kwargs['run_num']==1 or kwargs['run_num']=='1':\n                        raise dbsClientException('Invalid input', 'files API does not supprt run_num=1 when no lumi.')\n\n        #check if no lfn is given, but run_num=1 is used for searching\n        if ('logical_file_name' not in kwargs.keys() or not kwargs['logical_file_name']) and 'run_num' in kwargs.keys():\n            if isinstance(kwargs['run_num'], list):\n                if 1 in kwargs['run_num'] or '1' in kwargs['run_num']:\n                    raise dbsClientException('Invalid input', 'files API does not supprt run_num=1 without logical_file_name.')\n            else:\n                if kwargs['run_num'] == 1 or kwargs['run_num'] == '1':\n                    raise dbsClientException('Invalid input', 'files API does not supprt run_num=1 without logical_file_name.')\n        \n        results = []\n        mykey = None\n        total_lumi_len = 0\n        split_lumi_list = []\n        max_list_len = 1000 #this number is defined in DBS server\n        for key, value in kwargs.iteritems():\n            if key == 'lumi_list' and isinstance(kwargs['lumi_list'], list)\\\n                and kwargs['lumi_list'] and isinstance(kwargs['lumi_list'][0], list):\n                lapp = 0\n                l = 0\n                sm = []\n                for i in kwargs['lumi_list']:\n                    while i[0]+max_list_len < i[1]:\n                        split_lumi_list.append([[i[0], i[0]+max_list_len-1]])\n                        i[0] = i[0] + max_list_len\n                    else:\n                        l += (i[1]-i[0]+1)\n                        if l <=  max_list_len:\n                            sm.append([i[0], i[1]])\n                            lapp = l  #number lumis in sm\n                        else:\n                            split_lumi_list.append(sm)\n                            sm=[]\n                            sm.append([i[0], i[1]])\n                            lapp = i[1]-i[0]+1\n                if sm:\n                    split_lumi_list.append(sm)\n            elif key in ('logical_file_name', 'run_num', 'lumi_list') and isinstance(value, list) and len(value)>max_list_len:\n                mykey =key\n#\n        if mykey:  \n            sourcelist = []\n            #create a new list to slice\n            sourcelist = kwargs[mykey][:]\n            for slice in slicedIterator(sourcelist, max_list_len):\n                kwargs[mykey] = slice\n                results.extend(self.__callServer(\"fileArray\", data=kwargs, callmethod=\"POST\"))\n        elif split_lumi_list:\n            for item in split_lumi_list:\n                kwargs['lumi_list'] = item\n                results.extend(self.__callServer(\"fileArray\", data=kwargs, callmethod=\"POST\"))\n        else:\n            return self.__callServer(\"fileArray\", data=kwargs, callmethod=\"POST\")\n        \n        #make sure only one dictionary per lfn.\n        #Make sure this changes when we move to 2.7 or 3.0\n        #http://stackoverflow.com/questions/11092511/python-list-of-unique-dictionaries\n        # YG May-26-2015\n        return dict((v['logical_file_name'], v) for v in results).values()", "response": "This function lists the files in DBS."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef listPrimaryDSTypes(self, **kwargs):\n        validParameters = ['primary_ds_type', 'dataset']\n\n        checkInputParameter(method=\"listPrimaryDSTypes\", parameters=kwargs.keys(), validParameters=validParameters)\n\n        return self.__callServer(\"primarydstypes\", params=kwargs)", "response": "This method returns a list of dictionaries containing the primary dataset types and data types for that dataset."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef listRuns(self, **kwargs):\n        validParameters = ['run_num', 'logical_file_name', 'block_name', 'dataset']\n\n        requiredParameters = {'multiple': validParameters}\n\n        checkInputParameter(method=\"listRuns\", parameters=kwargs.keys(), validParameters=validParameters,\n                            requiredParameters=requiredParameters)\n\n        return self.__callServer(\"runs\", params=kwargs)", "response": "This method returns a list of all runs in a given block and dataset."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef updateAcqEraEndDate(self, **kwargs):\n        validParameters = ['end_date', 'acquisition_era_name']\n\n        requiredParameters = {'forced': validParameters}\n\n        checkInputParameter(method=\"updateAcqEraEndDate\", parameters=kwargs.keys(), validParameters=validParameters,\n                            requiredParameters=requiredParameters)\n\n        return self.__callServer(\"acquisitioneras\", params=kwargs, callmethod='PUT')", "response": "This method updates the end_date of an acquisition era"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef execute(self, conn, logical_file_name='', block_name='', run_num=-1, validFileOnly=0, migration=False):\n\tsql = \"\"\n\twheresql = \"\"\n\tlfn_generator = \"\"\n\trun_generator = \"\"\n        if logical_file_name and not isinstance(logical_file_name, list):\n            binds = {'logical_file_name': logical_file_name}\n            if int(validFileOnly) == 0:\n\t\tif migration:   #migration always call with single file and include all files no matter valid or not.\n\t\t    sql = self.sql + \"\"\" FROM {owner}FILE_LUMIS FL \n\t\t\t\t     JOIN {owner}FILES F ON F.FILE_ID = FL.FILE_ID \n\t\t\t\t     WHERE F.LOGICAL_FILE_NAME = :logical_file_name \n\t\t\t\t  \"\"\".format(owner=self.owner)\n\t\telse:\n\t\t    sql = self.sql + \"\"\" , F.LOGICAL_FILE_NAME as LOGICAL_FILE_NAME FROM {owner}FILE_LUMIS FL\n\t\t\t\t    JOIN {owner}FILES F ON F.FILE_ID = FL.FILE_ID \n                                     WHERE F.LOGICAL_FILE_NAME = :logical_file_name \n                                  \"\"\".format(owner=self.owner)\n            else:\n                sql = self.sql + \"\"\" , F.LOGICAL_FILE_NAME as LOGICAL_FILE_NAME FROM {owner}FILE_LUMIS FL \n\t\t\t\t     JOIN {owner}FILES F ON F.FILE_ID = FL.FILE_ID\n\t\t\t\t     JOIN {owner}DATASETS D ON  D.DATASET_ID = F.DATASET_ID\n\t\t\t\t     JOIN {owner}DATASET_ACCESS_TYPES DT ON  DT.DATASET_ACCESS_TYPE_ID = D.DATASET_ACCESS_TYPE_ID\t\t\n\t\t\t\t     WHERE F.IS_FILE_VALID = 1 AND F.LOGICAL_FILE_NAME = :logical_file_name \n\t\t\t\t     AND DT.DATASET_ACCESS_TYPE in ('VALID', 'PRODUCTION') \n\t\t\t\t \"\"\".format(owner=self.owner)\n        elif logical_file_name and isinstance(logical_file_name, list):\n\t    sql = self.sql + \"\"\" , F.LOGICAL_FILE_NAME as LOGICAL_FILE_NAME FROM {owner}FILE_LUMIS FL JOIN {owner}FILES F ON F.FILE_ID = FL.FILE_ID \"\"\".format(owner=self.owner)\t\n            lfn_generator, binds = create_token_generator(logical_file_name)\n            if int(validFileOnly) == 0:\n                wheresql = \"WHERE F.LOGICAL_FILE_NAME in (SELECT TOKEN FROM TOKEN_GENERATOR)\"\n            else:\n\t\tsql = sql + \"\"\" JOIN {owner}DATASETS D ON  D.DATASET_ID = F.DATASET_ID \n\t\t\t\tJOIN {owner}DATASET_ACCESS_TYPES DT ON  DT.DATASET_ACCESS_TYPE_ID = D.DATASET_ACCESS_TYPE_ID\n\t\t            \"\"\".format(owner=self.owner)\t\t\t\n                wheresql = \"\"\" WHERE F.IS_FILE_VALID = 1 AND F.LOGICAL_FILE_NAME in (SELECT TOKEN FROM TOKEN_GENERATOR) \n\t\t\t       AND DT.DATASET_ACCESS_TYPE in ('VALID', 'PRODUCTION')\n\t\t\t   \"\"\"\n            sql = \"{lfn_generator} {sql} {wheresql}\".format(lfn_generator=lfn_generator, sql=sql, wheresql=wheresql)\n        elif block_name:\n            binds = {'block_name': block_name}\n            if int(validFileOnly) == 0:\n                sql = self.sql + \"\"\" , F.LOGICAL_FILE_NAME as LOGICAL_FILE_NAME FROM {owner}FILE_LUMIS FL JOIN {owner}FILES F ON F.FILE_ID = FL.FILE_ID  \n\t\t\t\t     JOIN {owner}BLOCKS B ON B.BLOCK_ID = F.BLOCK_ID  \n\t\t\t\t     WHERE B.BLOCK_NAME = :block_name\"\"\".format(owner=self.owner)\n            else:\n                sql = self.sql + \"\"\" , F.LOGICAL_FILE_NAME as LOGICAL_FILE_NAME FROM {owner}FILE_LUMIS FL JOIN {owner}FILES F ON F.FILE_ID = FL.FILE_ID \n\t\t\t\t     JOIN {owner}DATASETS D ON  D.DATASET_ID = F.DATASET_ID \n\t\t\t\t     JOIN {owner}DATASET_ACCESS_TYPES DT ON  DT.DATASET_ACCESS_TYPE_ID = D.DATASET_ACCESS_TYPE_ID \n\t\t\t\t     JOIN {owner}BLOCKS B ON B.BLOCK_ID = F.BLOCK_ID\n\t\t\t\t     WHERE F.IS_FILE_VALID = 1 AND B.BLOCK_NAME = :block_name \n\t\t\t\t     AND DT.DATASET_ACCESS_TYPE in ('VALID', 'PRODUCTION')\t\n\t\t\t\t\"\"\".format(owner=self.owner)\n        else:\n                dbsExceptionHandler('dbsException-invalid-input2', \"FileLumi/List: Either logocal_file_name or block_name must be provided.\", self.logger.exception, \"FileLumi/List: Either logocal_file_name or block_name must be provided.\")\n          #\n        if run_num != -1:\n            run_list = []\n            wheresql_run_list=''\n            wheresql_run_range=''\n            for r in parseRunRange(run_num):\n                if isinstance(r, basestring) or isinstance(r, int) or isinstance(r, long) or isinstance(r, str):\n                    run_list.append(str(r))\n                if isinstance(r, run_tuple):\n                    if r[0] == r[1]:\n                        dbsExceptionHandler('dbsException-invalid-input2', \"DBS run range must be apart at least by 1.\",\n\t\t\tself.logger.exception, \"DBS run range must be apart at least by 1.\")\n                    wheresql_run_range = \" FL.RUN_NUM between :minrun and :maxrun \"\n                    binds.update({\"minrun\":r[0]})\n                    binds.update({\"maxrun\":r[1]})\n            #\n            if run_list:\n\t\tif len(run_list) == 1:\n\t\t    wheresql_run_list = \" fl.RUN_NUM = :single_run \"\n\t\t    binds.update({\"single_run\": long(run_list[0])})\n\n\t\telse:\n\t\t    wheresql_run_list = \" fl.RUN_NUM in (SELECT TOKEN FROM TOKEN_GENERATOR) \"\n                    run_generator, run_binds = create_token_generator(run_list)\n                    sql =  \"{run_generator}\".format(run_generator=run_generator) + sql\n                    binds.update(run_binds)\n\n            if wheresql_run_range and wheresql_run_list:\n                sql += \" and (\" + wheresql_run_range + \" or \" +  wheresql_run_list + \" )\"\n            elif wheresql_run_range and not wheresql_run_list:\n                sql += \" and \" + wheresql_run_range\n            elif not wheresql_run_range and wheresql_run_list:\n                sql += \" and \" + wheresql_run_list\n        self.logger.debug(sql) \n\tself.logger.debug(binds)\n\tif run_generator and lfn_generator:\n\t\tdbsExceptionHandler('dbsException-invalid-input2', \"listFileLumiArray support single list of lfn or run_num. \",\n\t\t\tself.logger.exception, \"listFileLumiArray support single list of lfn or run_num. \")\n        cursors = self.dbi.processData(sql, binds, conn, transaction=False, returnCursor=True)\n        result=[]\n\tfile_run_lumi={}\n        event_ct=False\n        for i in cursors:\n            result.extend(self.formatCursor(i, size=100))\n        #for migration, we need flat format to load the data into another DB.\n        #self.logger.error(result) \n        if migration:\n            #YG 09/2015. \n\t    for item in result:\n\t\tyield item\n\telse:\n            if result and result[0]['event_count']: \n                event_ct = True\n\t    for i in result:\n\t\tr = i['run_num']\n\t\tf = i['logical_file_name']\n                if event_ct:\n                    file_run_lumi.setdefault((f, r), []).append([i['lumi_section_num'], i['event_count']])\n                else:\n                    file_run_lumi.setdefault((f, r), []).append(i['lumi_section_num'])\n\t    for k, v in file_run_lumi.iteritems():\n                if event_ct:\n                    lumi=[]\n                    event=[]\n                    for le in v:\n                        lumi.append(le[0])\n                        event.append(le[1])\n                    yield {'logical_file_name':k[0], 'run_num':k[1], 'lumi_section_num':lumi, 'event_count':event}\n                else:\n                    yield {'logical_file_name':k[0], 'run_num':k[1], 'lumi_section_num':v}\n        del file_run_lumi\n        del result", "response": "Executes the SQL SELECT query."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nlists all files in a child block.", "response": "def execute(self, conn, child_block_name='', child_lfn_list=[], transaction=False):\n        sql = ''\n        binds = {}\n        child_ds_name = ''\n        child_where = ''\n        if child_block_name:\n            child_ds_name = child_block_name.split('#')[0]\n            parent_where = \" where d.dataset = :child_ds_name ))\"\n            binds ={\"child_ds_name\": child_ds_name}\n        else:\n            dbsExceptionHandler('dbsException-invalid-input', \"Missing child block_name for listFileParentsByLumi. \")\n        #\n        if not child_lfn_list:\n            # most use cases \n            child_where = \" where b.block_name = :child_block_name )\"\n            binds.update({\"child_block_name\": child_block_name})\n            sql = \"\"\"\n            with\n            parents as\n            (            \n            \"\"\"  +\\\n            self.parent_sql +\\\n            parent_where +\\\n            \"\"\"), \n \n            \"\"\"+\\\n            \"\"\"\n            children as\n            (\n            \"\"\" +\\\n            self.child_sql +\\\n            child_where  +\\\n            \"\"\")\n            select distinct cid, pid from children c\n                inner join parents p on c.R = p.R and c.L = p.L \n            \"\"\"  \n        else:\n            # not commom \n            child_where = \"\"\" where b.block_name = :child_block_name \n                              and f.logical_file_name in (SELECT TOKEN FROM TOKEN_GENERATOR) ))\n                          \"\"\"\n            lfn_generator, bind = create_token_generator(child_lfn_list)\n            binds.update(bind)\n            sql = lfn_generator +\\\n            \"\"\"\n            with\n            parents as\n            (            \n            \"\"\"  +\\\n            self.parent_sql +\\\n            parent_where +\\\n            \"\"\"), \n \n            \"\"\"+\\\n            \"\"\"\n            children as\n            (\n            \"\"\" +\\\n            self.child_sql +\\\n            child_where  +\\\n            \"\"\")\n            select distinct cid, pid from children c\n                inner join parents p on c.R = p.R and c.L = p.L \n            \"\"\"\n        print(sql)\n\n\n        r = self.dbi.processData(sql, binds, conn, transaction=transaction)\n        #print(self.format(r))\n        return self.format(r)\n        \"\"\"\n        cursors = self.dbi.processData(sql, binds, conn, transaction=transaction, returnCursor=True)\n        for i in cursors:\n            d = self.formatCursor(i, size=100)\n            if isinstance(d, list) or isinstance(d, GeneratorType):\n                for elem in d:\n                    yield elem\n            elif d: \n                yield d\n        \"\"\""}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef execute(self, conn, run_num=-1, logical_file_name=\"\", block_name=\"\", dataset=\"\", trans=False):\n        sql = self.sql\n        binds = {}\n\tif logical_file_name and \"%\" not in logical_file_name:\n\t    sql += \"\"\" inner join %sFILES FILES on FILES.FILE_ID = FL.FILE_ID\n\t\t    WHERE FILES.LOGICAL_FILE_NAME = :logical_file_name\"\"\"%(self.owner)\n\t    binds[\"logical_file_name\"] = logical_file_name\n\telif block_name and \"%\" not in block_name:\n            sql += \"\"\" inner join %sFILES FILES on FILES.FILE_ID = FL.FILE_ID\n\t\t    inner join %sBLOCKS BLOCKS on BLOCKS.BLOCK_ID = FILES.BLOCK_ID\n\t\t    WHERE BLOCKS.BLOCK_NAME = :block_name \"\"\"%(self.owner, self.owner)\n            binds[\"block_name\"] =  block_name\n\telif dataset and \"%\" not in dataset:\n\t    sql += \"\"\" inner join %sFILES FILES on FILES.FILE_ID = FL.FILE_ID\n\t    inner join %sDATASETS DATASETS on DATASETS.DATASET_ID = FILES.DATASET_ID\n\t    WHERE DATASETS.DATASET = :dataset \"\"\"%(self.owner, self.owner)\n\t    binds[\"dataset\"] = dataset\n\telse:\n\t    pass\n        \n\tif run_num != -1:\n            andorwhere = (\"WHERE\", \"AND\")[\"WHERE\" in sql]\n            run_list = []\n            wheresql_run_list = ''\n            wheresql_run_range = ''\n            #\n            for r in parseRunRange(run_num):\n                if isinstance(r, basestring) or isinstance(r, int) or isinstance(r, long):\n                    run_list.append(str(r))\n                if isinstance(r, run_tuple):\n                    if r[0] == r[1]:\n                        dbsExceptionHandler('dbsException-invalid-input', \"DBS run_num range must be apart at least by 1.\", self.logger.exception)\n                    wheresql_run_range = \" FL.RUN_NUM between :minrun and :maxrun \"\n                    binds.update({\"minrun\":r[0]})\n                    binds.update({\"maxrun\":r[1]})\n            # \n            if run_list:\n                wheresql_run_list = \" fl.RUN_NUM in (SELECT TOKEN FROM TOKEN_GENERATOR) \"\n                run_generator, run_binds = create_token_generator(run_list)\n                sql =  \"{run_generator}\".format(run_generator=run_generator) + sql\n                binds.update(run_binds)\n\n            if wheresql_run_range and wheresql_run_list:\n                sql += \" %s (\" %andorwhere    + wheresql_run_range + \" or \" +  wheresql_run_list + \" )\"\n            elif wheresql_run_range and not wheresql_run_list:\n                sql += \" %s \" %andorwhere  + wheresql_run_range\n            elif not wheresql_run_range and wheresql_run_list:\n                sql += \" %s \" %andorwhere  + wheresql_run_list\n        #self.logger.debug(sql)\n\tcursors = self.dbi.processData(sql, binds, conn, transaction=trans, returnCursor=True)\n        result=[]\n        for c in cursors:\n            result.extend(self.formatCursor(c, size=100))\n        return result", "response": "This method returns a list of all primary datasets that match the given criteria."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a list of dictionaries that represents one device.", "response": "def find_devices():\n    \"\"\"Return a list of dictionaries. Each dictionary represents one device.\n\n    The dictionary contains the following keys: port, unique_id and in_use.\n    `port` can be used with :func:`open`. `serial_number` is the serial number\n    of the device (and can also be used with :func:`open`) and `in_use`\n    indicates whether the device was opened before and can currently not be\n    opened.\n\n    .. note::\n\n       There is no guarantee, that the returned information is still valid\n       when you open the device. Esp. if you open a device by the port, the\n       unique_id may change because you've just opened another device. Eg. it\n       may be disconnected from the machine after you call :func:`find_devices`\n       but before you call :func:`open`.\n\n       To open a device by its serial number, you should use the :func:`open`\n       with the `serial_number` parameter.\n    \"\"\"\n\n    # first fetch the number of attached devices, so we can create a buffer\n    # with the exact amount of entries. api expects array of u16\n    num_devices = api.py_aa_find_devices(0, array.array('H'))\n    _raise_error_if_negative(num_devices)\n\n    # return an empty list if no device is connected\n    if num_devices == 0:\n        return list()\n\n    ports = array.array('H', (0,) * num_devices)\n    unique_ids = array.array('I', (0,) * num_devices)\n    num_devices = api.py_aa_find_devices_ext(len(ports), len(unique_ids),\n            ports, unique_ids)\n    _raise_error_if_negative(num_devices)\n    if num_devices == 0:\n        return list()\n\n    del ports[num_devices:]\n    del unique_ids[num_devices:]\n\n    devices = list()\n    for port, uid in zip(ports, unique_ids):\n        in_use = bool(port & PORT_NOT_FREE)\n        dev = dict(\n                port=port & ~PORT_NOT_FREE,\n                serial_number=_unique_id_str(uid),\n                in_use=in_use)\n        devices.append(dev)\n\n    return devices"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nopen an aardvark device and return an Aardvark object.", "response": "def open(port=None, serial_number=None):\n    \"\"\"Open an aardvark device and return an :class:`Aardvark` object. If the\n    device cannot be opened an :class:`IOError` is raised.\n\n    The `port` can be retrieved by :func:`find_devices`. Usually, the first\n    device is 0, the second 1, etc.\n\n    If you are using only one device, you can therefore omit the parameter\n    in which case 0 is used.\n\n    Another method to open a device is to use the serial number. You can either\n    find the number on the device itself or in the in the corresponding USB\n    property. The serial number is a string which looks like `NNNN-MMMMMMM`.\n\n    Raises an :class:`IOError` if the port (or serial number) does not exist,\n    is already connected or an incompatible device is found.\n\n    .. note::\n\n       There is a small chance that this function raises an :class:`IOError`\n       although the correct device is available and not opened. The\n       open-by-serial-number method works by scanning the devices. But as\n       explained in :func:`find_devices`, the returned information may be\n       outdated. Therefore, :func:`open` checks the serial number once the\n       device is opened and if it is not the expected one, raises\n       :class:`IOError`. No retry mechanism is implemented.\n\n       As long as nobody comes along with a better idea, this failure case is\n       up to the user.\n    \"\"\"\n    if port is None and serial_number is None:\n        dev = Aardvark()\n    elif serial_number is not None:\n        for d in find_devices():\n            if d['serial_number'] == serial_number:\n                break\n        else:\n            _raise_error_if_negative(ERR_UNABLE_TO_OPEN)\n\n        dev = Aardvark(d['port'])\n\n        # make sure we opened the correct device\n        if dev.unique_id_str() != serial_number:\n            dev.close()\n            _raise_error_if_negative(ERR_UNABLE_TO_OPEN)\n    else:\n        dev = Aardvark(port)\n\n    return dev"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nset this to True to enable the hardware I2C interface.", "response": "def enable_i2c(self):\n        \"\"\"Set this to `True` to enable the hardware I2C interface. If set to\n        `False` the hardware interface will be disabled and its pins (SDA and\n        SCL) can be used as GPIOs.\n        \"\"\"\n        config = self._interface_configuration(CONFIG_QUERY)\n        return config == CONFIG_GPIO_I2C or config == CONFIG_SPI_I2C"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef enable_spi(self):\n        config = self._interface_configuration(CONFIG_QUERY)\n        return config == CONFIG_SPI_GPIO or config == CONFIG_SPI_I2C", "response": "Set this to True to enable the hardware SPI interface."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef i2c_pullups(self):\n        ret = api.py_aa_i2c_pullup(self.handle, I2C_PULLUP_QUERY)\n        _raise_error_if_negative(ret)\n        return ret", "response": "Enable or disable the I2C pullup resistors."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef target_power(self):\n        ret = api.py_aa_target_power(self.handle, TARGET_POWER_QUERY)\n        _raise_error_if_negative(ret)\n        return ret", "response": "Sets this to True will activate the power pins 4 and 6. If set to False will deactivate the power pins 4 and 6."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef i2c_bus_timeout(self):\n        ret = api.py_aa_i2c_bus_timeout(self.handle, 0)\n        _raise_error_if_negative(ret)\n        return ret", "response": "I2C bus lock timeout in ms."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef i2c_master_write(self, i2c_address, data, flags=I2C_NO_FLAGS):\n\n        data = array.array('B', data)\n        status, _ = api.py_aa_i2c_write_ext(self.handle, i2c_address, flags,\n                len(data), data)\n        _raise_i2c_status_code_error_if_failure(status)", "response": "Write data to the master i2c device."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nmake an I2C read access.", "response": "def i2c_master_read(self, addr, length, flags=I2C_NO_FLAGS):\n        \"\"\"Make an I2C read access.\n\n        The given I2C device is addressed and clock cycles for `length` bytes\n        are generated. A short read will occur if the device generates an early\n        NAK.\n\n        The transaction is finished with an I2C stop condition unless the\n        I2C_NO_STOP flag is set.\n        \"\"\"\n\n        data = array.array('B', (0,) * length)\n        status, rx_len = api.py_aa_i2c_read_ext(self.handle, addr, flags,\n                length, data)\n        _raise_i2c_status_code_error_if_failure(status)\n        del data[rx_len:]\n        return bytes(data)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef i2c_master_write_read(self, i2c_address, data, length):\n\n        self.i2c_master_write(i2c_address, data, I2C_NO_STOP)\n        return self.i2c_master_read(i2c_address, length)", "response": "This is a convenience method for making an I2C write and read access. This method is used to access the contents of the memory of the current I2C device."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef poll(self, timeout=None):\n        if timeout is None:\n            timeout = -1\n\n        ret = api.py_aa_async_poll(self.handle, timeout)\n        _raise_error_if_negative(ret)\n\n        events = list()\n        for event in (POLL_I2C_READ, POLL_I2C_WRITE, POLL_SPI,\n                POLL_I2C_MONITOR):\n            if ret & event:\n                events.append(event)\n        return events", "response": "Wait for an event to occur."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef enable_i2c_slave(self, slave_address):\n        ret = api.py_aa_i2c_slave_enable(self.handle, slave_address,\n                self.BUFFER_SIZE, self.BUFFER_SIZE)\n        _raise_error_if_negative(ret)", "response": "Enable I2C slave mode."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreads the bytes from an I2C slave reception.", "response": "def i2c_slave_read(self):\n        \"\"\"Read the bytes from an I2C slave reception.\n\n        The bytes are returned as a string object.\n        \"\"\"\n        data = array.array('B', (0,) * self.BUFFER_SIZE)\n        status, addr, rx_len = api.py_aa_i2c_slave_read_ext(self.handle,\n                self.BUFFER_SIZE, data)\n        _raise_i2c_status_code_error_if_failure(status)\n\n        # In case of general call, actually return the general call address\n        if addr == 0x80:\n            addr = 0x00\n        del data[rx_len:]\n        return (addr, bytes(data))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the number of bytes transmitted by the slave.", "response": "def i2c_slave_last_transmit_size(self):\n        \"\"\"Returns the number of bytes transmitted by the slave.\"\"\"\n        ret = api.py_aa_i2c_slave_write_stats(self.handle)\n        _raise_error_if_negative(ret)\n        return ret"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef i2c_monitor_read(self):\n        data = array.array('H', (0,) * self.BUFFER_SIZE)\n        ret = api.py_aa_i2c_monitor_read(self.handle, self.BUFFER_SIZE,\n                data)\n        _raise_error_if_negative(ret)\n        del data[ret:]\n        return data.tolist()", "response": "Read any data fetched by the monitor."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef spi_bitrate(self):\n        ret = api.py_aa_spi_bitrate(self.handle, 0)\n        _raise_error_if_negative(ret)\n        return ret", "response": "SPI bitrate in kHz."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nconfiguring the SPI interface.", "response": "def spi_configure(self, polarity, phase, bitorder):\n        \"\"\"Configure the SPI interface.\"\"\"\n        ret = api.py_aa_spi_configure(self.handle, polarity, phase, bitorder)\n        _raise_error_if_negative(ret)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nconfigures the SPI interface by the well known SPI modes.", "response": "def spi_configure_mode(self, spi_mode):\n        \"\"\"Configure the SPI interface by the well known SPI modes.\"\"\"\n        if spi_mode == SPI_MODE_0:\n            self.spi_configure(SPI_POL_RISING_FALLING,\n                    SPI_PHASE_SAMPLE_SETUP, SPI_BITORDER_MSB)\n        elif spi_mode == SPI_MODE_3:\n            self.spi_configure(SPI_POL_FALLING_RISING,\n                    SPI_PHASE_SETUP_SAMPLE, SPI_BITORDER_MSB)\n        else:\n            raise RuntimeError('SPI Mode not supported')"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nwrites a stream of bytes to a SPI device.", "response": "def spi_write(self, data):\n        \"\"\"Write a stream of bytes to a SPI device.\"\"\"\n        data_out = array.array('B', data)\n        data_in = array.array('B', (0,) * len(data_out))\n        ret = api.py_aa_spi_write(self.handle, len(data_out), data_out,\n                len(data_in), data_in)\n        _raise_error_if_negative(ret)\n        return bytes(data_in)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nchange the ouput polarity on the SS line.", "response": "def spi_ss_polarity(self, polarity):\n        \"\"\"Change the ouput polarity on the SS line.\n\n        Please note, that this only affects the master functions.\n        \"\"\"\n        ret = api.py_aa_spi_master_ss_polarity(self.handle, polarity)\n        _raise_error_if_negative(ret)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef flatten_nested_hash(hash_table):\n    def flatten(hash_table, brackets=True):\n        f = {}\n        for key, value in hash_table.items():\n            _key = '[' + str(key) + ']' if brackets else str(key)\n            if isinstance(value, dict):\n                for k, v in flatten(value).items():\n                    f[_key + k] = v\n            elif isinstance(value, list):\n                temp_hash = {}\n                for i, v in enumerate(value):\n                    temp_hash[str(i)] = v\n                for k, v in flatten(temp_hash).items():\n                    f[_key + k] = v\n            else:\n                f[_key] = value\n        return f\n    return flatten(hash_table, False)", "response": "Flatten nested dictionary for GET POST DELETE API request\n   "}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef sailthru_http_request(url, data, method, file_data=None, headers=None, request_timeout=10):\n    data = flatten_nested_hash(data)\n    method = method.upper()\n    params, data = (None, data) if method == 'POST' else (data, None)\n    sailthru_headers = {'User-Agent': 'Sailthru API Python Client %s; Python Version: %s' % ('2.3.5', platform.python_version())}\n    if headers and isinstance(headers, dict):\n        for key, value in sailthru_headers.items():\n            headers[key] = value\n    else:\n        headers = sailthru_headers\n    try:\n        response = requests.request(method, url, params=params, data=data, files=file_data, headers=headers, timeout=request_timeout)\n        return SailthruResponse(response)\n    except requests.HTTPError as e:\n        raise SailthruClientError(str(e))\n    except requests.RequestException as e:\n        raise SailthruClientError(str(e))", "response": "Perform an HTTP request to the Sailthru API."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _schema_from_verb(verb, partial=False):\n    from .verbs import Verbs\n    return getattr(Verbs, verb)(partial=partial)", "response": "Return an instance of schema for given verb."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning resumption token serializer.", "response": "def serialize(pagination, **kwargs):\n    \"\"\"Return resumption token serializer.\"\"\"\n    if not pagination.has_next:\n        return\n\n    token_builder = URLSafeTimedSerializer(\n        current_app.config['SECRET_KEY'],\n        salt=kwargs['verb'],\n    )\n    schema = _schema_from_verb(kwargs['verb'], partial=False)\n    data = dict(seed=random.random(), page=pagination.next_num,\n                kwargs=schema.dump(kwargs).data)\n    scroll_id = getattr(pagination, '_scroll_id', None)\n    if scroll_id:\n        data['scroll_id'] = scroll_id\n\n    return token_builder.dumps(data)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef make_request_validator(request):\n    verb = request.values.get('verb', '', type=str)\n    resumption_token = request.values.get('resumptionToken', None)\n\n    schema = Verbs if resumption_token is None else ResumptionVerbs\n    return getattr(schema, verb, OAISchema)(partial=False)", "response": "Validate arguments in incomming request."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nparsing an ISO8601 - formatted datetime and return a datetime object.", "response": "def from_iso_permissive(datestring, use_dateutil=True):\n        \"\"\"Parse an ISO8601-formatted datetime and return a datetime object.\n\n        Inspired by the marshmallow.utils.from_iso function, but also accepts\n        datestrings that don't contain the time.\n        \"\"\"\n        dateutil_available = False\n        try:\n            from dateutil import parser\n            dateutil_available = True\n        except ImportError:\n            dateutil_available = False\n            import datetime\n\n        # Use dateutil's parser if possible\n        if dateutil_available and use_dateutil:\n            return parser.parse(datestring)\n        else:\n            # Strip off timezone info.\n            return datetime.datetime.strptime(datestring[:19],\n                                              '%Y-%m-%dT%H:%M:%S')"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef validate(self, data):\n        if 'verb' in data and data['verb'] != self.__class__.__name__:\n            raise ValidationError(\n                # FIXME encode data\n                'This is not a valid OAI-PMH verb:{0}'.format(data['verb']),\n                field_names=['verb'],\n            )\n\n        if 'from_' in data and 'until' in data and \\\n                data['from_'] > data['until']:\n            raise ValidationError('Date \"from\" must be before \"until\".')\n\n        extra = set(request.values.keys()) - set([\n            f.load_from or f.name for f in self.fields.values()\n        ])\n        if extra:\n            raise ValidationError('You have passed too many arguments.')", "response": "Check range between dates under keys from_ and until."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef sets(self):\n        if self.cache:\n            return self.cache.get(\n                self.app.config['OAISERVER_CACHE_KEY'])", "response": "Get list of sets."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef sets(self, values):\n        # if cache server is configured, save sets list\n        if self.cache:\n            self.cache.set(self.app.config['OAISERVER_CACHE_KEY'], values)", "response": "Set list of sets."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nregistering signals to update the record record", "response": "def register_signals(self):\n        \"\"\"Register signals.\"\"\"\n        from .receivers import OAIServerUpdater\n        # Register Record signals to update OAI informations\n        self.update_function = OAIServerUpdater()\n        records_signals.before_record_insert.connect(self.update_function,\n                                                     weak=False)\n        records_signals.before_record_update.connect(self.update_function,\n                                                     weak=False)\n        if self.app.config['OAISERVER_REGISTER_SET_SIGNALS']:\n            self.register_signals_oaiset()"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nregisters signals to update records.", "response": "def register_signals_oaiset(self):\n        \"\"\"Register OAISet signals to update records.\"\"\"\n        from .models import OAISet\n        from .receivers import after_insert_oai_set, \\\n            after_update_oai_set, after_delete_oai_set\n        listen(OAISet, 'after_insert', after_insert_oai_set)\n        listen(OAISet, 'after_update', after_update_oai_set)\n        listen(OAISet, 'after_delete', after_delete_oai_set)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef init_config(self, app):\n        app.config.setdefault(\n            'OAISERVER_BASE_TEMPLATE',\n            app.config.get('BASE_TEMPLATE',\n                           'invenio_oaiserver/base.html'))\n\n        app.config.setdefault(\n            'OAISERVER_REPOSITORY_NAME',\n            app.config.get('THEME_SITENAME',\n                           'Invenio-OAIServer'))\n\n        # warn user if ID_PREFIX is not set\n        if 'OAISERVER_ID_PREFIX' not in app.config:\n            import socket\n            import warnings\n\n            app.config.setdefault(\n                'OAISERVER_ID_PREFIX',\n                'oai:{0}:recid/'.format(socket.gethostname()))\n            warnings.warn(\n                \"\"\"Please specify the OAISERVER_ID_PREFIX configuration.\"\"\"\n                \"\"\"default value is: {0}\"\"\".format(\n                    app.config.get('OAISERVER_ID_PREFIX')))\n\n        for k in dir(config):\n            if k.startswith('OAISERVER_'):\n                app.config.setdefault(k, getattr(config, k))", "response": "Initialize configuration.\n\n        :param app: An instance of :class:`flask.Flask`."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nextracts the values of a set of parameters recursing into nested dictionaries.", "response": "def extract_params(params):\n    \"\"\"\n    Extracts the values of a set of parameters, recursing into nested dictionaries.\n    \"\"\"\n    values = []\n    if isinstance(params, dict):\n        for key, value in params.items():\n            values.extend(extract_params(value))\n    elif isinstance(params, list):\n        for value in params:\n            values.extend(extract_params(value))\n    else:\n        values.append(params)\n    return values"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the unhashed signature string for an API call.", "response": "def get_signature_string(params, secret):\n    \"\"\"\n    Returns the unhashed signature string (secret + sorted list of param values) for an API call.\n    @param params: dictionary values to generate signature string\n    @param secret: secret string\n    \"\"\"\n    str_list = [str(item) for item in extract_params(params)]\n    str_list.sort()\n    return (secret + ''.join(str_list)).encode('utf-8')"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef send(self, template, email, _vars=None, options=None, schedule_time=None, limit=None):\n        _vars = _vars or {}\n        options = options or {}\n        data = {'template': template,\n                'email': email,\n                'vars': _vars,\n                'options': options.copy()}\n        if limit:\n            data['limit'] = limit.copy()\n        if schedule_time is not None:\n            data['schedule_time'] = schedule_time\n        return self.api_post('send', data)", "response": "Remotely send an email template to a single email address."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef multi_send(self, template, emails, _vars=None, evars=None, schedule_time=None, options=None):\n        _vars = _vars or {}\n        evars = evars or {}\n        options = options or {}\n        data = {'template': template,\n                'email': ','.join(emails) if isinstance(emails, list) else emails,\n                'vars': _vars.copy(),\n                'evars': evars.copy(),\n                'options': options.copy()}\n        if schedule_time is not None:\n            data['schedule_time'] = schedule_time\n        return self.api_post('send', data)", "response": "Remotely send an email template to multiple email addresses."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef set_email(self, email, _vars=None, lists=None, templates=None, verified=0, optout=None, send=None, send_vars=None):\n        _vars = _vars or {}\n        lists = lists or []\n        templates = templates or []\n        send_vars = send_vars or []\n        data = {'email': email,\n                'vars':  _vars.copy(),\n                'lists': lists,\n                'templates': templates,\n                'verified': int(verified)}\n        if optout is not None:\n            data['optout'] = optout\n        if send is not None:\n            data['send'] = send\n        if send_vars:\n            data['send_vars'] = send_vars\n        return self.api_post('email', data)", "response": "Set the email address of the user."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting user by a given idvalue", "response": "def get_user(self, idvalue, options=None):\n        \"\"\"\n        get user by a given id\n        http://getstarted.sailthru.com/api/user\n        \"\"\"\n        options = options or {}\n        data = options.copy()\n        data['id'] = idvalue\n        return self.api_get('user', data)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef save_user(self, idvalue, options=None):\n        options = options or {}\n        data = options.copy()\n        data['id'] = idvalue\n        return self.api_post('user', data)", "response": "save user by a given idvalue"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nschedules a blast of a list of mails.", "response": "def schedule_blast(self, name, list, schedule_time, from_name, from_email, subject, content_html, content_text, options=None):\n        \"\"\"\n        Schedule a mass mail blast\n        http://docs.sailthru.com/api/blast\n        @param name: name to give to this new blast\n        @param list: mailing list name to send to\n        @param schedule_time:  when the blast should send. Dates in the past will be scheduled for immediate delivery. Any English textual datetime format known to PHP's strtotime function is acceptable, such as 2009-03-18 23:57:22 UTC, now (immediate delivery), +3 hours (3 hours from now), or February 14, 9:30 EST. Be sure to specify a timezone if you use an exact time.\n        @param from_name: name appearing in the \"From\" of the email\n        @param from_email: email address to use as the \"from\" - choose from any of your verified emails\n        @param subject: subject line of the email\n        @param content_html: HTML format version of the email\n        @param content_text: Text format version of the email\n        @param options: optional parameters dictionary\n            blast_id\n            copy_blast\n            copy_template\n            replyto\n            report_email\n            is_link_tracking\n            is_google_analytics\n            is_public\n            suppress_list\n            test_vars\n            email_hour_range\n            abtest\n            test_percent\n            data_feed_url\n        \"\"\"\n        options = options or {}\n        data = options.copy()\n        data['name'] = name\n        data['list'] = list\n        data['schedule_time'] = schedule_time\n        data['from_name'] = from_name\n        data['from_email'] = from_email\n        data['subject'] = subject\n        data['content_html'] = content_html\n        data['content_text'] = content_text\n        return self.api_post('blast', data)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef schedule_blast_from_template(self, template, list_name, schedule_time, options=None):\n        options = options or {}\n        data = options.copy()\n        data['copy_template'] = template\n        data['list'] = list_name\n        data['schedule_time'] = schedule_time\n        return self.api_post('blast', data)", "response": "Schedule a mass mail blast from a template"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nscheduling a blast from previous blast", "response": "def schedule_blast_from_blast(self, blast_id, schedule_time, options=None):\n        \"\"\"\n        Schedule a mass mail blast from previous blast\n        http://docs.sailthru.com/api/blast\n        @param blast_id: blast_id to copy from\n        @param schedule_time\n        @param options: additional optional params\n        \"\"\"\n        options = options or {}\n        data = options.copy()\n        data['copy_blast'] = blast_id\n        data['schedule_time'] = schedule_time\n        return self.api_post('blast', data)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets detailed metadata about a list.", "response": "def get_list(self, list_name, options=None):\n        \"\"\"\n        Get detailed metadata information about a list.\n        \"\"\"\n        options = options or {}\n        data = {'list': list_name}\n        data.update(options)\n        return self.api_get('list', data)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef save_list(self, list_name, emails):\n        data = {'list': list_name,\n                'emails': ','.join(emails) if isinstance(emails, list) else emails}\n        return self.api_post('list', data)", "response": "Upload a list. The list import job is queued and will happen shortly after the API request.\n        http://docs.sailthru.com/api/list\n        @param list: list name\n        @param emails: List of email values or comma separated string"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef import_contacts(self, email, password, include_name=False):\n        data = {'email': email,\n                'password': password}\n        if include_name:\n            data['names'] = 1\n        return self.api_post('contacts', data)", "response": "Import email contacts from a user s address book on one of the major email websites."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\npushes a piece of content to Sailthru.", "response": "def push_content(self, title, url,\n                     images=None, date=None, expire_date=None,\n                     description=None, location=None, price=None,\n                     tags=None,\n                     author=None, site_name=None,\n                     spider=None, vars=None):\n\n        \"\"\"\n        Push a new piece of content to Sailthru.\n\n        Expected names for the `images` argument's map are \"full\" and \"thumb\"\n        Expected format for `location` should be [longitude,latitude]\n\n        @param title: title string for the content\n        @param url: URL string for the content\n        @param images: map of image names\n        @param date: date string\n        @param expire_date: date string for when the content expires\n        @param description: description for the content\n        @param location: location of the content\n        @param price: price for the content\n        @param tags: list or comma separated string values\n        @param author: author for the content\n        @param site_name: site name for the content\n        @param spider: truthy value to force respidering content\n        @param vars: replaceable vars dictionary\n\n        \"\"\"\n        vars = vars or {}\n        data = {'title': title,\n                'url': url}\n        if images is not None:\n            data['images'] = images\n        if date is not None:\n            data['date'] = date\n        if expire_date is not None:\n            data['expire_date'] = date\n        if location is not None:\n            data['location'] = date\n        if price is not None:\n            data['price'] = price\n        if description is not None:\n            data['description'] = description\n        if site_name is not None:\n            data['site_name'] = images\n        if author is not None:\n            data['author'] = author\n        if spider:\n            data['spider'] = 1\n        if tags is not None:\n            data['tags'] = \",\".join(tags) if isinstance(tags, list) else tags\n        if len(vars) > 0:\n            data['vars'] = vars.copy()\n        return self.api_post('content', data)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef save_alert(self, email, type, template, when=None, options=None):\n        options = options or {}\n        data = options.copy()\n        data['email'] = email\n        data['type'] = type\n        data['template'] = template\n        if type in ['weekly', 'daily']:\n            data['when'] = when\n        return self.api_post('alert', data)", "response": "Save an alert to a user."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef purchase(self, email, items=None, incomplete=None, message_id=None, options=None, extid=None):\n        items = items or {}\n        options = options or {}\n        data = options.copy()\n        data['email'] = email\n        data['items'] = items\n        if incomplete is not None:\n            data['incomplete'] = incomplete\n        if message_id is not None:\n            data['message_id'] = message_id\n        if extid is not None:\n            data['extid'] = extid\n        return self.api_post('purchase', data)", "response": "This method is used to create a new item in a user s purchase total."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_purchase(self, purchase_id, purchase_key='sid'):\n        data = {'purchase_id': purchase_id,\n                'purchase_key': purchase_key}\n        return self.api_get('purchase', data)", "response": "Retrieve information about a purchase using the system s unique ID or a client s ID."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nretrieve information about your subscriber counts on a particular list on a particular day.", "response": "def stats_list(self, list=None, date=None, headers=None):\n        \"\"\"\n        Retrieve information about your subscriber counts on a particular list, on a particular day.\n        http://docs.sailthru.com/api/stat\n        \"\"\"\n        data = {'stat': 'list'}\n        if list is not None:\n            data['list'] = list\n        if date is not None:\n            data['date'] = date\n        return self._stats(data, headers)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef stats_blast(self, blast_id=None, start_date=None, end_date=None, options=None):\n        options = options or {}\n        data = options.copy()\n        if blast_id is not None:\n            data['blast_id'] = blast_id\n        if start_date is not None:\n            data['start_date'] = start_date\n        if end_date is not None:\n            data['end_date'] = end_date\n        data['stat'] = 'blast'\n        return self._stats(data)", "response": "Retrieve information about a particular blast or aggregated information from all of the blasts over a specified date range."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef stats_send(self, template, start_date, end_date, options=None):\n        options = options or {}\n        data = options.copy()\n        data = {'template': template,\n                'start_date': start_date,\n                'end_date': end_date\n                }\n        data['stat'] = 'send'\n        return self._stats(data)", "response": "Retrieve information about a particular transactional or aggregated information from that template over a specified date range."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef receive_verify_post(self, post_params):\n        if isinstance(post_params,  dict):\n            required_params = ['action', 'email', 'send_id', 'sig']\n            if not self.check_for_valid_postback_actions(required_params, post_params):\n                return False\n        else:\n            return False\n\n        if post_params['action'] != 'verify':\n            return False\n\n        sig = post_params['sig']\n        post_params = post_params.copy()\n        del post_params['sig']\n\n        if sig != get_signature_hash(post_params, self.secret):\n            return False\n\n        send_response = self.get_send(post_params['send_id'])\n\n        try:\n            send_body = send_response.get_body()\n            send_json = json.loads(send_body)\n            if 'email' not in send_body:\n                return False\n            if send_json['email'] != post_params['email']:\n                return False\n        except ValueError:\n            return False\n\n        return True", "response": "Returns True if the incoming request is an authenticated verify post."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncheck if the post_params is valid and return True if the post was valid False otherwise", "response": "def receive_update_post(self, post_params):\n        \"\"\"\n        Update postbacks\n        \"\"\"\n\n        if isinstance(post_params, dict):\n            required_params = ['action', 'email', 'sig']\n            if not self.check_for_valid_postback_actions(required_params, post_params):\n                return False\n        else:\n            return False\n\n        if post_params['action'] != 'update':\n            return False\n\n        signature = post_params['sig']\n        post_params = post_params.copy()\n        del post_params['sig']\n\n        if signature != get_signature_hash(post_params, self.secret):\n            return False\n\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nchecking if a hard bounce post is received and return the set of related resources.", "response": "def receive_hardbounce_post(self, post_params):\n        \"\"\"\n        Hard bounce postbacks\n        \"\"\"\n        if isinstance(post_params, dict):\n            required_params = ['action', 'email', 'sig']\n            if not self.check_for_valid_postback_actions(required_params, post_params):\n                return False\n        else:\n            return False\n\n        if post_params['action'] != 'hardbounce':\n            return False\n\n        signature = post_params['sig']\n        post_params = post_params.copy()\n        del post_params['sig']\n\n        if signature != get_signature_hash(post_params, self.secret):\n            return False\n\n        # for sends\n        if 'send_id' in post_params:\n            send_id = post_params['send_id']\n            send_response = self.get_send(send_id)\n            if not send_response.is_ok():\n                return False\n            send_obj = send_response.get_body()\n            if not send_obj or 'email' not in send_obj:\n                return False\n\n        # for blasts\n        if 'blast_id' in post_params:\n            blast_id = post_params['blast_id']\n            blast_response = self.get_blast(blast_id)\n            if not blast_response.is_ok():\n                return False\n            blast_obj = blast_response.get_body()\n            if not blast_obj:\n                return False\n\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nchecking if post_params contain required keys", "response": "def check_for_valid_postback_actions(self, required_keys, post_params):\n        \"\"\"\n        checks if post_params contain required keys\n        \"\"\"\n        for key in required_keys:\n            if key not in post_params:\n                return False\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef api_get(self, action, data, headers=None):\n        return self._api_request(action, data, 'GET', headers)", "response": "Perform an HTTP GET request using the shared - secret auth hash."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nperforming an HTTP POST request using the shared - secret auth hash.", "response": "def api_post(self, action, data, binary_data_param=None):\n        \"\"\"\n        Perform an HTTP POST request, using the shared-secret auth hash.\n        @param action: API action call\n        @param data: dictionary values\n        \"\"\"\n        binary_data_param = binary_data_param or []\n        if binary_data_param:\n            return self.api_post_multipart(action, data, binary_data_param)\n        else:\n            return self._api_request(action, data, 'POST')"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef api_post_multipart(self, action, data, binary_data_param):\n        binary_data = {}\n        data = data.copy()\n\n        try:\n            file_handles = []\n            for param in binary_data_param:\n                if param in data:\n                    binary_data[param] = file_handle = open(data[param], 'r')\n                    file_handles.append(file_handle)\n                    del data[param]\n            json_payload = self._prepare_json_payload(data)\n\n            return self._http_request(action, json_payload, \"POST\", binary_data)\n        finally:\n            for file_handle in file_handles:\n                file_handle.close()", "response": "Perform an HTTP Multipart POST request using the shared - secret auth hash."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _api_request(self, action, data, request_type, headers=None):\n        if 'file' in data:\n            file_data = {'file': open(data['file'], 'rb')}\n        else:\n            file_data = None\n\n        return self._http_request(action, self._prepare_json_payload(data), request_type, file_data, headers)", "response": "Make a request to Sailthru API with given data and api key format and signature hash"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget rate limit information for last API call", "response": "def get_last_rate_limit_info(self, action, method):\n        \"\"\"\n        Get rate limit information for last API call\n        :param action: API endpoint\n        :param method: Http method, GET, POST or DELETE\n        :return: dict|None\n        \"\"\"\n        method = method.upper()\n        if (action in self.last_rate_limit_info and method in self.last_rate_limit_info[action]):\n            return self.last_rate_limit_info[action][method]\n\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nminting record identifiers. :param record_uuid: The record UUID. :param data: The record data. :returns: A :class:`invenio_pidstore.models.PersistentIdentifier` instance.", "response": "def oaiid_minter(record_uuid, data):\n    \"\"\"Mint record identifiers.\n\n    :param record_uuid: The record UUID.\n    :param data: The record data.\n    :returns: A :class:`invenio_pidstore.models.PersistentIdentifier` instance.\n    \"\"\"\n    pid_value = data.get('_oai', {}).get('id')\n    if pid_value is None:\n        fetcher_name = \\\n            current_app.config.get('OAISERVER_CONTROL_NUMBER_FETCHER', 'recid')\n        cn_pid = current_pidstore.fetchers[fetcher_name](record_uuid, data)\n        pid_value = current_app.config.get('OAISERVER_ID_PREFIX', '') + str(\n            cn_pid.pid_value\n        )\n    provider = OAIIDProvider.create(\n        object_type='rec', object_uuid=record_uuid,\n        pid_value=str(pid_value)\n    )\n    data.setdefault('_oai', {})\n    data['_oai']['id'] = provider.pid.pid_value\n    return provider.pid"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a formatter validation error.", "response": "def validation_error(exception):\n    \"\"\"Return formatter validation error.\"\"\"\n    messages = getattr(exception, 'messages', None)\n    if messages is None:\n        messages = getattr(exception, 'data', {'messages': None})['messages']\n\n    def extract_errors():\n        \"\"\"Extract errors from exception.\"\"\"\n        if isinstance(messages, dict):\n            for field, message in messages.items():\n                if field == 'verb':\n                    yield 'badVerb', '\\n'.join(message)\n                else:\n                    yield 'badArgument', '\\n'.join(message)\n        else:\n            for field in exception.field_names:\n                if field == 'verb':\n                    yield 'badVerb', '\\n'.join(messages)\n                else:\n                    yield 'badArgument', '\\n'.join(messages)\n\n            if not exception.field_names:\n                yield 'badArgument', '\\n'.join(messages)\n\n    return (etree.tostring(xml.error(extract_errors())),\n            422,\n            {'Content-Type': 'text/xml'})"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef create(cls, object_type=None, object_uuid=None, **kwargs):\n        assert 'pid_value' in kwargs\n\n        kwargs.setdefault('status', cls.default_status)\n        if object_type and object_uuid:\n            kwargs['status'] = PIDStatus.REGISTERED\n\n        return super(OAIIDProvider, cls).create(\n            object_type=object_type, object_uuid=object_uuid, **kwargs)", "response": "Create a new record identifier."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates a percolator mapping for the given index and document type.", "response": "def _create_percolator_mapping(index, doc_type):\n    \"\"\"Update mappings with the percolator field.\n\n    .. note::\n\n        This is only needed from ElasticSearch v5 onwards, because percolators\n        are now just a special type of field inside mappings.\n    \"\"\"\n    if ES_VERSION[0] >= 5:\n        current_search_client.indices.put_mapping(\n            index=index, doc_type=doc_type,\n            body=PERCOLATOR_MAPPING, ignore=[400, 404])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting results for a percolate query.", "response": "def _percolate_query(index, doc_type, percolator_doc_type, document):\n    \"\"\"Get results for a percolate query.\"\"\"\n    if ES_VERSION[0] in (2, 5):\n        results = current_search_client.percolate(\n            index=index, doc_type=doc_type, allow_no_indices=True,\n            ignore_unavailable=True, body={'doc': document}\n        )\n        return results['matches']\n    elif ES_VERSION[0] == 6:\n        results = current_search_client.search(\n            index=index, doc_type=percolator_doc_type, allow_no_indices=True,\n            ignore_unavailable=True, body={\n                'query': {\n                    'percolate': {\n                        'field': 'query',\n                        'document_type': percolator_doc_type,\n                        'document': document,\n                    }\n                }\n            }\n        )\n        return results['hits']['hits']"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _new_percolator(spec, search_pattern):\n    if spec and search_pattern:\n        query = query_string_parser(search_pattern=search_pattern).to_dict()\n        for index in current_search.mappings.keys():\n            # Create the percolator doc_type in the existing index for >= ES5\n            # TODO: Consider doing this only once in app initialization\n            percolator_doc_type = _get_percolator_doc_type(index)\n            _create_percolator_mapping(index, percolator_doc_type)\n            current_search_client.index(\n                index=index, doc_type=percolator_doc_type,\n                id='oaiset-{}'.format(spec),\n                body={'query': query}\n            )", "response": "Create new percolator associated with the new set."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ndelete percolator associated with the new oaiset.", "response": "def _delete_percolator(spec, search_pattern):\n    \"\"\"Delete percolator associated with the new oaiset.\"\"\"\n    if spec:\n        for index in current_search.mappings.keys():\n            # Create the percolator doc_type in the existing index for >= ES5\n            percolator_doc_type = _get_percolator_doc_type(index)\n            _create_percolator_mapping(index, percolator_doc_type)\n            current_search_client.delete(\n                index=index, doc_type=percolator_doc_type,\n                id='oaiset-{}'.format(spec), ignore=[404]\n            )"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef update_affected_records(spec=None, search_pattern=None):\n    chunk_size = current_app.config['OAISERVER_CELERY_TASK_CHUNK_SIZE']\n    record_ids = get_affected_records(spec=spec, search_pattern=search_pattern)\n\n    group(\n        update_records_sets.s(list(filter(None, chunk)))\n        for chunk in zip_longest(*[iter(record_ids)] * chunk_size)\n    )()", "response": "Update all affected records by OAISet change."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncreates OAI - PMH envelope for response.", "response": "def envelope(**kwargs):\n    \"\"\"Create OAI-PMH envelope for response.\"\"\"\n    e_oaipmh = Element(etree.QName(NS_OAIPMH, 'OAI-PMH'), nsmap=NSMAP)\n    e_oaipmh.set(etree.QName(NS_XSI, 'schemaLocation'),\n                 '{0} {1}'.format(NS_OAIPMH, NS_OAIPMH_XSD))\n    e_tree = ElementTree(element=e_oaipmh)\n\n    if current_app.config['OAISERVER_XSL_URL']:\n        e_oaipmh.addprevious(etree.ProcessingInstruction(\n            'xml-stylesheet', 'type=\"text/xsl\" href=\"{0}\"'\n                .format(current_app.config['OAISERVER_XSL_URL'])))\n\n    e_responseDate = SubElement(\n        e_oaipmh, etree.QName(\n            NS_OAIPMH, 'responseDate'))\n    # date should be first possible moment\n    e_responseDate.text = datetime_to_datestamp(datetime.utcnow())\n    e_request = SubElement(e_oaipmh, etree.QName(NS_OAIPMH, 'request'))\n    for key, value in kwargs.items():\n        if key == 'from_' or key == 'until':\n            value = datetime_to_datestamp(value)\n        elif key == 'resumptionToken':\n            value = value['token']\n        e_request.set(key, value)\n    e_request.text = url_for('invenio_oaiserver.response', _external=True)\n    return e_tree, e_oaipmh"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef verb(**kwargs):\n    e_tree, e_oaipmh = envelope(**kwargs)\n    e_element = SubElement(e_oaipmh, etree.QName(NS_OAIPMH, kwargs['verb']))\n    return e_tree, e_element", "response": "Create OAI - PMH envelope for response with verb."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate OAI - PMH response for verb Identify.", "response": "def identify(**kwargs):\n    \"\"\"Create OAI-PMH response for verb Identify.\"\"\"\n    cfg = current_app.config\n\n    e_tree, e_identify = verb(**kwargs)\n\n    e_repositoryName = SubElement(\n        e_identify, etree.QName(NS_OAIPMH, 'repositoryName'))\n    e_repositoryName.text = cfg['OAISERVER_REPOSITORY_NAME']\n\n    e_baseURL = SubElement(e_identify, etree.QName(NS_OAIPMH, 'baseURL'))\n    e_baseURL.text = url_for('invenio_oaiserver.response', _external=True)\n\n    e_protocolVersion = SubElement(e_identify,\n                                   etree.QName(NS_OAIPMH, 'protocolVersion'))\n    e_protocolVersion.text = cfg['OAISERVER_PROTOCOL_VERSION']\n\n    for adminEmail in cfg['OAISERVER_ADMIN_EMAILS']:\n        e = SubElement(e_identify, etree.QName(NS_OAIPMH, 'adminEmail'))\n        e.text = adminEmail\n\n    e_earliestDatestamp = SubElement(\n        e_identify, etree.QName(\n            NS_OAIPMH, 'earliestDatestamp'))\n    earliest_date = datetime(MINYEAR, 1, 1)\n    earliest_record = OAIServerSearch(\n        index=current_app.config['OAISERVER_RECORD_INDEX']).sort({\n            \"_created\": {\"order\": \"asc\"}})[0:1].execute()\n    if len(earliest_record.hits.hits) > 0:\n        created_date_str = earliest_record.hits.hits[0].get(\n            \"_source\", {}).get('_created')\n        if created_date_str:\n            earliest_date = arrow.get(\n                created_date_str).to('utc').datetime.replace(tzinfo=None)\n\n    e_earliestDatestamp.text = datetime_to_datestamp(earliest_date)\n\n    e_deletedRecord = SubElement(e_identify,\n                                 etree.QName(NS_OAIPMH, 'deletedRecord'))\n    e_deletedRecord.text = 'no'\n\n    e_granularity = SubElement(e_identify,\n                               etree.QName(NS_OAIPMH, 'granularity'))\n    assert cfg['OAISERVER_GRANULARITY'] in DATETIME_FORMATS\n    e_granularity.text = cfg['OAISERVER_GRANULARITY']\n\n    compressions = cfg['OAISERVER_COMPRESSIONS']\n    if compressions != ['identity']:\n        for compression in compressions:\n            e_compression = SubElement(e_identify,\n                                       etree.QName(NS_OAIPMH, 'compression'))\n            e_compression.text = compression\n\n    for description in cfg.get('OAISERVER_DESCRIPTIONS', []):\n        e_description = SubElement(e_identify,\n                                   etree.QName(NS_OAIPMH, 'description'))\n        e_description.append(etree.fromstring(description))\n\n    return e_tree"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef resumption_token(parent, pagination, **kwargs):\n    # Do not add resumptionToken if all results fit to the first page.\n    if pagination.page == 1 and not pagination.has_next:\n        return\n\n    token = serialize(pagination, **kwargs)\n    e_resumptionToken = SubElement(parent, etree.QName(NS_OAIPMH,\n                                                       'resumptionToken'))\n    if pagination.total:\n        expiration_date = datetime.utcnow() + timedelta(\n            seconds=current_app.config[\n                'OAISERVER_RESUMPTION_TOKEN_EXPIRE_TIME'\n            ]\n        )\n        e_resumptionToken.set('expirationDate', datetime_to_datestamp(\n            expiration_date\n        ))\n        e_resumptionToken.set('cursor', str(\n            (pagination.page - 1) * pagination.per_page\n        ))\n        e_resumptionToken.set('completeListSize', str(pagination.total))\n\n    if token:\n        e_resumptionToken.text = token", "response": "Attach resumption token element to a parent element."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef listsets(**kwargs):\n    e_tree, e_listsets = verb(**kwargs)\n\n    page = kwargs.get('resumptionToken', {}).get('page', 1)\n    size = current_app.config['OAISERVER_PAGE_SIZE']\n    oai_sets = OAISet.query.paginate(page=page, per_page=size, error_out=False)\n\n    for oai_set in oai_sets.items:\n        e_set = SubElement(e_listsets, etree.QName(NS_OAIPMH, 'set'))\n        e_setSpec = SubElement(e_set, etree.QName(NS_OAIPMH, 'setSpec'))\n        e_setSpec.text = oai_set.spec\n        e_setName = SubElement(e_set, etree.QName(NS_OAIPMH, 'setName'))\n        e_setName.text = sanitize_unicode(oai_set.name)\n        if oai_set.description:\n            e_setDescription = SubElement(e_set, etree.QName(NS_OAIPMH,\n                                                             'setDescription'))\n            e_dc = SubElement(\n                e_setDescription, etree.QName(NS_OAIDC, 'dc'),\n                nsmap=NSMAP_DESCRIPTION\n            )\n            e_dc.set(etree.QName(NS_XSI, 'schemaLocation'), NS_OAIDC)\n            e_description = SubElement(e_dc, etree.QName(NS_DC, 'description'))\n            e_description.text = oai_set.description\n\n    resumption_token(e_listsets, oai_sets, **kwargs)\n    return e_tree", "response": "Create OAI - PMH response for ListSets verb."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef listmetadataformats(**kwargs):\n    cfg = current_app.config\n    e_tree, e_listmetadataformats = verb(**kwargs)\n\n    if 'identifier' in kwargs:\n        # test if record exists\n        OAIIDProvider.get(pid_value=kwargs['identifier'])\n\n    for prefix, metadata in cfg.get('OAISERVER_METADATA_FORMATS', {}).items():\n        e_metadataformat = SubElement(\n            e_listmetadataformats, etree.QName(NS_OAIPMH, 'metadataFormat')\n        )\n        e_metadataprefix = SubElement(\n            e_metadataformat, etree.QName(NS_OAIPMH, 'metadataPrefix')\n        )\n        e_metadataprefix.text = prefix\n        e_schema = SubElement(\n            e_metadataformat, etree.QName(NS_OAIPMH, 'schema')\n        )\n        e_schema.text = metadata['schema']\n        e_metadataNamespace = SubElement(\n            e_metadataformat, etree.QName(NS_OAIPMH, 'metadataNamespace')\n        )\n        e_metadataNamespace.text = metadata['namespace']\n\n    return e_tree", "response": "Create OAI - PMH response for ListMetadataFormats verb."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nattaching a header element to a parent element.", "response": "def header(parent, identifier, datestamp, sets=None, deleted=False):\n    \"\"\"Attach ``<header/>`` element to a parent.\"\"\"\n    e_header = SubElement(parent, etree.QName(NS_OAIPMH, 'header'))\n    if deleted:\n        e_header.set('status', 'deleted')\n    e_identifier = SubElement(e_header, etree.QName(NS_OAIPMH, 'identifier'))\n    e_identifier.text = identifier\n    e_datestamp = SubElement(e_header, etree.QName(NS_OAIPMH, 'datestamp'))\n    e_datestamp.text = datetime_to_datestamp(datestamp)\n    for spec in sets or []:\n        e = SubElement(e_header, etree.QName(NS_OAIPMH, 'setSpec'))\n        e.text = spec\n    return e_header"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncreates OAI - PMH response for verb Identify.", "response": "def getrecord(**kwargs):\n    \"\"\"Create OAI-PMH response for verb Identify.\"\"\"\n    record_dumper = serializer(kwargs['metadataPrefix'])\n    pid = OAIIDProvider.get(pid_value=kwargs['identifier']).pid\n    record = Record.get_record(pid.object_uuid)\n\n    e_tree, e_getrecord = verb(**kwargs)\n    e_record = SubElement(e_getrecord, etree.QName(NS_OAIPMH, 'record'))\n\n    header(\n        e_record,\n        identifier=pid.pid_value,\n        datestamp=record.updated,\n        sets=record.get('_oai', {}).get('sets', []),\n    )\n    e_metadata = SubElement(e_record,\n                            etree.QName(NS_OAIPMH, 'metadata'))\n    e_metadata.append(record_dumper(pid, {'_source': record}))\n\n    return e_tree"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncreates OAI - PMH response for verb ListIdentifiers.", "response": "def listidentifiers(**kwargs):\n    \"\"\"Create OAI-PMH response for verb ListIdentifiers.\"\"\"\n    e_tree, e_listidentifiers = verb(**kwargs)\n    result = get_records(**kwargs)\n\n    for record in result.items:\n        pid = oaiid_fetcher(record['id'], record['json']['_source'])\n        header(\n            e_listidentifiers,\n            identifier=pid.pid_value,\n            datestamp=record['updated'],\n            sets=record['json']['_source'].get('_oai', {}).get('sets', []),\n        )\n\n    resumption_token(e_listidentifiers, result, **kwargs)\n    return e_tree"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate OAI - PMH response for verb ListRecords.", "response": "def listrecords(**kwargs):\n    \"\"\"Create OAI-PMH response for verb ListRecords.\"\"\"\n    record_dumper = serializer(kwargs['metadataPrefix'])\n\n    e_tree, e_listrecords = verb(**kwargs)\n    result = get_records(**kwargs)\n\n    for record in result.items:\n        pid = oaiid_fetcher(record['id'], record['json']['_source'])\n        e_record = SubElement(e_listrecords,\n                              etree.QName(NS_OAIPMH, 'record'))\n        header(\n            e_record,\n            identifier=pid.pid_value,\n            datestamp=record['updated'],\n            sets=record['json']['_source'].get('_oai', {}).get('sets', []),\n        )\n        e_metadata = SubElement(e_record, etree.QName(NS_OAIPMH, 'metadata'))\n        e_metadata.append(record_dumper(pid, record['json']))\n\n    resumption_token(e_listrecords, result, **kwargs)\n    return e_tree"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nfetching a record s identifier.", "response": "def oaiid_fetcher(record_uuid, data):\n    \"\"\"Fetch a record's identifier.\n\n    :param record_uuid: The record UUID.\n    :param data: The record data.\n    :returns: A :class:`invenio_pidstore.fetchers.FetchedPID` instance.\n    \"\"\"\n    pid_value = data.get('_oai', {}).get('id')\n    if pid_value is None:\n        raise PersistentIdentifierError()\n    return FetchedPID(\n        provider=OAIIDProvider,\n        pid_type=OAIIDProvider.pid_type,\n        pid_value=str(pid_value),\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef validate_spec(self, key, value):\n        if self.spec and self.spec != value:\n            raise OAISetSpecUpdateError(\"Updating spec is not allowed.\")\n        return value", "response": "Validate that the spec is correct."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef add_record(self, record):\n        record.setdefault('_oai', {}).setdefault('sets', [])\n\n        assert not self.has_record(record)\n\n        record['_oai']['sets'].append(self.spec)", "response": "Add a record to the OAISet."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nremove a record from the OAISet.", "response": "def remove_record(self, record):\n        \"\"\"Remove a record from the OAISet.\n\n        :param record: Record to be removed.\n        :type record: `invenio_records.api.Record` or derivative.\n        \"\"\"\n        assert self.has_record(record)\n\n        record['_oai']['sets'] = [\n            s for s in record['_oai']['sets'] if s != self.spec]"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ninitializing OAI - PMH server.", "response": "def oaiserver(sets, records):\n    \"\"\"Initialize OAI-PMH server.\"\"\"\n    from invenio_db import db\n    from invenio_oaiserver.models import OAISet\n    from invenio_records.api import Record\n\n    # create a OAI Set\n    with db.session.begin_nested():\n        for i in range(sets):\n            db.session.add(OAISet(\n                spec='test{0}'.format(i),\n                name='Test{0}'.format(i),\n                description='test desc {0}'.format(i),\n                search_pattern='title_statement.title:Test{0}'.format(i),\n            ))\n\n    # create a record\n    schema = {\n        'type': 'object',\n        'properties': {\n            'title_statement': {\n                'type': 'object',\n                'properties': {\n                    'title': {\n                        'type': 'string',\n                    },\n                },\n            },\n            'field': {'type': 'boolean'},\n        },\n    }\n\n    with app.app_context():\n        indexer = RecordIndexer()\n        with db.session.begin_nested():\n            for i in range(records):\n                record_id = uuid.uuid4()\n                data = {\n                    'title_statement': {'title': 'Test{0}'.format(i)},\n                    '$schema': schema,\n                }\n                recid_minter(record_id, data)\n                oaiid_minter(record_id, data)\n                record = Record.create(data, id_=record_id)\n                indexer.index(record)\n\n        db.session.commit()"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns etree_dumper instances. :param metadata_prefix: One of the metadata identifiers configured in ``OAISERVER_METADATA_FORMATS``.", "response": "def serializer(metadata_prefix):\n    \"\"\"Return etree_dumper instances.\n\n    :param metadata_prefix: One of the metadata identifiers configured in\n        ``OAISERVER_METADATA_FORMATS``.\n    \"\"\"\n    metadataFormats = current_app.config['OAISERVER_METADATA_FORMATS']\n    serializer_ = metadataFormats[metadata_prefix]['serializer']\n    if isinstance(serializer_, tuple):\n        return partial(import_string(serializer_[0]), **serializer_[1])\n    return import_string(serializer_)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ndumps MARC21 compatible record.", "response": "def dumps_etree(pid, record, **kwargs):\n    \"\"\"Dump MARC21 compatible record.\n\n    :param pid: The :class:`invenio_pidstore.models.PersistentIdentifier`\n        instance.\n    :param record: The :class:`invenio_records.api.Record` instance.\n    :returns: A LXML Element instance.\n    \"\"\"\n    from dojson.contrib.to_marc21 import to_marc21\n    from dojson.contrib.to_marc21.utils import dumps_etree\n\n    return dumps_etree(to_marc21.do(record['_source']), **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ngenerate the eprints element for the identify response.", "response": "def eprints_description(metadataPolicy, dataPolicy,\n                        submissionPolicy=None, content=None):\n    \"\"\"Generate the eprints element for the identify response.\n\n    The eprints container is used by the e-print community to describe\n    the content and policies of repositories.\n    For the full specification and schema definition visit:\n    http://www.openarchives.org/OAI/2.0/guidelines-eprints.htm\n    \"\"\"\n    eprints = Element(etree.QName(NS_EPRINTS[None], 'eprints'),\n                      nsmap=NS_EPRINTS)\n    eprints.set(etree.QName(ns['xsi'], 'schemaLocation'),\n                '{0} {1}'.format(EPRINTS_SCHEMA_LOCATION,\n                                 EPRINTS_SCHEMA_LOCATION_XSD))\n    if content:\n        contentElement = etree.Element('content')\n        for key, value in content.items():\n            contentElement.append(E(key, value))\n        eprints.append(contentElement)\n\n    metadataPolicyElement = etree.Element('metadataPolicy')\n    for key, value in metadataPolicy.items():\n        metadataPolicyElement.append(E(key, value))\n        eprints.append(metadataPolicyElement)\n\n    dataPolicyElement = etree.Element('dataPolicy')\n    for key, value in dataPolicy.items():\n        dataPolicyElement.append(E(key, value))\n        eprints.append(dataPolicyElement)\n\n    if submissionPolicy:\n        submissionPolicyElement = etree.Element('submissionPolicy')\n        for key, value in submissionPolicy.items():\n            submissionPolicyElement.append(E(key, value))\n        eprints.append(submissionPolicyElement)\n    return etree.tostring(eprints, pretty_print=True)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef oai_identifier_description(scheme, repositoryIdentifier,\n                               delimiter, sampleIdentifier):\n    \"\"\"Generate the oai-identifier element for the identify response.\n\n    The OAI identifier format is intended to provide persistent resource\n    identifiers for items in repositories that implement OAI-PMH.\n    For the full specification and schema definition visit:\n    http://www.openarchives.org/OAI/2.0/guidelines-oai-identifier.htm\n    \"\"\"\n    oai_identifier = Element(etree.QName(NS_OAI_IDENTIFIER[None],\n                             'oai_identifier'),\n                             nsmap=NS_OAI_IDENTIFIER)\n    oai_identifier.set(etree.QName(ns['xsi'], 'schemaLocation'),\n                       '{0} {1}'.format(OAI_IDENTIFIER_SCHEMA_LOCATION,\n                                        OAI_IDENTIFIER_SCHEMA_LOCATION_XSD))\n    oai_identifier.append(E('scheme', scheme))\n    oai_identifier.append(E('repositoryIdentifier', repositoryIdentifier))\n    oai_identifier.append(E('delimiter', delimiter))\n    oai_identifier.append(E('sampleIdentifier', sampleIdentifier))\n    return etree.tostring(oai_identifier, pretty_print=True)", "response": "Generate the oai - identifier element for the identify response."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngenerates the friends element for the identify response.", "response": "def friends_description(baseURLs):\n    \"\"\"Generate the friends element for the identify response.\n\n    The friends container is recommended for use by repositories\n    to list confederate repositories.\n    For the schema definition visit:\n    http://www.openarchives.org/OAI/2.0/guidelines-friends.htm\n    \"\"\"\n    friends = Element(etree.QName(NS_FRIENDS[None], 'friends'),\n                      nsmap=NS_FRIENDS)\n    friends.set(etree.QName(ns['xsi'], 'schemaLocation'),\n                '{0} {1}'.format(FRIENDS_SCHEMA_LOCATION,\n                                 FRIENDS_SCHEMA_LOCATION_XSD))\n    for baseURL in baseURLs:\n        friends.append(E('baseURL', baseURL))\n    return etree.tostring(friends, pretty_print=True)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nupdate records on OAISet insertion.", "response": "def after_insert_oai_set(mapper, connection, target):\n    \"\"\"Update records on OAISet insertion.\"\"\"\n    _new_percolator(spec=target.spec, search_pattern=target.search_pattern)\n    sleep(2)\n    update_affected_records.delay(\n        search_pattern=target.search_pattern\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nupdates records on OAISet update.", "response": "def after_update_oai_set(mapper, connection, target):\n    \"\"\"Update records on OAISet update.\"\"\"\n    _delete_percolator(spec=target.spec, search_pattern=target.search_pattern)\n    _new_percolator(spec=target.spec, search_pattern=target.search_pattern)\n    sleep(2)\n    update_affected_records.delay(\n        spec=target.spec, search_pattern=target.search_pattern\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef after_delete_oai_set(mapper, connection, target):\n    _delete_percolator(spec=target.spec, search_pattern=target.search_pattern)\n    sleep(2)\n    update_affected_records.delay(\n        spec=target.spec\n    )", "response": "Update records on OAISet deletion."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef query_string_parser(search_pattern):\n    if not hasattr(current_oaiserver, 'query_parser'):\n        query_parser = current_app.config['OAISERVER_QUERY_PARSER']\n        if isinstance(query_parser, six.string_types):\n            query_parser = import_string(query_parser)\n        current_oaiserver.query_parser = query_parser\n    return current_oaiserver.query_parser('query_string', query=search_pattern)", "response": "Elasticsearch query string parser."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_affected_records(spec=None, search_pattern=None):\n    # spec       pattern    query\n    # ---------- ---------- -------\n    # None       None       None\n    # None       Y          Y\n    # X          None       X\n    # X          ''         X\n    # X          Y          X OR Y\n\n    if spec is None and search_pattern is None:\n        raise StopIteration\n\n    queries = []\n\n    if spec is not None:\n        queries.append(Q('match', **{'_oai.sets': spec}))\n\n    if search_pattern:\n        queries.append(query_string_parser(search_pattern=search_pattern))\n\n    search = OAIServerSearch(\n        index=current_app.config['OAISERVER_RECORD_INDEX'],\n    ).query(Q('bool', should=queries))\n\n    for result in search.scan():\n        yield result.meta.id", "response": "Get list of affected records."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the path to a file in the current directory.", "response": "def get_file_path(filename, local=True, relative_to_module=None, my_dir=my_dir):\n    \"\"\"\n    Look for an existing path matching filename.\n    Try to resolve relative to the module location if the path cannot by found\n    using \"normal\" resolution.\n    \"\"\"\n    # override my_dir if module is provided\n    if relative_to_module is not None:\n        my_dir = os.path.dirname(relative_to_module.__file__)\n    user_path = result = filename\n    if local:\n        user_path = os.path.expanduser(filename)\n        result = os.path.abspath(user_path)\n        if os.path.exists(result):\n            return result  # The file was found normally\n    # otherwise look relative to the module.\n    result = os.path.join(my_dir, filename)\n    assert os.path.exists(result), \"no such file \" + repr((filename, result, user_path))\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef load_if_not_loaded(widget, filenames, verbose=False, delay=0.1, force=False, local=True, evaluator=None):\n    if evaluator is None:\n        evaluator = EVALUATOR  # default if not specified.\n    for filename in filenames:\n        loaded = False\n        if force or not filename in LOADED_JAVASCRIPT:\n            js_text = get_text_from_file_name(filename, local)\n            if verbose:\n                print(\"loading javascript file\", filename, \"with\", evaluator)\n            evaluator(widget, js_text)\n            LOADED_JAVASCRIPT.add(filename)\n            loaded = True\n        else:\n            if verbose:\n                print (\"not reloading javascript file\", filename)\n        if loaded and delay > 0:\n            if verbose:\n                print (\"delaying to allow JS interpreter to sync.\")\n            time.sleep(delay)", "response": "Load a javascript file to the Jupyter notebook context if it is not already loaded."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _set(self, name, value):\n        \"Proxy to set a property of the widget element.\"\n        return self.widget(self.widget_element._set(name, value))", "response": "Proxy to set a property of the widget element."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nstripping the outer tag if text starts with a tag.", "response": "def strip_outer_tag(text):\n    \"\"\"Strips the outer tag, if text starts with a tag.  Not entity aware;\n    designed to quickly strip outer tags from lxml cleaner output.  Only\n    checks for <p> and <div> outer tags.\"\"\"\n    if not text or not isinstance(text, basestring):\n        return text\n    stripped = text.strip()\n    if (stripped.startswith('<p>') or stripped.startswith('<div>')) and \\\n        (stripped.endswith('</p>') or stripped.endswith('</div>')):\n        return stripped[stripped.index('>')+1:stripped.rindex('<')]\n    return text"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef munge_author(author):\n    # this loveliness is from feedparser but was not usable as a function\n    if '@' in author:\n        emailmatch = re.search(r\"(([a-zA-Z0-9\\_\\-\\.\\+]+)@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.)|(([a-zA-Z0-9\\-]+\\.)+))([a-zA-Z]{2,4}|[0-9]{1,3})(\\]?))(\\?subject=\\S+)?\", author, re.UNICODE)\n        if emailmatch:\n            email = emailmatch.group(0)\n            # probably a better way to do the following, but it passes all the tests\n            author = author.replace(email, u'')\n            author = author.replace(u'()', u'')\n            author = author.replace(u'<>', u'')\n            author = author.replace(u'&lt;&gt;', u'')\n            author = author.strip()\n            if author and (author[0] == u'('):\n                author = author[1:]\n            if author and (author[-1] == u')'):\n                author = author[:-1]\n            author = author.strip()\n            return '%s (%s)' % (author, email)\n    return author", "response": "Munge an author into a format that can be used in a sequence of author names and emails."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ndetermining the base url for a root element.", "response": "def base_url(root):\n    \"\"\"Determine the base url for a root element.\"\"\"\n    for attr, value in root.attrib.iteritems():\n        if attr.endswith('base') and 'http' in value:\n            return value\n    return None"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a tag and its namespace separately.", "response": "def clean_ns(tag):\n    \"\"\"Return a tag and its namespace separately.\"\"\"\n    if '}' in tag:\n        split = tag.split('}')\n        return split[0].strip('{'), split[-1]\n    return '', tag"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef innertext(node):\n    if not len(node):\n        return node.text\n\n    return (node.text or '') + ''.join([etree.tostring(c) for c in node]) + (node.tail or '')", "response": "Return the inner text of a node."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nparsing a document and return a feedparser dictionary with attr key access.", "response": "def parse(document, clean_html=True, unix_timestamp=False, encoding=None):\n    \"\"\"Parse a document and return a feedparser dictionary with attr key access.\n    If clean_html is False, the html in the feed will not be cleaned.  If\n    clean_html is True, a sane version of lxml.html.clean.Cleaner will be used.\n    If it is a Cleaner object, that cleaner will be used.  If unix_timestamp is\n    True, the date information will be a numerical unix timestamp rather than a\n    struct_time.  If encoding is provided, the encoding of the document will be\n    manually set to that.\"\"\"\n    if isinstance(clean_html, bool):\n        cleaner = default_cleaner if clean_html else fake_cleaner\n    else:\n        cleaner = clean_html\n    result = feedparser.FeedParserDict()\n    result['feed'] = feedparser.FeedParserDict()\n    result['entries'] = []\n    result['bozo'] = 0\n    try:\n        parser = SpeedParser(document, cleaner, unix_timestamp, encoding)\n        parser.update(result)\n    except Exception as e:\n        if isinstance(e, UnicodeDecodeError) and encoding is True:\n            encoding = chardet.detect(document)['encoding']\n            document = document.decode(encoding, 'replace').encode('utf-8')\n            return parse(document, clean_html, unix_timestamp, encoding)\n        import traceback\n        result['bozo'] = 1\n        result['bozo_exception'] = e\n        result['bozo_tb'] = traceback.format_exc()\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef changed_path(self):\n        \"Find any changed path and update all changed modification times.\"\n        result = None  # default\n        for path in self.paths_to_modification_times:\n            lastmod = self.paths_to_modification_times[path]\n            mod = os.path.getmtime(path)\n            if mod > lastmod:\n                result = \"Watch file has been modified: \" + repr(path)\n            self.paths_to_modification_times[path] = mod\n        for folder in self.folder_paths:\n            for filename in os.listdir(folder):\n                subpath = os.path.join(folder, filename)\n                if os.path.isfile(subpath) and subpath not in self.paths_to_modification_times:\n                    result = \"New file in watched folder: \" + repr(subpath)\n                    self.add(subpath)\n        if self.check_python_modules:\n            # refresh the modules\n            self.add_all_modules()\n        if self.check_javascript:\n            self.watch_javascript()\n        return result", "response": "Find any changed path and update all changed modification times."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nparsing a variety of ISO - 8601 - compatible formats like 20040105.", "response": "def _parse_date_iso8601(dateString):\n    '''Parse a variety of ISO-8601-compatible formats like 20040105'''\n    m = None\n    for _iso8601_match in _iso8601_matches:\n        m = _iso8601_match(dateString)\n        if m:\n            break\n    if not m:\n        return\n    if m.span() == (0, 0):\n        return\n    params = m.groupdict()\n    ordinal = params.get('ordinal', 0)\n    if ordinal:\n        ordinal = int(ordinal)\n    else:\n        ordinal = 0\n    year = params.get('year', '--')\n    if not year or year == '--':\n        year = time.gmtime()[0]\n    elif len(year) == 2:\n        # ISO 8601 assumes current century, i.e. 93 -> 2093, NOT 1993\n        year = 100 * int(time.gmtime()[0] / 100) + int(year)\n    else:\n        year = int(year)\n    month = params.get('month', '-')\n    if not month or month == '-':\n        # ordinals are NOT normalized by mktime, we simulate them\n        # by setting month=1, day=ordinal\n        if ordinal:\n            month = 1\n        else:\n            month = time.gmtime()[1]\n    month = int(month)\n    day = params.get('day', 0)\n    if not day:\n        # see above\n        if ordinal:\n            day = ordinal\n        elif params.get('century', 0) or \\\n                 params.get('year', 0) or params.get('month', 0):\n            day = 1\n        else:\n            day = time.gmtime()[2]\n    else:\n        day = int(day)\n    # special case of the century - is the first year of the 21st century\n    # 2000 or 2001 ? The debate goes on...\n    if 'century' in params:\n        year = (int(params['century']) - 1) * 100 + 1\n    # in ISO 8601 most fields are optional\n    for field in ['hour', 'minute', 'second', 'tzhour', 'tzmin']:\n        if not params.get(field, None):\n            params[field] = 0\n    hour = int(params.get('hour', 0))\n    minute = int(params.get('minute', 0))\n    second = int(float(params.get('second', 0)))\n    # weekday is normalized by mktime(), we can ignore it\n    weekday = 0\n    daylight_savings_flag = -1\n    tm = [year, month, day, hour, minute, second, weekday,\n          ordinal, daylight_savings_flag]\n    # ISO 8601 time zone adjustments\n    tz = params.get('tz')\n    if tz and tz != 'Z':\n        if tz[0] == '-':\n            tm[3] += int(params.get('tzhour', 0))\n            tm[4] += int(params.get('tzmin', 0))\n        elif tz[0] == '+':\n            tm[3] -= int(params.get('tzhour', 0))\n            tm[4] -= int(params.get('tzmin', 0))\n        else:\n            return None\n    # Python's time.mktime() is a wrapper around the ANSI C mktime(3c)\n    # which is guaranteed to normalize d/m/y/h/m/s.\n    # Many implementations have bugs, but we'll pretend they don't.\n    return time.localtime(time.mktime(tuple(tm)))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nparse a string according to the OnBlog 8 - bit date format", "response": "def _parse_date_onblog(dateString):\n    '''Parse a string according to the OnBlog 8-bit date format'''\n    m = _korean_onblog_date_re.match(dateString)\n    if not m:\n        return\n    w3dtfdate = '%(year)s-%(month)s-%(day)sT%(hour)s:%(minute)s:%(second)s%(zonediff)s' % \\\n                {'year': m.group(1), 'month': m.group(2), 'day': m.group(3),\\\n                 'hour': m.group(4), 'minute': m.group(5), 'second': m.group(6),\\\n                 'zonediff': '+09:00'}\n    return _parse_date_w3dtf(w3dtfdate)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _parse_date_nate(dateString):\n    '''Parse a string according to the Nate 8-bit date format'''\n    m = _korean_nate_date_re.match(dateString)\n    if not m:\n        return\n    hour = int(m.group(5))\n    ampm = m.group(4)\n    if (ampm == _korean_pm):\n        hour += 12\n    hour = str(hour)\n    if len(hour) == 1:\n        hour = '0' + hour\n    w3dtfdate = '%(year)s-%(month)s-%(day)sT%(hour)s:%(minute)s:%(second)s%(zonediff)s' % \\\n                {'year': m.group(1), 'month': m.group(2), 'day': m.group(3),\\\n                 'hour': hour, 'minute': m.group(6), 'second': m.group(7),\\\n                 'zonediff': '+09:00'}\n    return _parse_date_w3dtf(w3dtfdate)", "response": "Parse a string according to the Nate 8 - bit date format"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nparsing a string according to a Greek 8 - bit date format.", "response": "def _parse_date_greek(dateString):\n    '''Parse a string according to a Greek 8-bit date format.'''\n    m = _greek_date_format_re.match(dateString)\n    if not m:\n        return\n    wday = _greek_wdays[m.group(1)]\n    month = _greek_months[m.group(3)]\n    rfc822date = '%(wday)s, %(day)s %(month)s %(year)s %(hour)s:%(minute)s:%(second)s %(zonediff)s' % \\\n                 {'wday': wday, 'day': m.group(2), 'month': month, 'year': m.group(4),\\\n                  'hour': m.group(5), 'minute': m.group(6), 'second': m.group(7),\\\n                  'zonediff': m.group(8)}\n    return _parse_date_rfc822(rfc822date)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _parse_date_hungarian(dateString):\n    '''Parse a string according to a Hungarian 8-bit date format.'''\n    m = _hungarian_date_format_re.match(dateString)\n    if not m or m.group(2) not in _hungarian_months:\n        return None\n    month = _hungarian_months[m.group(2)]\n    day = m.group(3)\n    if len(day) == 1:\n        day = '0' + day\n    hour = m.group(4)\n    if len(hour) == 1:\n        hour = '0' + hour\n    w3dtfdate = '%(year)s-%(month)s-%(day)sT%(hour)s:%(minute)s%(zonediff)s' % \\\n                {'year': m.group(1), 'month': month, 'day': day,\\\n                 'hour': hour, 'minute': m.group(5),\\\n                 'zonediff': m.group(6)}\n    return _parse_date_w3dtf(w3dtfdate)", "response": "Parse a string according to a Hungarian 8 - bit date format."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _parse_date_rfc822(dateString):\n    '''Parse an RFC822, RFC1123, RFC2822, or asctime-style date'''\n    data = dateString.split()\n    if not data:\n        return None\n    if data[0][-1] in (',', '.') or data[0].lower() in rfc822._daynames:\n        del data[0]\n    if len(data) == 4:\n        s = data[3]\n        i = s.find('+')\n        if i > 0:\n            data[3:] = [s[:i], s[i+1:]]\n        else:\n            data.append('')\n        dateString = \" \".join(data)\n    # Account for the Etc/GMT timezone by stripping 'Etc/'\n    elif len(data) == 5 and data[4].lower().startswith('etc/'):\n        data[4] = data[4][4:]\n        dateString = \" \".join(data)\n    if len(data) < 5:\n        dateString += ' 00:00:00 GMT'\n    tm = rfc822.parsedate_tz(dateString)\n    if tm:\n        # Jython doesn't adjust for 2-digit years like CPython does,\n        # so account for it by shifting the year so that it's in the\n        # range 1970-2069 (1970 being the year of the Unix epoch).\n        if tm[0] < 100:\n            tm = (tm[0] + (1900, 2000)[tm[0] < 70],) + tm[1:]\n        return time.gmtime(rfc822.mktime_tz(tm))", "response": "Parse an RFC822 date string into a time object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _parse_date_perforce(aDateString):\n    # Fri, 2006/09/15 08:19:53 EDT\n    _my_date_pattern = re.compile( \\\n        r'(\\w{,3}), (\\d{,4})/(\\d{,2})/(\\d{2}) (\\d{,2}):(\\d{2}):(\\d{2}) (\\w{,3})')\n\n    m = _my_date_pattern.search(aDateString)\n    if m is None:\n        return None\n    dow, year, month, day, hour, minute, second, tz = m.groups()\n    months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']\n    dateString = \"%s, %s %s %s %s:%s:%s %s\" % (dow, day, months[int(month) - 1], year, hour, minute, second, tz)\n    tm = rfc822.parsedate_tz(dateString)\n    if tm:\n        return time.gmtime(rfc822.mktime_tz(tm))", "response": "parse a date in yyyyMMDD hhmmmmSS TTT format"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nparse a variety of date formats into a 9 - tuple in GMT", "response": "def parse_date(dateString):\n    '''Parses a variety of date formats into a 9-tuple in GMT'''\n    if not dateString:\n        return None\n    for handler in _date_handlers:\n        try:\n            date9tuple = handler(dateString)\n        except (KeyError, OverflowError, ValueError):\n            continue\n        if not date9tuple:\n            continue\n        if len(date9tuple) != 9:\n            continue\n        return date9tuple\n    return None"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nwraps to allow output redirects for handle_chunk", "response": "def handle_chunk_wrapper(self, status, name, content, file_info):\n        \"\"\"wrapper to allow output redirects for handle_chunk.\"\"\"\n        out = self.output\n        if out is not None:\n            with out:\n                print(\"handling chunk \" + repr(type(content)))\n                self.handle_chunk(status, name, content, file_info)\n        else:\n            self.handle_chunk(status, name, content, file_info)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nhandle one chunk of the file. Override this method for peicewise delivery or error handling.", "response": "def handle_chunk(self, status, name, content, file_info):\n        \"Handle one chunk of the file.  Override this method for peicewise delivery or error handling.\"\n        if status == \"error\":\n            msg = repr(file_info.get(\"message\"))\n            exc = JavaScriptError(msg)\n            exc.file_info = file_info\n            self.status = \"Javascript sent exception \" + msg\n            self.chunk_collector = []\n            raise exc\n        if status == \"more\":\n            self.chunk_collector.append(content)\n            self.progress_callback(self.chunk_collector, file_info)\n        else:\n            assert status == \"done\", \"Unknown status \" + repr(status)\n            self.save_chunks = self.chunk_collector\n            self.chunk_collector.append(content)\n            all_content = self.combine_chunks(self.chunk_collector)\n            self.chunk_collector = []\n            content_callback = self.content_callback\n            if content_callback is None:\n                content_callback = self.default_content_callback\n            self.status = \"calling \" + repr(content_callback)\n            try:\n                content_callback(self.widget, name, all_content)\n            except Exception as e:\n                self.status += \"\\n\" + repr(content_callback) + \" raised \" + repr(e)\n                raise"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a URL for a user to login or register with ORCID.", "response": "def get_login_url(self, scope, redirect_uri, state=None,\n                      family_names=None, given_names=None, email=None,\n                      lang=None, show_login=None):\n        \"\"\"Return a URL for a user to login/register with ORCID.\n\n        Parameters\n        ----------\n        :param scope: string or iterable of strings\n            The scope(s) of the authorization request.\n            For example '/authenticate'\n        :param redirect_uri: string\n            The URI to which the user's browser should be redirected after the\n            login.\n        :param state: string\n            An arbitrary token to prevent CSRF. See the OAuth 2 docs for\n            details.\n        :param family_names: string\n            The user's family name, used to fill the registration form.\n        :param given_names: string\n            The user's given name, used to fill the registration form.\n        :param email: string\n            The user's email address, used to fill the sign-in or registration\n            form.\n        :param lang: string\n            The language in which to display the authorization page.\n        :param show_login: bool\n            Determines whether the log-in or registration form will be shown by\n            default.\n\n        Returns\n        -------\n        :returns: string\n            The URL ready to be offered as a link to the user.\n        \"\"\"\n        if not isinstance(scope, string_types):\n            scope = \" \".join(sorted(set(scope)))\n        data = [(\"client_id\", self._key), (\"scope\", scope),\n                (\"response_type\", \"code\"), (\"redirect_uri\", redirect_uri)]\n        if state:\n            data.append((\"state\", state))\n        if family_names:\n            data.append((\"family_names\", family_names.encode(\"utf-8\")))\n        if given_names:\n            data.append((\"given_names\", given_names.encode(\"utf-8\")))\n        if email:\n            data.append((\"email\", email))\n        if lang:\n            data.append((\"lang\", lang))\n        if show_login is not None:\n            data.append((\"show_login\", \"true\" if show_login else \"false\"))\n        return self._login_or_register_endpoint + \"?\" + urlencode(data)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsearches the ORCID database.", "response": "def search(self, query, method=\"lucene\", start=None,\n               rows=None, access_token=None):\n        \"\"\"Search the ORCID database.\n\n        Parameters\n        ----------\n        :param query: string\n            Query in line with the chosen method.\n        :param method: string\n            One of 'lucene', 'edismax', 'dismax'\n        :param start: string\n            Index of the first record requested. Use for pagination.\n        :param rows: string\n            Number of records requested. Use for pagination.\n        :param access_token: string\n            If obtained before, the access token to use to pass through\n            authorization. Note that if this argument is not provided,\n            the function will take more time.\n\n        Returns\n        -------\n        :returns: dict\n            Search result with error description available. The results can\n            be obtained by accessing key 'result'. To get the number\n            of all results, access the key 'num-found'.\n        \"\"\"\n        if access_token is None:\n            access_token = self. \\\n                get_search_token_from_orcid()\n\n        headers = {'Accept': 'application/orcid+json',\n                   'Authorization': 'Bearer %s' % access_token}\n\n        return self._search(query, method, start, rows, headers,\n                            self._endpoint)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef search_generator(self, query, method=\"lucene\",\n                         pagination=10, access_token=None):\n        \"\"\"Search the ORCID database with a generator.\n\n        The generator will yield every result.\n\n        Parameters\n        ----------\n        :param query: string\n            Query in line with the chosen method.\n        :param method: string\n            One of 'lucene', 'edismax', 'dismax'\n        :param pagination: integer\n            How many papers should be fetched with the request.\n        :param access_token: string\n            If obtained before, the access token to use to pass through\n            authorization. Note that if this argument is not provided,\n            the function will take more time.\n\n        Yields\n        -------\n        :yields: dict\n            Single profile from the search results.\n        \"\"\"\n        if access_token is None:\n            access_token = self. \\\n                get_search_token_from_orcid()\n\n        headers = {'Accept': 'application/orcid+json',\n                   'Authorization': 'Bearer %s' % access_token}\n\n        index = 0\n\n        while True:\n            paginated_result = self._search(query, method, index, pagination,\n                                            headers, self._endpoint)\n            if not paginated_result['result']:\n                return\n\n            for result in paginated_result['result']:\n                yield result\n            index += pagination", "response": "Search the ORCID database with a generator."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget a token for searching records from the ORCID.", "response": "def get_search_token_from_orcid(self, scope='/read-public'):\n        \"\"\"Get a token for searching ORCID records.\n\n        Parameters\n        ----------\n        :param scope: string\n            /read-public or /read-member\n\n        Returns\n        -------\n        :returns: string\n            The token.\n        \"\"\"\n        payload = {'client_id': self._key,\n                   'client_secret': self._secret,\n                   'scope': scope,\n                   'grant_type': 'client_credentials'\n                   }\n\n        url = \"%s/oauth/token\" % self._endpoint\n        headers = {'Accept': 'application/json'}\n\n        response = requests.post(url, data=payload, headers=headers,\n                                 timeout=self._timeout)\n        response.raise_for_status()\n        if self.do_store_raw_response:\n            self.raw_response = response\n        return response.json()['access_token']"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_token(self, user_id, password, redirect_uri,\n                  scope='/read-limited'):\n        \"\"\"Get the token.\n\n        Parameters\n        ----------\n        :param user_id: string\n            The id of the user used for authentication.\n        :param password: string\n            The user password.\n        :param redirect_uri: string\n            The redirect uri of the institution.\n        :param scope: string\n            The desired scope. For example '/activities/update',\n            '/read-limited', etc.\n\n        Returns\n        -------\n        :returns: string\n            The token.\n        \"\"\"\n        response = self._authenticate(user_id, password, redirect_uri,\n                                      scope)\n        return response['access_token']", "response": "Get the token for the user."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_token_from_authorization_code(self,\n                                          authorization_code, redirect_uri):\n        \"\"\"Like `get_token`, but using an OAuth 2 authorization code.\n\n        Use this method if you run a webserver that serves as an endpoint for\n        the redirect URI. The webserver can retrieve the authorization code\n        from the URL that is requested by ORCID.\n\n        Parameters\n        ----------\n        :param redirect_uri: string\n            The redirect uri of the institution.\n        :param authorization_code: string\n            The authorization code.\n\n        Returns\n        -------\n        :returns: dict\n            All data of the access token.  The access token itself is in the\n            ``\"access_token\"`` key.\n        \"\"\"\n        token_dict = {\n            \"client_id\": self._key,\n            \"client_secret\": self._secret,\n            \"grant_type\": \"authorization_code\",\n            \"code\": authorization_code,\n            \"redirect_uri\": redirect_uri,\n        }\n        response = requests.post(self._token_url, data=token_dict,\n                                 headers={'Accept': 'application/json'},\n                                 timeout=self._timeout)\n        response.raise_for_status()\n        if self.do_store_raw_response:\n            self.raw_response = response\n        return json.loads(response.text)", "response": "Like get_token but using an OAuth 2 authorization code."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef read_record_public(self, orcid_id, request_type, token, put_code=None,\n                           accept_type='application/orcid+json'):\n        \"\"\"Get the public info about the researcher.\n\n        Parameters\n        ----------\n        :param orcid_id: string\n            Id of the queried author.\n        :param request_type: string\n            For example: 'record'.\n            See https://members.orcid.org/api/tutorial/read-orcid-records\n            for possible values.\n        :param token: string\n            Token received from OAuth 2 3-legged authorization.\n        :param put_code: string | list of strings\n            The id of the queried work. In case of 'works' request_type\n            might be a list of strings\n        :param accept_type: expected MIME type of received data\n\n        Returns\n        -------\n        :returns: dict | lxml.etree._Element\n            Record(s) in JSON-compatible dictionary representation or\n            in XML E-tree, depending on accept_type specified.\n        \"\"\"\n        return self._get_info(orcid_id, self._get_public_info, request_type,\n                              token, put_code, accept_type)", "response": "Get the public info about the researcher."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nadds a record to a profile.", "response": "def add_record(self, orcid_id, token, request_type, data,\n                   content_type='application/orcid+json'):\n        \"\"\"Add a record to a profile.\n\n        Parameters\n        ----------\n        :param orcid_id: string\n            Id of the author.\n        :param token: string\n            Token received from OAuth 2 3-legged authorization.\n        :param request_type: string\n            One of 'activities', 'education', 'employment', 'funding',\n            'peer-review', 'work'.\n        :param data: dict | lxml.etree._Element\n            The record in Python-friendly format, as either JSON-compatible\n            dictionary (content_type == 'application/orcid+json') or\n            XML (content_type == 'application/orcid+xml')\n        :param content_type: string\n            MIME type of the passed record.\n\n        Returns\n        -------\n        :returns: string\n            Put-code of the new work.\n        \"\"\"\n        return self._update_activities(orcid_id, token, requests.post,\n                                       request_type, data,\n                                       content_type=content_type)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_token(self, user_id, password, redirect_uri,\n                  scope='/activities/update'):\n        \"\"\"Get the token.\n\n        Parameters\n        ----------\n        :param user_id: string\n\n            The id of the user used for authentication.\n        :param password: string\n            The user password.\n        :param redirect_uri: string\n            The redirect uri of the institution.\n        :param scope: string\n            The desired scope. For example '/activities/update',\n            '/read-limited', etc.\n\n        Returns\n        -------\n        :returns: string\n            The token.\n        \"\"\"\n        return super(MemberAPI, self).get_token(user_id, password,\n                                                redirect_uri, scope)", "response": "Get the token for the user."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting the user orcid from authentication process.", "response": "def get_user_orcid(self, user_id, password, redirect_uri):\n        \"\"\"Get the user orcid from authentication process.\n\n        Parameters\n        ----------\n        :param user_id: string\n            The id of the user used for authentication.\n        :param password: string\n            The user password.\n        :param redirect_uri: string\n            The redirect uri of the institution.\n\n        Returns\n        -------\n        :returns: string\n            The orcid.\n        \"\"\"\n        response = self._authenticate(user_id, password, redirect_uri,\n                                      '/authenticate')\n\n        return response['orcid']"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the member info about the researcher.", "response": "def read_record_member(self, orcid_id, request_type, token, put_code=None,\n                           accept_type='application/orcid+json'):\n        \"\"\"Get the member info about the researcher.\n\n        Parameters\n        ----------\n        :param orcid_id: string\n            Id of the queried author.\n        :param request_type: string\n            For example: 'record'.\n            See https://members.orcid.org/api/tutorial/read-orcid-records\n            for possible values..\n        :param response_format: string\n            One of json, xml.\n        :param token: string\n            Token received from OAuth 2 3-legged authorization.\n        :param put_code: string | list of strings\n            The id of the queried work. In case of 'works' request_type\n            might be a list of strings\n        :param accept_type: expected MIME type of received data\n\n        Returns\n        -------\n        :returns: dict | lxml.etree._Element\n            Record(s) in JSON-compatible dictionary representation or\n            in XML E-tree, depending on accept_type specified.\n        \"\"\"\n        return self._get_info(orcid_id, self._get_member_info, request_type,\n                              token, put_code, accept_type)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nadding a record to a profile.", "response": "def remove_record(self, orcid_id, token, request_type, put_code):\n        \"\"\"Add a record to a profile.\n\n        Parameters\n        ----------\n        :param orcid_id: string\n            Id of the author.\n        :param token: string\n            Token received from OAuth 2 3-legged authorization.\n        :param request_type: string\n            One of 'activities', 'education', 'employment', 'funding',\n            'peer-review', 'work'.\n         :param put_code: string\n            The id of the record. Can be retrieved using read_record_* method.\n            In the result of it, it will be called 'put-code'.\n        \"\"\"\n        self._update_activities(orcid_id, token, requests.delete, request_type,\n                                put_code=put_code)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef update_record(self, orcid_id, token, request_type, data, put_code,\n                      content_type='application/orcid+json'):\n        \"\"\"Add a record to a profile.\n\n        Parameters\n        ----------\n        :param orcid_id: string\n            Id of the author.\n        :param token: string\n            Token received from OAuth 2 3-legged authorization.\n        :param request_type: string\n            One of 'activities', 'education', 'employment', 'funding',\n            'peer-review', 'work'.\n        :param data: dict | lxml.etree._Element\n            The record in Python-friendly format, as either JSON-compatible\n            dictionary (content_type == 'application/orcid+json') or\n            XML (content_type == 'application/orcid+xml')\n        :param put_code: string\n            The id of the record. Can be retrieved using read_record_* method.\n            In the result of it, it will be called 'put-code'.\n        :param content_type: string\n            MIME type of the data being sent.\n        \"\"\"\n        self._update_activities(orcid_id, token, requests.put, request_type,\n                                data, put_code, content_type)", "response": "Add a record to a profile."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nremoves any duplicates from the entity relationship table.", "response": "def remove_duplicates(apps, schema_editor):\n    \"\"\"\n    Remove any duplicates from the entity relationship table\n    :param apps:\n    :param schema_editor:\n    :return:\n    \"\"\"\n\n    # Get the model\n    EntityRelationship = apps.get_model('entity', 'EntityRelationship')\n\n    # Find the duplicates\n    duplicates = EntityRelationship.objects.all().order_by(\n        'sub_entity_id',\n        'super_entity_id'\n    ).values(\n        'sub_entity_id',\n        'super_entity_id'\n    ).annotate(\n        Count('sub_entity_id'),\n        Count('super_entity_id'),\n        max_id=Max('id')\n    ).filter(\n        super_entity_id__count__gt=1\n    )\n\n    # Loop over the duplicates and delete\n    for duplicate in duplicates:\n        EntityRelationship.objects.filter(\n            sub_entity_id=duplicate['sub_entity_id'],\n            super_entity_id=duplicate['super_entity_id']\n        ).exclude(\n            id=duplicate['max_id']\n        ).delete()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_access_tokens(self, authorization_code):\n        response = self.box_request.get_access_token(authorization_code)\n        try:\n            att = response.json()\n        except Exception, ex:\n            raise BoxHttpResponseError(ex)\n\n        if response.status_code >= 400:\n            raise BoxError(response.status_code, att)\n\n        return att['access_token'], att['refresh_token']", "response": "Get the access token and refresh token from Box."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef unpack_frame(message):\n    body = []\n    returned = dict(cmd='', headers={}, body='')\n\n    breakdown = message.split('\\n')\n\n    # Get the message command:\n    returned['cmd'] = breakdown[0]\n    breakdown = breakdown[1:]\n\n    def headD(field):\n        # find the first ':' everything to the left of this is a\n        # header, everything to the right is data:\n        index = field.find(':')\n        if index:\n            header = field[:index].strip()\n            data = field[index+1:].strip()\n#            print \"header '%s' data '%s'\" % (header, data)\n            returned['headers'][header.strip()] = data.strip()\n\n    def bodyD(field):\n        field = field.strip()\n        if field:\n            body.append(field)\n\n    # Recover the header fields and body data\n    handler = headD\n    for field in breakdown:\n#        print \"field:\", field\n        if field.strip() == '':\n            # End of headers, it body data next.\n            handler = bodyD\n            continue\n\n        handler(field)\n\n    # Stich the body data together:\n#    print \"1. body: \", body\n    body = \"\".join(body)\n    returned['body'] = body.replace('\\x00', '')\n\n#    print \"2. body: <%s>\" % returned['body']\n\n    return returned", "response": "Unpack a STOMP message into a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nstomp acknowledge command. Acknowledge receipt of a specific message from the server. messageid: This is the id of the message we are acknowledging, what else could it be? ;) transactionid: This is the id that all actions in this transaction will have. If this is not given then a random UUID will be generated for this.", "response": "def ack(messageid, transactionid=None):\n    \"\"\"STOMP acknowledge command.\n\n    Acknowledge receipt of a specific message from the server.\n\n    messageid:\n        This is the id of the message we are acknowledging,\n        what else could it be? ;)\n\n    transactionid:\n        This is the id that all actions in this transaction\n        will have. If this is not given then a random UUID\n        will be generated for this.\n\n    \"\"\"\n    header = 'message-id: %s' % messageid\n\n    if transactionid:\n        header = 'message-id: %s\\ntransaction: %s' % (messageid, transactionid)\n\n    return \"ACK\\n%s\\n\\n\\x00\\n\" % header"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef send(dest, msg, transactionid=None):\n    transheader = ''\n\n    if transactionid:\n        transheader = 'transaction: %s\\n' % transactionid\n\n    return \"SEND\\ndestination: %s\\n%s\\n%s\\x00\\n\" % (dest, transheader, msg)", "response": "This function returns the command to send a message to a channel."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef setCmd(self, cmd):\n        cmd = cmd.upper()\n        if cmd not in VALID_COMMANDS:\n            raise FrameError(\"The cmd '%s' is not valid! It must be one of '%s' (STOMP v%s).\" % (\n                cmd, VALID_COMMANDS, STOMP_VERSION)\n            )\n        else:\n            self._cmd = cmd", "response": "Set the command of the current object."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef pack(self):\n        headers = ''.join(\n            ['%s:%s\\n' % (f, v) for f, v in sorted(self.headers.items())]\n        )\n        stomp_message = \"%s\\n%s\\n%s%s\\n\" % (self._cmd, headers, self.body, NULL)\n\n#        import pprint\n#        print \"stomp_message: \", pprint.pprint(stomp_message)\n\n        return stomp_message", "response": "Packs the internal values into a STOMP message."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nunpacking a STOMP message into this instance.", "response": "def unpack(self, message):\n        \"\"\"Called to extract a STOMP message into this instance.\n\n        message:\n            This is a text string representing a valid\n            STOMP (v1.0) message.\n\n        This method uses unpack_frame(...) to extract the\n        information, before it is assigned internally.\n\n        retuned:\n            The result of the unpack_frame(...) call.\n\n        \"\"\"\n        if not message:\n            raise FrameError(\"Unpack error! The given message isn't valid '%s'!\" % message)\n\n        msg = unpack_frame(message)\n\n        self.cmd = msg['cmd']\n        self.headers = msg['headers']\n\n        # Assign directly as the message will have the null\n        # character in the message already.\n        self.body = msg['body']\n\n        return msg"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef react(self, msg):\n        returned = \"\"\n\n        # If its not a string assume its a dict.\n        mtype = type(msg)\n        if mtype in stringTypes:\n            msg = unpack_frame(msg)\n        elif mtype == dict:\n            pass\n        else:\n            raise FrameError(\"Unknown message type '%s', I don't know what to do with this!\" % mtype)\n\n        if msg['cmd'] in self.states:\n#            print(\"reacting to message - %s\" % msg['cmd'])\n            returned = self.states[msg['cmd']](msg)\n\n        return returned", "response": "Called to provide a response to a message if needed."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef error(self, msg):\n        body = msg['body'].replace(NULL, '')\n\n        brief_msg = \"\"\n        if 'message' in msg['headers']:\n            brief_msg = msg['headers']['message']\n\n        self.log.error(\"Received server error - message%s\\n\\n%s\" % (brief_msg, body))\n\n        returned = NO_RESPONSE_NEEDED\n        if self.testing:\n            returned = 'error'\n\n        return returned", "response": "Called to handle an error message received from the server."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncall to handle a receipt message received from the server.", "response": "def receipt(self, msg):\n        \"\"\"Called to handle a receipt message received from the server.\n\n        This method just logs the receipt message\n\n        returned:\n            NO_RESPONSE_NEEDED\n\n        \"\"\"\n        body = msg['body'].replace(NULL, '')\n\n        brief_msg = \"\"\n        if 'receipt-id' in msg['headers']:\n            brief_msg = msg['headers']['receipt-id']\n\n        self.log.info(\"Received server receipt message - receipt-id:%s\\n\\n%s\" % (brief_msg, body))\n\n        returned = NO_RESPONSE_NEEDED\n        if self.testing:\n            returned = 'receipt'\n\n        return returned"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ninitialize the logger that catches all channels and logs it to stdout.", "response": "def log_init(level):\n    \"\"\"Set up a logger that catches all channels and logs it to stdout.\n    \n    This is used to set up logging when testing.\n    \n    \"\"\"\n    log = logging.getLogger()\n    hdlr = logging.StreamHandler()\n    formatter = logging.Formatter('%(asctime)s %(name)s %(levelname)s %(message)s')\n    hdlr.setFormatter(formatter)\n    log.addHandler(hdlr)\n    log.setLevel(level)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\noverrides this and do some customer message handler. ack", "response": "def ack(self, msg):\n        \"\"\"Override this and do some customer message handler.\n        \"\"\"\n        print(\"Got a message:\\n%s\\n\" % msg['body'])\n        \n        # do something with the message...\n        \n        # Generate the ack or not if you subscribed with ack='auto'\n        return super(Pong, self).ack(msg)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef transaction_atomic_with_retry(num_retries=5, backoff=0.1):\n\n    # Create the decorator\n    @wrapt.decorator\n    def wrapper(wrapped, instance, args, kwargs):\n        # Keep track of how many times we have tried\n        num_tries = 0\n        exception = None\n\n        # Call the main sync entities method and catch any exceptions\n        while num_tries <= num_retries:\n            # Try running the transaction\n            try:\n                with transaction.atomic():\n                    return wrapped(*args, **kwargs)\n            # Catch any operation errors\n            except db.utils.OperationalError as e:\n                num_tries += 1\n                exception = e\n                sleep(backoff * num_tries)\n\n        # If we have an exception raise it\n        raise exception\n\n    # Return the decorator\n    return wrapper", "response": "This is a decorator that will wrap the decorated method in an atomic transaction and retry the transaction a given number of times with a given backoff"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngiving a dictionary of all model objects organized by content type and a dictionary of all model IDs that need to be synced and a boolean indicating whether or not the entity needs to be synced.", "response": "def _get_super_entities_by_ctype(model_objs_by_ctype, model_ids_to_sync, sync_all):\n    \"\"\"\n    Given model objects organized by content type and a dictionary of all model IDs that need\n    to be synced, organize all super entity relationships that need to be synced.\n\n    Ensure that the model_ids_to_sync dict is updated with any new super entities\n    that need to be part of the overall entity sync\n    \"\"\"\n    super_entities_by_ctype = defaultdict(lambda: defaultdict(list))  # pragma: no cover\n    for ctype, model_objs_for_ctype in model_objs_by_ctype.items():\n        entity_config = entity_registry.entity_registry.get(ctype.model_class())\n        super_entities = entity_config.get_super_entities(model_objs_for_ctype, sync_all)\n        super_entities_by_ctype[ctype] = {\n            ContentType.objects.get_for_model(model_class, for_concrete_model=False): relationships\n            for model_class, relationships in super_entities.items()\n        }\n\n        # Continue adding to the set of entities that need to be synced\n        for super_entity_ctype, relationships in super_entities_by_ctype[ctype].items():\n            for sub_entity_id, super_entity_id in relationships:\n                model_ids_to_sync[ctype].add(sub_entity_id)\n                model_ids_to_sync[super_entity_ctype].add(super_entity_id)\n\n    return super_entities_by_ctype"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _get_model_objs_to_sync(model_ids_to_sync, model_objs_map, sync_all):\n    model_objs_to_sync = {}\n    for ctype, model_ids_to_sync_for_ctype in model_ids_to_sync.items():\n        model_qset = entity_registry.entity_registry.get(ctype.model_class()).queryset\n\n        if not sync_all:\n            model_objs_to_sync[ctype] = model_qset.filter(id__in=model_ids_to_sync_for_ctype)\n        else:\n            model_objs_to_sync[ctype] = [\n                model_objs_map[ctype, model_id] for model_id in model_ids_to_sync_for_ctype\n            ]\n\n    return model_objs_to_sync", "response": "Given the model IDs to sync fetch all model objects to sync"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef sync_entities(*model_objs):\n\n    # Check if we are deferring processing\n    if sync_entities.defer:\n        # If we dont have any model objects passed add a none to let us know that we need to sync all\n        if not model_objs:\n            sync_entities.buffer[None] = None\n        else:\n            # Add each model obj to the buffer\n            for model_obj in model_objs:\n                sync_entities.buffer[(model_obj.__class__, model_obj.pk)] = model_obj\n\n        # Return false that we did not do anything\n        return False\n\n    # Create a syncer and sync\n    EntitySyncer(*model_objs).sync()", "response": "Syncs the entities in the current node with the given list of model objects."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef sync_entities_watching(instance):\n    for entity_model, entity_model_getter in entity_registry.entity_watching[instance.__class__]:\n        model_objs = list(entity_model_getter(instance))\n        if model_objs:\n            sync_entities(*model_objs)", "response": "Syncs entities watching changes of a model instance."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef upsert_entity_kinds(self, entity_kinds):\n\n        # Filter out unchanged entity kinds\n        unchanged_entity_kinds = {}\n        if entity_kinds:\n            unchanged_entity_kinds = {\n                (entity_kind.name, entity_kind.display_name): entity_kind\n                for entity_kind in EntityKind.all_objects.extra(\n                    where=['(name, display_name) IN %s'],\n                    params=[tuple(\n                        (entity_kind.name, entity_kind.display_name)\n                        for entity_kind in entity_kinds\n                    )]\n                )\n            }\n\n        # Filter out the unchanged entity kinds\n        changed_entity_kinds = [\n            entity_kind\n            for entity_kind in entity_kinds\n            if (entity_kind.name, entity_kind.display_name) not in unchanged_entity_kinds\n        ]\n\n        # If any of our kinds have changed upsert them\n        upserted_enitity_kinds = []\n        if changed_entity_kinds:\n            # Select all our existing entity kinds for update so we can do proper locking\n            # We have to select all here for some odd reason, if we only select the ones\n            # we are syncing we still run into deadlock issues\n            list(EntityKind.all_objects.all().select_for_update().values_list('id', flat=True))\n\n            # Upsert the entity kinds\n            upserted_enitity_kinds = manager_utils.bulk_upsert(\n                queryset=EntityKind.all_objects.filter(\n                    name__in=[entity_kind.name for entity_kind in changed_entity_kinds]\n                ),\n                model_objs=changed_entity_kinds,\n                unique_fields=['name'],\n                update_fields=['display_name'],\n                return_upserts=True\n            )\n\n        # Return all the entity kinds\n        return upserted_enitity_kinds + list(unchanged_entity_kinds.values())", "response": "This function will update the entity kinds of the entity."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef upsert_entities(self, entities, sync=False):\n\n        # Select the entities we are upserting for update to reduce deadlocks\n        if entities:\n            # Default select for update query when syncing all\n            select_for_update_query = (\n                'SELECT FROM {table_name} FOR NO KEY UPDATE'\n            ).format(\n                table_name=Entity._meta.db_table\n            )\n            select_for_update_query_params = []\n\n            # If we are not syncing all, only select those we are updating\n            if not sync:\n                select_for_update_query = (\n                    'SELECT FROM {table_name} WHERE (entity_type_id, entity_id) IN %s FOR NO KEY UPDATE'\n                ).format(\n                    table_name=Entity._meta.db_table\n                )\n                select_for_update_query_params = [tuple(\n                    (entity.entity_type_id, entity.entity_id)\n                    for entity in entities\n                )]\n\n            # Select the items for update\n            with connection.cursor() as cursor:\n                cursor.execute(select_for_update_query, select_for_update_query_params)\n\n        # If we are syncing run the sync logic\n        if sync:\n            upserted_entities = manager_utils.sync(\n                queryset=Entity.all_objects.all(),\n                model_objs=entities,\n                unique_fields=['entity_type_id', 'entity_id'],\n                update_fields=['entity_kind_id', 'entity_meta', 'display_name', 'is_active'],\n                return_upserts=True\n            )\n        # Otherwise we want to upsert our entities\n        else:\n            upserted_entities = manager_utils.bulk_upsert(\n                queryset=Entity.all_objects.extra(\n                    where=['(entity_type_id, entity_id) IN %s'],\n                    params=[tuple(\n                        (entity.entity_type_id, entity.entity_id)\n                        for entity in entities\n                    )]\n                ),\n                model_objs=entities,\n                unique_fields=['entity_type_id', 'entity_id'],\n                update_fields=['entity_kind_id', 'entity_meta', 'display_name', 'is_active'],\n                return_upserts=True\n            )\n\n        # Return the upserted entities\n        return upserted_entities", "response": "Upsert a list of entities to the database."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a tuple for a kind name and kind display name of an entity.", "response": "def get_entity_kind(self, model_obj):\n        \"\"\"\n        Returns a tuple for a kind name and kind display name of an entity.\n        By default, uses the app_label and model of the model object's content\n        type as the kind.\n        \"\"\"\n        model_obj_ctype = ContentType.objects.get_for_model(self.queryset.model)\n        return (u'{0}.{1}'.format(model_obj_ctype.app_label, model_obj_ctype.model), u'{0}'.format(model_obj_ctype))"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nregisters an entity config with the registry.", "response": "def register_entity(self, entity_config):\n        \"\"\"\n        Registers an entity config\n        \"\"\"\n        if not issubclass(entity_config, EntityConfig):\n            raise ValueError('Must register entity config class of subclass EntityConfig')\n\n        if entity_config.queryset is None:\n            raise ValueError('Entity config must define queryset')\n\n        model = entity_config.queryset.model\n\n        self._entity_registry[model] = entity_config()\n\n        # Add watchers to the global look up table\n        for watching_model, entity_model_getter in entity_config.watching:\n            self._entity_watching[watching_model].append((model, entity_model_getter))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef start(host='localhost', port=61613, username='', password=''):\n    StompClientFactory.username = username\n    StompClientFactory.password = password\n    reactor.connectTCP(host, port, StompClientFactory())\n    reactor.run()", "response": "Start twisted event loop and the fun should begin..."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncalling when a new connection is established.", "response": "def connected(self, msg):\n        \"\"\"Once I've connected I want to subscribe to my the message queue.\n        \"\"\"\n        stomper.Engine.connected(self, msg)\n\n        self.log.info(\"Connected: session %s. Beginning say hello.\" % msg['headers']['session'])\n        \n        def setup_looping_call():\n            lc = LoopingCall(self.send)\n            lc.start(2)\n            \n        reactor.callLater(1, setup_looping_call)\n\n        f = stomper.Frame()\n        f.unpack(stomper.subscribe(DESTINATION))\n\n        # ActiveMQ specific headers:\n        #\n        # prevent the messages we send comming back to us.\n        f.headers['activemq.noLocal'] = 'true'\n        \n        return f.pack()"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nsend out a hello message periodically.", "response": "def send(self):\n        \"\"\"Send out a hello message periodically.\n        \"\"\"\n        self.log.info(\"Saying hello (%d).\" % self.counter)\n\n        f = stomper.Frame()\n        f.unpack(stomper.send(DESTINATION, 'hello there (%d)' % self.counter))\n\n        self.counter += 1        \n\n        # ActiveMQ specific headers:\n        #\n        #f.headers['persistent'] = 'true'\n\n        self.transport.write(f.pack())"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nregister with stomp server.", "response": "def connectionMade(self):\n        \"\"\"Register with stomp server.\n        \"\"\"\n        cmd = stomper.connect(self.username, self.password)\n        self.transport.write(cmd)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef dataReceived(self, data):\n        self.stompBuffer.appendData(data)\n\n        while True:\n           msg = self.stompBuffer.getOneMessage()\n           if msg is None:\n               break\n\n           returned = self.react(msg)\n           if returned:\n               self.transport.write(returned)", "response": "Called by the server when data has been received."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef clientConnectionFailed(self, connector, reason):\n        print('Connection failed. Reason:', reason)        \n        ReconnectingClientFactory.clientConnectionFailed(self, connector, reason)", "response": "Called by the client when a connection attempt is failed."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef ack(self, msg):\n        self.log.info(\"receiverId <%s> Received: <%s> \" % (self.receiverId, msg['body']))\n        \n        #return super(MyStomp, self).ack(msg) \n        return stomper.NO_REPONSE_NEEDED", "response": "Process the message and determine what to do with it."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef connectionMade(self):\n        cmd = self.sm.connect()\n        self.transport.write(cmd)", "response": "Register with the stomp server."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreceives a data frame and reacts to it and respond if needed.", "response": "def dataReceived(self, data):\n        \"\"\"Data received, react to it and respond if needed.\n        \"\"\"\n#        print \"receiver dataReceived: <%s>\" % data\n        \n        msg = stomper.unpack_frame(data)\n        \n        returned = self.sm.react(msg)\n\n#        print \"receiver returned <%s>\" % returned\n        \n        if returned:\n            self.transport.write(returned)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef find_id_in_folder(self, name, parent_folder_id=0):\n        if name is None or len(name) == 0:\n            return parent_folder_id\n        offset = 0\n        resp = self.get_folder_items(parent_folder_id,\n                                     limit=1000, offset=offset,\n                                     fields_list=['name'])\n        total = int(resp['total_count'])\n        while offset < total:\n            found = self.__find_name(resp, name)\n            if found is not None:\n                return found\n            offset += int(len(resp['entries']))\n            resp = self.get_folder_items(parent_folder_id,\n                                            limit=1000, offset=offset,\n                                            fields_list=['name'])\n\n        return None", "response": "Find a file or folder ID from its name inside a given folder."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef create_folder(self, name, parent_folder_id=0):\n        return self.__request(\"POST\", \"folders\",\n                        data={ \"name\": name,\n                               \"parent\": {\"id\": unicode(parent_folder_id)} })", "response": "Create a folder in Box."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ndelete an existing folder in Box.", "response": "def delete_folder(self, folder_id, recursive=True):\n        \"\"\"Delete an existing folder\n\n        Args:\n            folder_id (int): ID of the folder to delete.\n            recursive (bool): Delete all subfolder if True.\n\n        Returns:\n            dict. Response from Box.\n\n        Raises:\n            BoxError: An error response is returned from Box (status_code >= 400).\n\n            BoxHttpResponseError: Response from Box is malformed.\n\n            requests.exceptions.*: Any connection related problem.\n        \"\"\"\n        return self.__request(\"DELETE\", \"folders/%s\" % (folder_id, ),\n                        querystring={'recursive': unicode(recursive).lower()})"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_folder_items(self, folder_id,\n                            limit=100, offset=0, fields_list=None):\n        \"\"\"Get files and folders inside a given folder\n\n        Args:\n            folder_id (int): Where to get files and folders info.\n\n            limit (int): The number of items to return.\n\n            offset (int): The item at which to begin the response.\n\n            fields_list (list): List of attributes to get. All attributes if None.\n\n        Returns:\n            dict. Response from Box.\n\n        Raises:\n            BoxError: An error response is returned from Box (status_code >= 400).\n\n            BoxHttpResponseError: Response from Box is malformed.\n\n            requests.exceptions.*: Any connection related problem.\n        \"\"\"\n        qs = {  \"limit\": limit,\n                \"offset\": offset }\n        if fields_list:\n            qs['fields'] = ','.join(fields_list)\n        return self.__request(\"GET\", \"folders/%s/items\" % (folder_id, ),\n                        querystring=qs)", "response": "Get files and folders inside a given folder."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef upload_file(self, name, folder_id, file_path):\n        try:\n            return self.__do_upload_file(name, folder_id, file_path)\n        except BoxError, ex:\n            if ex.status != 401:\n                raise\n            #tokens had been refreshed, so we start again the upload\n            return self.__do_upload_file(name, folder_id, file_path)", "response": "Upload a file into a folder."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nuploads a new file into a folder.", "response": "def upload_new_file_version(self, name, folder_id, file_id, file_path):\n        \"\"\"Upload a new version of a file into a folder.\n\n        Use function for small file otherwise there is the chunk_upload_file() function.\n\n        Args::\n            name (str): Name of the file on your Box storage.\n\n            folder_id (int): ID of the folder where to upload the file.\n\n            file_id (int): ID of the file to update.\n\n            file_path (str): Local path of the file to upload.\n\n        Returns:\n            dict. Response from Box.\n\n        Raises:\n            BoxError: An error response is returned from Box (status_code >= 400).\n\n            BoxHttpResponseError: Response from Box is malformed.\n\n            requests.exceptions.*: Any connection related problem.\n        \"\"\"\n        try:\n            return self.__do_upload_file(name, folder_id, file_path, file_id)\n        except BoxError, ex:\n            if ex.status != 401:\n                raise\n            #tokens had been refreshed, so we start again the upload\n            return self.__do_upload_file(name, folder_id, file_path, file_id)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nuploading a file chunk by chunk.", "response": "def chunk_upload_file(self, name, folder_id, file_path,\n                            progress_callback=None,\n                            chunk_size=1024*1024*1):\n        \"\"\"Upload a file chunk by chunk.\n\n        The whole file is never loaded in memory.\n        Use this function for big file.\n\n        The callback(transferred, total) to let you know the upload progress.\n        Upload can be cancelled if the callback raise an Exception.\n\n        >>> def progress_callback(transferred, total):\n        ...    print 'Uploaded %i bytes of %i' % (transferred, total, )\n        ...    if user_request_cancel:\n        ...       raise MyCustomCancelException()\n\n        Args:\n            name (str): Name of the file on your Box storage.\n\n            folder_id (int): ID of the folder where to upload the file.\n\n            file_path (str): Local path of the file to upload.\n\n            progress_callback (func): Function called each time a chunk is uploaded.\n\n            chunk_size (int): Size of chunks.\n\n        Returns:\n            dict. Response from Box.\n\n        Raises:\n            BoxError: An error response is returned from Box (status_code >= 400).\n\n            BoxHttpResponseError: Response from Box is malformed.\n\n            requests.exceptions.*: Any connection related problem.\n        \"\"\"\n\n        try:\n            return self.__do_chunk_upload_file(name, folder_id, file_path,\n                                    progress_callback,\n                                    chunk_size)\n        except BoxError, ex:\n            if ex.status != 401:\n                raise\n            #tokens had been refreshed, so we start again the upload\n            return self.__do_chunk_upload_file(name, folder_id, file_path,\n                                    progress_callback,\n                                    chunk_size)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncopies file to new destination folder.", "response": "def copy_file(self, file_id, dest_folder_id):\n        \"\"\"Copy file to new destination\n\n        Args:\n            file_id (int): ID of the folder.\n\n            dest_folder_id (int): ID of parent folder you are copying to.\n\n        Returns:\n            dict. Response from Box.\n\n        Raises:\n            BoxError: An error response is returned from Box (status_code >= 400).\n\n            BoxError: 409 - Item with the same name already exists.\n            In this case you will need download the file and upload a new version to your destination.\n            (Box currently doesn't have a method to copy a new verison.)\n\n            BoxHttpResponseError: Response from Box is malformed.\n\n            requests.exceptions.*: Any connection related problem.\n        \"\"\"\n\n        return self.__request(\"POST\", \"/files/\" + unicode(file_id) + \"/copy\",\n                        data={ \"parent\": {\"id\": unicode(dest_folder_id)} })"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef download_file(self, file_id, dest_file_path,\n                            progress_callback=None,\n                            chunk_size=1024*1024*1):\n        \"\"\"Download a file.\n\n        The whole file is never loaded in memory.\n\n        The callback(transferred, total) to let you know the download progress.\n        Download can be cancelled if the callback raise an Exception.\n\n        >>> def progress_callback(transferred, total):\n        ...    print 'Downloaded %i bytes of %i' % (transferred, total, )\n        ...    if user_request_cancel:\n        ...       raise MyCustomCancelException()\n\n        Args:\n            file_id (int): ID of the file to download.\n\n            dest_file_path (str): Local path where to store the downloaded filed.\n\n            progress_callback (func): Function called each time a chunk is downloaded.\n\n            chunk_size (int): Size of chunks.\n\n        Raises:\n            BoxError: An error response is returned from Box (status_code >= 400).\n\n            BoxHttpResponseError: Response from Box is malformed.\n\n            requests.exceptions.*: Any connection related problem.\n        \"\"\"\n        with open(dest_file_path, 'wb') as fp:\n            req = self.__request(\"GET\", \"files/%s/content\" % (file_id, ),\n                                                stream=True,\n                                                json_data=False)\n            total = -1\n            if hasattr(req, 'headers'):\n                lower_headers = {k.lower():v for k,v in req.headers.items()}\n                if 'content-length' in lower_headers:\n                    total = lower_headers['content-length']\n\n            transferred = 0\n            for chunk in req.iter_content(chunk_size=chunk_size):\n                if chunk: # filter out keep-alive new chunks\n                    if progress_callback:\n                        progress_callback(transferred, total)\n                    fp.write(chunk)\n                    fp.flush()\n                    transferred += len(chunk)\n\n            if progress_callback:\n                progress_callback(transferred, total)", "response": "Download a file from Box and store it in a local file."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsearches for files and folders in Box.", "response": "def search(self, **kwargs):\n        \"\"\"Searches for files/folders\n\n        Args:\n            \\*\\*kwargs (dict): A dictionary containing necessary parameters\n                            (check https://developers.box.com/docs/#search for\n                            list of parameters)\n\n        Returns:\n            dict. Response from Box.\n\n        Raises:\n            BoxError: An error response is returned from Box (status_code >= 400).\n\n            BoxHttpResponseError: Response from Box is malformed.\n\n            requests.exceptions.*: Any connection related problem.\n        \"\"\"\n        query_string = {}\n        for key, value in kwargs.iteritems():\n            query_string[key] = value\n        return self.__request(\"GET\",\"search\",querystring=query_string)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef getmany(self, *keys):\n        pickled_keys = (self._pickle_key(k) for k in keys)\n        pickled_values = self.redis.hmget(self.key, *pickled_keys)\n\n        ret = []\n        for k, v in zip(keys, pickled_values):\n            value = self.cache.get(k, self._unpickle(v))\n            ret.append(value)\n\n        return ret", "response": "Get a list of values corresponding to the keys in the iterable of\n           ."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _data(self, pipe=None):\n        pipe = self.redis if pipe is None else pipe\n        items = pipe.hgetall(self.key).items()\n\n        return {self._unpickle_key(k): self._unpickle(v) for k, v in items}", "response": "Returns a Python dictionary with the same values as this object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning an iterator over the dictionary s keys and values.", "response": "def iteritems(self, pipe=None):\n        \"\"\"Return an iterator over the dictionary's ``(key, value)`` pairs.\"\"\"\n        pipe = self.redis if pipe is None else pipe\n        for k, v in self._data(pipe).items():\n            yield k, self.cache.get(k, v)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nremoving the value for the given key and returns its value. If the key is not in the dictionary return default.", "response": "def pop(self, key, default=__marker):\n        \"\"\"If *key* is in the dictionary, remove it and return its value,\n        else return *default*. If *default* is not given and *key* is not\n        in the dictionary, a :exc:`KeyError` is raised.\n        \"\"\"\n        pickled_key = self._pickle_key(key)\n\n        if key in self.cache:\n            self.redis.hdel(self.key, pickled_key)\n            return self.cache.pop(key)\n\n        def pop_trans(pipe):\n            pickled_value = pipe.hget(self.key, pickled_key)\n            if pickled_value is None:\n                if default is self.__marker:\n                    raise KeyError(key)\n                return default\n\n            pipe.hdel(self.key, pickled_key)\n            return self._unpickle(pickled_value)\n\n        value = self._transaction(pop_trans)\n        self.cache.pop(key, None)\n\n        return value"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nremove and return an arbitrary key value pair from the dictionary.", "response": "def popitem(self):\n        \"\"\"Remove and return an arbitrary ``(key, value)`` pair from\n        the dictionary.\n\n        :func:`popitem` is useful to destructively iterate over\n        a dictionary, as often used in set algorithms. If\n        the dictionary is empty, calling :func:`popitem` raises\n        a :exc:`KeyError`.\n        \"\"\"\n        def popitem_trans(pipe):\n            try:\n                pickled_key = pipe.hkeys(self.key)[0]\n            except IndexError:\n                raise KeyError\n\n            # pop its value\n            pipe.multi()\n            pipe.hget(self.key, pickled_key)\n            pipe.hdel(self.key, pickled_key)\n            pickled_value, __ = pipe.execute()\n\n            return (\n                self._unpickle_key(pickled_key), self._unpickle(pickled_value)\n            )\n\n        key, value = self._transaction(popitem_trans)\n\n        return key, self.cache.pop(key, value)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nset the value of the key to default. If the key is not in the dictionary return default.", "response": "def setdefault(self, key, default=None):\n        \"\"\"If *key* is in the dictionary, return its value.\n        If not, insert *key* with a value of *default* and\n        return *default*. *default* defaults to :obj:`None`.\n        \"\"\"\n        if key in self.cache:\n            return self.cache[key]\n\n        def setdefault_trans(pipe):\n            pickled_key = self._pickle_key(key)\n\n            pipe.multi()\n            pipe.hsetnx(self.key, pickled_key, self._pickle_value(default))\n            pipe.hget(self.key, pickled_key)\n\n            __, pickled_value = pipe.execute()\n\n            return self._unpickle(pickled_value)\n\n        value = self._transaction(setdefault_trans)\n\n        if self.writeback:\n            self.cache[key] = value\n        return value"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nupdates the dictionary with the key value pairs from other.", "response": "def update(self, other=None, **kwargs):\n        \"\"\"Update the dictionary with the key/value pairs from *other*,\n        overwriting existing keys. Return :obj:`None`.\n\n        :func:`update` accepts either another dictionary object or\n        an iterable of key/value pairs (as tuples or other iterables\n        of length two). If keyword arguments are specified, the\n        dictionary is then updated with those key/value pairs:\n        ``d.update(red=1, blue=2)``.\n        \"\"\"\n        if other is not None:\n            if self._same_redis(other, RedisCollection):\n                self._update_helper(other, use_redis=True)\n            elif hasattr(other, 'keys'):\n                self._update_helper(other)\n            else:\n                self._update_helper({k: v for k, v in other})\n\n        if kwargs:\n            self._update_helper(kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef copy(self, key=None):\n        other = self.__class__(redis=self.redis, key=key)\n        other.update(self)\n\n        return other", "response": "Returns a new collection with the same items as this one."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef fromkeys(cls, seq, value=None, **kwargs):\n        values = ((key, value) for key in seq)\n        return cls(values, **kwargs)", "response": "Create a new dictionary with keys from seq and values set to value."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nyield each of the key value pairs from the collection without pulling them all into memory.", "response": "def scan_items(self):\n        \"\"\"\n        Yield each of the ``(key, value)`` pairs from the collection, without\n        pulling them all into memory.\n\n        .. warning::\n            This method is not available on the dictionary collections provided\n            by Python.\n\n            This method may return the same (key, value) pair multiple times.\n            See the `Redis SCAN documentation\n            <http://redis.io/commands/scan#scan-guarantees>`_ for details.\n        \"\"\"\n        for k, v in self.redis.hscan_iter(self.key):\n            yield self._unpickle_key(k), self._unpickle(v)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nupdates the internal dictionary with counts from another.", "response": "def update(self, other=None, **kwargs):\n        \"\"\"Elements are counted from an *iterable* or added-in from another\n        *mapping* (or counter). Like :func:`dict.update` but adds counts\n        instead of replacing them. Also, the *iterable* is expected to be\n        a sequence of elements, not a sequence of ``(key, value)`` pairs.\n        \"\"\"\n        if other is not None:\n            if self._same_redis(other, RedisCollection):\n                self._update_helper(other, operator.add, use_redis=True)\n            elif hasattr(other, 'keys'):\n                self._update_helper(other, operator.add)\n            else:\n                self._update_helper(collections.Counter(other), operator.add)\n\n        if kwargs:\n            self._update_helper(kwargs, operator.add)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef subtract(self, other=None, **kwargs):\n        if other is not None:\n            if self._same_redis(other, RedisCollection):\n                self._update_helper(other, operator.sub, use_redis=True)\n            elif hasattr(other, 'keys'):\n                self._update_helper(other, operator.sub)\n            else:\n                self._update_helper(collections.Counter(other), operator.sub)\n\n        if kwargs:\n            self._update_helper(kwargs, operator.sub)", "response": "Subtracts elements from another collection or counter."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nprocesses the received message and generates an ack message.", "response": "def ack(self, msg):\n        \"\"\"Processes the received message. I don't need to \n        generate an ack message.\n        \n        \"\"\"\n        self.log.info(\"senderID:%s Received: %s \" % (self.senderID, msg['body']))\n        return stomper.NO_REPONSE_NEEDED"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _normalize_index(self, index, pipe=None):\n        pipe = self.redis if pipe is None else pipe\n        len_self = self.__len__(pipe)\n        positive_index = index if index >= 0 else len_self + index\n\n        return len_self, positive_index", "response": "Convert negative indexes into their positive equivalents."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ngive a :obj:`slice` *index*, return a 4-tuple ``(start, stop, step, fowrward)``. The first three items can be used with the ``range`` function to retrieve the values associated with the slice; the last item indicates the direction.", "response": "def _normalize_slice(self, index, pipe=None):\n        \"\"\"Given a :obj:`slice` *index*, return a 4-tuple\n        ``(start, stop, step, fowrward)``. The first three items can be used\n        with the ``range`` function to retrieve the values associated with the\n        slice; the last item indicates the direction.\n        \"\"\"\n        if index.step == 0:\n            raise ValueError\n        pipe = self.redis if pipe is None else pipe\n\n        len_self = self.__len__(pipe)\n\n        step = index.step or 1\n        forward = step > 0\n        step = abs(step)\n\n        if index.start is None:\n            start = 0 if forward else len_self - 1\n        elif index.start < 0:\n            start = max(len_self + index.start, 0)\n        else:\n            start = min(index.start, len_self)\n\n        if index.stop is None:\n            stop = len_self if forward else -1\n        elif index.stop < 0:\n            stop = max(len_self + index.stop, 0)\n        else:\n            stop = min(index.stop, len_self)\n\n        if not forward:\n            start, stop = min(stop + 1, len_self), min(start + 1, len_self)\n\n        return start, stop, step, forward, len_self"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _transaction(self, fn, *extra_keys):\n        results = []\n\n        def trans(pipe):\n            results.append(fn(pipe))\n\n        self.redis.transaction(trans, self.key, *extra_keys)\n        return results[0]", "response": "Helper simplifying code within watched transaction."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef nack(messageid, subscriptionid, transactionid=None):\n    header = 'subscription:%s\\nmessage-id:%s' % (subscriptionid, messageid)\n\n    if transactionid:\n        header += '\\ntransaction:%s' % transactionid\n\n    return \"NACK\\n%s\\n\\n\\x00\\n\" % header", "response": "STOMP negative acknowledge command."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nstomp connect command. username, password: These are the needed auth details to connect to the message server. After sending this we will receive a CONNECTED message which will contain our session id.", "response": "def connect(username, password, host, heartbeats=(0,0)):\n    \"\"\"STOMP connect command.\n\n    username, password:\n        These are the needed auth details to connect to the\n        message server.\n\n    After sending this we will receive a CONNECTED\n    message which will contain our session id.\n\n    \"\"\"\n    if len(heartbeats) != 2:\n        raise ValueError('Invalid heartbeat %r' % heartbeats)\n    cx, cy = heartbeats\n    return \"CONNECT\\naccept-version:1.1\\nhost:%s\\nheart-beat:%i,%i\\nlogin:%s\\npasscode:%s\\n\\n\\x00\\n\" % (host, cx, cy, username, password)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef ack(self, msg):\n        message_id = msg['headers']['message-id']\n        subscription = msg['headers']['subscription']\n\n        transaction_id = None\n        if 'transaction-id' in msg['headers']:\n            transaction_id = msg['headers']['transaction-id']\n\n#        print \"acknowledging message id <%s>.\" % message_id\n\n        return ack(message_id, subscription, transaction_id)", "response": "Called when a MESSAGE has been received."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _findMessageBytes ( self, data ):\n\n        # Sanity check. See the docstring for the method to see what it\n        # does an why we need it.\n        self.syncBuffer()\n        \n        # If the string '\\n\\n' does not exist, we don't even have the complete\n        # header yet and we MUST exit.\n        try:\n            i = data.index ( '\\n\\n' )\n        except ValueError:\n            return ( 0, 0 )\n        # If the string '\\n\\n' exists, then we have the entire header and can\n        # check for the content-length header. If it exists, we can check\n        # the length of the buffer for the number of bytes, else we check for\n        # the existence of a null byte.\n\n        # Pull out the header before we perform the regexp search. This\n        # prevents us from matching (possibly malicious) strings in the\n        # body.\n        _hdr = self.buffer[:i]\n        match = content_length_re.search ( _hdr )\n        if match:\n            # There was a content-length header, so read out the value.\n            content_length = int ( match.groups()[0] )\n\n            # THIS IS NO LONGER THE CASE IF WE REMOVE THE '\\n\\n' in\n            # Frame.pack()\n            \n            # This is the content length of the body up until the null\n            # byte, not the entire message. Note that this INCLUDES the 2\n            # '\\n\\n' bytes inserted by the STOMP encoder after the body\n            # (see the calculation of content_length in\n            # StompEngine.callRemote()), so we only need to add 2 final bytes\n            # for the footer.\n            #\n            #The message looks like:\n            #\n            #   <header>\\n\\n<body>\\n\\n\\x00\\n\n            #           ^         ^^^^\n            #          (i)         included in content_length!\n            #\n            # We have the location of the end of the header (i), so we\n            # need to ensure that the message contains at least:\n            #\n            #     i + len ( '\\n\\n' ) + content_length + len ( '\\x00\\n' )\n            #\n            # Note that i is also the count of bytes in the header, because\n            # of the fact that str.index() returns a 0-indexed value.\n            req_len = i + len_sep + content_length + len_footer\n            # log.msg ( \"We have [%s] bytes and need [%s] bytes\" %\n            #           ( len ( data ), req_len, ) )\n            if len ( data ) < req_len:\n                # We don't have enough bytes in the buffer.\n                return ( 0, 0 )\n            else:\n                # We have enough bytes in the buffer\n                return ( req_len, i )\n        else:\n            # There was no content-length header, so just look for the\n            # message terminator ('\\x00\\n' ).\n            try:\n                j = data.index ( '\\x00\\n' )\n            except ValueError:\n                return ( 0, 0 )\n            # j points to the 0-indexed location of the null byte. However,\n            # we need to add 1 (to turn it into a byte count) and 1 to take\n            # account of the final '\\n' character after the null byte.\n            return ( j + 2, i )", "response": "Find the bytes in the buffer that are in the message and return them."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nsynchronize the buffer with the contents of the STOMP command.", "response": "def syncBuffer( self ):\n        \"\"\"\n        I detect and correct corruption in the buffer.\n        \n        Corruption in the buffer is defined as the following conditions\n        both being true:\n        \n            1. The buffer contains at least one newline;\n            2. The text until the first newline is not a STOMP command.\n        \n        In this case, we heuristically try to flush bits of the buffer until\n        one of the following conditions becomes true:\n        \n            1. the buffer starts with a STOMP command;\n            2. the buffer does not contain a newline.\n            3. the buffer is empty;\n\n        If the buffer is deemed corrupt, the first step is to flush the buffer\n        up to and including the first occurrence of the string '\\x00\\n', which\n        is likely to be a frame boundary.\n\n        Note that this is not guaranteed to be a frame boundary, as a binary\n        payload could contain the string '\\x00\\n'. That condition would get\n        handled on the next loop iteration.\n        \n        If the string '\\x00\\n' does not occur, the entire buffer is cleared.\n        An earlier version progressively removed strings until the next newline,\n        but this gets complicated because the body could contain strings that\n        look like STOMP commands.\n        \n        Note that we do not check \"partial\" strings to see if they *could*\n        match a command; that would be too resource-intensive. In other words,\n        a buffer containing the string 'BUNK' with no newline is clearly\n        corrupt, but we sit and wait until the buffer contains a newline before\n        attempting to see if it's a STOMP command.\n        \"\"\"\n        while True:\n            if not self.buffer:\n                # Buffer is empty; no need to do anything.\n                break\n            m = command_re.match ( self.buffer )\n            if m is None:\n                # Buffer doesn't even contain a single newline, so we can't\n                # determine whether it's corrupt or not. Assume it's OK.\n                break\n            cmd = m.groups()[0]\n            if cmd in stomper.VALID_COMMANDS:\n                # Good: the buffer starts with a command.\n                break\n            else:\n                # Bad: the buffer starts with bunk, so strip it out. We first\n                # try to strip to the first occurrence of '\\x00\\n', which\n                # is likely to be a frame boundary, but if this fails, we\n                # strip until the first newline.\n                ( self.buffer, nsubs ) = sync_re.subn ( '', self.buffer )\n\n                if nsubs:\n                    # Good: we managed to strip something out, so restart the\n                    # loop to see if things look better.\n                    continue\n                else:\n                    # Bad: we failed to strip anything out, so kill the\n                    # entire buffer. Since this resets the buffer to a\n                    # known good state, we can break out of the loop.\n                    self.buffer = ''\n                    break"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef connected(self, msg):\n        super(MyStomp, self).connected(msg)\n\n        self.log.info(\"connected: session %s\" % msg['headers']['session'])\n        f = stomper.Frame()\n        f.unpack(stomper.subscribe(DESTINATION))\n        return f.pack()", "response": "Called when a new session is established."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncalls when an entity is deleted.", "response": "def delete_entity_signal_handler(sender, instance, **kwargs):\n    \"\"\"\n    Defines a signal handler for syncing an individual entity. Called when\n    an entity is saved or deleted.\n    \"\"\"\n    if instance.__class__ in entity_registry.entity_registry:\n        Entity.all_objects.delete_for_obj(instance)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ndefining a signal handler for saving an entity. Syncs the entity to the entity mirror table.", "response": "def save_entity_signal_handler(sender, instance, **kwargs):\n    \"\"\"\n    Defines a signal handler for saving an entity. Syncs the entity to\n    the entity mirror table.\n    \"\"\"\n    if instance.__class__ in entity_registry.entity_registry:\n        sync_entities(instance)\n\n    if instance.__class__ in entity_registry.entity_watching:\n        sync_entities_watching(instance)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsignaling handler for manytomany changed entity.", "response": "def m2m_changed_entity_signal_handler(sender, instance, action, **kwargs):\n    \"\"\"\n    Defines a signal handler for a manytomany changed signal. Only listens for the\n    post actions so that entities are synced once (rather than twice for a pre and post action).\n    \"\"\"\n    if action == 'post_add' or action == 'post_remove' or action == 'post_clear':\n        save_entity_signal_handler(sender, instance, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef turn_off_syncing(for_post_save=True, for_post_delete=True, for_m2m_changed=True, for_post_bulk_operation=True):\n    if for_post_save:\n        post_save.disconnect(save_entity_signal_handler, dispatch_uid='save_entity_signal_handler')\n    if for_post_delete:\n        post_delete.disconnect(delete_entity_signal_handler, dispatch_uid='delete_entity_signal_handler')\n    if for_m2m_changed:\n        m2m_changed.disconnect(m2m_changed_entity_signal_handler, dispatch_uid='m2m_changed_entity_signal_handler')\n    if for_post_bulk_operation:\n        post_bulk_operation.disconnect(bulk_operation_signal_handler, dispatch_uid='bulk_operation_signal_handler')", "response": "Turn off syncing entities."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nenable all of the signals for syncing entities.", "response": "def turn_on_syncing(for_post_save=True, for_post_delete=True, for_m2m_changed=True, for_post_bulk_operation=False):\n    \"\"\"\n    Enables all of the signals for syncing entities. Everything is True by default, except for the post_bulk_operation\n    signal. The reason for this is because when any bulk operation occurs on any mirrored entity model, it will\n    result in every single entity being synced again. This is not a desired behavior by the majority of users, and\n    should only be turned on explicitly.\n    \"\"\"\n    if for_post_save:\n        post_save.connect(save_entity_signal_handler, dispatch_uid='save_entity_signal_handler')\n    if for_post_delete:\n        post_delete.connect(delete_entity_signal_handler, dispatch_uid='delete_entity_signal_handler')\n    if for_m2m_changed:\n        m2m_changed.connect(m2m_changed_entity_signal_handler, dispatch_uid='m2m_changed_entity_signal_handler')\n    if for_post_bulk_operation:\n        post_bulk_operation.connect(bulk_operation_signal_handler, dispatch_uid='bulk_operation_signal_handler')"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef add(self, value):\n        # Raise TypeError if value is not hashable\n        hash(value)\n\n        self.redis.sadd(self.key, self._pickle(value))", "response": "Add element value to the set."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nremoves the element value from the set if it is present.", "response": "def discard(self, value):\n        \"\"\"Remove element *value* from the set if it is present.\"\"\"\n        # Raise TypeError if value is not hashable\n        hash(value)\n\n        self.redis.srem(self.key, self._pickle(value))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn True if the set has no elements in common with other.", "response": "def isdisjoint(self, other):\n        \"\"\"\n        Return ``True`` if the set has no elements in common with *other*.\n        Sets are disjoint if and only if their intersection is the empty set.\n\n        :param other: Any kind of iterable.\n        :rtype: boolean\n        \"\"\"\n        def isdisjoint_trans_pure(pipe):\n            return not pipe.sinter(self.key, other.key)\n\n        def isdisjoint_trans_mixed(pipe):\n            self_values = set(self.__iter__(pipe))\n            if use_redis:\n                other_values = set(other.__iter__(pipe))\n            else:\n                other_values = set(other)\n\n            return self_values.isdisjoint(other_values)\n\n        if self._same_redis(other):\n            return self._transaction(isdisjoint_trans_pure, other.key)\n        if self._same_redis(other, RedisCollection):\n            use_redis = True\n            return self._transaction(isdisjoint_trans_mixed, other.key)\n\n        use_redis = False\n        return self._transaction(isdisjoint_trans_mixed)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef pop(self):\n        result = self.redis.spop(self.key)\n        if result is None:\n            raise KeyError\n\n        return self._unpickle(result)", "response": "Removes and returns an arbitrary element from the set. Raises KeyError if the set is empty."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a random k elements from the set.", "response": "def random_sample(self, k=1):\n        \"\"\"\n        Return a *k* length list of unique elements chosen from the Set.\n        Elements are not removed. Similar to :func:`random.sample` function\n        from standard library.\n\n        :param k: Size of the sample, defaults to 1.\n        :rtype: :class:`list`\n\n        \"\"\"\n        # k == 0: no work to do\n        if k == 0:\n            results = []\n        # k == 1: same behavior on all versions of Redis\n        elif k == 1:\n            results = [self.redis.srandmember(self.key)]\n        # k != 1, Redis version >= 2.6: compute in Redis\n        else:\n            results = self.redis.srandmember(self.key, k)\n\n        return [self._unpickle(x) for x in results]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nremoving the element value from the set. Raises KeyError if the key is not contained in the set.", "response": "def remove(self, value):\n        \"\"\"\n        Remove element *value* from the set. Raises :exc:`KeyError` if it\n        is not contained in the set.\n        \"\"\"\n        # Raise TypeError if value is not hashable\n        hash(value)\n\n        result = self.redis.srem(self.key, self._pickle(value))\n        if not result:\n            raise KeyError(value)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef scan_elements(self):\n        for x in self.redis.sscan_iter(self.key):\n            yield self._unpickle(x)", "response": "Yields each of the elements from the collection without pulling them into memory."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nupdates the set keeping only elements found in it and all others.", "response": "def intersection_update(self, *others):\n        \"\"\"\n        Update the set, keeping only elements found in it and all *others*.\n\n        :param others: Iterables, each one as a single positional argument.\n        :rtype: None\n\n        .. note::\n            The same behavior as at :func:`difference_update` applies.\n        \"\"\"\n        return self._op_update_helper(\n            tuple(others), operator.and_, 'sinterstore', update=True\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nupdating the set with the elements from all others.", "response": "def update(self, *others):\n        \"\"\"\n        Update the set, adding elements from all *others*.\n\n        :param others: Iterables, each one as a single positional argument.\n        :rtype: None\n\n        .. note::\n            If all *others* are :class:`Set` instances, the operation\n            is performed completely in Redis. Otherwise, values are retrieved\n            from Redis and the operation is performed in Python.\n        \"\"\"\n        return self._op_update_helper(\n            tuple(others), operator.or_, 'sunionstore', update=True\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef difference_update(self, *others):\n        return self._op_update_helper(\n            tuple(others), operator.sub, 'sdiffstore', update=True\n        )", "response": "Update the set removing elements found in others."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ndiscarding a key from the collection.", "response": "def discard_member(self, member, pipe=None):\n        \"\"\"\n        Remove *member* from the collection, unconditionally.\n        \"\"\"\n        pipe = self.redis if pipe is None else pipe\n        pipe.zrem(self.key, self._pickle(member))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nyielding each member of the set in the collection without pulling them all into memory.", "response": "def scan_items(self):\n        \"\"\"\n        Yield each of the ``(member, score)`` tuples from the collection,\n        without pulling them all into memory.\n\n        .. warning::\n            This method may return the same (member, score) tuple multiple\n            times.\n            See the `Redis SCAN documentation\n            <http://redis.io/commands/scan#scan-guarantees>`_ for details.\n        \"\"\"\n        for m, s in self.redis.zscan_iter(self.key):\n            yield self._unpickle(m), s"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef update(self, other):\n        def update_trans(pipe):\n            other_items = method(pipe=pipe) if use_redis else method()\n\n            pipe.multi()\n            for member, score in other_items:\n                pipe.zadd(self.key, {self._pickle(member): float(score)})\n\n        watches = []\n        if self._same_redis(other, RedisCollection):\n            use_redis = True\n            watches.append(other.key)\n        else:\n            use_redis = False\n\n        if hasattr(other, 'items'):\n            method = other.items\n        elif hasattr(other, '__iter__'):\n            method = other.__iter__\n\n        self._transaction(update_trans, *watches)", "response": "Update the collection with items from other. Accepts other\n        instance dictionaries mapping members to\n            numeric scores or sequences of tuples of member score."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef count_between(self, min_score=None, max_score=None):\n        min_score = float('-inf') if min_score is None else float(min_score)\n        max_score = float('inf') if max_score is None else float(max_score)\n\n        return self.redis.zcount(self.key, min_score, max_score)", "response": "Returns the number of members whose score is between min_score and max_score ( inclusive."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nremoves members from the cache that are in the given range between the given scores and the given min and max scores.", "response": "def discard_between(\n        self,\n        min_rank=None,\n        max_rank=None,\n        min_score=None,\n        max_score=None,\n    ):\n        \"\"\"\n        Remove members whose ranking is between *min_rank* and *max_rank*\n        OR whose score is between *min_score* and *max_score* (both ranges\n        inclusive). If no bounds are specified, no members will be removed.\n        \"\"\"\n        no_ranks = (min_rank is None) and (max_rank is None)\n        no_scores = (min_score is None) and (max_score is None)\n\n        # Default scope: nothing\n        if no_ranks and no_scores:\n            return\n\n        # Scope widens to given score range\n        if no_ranks and (not no_scores):\n            return self.discard_by_score(min_score, max_score)\n\n        # Scope widens to given rank range\n        if (not no_ranks) and no_scores:\n            return self.discard_by_rank(min_rank, max_rank)\n\n        # Scope widens to score range and then rank range\n        with self.redis.pipeline() as pipe:\n            self.discard_by_score(min_score, max_score, pipe)\n            self.discard_by_rank(min_rank, max_rank, pipe)\n            pipe.execute()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_score(self, member, default=None, pipe=None):\n        pipe = self.redis if pipe is None else pipe\n        score = pipe.zscore(self.key, self._pickle(member))\n\n        if (score is None) and (default is not None):\n            score = float(default)\n\n        return score", "response": "Get the score of a member in the available set."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting or set the score of a member in the collection.", "response": "def get_or_set_score(self, member, default=0):\n        \"\"\"\n        If *member* is in the collection, return its value. If not, store it\n        with a score of *default* and return *default*. *default* defaults to\n        0.\n        \"\"\"\n        default = float(default)\n\n        def get_or_set_score_trans(pipe):\n            pickled_member = self._pickle(member)\n            score = pipe.zscore(self.key, pickled_member)\n\n            if score is None:\n                pipe.zadd(self.key, {self._pickle(member): default})\n                return default\n\n            return score\n\n        return self._transaction(get_or_set_score_trans)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget the rank of a member in the collection.", "response": "def get_rank(self, member, reverse=False, pipe=None):\n        \"\"\"\n        Return the rank of *member* in the collection.\n        By default, the member with the lowest score has rank 0.\n        If *reverse* is ``True``, the member with the highest score has rank 0.\n        \"\"\"\n        pipe = self.redis if pipe is None else pipe\n        method = getattr(pipe, 'zrevrank' if reverse else 'zrank')\n        rank = method(self.key, self._pickle(member))\n\n        return rank"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nincrements the score of a member in the record store by amount.", "response": "def increment_score(self, member, amount=1):\n        \"\"\"\n        Adjust the score of *member* by *amount*. If *member* is not in the\n        collection it will be stored with a score of *amount*.\n        \"\"\"\n        return self.redis.zincrby(\n            self.key, float(amount), self._pickle(member)\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a list of items in the cache.", "response": "def items(\n        self,\n        min_rank=None,\n        max_rank=None,\n        min_score=None,\n        max_score=None,\n        reverse=False,\n        pipe=None,\n    ):\n        \"\"\"\n        Return a list of ``(member, score)`` tuples whose ranking is between\n        *min_rank* and *max_rank* AND whose score is between *min_score* and\n        *max_score* (both ranges inclusive). If no bounds are specified, all\n        items will be returned.\n        \"\"\"\n        pipe = self.redis if pipe is None else pipe\n\n        no_ranks = (min_rank is None) and (max_rank is None)\n        no_scores = (min_score is None) and (max_score is None)\n\n        # Default scope: everything\n        if no_ranks and no_scores:\n            ret = self.items_by_score(min_score, max_score, reverse, pipe)\n        # Scope narrows to given score range\n        elif no_ranks and (not no_scores):\n            ret = self.items_by_score(min_score, max_score, reverse, pipe)\n        # Scope narrows to given rank range\n        elif (not no_ranks) and no_scores:\n            ret = self.items_by_rank(min_rank, max_rank, reverse, pipe)\n        # Scope narrows twice - once by rank and once by score\n        else:\n            results = self.items_by_rank(min_rank, max_rank, reverse, pipe)\n            ret = []\n            for member, score in results:\n                if (min_score is not None) and (score < min_score):\n                    continue\n                if (max_score is not None) and (score > max_score):\n                    continue\n                ret.append((member, score))\n\n        return ret"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset the score of member to score.", "response": "def set_score(self, member, score, pipe=None):\n        \"\"\"\n        Set the score of *member* to *score*.\n        \"\"\"\n        pipe = self.redis if pipe is None else pipe\n        pipe.zadd(self.key, {self._pickle(member): float(score)})"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the great circle distance between two sets of locations.", "response": "def distance_between(self, place_1, place_2, unit='km'):\n        \"\"\"\n        Return the great-circle distance between *place_1* and *place_2*,\n        in the *unit* specified.\n\n        The default unit is ``'km'``, but ``'m'``, ``'mi'``, and ``'ft'`` can\n        also be specified.\n        \"\"\"\n        pickled_place_1 = self._pickle(place_1)\n        pickled_place_2 = self._pickle(place_2)\n        try:\n            return self.redis.geodist(\n                self.key, pickled_place_1, pickled_place_2, unit=unit\n            )\n        except TypeError:\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting the Geohash of place.", "response": "def get_hash(self, place):\n        \"\"\"\n        Return the Geohash of *place*.\n        If it's not present in the collection, ``None`` will be returned\n        instead.\n        \"\"\"\n        pickled_place = self._pickle(place)\n        try:\n            return self.redis.geohash(self.key, pickled_place)[0]\n        except (AttributeError, TypeError):\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_location(self, place):\n        pickled_place = self._pickle(place)\n        try:\n            longitude, latitude = self.redis.geopos(self.key, pickled_place)[0]\n        except (AttributeError, TypeError):\n            return None\n\n        return {'latitude': latitude, 'longitude': longitude}", "response": "Return a dict with the coordinates *place*. The keys are\n        latitude and longitude."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef places_within_radius(\n        self, place=None, latitude=None, longitude=None, radius=0, **kwargs\n    ):\n        \"\"\"\n        Return descriptions of the places stored in the collection that are\n        within the circle specified by the given location and radius.\n        A list of dicts will be returned.\n\n        The center of the circle can be specified by the identifier of another\n        place in the collection with the *place* keyword argument.\n        Or, it can be specified by using both the *latitude* and *longitude*\n        keyword arguments.\n\n        By default the *radius* is given in kilometers, but you may also set\n        the *unit* keyword argument to ``'m'``, ``'mi'``, or ``'ft'``.\n\n        Limit the number of results returned with the *count* keyword argument.\n\n        Change the sorted order by setting the *sort* keyword argument to\n        ``b'DESC'``.\n        \"\"\"\n        kwargs['withdist'] = True\n        kwargs['withcoord'] = True\n        kwargs['withhash'] = False\n        kwargs.setdefault('sort', 'ASC')\n        unit = kwargs.setdefault('unit', 'km')\n\n        # Make the query\n        if place is not None:\n            response = self.redis.georadiusbymember(\n                self.key, self._pickle(place), radius, **kwargs\n            )\n        elif (latitude is not None) and (longitude is not None):\n            response = self.redis.georadius(\n                self.key, longitude, latitude, radius, **kwargs\n            )\n        else:\n            raise ValueError(\n                'Must specify place, or both latitude and longitude'\n            )\n\n        # Assemble the result\n        ret = []\n        for item in response:\n            ret.append(\n                {\n                    'place': self._unpickle(item[0]),\n                    'distance': item[1],\n                    'unit': unit,\n                    'latitude': item[2][1],\n                    'longitude': item[2][0],\n                }\n            )\n\n        return ret", "response": "Returns a list of dictionaries describing the places stored in the collection that are within the given radius."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set_location(self, place, latitude, longitude, pipe=None):\n        pipe = self.redis if pipe is None else pipe\n        pipe.geoadd(self.key, longitude, latitude, self._pickle(place))", "response": "Set the location of the entry in the cache."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef update(self, other):\n        # other is another Sorted Set\n        def update_sortedset_trans(pipe):\n            items = other._data(pipe=pipe) if use_redis else other._data()\n\n            pipe.multi()\n            for member, score in items:\n                pipe.zadd(self.key, {self._pickle(member): float(score)})\n\n        # other is dict-like\n        def update_mapping_trans(pipe):\n            items = other.items(pipe=pipe) if use_redis else other.items()\n\n            pipe.multi()\n            for place, value in items:\n                self.set_location(\n                    place, value['latitude'], value['longitude'], pipe=pipe\n                )\n\n        # other is a list of tuples\n        def update_tuples_trans(pipe):\n            items = (\n                other.__iter__(pipe=pipe) if use_redis else other.__iter__()\n            )\n\n            pipe.multi()\n            for place, latitude, longitude in items:\n                self.set_location(place, latitude, longitude, pipe=pipe)\n\n        watches = []\n        if self._same_redis(other, RedisCollection):\n            use_redis = True\n            watches.append(other.key)\n        else:\n            use_redis = False\n\n        if isinstance(other, SortedSetBase):\n            func = update_sortedset_trans\n        elif hasattr(other, 'items'):\n            func = update_mapping_trans\n        elif hasattr(other, '__iter__'):\n            func = update_tuples_trans\n\n        self._transaction(func, *watches)", "response": "Update the collection with items from other. Accepts other : class : GeoDB instance or list of dictionaries mapping places to\n           ."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate a new collection with the same items and maxsize with the given key.", "response": "def copy(self, key=None):\n        \"\"\"\n        Creates another collection with the same items and maxsize with\n        the given *key*.\n        \"\"\"\n        other = self.__class__(\n            maxsize=self.maxsize, redis=self.persistence.redis, key=key\n        )\n        other.update(self)\n\n        return other"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates a new collection with keys from seq and values set to value.", "response": "def fromkeys(cls, seq, value=None, **kwargs):\n        \"\"\"\n        Create a new collection with keys from *seq* and values set to\n        *value*. The keyword arguments are passed to the persistent ``Dict``.\n        \"\"\"\n        other = cls(**kwargs)\n        other.update(((key, value) for key in seq))\n\n        return other"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsynchronizing the items from the local cache to the persistent Dict.", "response": "def sync(self, clear_cache=False):\n        \"\"\"\n        Copy items from the local cache to the persistent Dict.\n        If *clear_cache* is ``True``, clear out the local cache after\n        pushing its items to Redis.\n        \"\"\"\n        self.persistence.update(self)\n\n        if clear_cache:\n            self.cache.clear()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _data(self, pipe=None):\n        pipe = self.redis if pipe is None else pipe\n        return [self._unpickle(v) for v in pipe.lrange(self.key, 0, -1)]", "response": "Return a list of all values from Redis\n       "}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef append(self, value):\n        len_self = self.redis.rpush(self.key, self._pickle(value))\n\n        if self.writeback:\n            self.cache[len_self - 1] = value", "response": "Insert value at the end of this collection."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef copy(self, key=None):\n        other = self.__class__(\n            redis=self.redis, key=key, writeback=self.writeback\n        )\n        other.extend(self)\n\n        return other", "response": "Return a new collection with the same items as this one."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef extend(self, other):\n        def extend_trans(pipe):\n            values = list(other.__iter__(pipe)) if use_redis else other\n            len_self = pipe.rpush(self.key, *(self._pickle(v) for v in values))\n            if self.writeback:\n                for i, v in enumerate(values, len_self - len(values)):\n                    self.cache[i] = v\n\n        if self._same_redis(other, RedisCollection):\n            use_redis = True\n            self._transaction(extend_trans, other.key)\n        else:\n            use_redis = False\n            self._transaction(extend_trans)", "response": "Adds the values from the iterable other to the end of this collection."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the index of the first occurence of value.", "response": "def index(self, value, start=None, stop=None):\n        \"\"\"\n        Return the index of the first occurence of *value*.\n        If *start* or *stop* are provided, return the smallest\n        index such that ``s[index] == value`` and ``start <= index < stop``.\n        \"\"\"\n        def index_trans(pipe):\n            len_self, normal_start = self._normalize_index(start or 0, pipe)\n            __, normal_stop = self._normalize_index(stop or len_self, pipe)\n            for i, v in enumerate(self.__iter__(pipe=pipe)):\n                if v == value:\n                    if i < normal_start:\n                        continue\n                    if i >= normal_stop:\n                        break\n                    return i\n            raise ValueError\n\n        return self._transaction(index_trans)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ninserting a new entry into the collection at the specified index.", "response": "def insert(self, index, value):\n        \"\"\"\n        Insert *value* into the collection at *index*.\n        \"\"\"\n        if index == 0:\n            return self._insert_left(value)\n\n        def insert_middle_trans(pipe):\n            self._insert_middle(index, value, pipe=pipe)\n\n        return self._transaction(insert_middle_trans)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef pop(self, index=-1):\n        if index == 0:\n            return self._pop_left()\n        elif index == -1:\n            return self._pop_right()\n        else:\n            return self._pop_middle(index)", "response": "Remove the value at index from the collection and return it."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nremove the first occurence of value.", "response": "def remove(self, value):\n        \"\"\"Remove the first occurence of *value*.\"\"\"\n        def remove_trans(pipe):\n            # If we're caching, we'll need to synchronize before removing.\n            if self.writeback:\n                self._sync_helper(pipe)\n\n            delete_count = pipe.lrem(self.key, 1, self._pickle(value))\n            if delete_count == 0:\n                raise ValueError\n\n        self._transaction(remove_trans)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreversing the items of this collection in place.", "response": "def reverse(self):\n        \"\"\"\n        Reverses the items of this collection \"in place\" (only two values are\n        retrieved from Redis at a time).\n        \"\"\"\n        def reverse_trans(pipe):\n            if self.writeback:\n                self._sync_helper(pipe)\n\n            n = self.__len__(pipe)\n            for i in range(n // 2):\n                left = pipe.lindex(self.key, i)\n                right = pipe.lindex(self.key, n - i - 1)\n                pipe.lset(self.key, i, right)\n                pipe.lset(self.key, n - i - 1, left)\n\n        self._transaction(reverse_trans)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef sort(self, key=None, reverse=False):\n        def sort_trans(pipe):\n            values = list(self.__iter__(pipe))\n            values.sort(key=key, reverse=reverse)\n\n            pipe.multi()\n            pipe.delete(self.key)\n            pipe.rpush(self.key, *(self._pickle(v) for v in values))\n\n            if self.writeback:\n                self.cache = {}\n\n        return self._transaction(sort_trans)", "response": "Sort the items of this collection according to the optional callable\n            key."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nadds value to the right side of the collection.", "response": "def append(self, value):\n        \"\"\"Add *value* to the right side of the collection.\"\"\"\n        def append_trans(pipe):\n            self._append_helper(value, pipe)\n\n        self._transaction(append_trans)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nadding value to the left side of the collection.", "response": "def appendleft(self, value):\n        \"\"\"Add *value* to the left side of the collection.\"\"\"\n        def appendleft_trans(pipe):\n            self._appendleft_helper(value, pipe)\n\n        self._transaction(appendleft_trans)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef copy(self, key=None):\n        other = self.__class__(\n            self.__iter__(),\n            self.maxlen,\n            redis=self.redis,\n            key=key,\n            writeback=self.writeback,\n        )\n\n        return other", "response": "Return a new collection with the same items as this one."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nextending the right side of the collection by appending values from the iterable other.", "response": "def extend(self, other):\n        \"\"\"\n        Extend the right side of the the collection by appending values from\n        the iterable *other*.\n        \"\"\"\n        def extend_trans(pipe):\n            values = list(other.__iter__(pipe)) if use_redis else other\n            for v in values:\n                self._append_helper(v, pipe)\n\n        if self._same_redis(other, RedisCollection):\n            use_redis = True\n            self._transaction(extend_trans, other.key)\n        else:\n            use_redis = False\n            self._transaction(extend_trans)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nextend the left side of the collection by appending values from the iterable other.", "response": "def extendleft(self, other):\n        \"\"\"\n        Extend the left side of the the collection by appending values from\n        the iterable *other*. Note that the appends will reverse the order\n        of the given values.\n        \"\"\"\n        def extendleft_trans(pipe):\n            values = list(other.__iter__(pipe)) if use_redis else other\n            for v in values:\n                self._appendleft_helper(v, pipe)\n\n        if self._same_redis(other, RedisCollection):\n            use_redis = True\n            self._transaction(extendleft_trans, other.key)\n        else:\n            use_redis = False\n            self._transaction(extendleft_trans)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef insert(self, index, value):\n        def insert_trans(pipe):\n            len_self = self.__len__(pipe)\n            if (self.maxlen is not None) and (len_self >= self.maxlen):\n                raise IndexError\n\n            if index == 0:\n                self._insert_left(value, pipe)\n            else:\n                self._insert_middle(index, value, pipe=pipe)\n\n        self._transaction(insert_trans)", "response": "Insert value into the collection at index."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nrotating the deque n steps to the right.", "response": "def rotate(self, n=1):\n        \"\"\"\n        Rotate the deque n steps to the right.\n        If n is negative, rotate to the left.\n        \"\"\"\n        # No work to do for a 0-step rotate\n        if n == 0:\n            return\n\n        def rotate_trans(pipe):\n            # Synchronize the cache before rotating\n            if self.writeback:\n                self._sync_helper(pipe)\n\n            # Rotating len(self) times has no effect.\n            len_self = self.__len__(pipe)\n            steps = abs_n % len_self\n\n            # When n is positive we can use the built-in Redis command\n            if forward:\n                pipe.multi()\n                for __ in range(steps):\n                    pipe.rpoplpush(self.key, self.key)\n            # When n is negative we must use Python\n            else:\n                for __ in range(steps):\n                    pickled_value = pipe.lpop(self.key)\n                    pipe.rpush(self.key, pickled_value)\n\n        forward = n >= 0\n        abs_n = abs(n)\n        self._transaction(rotate_trans)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_entities_by_kind(membership_cache=None, is_active=True):\n    # Accept an existing cache or build a new one\n    if membership_cache is None:\n        membership_cache = EntityGroup.objects.get_membership_cache(is_active=is_active)\n\n    entities_by_kind = {}\n    kinds_with_all = set()\n    kinds_with_supers = set()\n    super_ids = set()\n\n    # Loop over each group\n    for group_id, memberships in membership_cache.items():\n\n        # Look at each membership\n        for entity_id, entity_kind_id in memberships:\n\n            # Only care about memberships with entity kind\n            if entity_kind_id:\n\n                # Make sure a dict exists for this kind\n                entities_by_kind.setdefault(entity_kind_id, {})\n\n                # Check if this is all entities of a kind under a specific entity\n                if entity_id:\n                    entities_by_kind[entity_kind_id][entity_id] = []\n                    kinds_with_supers.add(entity_kind_id)\n                    super_ids.add(entity_id)\n                else:\n                    # This is all entities of this kind\n                    entities_by_kind[entity_kind_id]['all'] = []\n                    kinds_with_all.add(entity_kind_id)\n\n    # Get entities for 'all'\n    all_entities_for_types = Entity.objects.filter(\n        entity_kind_id__in=kinds_with_all\n    ).values_list('id', 'entity_kind_id')\n\n    # Add entity ids to entity kind's all list\n    for id, entity_kind_id in all_entities_for_types:\n        entities_by_kind[entity_kind_id]['all'].append(id)\n\n    # Get relationships\n    relationships = EntityRelationship.objects.filter(\n        super_entity_id__in=super_ids,\n        sub_entity__entity_kind_id__in=kinds_with_supers\n    ).values_list(\n        'super_entity_id', 'sub_entity_id', 'sub_entity__entity_kind_id'\n    )\n\n    # Add entity ids to each super entity's list\n    for super_entity_id, sub_entity_id, sub_entity__entity_kind_id in relationships:\n        entities_by_kind[sub_entity__entity_kind_id].setdefault(super_entity_id, [])\n        entities_by_kind[sub_entity__entity_kind_id][super_entity_id].append(sub_entity_id)\n\n    return entities_by_kind", "response": "Returns a dict with keys of entity kinds and values are lists of Entity objects."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ngive a list of super entities return the entities that have those as a subset of their super entities.", "response": "def is_sub_to_all(self, *super_entities):\n        \"\"\"\n        Given a list of super entities, return the entities that have those as a subset of their super entities.\n        \"\"\"\n        if super_entities:\n            if len(super_entities) == 1:\n                # Optimize for the case of just one super entity since this is a much less intensive query\n                has_subset = EntityRelationship.objects.filter(\n                    super_entity=super_entities[0]).values_list('sub_entity', flat=True)\n            else:\n                # Get a list of entities that have super entities with all types\n                has_subset = EntityRelationship.objects.filter(\n                    super_entity__in=super_entities).values('sub_entity').annotate(Count('super_entity')).filter(\n                    super_entity__count=len(set(super_entities))).values_list('sub_entity', flat=True)\n\n            return self.filter(id__in=has_subset)\n        else:\n            return self"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the entities that have super entities that interset with those provided.", "response": "def is_sub_to_any(self, *super_entities):\n        \"\"\"\n        Given a list of super entities, return the entities that have super entities that interset with those provided.\n        \"\"\"\n        if super_entities:\n            return self.filter(id__in=EntityRelationship.objects.filter(\n                super_entity__in=super_entities).values_list('sub_entity', flat=True))\n        else:\n            return self"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef is_sub_to_all_kinds(self, *super_entity_kinds):\n        if super_entity_kinds:\n            if len(super_entity_kinds) == 1:\n                # Optimize for the case of just one\n                has_subset = EntityRelationship.objects.filter(\n                    super_entity__entity_kind=super_entity_kinds[0]).values_list('sub_entity', flat=True)\n            else:\n                # Get a list of entities that have super entities with all types\n                has_subset = EntityRelationship.objects.filter(\n                    super_entity__entity_kind__in=super_entity_kinds).values('sub_entity').annotate(\n                    Count('super_entity')).filter(super_entity__count=len(set(super_entity_kinds))).values_list(\n                    'sub_entity', flat=True)\n\n            return self.filter(pk__in=has_subset)\n        else:\n            return self", "response": "Returns a new queryset with only the superentites of the given entity_kinds."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef is_sub_to_any_kind(self, *super_entity_kinds):\n        if super_entity_kinds:\n            # get the pks of the desired subs from the relationships table\n            if len(super_entity_kinds) == 1:\n                entity_pks = EntityRelationship.objects.filter(\n                    super_entity__entity_kind=super_entity_kinds[0]\n                ).select_related('entity_kind', 'sub_entity').values_list('sub_entity', flat=True)\n            else:\n                entity_pks = EntityRelationship.objects.filter(\n                    super_entity__entity_kind__in=super_entity_kinds\n                ).select_related('entity_kind', 'sub_entity').values_list('sub_entity', flat=True)\n            # return a queryset limited to only those pks\n            return self.filter(pk__in=entity_pks)\n        else:\n            return self", "response": "Return a queryset of all entities that have super_entities of any of the specified kinds."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef cache_relationships(self, cache_super=True, cache_sub=True):\n        relationships_to_cache = compress(\n            ['super_relationships__super_entity', 'sub_relationships__sub_entity'], [cache_super, cache_sub])\n        return self.prefetch_related(*relationships_to_cache)", "response": "Caches the super and sub relationships by doing a prefetch_related."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngives a saved entity model object return the associated entity.", "response": "def get_for_obj(self, entity_model_obj):\n        \"\"\"\n        Given a saved entity model object, return the associated entity.\n        \"\"\"\n        return self.get(entity_type=ContentType.objects.get_for_model(\n            entity_model_obj, for_concrete_model=False), entity_id=entity_model_obj.id)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef delete_for_obj(self, entity_model_obj):\n        return self.filter(\n            entity_type=ContentType.objects.get_for_model(\n                entity_model_obj, for_concrete_model=False), entity_id=entity_model_obj.id).delete(\n            force=True)", "response": "Delete the entities associated with a model object."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef cache_relationships(self, cache_super=True, cache_sub=True):\n        return self.get_queryset().cache_relationships(cache_super=cache_super, cache_sub=cache_sub)", "response": "Caches the super and sub relationships by doing a prefetch_related."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_membership_cache(self, group_ids=None, is_active=True):\n        membership_queryset = EntityGroupMembership.objects.filter(\n            Q(entity__isnull=True) | (Q(entity__isnull=False) & Q(entity__is_active=is_active))\n        )\n        if is_active is None:\n            membership_queryset = EntityGroupMembership.objects.all()\n\n        if group_ids:\n            membership_queryset = membership_queryset.filter(entity_group_id__in=group_ids)\n\n        membership_queryset = membership_queryset.values_list('entity_group_id', 'entity_id', 'sub_entity_kind_id')\n\n        # Iterate over the query results and build the cache dict\n        membership_cache = {}\n        for entity_group_id, entity_id, sub_entity_kind_id in membership_queryset:\n            membership_cache.setdefault(entity_group_id, [])\n            membership_cache[entity_group_id].append([entity_id, sub_entity_kind_id])\n\n        return membership_cache", "response": "Builds a dict cache with the group membership info."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef all_entities(self, is_active=True):\n        return self.get_all_entities(return_models=True, is_active=is_active)", "response": "Return all the entities in the group."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_all_entities(self, membership_cache=None, entities_by_kind=None, return_models=False, is_active=True):\n        # If cache args were not passed, generate the cache\n        if membership_cache is None:\n            membership_cache = EntityGroup.objects.get_membership_cache([self.id], is_active=is_active)\n\n        if entities_by_kind is None:\n            entities_by_kind = entities_by_kind or get_entities_by_kind(membership_cache=membership_cache)\n\n        # Build set of all entity ids for this group\n        entity_ids = set()\n\n        # This group does have entities\n        if membership_cache.get(self.id):\n\n            # Loop over each membership in this group\n            for entity_id, entity_kind_id in membership_cache[self.id]:\n                if entity_id:\n                    if entity_kind_id:\n                        # All sub entities of this kind under this entity\n                        entity_ids.update(entities_by_kind[entity_kind_id][entity_id])\n                    else:\n                        # Individual entity\n                        entity_ids.add(entity_id)\n                else:\n                    # All entities of this kind\n                    entity_ids.update(entities_by_kind[entity_kind_id]['all'])\n\n        # Check if a queryset needs to be returned\n        if return_models:\n            return Entity.objects.filter(id__in=entity_ids)\n\n        return entity_ids", "response": "Returns a list of all entity ids in this group or optionally returns a queryset for all entity models."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef add_entity(self, entity, sub_entity_kind=None):\n        membership = EntityGroupMembership.objects.create(\n            entity_group=self,\n            entity=entity,\n            sub_entity_kind=sub_entity_kind,\n        )\n        return membership", "response": "Adds an entity or sub - entity group to this EntityGroup."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef bulk_add_entities(self, entities_and_kinds):\n        memberships = [EntityGroupMembership(\n            entity_group=self,\n            entity=entity,\n            sub_entity_kind=sub_entity_kind,\n        ) for entity, sub_entity_kind in entities_and_kinds]\n        created = EntityGroupMembership.objects.bulk_create(memberships)\n        return created", "response": "Bulk add many entities and sub - entity groups to this EntityGroup."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef remove_entity(self, entity, sub_entity_kind=None):\n        EntityGroupMembership.objects.get(\n            entity_group=self,\n            entity=entity,\n            sub_entity_kind=sub_entity_kind,\n        ).delete()", "response": "Removes an entity or sub - entity group from this EntityGroup."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nbulks remove entities and sub - entity groups to this EntityGroup.", "response": "def bulk_remove_entities(self, entities_and_kinds):\n        \"\"\"\n        Remove many entities and sub-entity groups to this EntityGroup.\n\n        :type entities_and_kinds: List of (Entity, EntityKind) pairs.\n        :param entities_and_kinds: A list of entity, entity-kind pairs\n            to remove from the group. In the pairs, the entity-kind\n            can be ``None``, to add a single entity, or some entity\n            kind to add all sub-entities of that kind.\n        \"\"\"\n        criteria = [\n            Q(entity=entity, sub_entity_kind=entity_kind)\n            for entity, entity_kind in entities_and_kinds\n        ]\n        criteria = reduce(lambda q1, q2: q1 | q2, criteria, Q())\n        EntityGroupMembership.objects.filter(\n            criteria, entity_group=self).delete()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nbulk overwrite the given entities and sub - entity groups.", "response": "def bulk_overwrite(self, entities_and_kinds):\n        \"\"\"\n        Update the group to the given entities and sub-entity groups.\n\n        After this operation, the only members of this EntityGroup\n        will be the given entities, and sub-entity groups.\n\n        :type entities_and_kinds: List of (Entity, EntityKind) pairs.\n        :param entities_and_kinds: A list of entity, entity-kind pairs\n            to set to the EntityGroup. In the pairs the entity-kind\n            can be ``None``, to add a single entity, or some entity\n            kind to add all sub-entities of that kind.\n        \"\"\"\n        EntityGroupMembership.objects.filter(entity_group=self).delete()\n        return self.bulk_add_entities(entities_and_kinds)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nset the slug for each Work in the DB.", "response": "def set_slug(apps, schema_editor, class_name):\n    \"\"\"\n    Create a slug for each Work already in the DB.\n    \"\"\"\n    Cls = apps.get_model('spectator_events', class_name)\n\n    for obj in Cls.objects.all():\n        obj.slug = generate_slug(obj.pk)\n        obj.save(update_fields=['slug'])"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_kind_name_plural(kind):\n        \"e.g. 'Gigs' or 'Movies'.\"\n        if kind in ['comedy', 'cinema', 'dance', 'theatre']:\n            return kind.title()\n        elif kind == 'museum':\n            return 'Galleries/Museums'\n        else:\n            return '{}s'.format(Event.get_kind_name(kind))", "response": "e. g. Gigs or Movies."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_kinds_data():\n        kinds = {k:{'name':v} for k,v in Event.KIND_CHOICES}\n        for k,data in kinds.items():\n            kinds[k]['slug'] = Event.KIND_SLUGS[k]\n            kinds[k]['name_plural'] = Event.get_kind_name_plural(k)\n        return kinds", "response": "Returns a dict of all the data about the kinds of the log entries. e. g. Gigs and Gigs are listed in Event. KIND_SLUGS and Event. KIND_NAME_PLURAL."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_list_url(self, kind_slug=None):\n        if kind_slug is None:\n            kind_slug = self.KIND_SLUGS[self.kind]\n        return reverse('spectator:events:work_list',\n                                            kwargs={'kind_slug': kind_slug})", "response": "Get the list URL for this Work."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nconverts descriptor and rows to Pandas DataFrame.", "response": "def convert_descriptor_and_rows(self, descriptor, rows):\n        \"\"\"Convert descriptor and rows to Pandas\n        \"\"\"\n\n        # Prepare\n        primary_key = None\n        schema = tableschema.Schema(descriptor)\n        if len(schema.primary_key) == 1:\n            primary_key = schema.primary_key[0]\n        elif len(schema.primary_key) > 1:\n            message = 'Multi-column primary keys are not supported'\n            raise tableschema.exceptions.StorageError(message)\n\n        # Get data/index\n        data_rows = []\n        index_rows = []\n        jtstypes_map = {}\n        for row in rows:\n            values = []\n            index = None\n            for field, value in zip(schema.fields, row):\n                try:\n                    if isinstance(value, float) and np.isnan(value):\n                        value = None\n                    if value and field.type == 'integer':\n                        value = int(value)\n                    value = field.cast_value(value)\n                except tableschema.exceptions.CastError:\n                    value = json.loads(value)\n                # http://pandas.pydata.org/pandas-docs/stable/gotchas.html#support-for-integer-na\n                if value is None and field.type in ('number', 'integer'):\n                    jtstypes_map[field.name] = 'number'\n                    value = np.NaN\n                if field.name == primary_key:\n                    index = value\n                else:\n                    values.append(value)\n            data_rows.append(tuple(values))\n            index_rows.append(index)\n\n        # Get dtypes\n        dtypes = []\n        for field in schema.fields:\n            if field.name != primary_key:\n                field_name = field.name\n                if six.PY2:\n                    field_name = field.name.encode('utf-8')\n                dtype = self.convert_type(jtstypes_map.get(field.name, field.type))\n                dtypes.append((field_name, dtype))\n\n        # Create dataframe\n        index = None\n        columns = schema.headers\n        array = np.array(data_rows, dtype=dtypes)\n        if primary_key:\n            index_field = schema.get_field(primary_key)\n            index_dtype = self.convert_type(index_field.type)\n            index_class = pd.Index\n            if index_field.type in ['datetime', 'date']:\n                index_class = pd.DatetimeIndex\n            index = index_class(index_rows, name=primary_key, dtype=index_dtype)\n            columns = filter(lambda column: column != primary_key, schema.headers)\n        dataframe = pd.DataFrame(array, index=index, columns=columns)\n\n        return dataframe"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nconverts type to Pandas", "response": "def convert_type(self, type):\n        \"\"\"Convert type to Pandas\n        \"\"\"\n\n        # Mapping\n        mapping = {\n            'any': np.dtype('O'),\n            'array': np.dtype(list),\n            'boolean': np.dtype(bool),\n            'date': np.dtype('O'),\n            'datetime': np.dtype('datetime64[ns]'),\n            'duration': np.dtype('O'),\n            'geojson': np.dtype('O'),\n            'geopoint': np.dtype('O'),\n            'integer': np.dtype(int),\n            'number': np.dtype(float),\n            'object': np.dtype(dict),\n            'string': np.dtype('O'),\n            'time': np.dtype('O'),\n            'year': np.dtype(int),\n            'yearmonth': np.dtype('O'),\n        }\n\n        # Get type\n        if type not in mapping:\n            message = 'Type \"%s\" is not supported' % type\n            raise tableschema.exceptions.StorageError(message)\n\n        return mapping[type]"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nrestores descriptor from Pandas", "response": "def restore_descriptor(self, dataframe):\n        \"\"\"Restore descriptor from Pandas\n        \"\"\"\n\n        # Prepare\n        fields = []\n        primary_key = None\n\n        # Primary key\n        if dataframe.index.name:\n            field_type = self.restore_type(dataframe.index.dtype)\n            field = {\n                'name': dataframe.index.name,\n                'type': field_type,\n                'constraints': {'required': True},\n            }\n            fields.append(field)\n            primary_key = dataframe.index.name\n\n        # Fields\n        for column, dtype in dataframe.dtypes.iteritems():\n            sample = dataframe[column].iloc[0] if len(dataframe) else None\n            field_type = self.restore_type(dtype, sample=sample)\n            field = {'name': column, 'type': field_type}\n            # TODO: provide better required indication\n            # if dataframe[column].isnull().sum() == 0:\n            #     field['constraints'] = {'required': True}\n            fields.append(field)\n\n        # Descriptor\n        descriptor = {}\n        descriptor['fields'] = fields\n        if primary_key:\n            descriptor['primaryKey'] = primary_key\n\n        return descriptor"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef restore_row(self, row, schema, pk):\n        result = []\n        for field in schema.fields:\n            if schema.primary_key and schema.primary_key[0] == field.name:\n                if field.type == 'number' and np.isnan(pk):\n                    pk = None\n                if pk and field.type == 'integer':\n                    pk = int(pk)\n                result.append(field.cast_value(pk))\n            else:\n                value = row[field.name]\n                if field.type == 'number' and np.isnan(value):\n                    value = None\n                if value and field.type == 'integer':\n                    value = int(value)\n                elif field.type == 'datetime':\n                    value = value.to_pydatetime()\n                result.append(field.cast_value(value))\n        return result", "response": "Restore row from Pandas\n           "}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef restore_type(self, dtype, sample=None):\n\n        # Pandas types\n        if pdc.is_bool_dtype(dtype):\n            return 'boolean'\n        elif pdc.is_datetime64_any_dtype(dtype):\n            return 'datetime'\n        elif pdc.is_integer_dtype(dtype):\n            return 'integer'\n        elif pdc.is_numeric_dtype(dtype):\n            return 'number'\n\n        # Python types\n        if sample is not None:\n            if isinstance(sample, (list, tuple)):\n                return 'array'\n            elif isinstance(sample, datetime.date):\n                return 'date'\n            elif isinstance(sample, isodate.Duration):\n                return 'duration'\n            elif isinstance(sample, dict):\n                return 'object'\n            elif isinstance(sample, six.string_types):\n                return 'string'\n            elif isinstance(sample, datetime.time):\n                return 'time'\n\n        return 'string'", "response": "Restore type from Pandas\n       "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a dict that can be used to display a link to the object s Admin page.", "response": "def change_object_link_card(obj, perms):\n    \"\"\"\n    If the user has permission to change `obj`, show a link to its Admin page.\n    obj -- An object like Movie, Play, ClassicalWork, Publication, etc.\n    perms -- The `perms` object that it's the template.\n    \"\"\"\n    # eg: 'movie' or 'classicalwork':\n    name = obj.__class__.__name__.lower()\n    permission = 'spectator.can_edit_{}'.format(name)\n    # eg: 'admin:events_classicalwork_change':\n    change_url_name = 'admin:{}_{}_change'.format(obj._meta.app_label, name)\n\n    return {\n        'display_link': (permission in perms),\n        'change_url': reverse(change_url_name, args=[obj.id])\n    }"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn an HTML link to the supplied URL, but only using the domain as the text. Strips 'www.' from the start of the domain, if present. e.g. if `my_url` is 'http://www.example.org/foo/' then: {{ my_url|domain_urlize }} returns: <a href=\"http://www.example.org/foo/\" rel=\"nofollow\">example.org</a>", "response": "def domain_urlize(value):\n    \"\"\"\n    Returns an HTML link to the supplied URL, but only using the domain as the\n    text. Strips 'www.' from the start of the domain, if present.\n\n    e.g. if `my_url` is 'http://www.example.org/foo/' then:\n\n        {{ my_url|domain_urlize }}\n\n    returns:\n        <a href=\"http://www.example.org/foo/\" rel=\"nofollow\">example.org</a>\n    \"\"\"\n    parsed_uri = urlparse(value)\n    domain = '{uri.netloc}'.format(uri=parsed_uri)\n\n    if domain.startswith('www.'):\n        domain = domain[4:]\n\n    return format_html('<a href=\"{}\" rel=\"nofollow\">{}</a>',\n            value,\n            domain\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef current_url_name(context):\n    url_name = False\n    if context.request.resolver_match:\n        url_name = \"{}:{}\".format(\n                                context.request.resolver_match.namespace,\n                                context.request.resolver_match.url_name\n                            )\n    return url_name", "response": "Returns the name of the current URL namespaced or False."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef query_string(context, key, value):\n    try:\n        request = context['request']\n        args = request.GET.copy()\n    except KeyError:\n        args = QueryDict('').copy()\n    args[key] = value\n    return args.urlencode()", "response": "Returns a query string for a URL."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef most_read_creators_card(num=10):\n    if spectator_apps.is_enabled('reading'):\n\n        object_list = most_read_creators(num=num)\n\n        object_list = chartify(object_list, 'num_readings', cutoff=1)\n\n        return {\n            'card_title': 'Most read authors',\n            'score_attr': 'num_readings',\n            'object_list': object_list,\n        }", "response": "Displays a card showing the most Readings of Creators who have the most Readings associated with their Publications."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef most_visited_venues_card(num=10):\n    if spectator_apps.is_enabled('events'):\n\n        object_list = most_visited_venues(num=num)\n\n        object_list = chartify(object_list, 'num_visits', cutoff=1)\n\n        return {\n            'card_title': 'Most visited venues',\n            'score_attr': 'num_visits',\n            'object_list': object_list,\n        }", "response": "Displays a card showing the most Visited Venues."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_entity(package, entity):\n    init_py = open(os.path.join(package, '__init__.py')).read()\n    find = \"__%s__ = ['\\\"]([^'\\\"]+)['\\\"]\" % entity\n    return re.search(find, init_py).group(1)", "response": "get_entity returns the value in\n   "}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreduce the number of queries and speed things up.", "response": "def get_queryset(self):\n        \"Reduce the number of queries and speed things up.\"\n        qs = super().get_queryset()\n\n        qs = qs.select_related('publication__series') \\\n                .prefetch_related('publication__roles__creator')\n\n        return qs"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef set_slug(apps, schema_editor):\n    Creator = apps.get_model('spectator_core', 'Creator')\n\n    for c in Creator.objects.all():\n        c.slug = generate_slug(c.pk)\n        c.save(update_fields=['slug'])", "response": "Create a slug for each Creator already in the DB."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncopy the ClassicalWork and DancePiece data to use the new through models.", "response": "def forwards(apps, schema_editor):\n    \"\"\"\n    Copy the ClassicalWork and DancePiece data to use the new through models.\n    \"\"\"\n    Event = apps.get_model('spectator_events', 'Event')\n    ClassicalWorkSelection = apps.get_model(\n                                'spectator_events', 'ClassicalWorkSelection')\n    DancePieceSelection = apps.get_model(\n                                'spectator_events', 'DancePieceSelection')\n\n    for event in Event.objects.all():\n\n        for work in event.classicalworks.all():\n            selection = ClassicalWorkSelection(\n                            classical_work=work,\n                            event=event)\n            selection.save()\n\n        for piece in event.dancepieces.all():\n            selection = DancePieceSelection(\n                            dance_piece=piece,\n                            event=event)\n            selection.save()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef forwards(apps, schema_editor):\n    Event = apps.get_model('spectator_events', 'Event')\n\n    for event in Event.objects.all():\n        if event.venue is not None:\n            event.venue_name = event.venue.name\n            event.save()", "response": "Set the venue_name field of all Events that have a Venue."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef forwards(apps, schema_editor):\n    Event = apps.get_model('spectator_events', 'Event')\n\n    for ev in Event.objects.filter(kind='exhibition'):\n        ev.kind = 'museum'\n        ev.save()", "response": "Migrate all exhibition Events to the new museum Event kind."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef truncate_string(text, strip_html=True, chars=255, truncate='\u2026', at_word_boundary=False):\n    if strip_html:\n        text = strip_tags(text)\n    text = text.replace('\\n', ' ').replace('\\r', '')\n    text = ' '.join(text.split())\n    if at_word_boundary:\n        if len(text) > chars:\n            text = text[:chars].rsplit(' ', 1)[0] + truncate\n    else:\n        text = Truncator(text).chars(chars, html=False, truncate=truncate)\n    return text", "response": "Truncate a string to a certain length."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef chartify(qs, score_field, cutoff=0, ensure_chartiness=True):\n    chart = []\n    position = 0\n    prev_obj = None\n\n    for counter, obj in enumerate(qs):\n        score = getattr(obj, score_field)\n\n        if score != getattr(prev_obj, score_field, None):\n            position = counter + 1\n\n        if cutoff is None or score > cutoff:\n            obj.chart_position = position\n            chart.append(obj)\n\n        prev_obj = obj\n\n    if ensure_chartiness and len(chart) > 0:\n        if getattr(chart[0], score_field) == getattr(chart[-1], score_field):\n            chart = []\n\n    return chart", "response": "Given a QuerySet it will go through and add a chart_position property to each object returning a list of the objects that are adjacent to the given score field. If the object is not adjacent to the given score the list will be empty."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a QuerySet of all the Venues that have been held there.", "response": "def by_visits(self, event_kind=None):\n        \"\"\"\n        Gets Venues in order of how many Events have been held there.\n        Adds a `num_visits` field to each one.\n\n        event_kind filters by kind of Event, e.g. 'theatre', 'cinema', etc.\n        \"\"\"\n        qs = self.get_queryset()\n\n        if event_kind is not None:\n            qs = qs.filter(event__kind=event_kind)\n\n        qs = qs.annotate(num_visits=Count('event')) \\\n                .order_by('-num_visits', 'name_sort')\n\n        return qs"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a QuerySet of all Works in order of how many times they have been attached to a specific Entry.", "response": "def by_views(self, kind=None):\n        \"\"\"\n        Gets Works in order of how many times they've been attached to\n        Events.\n\n        kind is the kind of Work, e.g. 'play', 'movie', etc.\n        \"\"\"\n        qs = self.get_queryset()\n\n        if kind is not None:\n            qs = qs.filter(kind=kind)\n\n        qs = qs.annotate(num_views=Count('event')) \\\n                .order_by('-num_views', 'title_sort')\n\n        return qs"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nmake a naturalized version of a general string, not a person's name. e.g., title of a book, a band's name, etc. string -- a lowercase string.", "response": "def naturalize_thing(self, string):\n        \"\"\"\n        Make a naturalized version of a general string, not a person's name.\n        e.g., title of a book, a band's name, etc.\n\n        string -- a lowercase string.\n        \"\"\"\n\n        # Things we want to move to the back of the string:\n        articles = [\n                        'a', 'an', 'the',\n                        'un', 'une', 'le', 'la', 'les', \"l'\", \"l\u2019\",\n                        'ein', 'eine', 'der', 'die', 'das',\n                        'una', 'el', 'los', 'las',\n                    ]\n\n        sort_string = string\n        parts = string.split(' ')\n\n        if len(parts) > 1 and parts[0] in articles:\n            if parts[0] != parts[1]:\n                # Don't do this if the name is 'The The' or 'La La Land'.\n                # Makes 'long blondes, the':\n                sort_string = '{}, {}'.format(' '.join(parts[1:]), parts[0])\n\n        sort_string = self._naturalize_numbers(sort_string)\n\n        return sort_string"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nattempts to make a version of the string that has the surname, if any, at the start. 'John, Brown' to 'Brown, John' 'Sir John Brown Jr' to 'Brown, Sir John Jr' 'Prince' to 'Prince' string -- The string to change.", "response": "def naturalize_person(self, string):\n        \"\"\"\n        Attempt to make a version of the string that has the surname, if any,\n        at the start.\n\n        'John, Brown' to 'Brown, John'\n        'Sir John Brown Jr' to 'Brown, Sir John Jr'\n        'Prince' to 'Prince'\n\n        string -- The string to change.\n        \"\"\"\n        suffixes = [\n                    'Jr', 'Jr.', 'Sr', 'Sr.',\n                    'I', 'II', 'III', 'IV', 'V',\n                    ]\n        # Add lowercase versions:\n        suffixes = suffixes + [s.lower() for s in suffixes]\n\n        # If a name has a capitalised particle in we use that to sort.\n        # So 'Le Carre, John' but 'Carre, John le'.\n        particles = [\n                    'Le', 'La',\n                    'Von', 'Van',\n                    'Du', 'De',\n                    ]\n\n        surname = '' # Smith\n        names = ''   # Fred James\n        suffix = ''  # Jr\n\n        sort_string = string\n        parts = string.split(' ')\n\n        if parts[-1] in suffixes:\n            # Remove suffixes entirely, as we'll add them back on the end.\n            suffix = parts[-1]\n            parts = parts[0:-1] # Remove suffix from parts\n            sort_string = ' '.join(parts)\n\n        if len(parts) > 1:\n\n            if parts[-2] in particles:\n                # From ['Alan', 'Barry', 'Le', 'Carr\u00e9']\n                # to   ['Alan', 'Barry', 'Le Carr\u00e9']:\n                parts = parts[0:-2] + [ ' '.join(parts[-2:]) ]\n\n            # From 'David Foster Wallace' to 'Wallace, David Foster':\n            sort_string = '{}, {}'.format(parts[-1], ' '.join(parts[:-1]))\n\n        if suffix:\n            # Add it back on.\n            sort_string = '{} {}'.format(sort_string, suffix)\n\n        # In case this name has any numbers in it.\n        sort_string = self._naturalize_numbers(sort_string)\n\n        return sort_string"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ntaking a string and replaces any zero - padded numbers into very zero - padded numbers.", "response": "def _naturalize_numbers(self, string):\n        \"\"\"\n        Makes any integers into very zero-padded numbers.\n        e.g. '1' becomes '00000001'.\n        \"\"\"\n\n        def naturalize_int_match(match):\n            return '%08d' % (int(match.group(0)),)\n\n        string = re.sub(r'\\d+', naturalize_int_match, string)\n\n        return string"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a list of dicts that are lists of dicts with counts for each year of reading.", "response": "def annual_reading_counts(kind='all'):\n    \"\"\"\n    Returns a list of dicts, one per year of reading. In year order.\n    Each dict is like this (if kind is 'all'):\n\n        {'year':        datetime.date(2003, 1, 1),\n         'book':        12,    # only included if kind is 'all' or 'book'\n         'periodical':  18,    # only included if kind is 'all' or 'periodical'\n         'total':       30,    # only included if kind is 'all'\n         }\n\n    We use the end_date of a Reading to count when that thing was read.\n\n    kind is one of 'book', 'periodical' or 'all', for both.\n    \"\"\"\n    if kind == 'all':\n        kinds = ['book', 'periodical']\n    else:\n        kinds = [kind]\n\n    # This will have keys of years (strings) and dicts of data:\n    # {\n    #   '2003': {'books': 12, 'periodicals': 18},\n    # }\n    counts = OrderedDict()\n\n    for k in kinds:\n        qs = Reading.objects.exclude(end_date__isnull=True) \\\n                            .filter(publication__kind=k) \\\n                            .annotate(year=TruncYear('end_date')) \\\n                            .values('year') \\\n                            .annotate(count=Count('id')) \\\n                            .order_by('year')\n\n        for year_data in qs:\n            year_str = year_data['year'].strftime('%Y')\n            if not year_str in counts:\n                counts[year_str] = {\n                    'year': year_data['year'],\n                }\n\n            counts[year_str][k] = year_data['count']\n\n    # Now translate counts into our final list, with totals, and 0s for kinds\n    # when they have no Readings for that year.\n    counts_list = []\n\n    for year_str, data in counts.items():\n        year_data = {\n            'year': data['year'],\n        }\n        if kind == 'all':\n            year_data['total'] = 0\n\n        for k in kinds:\n            if k in data:\n                year_data[k] = data[k]\n                if kind == 'all':\n                    year_data['total'] += data[k]\n            else:\n                year_data[k] = 0\n\n        counts_list.append(year_data)\n\n    return counts_list"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef lookups(self, request, model_admin):\n        list_of_countries = []\n\n        # We don't need the country_count but we need to annotate them in order\n        # to group the results.\n        qs = Venue.objects.exclude(country='') \\\n                            .values('country') \\\n                            .annotate(country_count=Count('country')) \\\n                            .order_by('country')\n        for obj in qs:\n            country = obj['country']\n            list_of_countries.append(\n                (country, Venue.COUNTRIES[country])\n            )\n\n        return sorted(list_of_countries, key=lambda c: c[1])", "response": "Returns a list of tuples like Australia GB UK and USA."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef queryset(self, request, queryset):\n        if self.value():\n            return queryset.filter(country=self.value())\n        else:\n            return queryset", "response": "Returns the filtered queryset based on the value\n        provided in the query string and retrievable via the self. value property."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncopy data from the old Event. movie and Event. play ManyToManyFields into the new Event. movies and Event. plays ManyToManyFields.", "response": "def forward(apps, schema_editor):\n    \"\"\"\n    Copying data from the old `Event.movie` and `Event.play` ForeignKey fields\n    into the new `Event.movies` and `Event.plays` ManyToManyFields.\n    \"\"\"\n\n    Event = apps.get_model('spectator_events', 'Event')\n    MovieSelection = apps.get_model('spectator_events', 'MovieSelection')\n    PlaySelection = apps.get_model('spectator_events', 'PlaySelection')\n\n    for event in Event.objects.all():\n        if event.movie is not None:\n            selection = MovieSelection(event=event, movie=event.movie)\n            selection.save()\n\n        if event.play is not None:\n            selection = PlaySelection(event=event, play=event.play)\n            selection.save()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate a slug for each Event already in the DB.", "response": "def set_slug(apps, schema_editor):\n    \"\"\"\n    Create a slug for each Event already in the DB.\n    \"\"\"\n    Event = apps.get_model('spectator_events', 'Event')\n\n    for e in Event.objects.all():\n        e.slug = generate_slug(e.pk)\n        e.save(update_fields=['slug'])"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a standard page instance with custom digg - specific page ranges attached.", "response": "def page(self, number, *args, **kwargs):\n        \"\"\"Return a standard ``Page`` instance with custom, digg-specific\n        page ranges attached.\n        \"\"\"\n\n        page = super().page(number, *args, **kwargs)\n        number = int(number) # we know this will work\n\n        # easier access\n        num_pages, body, tail, padding, margin = \\\n            self.num_pages, self.body, self.tail, self.padding, self.margin\n\n        # put active page in middle of main range\n        main_range = list(map(int, [\n            math.floor(number-body/2.0)+1,  # +1 = shift odd body to right\n            math.floor(number+body/2.0)]))\n        # adjust bounds\n        if main_range[0] < 1:\n            main_range = list(map(abs(main_range[0]-1).__add__, main_range))\n        if main_range[1] > num_pages:\n            main_range = list(map((num_pages-main_range[1]).__add__, main_range))\n\n        # Determine leading and trailing ranges; if possible and appropriate,\n        # combine them with the main range, in which case the resulting main\n        # block might end up considerable larger than requested. While we\n        # can't guarantee the exact size in those cases, we can at least try\n        # to come as close as possible: we can reduce the other boundary to\n        # max padding, instead of using half the body size, which would\n        # otherwise be the case. If the padding is large enough, this will\n        # of course have no effect.\n        # Example:\n        #     total pages=100, page=4, body=5, (default padding=2)\n        #     1 2 3 [4] 5 6 ... 99 100\n        #     total pages=100, page=4, body=5, padding=1\n        #     1 2 3 [4] 5 ... 99 100\n        # If it were not for this adjustment, both cases would result in the\n        # first output, regardless of the padding value.\n        if main_range[0] <= tail+margin:\n            leading = []\n            main_range = [1, max(body, min(number+padding, main_range[1]))]\n            main_range[0] = 1\n        else:\n            leading = list(range(1, tail+1))\n        # basically same for trailing range, but not in ``left_align`` mode\n        if self.align_left:\n            trailing = []\n        else:\n            if main_range[1] >= num_pages-(tail+margin)+1:\n                trailing = []\n                if not leading:\n                    # ... but handle the special case of neither leading nor\n                    # trailing ranges; otherwise, we would now modify the\n                    # main range low bound, which we just set in the previous\n                    # section, again.\n                    main_range = [1, num_pages]\n                else:\n                    main_range = [min(num_pages-body+1, max(number-padding, main_range[0])), num_pages]\n            else:\n                trailing = list(range(num_pages-tail+1, num_pages+1))\n\n        # finally, normalize values that are out of bound; this basically\n        # fixes all the things the above code screwed up in the simple case\n        # of few enough pages where one range would suffice.\n        main_range = [max(main_range[0], 1), min(main_range[1], num_pages)]\n\n        # make the result of our calculations available as custom ranges\n        # on the ``Page`` instance.\n        page.main_range = list(range(main_range[0], main_range[1]+1))\n        page.leading_range = leading\n        page.trailing_range = trailing\n        page.page_range = reduce(lambda x, y: x+((x and y) and [False])+y,\n            [page.leading_range, page.main_range, page.trailing_range])\n\n        page.__class__ = DiggPage\n        return page"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef version():\n    namespace = {}\n    with open(os.path.join('mrcfile', 'version.py')) as f:\n        exec(f.read(), namespace)\n    return namespace['__version__']", "response": "Get the version number without importing the mrcfile package."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_event_counts(self):\n        counts = {'all': Event.objects.count(),}\n\n        for k,v in Event.KIND_CHOICES:\n            # e.g. 'movie_count':\n            counts[k] = Event.objects.filter(kind=k).count()\n\n        return {'counts': counts,}", "response": "Returns a dict of event counts."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_event_kind(self):\n        slug = self.kwargs.get('kind_slug', None)\n        if slug is None:\n            return None  # Front page; showing all Event kinds.\n        else:\n            slugs_to_kinds = {v:k for k,v in Event.KIND_SLUGS.items()}\n            return slugs_to_kinds.get(slug, None)", "response": "Returns the event kind from the kind_slug."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nrestrict to a single kind of event if any and include Venue data.", "response": "def get_queryset(self):\n        \"Restrict to a single kind of event, if any, and include Venue data.\"\n        qs = super().get_queryset()\n\n        kind = self.get_event_kind()\n        if kind is not None:\n            qs = qs.filter(kind=kind)\n\n        qs = qs.select_related('venue')\n\n        return qs"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_work_kind(self):\n        slugs_to_kinds = {v:k for k,v in Work.KIND_SLUGS.items()}\n        return slugs_to_kinds.get(self.kind_slug, None)", "response": "Get the work kind from the kind_slug."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_countries(self):\n        qs = Venue.objects.values('country') \\\n                                    .exclude(country='') \\\n                                    .distinct() \\\n                                    .order_by('country')\n\n        countries = []\n\n        for c in qs:\n            countries.append({\n                'code': c['country'],\n                'name': Venue.get_country_name(c['country'])\n            })\n\n        return sorted(countries, key=lambda k: k['name'])", "response": "Returns a list of dicts one per country that has at least one Venue\n        in it."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef annual_event_counts(kind='all'):\n    qs = Event.objects\n\n    if kind != 'all':\n        qs = qs.filter(kind=kind)\n\n    qs = qs.annotate(year=TruncYear('date')) \\\n            .values('year') \\\n            .annotate(total=Count('id')) \\\n            .order_by('year')\n\n    return qs", "response": "Returns a QuerySet of dicts with the keys year total and the values of the year that are annual events."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef annual_event_counts_card(kind='all', current_year=None):\n    if kind == 'all':\n        card_title = 'Events per year'\n    else:\n        card_title = '{} per year'.format(Event.get_kind_name_plural(kind))\n\n    return {\n            'card_title': card_title,\n            'kind': kind,\n            'years': annual_event_counts(kind=kind),\n            'current_year': current_year\n            }", "response": "A simple card showing the number of events per year."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nrenders a date as a date and display it in a time tag.", "response": "def display_date(d):\n    \"\"\"\n    Render a date/datetime (d) as a date, using the SPECTATOR_DATE_FORMAT\n    setting. Wrap the output in a <time> tag.\n\n    Time tags: http://www.brucelawson.co.uk/2012/best-of-time/\n    \"\"\"\n    stamp = d.strftime('%Y-%m-%d')\n    visible_date = d.strftime(app_settings.DATE_FORMAT)\n\n    return format_html('<time datetime=\"%(stamp)s\">%(visible)s</time>' % {\n                'stamp': stamp,\n                'visible': visible_date\n            })"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ndisplay the tabs to different event_list pages. `counts` is a dict of number of events for each kind, like: {'all': 30, 'gig': 12, 'movie': 18,} `current_kind` is the event kind that's active, if any. e.g. 'gig', 'movie', etc. `page_number` is the current page of this kind of events we're on.", "response": "def event_list_tabs(counts, current_kind, page_number=1):\n    \"\"\"\n    Displays the tabs to different event_list pages.\n\n    `counts` is a dict of number of events for each kind, like:\n        {'all': 30, 'gig': 12, 'movie': 18,}\n\n    `current_kind` is the event kind that's active, if any. e.g. 'gig',\n        'movie', etc.\n\n    `page_number` is the current page of this kind of events we're on.\n    \"\"\"\n    return {\n            'counts': counts,\n            'current_kind': current_kind,\n            'page_number': page_number,\n            # A list of all the kinds we might show tabs for, like\n            # ['gig', 'movie', 'play', ...]\n            'event_kinds': Event.get_kinds(),\n            # A dict of data about each kind, keyed by kind ('gig') including\n            # data about 'name', 'name_plural' and 'slug':\n            'event_kinds_data': Event.get_kinds_data(),\n        }"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ndisplay the events that happened on the supplied date.", "response": "def day_events_card(date):\n    \"\"\"\n    Displays Events that happened on the supplied date.\n    `date` is a date object.\n    \"\"\"\n    d = date.strftime(app_settings.DATE_FORMAT)\n    card_title = 'Events on {}'.format(d)\n    return {\n            'card_title': card_title,\n            'event_list': day_events(date=date),\n            }"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef most_seen_creators_card(event_kind=None, num=10):\n    object_list = most_seen_creators(event_kind=event_kind, num=num)\n\n    object_list = chartify(object_list, 'num_events', cutoff=1)\n\n    return {\n        'card_title': 'Most seen people/groups',\n        'score_attr': 'num_events',\n        'object_list': object_list,\n    }", "response": "Displays a card showing the most seen Creators."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a QuerySet of Creators that are associated with the most Works.", "response": "def most_seen_creators_by_works(work_kind=None, role_name=None, num=10):\n    \"\"\"\n    Returns a QuerySet of the Creators that are associated with the most Works.\n    \"\"\"\n    return Creator.objects.by_works(kind=work_kind, role_name=role_name)[:num]"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ndisplay a card showing the Creators that are associated with the most Works.", "response": "def most_seen_creators_by_works_card(work_kind=None, role_name=None, num=10):\n    \"\"\"\n    Displays a card showing the Creators that are associated with the most Works.\n\n    e.g.:\n\n      {% most_seen_creators_by_works_card work_kind='movie' role_name='Director' num=5 %}\n    \"\"\"\n    object_list = most_seen_creators_by_works(\n                            work_kind=work_kind, role_name=role_name, num=num)\n\n    object_list = chartify(object_list, 'num_works', cutoff=1)\n\n    # Attempt to create a sensible card title...\n\n    if role_name:\n        # Yes, this pluralization is going to break at some point:\n        creators_name = '{}s'.format(role_name.capitalize())\n    else:\n        creators_name = 'People/groups'\n\n    if work_kind:\n        works_name = Work.get_kind_name_plural(work_kind).lower()\n    else:\n        works_name = 'works'\n\n    card_title = '{} with most {}'.format(creators_name, works_name)\n\n    return {\n        'card_title': card_title,\n        'score_attr': 'num_works',\n        'object_list': object_list,\n    }"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef most_seen_works_card(kind=None, num=10):\n    object_list = most_seen_works(kind=kind, num=num)\n\n    object_list = chartify(object_list, 'num_views', cutoff=1)\n\n    if kind:\n        card_title = 'Most seen {}'.format(\n                                    Work.get_kind_name_plural(kind).lower())\n    else:\n        card_title = 'Most seen works'\n\n    return {\n        'card_title': card_title,\n        'score_attr': 'num_views',\n        'object_list': object_list,\n        'name_attr': 'title',\n        'use_cite': True,\n    }", "response": "Displays a card showing the Works that are associated with the most Events."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _generate_slug(self, value):\n        alphabet = app_settings.SLUG_ALPHABET\n        salt = app_settings.SLUG_SALT\n\n        hashids = Hashids(alphabet=alphabet, salt=salt, min_length=5)\n\n        return hashids.encode(value)", "response": "Generates a slug using a Hashid of value."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef create(self, bucket, descriptor, force=False):\n\n        # Make lists\n        buckets = bucket\n        if isinstance(bucket, six.string_types):\n            buckets = [bucket]\n        descriptors = descriptor\n        if isinstance(descriptor, dict):\n            descriptors = [descriptor]\n\n        # Check buckets for existence\n        for bucket in buckets:\n            if bucket in self.buckets:\n                if not force:\n                    message = 'Bucket \"%s\" already exists' % bucket\n                    raise tableschema.exceptions.StorageError(message)\n                self.delete(bucket)\n\n        # Define dataframes\n        for bucket, descriptor in zip(buckets, descriptors):\n            tableschema.validate(descriptor)\n            self.__descriptors[bucket] = descriptor\n            self.__dataframes[bucket] = pd.DataFrame()", "response": "Create a new object in the storage."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef delete(self, bucket=None, ignore=False):\n\n        # Make lists\n        buckets = bucket\n        if isinstance(bucket, six.string_types):\n            buckets = [bucket]\n        elif bucket is None:\n            buckets = reversed(self.buckets)\n\n        # Iterate over buckets\n        for bucket in buckets:\n\n            # Non existent bucket\n            if bucket not in self.buckets:\n                if not ignore:\n                    message = 'Bucket \"%s\" doesn\\'t exist' % bucket\n                    raise tableschema.exceptions.StorageError(message)\n                return\n\n            # Remove from descriptors\n            if bucket in self.__descriptors:\n                del self.__descriptors[bucket]\n\n            # Remove from dataframes\n            if bucket in self.__dataframes:\n                del self.__dataframes[bucket]", "response": "Delete the object from the database."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget or set the descriptor for a given bucket.", "response": "def describe(self, bucket, descriptor=None):\n        \"\"\"https://github.com/frictionlessdata/tableschema-pandas-py#storage\n        \"\"\"\n\n        # Set descriptor\n        if descriptor is not None:\n            self.__descriptors[bucket] = descriptor\n\n        # Get descriptor\n        else:\n            descriptor = self.__descriptors.get(bucket)\n            if descriptor is None:\n                dataframe = self.__dataframes[bucket]\n                descriptor = self.__mapper.restore_descriptor(dataframe)\n\n        return descriptor"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef iter(self, bucket):\n\n        # Check existense\n        if bucket not in self.buckets:\n            message = 'Bucket \"%s\" doesn\\'t exist.' % bucket\n            raise tableschema.exceptions.StorageError(message)\n\n        # Prepare\n        descriptor = self.describe(bucket)\n        schema = tableschema.Schema(descriptor)\n\n        # Yield rows\n        for pk, row in self.__dataframes[bucket].iterrows():\n            row = self.__mapper.restore_row(row, schema=schema, pk=pk)\n            yield row", "response": "Iterate over the items in the specified bucket."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nwrite the rows to the DataFrame.", "response": "def write(self, bucket, rows):\n        \"\"\"https://github.com/frictionlessdata/tableschema-pandas-py#storage\n        \"\"\"\n\n        # Prepare\n        descriptor = self.describe(bucket)\n        new_data_frame = self.__mapper.convert_descriptor_and_rows(descriptor, rows)\n\n        # Just set new DataFrame if current is empty\n        if self.__dataframes[bucket].size == 0:\n            self.__dataframes[bucket] = new_data_frame\n\n        # Append new data frame to the old one setting new data frame\n        # containing data from both old and new data frames\n        else:\n            self.__dataframes[bucket] = pd.concat([\n                self.__dataframes[bucket],\n                new_data_frame,\n            ])"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef forwards(apps, schema_editor):\n    Movie = apps.get_model('spectator_events', 'Movie')\n    Work = apps.get_model('spectator_events', 'Work')\n    WorkRole = apps.get_model('spectator_events', 'WorkRole')\n    WorkSelection = apps.get_model('spectator_events', 'WorkSelection')\n\n    for m in Movie.objects.all():\n\n        work = Work.objects.create(\n            kind='movie',\n            title=m.title,\n            title_sort=m.title_sort,\n            year=m.year,\n            imdb_id=m.imdb_id\n        )\n\n        for role in m.roles.all():\n            WorkRole.objects.create(\n                creator=role.creator,\n                work=work,\n                role_name=role.role_name,\n                role_order=role.role_order\n            )\n\n        for selection in m.events.all():\n            WorkSelection.objects.create(\n                event=selection.event,\n                work=work,\n                order=selection.order\n            )\n\n        m.delete()", "response": "Change all Movie objects into Work objects and their associated\nAddon data into WorkRole and WorkSelection models then delete the Movie."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef paginate_queryset(self, queryset, page_size):\n        paginator = self.get_paginator(\n            queryset,\n            page_size,\n            orphans = self.get_paginate_orphans(),\n            allow_empty_first_page = self.get_allow_empty(),\n            body    = self.paginator_body,\n            margin  = self.paginator_margin,\n            padding = self.paginator_padding,\n            tail    = self.paginator_tail,\n        )\n        page_kwarg = self.page_kwarg\n        page = self.kwargs.get(page_kwarg) or self.request.GET.get(page_kwarg) or 1\n        try:\n            page_number = int(page)\n        except ValueError:\n            if page == 'last':\n                page_number = paginator.num_pages\n            else:\n                raise Http404(_(\"Page is not 'last', nor can it be converted to an int.\"))\n        try:\n            page = paginator.page(page_number, softlimit=False)\n            return (paginator, page, page.object_list, page.has_other_pages())\n        except InvalidPage as e:\n            raise Http404(_('Invalid page (%(page_number)s): %(message)s') % {\n                'page_number': page_number,\n                'message': str(e)\n            })", "response": "Paginate the queryset and return a tuple of tuples containing the paginator and the list of objects that are returned."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef annual_reading_counts_card(kind='all', current_year=None):\n    if kind == 'book':\n        card_title = 'Books per year'\n    elif kind == 'periodical':\n        card_title = 'Periodicals per year'\n    else:\n        card_title = 'Reading per year'\n\n    return {\n            'card_title': card_title,\n            'kind': kind,\n            'years': utils.annual_reading_counts(kind),\n            'current_year': current_year\n            }", "response": "Returns a dict with the information about the annual reading counts of the current year."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a QuerySet of Publications that were being read on date.", "response": "def day_publications(date):\n    \"\"\"\n    Returns a QuerySet of Publications that were being read on `date`.\n    `date` is a date tobject.\n    \"\"\"\n    readings = Reading.objects \\\n                        .filter(start_date__lte=date) \\\n                        .filter(\n                            Q(end_date__gte=date)\n                            |\n                            Q(end_date__isnull=True)\n                        )\n    if readings:\n        return Publication.objects.filter(reading__in=readings) \\\n                        .select_related('series') \\\n                        .prefetch_related('roles__creator') \\\n                        .distinct()\n    else:\n        return Publication.objects.none()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef day_publications_card(date):\n    d = date.strftime(app_settings.DATE_FORMAT)\n    card_title = 'Reading on {}'.format(d)\n    return {\n            'card_title': card_title,\n            'publication_list': day_publications(date=date),\n            }", "response": "Displays Publications that were being read on date."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef reading_dates(reading):\n\n    # 3 September 2017\n    full_format = '<time datetime=\"%Y-%m-%d\">{}</time>'.format('%-d %B %Y')\n    # September 2017\n    month_year_format = '<time datetime=\"%Y-%m\">{}</time>'.format('%B %Y')\n    # 2017\n    year_format = '<time datetime=\"%Y\">{}</time>'.format('%Y')\n    # 3\n    day_format = '<time datetime=\"%Y-%m-%d\">{}</time>'.format('%-d')\n    # 3 September\n    day_month_format = '<time datetime=\"%Y-%m-%d\">{}</time>'.format('%-d %B')\n    # September\n    month_format = '<time datetime=\"%Y-%m\">{}</time>'.format('%B')\n\n    period_format_short = '{}\u2013{}'\n\n    period_format_long = '{} to {}'\n\n    # For brevity:\n    start_date = reading.start_date\n    end_date = reading.end_date\n    start_gran = reading.start_granularity\n    end_gran = reading.end_granularity\n\n    # Are start and end in the same day, year or month?\n    same_day = False\n    same_month = False\n    same_year = False\n\n    if start_date and end_date:\n        if start_date.strftime('%Y') == end_date.strftime('%Y'):\n            same_year = True\n            if start_date.strftime('%m%Y') == end_date.strftime('%m%Y'):\n                same_month = True\n                if start_date.strftime('%d%m%Y') == end_date.strftime('%d%m%Y'):\n                    same_day = True\n\n    start_str = ''\n    end_str = ''\n    output = ''\n\n    # Make some basic start and end strings, which we might use...\n\n    if start_date:\n        if start_gran == 3:\n            start_str = start_date.strftime(full_format)\n        elif start_gran == 4:\n            start_str = start_date.strftime(month_year_format)\n        else:\n            start_str = start_date.strftime(year_format)\n\n    if end_date:\n        if end_gran == 3:\n            end_str = end_date.strftime(full_format)\n        elif end_gran == 4:\n            end_str = end_date.strftime(month_year_format)\n        else:\n            end_str = end_date.strftime(year_format)\n\n    # Now make the final strings we'll return:\n\n    if start_date and end_date:\n\n        # A default which will be overridden in many cases. This covers:\n        # 1 February 2017 to 3 March 2018\n        # 1 February 2017 to March 2018\n        # 1 February 2017 to 2018\n        # February 2017 to 3 March 2018\n        # February 2017 to March 2018\n        # February 2017 to 2018\n        # 2017 to 3 March 2018\n        # 2017 to March 2018\n        # 2017 to 2018\n        output = period_format_long.format(start_str, end_str)\n\n        if (start_gran == 4 or end_gran == 4) and same_month:\n            # Only have enough to output 'February 2017'.\n            output = start_str\n\n        elif (start_gran == 6 or end_gran == 6) and same_year:\n            # Only have enough to output '2017'.\n            output = start_str\n\n        elif start_gran == 3:\n            if end_gran == 3:\n                if same_day:\n                    # 1 February 2017\n                    output = start_str\n\n                elif same_month:\n                    # 1\u20136 February 2017\n                    output = period_format_short.format(\n                                start_date.strftime(day_format),\n                                end_str)\n                elif same_year:\n                    # 1 February to 3 March 2017\n                    output = period_format_long.format(\n                                        start_date.strftime(day_month_format),\n                                        end_str)\n            elif end_gran == 4:\n                if same_year:\n                    # 1 February to March 2017\n                    output = period_format_long.format(\n                                        start_date.strftime(day_month_format),\n                                        end_str)\n        elif start_gran == 4:\n            if end_gran == 3:\n                if same_year:\n                    # February to 3 March 2017\n                    output = period_format_long.format(\n                                            start_date.strftime(month_format),\n                                            end_str)\n            elif end_gran == 4:\n                if same_year:\n                    # February to March 2017\n                    output = period_format_long.format(\n                                            start_date.strftime(month_format),\n                                            end_str)\n    elif end_date:\n        # Only an end_date.\n        if end_gran == 3:\n            # Finished on 1 February 2017\n            output = \"Finished on {}\".format(end_str)\n        else:\n            # Finished in February 2017\n            # Finished in 2017\n            output = \"Finished in {}\".format(end_str)\n\n    else:\n        # No end_date: the reading has started, but not ended.\n        if start_gran == 3:\n            # Started on 1 February 2017\n            output = \"Started on {}\".format(start_str)\n\n        else:\n            # Started in February 2017\n            # Started in 2017\n            output = \"Started in {}\".format(start_str)\n\n    return format_html(output)", "response": "Given a Reading returns a HTML string representing that period."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nchanges Events with kind movie to cinema and Events with kind play to theatre.", "response": "def forwards(apps, schema_editor):\n    \"\"\"\n    Change Events with kind 'movie' to 'cinema'\n    and Events with kind 'play' to 'theatre'.\n\n    Purely for more consistency.\n    \"\"\"\n    Event = apps.get_model('spectator_events', 'Event')\n\n    for ev in Event.objects.filter(kind='movie'):\n        ev.kind = 'cinema'\n        ev.save()\n\n    for ev in Event.objects.filter(kind='play'):\n        ev.kind = 'theatre'\n        ev.save()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget the environment variable or return exception.", "response": "def get_env_variable(var_name, default=None):\n    \"\"\"Get the environment variable or return exception.\"\"\"\n    try:\n        return os.environ[var_name]\n    except KeyError:\n        if default is None:\n            error_msg = \"Set the %s environment variable\" % var_name\n            raise ImproperlyConfigured(error_msg)\n        else:\n            return default"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef generate_slug(value):\n    alphabet = app_settings.SLUG_ALPHABET\n    salt = app_settings.SLUG_SALT\n\n    hashids = Hashids(alphabet=alphabet, salt=salt, min_length=5)\n\n    return hashids.encode(value)", "response": "Generates a slug using a Hashid of value."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nadd new Exhibition Works to the Event and Exhibition.", "response": "def forwards(apps, schema_editor):\n    \"\"\"\n    Having added the new 'exhibition' Work type, we're going to assume that\n    every Event of type 'museum' should actually have one Exhibition attached.\n\n    So, we'll add one, with the same title as the Event.\n    And we'll move all Creators from the Event to the Exhibition.\n    \"\"\"\n    Event = apps.get_model('spectator_events', 'Event')\n    Work = apps.get_model('spectator_events', 'Work')\n    WorkRole = apps.get_model('spectator_events', 'WorkRole')\n    WorkSelection = apps.get_model('spectator_events', 'WorkSelection')\n\n    for event in Event.objects.filter(kind='museum'):\n\n        # Create a new Work based on this Event's details.\n\n        work = Work.objects.create(\n            kind='exhibition',\n            title=event.title,\n            title_sort=event.title_sort\n        )\n        # This doesn't generate the slug field automatically because Django.\n        # So we'll have to do it manually. Graarhhh.\n        work.slug = generate_slug(work.pk)\n        work.save()\n\n        # Associate the new Work with the Event.\n        WorkSelection.objects.create(\n            event=event,\n            work=work\n        )\n\n        # Associate any Creators on the Event with the new Work.\n        for role in event.roles.all():\n            WorkRole.objects.create(\n                creator=role.creator,\n                work=work,\n                role_name=role.role_name,\n                role_order=role.role_order\n            )\n\n            # Remove Creators from the Event.\n            role.delete()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef by_publications(self):\n        if not spectator_apps.is_enabled('reading'):\n            raise ImproperlyConfigured(\"To use the CreatorManager.by_publications() method, 'spectator.reading' must by in INSTALLED_APPS.\")\n\n        qs = self.get_queryset()\n\n        qs = qs.exclude(publications__reading__isnull=True) \\\n                    .annotate(num_publications=Count('publications')) \\\n                    .order_by('-num_publications', 'name_sort')\n\n        return qs", "response": "Returns a QuerySet of Creators who have been most - read ordered by number of read\n        publications."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a QuerySet of Creators who have been most - read ordered by number of readings.", "response": "def by_readings(self, role_names=['', 'Author']):\n        \"\"\"\n        The Creators who have been most-read, ordered by number of readings.\n\n        By default it will only include Creators whose role was left empty,\n        or is 'Author'.\n\n        Each Creator will have a `num_readings` attribute.\n        \"\"\"\n        if not spectator_apps.is_enabled('reading'):\n            raise ImproperlyConfigured(\"To use the CreatorManager.by_readings() method, 'spectator.reading' must by in INSTALLED_APPS.\")\n\n        qs = self.get_queryset()\n\n        qs = qs.filter(publication_roles__role_name__in=role_names) \\\n                .exclude(publications__reading__isnull=True) \\\n                .annotate(num_readings=Count('publications__reading')) \\\n                .order_by('-num_readings', 'name_sort')\n\n        return qs"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef by_events(self, kind=None):\n        if not spectator_apps.is_enabled('events'):\n            raise ImproperlyConfigured(\"To use the CreatorManager.by_events() method, 'spectator.events' must by in INSTALLED_APPS.\")\n\n        qs = self.get_queryset()\n\n        if kind is not None:\n            qs = qs.filter(events__kind=kind)\n\n        qs = qs.annotate(num_events=Count('events', distinct=True)) \\\n                .order_by('-num_events', 'name_sort')\n\n        return qs", "response": "Returns a QuerySet of Creators involved in most Events."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a QuerySet of Creators involved in the most Works.", "response": "def by_works(self, kind=None, role_name=None):\n        \"\"\"\n        Get the Creators involved in the most Works.\n\n        kind - If supplied, only Works with that `kind` value will be counted.\n        role_name - If supplied, only Works on which the role is that will be counted.\n\n        e.g. To get all 'movie' Works on which the Creators had the role 'Director':\n\n            Creator.objects.by_works(kind='movie', role_name='Director')\n        \"\"\"\n        if not spectator_apps.is_enabled('events'):\n            raise ImproperlyConfigured(\"To use the CreatorManager.by_works() method, 'spectator.events' must by in INSTALLED_APPS.\")\n\n        qs = self.get_queryset()\n\n        filter_kwargs = {}\n\n        if kind is not None:\n            filter_kwargs['works__kind'] = kind\n\n        if role_name is not None:\n            filter_kwargs['work_roles__role_name'] = role_name\n\n        if filter_kwargs:\n            qs = qs.filter(**filter_kwargs)\n\n        qs = qs.annotate(num_works=Count('works', distinct=True)) \\\n                .order_by('-num_works', 'name_sort')\n\n        return qs"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef index():\n    page = request.values.get('page', 1, type=int)\n    size = request.values.get('size', 2, type=int)\n    search = ExampleSearch()[(page - 1) * size:page * size]\n    if 'q' in request.values:\n        search = search.query(QueryString(query=request.values.get('q')))\n\n    search = search.sort(\n        request.values.get('sort', 'title')\n    )\n    search = ExampleSearch.faceted_search(search=search)\n    results = search.execute().to_dict()\n    return jsonify({'hits': results.get('hits')})", "response": "Query Elasticsearch using Invenio query syntax."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef clean_options(self,\n                      using_keytab=False, principal=None,\n                      keytab_file=None, ccache_file=None,\n                      password=None):\n        \"\"\"Clean argument to related object\n\n        :param bool using_keytab: refer to ``krbContext.__init__``.\n        :param str principal: refer to ``krbContext.__init__``.\n        :param str keytab_file: refer to ``krbContext.__init__``.\n        :param str ccache_file: refer to ``krbContext.__init__``.\n        :param str password: refer to ``krbContext.__init__``.\n\n        :return: a mapping containing cleaned names and values, which are used\n            internally.\n        :rtype: dict\n        :raises ValueError: principal is missing or given keytab file does not\n            exist, when initialize from a keytab.\n        \"\"\"\n        cleaned = {}\n\n        if using_keytab:\n            if principal is None:\n                raise ValueError('Principal is required when using key table.')\n            princ_name = gssapi.names.Name(\n                principal, gssapi.names.NameType.kerberos_principal)\n\n            if keytab_file is None:\n                cleaned['keytab'] = DEFAULT_KEYTAB\n            elif not os.path.exists(keytab_file):\n                raise ValueError(\n                    'Keytab file {0} does not exist.'.format(keytab_file))\n            else:\n                cleaned['keytab'] = keytab_file\n        else:\n            if principal is None:\n                principal = get_login()\n            princ_name = gssapi.names.Name(principal,\n                                           gssapi.names.NameType.user)\n\n        cleaned['using_keytab'] = using_keytab\n        cleaned['principal'] = princ_name\n        cleaned['ccache'] = ccache_file or DEFAULT_CCACHE\n        cleaned['password'] = password\n\n        return cleaned", "response": "Clean options for related object."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ninitialize credential cache with keytab", "response": "def init_with_keytab(self):\n        \"\"\"Initialize credential cache with keytab\"\"\"\n        creds_opts = {\n            'usage': 'initiate',\n            'name': self._cleaned_options['principal'],\n        }\n\n        store = {}\n        if self._cleaned_options['keytab'] != DEFAULT_KEYTAB:\n            store['client_keytab'] = self._cleaned_options['keytab']\n        if self._cleaned_options['ccache'] != DEFAULT_CCACHE:\n            store['ccache'] = self._cleaned_options['ccache']\n        if store:\n            creds_opts['store'] = store\n\n        creds = gssapi.creds.Credentials(**creds_opts)\n        try:\n            creds.lifetime\n        except gssapi.exceptions.ExpiredCredentialsError:\n            new_creds_opts = copy.deepcopy(creds_opts)\n            # Get new credential and put it into a temporary ccache\n            if 'store' in new_creds_opts:\n                new_creds_opts['store']['ccache'] = _get_temp_ccache()\n            else:\n                new_creds_opts['store'] = {'ccache': _get_temp_ccache()}\n            creds = gssapi.creds.Credentials(**new_creds_opts)\n            # Then, store new credential back to original specified ccache,\n            # whatever a given ccache file or the default one.\n            _store = None\n            # If default cccache is used, no need to specify ccache in store\n            # parameter passed to ``creds.store``.\n            if self._cleaned_options['ccache'] != DEFAULT_CCACHE:\n                _store = {'ccache': store['ccache']}\n            creds.store(usage='initiate', store=_store, overwrite=True)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ninitializes credential cache with password from command line or pass it to application Kerberos authentication context.", "response": "def init_with_password(self):\n        \"\"\"Initialize credential cache with password\n\n        **Causion:** once you enter password from command line, or pass it to\n        API directly, the given password is not encrypted always. Although\n        getting credential with password works, from security point of view, it\n        is strongly recommended **NOT** use it in any formal production\n        environment. If you need to initialize credential in an application to\n        application Kerberos authentication context, keytab has to be used.\n\n        :raises IOError: when trying to prompt to input password from command\n            line but no attry is available.\n        \"\"\"\n        creds_opts = {\n            'usage': 'initiate',\n            'name': self._cleaned_options['principal'],\n        }\n        if self._cleaned_options['ccache'] != DEFAULT_CCACHE:\n            creds_opts['store'] = {'ccache': self._cleaned_options['ccache']}\n\n        cred = gssapi.creds.Credentials(**creds_opts)\n        try:\n            cred.lifetime\n        except gssapi.exceptions.ExpiredCredentialsError:\n            password = self._cleaned_options['password']\n\n            if not password:\n                if not sys.stdin.isatty():\n                    raise IOError(\n                        'krbContext is not running from a terminal. So, you '\n                        'need to run kinit with your principal manually before'\n                        ' anything goes.')\n\n                # If there is no password specified via API call, prompt to\n                # enter one in order to continue to get credential. BUT, in\n                # some cases, blocking program and waiting for input of\n                # password is really bad, which may be only suitable for some\n                # simple use cases, for example, writing some scripts to test\n                # something that need Kerberos authentication. Anyway, whether\n                # it is really to enter a password from command line, it\n                # depends on concrete use cases totally.\n                password = getpass.getpass()\n\n            cred = gssapi.raw.acquire_cred_with_password(\n                self._cleaned_options['principal'], password)\n\n            ccache = self._cleaned_options['ccache']\n            if ccache == DEFAULT_CCACHE:\n                gssapi.raw.store_cred(cred.creds,\n                                      usage='initiate',\n                                      overwrite=True)\n            else:\n                gssapi.raw.store_cred_into({'ccache': ccache},\n                                           cred.creds,\n                                           usage='initiate',\n                                           overwrite=True)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _prepare_context(self):\n        ccache = self._cleaned_options['ccache']\n\n        # Whatever there is KRB5CCNAME was set in current process,\n        # original_krb5ccname will contain current value even if None if\n        # that variable wasn't set, and when leave krbcontext, it can be\n        # handled properly.\n        self._original_krb5ccname = os.environ.get(ENV_KRB5CCNAME)\n\n        if ccache == DEFAULT_CCACHE:\n            # If user wants to use default ccache, existing KRB5CCNAME in\n            # current environment variable should be removed.\n            if self._original_krb5ccname:\n                del os.environ[ENV_KRB5CCNAME]\n        else:\n            # When not using default ccache to initialize new credential, let\n            # us point to the given ccache by KRB5CCNAME.\n            os.environ[ENV_KRB5CCNAME] = ccache\n\n        if self._cleaned_options['using_keytab']:\n            self.init_with_keytab()\n        else:\n            self.init_with_password()", "response": "Prepare context for Kerberos context."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngenerating a dictionary with template names and file paths.", "response": "def templates(self):\n        \"\"\"Generate a dictionary with template names and file paths.\"\"\"\n        templates = {}\n        result = []\n        if self.entry_point_group_templates:\n            result = self.load_entry_point_group_templates(\n                self.entry_point_group_templates) or []\n\n        for template in result:\n            for name, path in template.items():\n                templates[name] = path\n\n        return templates"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nregister mappings from a given package under given alias.", "response": "def register_mappings(self, alias, package_name):\n        \"\"\"Register mappings from a package under given alias.\n\n        :param alias: The alias.\n        :param package_name: The package name.\n        \"\"\"\n        # For backwards compatibility, we also allow for ES2 mappings to be\n        # placed at the root level of the specified package path, and not in\n        # the `<package-path>/v2` directory.\n        if ES_VERSION[0] == 2:\n            try:\n                resource_listdir(package_name, 'v2')\n                package_name += '.v2'\n            except (OSError, IOError) as ex:\n                if getattr(ex, 'errno', 0) != errno.ENOENT:\n                    raise\n                warnings.warn(\n                    \"Having mappings in a path which doesn't specify the \"\n                    \"Elasticsearch version is deprecated. Please move your \"\n                    \"mappings to a subfolder named according to the \"\n                    \"Elasticsearch version which your mappings are intended \"\n                    \"for. (e.g. '{}/v2/{}')\".format(\n                        package_name, alias),\n                    PendingDeprecationWarning)\n        else:\n            package_name = '{}.v{}'.format(package_name, ES_VERSION[0])\n\n        def _walk_dir(aliases, *parts):\n            root_name = build_index_name(self.app, *parts)\n            resource_name = os.path.join(*parts)\n\n            if root_name not in aliases:\n                self.number_of_indexes += 1\n\n            data = aliases.get(root_name, {})\n\n            for filename in resource_listdir(package_name, resource_name):\n                index_name = build_index_name(\n                    self.app,\n                    *(parts + (filename, ))\n                )\n                file_path = os.path.join(resource_name, filename)\n\n                if resource_isdir(package_name, file_path):\n                    _walk_dir(data, *(parts + (filename, )))\n                    continue\n\n                ext = os.path.splitext(filename)[1]\n                if ext not in {'.json', }:\n                    continue\n\n                assert index_name not in data, 'Duplicate index'\n                data[index_name] = self.mappings[index_name] = \\\n                    resource_filename(\n                        package_name, os.path.join(resource_name, filename))\n                self.number_of_indexes += 1\n\n            aliases[root_name] = data\n\n        # Start the recursion here:\n        _walk_dir(self.aliases, alias)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef register_templates(self, directory):\n        try:\n            resource_listdir(directory, 'v{}'.format(ES_VERSION[0]))\n            directory = '{}/v{}'.format(directory, ES_VERSION[0])\n        except (OSError, IOError) as ex:\n            if getattr(ex, 'errno', 0) == errno.ENOENT:\n                raise OSError(\n                    \"Please move your templates to a subfolder named \"\n                    \"according to the Elasticsearch version \"\n                    \"which your templates are intended \"\n                    \"for. (e.g. '{}.v{}')\".format(directory,\n                                                  ES_VERSION[0]))\n        result = {}\n        module_name, parts = directory.split('.')[0], directory.split('.')[1:]\n        parts = tuple(parts)\n\n        def _walk_dir(parts):\n            resource_name = os.path.join(*parts)\n\n            for filename in resource_listdir(module_name, resource_name):\n                template_name = build_index_name(\n                    self.app,\n                    *(parts[1:] + (filename, ))\n                )\n                file_path = os.path.join(resource_name, filename)\n\n                if resource_isdir(module_name, file_path):\n                    _walk_dir((parts + (filename, )))\n                    continue\n\n                ext = os.path.splitext(filename)[1]\n                if ext not in {'.json', }:\n                    continue\n\n                result[template_name] = resource_filename(\n                    module_name, os.path.join(resource_name, filename))\n\n        # Start the recursion here:\n        _walk_dir(parts)\n        return result", "response": "Register templates from the provided directory."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef load_entry_point_group_mappings(self, entry_point_group_mappings):\n        for ep in iter_entry_points(group=entry_point_group_mappings):\n            self.register_mappings(ep.name, ep.module_name)", "response": "Load actions from an entry point group."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef load_entry_point_group_templates(self, entry_point_group_templates):\n        result = []\n        for ep in iter_entry_points(group=entry_point_group_templates):\n            with self.app.app_context():\n                for template_dir in ep.load()():\n                    result.append(self.register_templates(template_dir))\n        return result", "response": "Load actions from an entry point group."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef client(self):\n        if self._client is None:\n            self._client = self._client_builder()\n        return self._client", "response": "Return client for current application."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nflushes and refresh one or more indices.", "response": "def flush_and_refresh(self, index):\n        \"\"\"Flush and refresh one or more indices.\n\n        .. warning::\n\n           Do not call this method unless you know what you are doing. This\n           method is only intended to be called during tests.\n        \"\"\"\n        self.client.indices.flush(wait_if_ongoing=True, index=index)\n        self.client.indices.refresh(index=index)\n        self.client.cluster.health(\n            wait_for_status='yellow', request_timeout=30)\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef cluster_version(self):\n        versionstr = self.client.info()['version']['number']\n        return [int(x) for x in versionstr.split('.')]", "response": "Get version of Elasticsearch running on the cluster."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets a filtered list of aliases based on configuration.", "response": "def active_aliases(self):\n        \"\"\"Get a filtered list of aliases based on configuration.\n\n        Returns aliases and their mappings that are defined in the\n        `SEARCH_MAPPINGS` config variable. If the `SEARCH_MAPPINGS` is set to\n        `None` (the default), all aliases are included.\n        \"\"\"\n        whitelisted_aliases = self.app.config.get('SEARCH_MAPPINGS')\n        if whitelisted_aliases is None:\n            return self.aliases\n        else:\n            return {k: v for k, v in self.aliases.items()\n                    if k in whitelisted_aliases}"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nyields tuple with created index name and responses from a client.", "response": "def create(self, ignore=None):\n        \"\"\"Yield tuple with created index name and responses from a client.\"\"\"\n        ignore = ignore or []\n\n        def _create(tree_or_filename, alias=None):\n            \"\"\"Create indices and aliases by walking DFS.\"\"\"\n            # Iterate over aliases:\n            for name, value in tree_or_filename.items():\n                if isinstance(value, dict):\n                    for result in _create(value, alias=name):\n                        yield result\n                else:\n                    with open(value, 'r') as body:\n                        yield name, self.client.indices.create(\n                            index=name,\n                            body=json.load(body),\n                            ignore=ignore,\n                        )\n\n            if alias:\n                yield alias, self.client.indices.put_alias(\n                    index=list(_get_indices(tree_or_filename)),\n                    name=alias,\n                    ignore=ignore,\n                )\n\n        for result in _create(self.active_aliases):\n            yield result"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nyield tuple with registered template and response from client.", "response": "def put_templates(self, ignore=None):\n        \"\"\"Yield tuple with registered template and response from client.\"\"\"\n        ignore = ignore or []\n\n        def _replace_prefix(template_path, body):\n            \"\"\"Replace index prefix in template request body.\"\"\"\n            pattern = '__SEARCH_INDEX_PREFIX__'\n\n            prefix = self.app.config['SEARCH_INDEX_PREFIX'] or ''\n            if prefix:\n                assert pattern in body, \"You are using the prefix `{0}`, \"\n                \"but the template `{1}` does not contain the \"\n                \"pattern `{2}`.\".format(prefix, template_path, pattern)\n\n            return body.replace(pattern, prefix)\n\n        def _put_template(template):\n            \"\"\"Put template in search client.\"\"\"\n            with open(self.templates[template], 'r') as fp:\n                body = fp.read()\n                replaced_body = _replace_prefix(self.templates[template], body)\n                return self.templates[template],\\\n                    current_search_client.indices.put_template(\n                        name=template,\n                        body=json.loads(replaced_body),\n                        ignore=ignore,\n                )\n\n        for template in self.templates:\n            yield _put_template(template)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nyielding tuples with deleted index name and responses from a client.", "response": "def delete(self, ignore=None):\n        \"\"\"Yield tuple with deleted index name and responses from a client.\"\"\"\n        ignore = ignore or []\n\n        def _delete(tree_or_filename, alias=None):\n            \"\"\"Delete indexes and aliases by walking DFS.\"\"\"\n            if alias:\n                yield alias, self.client.indices.delete_alias(\n                    index=list(_get_indices(tree_or_filename)),\n                    name=alias,\n                    ignore=ignore,\n                )\n\n            # Iterate over aliases:\n            for name, value in tree_or_filename.items():\n                if isinstance(value, dict):\n                    for result in _delete(value, alias=name):\n                        yield result\n                else:\n                    yield name, self.client.indices.delete(\n                        index=name,\n                        ignore=ignore,\n                    )\n\n        for result in _delete(self.active_aliases):\n            yield result"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef init_app(self, app,\n                 entry_point_group_mappings='invenio_search.mappings',\n                 entry_point_group_templates='invenio_search.templates',\n                 **kwargs):\n        \"\"\"Flask application initialization.\n\n        :param app: An instance of :class:`~flask.app.Flask`.\n        \"\"\"\n        self.init_config(app)\n\n        app.cli.add_command(index_cmd)\n\n        state = _SearchState(\n            app,\n            entry_point_group_mappings=entry_point_group_mappings,\n            entry_point_group_templates=entry_point_group_templates,\n            **kwargs\n        )\n        self._state = app.extensions['invenio-search'] = state", "response": "Initialize the application with the given entry_point_group_mappings entry_point_group_templates and kwargs."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef main():\n    try:\n        opts, args = getopt.getopt(sys.argv[1:], \"h:v\", [\"help\", \"nack=\",\n                                   \"servers=\", \"queues=\"])\n    except getopt.GetoptError as err:\n        print str(err)\n        usage()\n        sys.exit()\n\n    # defaults\n    nack = 0.0\n    verbose = False\n    servers = \"localhost:7712,localhost:7711\"\n    queues = \"test\"\n\n    for o, a in opts:\n        if o == \"-v\":\n            verbose = True\n        elif o in (\"-h\", \"--help\"):\n            usage()\n            sys.exit()\n        elif o in (\"--nack\"):\n            nack = float(a)\n        elif o in (\"--servers\"):\n            servers = a\n        elif o in (\"--queues\"):\n            queues = a\n        else:\n            assert False, \"unhandled option\"\n\n    # prepare servers and queus for pydisque\n    servers = servers.split(\",\")\n    queues = queues.split(\",\")\n\n    c = Client(servers)\n    c.connect()\n\n    while True:\n        jobs = c.get_job(queues)\n        for queue_name, job_id, job in jobs:\n            rnd = random.random()\n\n            # as this is a test processor, we don't do any validation on\n            # the actual job body, so lets just pay attention to id's\n\n            if rnd >= nack:\n                print \">>> received job:\", job_id\n                c.ack_job(job_id)\n            else:\n                print \">>> bouncing job:\", job_id\n                c.nack_job(job_id)", "response": "Start the poor consumer."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef connect(self):\n        self.connected_node = None\n\n        for i, node in self.nodes.items():\n            host, port = i.split(':')\n            port = int(port)\n            redis_client = redis.Redis(host, port, **self.client_kw_args)\n\n            try:\n                ret = redis_client.execute_command('HELLO')\n                format_version, node_id = ret[0], ret[1]\n                others = ret[2:]\n                self.nodes[i] = Node(node_id, host, port, redis_client)\n                self.connected_node = self.nodes[i]\n            except redis.exceptions.ConnectionError:\n                pass\n\n        if not self.connected_node:\n            raise ConnectionError('couldnt connect to any nodes')\n        logger.info(\"connected to node %s\" % self.connected_node)", "response": "Connect to one of the Disque nodes."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nexecute a command on the connected server.", "response": "def execute_command(self, *args, **kwargs):\n        \"\"\"Execute a command on the connected server.\"\"\"\n        try:\n            return self.get_connection().execute_command(*args, **kwargs)\n        except ConnectionError as e:\n            logger.warn('trying to reconnect')\n            self.connect()\n            logger.warn('connected')\n            raise"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef add_job(self, queue_name, job, timeout=200, replicate=None, delay=None,\n                retry=None, ttl=None, maxlen=None, asynchronous=None):\n        \"\"\"\n        Add a job to a queue.\n\n        ADDJOB queue_name job <ms-timeout> [REPLICATE <count>] [DELAY <sec>]\n            [RETRY <sec>] [TTL <sec>] [MAXLEN <count>] [ASYNC]\n\n        :param queue_name: is the name of the queue, any string, basically.\n        :param job: is a string representing the job.\n        :param timeout: is the command timeout in milliseconds.\n        :param replicate: count is the number of nodes the job should be\n            replicated to.\n        :param delay: sec is the number of seconds that should elapse\n            before the job is queued by any server.\n        :param retry: sec period after which, if no ACK is received, the\n            job is put again into the queue for delivery. If RETRY is 0,\n            the job has an at-most-once delivery semantics.\n        :param ttl: sec is the max job life in seconds. After this time,\n            the job is deleted even if it was not successfully delivered.\n        :param maxlen: count specifies that if there are already count\n            messages queued for the specified queue name, the message is\n            refused and an error reported to the client.\n        :param asynchronous: asks the server to let the command return ASAP and\n            replicate the job to other nodes in the background. The job\n            gets queued ASAP, while normally the job is put into the queue\n            only when the client gets a positive reply. Changing the name of this\n            argument as async is reserved keyword in python 3.7\n\n        :returns: job_id\n        \"\"\"\n        command = ['ADDJOB', queue_name, job, timeout]\n\n        if replicate:\n            command += ['REPLICATE', replicate]\n        if delay:\n            command += ['DELAY', delay]\n        if retry is not None:\n            command += ['RETRY', retry]\n        if ttl:\n            command += ['TTL', ttl]\n        if maxlen:\n            command += ['MAXLEN', maxlen]\n        if asynchronous:\n            command += ['ASYNC']\n\n        # TODO(canardleteer): we need to handle \"-PAUSE\" messages more\n        # appropriately, for now it's up to the person using the library\n        # to handle a generic ResponseError on their own.\n        logger.debug(\"sending job - %s\", command)\n        job_id = self.execute_command(*command)\n        logger.debug(\"sent job - %s\", command)\n        logger.debug(\"job_id: %s \" % job_id)\n        return job_id", "response": "This function adds a job to a queue."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_job(self, queues, timeout=None, count=None, nohang=False, withcounters=False):\n        assert queues\n\n        command = ['GETJOB']\n        if nohang:\n            command += ['NOHANG']\n        if timeout:\n            command += ['TIMEOUT', timeout]\n        if count:\n            command += ['COUNT', count]\n        if withcounters:\n            command += ['WITHCOUNTERS']\n\n        command += ['FROM'] + queues\n        results = self.execute_command(*command)\n        if not results:\n            return []\n\n        if withcounters:\n            return [(job_id, queue_name, job, nacks, additional_deliveries) for\n                    job_id, queue_name, job, _, nacks, _, additional_deliveries in results]\n        else:\n            return [(job_id, queue_name, job) for\n                    job_id, queue_name, job in results]", "response": "Get some number of jobs from specified queues."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the status of a queue.", "response": "def qstat(self, queue_name, return_dict=False):\n        \"\"\"\n        Return the status of the queue (currently unimplemented).\n\n        Future support / testing of QSTAT support in Disque\n\n        QSTAT <qname>\n\n        Return produced ... consumed ... idle ... sources [...] ctime ...\n        \"\"\"\n        rtn = self.execute_command('QSTAT', queue_name)\n\n        if return_dict:\n            grouped = self._grouper(rtn, 2)\n            rtn = dict((a, b) for a, b in grouped)\n\n        return rtn"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ndescribe the job. :param job_id:", "response": "def show(self, job_id, return_dict=False):\n        \"\"\"\n        Describe the job.\n\n        :param job_id:\n\n        \"\"\"\n        rtn = self.execute_command('SHOW', job_id)\n\n        if return_dict:\n            grouped = self._grouper(rtn, 2)\n            rtn = dict((a, b) for a, b in grouped)\n\n        return rtn"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\npause a queue in the canardleteer cluster.", "response": "def pause(self, queue_name, kw_in=None, kw_out=None, kw_all=None,\n              kw_none=None, kw_state=None, kw_bcast=None):\n        \"\"\"\n        Pause a queue.\n\n        Unfortunately, the PAUSE keywords are mostly reserved words in Python,\n        so I've been a little creative in the function variable names. Open\n        to suggestions to change it (canardleteer)\n\n        :param queue_name: The job queue we are modifying.\n        :param kw_in: pause the queue in input.\n        :param kw_out: pause the queue in output.\n        :param kw_all: pause the queue in input and output (same as specifying\n                       both the in and out options).\n        :param kw_none: clear the paused state in input and output.\n        :param kw_state: just report the current queue state.\n        :param kw_bcast: send a PAUSE command to all the reachable nodes of\n                         the cluster to set the same queue in the other nodes\n                         to the same state.\n        \"\"\"\n        command = [\"PAUSE\", queue_name]\n        if kw_in:\n            command += [\"in\"]\n        if kw_out:\n            command += [\"out\"]\n        if kw_all:\n            command += [\"all\"]\n        if kw_none:\n            command += [\"none\"]\n        if kw_state:\n            command += [\"state\"]\n        if kw_bcast:\n            command += [\"bcast\"]\n\n        return self.execute_command(*command)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef qscan(self, cursor=0, count=None, busyloop=None, minlen=None,\n              maxlen=None, importrate=None):\n        \"\"\"\n        Iterate all the existing queues in the local node.\n\n        :param count: An hint about how much work to do per iteration.\n        :param busyloop: Block and return all the elements in a busy loop.\n        :param minlen: Don't return elements with less than count jobs queued.\n        :param maxlen: Don't return elements with more than count jobs queued.\n        :param importrate: Only return elements with an job import rate\n                        (from other nodes) >= rate.\n        \"\"\"\n        command = [\"QSCAN\", cursor]\n        if count:\n            command += [\"COUNT\", count]\n        if busyloop:\n            command += [\"BUSYLOOP\"]\n        if minlen:\n            command += [\"MINLEN\", minlen]\n        if maxlen:\n            command += [\"MAXLEN\", maxlen]\n        if importrate:\n            command += [\"IMPORTRATE\", importrate]\n\n        return self.execute_command(*command)", "response": "Iterate all the existing queues in the local node."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\niterates all the existing jobs in the local node.", "response": "def jscan(self, cursor=0, count=None, busyloop=None, queue=None,\n              state=None, reply=None):\n        \"\"\"Iterate all the existing jobs in the local node.\n\n        :param count: An hint about how much work to do per iteration.\n        :param busyloop: Block and return all the elements in a busy loop.\n        :param queue: Return only jobs in the specified queue.\n        :param state: Must be a list - Return jobs in the specified state.\n            Can be used multiple times for a logic OR.\n        :param reply: None or string {\"all\", \"id\"} - Job reply type. Type can\n            be all or id. Default is to report just the job ID. If all is\n            specified the full job state is returned like for the SHOW command.\n        \"\"\"\n        command = [\"JSCAN\", cursor]\n        if count:\n            command += [\"COUNT\", count]\n        if busyloop:\n            command += [\"BUSYLOOP\"]\n        if queue:\n            command += [\"QUEUE\", queue]\n        if type(state) is list:\n            for s in state:\n                command += [\"STATE\", s]\n        if reply:\n            command += [\"REPLY\", reply]\n\n        return self.execute_command(*command)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nbuilds an index name from parts.", "response": "def build_index_name(app, *parts):\n    \"\"\"Build an index name from parts.\n\n    :param parts: Parts that should be combined to make an index name.\n    \"\"\"\n    base_index = os.path.splitext(\n        '-'.join([part for part in parts if part])\n    )[0]\n\n    return prefix_index(app=app, index=base_index)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget index and doc_type given a schema URL.", "response": "def schema_to_index(schema, index_names=None):\n    \"\"\"Get index/doc_type given a schema URL.\n\n    :param schema: The schema name\n    :param index_names: A list of index name.\n    :returns: A tuple containing (index, doc_type).\n    \"\"\"\n    parts = schema.split('/')\n    doc_type = os.path.splitext(parts[-1])\n\n    if doc_type[1] not in {'.json', }:\n        return (None, None)\n\n    if index_names is None:\n        return (build_index_name(current_app, *parts), doc_type[0])\n\n    for start in range(len(parts)):\n        index_name = build_index_name(current_app, *parts[start:])\n        if index_name in index_names:\n            return (index_name, doc_type[0])\n\n    return (None, None)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef es_version_check(f):\n    @wraps(f)\n    def inner(*args, **kwargs):\n        cluster_ver = current_search.cluster_version[0]\n        client_ver = ES_VERSION[0]\n        if cluster_ver != client_ver:\n            raise click.ClickException(\n                'Elasticsearch version mismatch. Invenio was installed with '\n                'Elasticsearch v{client_ver}.x support, but the cluster runs '\n                'Elasticsearch v{cluster_ver}.x.'.format(\n                    client_ver=client_ver,\n                    cluster_ver=cluster_ver,\n                ))\n        return f(*args, **kwargs)\n    return inner", "response": "Decorator to check Elasticsearch version."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ninitializing registered aliases and mappings.", "response": "def init(force):\n    \"\"\"Initialize registered aliases and mappings.\"\"\"\n    click.secho('Creating indexes...', fg='green', bold=True, file=sys.stderr)\n    with click.progressbar(\n            current_search.create(ignore=[400] if force else None),\n            length=current_search.number_of_indexes) as bar:\n        for name, response in bar:\n            bar.label = name\n    click.secho('Putting templates...', fg='green', bold=True, file=sys.stderr)\n    with click.progressbar(\n            current_search.put_templates(ignore=[400] if force else None),\n            length=len(current_search.templates.keys())) as bar:\n        for response in bar:\n            bar.label = response"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating a new index.", "response": "def create(index_name, body, force, verbose):\n    \"\"\"Create a new index.\"\"\"\n    result = current_search_client.indices.create(\n        index=index_name,\n        body=json.load(body),\n        ignore=[400] if force else None,\n    )\n    if verbose:\n        click.echo(json.dumps(result))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nlist all entries in the tree.", "response": "def list_cmd(only_active, only_aliases, verbose):\n    \"\"\"List indices.\"\"\"\n    def _tree_print(d, rec_list=None, verbose=False, indent=2):\n        # Note that on every recursion rec_list is copied,\n        # which might not be very effective for very deep dictionaries.\n        rec_list = rec_list or []\n        for idx, key in enumerate(sorted(d)):\n            line = (['\u2502' + ' ' * indent\n                     if i == 1 else ' ' * (indent+1) for i in rec_list])\n            line.append('\u2514\u2500\u2500' if len(d)-1 == idx else '\u251c\u2500\u2500')\n            click.echo(''.join(line), nl=False)\n            if isinstance(d[key], dict):\n                click.echo(key)\n                new_rec_list = rec_list + [0 if len(d)-1 == idx else 1]\n                _tree_print(d[key], new_rec_list, verbose)\n            else:\n                leaf_txt = '{} -> {}'.format(key, d[key]) if verbose else key\n                click.echo(leaf_txt)\n\n    aliases = (current_search.active_aliases\n               if only_active else current_search.aliases)\n    active_aliases = current_search.active_aliases\n\n    if only_aliases:\n        click.echo(json.dumps(list((aliases.keys())), indent=4))\n    else:\n        # Mark active indices for printout\n        aliases = {(k + (' *' if k in active_aliases else '')): v\n                   for k, v in aliases.items()}\n        click.echo(_tree_print(aliases, verbose=verbose))"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ndeletes an index by its name.", "response": "def delete(index_name, force, verbose):\n    \"\"\"Delete index by its name.\"\"\"\n    result = current_search_client.indices.delete(\n        index=index_name,\n        ignore=[400, 404] if force else None,\n    )\n    if verbose:\n        click.echo(json.dumps(result))"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns records by their identifiers.", "response": "def get_records(self, ids):\n        \"\"\"Return records by their identifiers.\n\n        :param ids: A list of record identifier.\n        :returns: A list of records.\n        \"\"\"\n        return self.query(Ids(values=[str(id_) for id_ in ids]))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef faceted_search(cls, query=None, filters=None, search=None):\n        search_ = search or cls()\n\n        class RecordsFacetedSearch(FacetedSearch):\n            \"\"\"Pass defaults from ``cls.Meta`` object.\"\"\"\n\n            index = prefix_index(app=current_app, index=search_._index[0])\n            doc_types = getattr(search_.Meta, 'doc_types', ['_all'])\n            fields = getattr(search_.Meta, 'fields', ('*', ))\n            facets = getattr(search_.Meta, 'facets', {})\n\n            def search(self):\n                \"\"\"Use ``search`` or ``cls()`` instead of default Search.\"\"\"\n                # Later versions of `elasticsearch-dsl` (>=5.1.0) changed the\n                # Elasticsearch FacetedResponse class constructor signature.\n\n                if ES_VERSION[0] > 2:\n                    return search_.response_class(FacetedResponse)\n                return search_.response_class(partial(FacetedResponse, self))\n\n        return RecordsFacetedSearch(query=query, filters=filters or {})", "response": "Return a new instance of the faceted search class with defaults set."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef with_preference_param(self):\n        user_hash = self._get_user_hash()\n        if user_hash:\n            return self.params(preference=user_hash)\n        return self", "response": "Add the preference param to the ES request and return a new Search object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nretrieving the request s User - Agent if available.", "response": "def _get_user_agent(self):\n        \"\"\"Retrieve the request's User-Agent, if available.\n\n        Taken from Flask Login utils.py.\n        \"\"\"\n        user_agent = request.headers.get('User-Agent')\n        if user_agent:\n            user_agent = user_agent.encode('utf-8')\n        return user_agent or ''"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncalculating a digest based on request s User - Agent and IP address.", "response": "def _get_user_hash(self):\n        \"\"\"Calculate a digest based on request's User-Agent and IP address.\"\"\"\n        if request:\n            user_hash = '{ip}-{ua}'.format(ip=request.remote_addr,\n                                           ua=self._get_user_agent())\n            alg = hashlib.md5()\n            alg.update(user_hash.encode('utf8'))\n            return alg.hexdigest()\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nbeautifying JSON string or file.", "response": "def beautify(filename=None, json_str=None):\n    \"\"\"Beautify JSON string or file.\n\n    Keyword arguments:\n    :param filename: use its contents as json string instead of\n    json_str param.\n    :param json_str: json string to be beautified.\n    \"\"\"\n    if filename is not None:\n        with open(filename) as json_file:\n            json_str = json.load(json_file)\n\n    return  json.dumps(json_str, indent=4, sort_keys=True)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef replace(pretty, old_str, new_str):\n    out_str = ''\n    line_number = 1\n    changes = 0\n    for line in pretty.splitlines(keepends=True):\n        new_line = line.replace(old_str, new_str)\n        if line.find(old_str) != -1:\n            logging.debug('%s', line_number)\n            logging.debug('< %s', line)\n            logging.debug('> %s', new_line)\n            changes += 1\n        out_str += new_line\n        line_number += 1\n\n    logging.info('Total changes(%s): %s', old_str, changes)\n    return out_str", "response": "Replace strings giving some info on where\n    the replacement was done\n   "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nwait for and then return a connected socket.", "response": "def receive_connection():\n    \"\"\"Wait for and then return a connected socket..\n\n    Opens a TCP connection on port 8080, and waits for a single client.\n\n    \"\"\"\n    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n    server.bind((\"localhost\", 8080))\n    server.listen(1)\n    client = server.accept()[0]\n    server.close()\n    return client"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nsend a message to the client and close the connection.", "response": "def send_message(client, message):\n    \"\"\"Send message to client and close the connection.\"\"\"\n    print(message)\n    client.send(\"HTTP/1.1 200 OK\\r\\n\\r\\n{}\".format(message).encode(\"utf-8\"))\n    client.close()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nproviding the program s entry point when directly executed.", "response": "def main():\n    \"\"\"Provide the program's entry point when directly executed.\"\"\"\n    if len(sys.argv) < 2:\n        print(\"Usage: {} SCOPE...\".format(sys.argv[0]))\n        return 1\n\n    authenticator = prawcore.TrustedAuthenticator(\n        prawcore.Requestor(\"prawcore_refresh_token_example\"),\n        os.environ[\"PRAWCORE_CLIENT_ID\"],\n        os.environ[\"PRAWCORE_CLIENT_SECRET\"],\n        os.environ[\"PRAWCORE_REDIRECT_URI\"],\n    )\n\n    state = str(random.randint(0, 65000))\n    url = authenticator.authorize_url(\"permanent\", sys.argv[1:], state)\n    print(url)\n\n    client = receive_connection()\n    data = client.recv(1024).decode(\"utf-8\")\n    param_tokens = data.split(\" \", 2)[1].split(\"?\", 1)[1].split(\"&\")\n    params = {\n        key: value\n        for (key, value) in [token.split(\"=\") for token in param_tokens]\n    }\n\n    if state != params[\"state\"]:\n        send_message(\n            client,\n            \"State mismatch. Expected: {} Received: {}\".format(\n                state, params[\"state\"]\n            ),\n        )\n        return 1\n    elif \"error\" in params:\n        send_message(client, params[\"error\"])\n        return 1\n\n    authorizer = prawcore.Authorizer(authenticator)\n    authorizer.authorize(params[\"code\"])\n\n    send_message(client, \"Refresh token: {}\".format(authorizer.refresh_token))\n    return 0"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nwrap for using the Watcher. watch method.", "response": "def watch(logger_name, level=DEBUG, out=stdout):\n    \"\"\" Quick wrapper for using the Watcher.\n\n    :param logger_name: name of logger to watch\n    :param level: minimum log level to show (default INFO)\n    :param out: where to send output (default stdout)\n    :return: Watcher instance\n    \"\"\"\n    watcher = Watcher(logger_name)\n    watcher.watch(level, out)\n    return watcher"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_user_agent():\n    from sys import platform, version_info\n    template = \"neobolt/{} Python/{}.{}.{}-{}-{} ({})\"\n    fields = (version,) + tuple(version_info) + (platform,)\n    return template.format(*fields)", "response": "Obtain the default user agent string sent to the server after\n    a successful handshake."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef import_best(c_module, py_module):\n    from importlib import import_module\n    from os import getenv\n    pure_python = getenv(\"PURE_PYTHON\", \"\")\n    if pure_python:\n        return import_module(py_module)\n    else:\n        try:\n            return import_module(c_module)\n        except ImportError:\n            return import_module(py_module)", "response": "Import the best available module with C preferred to pure Python."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nconverting PackStream values into native values.", "response": "def hydrate(self, values):\n        \"\"\" Convert PackStream values into native values.\n        \"\"\"\n\n        def hydrate_(obj):\n            if isinstance(obj, Structure):\n                try:\n                    f = self.hydration_functions[obj.tag]\n                except KeyError:\n                    # If we don't recognise the structure type, just return it as-is\n                    return obj\n                else:\n                    return f(*map(hydrate_, obj.fields))\n            elif isinstance(obj, list):\n                return list(map(hydrate_, obj))\n            elif isinstance(obj, dict):\n                return {key: hydrate_(value) for key, value in obj.items()}\n            else:\n                return obj\n\n        return tuple(map(hydrate_, values))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef authorize_url(self, duration, scopes, state, implicit=False):\n        if self.redirect_uri is None:\n            raise InvalidInvocation(\"redirect URI not provided\")\n        if implicit and not isinstance(self, UntrustedAuthenticator):\n            raise InvalidInvocation(\n                \"Only UntrustedAuthentictor instances can \"\n                \"use the implicit grant flow.\"\n            )\n        if implicit and duration != \"temporary\":\n            raise InvalidInvocation(\n                \"The implicit grant flow only supports \"\n                \"temporary access tokens.\"\n            )\n\n        params = {\n            \"client_id\": self.client_id,\n            \"duration\": duration,\n            \"redirect_uri\": self.redirect_uri,\n            \"response_type\": \"token\" if implicit else \"code\",\n            \"scope\": \" \".join(scopes),\n            \"state\": state,\n        }\n        url = self._requestor.reddit_url + const.AUTHORIZATION_PATH\n        request = Request(\"GET\", url, params=params)\n        return request.prepare().url", "response": "Returns the URL used out - of - band to grant access to your application."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef revoke_token(self, token, token_type=None):\n        data = {\"token\": token}\n        if token_type is not None:\n            data[\"token_type_hint\"] = token_type\n        url = self._requestor.reddit_url + const.REVOKE_TOKEN_PATH\n        self._post(url, success_status=codes[\"no_content\"], **data)", "response": "Ask Reddit to revoke the provided token."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nrevokes the current authorization.", "response": "def revoke(self):\n        \"\"\"Revoke the current Authorization.\"\"\"\n        if self.access_token is None:\n            raise InvalidInvocation(\"no token available to revoke\")\n\n        self._authenticator.revoke_token(self.access_token, \"access_token\")\n        self._clear_access_token()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef authorize(self, code):\n        if self._authenticator.redirect_uri is None:\n            raise InvalidInvocation(\"redirect URI not provided\")\n        self._request_token(\n            code=code,\n            grant_type=\"authorization_code\",\n            redirect_uri=self._authenticator.redirect_uri,\n        )", "response": "Obtain and set authorization tokens based on code."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nobtains a new access token from the refresh_token.", "response": "def refresh(self):\n        \"\"\"Obtain a new access token from the refresh_token.\"\"\"\n        if self.refresh_token is None:\n            raise InvalidInvocation(\"refresh token not provided\")\n        self._request_token(\n            grant_type=\"refresh_token\", refresh_token=self.refresh_token\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef revoke(self, only_access=False):\n        if only_access or self.refresh_token is None:\n            super(Authorizer, self).revoke()\n        else:\n            self._authenticator.revoke_token(\n                self.refresh_token, \"refresh_token\"\n            )\n            self._clear_access_token()\n            self.refresh_token = None", "response": "Revokes the current authorization."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef refresh(self):\n        grant_type = \"https://oauth.reddit.com/grants/installed_client\"\n        self._request_token(grant_type=grant_type, device_id=self._device_id)", "response": "Obtain a new access token."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef refresh(self):\n        self._request_token(\n            grant_type=\"password\",\n            username=self._username,\n            password=self._password,\n        )", "response": "Obtain a new personal - use script type access token."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nissue the HTTP request capturing any errors that may occur.", "response": "def request(self, *args, **kwargs):\n        \"\"\"Issue the HTTP request capturing any errors that may occur.\"\"\"\n        try:\n            return self._http.request(*args, timeout=TIMEOUT, **kwargs)\n        except Exception as exc:\n            raise RequestException(exc, args, kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _hangul_char_to_jamo(syllable):\n    if is_hangul_char(syllable):\n        rem = ord(syllable) - _JAMO_OFFSET\n        tail = rem % 28\n        vowel = 1 + ((rem - tail) % 588) // 28\n        lead = 1 + rem // 588\n        if tail:\n            return (chr(lead + _JAMO_LEAD_OFFSET),\n                    chr(vowel + _JAMO_VOWEL_OFFSET),\n                    chr(tail + _JAMO_TAIL_OFFSET))\n        else:\n            return (chr(lead + _JAMO_LEAD_OFFSET),\n                    chr(vowel + _JAMO_VOWEL_OFFSET))\n    else:\n        return syllable", "response": "Return a 3 - tuple of lead vowel and tail jamo characters."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the Hangul character for the given jamo characters.", "response": "def _jamo_to_hangul_char(lead, vowel, tail=0):\n    \"\"\"Return the Hangul character for the given jamo characters.\n    \"\"\"\n    lead = ord(lead) - _JAMO_LEAD_OFFSET\n    vowel = ord(vowel) - _JAMO_VOWEL_OFFSET\n    tail = ord(tail) - _JAMO_TAIL_OFFSET if tail else 0\n    return chr(tail + (vowel - 1) * 28 + (lead - 1) * 588 + _JAMO_OFFSET)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _get_unicode_name(char):\n    if char not in _JAMO_TO_NAME.keys() and char not in _HCJ_TO_NAME.keys():\n        raise InvalidJamoError(\"Not jamo or nameless jamo character\", char)\n    else:\n        if is_hcj(char):\n            return _HCJ_TO_NAME[char]\n        return _JAMO_TO_NAME[char]", "response": "Fetch the unicode name for a jamo character."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef is_jamo(character):\n    code = ord(character)\n    return 0x1100 <= code <= 0x11FF or\\\n        0xA960 <= code <= 0xA97C or\\\n        0xD7B0 <= code <= 0xD7C6 or 0xD7CB <= code <= 0xD7FB or\\\n        is_hcj(character)", "response": "Test if a single character is a jamo character."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef is_jamo_modern(character):\n    code = ord(character)\n    return 0x1100 <= code <= 0x1112 or\\\n        0x1161 <= code <= 0x1175 or\\\n        0x11A8 <= code <= 0x11C2 or\\\n        is_hcj_modern(character)", "response": "Test if a single character is a modern jamo character."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef is_jamo_compound(character):\n    if len(character) != 1:\n        return False\n        # Consider instead:\n        # raise TypeError('is_jamo_compound() expected a single character')\n    if is_jamo(character):\n        return character in JAMO_COMPOUNDS\n    return False", "response": "Test if a single character is a compound i. e. a consonant\n    cluster double consonant or dipthong."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ndetermining if a jamo character is a lead vowel or tail.", "response": "def get_jamo_class(jamo):\n    \"\"\"Determine if a jamo character is a lead, vowel, or tail.\n    Integers and U+11xx characters are valid arguments. HCJ consonants are not\n    valid here.\n\n    get_jamo_class should return the class [\"lead\" | \"vowel\" | \"tail\"] of a\n    given character or integer.\n\n    Note: jamo class directly corresponds to the Unicode 7.0 specification,\n    thus includes filler characters as having a class.\n    \"\"\"\n    # TODO: Perhaps raise a separate error for U+3xxx jamo.\n    if jamo in JAMO_LEADS or jamo == chr(0x115F):\n        return \"lead\"\n    if jamo in JAMO_VOWELS or jamo == chr(0x1160) or\\\n            0x314F <= ord(jamo) <= 0x3163:\n        return \"vowel\"\n    if jamo in JAMO_TAILS:\n        return \"tail\"\n    else:\n        raise InvalidJamoError(\"Invalid or classless jamo argument.\", jamo)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nconvert a HCJ character to a jamo character.", "response": "def hcj_to_jamo(hcj_char, position=\"vowel\"):\n    \"\"\"Convert a HCJ character to a jamo character.\n    Arguments may be single characters along with the desired jamo class\n    (lead, vowel, tail). Non-mappable input will raise an InvalidJamoError.\n    \"\"\"\n    if position == \"lead\":\n        jamo_class = \"CHOSEONG\"\n    elif position == \"vowel\":\n        jamo_class = \"JUNGSEONG\"\n    elif position == \"tail\":\n        jamo_class = \"JONGSEONG\"\n    else:\n        raise InvalidJamoError(\"No mapping from input to jamo.\", hcj_char)\n    jamo_name = re.sub(\"(?<=HANGUL )(\\w+)\",\n                       jamo_class,\n                       _get_unicode_name(hcj_char))\n    # TODO: add tests that test non entries.\n    if jamo_name in _JAMO_REVERSE_LOOKUP.keys():\n        return _JAMO_REVERSE_LOOKUP[jamo_name]\n    return hcj_char"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nconvert a string of Hangul to jamo.", "response": "def hangul_to_jamo(hangul_string):\n    \"\"\"Convert a string of Hangul to jamo.\n    Arguments may be iterables of characters.\n\n    hangul_to_jamo should split every Hangul character into U+11xx jamo\n    characters for any given string. Non-hangul characters are not changed.\n\n    hangul_to_jamo is the generator version of h2j, the string version.\n    \"\"\"\n    return (_ for _ in\n            chain.from_iterable(_hangul_char_to_jamo(_) for _ in\n                                hangul_string))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef jamo_to_hangul(lead, vowel, tail=''):\n    # Internally, we convert everything to a jamo char,\n    # then pass it to _jamo_to_hangul_char\n    lead = hcj_to_jamo(lead, \"lead\")\n    vowel = hcj_to_jamo(vowel, \"vowel\")\n    if not tail or ord(tail) == 0:\n        tail = None\n    elif is_hcj(tail):\n        tail = hcj_to_jamo(tail, \"tail\")\n    if (is_jamo(lead) and get_jamo_class(lead) == \"lead\") and\\\n       (is_jamo(vowel) and get_jamo_class(vowel) == \"vowel\") and\\\n       ((not tail) or (is_jamo(tail) and get_jamo_class(tail) == \"tail\")):\n        result = _jamo_to_hangul_char(lead, vowel, tail)\n        if is_hangul_char(result):\n            return result\n    raise InvalidJamoError(\"Could not synthesize characters to Hangul.\",\n                           '\\x00')", "response": "Return the Hangul character for the given jamo input."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a tuple of jamo character constituents of a compound.", "response": "def decompose_jamo(compound):\n    \"\"\"Return a tuple of jamo character constituents of a compound.\n    Note: Non-compound characters are echoed back.\n\n    WARNING: Archaic jamo compounds will raise NotImplementedError.\n    \"\"\"\n    if len(compound) != 1:\n        raise TypeError(\"decompose_jamo() expects a single character,\",\n                        \"but received\", type(compound), \"length\",\n                        len(compound))\n    if compound not in JAMO_COMPOUNDS:\n        # Strict version:\n        # raise TypeError(\"decompose_jamo() expects a compound jamo,\",\n        #                 \"but received\", compound)\n        return compound\n    return _JAMO_TO_COMPONENTS.get(compound, compound)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the compound jamo for the given jamo input.", "response": "def compose_jamo(*parts):\n    \"\"\"Return the compound jamo for the given jamo input.\n    Integers corresponding to U+11xx jamo codepoints, U+11xx jamo\n    characters, or HCJ are valid inputs.\n\n    Outputs a one-character jamo string.\n    \"\"\"\n    # Internally, we convert everything to a jamo char,\n    # then pass it to _jamo_to_hangul_char\n    # NOTE: Relies on hcj_to_jamo not strictly requiring \"position\" arg.\n    for p in parts:\n        if not (type(p) == str and len(p) == 1 and 2 <= len(parts) <= 3):\n            raise TypeError(\"compose_jamo() expected 2-3 single characters \" +\n                            \"but received \" + str(parts),\n                            '\\x00')\n    hcparts = [j2hcj(_) for _ in parts]\n    hcparts = tuple(hcparts)\n    if hcparts in _COMPONENTS_REVERSE_LOOKUP:\n        return _COMPONENTS_REVERSE_LOOKUP[hcparts]\n    raise InvalidJamoError(\n            \"Could not synthesize characters to compound: \" + \", \".join(\n                    str(_) + \"(U+\" + str(hex(ord(_)))[2:] +\n                    \")\" for _ in parts), '\\x00')"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef synth_hangul(string):\n    raise NotImplementedError\n    return ''.join([''.join(''.join(jamo_to_hcj(_)) for _ in string)])", "response": "Convert jamo characters in a string into hcj as much as possible."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning an exception instance that maps to the OAuth Error.", "response": "def authorization_error_class(response):\n    \"\"\"Return an exception instance that maps to the OAuth Error.\n\n    :param response: The HTTP response containing a www-authenticate error.\n\n    \"\"\"\n    message = response.headers.get(\"www-authenticate\")\n    if message:\n        error = message.replace('\"', \"\").rsplit(\"=\", 1)[1]\n    else:\n        error = response.status_code\n    return _auth_error_mapping[error](response)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _last_bookmark(b0, b1):\n    n = [None, None]\n    _, _, n[0] = b0.rpartition(\":\")\n    _, _, n[1] = b1.rpartition(\":\")\n    for i in range(2):\n        try:\n            n[i] = int(n[i])\n        except ValueError:\n            raise ValueError(\"Invalid bookmark: {}\".format(b0))\n    return b0 if n[0] > n[1] else b1", "response": "Return the latest bookmark in two bookmarks."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the last bookmark in the list of bookmarks.", "response": "def last_bookmark(bookmarks):\n    \"\"\" The bookmark returned by the last :class:`.Transaction`.\n    \"\"\"\n    last = None\n    for bookmark in bookmarks:\n        if last is None:\n            last = bookmark\n        else:\n            last = _last_bookmark(last, bookmark)\n    return last"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef connect(address, **config):\n    ssl_context = make_ssl_context(**config)\n    last_error = None\n    # Establish a connection to the host and port specified\n    # Catches refused connections see:\n    # https://docs.python.org/2/library/errno.html\n    log_debug(\"[#0000]  C: <RESOLVE> %s\", address)\n    resolver = Resolver(custom_resolver=config.get(\"resolver\"))\n    resolver.addresses.append(address)\n    resolver.custom_resolve()\n    resolver.dns_resolve()\n    for resolved_address in resolver.addresses:\n        try:\n            s = _connect(resolved_address, **config)\n            s, der_encoded_server_certificate = _secure(s, address[0], ssl_context)\n            connection = _handshake(s, resolved_address, der_encoded_server_certificate, **config)\n        except Exception as error:\n            last_error = error\n        else:\n            return connection\n    if last_error is None:\n        raise ServiceUnavailable(\"Failed to resolve addresses for %s\" % address)\n    else:\n        raise last_error", "response": "Connect and perform a handshake and return a valid Connection object assuming that a protocol version can be agreed."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _append(self, signature, fields=(), response=None):\n        self.packer.pack_struct(signature, fields)\n        self.output_buffer.chunk()\n        self.output_buffer.chunk()\n        self.responses.append(response)", "response": "Add a message to the outgoing queue."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsends a RESET message to the outgoing queue and consume all remaining messages.", "response": "def reset(self):\n        \"\"\" Add a RESET message to the outgoing queue, send\n        it and consume all remaining messages.\n        \"\"\"\n\n        def fail(metadata):\n            raise ProtocolError(\"RESET failed %r\" % metadata)\n\n        log_debug(\"[#%04X]  C: RESET\", self.local_port)\n        self._append(b\"\\x0F\", response=Response(self, on_failure=fail))\n        self.sync()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _send(self):\n        data = self.output_buffer.view()\n        if not data:\n            return\n        if self.closed():\n            raise self.Error(\"Failed to write to closed connection {!r}\".format(self.server.address))\n        if self.defunct():\n            raise self.Error(\"Failed to write to defunct connection {!r}\".format(self.server.address))\n        self.socket.sendall(data)\n        self.output_buffer.clear()", "response": "Send all queued messages to the server."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _fetch(self):\n        if self.closed():\n            raise self.Error(\"Failed to read from closed connection {!r}\".format(self.server.address))\n        if self.defunct():\n            raise self.Error(\"Failed to read from defunct connection {!r}\".format(self.server.address))\n        if not self.responses:\n            return 0, 0\n\n        self._receive()\n\n        details, summary_signature, summary_metadata = self._unpack()\n\n        if details:\n            log_debug(\"[#%04X]  S: RECORD * %d\", self.local_port, len(details))  # TODO\n            self.responses[0].on_records(details)\n\n        if summary_signature is None:\n            return len(details), 0\n\n        response = self.responses.popleft()\n        response.complete = True\n        if summary_signature == b\"\\x70\":\n            log_debug(\"[#%04X]  S: SUCCESS %r\", self.local_port, summary_metadata)\n            response.on_success(summary_metadata or {})\n        elif summary_signature == b\"\\x7E\":\n            self._last_run_statement = None\n            log_debug(\"[#%04X]  S: IGNORED\", self.local_port)\n            response.on_ignored(summary_metadata or {})\n        elif summary_signature == b\"\\x7F\":\n            self._last_run_statement = None\n            log_debug(\"[#%04X]  S: FAILURE %r\", self.local_port, summary_metadata)\n            response.on_failure(summary_metadata or {})\n        else:\n            self._last_run_statement = None\n            raise ProtocolError(\"Unexpected response message with signature %02X\" % summary_signature)\n\n        return len(details), 1", "response": "Receive at least one message from the server."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef sync(self):\n        self.send()\n        detail_count = summary_count = 0\n        while self.responses:\n            response = self.responses[0]\n            while not response.complete:\n                detail_delta, summary_delta = self.fetch()\n                detail_count += detail_delta\n                summary_count += summary_delta\n        return detail_count, summary_count", "response": "Send and fetch all outstanding messages."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nacquires a connection from the pool.", "response": "def acquire_direct(self, address):\n        \"\"\" Acquire a connection to a given address from the pool.\n        The address supplied should always be an IP address, not\n        a host name.\n\n        This method is thread safe.\n        \"\"\"\n        if self.closed():\n            raise ServiceUnavailable(\"Connection pool closed\")\n        with self.lock:\n            try:\n                connections = self.connections[address]\n            except KeyError:\n                connections = self.connections[address] = deque()\n\n            connection_acquisition_start_timestamp = perf_counter()\n            while True:\n                # try to find a free connection in pool\n                for connection in list(connections):\n                    if connection.closed() or connection.defunct() or connection.timedout():\n                        connections.remove(connection)\n                        continue\n                    if not connection.in_use:\n                        connection.in_use = True\n                        return connection\n                # all connections in pool are in-use\n                infinite_connection_pool = (self._max_connection_pool_size < 0 or\n                                            self._max_connection_pool_size == float(\"inf\"))\n                can_create_new_connection = infinite_connection_pool or len(connections) < self._max_connection_pool_size\n                if can_create_new_connection:\n                    try:\n                        connection = self.connector(address)\n                    except ServiceUnavailable:\n                        self.remove(address)\n                        raise\n                    else:\n                        connection.pool = self\n                        connection.in_use = True\n                        connections.append(connection)\n                        return connection\n\n                # failed to obtain a connection from pool because the pool is full and no free connection in the pool\n                span_timeout = self._connection_acquisition_timeout - (perf_counter() - connection_acquisition_start_timestamp)\n                if span_timeout > 0:\n                    self.cond.wait(span_timeout)\n                    # if timed out, then we throw error. This time computation is needed, as with python 2.7, we cannot\n                    # tell if the condition is notified or timed out when we come to this line\n                    if self._connection_acquisition_timeout <= (perf_counter() - connection_acquisition_start_timestamp):\n                        raise ClientError(\"Failed to obtain a connection from pool within {!r}s\".format(\n                            self._connection_acquisition_timeout))\n                else:\n                    raise ClientError(\"Failed to obtain a connection from pool within {!r}s\".format(self._connection_acquisition_timeout))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef release(self, connection):\n        with self.lock:\n            connection.in_use = False\n            self.cond.notify_all()", "response": "Release a connection back into the pool."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef in_use_connection_count(self, address):\n        try:\n            connections = self.connections[address]\n        except KeyError:\n            return 0\n        else:\n            return sum(1 if connection.in_use else 0 for connection in connections)", "response": "Count the number of connections currently in use to a given address."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ndeactivating an address from the connection pool if present closing all idle connections to that address.", "response": "def deactivate(self, address):\n        \"\"\" Deactivate an address from the connection pool, if present, closing\n        all idle connection to that address\n        \"\"\"\n        with self.lock:\n            try:\n                connections = self.connections[address]\n            except KeyError: # already removed from the connection pool\n                return\n            for conn in list(connections):\n                if not conn.in_use:\n                    connections.remove(conn)\n                    try:\n                        conn.close()\n                    except IOError:\n                        pass\n            if not connections:\n                self.remove(address)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nremoving an address from the connection pool closing all connections to that address.", "response": "def remove(self, address):\n        \"\"\" Remove an address from the connection pool, if present, closing\n        all connections to that address.\n        \"\"\"\n        with self.lock:\n            for connection in self.connections.pop(address, ()):\n                try:\n                    connection.close()\n                except IOError:\n                    pass"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef close(self):\n        if self._closed:\n            return\n        try:\n            with self.lock:\n                if not self._closed:\n                    self._closed = True\n                    for address in list(self.connections):\n                        self.remove(address)\n        except TypeError as e:\n            pass", "response": "Close all connections and empty the pool."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncalls when one or more RECORD messages have been received.", "response": "def on_records(self, records):\n        \"\"\" Called when one or more RECORD messages have been received.\n        \"\"\"\n        handler = self.handlers.get(\"on_records\")\n        if callable(handler):\n            handler(records)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncall when a SUCCESS message has been received.", "response": "def on_success(self, metadata):\n        \"\"\" Called when a SUCCESS message has been received.\n        \"\"\"\n        handler = self.handlers.get(\"on_success\")\n        if callable(handler):\n            handler(metadata)\n        handler = self.handlers.get(\"on_summary\")\n        if callable(handler):\n            handler()"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncalls when a FAILURE message has been received.", "response": "def on_failure(self, metadata):\n        \"\"\" Called when a FAILURE message has been received.\n        \"\"\"\n        self.connection.reset()\n        handler = self.handlers.get(\"on_failure\")\n        if callable(handler):\n            handler(metadata)\n        handler = self.handlers.get(\"on_summary\")\n        if callable(handler):\n            handler()\n        raise CypherError.hydrate(**metadata)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef on_ignored(self, metadata=None):\n        handler = self.handlers.get(\"on_ignored\")\n        if callable(handler):\n            handler(metadata)\n        handler = self.handlers.get(\"on_summary\")\n        if callable(handler):\n            handler()", "response": "Called when an IGNORED message has been received."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nconvert pysnmp objects into native Python objects.", "response": "def _convert_value_to_native(value):\n    \"\"\"\n    Converts pysnmp objects into native Python objects.\n    \"\"\"\n    if isinstance(value, Counter32):\n        return int(value.prettyPrint())\n    if isinstance(value, Counter64):\n        return int(value.prettyPrint())\n    if isinstance(value, Gauge32):\n        return int(value.prettyPrint())\n    if isinstance(value, Integer):\n        return int(value.prettyPrint())\n    if isinstance(value, Integer32):\n        return int(value.prettyPrint())\n    if isinstance(value, Unsigned32):\n        return int(value.prettyPrint())\n    if isinstance(value, IpAddress):\n        return str(value.prettyPrint())\n    if isinstance(value, OctetString):\n        try:\n            return value.asOctets().decode(value.encoding)\n        except UnicodeDecodeError:\n            return value.asOctets()\n    if isinstance(value, TimeTicks):\n        return timedelta(seconds=int(value.prettyPrint()) / 100.0)\n    return value"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get(self, oid):\n        snmpsecurity = self._get_snmp_security()\n\n        try:\n            engine_error, pdu_error, pdu_error_index, objects = self._cmdgen.getCmd(\n                snmpsecurity,\n                cmdgen.UdpTransportTarget((self.host, self.port), timeout=self.timeout,\n                                          retries=self.retries),\n                oid,\n            )\n\n        except Exception as e:\n            raise SNMPError(e)\n        if engine_error:\n            raise SNMPError(engine_error)\n        if pdu_error:\n            raise SNMPError(pdu_error.prettyPrint())\n\n        _, value = objects[0]\n        value = _convert_value_to_native(value)\n        return value", "response": "Get a single OID value."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsetting a single OID value.", "response": "def set(self, oid, value, value_type=None):\n        \"\"\"\n        Sets a single OID value. If you do not pass value_type hnmp will\n        try to guess the correct type. Autodetection is supported for:\n\n        * int and float (as Integer, fractional part will be discarded)\n        * IPv4 address (as IpAddress)\n        * str (as OctetString)\n\n        Unfortunately, pysnmp does not support the SNMP FLOAT type so\n        please use Integer instead.\n        \"\"\"\n        snmpsecurity = self._get_snmp_security()\n\n        if value_type is None:\n            if isinstance(value, int):\n                data = Integer(value)\n            elif isinstance(value, float):\n                data = Integer(value)\n            elif isinstance(value, str):\n                if is_ipv4_address(value):\n                    data = IpAddress(value)\n                else:\n                    data = OctetString(value)\n            else:\n                raise TypeError(\n                    \"Unable to autodetect type. Please pass one of \"\n                    \"these strings as the value_type keyword arg: \"\n                    \", \".join(TYPES.keys())\n                )\n        else:\n            if value_type not in TYPES:\n                raise ValueError(\"'{}' is not one of the supported types: {}\".format(\n                    value_type,\n                    \", \".join(TYPES.keys())\n                ))\n            data = TYPES[value_type](value)\n\n        try:\n            engine_error, pdu_error, pdu_error_index, objects = self._cmdgen.setCmd(\n                snmpsecurity,\n                cmdgen.UdpTransportTarget((self.host, self.port), timeout=self.timeout,\n                                          retries=self.retries),\n                (oid, data),\n            )\n            if engine_error:\n                raise SNMPError(engine_error)\n            if pdu_error:\n                raise SNMPError(pdu_error.prettyPrint())\n        except Exception as e:\n            raise SNMPError(e)\n\n        _, value = objects[0]\n        value = _convert_value_to_native(value)\n        return value"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget a table of values with the given OID prefix.", "response": "def table(self, oid, columns=None, column_value_mapping=None, non_repeaters=0,\n              max_repetitions=20, fetch_all_columns=True):\n        \"\"\"\n        Get a table of values with the given OID prefix.\n        \"\"\"\n        snmpsecurity = self._get_snmp_security()\n        base_oid = oid.strip(\".\")\n\n        if not fetch_all_columns and not columns:\n            raise ValueError(\"please use the columns argument to \"\n                             \"indicate which columns to fetch\")\n\n        if fetch_all_columns:\n            columns_to_fetch = [\"\"]\n        else:\n            columns_to_fetch = [\".\" + str(col_id) for col_id in columns.keys()]\n\n        full_obj_table = []\n\n        for col in columns_to_fetch:\n            try:\n                engine_error, pdu_error, pdu_error_index, obj_table = self._cmdgen.bulkCmd(\n                    snmpsecurity,\n                    cmdgen.UdpTransportTarget((self.host, self.port), timeout=self.timeout,\n                                              retries=self.retries),\n                    non_repeaters,\n                    max_repetitions,\n                    oid + col,\n                )\n\n            except Exception as e:\n                raise SNMPError(e)\n            if engine_error:\n                raise SNMPError(engine_error)\n            if pdu_error:\n                raise SNMPError(pdu_error.prettyPrint())\n\n            # remove any trailing rows from the next subtree\n            try:\n                while not str(obj_table[-1][0][0].getOid()).lstrip(\".\").startswith(\n                    base_oid + col + \".\"\n                ):\n                    obj_table.pop()\n            except IndexError:\n                pass\n\n            # append this column to full result\n            full_obj_table += obj_table\n\n        t = Table(columns=columns, column_value_mapping=column_value_mapping)\n\n        for row in full_obj_table:\n            for name, value in row:\n                oid = str(name.getOid()).strip(\".\")\n                value = _convert_value_to_native(value)\n                column, row_id = oid[len(base_oid) + 1:].split(\".\", 1)\n                t._add_value(int(column), row_id, value)\n\n        return t"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_parser():\n    desc = Colors.LIGHTBLUE + textwrap.dedent(\n        '''\\\n        Welcome to\n                      _                           _                            _\n           __ _ _   _| |_ ___      _ __  _   _   | |_ ___  _ __ _ __ ___ _ __ | |_\n          / _` | | | | __/ _ \\    | '_ \\| | | |  | __/ _ \\| '__| '__/ _ \\ '_ \\| __|\n         | (_| | |_| | || (_) |   | |_) | |_| |  | || (_) | |  | | |  __/ | | | |_\n          \\__,_|\\__,_|\\__\\___/____| .__/ \\__, |___\\__\\___/|_|  |_|  \\___|_| |_|\\__|\n                            |_____|_|    |___/_____|\n\n        ------------------------------------\n          auto_py_torrent is an automated tool for download files by obtaining\n        torrents or magnets that are in different provided pages that the\n        user can choose.\n\n          Its goal is to make it easier for users to find the files they want\n        and download them instantly.\n\n          An auto_py_torrent command is provided in which the user can\n        currently choose between two modes, best_rated and list mode, then it\n        selects one of the torrent tracking pages for multimedia content and\n        finally enter the text of what you want to download.\n        ------------------------------------\n        ''') + Colors.ENDC\n    usage_info = Colors.LGREEN + textwrap.dedent(\n        '''\\\n\n        Use \"%(prog)s --help\" for more information.\n        Examples:\n            use \"%(prog)s MODE SELECTED_PAGE STRING_TO_SEARCH # generic.\n            use \"%(prog)s 0 0 \"The simpsons\" # best rated.\n            use \"%(prog)s 1 0 \"The simpsons\" # list rated.\n\n        Mode options:\n            0: best_rated. # Download the most rated file.\n            1: list. # Get a list, and select one of them.\n\n        Page list options:\n            0: torrent project.\n            1: the pirate bay.\n            2: 1337x.\n            3: eztv.\n            4: limetorrents.\n            5: isohunt.\n        ''') + Colors.ENDC\n    epi = Colors.LIGHTPURPLE + textwrap.dedent(\n        '''\\\n        -> Thanks for using auto_py_torrent!\n        ''') + Colors.ENDC\n\n    # Parent and only parser.\n    parser = argparse.ArgumentParser(\n        add_help=True,\n        formatter_class=argparse.RawTextHelpFormatter,\n        usage=usage_info,\n        description=desc,\n        epilog=epi)\n    parser.add_argument('mode', action='store',\n                        choices=range(len(MODES)),\n                        type=int,\n                        help='Select mode of file download.\\n'\n                             '    e.g: 0(rated) or 1(list).')\n    parser.add_argument('torr_page', action='store',\n                        choices=range(len(TORRENTS)),\n                        type=int,\n                        help='Select tracking page to download from.\\n'\n                             '    e.g: 0 to .. ' + str(len(TORRENTS)-1) + '.')\n    parser.add_argument('str_search', action='store',\n                        type=str,\n                        help='Input torrent string to search.\\n'\n                             '    e.g: \"String search\"')\n    return(parser)", "response": "Return parser for command line arguments."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ninsert args values into instance variables.", "response": "def insert(args):\n    \"\"\"Insert args values into instance variables.\"\"\"\n    string_search = args.str_search\n    mode_search = MODES[args.mode]\n    page = list(TORRENTS[args.torr_page].keys())[0]\n    key_search = TORRENTS[args.torr_page][page]['key_search']\n    torrent_page = TORRENTS[args.torr_page][page]['page']\n    domain = TORRENTS[args.torr_page][page]['domain']\n    return([args, string_search, mode_search, page,\n            key_search, torrent_page, domain])"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef run_it():\n    initialize()\n    parser = get_parser()\n    args = None\n    first_parse = True\n    while(True):\n        if first_parse is True:\n            first_parse = False\n            args = parser.parse_args()\n        else:\n            print(textwrap.dedent(\n                '''\\\n                Search again like in the beginning.\n                  -- You can either choose best rated or list mode.\n                  -- This time, you can insert the search string without double quotes.\n                  Remember the list mode options!\n                    0: torrent project.\n                    1: the pirate bay.\n                    2: 1337x.\n                    3: eztv.\n                    4: limetorrents.\n                    5: isohunt.\n                '''))\n\n            print('Or.. if you want to exit just write \"' +\n                  Colors.LRED + 'Q' + Colors.ENDC + '\" or \"' +\n                  Colors.LRED + 'q' + Colors.ENDC + '\".')\n            input_parse = input('>> ').replace(\"'\", \"\").replace('\"', '')\n            if input_parse in ['Q', 'q']:\n                sys.exit(1)\n\n            args = parser.parse_args(input_parse.split(' ', 2))\n\n        if args.str_search.strip() == \"\":\n            print('Please insert an appropiate non-empty string.')\n        else:\n            auto = AutoPy(*insert(args))\n            auto.get_content()\n            auto.select_torrent()\n            auto.download_torrent()", "response": "Search and download torrents until the user says it so."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nopening magnet according to os.", "response": "def open_magnet(self):\n        \"\"\"Open magnet according to os.\"\"\"\n        if sys.platform.startswith('linux'):\n            subprocess.Popen(['xdg-open', self.magnet],\n                             stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n        elif sys.platform.startswith('win32'):\n            os.startfile(self.magnet)\n        elif sys.platform.startswith('cygwin'):\n            os.startfile(self.magnet)\n        elif sys.platform.startswith('darwin'):\n            subprocess.Popen(['open', self.magnet],\n                             stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n        else:\n            subprocess.Popen(['xdg-open', self.magnet],\n                             stdout=subprocess.PIPE, stderr=subprocess.PIPE)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget magnet from torrent page. Url already got domain.", "response": "def get_magnet(self, url):\n        \"\"\"Get magnet from torrent page. Url already got domain.\"\"\"\n        content_most_rated = requests.get(url)\n        rated_soup = BeautifulSoup(content_most_rated.content, 'lxml')\n\n        if self.page == 'torrent_project':\n            self.magnet = rated_soup.find(\n                'a', href=True, text=re.compile('Download'))['href']\n\n        elif self.page == 'the_pirate_bay':\n            self.magnet = rated_soup.find(\n                'a', href=True, text=re.compile('Get this torrent'))['href']\n\n        elif self.page == '1337x':\n            div1337 = rated_soup.find(\n                'div', {'class': 'torrent-category-detail'})\n            self.magnet = div1337.find('a', href=re.compile('magnet'))['href']\n\n        elif self.page == 'isohunt':\n            self.magnet = rated_soup.find(\n                'a', href=re.compile('magnet'))['href']\n\n        else:\n            print('Wrong page to get magnet!')\n            sys.exit(1)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndownload torrent. Rated implies download the unique best rated torrent found. Otherwise: get the magnet and download it.", "response": "def download_torrent(self):\n        \"\"\"Download torrent.\n\n        Rated implies download the unique best rated torrent found.\n        Otherwise: get the magnet and download it.\n        \"\"\"\n        try:\n            if self.back_to_menu is True:\n                return\n            if self.found_torrents is False:\n                print('Nothing found.')\n                return\n            if self.mode_search == 'best_rated':\n                print('Downloading..')\n                self.open_magnet()\n            elif self.mode_search == 'list':\n                if self.selected is not None:\n                    # t_p, pirate and 1337x got magnet inside, else direct.\n                    if self.page in ['eztv', 'limetorrents']:\n                        self.magnet = self.hrefs[int(self.selected)]\n                        print('Downloading..')\n                        self.open_magnet()\n                    elif self.page in ['the_pirate_bay',\n                                       'torrent_project',\n                                       '1337x',\n                                       'isohunt']:\n                        url = self.hrefs[int(self.selected)]\n                        self.get_magnet(url)\n                        print('Downloading..')\n                        self.open_magnet()\n                    else:\n                        print('Bad selected page.')\n                else:\n                    print('Nothing selected.')\n                    sys.exit(1)\n        except Exception:\n            print(traceback.format_exc())\n            sys.exit(0)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef build_table(self):\n        headers = ['Title', 'Seeders', 'Leechers', 'Age', 'Size']\n        titles = []\n        seeders = []\n        leechers = []\n        ages = []\n        sizes = []\n\n        if self.page == 'torrent_project':\n            titles = [list(span.find('a').stripped_strings)[0]\n                      for span in self.elements[0]]\n\n            seeders = [span.get_text() for span in self.elements[1]]\n            leechers = [span.get_text() for span in self.elements[2]]\n            ages = [span.get_text() for span in self.elements[3]]\n            sizes = [span.get_text() for span in self.elements[4]]\n\n            # Torrents\n            self.hrefs = [self.domain +\n                          span.find('a')['href']\n                          for span in self.elements[0]]\n\n        elif self.page == 'the_pirate_bay':\n            for elem in self.elements[0]:\n                title = elem.find('a', {'class': 'detLink'}).get_text()\n                titles.append(title)\n\n                font_text = elem.find(\n                    'font', {'class': 'detDesc'}).get_text()\n                dammit = UnicodeDammit(font_text)\n                age, size = dammit.unicode_markup.split(',')[:-1]\n                ages.append(age)\n                sizes.append(size)\n                # Torrent\n                href = self.domain + \\\n                    elem.find('a', title=re.compile('magnet'))['href']\n                self.hrefs.append(str(href))\n\n            seeders = [elem.get_text() for elem in self.elements[1]]\n            leechers = [elem.get_text() for elem in self.elements[2]]\n\n        elif self.page == '1337x':\n            titles = [elem.get_text() for elem in self.elements[0]]\n            seeders = [elem.get_text() for elem in self.elements[1]]\n            leechers = [elem.get_text() for elem in self.elements[2]]\n            ages = [elem.get_text() for elem in self.elements[3]]\n            sizes = [elem.get_text('|').split('|')[0]\n                     for elem in self.elements[4]]\n\n            # Torrent\n            self.hrefs = [self.domain +\n                          elem.find(href=re.compile('torrent'))['href']\n                          for elem in self.elements[0]]\n\n        elif self.page == 'eztv':\n            titles = [elem.get_text() for elem in self.elements[0]]\n            seeders = [elem.get_text() for elem in self.elements[4]]\n            leechers = ['-' for elem in self.elements[4]]\n            ages = [elem.get_text() for elem in self.elements[3]]\n            sizes = [elem.get_text() for elem in self.elements[2]]\n\n            # Magnets\n            self.hrefs = [elem.find(href=re.compile('magnet'))['href']\n                          for elem in self.elements[1]]\n\n        elif self.page == 'limetorrents':\n            titles = [elem.get_text() for elem in self.elements[0]]\n            seeders = [elem.get_text() for elem in self.elements[3]]\n            leechers = [elem.get_text() for elem in self.elements[4]]\n            ages = [elem.get_text() for elem in self.elements[1]]\n            sizes = [elem.get_text() for elem in self.elements[2]]\n\n            # Magnets\n            self.hrefs = [elem.find('a', href=re.compile('torrent'))['href']\n                          for elem in self.elements[0]]\n\n        elif self.page == 'isohunt':\n            titles = [elem.get_text() for elem in self.elements[0]]\n            seeders = [elem.get_text() for elem in self.elements[5]]\n            leechers = ['-' for elem in self.elements[5]]\n            ages = [elem.get_text() for elem in self.elements[3]]\n            sizes = [elem.get_text() for elem in self.elements[4]]\n\n            # Torrents\n            self.hrefs = [self.domain +\n                          elem.find(href=re.compile('torrent_details'))['href']\n                          for elem in self.elements[0]]\n        else:\n            print('Error page')\n\n        self.table = [[Colors.BOLD +\n                       UnicodeDammit(titles[i][:75].strip(), [\"utf-8\"]).unicode_markup +\n                       Colors.ENDC\n                       if (i + 1) % 2 == 0\n                       else UnicodeDammit(\n                           titles[i][:75].strip()).unicode_markup,\n                       Colors.SEEDER + seeders[i].strip() + Colors.ENDC\n                       if (i + 1) % 2 == 0\n                       else Colors.LGREEN + seeders[i].strip() + Colors.ENDC,\n                       Colors.LEECHER + leechers[i].strip() + Colors.ENDC\n                       if (i + 1) % 2 == 0\n                       else Colors.LRED + leechers[i].strip() + Colors.ENDC,\n                       Colors.LIGHTBLUE + ages[i].strip() + Colors.ENDC\n                       if (i + 1) % 2 == 0\n                       else Colors.BLUE + ages[i].strip() + Colors.ENDC,\n                       Colors.PINK + sizes[i].strip() + Colors.ENDC\n                       if (i + 1) % 2 == 0\n                       else Colors.PURPLE + sizes[i].strip() + Colors.ENDC]\n                      for i in range(len(self.hrefs))]\n\n        print(tabulate(self.table,\n                       headers=headers,\n                       tablefmt='psql',\n                       numalign='right',\n                       stralign='left',\n                       showindex=True))", "response": "Build the table of torrents."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget proper torrent and magnet information.", "response": "def soupify(self):\n        \"\"\"Get proper torrent/magnet information.\n\n        If search_mode is rated then get torrent/magnet.\n        If not, get all the elements to build the table.\n        There are different ways for each page.\n        \"\"\"\n        soup = BeautifulSoup(self.content_page.content, 'lxml')\n        if self.page == 'torrent_project':\n            main = soup.find('div', {'id': 'similarfiles'})\n            if self.mode_search == 'best_rated':\n                rated_url = self.domain + \\\n                    main.find(href=re.compile('torrent.html'))['href']\n                self.get_magnet(rated_url)\n            else:\n                divs = main.find_all('div', limit=30)[2:]\n                self.elements = list(\n                    zip(*[d.find_all('span', recursive=False)\n                          for d in divs]))  # Torrents\n\n        elif self.page == 'the_pirate_bay':\n            main = soup.find('table', {'id': 'searchResult'})\n            if self.mode_search == 'best_rated':\n                rated_url = self.domain + \\\n                    main.find('a', href=re.compile('torrent'))['href']\n                self.get_magnet(rated_url)\n            else:\n                trs = main.find_all('tr', limit=30)[1:]\n                self.elements = list(\n                    zip(*[tr.find_all('td', recursive=False)[1:]\n                          for tr in trs]))  # Magnets\n\n        elif self.page == '1337x':\n            main = soup.find('table', {'class': 'table'})\n            if self.mode_search == 'best_rated':\n                rated_url = self.domain + \\\n                    main.find('a', href=re.compile('torrent'))['href']\n                self.get_magnet(rated_url)\n            else:\n                trs = main.find_all('tr', limit=30)[1:]\n                self.elements = list(\n                    zip(*([tr.find_all('td', recursive=False)[:-1]\n                           for tr in trs])))  # Torrents\n\n        elif self.page == 'eztv':\n            main = soup.find_all('table', {'class': 'forum_header_border'})[2]\n            if self.mode_search == 'best_rated':\n                self.magnet = main.find('a', href=re.compile('magnet'))['href']\n            else:\n                trs = main.find_all('tr', limit=30)[2:]\n                self.elements = list(\n                    zip(*([tr.find_all('td', recursive=False)[1:-1]\n                           for tr in trs])))  # Magnets\n\n        elif self.page == 'limetorrents':\n            main = soup.find('table', {'class': 'table2'})\n            if self.mode_search == 'best_rated':\n                self.magnet = main.find(\n                    'a', href=re.compile('torrent'))['href']\n            else:\n                trs = main.find_all('tr', limit=30)[1:]\n                self.elements = list(\n                    zip(*([tr.find_all('td', recursive=False)[:-1]\n                           for tr in trs])))  # Magnets\n\n        elif self.page == 'isohunt':\n            main = soup.find('table', {'class': 'table'})\n            if self.mode_search == 'best_rated':\n                rated_url = self.domain + \\\n                    main.find('a', href=re.compile(\n                        'torrent_details'))['href']\n                self.get_magnet(rated_url)\n            else:\n                trs = main.find_all('tr', limit=30)[1:-1]\n                self.elements = list(\n                    zip(*([tr.find_all('td', recursive=False)[1:-1]\n                           for tr in trs])))  # Torrent\n        else:\n            print('Cannot soupify current page. Try again.')"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef handle_select(self):\n        self.selected = input('>> ')\n        if self.selected in ['Q', 'q']:\n            sys.exit(1)\n        elif self.selected in ['B', 'b']:\n            self.back_to_menu = True\n            return True\n        elif is_num(self.selected):\n            if 0 <= int(self.selected) <= len(self.hrefs) - 1:\n                self.back_to_menu = False\n                return True\n            else:\n                print(Colors.FAIL +\n                      'Wrong index. ' +\n                      'Please select an appropiate one or other option.' +\n                      Colors.ENDC)\n                return False\n        else:\n            print(Colors.FAIL +\n                  'Invalid input. ' +\n                  'Please select an appropiate one or other option.' +\n                  Colors.ENDC)\n            return False", "response": "Handle user s input in list mode."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef select_torrent(self):\n        try:\n            self.found_torrents = not bool(self.key_search in\n                                           self.content_page.text)\n            if not self.found_torrents:\n                print('No torrents found.')\n                sys.exit(1)\n            self.soupify()\n            if self.mode_search == 'list':\n                self.build_table()\n                if len(self.hrefs) == 1:\n                    print('Press \"0\" to download it.')\n                elif len(self.hrefs) >= 2:\n                    print('\\nSelect one of the following torrents. ' +\n                          'Enter a number between: 0 and ' +\n                          str(len(self.hrefs) - 1))\n\n                print('If you want to exit write \"' +\n                      Colors.LRED + 'Q' + Colors.ENDC + '\" or \"' +\n                      Colors.LRED + 'q' + Colors.ENDC + '\".')\n                print('If you want to go back to menu and search again write \"' +\n                      Colors.LGREEN + 'B' + Colors.ENDC + '\" or \"' +\n                      Colors.LGREEN + 'b' + Colors.ENDC + '\".')\n                while not(self.picked_choice):\n                    self.picked_choice = self.handle_select()\n        except Exception:\n            print('ERROR select_torrent: ')\n            logging.error(traceback.format_exc())\n            sys.exit(0)", "response": "Select a specific element from content page."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef build_url(self):\n        url = requests.utils.requote_uri(\n            self.torrent_page + self.string_search)\n        if self.page == '1337x':\n            return(url + '/1/')\n        elif self.page == 'limetorrents':\n            return(url + '/')\n        else:\n            return(url)", "response": "Build appropiate encoded URL."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting content of the page through url.", "response": "def get_content(self):\n        \"\"\"Get content of the page through url.\"\"\"\n        url = self.build_url()\n        try:\n            self.content_page = requests.get(url)\n            if not(self.content_page.status_code == requests.codes.ok):\n                self.content_page.raise_for_status()\n        except requests.exceptions.RequestException as ex:\n            logging.info('A requests exception has ocurred: ' + str(ex))\n            logging.error(traceback.format_exc())\n            sys.exit(0)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreclaims the buffer space before the origin.", "response": "def _recycle(self):\n        \"\"\" Reclaim buffer space before the origin.\n\n        Note: modifies buffer size\n        \"\"\"\n        origin = self._origin\n        if origin == 0:\n            return False\n        available = self._extent - origin\n        self._data[:available] = self._data[origin:self._extent]\n        self._extent = available\n        self._origin = 0\n        #log_debug(\"Recycled %d bytes\" % origin)\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef frame_message(self):\n        if self._frame is not None:\n            self.discard_message()\n        panes = []\n        p = origin = self._origin\n        extent = self._extent\n        while p < extent:\n            available = extent - p\n            if available < 2:\n                break\n            chunk_size, = struct_unpack(\">H\", self._view[p:(p + 2)])\n            p += 2\n            if chunk_size == 0:\n                self._limit = p\n                self._frame = MessageFrame(memoryview(self._view[origin:self._limit]), panes)\n                return True\n            q = p + chunk_size\n            panes.append((p - origin, q - origin))\n            p = q\n        return False", "response": "Construct a message frame around the first complete message in the buffer."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef call(self, request_function, set_header_callback, *args, **kwargs):\n        self.delay()\n        kwargs[\"headers\"] = set_header_callback()\n        response = request_function(*args, **kwargs)\n        self.update(response.headers)\n        return response", "response": "Rate limit the call to request_function."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef delay(self):\n        if self.next_request_timestamp is None:\n            return\n        sleep_seconds = self.next_request_timestamp - time.time()\n        if sleep_seconds <= 0:\n            return\n        message = \"Sleeping: {:0.2f} seconds prior to\" \" call\".format(\n            sleep_seconds\n        )\n        log.debug(message)\n        time.sleep(sleep_seconds)", "response": "Sleep for an amount of time to remain under the rate limit."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef update(self, response_headers):\n        if \"x-ratelimit-remaining\" not in response_headers:\n            if self.remaining is not None:\n                self.remaining -= 1\n                self.used += 1\n            return\n\n        now = time.time()\n        prev_remaining = self.remaining\n\n        seconds_to_reset = int(response_headers[\"x-ratelimit-reset\"])\n        self.remaining = float(response_headers[\"x-ratelimit-remaining\"])\n        self.used = int(response_headers[\"x-ratelimit-used\"])\n        self.reset_timestamp = now + seconds_to_reset\n\n        if self.remaining <= 0:\n            self.next_request_timestamp = self.reset_timestamp\n            return\n\n        if prev_remaining is not None and prev_remaining > self.remaining:\n            estimated_clients = prev_remaining - self.remaining\n        else:\n            estimated_clients = 1.0\n\n        self.next_request_timestamp = min(\n            self.reset_timestamp,\n            now + (estimated_clients * seconds_to_reset / self.remaining),\n        )", "response": "Update the state of the rate limiter based on the response headers."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef custom_resolve(self):\n        if not callable(self.custom_resolver):\n            return\n        new_addresses = []\n        for address in self.addresses:\n            for new_address in self.custom_resolver(address):\n                new_addresses.append(new_address)\n        self.addresses = new_addresses", "response": "Perform custom resolution on the contained addresses."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nperform DNS resolution on the contained addresses.", "response": "def dns_resolve(self):\n        \"\"\" Perform DNS resolution on the contained addresses.\n\n        :return:\n        \"\"\"\n        new_addresses = []\n        for address in self.addresses:\n            try:\n                info = getaddrinfo(address[0], address[1], 0, SOCK_STREAM, IPPROTO_TCP)\n            except gaierror:\n                raise AddressError(\"Cannot resolve address {!r}\".format(address))\n            else:\n                for _, _, _, _, address in info:\n                    if len(address) == 4 and address[3] != 0:\n                        # skip any IPv6 addresses with a non-zero scope id\n                        # as these appear to cause problems on some platforms\n                        continue\n                    new_addresses.append(address)\n        self.addresses = new_addresses"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget the quality of a network or cell from iwlist scan.", "response": "def get_quality(cell):\n    \"\"\" Gets the quality of a network / cell.\n    @param string cell\n        A network / cell from iwlist scan.\n\n    @return string\n        The quality of the network.\n    \"\"\"\n\n    quality = matching_line(cell, \"Quality=\")\n    if quality is None:\n        return \"\"\n    quality = quality.split()[0].split(\"/\")\n    quality = matching_line(cell, \"Quality=\").split()[0].split(\"/\")\n    return str(int(round(float(quality[0]) / float(quality[1]) * 100)))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the signal level of a network or cell from iwlist scan.", "response": "def get_signal_level(cell):\n    \"\"\" Gets the signal level of a network / cell.\n    @param string cell\n        A network / cell from iwlist scan.\n\n    @return string\n        The signal level of the network.\n    \"\"\"\n\n    signal = matching_line(cell, \"Signal level=\")\n    if signal is None:\n      return \"\"\n    signal = signal.split(\"=\")[1].split(\"/\")\n    if len(signal) == 2:\n        return str(int(round(float(signal[0]) / float(signal[1]) * 100)))\n    elif len(signal) == 1:\n        return signal[0].split(' ')[0]\n    else:\n        return \"\""}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_noise_level(cell):\n\n    noise = matching_line(cell, \"Noise level=\")\n    if noise is None:\n        return \"\"\n    noise = noise.split(\"=\")[1]\n    return noise.split(' ')[0]", "response": "Gets the noise level of a network or cell from iwlist scan."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_channel(cell):\n\n    channel = matching_line(cell, \"Channel:\")\n    if channel:\n        return channel\n    frequency = matching_line(cell, \"Frequency:\")\n    channel = re.sub(r\".*\\(Channel\\s(\\d{1,3})\\).*\", r\"\\1\", frequency)\n    return channel", "response": "Gets the channel of a network or cell from iwlist scan."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the encryption type of a network or cell from iwlist scan.", "response": "def get_encryption(cell, emit_version=False):\n    \"\"\" Gets the encryption type of a network / cell.\n    @param string cell\n        A network / cell from iwlist scan.\n\n    @return string\n        The encryption type of the network.\n    \"\"\"\n\n    enc = \"\"\n    if matching_line(cell, \"Encryption key:\") == \"off\":\n        enc = \"Open\"\n    else:\n        for line in cell:\n            matching = match(line,\"IE:\")\n            if matching == None:\n                continue\n\n            wpa = match(matching,\"WPA\")\n            if wpa == None:\n                continue\n\n            version_matches = VERSION_RGX.search(wpa)\n            if len(version_matches.regs) == 1:\n                version = version_matches \\\n                    .group(0) \\\n                    .lower() \\\n                    .replace(\"version\", \"\") \\\n                    .strip()\n                wpa = wpa.replace(version_matches.group(0), \"\").strip()\n                if wpa == \"\":\n                    wpa = \"WPA\"\n                if emit_version:\n                    enc = \"{0} v.{1}\".format(wpa, version)\n                else:\n                    enc = wpa\n                if wpa == \"WPA2\":\n                    return enc\n            else:\n                enc = wpa\n        if enc == \"\":\n            enc = \"WEP\"\n    return enc"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef matching_line(lines, keyword):\n    for line in lines:\n        matching = match(line,keyword)\n        if matching != None:\n            return matching\n    return None", "response": "Returns the first matching line in a list of lines."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the first part of line that matches keyword. If the first part of line matches keyword returns the end of that line otherwise returns None.", "response": "def match(line, keyword):\n    \"\"\" If the first part of line (modulo blanks) matches keyword,\n    returns the end of that line. Otherwise checks if keyword is\n    anywhere in the line and returns that section, else returns None\"\"\"\n\n    line = line.lstrip()\n    length = len(keyword)\n    if line[:length] == keyword:\n        return line[length:]\n    else:\n        if keyword in line:\n            return line[line.index(keyword):]\n        else:\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\napply the rules to the bunch of text describing a cell.", "response": "def parse_cell(cell, rules):\n    \"\"\" Applies the rules to the bunch of text describing a cell.\n    @param string cell\n        A network / cell from iwlist scan.\n    @param dictionary rules\n        A dictionary of parse rules.\n\n    @return dictionary\n        parsed networks. \"\"\"\n\n    parsed_cell = {}\n    for key in rules:\n        rule = rules[key]\n        parsed_cell.update({key: rule(cell)})\n    return parsed_cell"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_parsed_cells(iw_data, rules=None):\n\n    # Here's a dictionary of rules that will be applied to the description\n    # of each cell. The key will be the name of the column in the table.\n    # The value is a function defined above.\n    rules = rules or {\n        \"Name\": get_name,\n        \"Quality\": get_quality,\n        \"Channel\": get_channel,\n        \"Frequency\": get_frequency,\n        \"Encryption\": get_encryption,\n        \"Address\": get_address,\n        \"Signal Level\": get_signal_level,\n        \"Noise Level\": get_noise_level,\n        \"Bit Rates\": get_bit_rates,\n        \"Mode\": get_mode,\n    }\n\n    cells = [[]]\n    parsed_cells = []\n\n    for line in iw_data:\n        cell_line = match(line, \"Cell \")\n        if cell_line != None:\n            cells.append([])\n            line = cell_line[-27:]\n        cells[-1].append(line.rstrip())\n\n    cells = cells[1:]\n\n    for cell in cells:\n        parsed_cells.append(parse_cell(cell, rules))\n\n    sort_cells(parsed_cells)\n    return parsed_cells", "response": "Parses the output of the scan and returns a list of lists of properties."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsending a request to the resource at the specified path.", "response": "def request(\n        self, method, path, data=None, files=None, json=None, params=None\n    ):\n        \"\"\"Return the json content from the resource at ``path``.\n\n        :param method: The request verb. E.g., get, post, put.\n        :param path: The path of the request. This path will be combined with\n            the ``oauth_url`` of the Requestor.\n        :param data: Dictionary, bytes, or file-like object to send in the body\n            of the request.\n        :param files: Dictionary, mapping ``filename`` to file-like object.\n        :param json: Object to be serialized to JSON in the body of the\n            request.\n        :param params: The query parameters to send with the request.\n\n        Automatically refreshes the access token if it becomes invalid and a\n        refresh token is available. Raises InvalidInvocation in such a case if\n        a refresh token is not available.\n\n        \"\"\"\n        params = deepcopy(params) or {}\n        params[\"raw_json\"] = 1\n        if isinstance(data, dict):\n            data = deepcopy(data)\n            data[\"api_type\"] = \"json\"\n            data = sorted(data.items())\n        url = urljoin(self._requestor.oauth_url, path)\n        return self._request_with_retries(\n            data=data,\n            files=files,\n            json=json,\n            method=method,\n            params=params,\n            url=url,\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef main():\n    authenticator = prawcore.TrustedAuthenticator(\n        prawcore.Requestor(\"prawcore_script_auth_example\"),\n        os.environ[\"PRAWCORE_CLIENT_ID\"],\n        os.environ[\"PRAWCORE_CLIENT_SECRET\"],\n    )\n    authorizer = prawcore.ScriptAuthorizer(\n        authenticator,\n        os.environ[\"PRAWCORE_USERNAME\"],\n        os.environ[\"PRAWCORE_PASSWORD\"],\n    )\n    authorizer.refresh()\n\n    with prawcore.session(authorizer) as session:\n        data = session.request(\"GET\", \"/api/v1/me/friends\")\n\n    for friend in data[\"data\"][\"children\"]:\n        print(friend[\"name\"])\n\n    return 0", "response": "Provide the program s entry point when directly executed."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nprovide the program s entry point when directly executed.", "response": "def main():\n    \"\"\"Provide the program's entry point when directly executed.\"\"\"\n    if len(sys.argv) != 2:\n        print(\"Usage: {} USERNAME\".format(sys.argv[0]))\n        return 1\n\n    caching_requestor = prawcore.Requestor(\n        \"prawcore_device_id_auth_example\", session=CachingSession()\n    )\n    authenticator = prawcore.TrustedAuthenticator(\n        caching_requestor,\n        os.environ[\"PRAWCORE_CLIENT_ID\"],\n        os.environ[\"PRAWCORE_CLIENT_SECRET\"],\n    )\n    authorizer = prawcore.ReadOnlyAuthorizer(authenticator)\n    authorizer.refresh()\n\n    user = sys.argv[1]\n    with prawcore.session(authorizer) as session:\n        data1 = session.request(\"GET\", \"/api/v1/user/{}/trophies\".format(user))\n\n    with prawcore.session(authorizer) as session:\n        data2 = session.request(\"GET\", \"/api/v1/user/{}/trophies\".format(user))\n\n    for trophy in data1[\"data\"][\"trophies\"]:\n        description = trophy[\"data\"][\"description\"]\n        print(\n            \"Original:\",\n            trophy[\"data\"][\"name\"]\n            + (\" ({})\".format(description) if description else \"\"),\n        )\n\n    for trophy in data2[\"data\"][\"trophies\"]:\n        description = trophy[\"data\"][\"description\"]\n        print(\n            \"Cached:\",\n            trophy[\"data\"][\"name\"]\n            + (\" ({})\".format(description) if description else \"\"),\n        )\n    print(\n        \"----\\nCached == Original:\",\n        data2[\"data\"][\"trophies\"] == data2[\"data\"][\"trophies\"],\n    )\n\n    return 0"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nperform a request or return a cached response if available.", "response": "def request(self, method, url, params=None, **kwargs):\n        \"\"\"Perform a request, or return a cached response if available.\"\"\"\n        params_key = tuple(params.items()) if params else ()\n        if method.upper() == \"GET\":\n            if (url, params_key) in self.get_cache:\n                print(\"Returning cached response for:\", method, url, params)\n                return self.get_cache[(url, params_key)]\n        result = super().request(method, url, params, **kwargs)\n        if method.upper() == \"GET\":\n            self.get_cache[(url, params_key)] = result\n            print(\"Adding entry to the cache:\", method, url, params)\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef parse_routing_info(cls, records):\n        if len(records) != 1:\n            raise RoutingProtocolError(\"Expected exactly one record\")\n        record = records[0]\n        routers = []\n        readers = []\n        writers = []\n        try:\n            servers = record[\"servers\"]\n            for server in servers:\n                role = server[\"role\"]\n                addresses = []\n                for address in server[\"addresses\"]:\n                    addresses.append(SocketAddress.parse(address, DEFAULT_PORT))\n                if role == \"ROUTE\":\n                    routers.extend(addresses)\n                elif role == \"READ\":\n                    readers.extend(addresses)\n                elif role == \"WRITE\":\n                    writers.extend(addresses)\n            ttl = record[\"ttl\"]\n        except (KeyError, TypeError):\n            raise RoutingProtocolError(\"Cannot parse routing info\")\n        else:\n            return cls(routers, readers, writers, ttl)", "response": "Parse the routing info from a getServers call and return a new RoutingTable instance."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef is_fresh(self, access_mode):\n        log_debug(\"[#0000]  C: <ROUTING> Checking table freshness for %r\", access_mode)\n        expired = self.last_updated_time + self.ttl <= self.timer()\n        has_server_for_mode = bool(access_mode == READ_ACCESS and self.readers) or bool(access_mode == WRITE_ACCESS and self.writers)\n        log_debug(\"[#0000]  C: <ROUTING> Table expired=%r\", expired)\n        log_debug(\"[#0000]  C: <ROUTING> Table routers=%r\", self.routers)\n        log_debug(\"[#0000]  C: <ROUTING> Table has_server_for_mode=%r\", has_server_for_mode)\n        return not expired and self.routers and has_server_for_mode", "response": "Return True if routing information is still usable."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef update(self, new_routing_table):\n        self.routers.replace(new_routing_table.routers)\n        self.readers.replace(new_routing_table.readers)\n        self.writers.replace(new_routing_table.writers)\n        self.last_updated_time = self.timer()\n        self.ttl = new_routing_table.ttl\n        log_debug(\"[#0000]  S: <ROUTING> table=%r\", self)", "response": "Update the current routing table with a new routing information."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef fetch_routing_info(self, address):\n        metadata = {}\n        records = []\n\n        def fail(md):\n            if md.get(\"code\") == \"Neo.ClientError.Procedure.ProcedureNotFound\":\n                raise RoutingProtocolError(\"Server {!r} does not support routing\".format(address))\n            else:\n                raise RoutingProtocolError(\"Routing support broken on server {!r}\".format(address))\n\n        try:\n            with self.acquire_direct(address) as cx:\n                _, _, server_version = (cx.server.agent or \"\").partition(\"/\")\n                # TODO 2.0: remove old routing procedure\n                if server_version and Version.parse(server_version) >= Version((3, 2)):\n                    log_debug(\"[#%04X]  C: <ROUTING> query=%r\", cx.local_port, self.routing_context or {})\n                    cx.run(\"CALL dbms.cluster.routing.getRoutingTable({context})\",\n                           {\"context\": self.routing_context}, on_success=metadata.update, on_failure=fail)\n                else:\n                    log_debug(\"[#%04X]  C: <ROUTING> query={}\", cx.local_port)\n                    cx.run(\"CALL dbms.cluster.routing.getServers\", {}, on_success=metadata.update, on_failure=fail)\n                cx.pull_all(on_success=metadata.update, on_records=records.extend)\n                cx.sync()\n                routing_info = [dict(zip(metadata.get(\"fields\", ()), values)) for values in records]\n                log_debug(\"[#%04X]  S: <ROUTING> info=%r\", cx.local_port, routing_info)\n            return routing_info\n        except RoutingProtocolError as error:\n            raise ServiceUnavailable(*error.args)\n        except ServiceUnavailable:\n            self.deactivate(address)\n            return None", "response": "Fetch routing info from a given router address."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nfetch a routing table from a given router address.", "response": "def fetch_routing_table(self, address):\n        \"\"\" Fetch a routing table from a given router address.\n\n        :param address: router address\n        :return: a new RoutingTable instance or None if the given router is\n                 currently unable to provide routing information\n        :raise ServiceUnavailable: if no writers are available\n        :raise ProtocolError: if the routing information received is unusable\n        \"\"\"\n        new_routing_info = self.fetch_routing_info(address)\n        if new_routing_info is None:\n            return None\n\n        # Parse routing info and count the number of each type of server\n        new_routing_table = RoutingTable.parse_routing_info(new_routing_info)\n        num_routers = len(new_routing_table.routers)\n        num_readers = len(new_routing_table.readers)\n        num_writers = len(new_routing_table.writers)\n\n        # No writers are available. This likely indicates a temporary state,\n        # such as leader switching, so we should not signal an error.\n        # When no writers available, then we flag we are reading in absence of writer\n        self.missing_writer = (num_writers == 0)\n\n        # No routers\n        if num_routers == 0:\n            raise RoutingProtocolError(\"No routing servers returned from server %r\" % (address,))\n\n        # No readers\n        if num_readers == 0:\n            raise RoutingProtocolError(\"No read servers returned from server %r\" % (address,))\n\n        # At least one of each is fine, so return this table\n        return new_routing_table"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef update_routing_table_from(self, *routers):\n        for router in routers:\n            new_routing_table = self.fetch_routing_table(router)\n            if new_routing_table is not None:\n                self.routing_table.update(new_routing_table)\n                return True\n        return False", "response": "Try to update the routing table with the given routers."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef update_routing_table(self):\n        # copied because it can be modified\n        existing_routers = list(self.routing_table.routers)\n\n        has_tried_initial_routers = False\n        if self.missing_writer:\n            has_tried_initial_routers = True\n            if self.update_routing_table_from(self.initial_address):\n                return\n\n        if self.update_routing_table_from(*existing_routers):\n            return\n\n        if not has_tried_initial_routers and self.initial_address not in existing_routers:\n            if self.update_routing_table_from(self.initial_address):\n                return\n\n        # None of the routers have been successful, so just fail\n        raise ServiceUnavailable(\"Unable to retrieve routing information\")", "response": "Update the routing table from the first router able to provide valid routing information."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef ensure_routing_table_is_fresh(self, access_mode):\n        if self.routing_table.is_fresh(access_mode):\n            return False\n        with self.refresh_lock:\n            if self.routing_table.is_fresh(access_mode):\n                if access_mode == READ_ACCESS:\n                    # if reader is fresh but writers is not fresh, then we are reading in absence of writer\n                    self.missing_writer = not self.routing_table.is_fresh(WRITE_ACCESS)\n                return False\n            self.update_routing_table()\n            self.update_connection_pool()\n            return True", "response": "Ensures that the routing table is fresh on entry."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ndeactivates an address from the connection pool if present remove it from the routing table and also close all idle connections to that address.", "response": "def deactivate(self, address):\n        \"\"\" Deactivate an address from the connection pool,\n        if present, remove from the routing table and also closing\n        all idle connections to that address.\n        \"\"\"\n        log_debug(\"[#0000]  C: <ROUTING> Deactivating address %r\", address)\n        # We use `discard` instead of `remove` here since the former\n        # will not fail if the address has already been removed.\n        self.routing_table.routers.discard(address)\n        self.routing_table.readers.discard(address)\n        self.routing_table.writers.discard(address)\n        log_debug(\"[#0000]  C: <ROUTING> table=%r\", self.routing_table)\n        super(RoutingConnectionPool, self).deactivate(address)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nremoving a writer from the routing table if present.", "response": "def remove_writer(self, address):\n        \"\"\" Remove a writer address from the routing table, if present.\n        \"\"\"\n        log_debug(\"[#0000]  C: <ROUTING> Removing writer %r\", address)\n        self.routing_table.writers.discard(address)\n        log_debug(\"[#0000]  C: <ROUTING> table=%r\", self.routing_table)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nhandle any cleanup related to an error occurring on a pooled connection.", "response": "def handle(self, error, connection):\n        \"\"\" Handle any cleanup or similar activity related to an error\n        occurring on a pooled connection.\n        \"\"\"\n        error_class = error.__class__\n        if error_class in (ConnectionExpired, ServiceUnavailable, DatabaseUnavailableError):\n            self.deactivate(connection.address)\n        elif error_class in (NotALeaderError, ForbiddenOnReadOnlyDatabaseError):\n            self.remove_writer(connection.address)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef point_type(name, fields, srid_map):\n\n    def srid(self):\n        try:\n            return srid_map[len(self)]\n        except KeyError:\n            return None\n\n    attributes = {\"srid\": property(srid)}\n\n    for index, subclass_field in enumerate(fields):\n\n        def accessor(self, i=index, f=subclass_field):\n            try:\n                return self[i]\n            except IndexError:\n                raise AttributeError(f)\n\n        for field_alias in {subclass_field, \"xyz\"[index]}:\n            attributes[field_alias] = property(accessor)\n\n    cls = type(name, (Point,), attributes)\n\n    with __srid_table_lock:\n        for dim, srid in srid_map.items():\n            __srid_table[srid] = (cls, dim)\n\n    return cls", "response": "Dynamically create a Point subclass."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nprovides the program s entry point when directly executed.", "response": "def main():\n    \"\"\"Provide the program's entry point when directly executed.\"\"\"\n    if len(sys.argv) != 2:\n        print(\"Usage: {} USERNAME\".format(sys.argv[0]))\n        return 1\n\n    authenticator = prawcore.TrustedAuthenticator(\n        prawcore.Requestor(\"prawcore_read_only_example\"),\n        os.environ[\"PRAWCORE_CLIENT_ID\"],\n        os.environ[\"PRAWCORE_CLIENT_SECRET\"],\n    )\n    authorizer = prawcore.ReadOnlyAuthorizer(authenticator)\n    authorizer.refresh()\n\n    user = sys.argv[1]\n    with prawcore.session(authorizer) as session:\n        data = session.request(\"GET\", \"/api/v1/user/{}/trophies\".format(user))\n\n    for trophy in data[\"data\"][\"trophies\"]:\n        description = trophy[\"data\"][\"description\"]\n        print(\n            trophy[\"data\"][\"name\"]\n            + (\" ({})\".format(description) if description else \"\")\n        )\n\n    return 0"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef main():\n    args = parse_args()\n    configure_logging(args.debug)\n\n    src_path = args.src_path\n    dest_path = args.dest_path\n    old_str1 = '\\\\\"size\\\\\":' + args.old_size\n    old_str2 = '\\\\\"size\\\\\": ' + args.old_size\n    new_str = '\\\\\"size\\\\\":' + args.new_size\n\n    logging.info('Input path: %s', src_path)\n    logging.info('Output path: %s', dest_path)\n    logging.info('old str: %s', old_str1)\n    logging.info('old str: %s', old_str2)\n    logging.info('new str: %s', new_str)\n\n    if os.path.abspath(src_path) == os.path.abspath(dest_path):\n        logging.error('source and destination directiories must be different')\n        sys.exit(1)\n\n    # Iterate over input files\n    json_files = [f for f in os.listdir(src_path) if f.endswith('.json')]\n    for filename in json_files:\n\n        in_file_path = os.path.join(src_path, filename)\n        in_file_path = os.path.join(src_path, filename)\n\n        out_file_path = os.path.join(dest_path, filename)\n        logging.info('INPUT FILE: %s',in_file_path)\n        logging.info('OUTPUT FILE: %s',out_file_path)\n        # First beautify input\n        pretty = utils.beautify(filename=in_file_path)\n\n        # Iterate the beautified json string line by line\n        pretty_replaced = utils.replace(pretty, old_str1, new_str)\n        pretty_replaced = utils.replace(pretty_replaced, old_str2, new_str)\n\n        with open(out_file_path, 'w') as output_file:\n            output_file.write(pretty_replaced)\n\n    logging.info('This is the end.')", "response": "Main function for Kibana."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nparses command line arguments from the command line", "response": "def parse_args():\n    \"\"\"Parse arguments from the command line\"\"\"\n\n    parser = argparse.ArgumentParser(description=TO_KIBANA5_DESC_MSG)\n\n    parser.add_argument('-s', '--source', dest='src_path', \\\n        required=True, help='source directory')\n    parser.add_argument('-d', '--dest', dest='dest_path', \\\n        required=True, help='destination directory')\n\n    parser.add_argument('-o', '--old-size', dest='old_size', \\\n        default='0', help='aggregation old size')\n    parser.add_argument('-n', '--new-size', dest='new_size', \\\n        default='1000', help='aggregation new size')\n\n    parser.add_argument('-g', '--debug', dest='debug',\n                        action='store_true')\n\n    return parser.parse_args()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef configure_logging(debug=False):\n    if not debug:\n        logging.basicConfig(level=logging.INFO,\n                            format=LOG_FORMAT)\n    else:\n        logging.basicConfig(level=logging.DEBUG,\n                            format=DEBUG_LOG_FORMAT)", "response": "Configure logging for the\n   ."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef graph_format(new_mem, old_mem, is_firstiteration=True):\n    if is_firstiteration:\n        output = \"  n/a   \"\n    elif new_mem - old_mem > 50000000:\n        output = \"   +++++\"\n    elif new_mem - old_mem > 20000000:\n        output = \"   ++++ \"\n    elif new_mem - old_mem > 5000000:\n        output = \"   +++  \"\n    elif new_mem - old_mem > 1000000:\n        output = \"   ++   \"\n    elif new_mem - old_mem > 50000:\n        output = \"   +    \"\n    elif old_mem - new_mem > 10000000:\n        output = \"---     \"\n    elif old_mem - new_mem > 2000000:\n        output = \" --     \"\n    elif old_mem - new_mem > 100000:\n        output = \"  -     \"\n    else:\n        output = \"        \"\n    return output", "response": "Show changes graphically in memory consumption"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_cur_mem_use():\n    # http://lwn.net/Articles/28345/\n\n    lines = open(\"/proc/meminfo\", 'r').readlines()\n    emptySpace = re.compile('[ ]+')\n    for line in lines:\n        if \"MemTotal\" in line:\n            memtotal = float(emptySpace.split(line)[1])\n        if \"SwapFree\" in line:\n            swapfree = float(emptySpace.split(line)[1])\n        if \"SwapTotal\" in line:\n            swaptotal = float(emptySpace.split(line)[1])\n        if \"MemFree\" in line:\n            memfree = float(emptySpace.split(line)[1])\n        if \"Cached\" in line and not \"SwapCached\" in line:\n            cached = float(emptySpace.split(line)[1])\n\n    ramoccup = 1.0 - (memfree + cached) / memtotal\n    if swaptotal == 0:\n        swapoccup = 0\n    else:\n        swapoccup = 1.0 - swapfree / swaptotal\n    strramoccup = str(round(ramoccup * 100.0, 1))\n    strswapoccup = str(round(swapoccup * 100.0, 1))\n\n    return float(memtotal), strramoccup, strswapoccup", "response": "return utilization of memory"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncheck if a propper Python version is used.", "response": "def check_py_version():\n    \"\"\"Check if a propper Python version is used.\"\"\"\n    try:\n        if sys.version_info >= (2, 7):\n            return\n    except:\n        pass\n    print(\" \")\n    print(\" ERROR - memtop needs python version at least 2.7\")\n    print((\"Chances are that you can install newer version from your \"\n           \"repositories, or even that you have some newer version \"\n           \"installed yet.\"))\n    print(\"(one way to find out which versions are installed is to try \"\n          \"following: 'which python2.7' , 'which python3' and so...)\")\n    print(\" \")\n    sys.exit(-1)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nprompt a single character.", "response": "def character(prompt=None, empty=False):\n    \"\"\"Prompt a single character.\n\n    Parameters\n    ----------\n    prompt : str, optional\n        Use an alternative prompt.\n    empty : bool, optional\n        Allow an empty response.\n\n    Returns\n    -------\n    str or None\n        A str if the user entered a single-character, non-empty string.\n        None if the user pressed only Enter and ``empty`` was True.\n\n    \"\"\"\n    s = _prompt_input(prompt)\n    if empty and not s:\n        return None\n    elif len(s) == 1:\n        return s\n    else:\n        return character(prompt=prompt, empty=empty)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef email(prompt=None, empty=False, mode=\"simple\"):\n    if mode == \"simple\":\n        s = _prompt_input(prompt)\n        if empty and not s:\n            return None\n        else:\n            if RE_EMAIL_SIMPLE.match(s):\n                return s\n            else:\n                return email(prompt=prompt, empty=empty, mode=mode)\n    else:\n        raise ValueError", "response": "Prompt an email address."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nprompts an integer. Parameters ---------- prompt : str, optional Use an alternative prompt. empty : bool, optional Allow an empty response. Returns ------- int or None An int if the user entered a valid integer. None if the user pressed only Enter and ``empty`` was True.", "response": "def integer(prompt=None, empty=False):\n    \"\"\"Prompt an integer.\n\n    Parameters\n    ----------\n    prompt : str, optional\n        Use an alternative prompt.\n    empty : bool, optional\n        Allow an empty response.\n\n    Returns\n    -------\n    int or None\n        An int if the user entered a valid integer.\n        None if the user pressed only Enter and ``empty`` was True.\n\n    \"\"\"\n    s = _prompt_input(prompt)\n    if empty and not s:\n        return None\n    else:\n        try:\n            return int(s)\n        except ValueError:\n            return integer(prompt=prompt, empty=empty)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef real(prompt=None, empty=False):\n    s = _prompt_input(prompt)\n    if empty and not s:\n        return None\n    else:\n        try:\n            return float(s)\n        except ValueError:\n            return real(prompt=prompt, empty=empty)", "response": "Prompt a real number."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef regex(pattern, prompt=None, empty=False, flags=0):\n    s = _prompt_input(prompt)\n    if empty and not s:\n        return None\n    else:\n        m = re.match(pattern, s, flags=flags)\n        if m:\n            return m\n        else:\n            return regex(pattern, prompt=prompt, empty=empty, flags=flags)", "response": "Prompt a string that matches a regular expression."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nprompt a string without echoing.", "response": "def secret(prompt=None, empty=False):\n    \"\"\"Prompt a string without echoing.\n\n    Parameters\n    ----------\n    prompt : str, optional\n        Use an alternative prompt.\n    empty : bool, optional\n        Allow an empty response.\n\n    Returns\n    -------\n    str or None\n        A str if the user entered a non-empty string.\n        None if the user pressed only Enter and ``empty`` was True.\n\n    Raises\n    ------\n    getpass.GetPassWarning\n        If echo free input is unavailable.\n\n    See Also\n    --------\n    getpass.getpass\n\n    \"\"\"\n    if prompt is None:\n        prompt = PROMPT\n    s = getpass.getpass(prompt=prompt)\n    if empty and not s:\n        return None\n    else:\n        if s:\n            return s\n        else:\n            return secret(prompt=prompt, empty=empty)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nprompts a string. Parameters ---------- prompt : str, optional Use an alternative prompt. empty : bool, optional Allow an empty response. Returns ------- str or None A str if the user entered a non-empty string. None if the user pressed only Enter and ``empty`` was True.", "response": "def string(prompt=None, empty=False):\n    \"\"\"Prompt a string.\n\n    Parameters\n    ----------\n    prompt : str, optional\n        Use an alternative prompt.\n    empty : bool, optional\n        Allow an empty response.\n\n    Returns\n    -------\n    str or None\n        A str if the user entered a non-empty string.\n        None if the user pressed only Enter and ``empty`` was True.\n\n    \"\"\"\n    s = _prompt_input(prompt)\n    if empty and not s:\n        return None\n    else:\n        if s:\n            return s\n        else:\n            return string(prompt=prompt, empty=empty)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _get_cache_plus_key(self):\n        key = getattr(self, '_cache_key', self.key_from_query())\n        return self._cache.cache, key", "response": "Return a cache region plus key."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the value from the cache for this query.", "response": "def get_value(self, merge=True, createfunc=None,\n                  expiration_time=None, ignore_expiration=False):\n        \"\"\"\n        Return the value from the cache for this query.\n        \"\"\"\n        cache, cache_key = self._get_cache_plus_key()\n\n        # ignore_expiration means, if the value is in the cache\n        # but is expired, return it anyway.   This doesn't make sense\n        # with createfunc, which says, if the value is expired, generate\n        # a new value.\n        assert not ignore_expiration or not createfunc, \\\n            \"Can't ignore expiration and also provide createfunc\"\n\n        if ignore_expiration or not createfunc:\n            cached_value = cache.get(cache_key,\n                                     expiration_time=expiration_time,\n                                     ignore_expiration=ignore_expiration)\n        else:\n            cached_value = cache.get(cache_key)\n            if not cached_value:\n                cached_value = createfunc()\n                cache.set(cache_key, cached_value, timeout=expiration_time)\n\n        if cached_value and merge:\n            cached_value = self.merge_result(cached_value, load=False)\n\n        return cached_value"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef set_value(self, value):\n        cache, cache_key = self._get_cache_plus_key()\n        cache.set(cache_key, value)", "response": "Set the value in the cache for this query."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngiving a Query create a cache key.", "response": "def key_from_query(self, qualifier=None):\n        \"\"\"\n        Given a Query, create a cache key.\n\n        There are many approaches to this; here we use the simplest, which is\n        to create an md5 hash of the text of the SQL statement, combined with\n        stringified versions of all the bound parameters within it.\n\n        There's a bit of a performance hit with compiling out \"query.statement\"\n        here; other approaches include setting up an explicit cache key with a\n        particular Query, then combining that with the bound parameter values.\n        \"\"\"\n        stmt = self.with_labels().statement\n        compiled = stmt.compile()\n        params = compiled.params\n\n        values = [str(compiled)]\n        for k in sorted(params):\n            values.append(repr(params[k]))\n        key = u\" \".join(values)\n        return md5(key.encode('utf8')).hexdigest()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef process_query_conditionally(self, query):\n        if query._current_path:\n            mapper, prop = query._current_path[-2:]\n            for cls in mapper.class_.__mro__:\n                k = (cls, prop.key)\n                relationship_option = self._relationship_options.get(k)\n                if relationship_option:\n                    query._cache = relationship_option\n                    break", "response": "Process a Query that is used within a lazy load."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef fit(self, t, y, dy=1, presorted=False):\n        self.t, self.y, self.dy = self._validate_inputs(t, y, dy, presorted)\n        self._fit(self.t, self.y, self.dy)\n        return self", "response": "Fit the smoother to the given time locations y and dy."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\npredict the smoothed function value at time t", "response": "def predict(self, t):\n        \"\"\"Predict the smoothed function value at time t\n\n        Parameters\n        ----------\n        t : array_like\n            Times at which to predict the result\n\n        Returns\n        -------\n        y : ndarray\n            Smoothed values at time t\n        \"\"\"\n        t = np.asarray(t)\n        return self._predict(np.ravel(t)).reshape(t.shape)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the residuals of the cross - validation for the fit data", "response": "def cv_residuals(self, cv=True):\n        \"\"\"Return the residuals of the cross-validation for the fit data\"\"\"\n        vals = self.cv_values(cv)\n        return (self.y - vals) / self.dy"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the sum of cross - validation residuals for the input data", "response": "def cv_error(self, cv=True, skip_endpoints=True):\n        \"\"\"Return the sum of cross-validation residuals for the input data\"\"\"\n        resids = self.cv_residuals(cv)\n        if skip_endpoints:\n            resids = resids[1:-1]\n        return np.mean(abs(resids))"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a generator for the ARCFOUR / RC4 pseudorandom keystream for the key provided. Keys should be byte strings or sequences of ints.", "response": "def arcfour(key, csbN=1):\n\t'''Return a generator for the ARCFOUR/RC4 pseudorandom keystream for the \n\t   key provided. Keys should be byte strings or sequences of ints.'''\n\tif isinstance(key, str):\n\t\tkey = [ord(c) for c in key]\n\ts = range(256)\n\tj = 0\n\tfor n in range(csbN):\n\t\tfor i in range(256):\n\t\t\tj = (j + s[i] + key[i % len(key)]) % 256\n\t\t\tt = s[i]\n\t\t\ts[i] = s[j]\n\t\t\ts[j] = t\n\ti = 0\n\tj = 0\n\twhile True:\n\t\ti = (i + 1) % 256\n\t\tj = (j + s[i]) % 256\n\t\tt = s[i] \n\t\ts[i] = s[j]\n\t\ts[j] = t\n\t\tyield s[(s[i] + s[j]) % 256]"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a generator for the RC4 - drop pseudorandom keystream given by the key and the number of bytes to drop passed as arguments.", "response": "def arcfour_drop(key, n=3072):\n\t'''Return a generator for the RC4-drop pseudorandom keystream given by \n\t   the key and number of bytes to drop passed as arguments. Dropped bytes\n\t   default to the more conservative 3072, NOT the SCAN default of 768.'''\n\taf = arcfour(key)\n\t[af.next() for c in range(n)]\n\treturn af"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef resolve_ssl_protocol_version(version=None):\n\tif version is None:\n\t\tprotocol_preference = ('TLSv1_2', 'TLSv1_1', 'TLSv1', 'SSLv3', 'SSLv23', 'SSLv2')\n\t\tfor protocol in protocol_preference:\n\t\t\tif hasattr(ssl, 'PROTOCOL_' + protocol):\n\t\t\t\treturn getattr(ssl, 'PROTOCOL_' + protocol)\n\t\traise RuntimeError('could not find a suitable ssl PROTOCOL_ version constant')\n\telif isinstance(version, str):\n\t\tif not hasattr(ssl, 'PROTOCOL_' + version):\n\t\t\traise ValueError('invalid ssl protocol version: ' + version)\n\t\treturn getattr(ssl, 'PROTOCOL_' + version)\n\traise TypeError(\"ssl_version() argument 1 must be str, not {0}\".format(type(version).__name__))", "response": "This function returns the protocol constant corresponding to the given SSL protocol version. If version is None then the strongest available protocol will be returned."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nbuilding an instance of the AdvancedHTTPServer class from command line arguments.", "response": "def build_server_from_argparser(description=None, server_klass=None, handler_klass=None):\n\t\"\"\"\n\tBuild a server from command line arguments. If a ServerClass or\n\tHandlerClass is specified, then the object must inherit from the\n\tcorresponding AdvancedHTTPServer base class.\n\n\t:param str description: Description string to be passed to the argument parser.\n\t:param server_klass: Alternative server class to use.\n\t:type server_klass: :py:class:`.AdvancedHTTPServer`\n\t:param handler_klass: Alternative handler class to use.\n\t:type handler_klass: :py:class:`.RequestHandler`\n\t:return: A configured server instance.\n\t:rtype: :py:class:`.AdvancedHTTPServer`\n\t\"\"\"\n\timport argparse\n\n\tdef _argp_dir_type(arg):\n\t\tif not os.path.isdir(arg):\n\t\t\traise argparse.ArgumentTypeError(\"{0} is not a valid directory\".format(repr(arg)))\n\t\treturn arg\n\n\tdef _argp_port_type(arg):\n\t\tif not arg.isdigit():\n\t\t\traise argparse.ArgumentTypeError(\"{0} is not a valid port\".format(repr(arg)))\n\t\targ = int(arg)\n\t\tif arg < 0 or arg > 65535:\n\t\t\traise argparse.ArgumentTypeError(\"{0} is not a valid port\".format(repr(arg)))\n\t\treturn arg\n\n\tdescription = (description or 'HTTP Server')\n\tserver_klass = (server_klass or AdvancedHTTPServer)\n\thandler_klass = (handler_klass or RequestHandler)\n\n\tparser = argparse.ArgumentParser(conflict_handler='resolve', description=description, fromfile_prefix_chars='@')\n\tparser.epilog = 'When a config file is specified with --config only the --log, --log-file and --password options will be used.'\n\tparser.add_argument('-c', '--conf', dest='config', type=argparse.FileType('r'), help='read settings from a config file')\n\tparser.add_argument('-i', '--ip', dest='ip', default='0.0.0.0', help='the ip address to serve on')\n\tparser.add_argument('-L', '--log', dest='loglvl', choices=('DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL'), default='INFO', help='set the logging level')\n\tparser.add_argument('-p', '--port', dest='port', default=8080, type=_argp_port_type, help='port to serve on')\n\tparser.add_argument('-v', '--version', action='version', version=parser.prog + ' Version: ' + __version__)\n\tparser.add_argument('-w', '--web-root', dest='web_root', default='.', type=_argp_dir_type, help='path to the web root directory')\n\tparser.add_argument('--log-file', dest='log_file', help='log information to a file')\n\tparser.add_argument('--no-threads', dest='use_threads', action='store_false', default=True, help='disable threading')\n\tparser.add_argument('--password', dest='password', help='password to use for basic authentication')\n\tssl_group = parser.add_argument_group('ssl options')\n\tssl_group.add_argument('--ssl-cert', dest='ssl_cert', help='the ssl cert to use')\n\tssl_group.add_argument('--ssl-key', dest='ssl_key', help='the ssl key to use')\n\tssl_group.add_argument('--ssl-version', dest='ssl_version', choices=[p[9:] for p in dir(ssl) if p.startswith('PROTOCOL_')], help='the version of ssl to use')\n\targuments = parser.parse_args()\n\n\tlogging.getLogger('').setLevel(logging.DEBUG)\n\tconsole_log_handler = logging.StreamHandler()\n\tconsole_log_handler.setLevel(getattr(logging, arguments.loglvl))\n\tconsole_log_handler.setFormatter(logging.Formatter(\"%(asctime)s %(levelname)-8s %(message)s\"))\n\tlogging.getLogger('').addHandler(console_log_handler)\n\n\tif arguments.log_file:\n\t\tmain_file_handler = logging.handlers.RotatingFileHandler(arguments.log_file, maxBytes=262144, backupCount=5)\n\t\tmain_file_handler.setLevel(logging.DEBUG)\n\t\tmain_file_handler.setFormatter(logging.Formatter(\"%(asctime)s %(name)-30s %(levelname)-10s %(message)s\"))\n\t\tlogging.getLogger('').setLevel(logging.DEBUG)\n\t\tlogging.getLogger('').addHandler(main_file_handler)\n\n\tif arguments.config:\n\t\tconfig = ConfigParser()\n\t\tconfig.readfp(arguments.config)\n\t\tserver = build_server_from_config(\n\t\t\tconfig,\n\t\t\t'server',\n\t\t\tserver_klass=server_klass,\n\t\t\thandler_klass=handler_klass\n\t\t)\n\telse:\n\t\tserver = server_klass(\n\t\t\thandler_klass,\n\t\t\taddress=(arguments.ip, arguments.port),\n\t\t\tuse_threads=arguments.use_threads,\n\t\t\tssl_certfile=arguments.ssl_cert,\n\t\t\tssl_keyfile=arguments.ssl_key,\n\t\t\tssl_version=arguments.ssl_version\n\t\t)\n\t\tserver.serve_files_root = arguments.web_root\n\n\tif arguments.password:\n\t\tserver.auth_add_creds('', arguments.password)\n\treturn server"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef build_server_from_config(config, section_name, server_klass=None, handler_klass=None):\n\tserver_klass = (server_klass or AdvancedHTTPServer)\n\thandler_klass = (handler_klass or RequestHandler)\n\tport = config.getint(section_name, 'port')\n\tweb_root = None\n\tif config.has_option(section_name, 'web_root'):\n\t\tweb_root = config.get(section_name, 'web_root')\n\n\tif config.has_option(section_name, 'ip'):\n\t\tip = config.get(section_name, 'ip')\n\telse:\n\t\tip = '0.0.0.0'\n\tssl_certfile = None\n\tif config.has_option(section_name, 'ssl_cert'):\n\t\tssl_certfile = config.get(section_name, 'ssl_cert')\n\tssl_keyfile = None\n\tif config.has_option(section_name, 'ssl_key'):\n\t\tssl_keyfile = config.get(section_name, 'ssl_key')\n\tssl_version = None\n\tif config.has_option(section_name, 'ssl_version'):\n\t\tssl_version = config.get(section_name, 'ssl_version')\n\tserver = server_klass(\n\t\thandler_klass,\n\t\taddress=(ip, port),\n\t\tssl_certfile=ssl_certfile,\n\t\tssl_keyfile=ssl_keyfile,\n\t\tssl_version=ssl_version\n\t)\n\n\tif config.has_option(section_name, 'password_type'):\n\t\tpassword_type = config.get(section_name, 'password_type')\n\telse:\n\t\tpassword_type = 'md5'\n\tif config.has_option(section_name, 'password'):\n\t\tpassword = config.get(section_name, 'password')\n\t\tif config.has_option(section_name, 'username'):\n\t\t\tusername = config.get(section_name, 'username')\n\t\telse:\n\t\t\tusername = ''\n\t\tserver.auth_add_creds(username, password, pwtype=password_type)\n\tcred_idx = 0\n\twhile config.has_option(section_name, 'password' + str(cred_idx)):\n\t\tpassword = config.get(section_name, 'password' + str(cred_idx))\n\t\tif not config.has_option(section_name, 'username' + str(cred_idx)):\n\t\t\tbreak\n\t\tusername = config.get(section_name, 'username' + str(cred_idx))\n\t\tserver.auth_add_creds(username, password, pwtype=password_type)\n\t\tcred_idx += 1\n\n\tif web_root is None:\n\t\tserver.serve_files = False\n\telse:\n\t\tserver.serve_files = True\n\t\tserver.serve_files_root = web_root\n\t\tif config.has_option(section_name, 'list_directories'):\n\t\t\tserver.serve_files_list_directories = config.getboolean(section_name, 'list_directories')\n\treturn server", "response": "Build a server instance from a configuration file."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nconfigure the serializer to use for communication with the server.", "response": "def set_serializer(self, serializer_name, compression=None):\n\t\t\"\"\"\n\t\tConfigure the serializer to use for communication with the server.\n\t\tThe serializer specified must be valid and in the\n\t\t:py:data:`.g_serializer_drivers` map.\n\n\t\t:param str serializer_name: The name of the serializer to use.\n\t\t:param str compression: The name of a compression library to use.\n\t\t\"\"\"\n\t\tself.serializer = Serializer(serializer_name, charset='UTF-8', compression=compression)\n\t\tself.logger.debug('using serializer: ' + serializer_name)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef reconnect(self):\n\t\tself.lock.acquire()\n\t\tif self.use_ssl:\n\t\t\tself.client = http.client.HTTPSConnection(self.host, self.port, context=self.ssl_context)\n\t\telse:\n\t\t\tself.client = http.client.HTTPConnection(self.host, self.port)\n\t\tself.lock.release()", "response": "Reconnect to the remote server."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nissuing a call to the remote end point to execute the specified method.", "response": "def call(self, method, *args, **kwargs):\n\t\t\"\"\"\n\t\tIssue a call to the remote end point to execute the specified\n\t\tprocedure.\n\n\t\t:param str method: The name of the remote procedure to execute.\n\t\t:return: The return value from the remote function.\n\t\t\"\"\"\n\t\tif kwargs:\n\t\t\toptions = self.encode(dict(args=args, kwargs=kwargs))\n\t\telse:\n\t\t\toptions = self.encode(args)\n\n\t\theaders = {}\n\t\tif self.headers:\n\t\t\theaders.update(self.headers)\n\t\theaders['Content-Type'] = self.serializer.content_type\n\t\theaders['Content-Length'] = str(len(options))\n\t\theaders['Connection'] = 'close'\n\n\t\tif self.username is not None and self.password is not None:\n\t\t\theaders['Authorization'] = 'Basic ' + base64.b64encode((self.username + ':' + self.password).encode('UTF-8')).decode('UTF-8')\n\n\t\tmethod = os.path.join(self.uri_base, method)\n\t\tself.logger.debug('calling RPC method: ' + method[1:])\n\t\ttry:\n\t\t\twith self.lock:\n\t\t\t\tself.client.request('RPC', method, options, headers)\n\t\t\t\tresp = self.client.getresponse()\n\t\texcept http.client.ImproperConnectionState:\n\t\t\traise RPCConnectionError('improper connection state')\n\t\tif resp.status != 200:\n\t\t\traise RPCError(resp.reason, resp.status)\n\n\t\tresp_data = resp.read()\n\t\tresp_data = self.decode(resp_data)\n\t\tif not ('exception_occurred' in resp_data and 'result' in resp_data):\n\t\t\traise RPCError('missing response information', resp.status)\n\t\tif resp_data['exception_occurred']:\n\t\t\traise RPCError('remote method incurred an exception', resp.status, remote_exception=resp_data['exception'])\n\t\treturn resp_data['result']"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef cache_call(self, method, *options):\n\t\toptions_hash = self.encode(options)\n\t\tif len(options_hash) > 20:\n\t\t\toptions_hash = hashlib.new('sha1', options_hash).digest()\n\t\toptions_hash = sqlite3.Binary(options_hash)\n\n\t\twith self.cache_lock:\n\t\t\tcursor = self.cache_db.cursor()\n\t\t\tcursor.execute('SELECT return_value FROM cache WHERE method = ? AND options_hash = ?', (method, options_hash))\n\t\t\treturn_value = cursor.fetchone()\n\t\tif return_value:\n\t\t\treturn_value = bytes(return_value[0])\n\t\t\treturn self.decode(return_value)\n\t\treturn_value = self.call(method, *options)\n\t\tstore_return_value = sqlite3.Binary(self.encode(return_value))\n\t\twith self.cache_lock:\n\t\t\tcursor = self.cache_db.cursor()\n\t\t\tcursor.execute('INSERT INTO cache (method, options_hash, return_value) VALUES (?, ?, ?)', (method, options_hash, store_return_value))\n\t\t\tself.cache_db.commit()\n\t\treturn return_value", "response": "A method that calls a remote method and stores the result locally."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncall a remote method and update the local cache with the result if it already existed. :param str method: The name of the remote procedure to execute. :return: The return value from the remote function.", "response": "def cache_call_refresh(self, method, *options):\n\t\t\"\"\"\n\t\tCall a remote method and update the local cache with the result\n\t\tif it already existed.\n\n\t\t:param str method: The name of the remote procedure to execute.\n\t\t:return: The return value from the remote function.\n\t\t\"\"\"\n\t\toptions_hash = self.encode(options)\n\t\tif len(options_hash) > 20:\n\t\t\toptions_hash = hashlib.new('sha1', options).digest()\n\t\toptions_hash = sqlite3.Binary(options_hash)\n\n\t\twith self.cache_lock:\n\t\t\tcursor = self.cache_db.cursor()\n\t\t\tcursor.execute('DELETE FROM cache WHERE method = ? AND options_hash = ?', (method, options_hash))\n\t\treturn_value = self.call(method, *options)\n\t\tstore_return_value = sqlite3.Binary(self.encode(return_value))\n\t\twith self.cache_lock:\n\t\t\tcursor = self.cache_db.cursor()\n\t\t\tcursor.execute('INSERT INTO cache (method, options_hash, return_value) VALUES (?, ?, ?)', (method, options_hash, store_return_value))\n\t\t\tself.cache_db.commit()\n\t\treturn return_value"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\npurging the local store of all cached function information.", "response": "def cache_clear(self):\n\t\t\"\"\"Purge the local store of all cached function information.\"\"\"\n\t\twith self.cache_lock:\n\t\t\tcursor = self.cache_db.cursor()\n\t\t\tcursor.execute('DELETE FROM cache')\n\t\t\tself.cache_db.commit()\n\t\tself.logger.info('the RPC cache has been purged')\n\t\treturn"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nresponding to the client by serving a file, either directly or as an attachment. :param str file_path: The path to the file to serve, this does not need to be in the web root. :param bool attachment: Whether to serve the file as a download by setting the Content-Disposition header.", "response": "def respond_file(self, file_path, attachment=False, query=None):\n\t\t\"\"\"\n\t\tRespond to the client by serving a file, either directly or as\n\t\tan attachment.\n\n\t\t:param str file_path: The path to the file to serve, this does not need to be in the web root.\n\t\t:param bool attachment: Whether to serve the file as a download by setting the Content-Disposition header.\n\t\t\"\"\"\n\t\tdel query\n\t\tfile_path = os.path.abspath(file_path)\n\t\ttry:\n\t\t\tfile_obj = open(file_path, 'rb')\n\t\texcept IOError:\n\t\t\tself.respond_not_found()\n\t\t\treturn\n\t\tself.send_response(200)\n\t\tself.send_header('Content-Type', self.guess_mime_type(file_path))\n\t\tfs = os.fstat(file_obj.fileno())\n\t\tself.send_header('Content-Length', str(fs[6]))\n\t\tif attachment:\n\t\t\tfile_name = os.path.basename(file_path)\n\t\t\tself.send_header('Content-Disposition', 'attachment; filename=' + file_name)\n\t\tself.send_header('Last-Modified', self.date_time_string(fs.st_mtime))\n\t\tself.end_headers()\n\t\tshutil.copyfileobj(file_obj, self.wfile)\n\t\tfile_obj.close()\n\t\treturn"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nrespond to the client with an HTML page listing the contents of the specified directory.", "response": "def respond_list_directory(self, dir_path, query=None):\n\t\t\"\"\"\n\t\tRespond to the client with an HTML page listing the contents of\n\t\tthe specified directory.\n\n\t\t:param str dir_path: The path of the directory to list the contents of.\n\t\t\"\"\"\n\t\tdel query\n\t\ttry:\n\t\t\tdir_contents = os.listdir(dir_path)\n\t\texcept os.error:\n\t\t\tself.respond_not_found()\n\t\t\treturn\n\t\tif os.path.normpath(dir_path) != self.__config['serve_files_root']:\n\t\t\tdir_contents.append('..')\n\t\tdir_contents.sort(key=lambda a: a.lower())\n\t\tdisplaypath = html.escape(urllib.parse.unquote(self.path), quote=True)\n\n\t\tf = io.BytesIO()\n\t\tencoding = sys.getfilesystemencoding()\n\t\tf.write(b'<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 3.2 Final//EN\">\\n')\n\t\tf.write(b'<html>\\n<title>Directory listing for ' + displaypath.encode(encoding) + b'</title>\\n')\n\t\tf.write(b'<body>\\n<h2>Directory listing for ' + displaypath.encode(encoding) + b'</h2>\\n')\n\t\tf.write(b'<hr>\\n<ul>\\n')\n\t\tfor name in dir_contents:\n\t\t\tfullname = os.path.join(dir_path, name)\n\t\t\tdisplayname = linkname = name\n\t\t\t# Append / for directories or @ for symbolic links\n\t\t\tif os.path.isdir(fullname):\n\t\t\t\tdisplayname = name + \"/\"\n\t\t\t\tlinkname = name + \"/\"\n\t\t\tif os.path.islink(fullname):\n\t\t\t\tdisplayname = name + \"@\"\n\t\t\t\t# Note: a link to a directory displays with @ and links with /\n\t\t\tf.write(('<li><a href=\"' + urllib.parse.quote(linkname) + '\">' + html.escape(displayname, quote=True) + '</a>\\n').encode(encoding))\n\t\tf.write(b'</ul>\\n<hr>\\n</body>\\n</html>\\n')\n\t\tlength = f.tell()\n\t\tf.seek(0)\n\n\t\tself.send_response(200)\n\t\tself.send_header('Content-Type', 'text/html; charset=' + encoding)\n\t\tself.send_header('Content-Length', length)\n\t\tself.end_headers()\n\t\tshutil.copyfileobj(f, self.wfile)\n\t\tf.close()\n\t\treturn"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nresponds to the client with a 301 message and redirect them with the new location header.", "response": "def respond_redirect(self, location='/'):\n\t\t\"\"\"\n\t\tRespond to the client with a 301 message and redirect them with\n\t\ta Location header.\n\n\t\t:param str location: The new location to redirect the client to.\n\t\t\"\"\"\n\t\tself.send_response(301)\n\t\tself.send_header('Content-Length', 0)\n\t\tself.send_header('Location', location)\n\t\tself.end_headers()\n\t\treturn"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nhandle an internal server error, logging a traceback if executed within an exception handler. :param int status: The status code to respond to the client with. :param str status_line: The status message to respond to the client with. :param str message: The body of the response that is sent to the client.", "response": "def respond_server_error(self, status=None, status_line=None, message=None):\n\t\t\"\"\"\n\t\tHandle an internal server error, logging a traceback if executed\n\t\twithin an exception handler.\n\n\t\t:param int status: The status code to respond to the client with.\n\t\t:param str status_line: The status message to respond to the client with.\n\t\t:param str message: The body of the response that is sent to the client.\n\t\t\"\"\"\n\t\t(ex_type, ex_value, ex_traceback) = sys.exc_info()\n\t\tif ex_type:\n\t\t\t(ex_file_name, ex_line, _, _) = traceback.extract_tb(ex_traceback)[-1]\n\t\t\tline_info = \"{0}:{1}\".format(ex_file_name, ex_line)\n\t\t\tlog_msg = \"encountered {0} in {1}\".format(repr(ex_value), line_info)\n\t\t\tself.server.logger.error(log_msg, exc_info=True)\n\t\tstatus = (status or 500)\n\t\tstatus_line = (status_line or http.client.responses.get(status, 'Internal Server Error')).strip()\n\t\tself.send_response(status, status_line)\n\t\tmessage = (message or status_line)\n\t\tif isinstance(message, (str, bytes)):\n\t\t\tself.send_header('Content-Length', len(message))\n\t\t\tself.end_headers()\n\t\t\tif isinstance(message, str):\n\t\t\t\tself.wfile.write(message.encode(sys.getdefaultencoding()))\n\t\t\telse:\n\t\t\t\tself.wfile.write(message)\n\t\telif hasattr(message, 'fileno'):\n\t\t\tfs = os.fstat(message.fileno())\n\t\t\tself.send_header('Content-Length', fs[6])\n\t\t\tself.end_headers()\n\t\t\tshutil.copyfileobj(message, self.wfile)\n\t\telse:\n\t\t\tself.end_headers()\n\t\treturn"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nrespond to the client that the request is unauthorized.", "response": "def respond_unauthorized(self, request_authentication=False):\n\t\t\"\"\"\n\t\tRespond to the client that the request is unauthorized.\n\n\t\t:param bool request_authentication: Whether to request basic authentication information by sending a WWW-Authenticate header.\n\t\t\"\"\"\n\t\theaders = {}\n\t\tif request_authentication:\n\t\t\theaders['WWW-Authenticate'] = 'Basic realm=\"' + self.__config['server_version'] + '\"'\n\t\tself.send_response_full(b'Unauthorized', status=401, headers=headers)\n\t\treturn"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ndispatches functions based on the established handler_map. It is generally not necessary to override this function and doing so will prevent any handlers from being executed. This function is executed automatically when requests of either GET, HEAD, or POST are received. :param dict query: Parsed query parameters from the corresponding request.", "response": "def dispatch_handler(self, query=None):\n\t\t\"\"\"\n\t\tDispatch functions based on the established handler_map. It is\n\t\tgenerally not necessary to override this function and doing so\n\t\twill prevent any handlers from being executed. This function is\n\t\texecuted automatically when requests of either GET, HEAD, or POST\n\t\tare received.\n\n\t\t:param dict query: Parsed query parameters from the corresponding request.\n\t\t\"\"\"\n\t\tquery = (query or {})\n\t\t# normalize the path\n\t\t# abandon query parameters\n\t\tself.path = self.path.split('?', 1)[0]\n\t\tself.path = self.path.split('#', 1)[0]\n\t\toriginal_path = urllib.parse.unquote(self.path)\n\t\tself.path = posixpath.normpath(original_path)\n\t\twords = self.path.split('/')\n\t\twords = filter(None, words)\n\t\ttmp_path = ''\n\t\tfor word in words:\n\t\t\t_, word = os.path.splitdrive(word)\n\t\t\t_, word = os.path.split(word)\n\t\t\tif word in (os.curdir, os.pardir):\n\t\t\t\tcontinue\n\t\t\ttmp_path = os.path.join(tmp_path, word)\n\t\tself.path = tmp_path\n\n\t\tif self.path == 'robots.txt' and self.__config['serve_robots_txt']:\n\t\t\tself.send_response_full(self.__config['robots_txt'])\n\t\t\treturn\n\n\t\tself.cookies = http.cookies.SimpleCookie(self.headers.get('cookie', ''))\n\t\thandler, is_method = self.__get_handler(is_rpc=False)\n\t\tif handler is not None:\n\t\t\ttry:\n\t\t\t\thandler(*((query,) if is_method else (self, query)))\n\t\t\texcept Exception:\n\t\t\t\tself.respond_server_error()\n\t\t\treturn\n\n\t\tif not self.__config['serve_files']:\n\t\t\tself.respond_not_found()\n\t\t\treturn\n\n\t\tfile_path = self.__config['serve_files_root']\n\t\tfile_path = os.path.join(file_path, tmp_path)\n\t\tif os.path.isfile(file_path) and os.access(file_path, os.R_OK):\n\t\t\tself.respond_file(file_path, query=query)\n\t\t\treturn\n\t\telif os.path.isdir(file_path) and os.access(file_path, os.R_OK):\n\t\t\tif not original_path.endswith('/'):\n\t\t\t\t# redirect browser, doing what apache does\n\t\t\t\tdestination = self.path + '/'\n\t\t\t\tif self.command == 'GET' and self.query_data:\n\t\t\t\t\tdestination += '?' + urllib.parse.urlencode(self.query_data, True)\n\t\t\t\tself.respond_redirect(destination)\n\t\t\t\treturn\n\t\t\tfor index in ['index.html', 'index.htm']:\n\t\t\t\tindex = os.path.join(file_path, index)\n\t\t\t\tif os.path.isfile(index) and os.access(index, os.R_OK):\n\t\t\t\t\tself.respond_file(index, query=query)\n\t\t\t\t\treturn\n\t\t\tif self.__config['serve_files_list_directories']:\n\t\t\t\tself.respond_list_directory(file_path, query=query)\n\t\t\t\treturn\n\t\tself.respond_not_found()\n\t\treturn"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef guess_mime_type(self, path):\n\t\t_, ext = posixpath.splitext(path)\n\t\tif ext in self.extensions_map:\n\t\t\treturn self.extensions_map[ext]\n\t\text = ext.lower()\n\t\treturn self.extensions_map[ext if ext in self.extensions_map else '']", "response": "Guess an appropriate MIME type based on the extension of the passed path."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nchecks if the credentials contained within in are valid.", "response": "def check_authorization(self):\n\t\t\"\"\"\n\t\tCheck for the presence of a basic auth Authorization header and\n\t\tif the credentials contained within in are valid.\n\n\t\t:return: Whether or not the credentials are valid.\n\t\t:rtype: bool\n\t\t\"\"\"\n\t\ttry:\n\t\t\tstore = self.__config.get('basic_auth')\n\t\t\tif store is None:\n\t\t\t\treturn True\n\t\t\tauth_info = self.headers.get('Authorization')\n\t\t\tif not auth_info:\n\t\t\t\treturn False\n\t\t\tauth_info = auth_info.split()\n\t\t\tif len(auth_info) != 2 or auth_info[0] != 'Basic':\n\t\t\t\treturn False\n\t\t\tauth_info = base64.b64decode(auth_info[1]).decode(sys.getdefaultencoding())\n\t\t\tusername = auth_info.split(':')[0]\n\t\t\tpassword = ':'.join(auth_info.split(':')[1:])\n\t\t\tpassword_bytes = password.encode(sys.getdefaultencoding())\n\t\t\tif hasattr(self, 'custom_authentication'):\n\t\t\t\tif self.custom_authentication(username, password):\n\t\t\t\t\tself.basic_auth_user = username\n\t\t\t\t\treturn True\n\t\t\t\treturn False\n\t\t\tif not username in store:\n\t\t\t\tself.server.logger.warning('received invalid username: ' + username)\n\t\t\t\treturn False\n\t\t\tpassword_data = store[username]\n\n\t\t\tif password_data['type'] == 'plain':\n\t\t\t\tif password == password_data['value']:\n\t\t\t\t\tself.basic_auth_user = username\n\t\t\t\t\treturn True\n\t\t\telif hashlib.new(password_data['type'], password_bytes).digest() == password_data['value']:\n\t\t\t\tself.basic_auth_user = username\n\t\t\t\treturn True\n\t\t\tself.server.logger.warning('received invalid password from user: ' + username)\n\t\texcept Exception:\n\t\t\tpass\n\t\treturn False"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef cookie_get(self, name):\n\t\tif not hasattr(self, 'cookies'):\n\t\t\treturn None\n\t\tif self.cookies.get(name):\n\t\t\treturn self.cookies.get(name).value\n\t\treturn None", "response": "Returns the value of a cookie by name."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef cookie_set(self, name, value):\n\t\tif not self.headers_active:\n\t\t\traise RuntimeError('headers have already been ended')\n\t\tcookie = \"{0}={1}; Path=/; HttpOnly\".format(name, value)\n\t\tself.send_header('Set-Cookie', cookie)", "response": "Set a client cookie."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_content_type_charset(self, default='UTF-8'):\n\t\tencoding = default\n\t\theader = self.headers.get('Content-Type', '')\n\t\tidx = header.find('charset=')\n\t\tif idx > 0:\n\t\t\tencoding = (header[idx + 8:].split(' ', 1)[0] or encoding)\n\t\treturn encoding", "response": "Inspect the Content - Type header to retrieve the charset that the client\n\t has specified."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef close(self):\n\t\tif not self.connected:\n\t\t\treturn\n\t\tself.connected = False\n\t\tif self.handler.wfile.closed:\n\t\t\treturn\n\t\tif select.select([], [self.handler.wfile], [], 0)[1]:\n\t\t\twith self.lock:\n\t\t\t\tself.handler.wfile.write(b'\\x88\\x00')\n\t\tself.handler.wfile.flush()\n\t\tself.on_closed()", "response": "Closes the web socket connection and stop processing results."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsending a message over the socket.", "response": "def send_message(self, opcode, message):\n\t\t\"\"\"\n\t\tSend a message to the peer over the socket.\n\n\t\t:param int opcode: The opcode for the message to send.\n\t\t:param bytes message: The message data to send.\n\t\t\"\"\"\n\t\tif not isinstance(message, bytes):\n\t\t\tmessage = message.encode('utf-8')\n\t\tlength = len(message)\n\t\tif not select.select([], [self.handler.wfile], [], 0)[1]:\n\t\t\tself.logger.error('the socket is not ready for writing')\n\t\t\tself.close()\n\t\t\treturn\n\t\tbuffer = b''\n\t\tbuffer += struct.pack('B', 0x80 + opcode)\n\t\tif length <= 125:\n\t\t\tbuffer += struct.pack('B', length)\n\t\telif 126 <= length <= 65535:\n\t\t\tbuffer += struct.pack('>BH', 126, length)\n\t\telse:\n\t\t\tbuffer += struct.pack('>BQ', 127, length)\n\t\tbuffer += message\n\t\tself._last_sent_opcode = opcode\n\t\tself.lock.acquire()\n\t\ttry:\n\t\t\tself.handler.wfile.write(buffer)\n\t\t\tself.handler.wfile.flush()\n\t\texcept Exception:\n\t\t\tself.logger.error('an error occurred while sending a message', exc_info=True)\n\t\t\tself.close()\n\t\tfinally:\n\t\t\tself.lock.release()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef on_message(self, opcode, message):\n\t\tself.logger.debug(\"processing {0} (opcode: 0x{1:02x}) message\".format(self._opcode_names.get(opcode, 'UNKNOWN'), opcode))\n\t\tif opcode == self._opcode_close:\n\t\t\tself.close()\n\t\telif opcode == self._opcode_ping:\n\t\t\tif len(message) > 125:\n\t\t\t\tself.close()\n\t\t\t\treturn\n\t\t\tself.send_message(self._opcode_pong, message)\n\t\telif opcode == self._opcode_pong:\n\t\t\tpass\n\t\telif opcode == self._opcode_binary:\n\t\t\tself.on_message_binary(message)\n\t\telif opcode == self._opcode_text:\n\t\t\ttry:\n\t\t\t\tmessage = self._decode_string(message)\n\t\t\texcept UnicodeDecodeError:\n\t\t\t\tself.logger.warning('closing connection due to invalid unicode within a text message')\n\t\t\t\tself.close()\n\t\t\telse:\n\t\t\t\tself.on_message_text(message)\n\t\telif opcode == self._opcode_continue:\n\t\t\tself.close()\n\t\telse:\n\t\t\tself.logger.warning(\"received unknown opcode: {0} (0x{0:02x})\".format(opcode))\n\t\t\tself.close()", "response": "This method is called by the WebSocket when a message is received from the server."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nbuilds a serializer object from a MIME Content - Type string.", "response": "def from_content_type(cls, content_type):\n\t\t\"\"\"\n\t\tBuild a serializer object from a MIME Content-Type string.\n\n\t\t:param str content_type: The Content-Type string to parse.\n\t\t:return: A new serializer instance.\n\t\t:rtype: :py:class:`.Serializer`\n\t\t\"\"\"\n\t\tname = content_type\n\t\toptions = {}\n\t\tif ';' in content_type:\n\t\t\tname, options_str = content_type.split(';', 1)\n\t\t\tfor part in options_str.split(';'):\n\t\t\t\tpart = part.strip()\n\t\t\t\tif '=' in part:\n\t\t\t\t\tkey, value = part.split('=')\n\t\t\t\telse:\n\t\t\t\t\tkey, value = (part, None)\n\t\t\t\toptions[key] = value\n\t\t# old style compatibility\n\t\tif name.endswith('+zlib'):\n\t\t\toptions['compression'] = 'zlib'\n\t\t\tname = name[:-5]\n\t\treturn cls(name, charset=options.get('charset', 'UTF-8'), compression=options.get('compression'))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nserialize a python object for transmission or storage.", "response": "def dumps(self, data):\n\t\t\"\"\"\n\t\tSerialize a python data type for transmission or storage.\n\n\t\t:param data: The python object to serialize.\n\t\t:return: The serialized representation of the object.\n\t\t:rtype: bytes\n\t\t\"\"\"\n\t\tdata = g_serializer_drivers[self.name]['dumps'](data)\n\t\tif sys.version_info[0] == 3 and isinstance(data, str):\n\t\t\tdata = data.encode(self._charset)\n\t\tif self._compression == 'zlib':\n\t\t\tdata = zlib.compress(data)\n\t\tassert isinstance(data, bytes)\n\t\treturn data"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nadds an SSL certificate for a specific hostname as supported by SSL s SNI server name indicator extension.", "response": "def add_sni_cert(self, hostname, ssl_certfile=None, ssl_keyfile=None, ssl_version=None):\n\t\t\"\"\"\n\t\tAdd an SSL certificate for a specific hostname as supported by SSL's\n\t\tServer Name Indicator (SNI) extension. See :rfc:`3546` for more details\n\t\ton SSL extensions. In order to use this method, the server instance must\n\t\thave been initialized with at least one address configured for SSL.\n\n\t\t.. warning::\n\n\t\t\tThis method will raise a :py:exc:`RuntimeError` if either the SNI\n\t\t\textension is not available in the :py:mod:`ssl` module or if SSL was\n\t\t\tnot enabled at initialization time through the use of arguments to\n\t\t\t:py:meth:`~.__init__`.\n\n\t\t.. versionadded:: 2.0.0\n\n\t\t:param str hostname: The hostname for this configuration.\n\t\t:param str ssl_certfile: An SSL certificate file to use, setting this enables SSL.\n\t\t:param str ssl_keyfile: An SSL certificate file to use.\n\t\t:param ssl_version: The SSL protocol version to use.\n\t\t\"\"\"\n\t\tif not g_ssl_has_server_sni:\n\t\t\traise RuntimeError('the ssl server name indicator extension is unavailable')\n\t\tif self._ssl_sni_entries is None:\n\t\t\traise RuntimeError('ssl was not enabled on initialization')\n\t\tif ssl_certfile:\n\t\t\tssl_certfile = os.path.abspath(ssl_certfile)\n\t\tif ssl_keyfile:\n\t\t\tssl_keyfile = os.path.abspath(ssl_keyfile)\n\t\tcert_info = SSLSNICertificate(hostname, ssl_certfile, ssl_keyfile)\n\t\tif ssl_version is None or isinstance(ssl_version, str):\n\t\t\tssl_version = resolve_ssl_protocol_version(ssl_version)\n\t\tssl_ctx = ssl.SSLContext(ssl_version)\n\t\tssl_ctx.load_cert_chain(ssl_certfile, keyfile=ssl_keyfile)\n\t\tself._ssl_sni_entries[hostname] = SSLSNIEntry(context=ssl_ctx, certificate=cert_info)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef remove_sni_cert(self, hostname):\n\t\tif not g_ssl_has_server_sni:\n\t\t\traise RuntimeError('the ssl server name indicator extension is unavailable')\n\t\tif self._ssl_sni_entries is None:\n\t\t\traise RuntimeError('ssl was not enabled on initialization')\n\t\tsni_entry = self._ssl_sni_entries.pop(hostname, None)\n\t\tif sni_entry is None:\n\t\t\traise ValueError('the specified hostname does not have an sni certificate configuration')", "response": "Removes the SSL Server Name Indicator ( SNI ) certificate configuration for the specified hostname."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a tuple of SSLSNICertificate instances for each of the certificates that are configured for SSL.", "response": "def sni_certs(self):\n\t\t\"\"\"\n\t\t.. versionadded:: 2.2.0\n\n\t\t:return: Return a tuple of :py:class:`~.SSLSNICertificate` instances for each of the certificates that are configured.\n\t\t:rtype: tuple\n\t\t\"\"\"\n\t\tif not g_ssl_has_server_sni or self._ssl_sni_entries is None:\n\t\t\treturn tuple()\n\t\treturn tuple(entry.certificate for entry in self._ssl_sni_entries.values())"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef serve_forever(self, fork=False):\n\t\tif fork:\n\t\t\tif not hasattr(os, 'fork'):\n\t\t\t\traise OSError('os.fork is not available')\n\t\t\tchild_pid = os.fork()\n\t\t\tif child_pid != 0:\n\t\t\t\tself.logger.info('forked child process: ' + str(child_pid))\n\t\t\t\treturn child_pid\n\t\tself.__server_thread = threading.current_thread()\n\t\tself.__wakeup_fd = WakeupFd()\n\t\tself.__is_shutdown.clear()\n\t\tself.__should_stop.clear()\n\t\tself.__is_running.set()\n\t\twhile not self.__should_stop.is_set():\n\t\t\ttry:\n\t\t\t\tself._serve_ready()\n\t\t\texcept socket.error:\n\t\t\t\tself.logger.warning('encountered socket error, stopping server')\n\t\t\t\tself.__should_stop.set()\n\t\tself.__is_shutdown.set()\n\t\tself.__is_running.clear()\n\t\treturn 0", "response": "This method is called to serve content forever."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef auth_set(self, status):\n\t\tif not bool(status):\n\t\t\tself.__config['basic_auth'] = None\n\t\t\tself.logger.info('basic authentication has been disabled')\n\t\telse:\n\t\t\tself.__config['basic_auth'] = {}\n\t\t\tself.logger.info('basic authentication has been enabled')", "response": "Enables or disables requiring authentication on all incoming requests."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ndeletes the credentials for a specific username if specified or all stored credentials.", "response": "def auth_delete_creds(self, username=None):\n\t\t\"\"\"\n\t\tDelete the credentials for a specific username if specified or all\n\t\tstored credentials.\n\n\t\t:param str username: The username of the credentials to delete.\n\t\t\"\"\"\n\t\tif not username:\n\t\t\tself.__config['basic_auth'] = {}\n\t\t\tself.logger.info('basic authentication database has been cleared of all entries')\n\t\t\treturn\n\t\tdel self.__config['basic_auth'][username]"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nadding a valid set of credentials to be accepted for authentication. Calling this function will automatically enable requiring authentication. Passwords can be provided in either plaintext or as a hash by specifying the hash type in the *pwtype* argument. :param str username: The username of the credentials to be added. :param password: The password data of the credentials to be added. :type password: bytes, str :param str pwtype: The type of the *password* data, (plain, md5, sha1, etc.).", "response": "def auth_add_creds(self, username, password, pwtype='plain'):\n\t\t\"\"\"\n\t\tAdd a valid set of credentials to be accepted for authentication.\n\t\tCalling this function will automatically enable requiring\n\t\tauthentication. Passwords can be provided in either plaintext or\n\t\tas a hash by specifying the hash type in the *pwtype* argument.\n\n\t\t:param str username: The username of the credentials to be added.\n\t\t:param password: The password data of the credentials to be added.\n\t\t:type password: bytes, str\n\t\t:param str pwtype: The type of the *password* data, (plain, md5, sha1, etc.).\n\t\t\"\"\"\n\t\tif not isinstance(password, (bytes, str)):\n\t\t\traise TypeError(\"auth_add_creds() argument 2 must be bytes or str, not {0}\".format(type(password).__name__))\n\t\tpwtype = pwtype.lower()\n\t\tif not pwtype in ('plain', 'md5', 'sha1', 'sha256', 'sha384', 'sha512'):\n\t\t\traise ValueError('invalid password type, must be \\'plain\\', or supported by hashlib')\n\t\tif self.__config.get('basic_auth') is None:\n\t\t\tself.__config['basic_auth'] = {}\n\t\t\tself.logger.info('basic authentication has been enabled')\n\t\tif pwtype != 'plain':\n\t\t\talgorithms_available = getattr(hashlib, 'algorithms_available', ()) or getattr(hashlib, 'algorithms', ())\n\t\t\tif pwtype not in algorithms_available:\n\t\t\t\traise ValueError('hashlib does not support the desired algorithm')\n\t\t\t# only md5 and sha1 hex for backwards compatibility\n\t\t\tif pwtype == 'md5' and len(password) == 32:\n\t\t\t\tpassword = binascii.unhexlify(password)\n\t\t\telif pwtype == 'sha1' and len(password) == 40:\n\t\t\t\tpassword = binascii.unhexlify(password)\n\t\t\tif not isinstance(password, bytes):\n\t\t\t\tpassword = password.encode('UTF-8')\n\t\t\tif len(hashlib.new(pwtype, b'foobar').digest()) != len(password):\n\t\t\t\traise ValueError('the length of the password hash does not match the type specified')\n\t\tself.__config['basic_auth'][username] = {'value': password, 'type': pwtype}"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef validate_inputs(*arrays, **kwargs):\n    arrays = np.broadcast_arrays(*arrays)\n    sort_by = kwargs.pop('sort_by', None)\n\n    if kwargs:\n        raise ValueError(\"unrecognized arguments: {0}\".format(kwargs.keys()))\n\n    if arrays[0].ndim != 1:\n        raise ValueError(\"Input arrays should be one-dimensional.\")\n\n    if sort_by is not None:\n        isort = np.argsort(sort_by)\n        if isort.shape != arrays[0].shape:\n            raise ValueError(\"sort shape must equal array shape.\")\n        arrays = tuple([a[isort] for a in arrays])\n    return arrays", "response": "Validate input arrays for the\nTaxonomy class."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _prep_smooth(t, y, dy, span, t_out, span_out, period):\n\n    # If period is provided, sort by phases. Otherwise sort by t\n    if period:\n        t = t % period\n        if t_out is not None:\n            t_out = t_out % period\n\n    t, y, dy = validate_inputs(t, y, dy, sort_by=t)\n\n    if span_out is not None:\n        if t_out is None:\n            raise ValueError(\"Must specify t_out when span_out is given\")\n        if span is not None:\n            raise ValueError(\"Must specify only one of span, span_out\")\n        span, t_out = np.broadcast_arrays(span_out, t_out)\n        indices = np.searchsorted(t, t_out)\n    elif span is None:\n        raise ValueError(\"Must specify either span_out or span\")\n    else:\n        indices = None\n\n    return t, y, dy, span, t_out, span_out, indices", "response": "Private function to prepare & check variables for smooth utilities"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef moving_average_smooth(t, y, dy, span=None, cv=True,\n                          t_out=None, span_out=None, period=None):\n    \"\"\"Perform a moving-average smooth of the data\n\n    Parameters\n    ----------\n    t, y, dy : array_like\n        time, value, and error in value of the input data\n    span : array_like\n        the integer spans of the data\n    cv : boolean (default=True)\n        if True, treat the problem as a cross-validation, i.e. don't use\n        each point in the evaluation of its own smoothing.\n    t_out : array_like (optional)\n        the output times for the moving averages\n    span_out : array_like (optional)\n        the spans associated with the output times t_out\n    period : float\n        if provided, then consider the inputs periodic with the given period\n\n    Returns\n    -------\n    y_smooth : array_like\n        smoothed y values at each time t (or t_out)\n    \"\"\"\n    prep = _prep_smooth(t, y, dy, span, t_out, span_out, period)\n    t, y, dy, span, t_out, span_out, indices = prep\n\n    w = 1. / (dy ** 2)\n    w, yw = windowed_sum([w, y * w], t=t, span=span, subtract_mid=cv,\n                         indices=indices, period=period)\n\n    if t_out is None or span_out is not None:\n        return yw / w\n    else:\n        i = np.minimum(len(t) - 1, np.searchsorted(t, t_out))\n        return yw[i] / w[i]", "response": "Perform a moving - average smooth of the data in a new node."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef linear_smooth(t, y, dy, span=None, cv=True,\n                  t_out=None, span_out=None, period=None):\n    \"\"\"Perform a linear smooth of the data\n\n    Parameters\n    ----------\n    t, y, dy : array_like\n        time, value, and error in value of the input data\n    span : array_like\n        the integer spans of the data\n    cv : boolean (default=True)\n        if True, treat the problem as a cross-validation, i.e. don't use\n        each point in the evaluation of its own smoothing.\n    t_out : array_like (optional)\n        the output times for the moving averages\n    span_out : array_like (optional)\n        the spans associated with the output times t_out\n    period : float\n        if provided, then consider the inputs periodic with the given period\n\n    Returns\n    -------\n    y_smooth : array_like\n        smoothed y values at each time t or t_out\n    \"\"\"\n    t_input = t\n    prep = _prep_smooth(t, y, dy, span, t_out, span_out, period)\n    t, y, dy, span, t_out, span_out, indices = prep\n    if period:\n        t_input = np.asarray(t_input) % period\n\n    w = 1. / (dy ** 2)\n    w, yw, tw, tyw, ttw = windowed_sum([w, y * w, w, y * w, w], t=t,\n                                       tpowers=[0, 0, 1, 1, 2],\n                                       span=span, indices=indices,\n                                       subtract_mid=cv, period=period)\n\n    denominator = (w * ttw - tw * tw)\n    slope = (tyw * w - tw * yw)\n    intercept = (ttw * yw - tyw * tw)\n\n    if np.any(denominator == 0):\n        raise ValueError(\"Zero denominator in linear smooth. This usually \"\n                         \"indicates that the input contains duplicate points.\")\n\n    if t_out is None:\n        return (slope * t_input + intercept) / denominator\n    elif span_out is not None:\n        return (slope * t_out + intercept) / denominator\n    else:\n        i = np.minimum(len(t) - 1, np.searchsorted(t, t_out))\n        return (slope[i] * t_out + intercept[i]) / denominator[i]", "response": "Perform a linear smoothing of the data in a new object."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef multinterp(x, y, xquery, slow=False):\n    x, y, xquery = map(np.asarray, (x, y, xquery))\n    assert x.ndim == 1\n    assert xquery.ndim == 1\n    assert y.shape == x.shape + xquery.shape\n\n    # make sure xmin < xquery < xmax in all cases\n    xquery = np.clip(xquery, x.min(), x.max())\n\n    if slow:\n        from scipy.interpolate import interp1d\n        return np.array([interp1d(x, y)(xq) for xq, y in zip(xquery, y.T)])\n    elif len(x) == 3:\n        # Most common case: use a faster approach\n        yq_lower = y[0] + (xquery - x[0]) * (y[1] - y[0]) / (x[1] - x[0])\n        yq_upper = y[1] + (xquery - x[1]) * (y[2] - y[1]) / (x[2] - x[1])\n        return np.where(xquery < x[1], yq_lower, yq_upper)\n    else:\n        i = np.clip(np.searchsorted(x, xquery, side='right') - 1,\n                    0, len(x) - 2)\n        j = np.arange(len(xquery))\n        return y[i, j] + ((xquery - x[i]) *\n                          (y[i + 1, j] - y[i, j]) / (x[i + 1] - x[i]))", "response": "Multiple linear interpolations of the log - level data structures."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _create_session(self, test_connection=False):\n        session = consulate.Session(host=self.host, port=self.port)\n        if test_connection:\n            session.status.leader()\n        return session", "response": "Create a consulate. Session object and query for its leader to ensure that the connection is made."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\napply all config values defined in consul s kv store to self. app. config", "response": "def apply_remote_config(self, namespace=None):\n        \"\"\"\n        Applies all config values defined in consul's kv store to self.app.\n\n        There is no guarantee that these values will not be overwritten later\n        elsewhere.\n\n        :param namespace: kv namespace/directory. Defaults to\n                DEFAULT_KV_NAMESPACE\n        :return: None\n        \"\"\"\n\n        if namespace is None:\n            namespace = \"config/{service}/{environment}/\".format(\n                service=os.environ.get('SERVICE', 'generic_service'),\n                environment=os.environ.get('ENVIRONMENT', 'generic_environment')\n            )\n\n        for k, v in iteritems(self.session.kv.find(namespace)):\n            k = k.replace(namespace, '')\n            try:\n                self.app.config[k] = json.loads(v)\n            except (TypeError, ValueError):\n                self.app.logger.warning(\"Couldn't de-serialize {} to json, using raw value\".format(v))\n                self.app.config[k] = v\n\n            msg = \"Set {k}={v} from consul kv '{ns}'\".format(\n                k=k,\n                v=v,\n                ns=namespace,\n            )\n            self.app.logger.debug(msg)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nregister this service with consul kwargs passed to Consul. agent. service. register", "response": "def register_service(self, **kwargs):\n        \"\"\"\n        register this service with consul\n        kwargs passed to Consul.agent.service.register\n        \"\"\"\n        kwargs.setdefault('name', self.app.name)\n        self.session.agent.service.register(**kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nquery the consul DNS server for the service IP and port and return a list of urls that can be used to create the service.", "response": "def _resolve(self):\n        \"\"\"\n        Query the consul DNS server for the service IP and port\n        \"\"\"\n        endpoints = {}\n        r = self.resolver.query(self.service, 'SRV')\n        for rec in r.response.additional:\n            name = rec.name.to_text()\n            addr = rec.items[0].address\n            endpoints[name] = {'addr': addr}\n        for rec in r.response.answer[0].items:\n            name = '.'.join(rec.target.labels)\n            endpoints[name]['port'] = rec.port\n        return [\n            'http://{ip}:{port}'.format(\n                ip=v['addr'], port=v['port']\n            ) for v in endpoints.values()\n        ]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncrop the generator to a finite number of frames Return a generator which outputs the provided generator limited to enough samples to produce seconds of audio.", "response": "def crop(gens, seconds=5, cropper=None):\n\t'''\n\tCrop the generator to a finite number of frames\n\n\tReturn a generator which outputs the provided generator limited\n\tto enough samples to produce seconds seconds of audio (default 5s)\n\tat the provided frame rate.\n\t'''\n\tif hasattr(gens, \"next\"):\n\t\t# single generator\n\t\tgens = (gens,)\n\n\tif cropper == None:\n\t\tcropper = lambda gen: itertools.islice(gen, 0, seconds * sampler.FRAME_RATE)\n\n\tcropped = [cropper(gen) for gen in gens]\n\treturn cropped[0] if len(cropped) == 1 else cropped"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef crop_at_zero_crossing(gen, seconds=5, error=0.1):\n\t'''\n\tCrop the generator, ending at a zero-crossing\n\n\tCrop the generator to produce approximately seconds seconds \n\t(default 5s) of audio at the provided FRAME_RATE, attempting \n\tto end the clip at a zero crossing point to avoid clicking. \n\t'''\n\tsource = iter(gen)\n\tbuffer_length = int(2 * error * sampler.FRAME_RATE)\n\t\n\t# split the source into two iterators:\n\t# - start, which contains the bulk of the sound clip\n\t# - and end, which contains the final 100ms, plus 100ms past \n\t#   the desired clip length. We may cut the clip anywhere \n\t#   within this +/-100ms end buffer.\n\tstart = itertools.islice(source, 0, int((seconds - error) * sampler.FRAME_RATE))\n\tend = itertools.islice(source, 0, buffer_length)\n\n\tfor sample in start:\n\t\tyield sample\n\n\t# pull end buffer generator into memory so we can work with it\n\tend = list(end)\n\n\t# find min by sorting buffer samples, first by abs of sample, then by distance from optimal\n\tbest = sorted(enumerate(end), key=lambda x: (math.fabs(x[1]),abs((buffer_length/2)-x[0])))\n\tprint best[:10]\n\tprint best[0][0]\n\n\t# todo: better logic when we don't have a perfect zero crossing\n\t#if best[0][1] != 0:\n\t#\t# we don't have a perfect zero crossing, so let's look for best fit?\n\t#\tpass\n\t\n\t# crop samples at index of best zero crossing\n\tfor sample in end[:best[0][0] + 1]:\n\t\tyield sample", "response": "Crop the generator to produce approximately seconds at a zero crossing point."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nchange the volume of gen by dB decibles.", "response": "def volume(gen, dB=0):\n\t'''Change the volume of gen by dB decibles'''\n\tif not hasattr(dB, 'next'):\n\t\t# not a generator\n\t\tscale = 10 ** (dB / 20.)\n\telse:\n\t\tdef scale_gen():\n\t\t\twhile True:\n\t\t\t\tyield 10 ** (next(dB) / 20.)\n\t\tscale = scale_gen()\n\treturn envelope(gen, scale)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nmixes `inputs` together based on `mix` tuple `inputs` should be a tuple of *n* generators. `mix` should be a tuple of *m* tuples, one per desired output channel. Each of the *m* tuples should contain *n* generators, corresponding to the time-sequence of the desired mix levels for each of the *n* input channels. That is, to make an ouput channel contain a 50/50 mix of the two input channels, the tuple would be: (constant(0.5), constant(0.5)) The mix generators need not be constant, allowing for time-varying mix levels: # 50% from input 1, pulse input 2 over a two second cycle (constant(0.5), tone(0.5)) The mixer will return a list of *m* generators, each containing the data from the inputs mixed as specified. If no `mix` tuple is specified, all of the *n* input channels will be mixed together into one generator, with the volume of each reduced *n*-fold. Example: # three in, two out; # 10Hz binaural beat with white noise across both channels mixer( (white_noise(), tone(440), tone(450)), ( (constant(.5), constant(1), constant(0)), (constant(.5), constant(0), constant(1)), ) )", "response": "def mixer(inputs, mix=None):\n\t'''\n\tMix `inputs` together based on `mix` tuple\n\n\t`inputs` should be a tuple of *n* generators. \n\n\t`mix` should be a tuple of *m* tuples, one per desired\n\toutput channel. Each of the *m* tuples should contain\n\t*n* generators, corresponding to the time-sequence of \n\tthe desired mix levels for each of the *n* input channels.\n\n\tThat is, to make an ouput channel contain a 50/50 mix of the\n\ttwo input channels, the tuple would be:\n\n\t    (constant(0.5), constant(0.5))\n\t\n\tThe mix generators need not be constant, allowing for time-varying\n\tmix levels: \n\n\t    # 50% from input 1, pulse input 2 over a two second cycle\n\t    (constant(0.5), tone(0.5))\n\n\tThe mixer will return a list of *m* generators, each containing \n\tthe data from the inputs mixed as specified. \n\n\tIf no `mix` tuple is specified, all of the *n* input channels\n\twill be mixed together into one generator, with the volume of \n\teach reduced *n*-fold.\n\n\tExample:\n\n\t    # three in, two out; \n\t    # 10Hz binaural beat with white noise across both channels\n\t    mixer(\n\t    \t\t(white_noise(), tone(440), tone(450)), \n\t    \t\t(\n\t    \t\t\t(constant(.5), constant(1), constant(0)),\n\t    \t\t\t(constant(.5), constant(0), constant(1)),\n\t    \t\t)\n\t    \t)\n\t'''\n\tif mix == None:\n\t\t# by default, mix all inputs down to one channel\n\t\tmix = ([constant(1.0 / len(inputs))] * len(inputs),)\n\n\tduped_inputs = zip(*[itertools.tee(i, len(mix)) for i in inputs])\n\n# second zip is backwards\n\treturn [\\\n\t\t\tsum(*[multiply(m,i) for m,i in zip(channel_mix, channel_inputs)])\\\n\t\t\tfor channel_mix, channel_inputs in zip(mix, duped_inputs) \\\n\t\t\t]"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef channelize(gen, channels):\n\t'''\n\tBreak multi-channel generator into one sub-generator per channel\n\n\tTakes a generator producing n-tuples of samples and returns n generators,\n\teach producing samples for a single channel.\n\n\tSince multi-channel generators are the only reasonable way to synchronize samples\n\tacross channels, and the sampler functions only take tuples of generators,\n\tyou must use this function to process synchronized streams for output.\n\t'''\n\tdef pick(g, channel):\n\t\tfor samples in g:\n\t\t\tyield samples[channel]\n\treturn [pick(gen_copy, channel) for channel, gen_copy in enumerate(itertools.tee(gen, channels))]", "response": "This function takes a generator producing n - tuples of samples and returns n - tuples of samples for a single channel."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef file_is_seekable(f):\n\t'''\n\tReturns True if file `f` is seekable, and False if not\n\t\n\tUseful to determine, for example, if `f` is STDOUT to \n\ta pipe.\n\t'''\n\ttry:\n\t\tf.tell()\n\t\tlogger.info(\"File is seekable!\")\n\texcept IOError, e:\n\t\tif e.errno == errno.ESPIPE:\n\t\t\treturn False\n\t\telse:\n\t\t\traise\n\treturn True", "response": "Returns True if file f is seekable and False otherwise."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef sample(generator, min=-1, max=1, width=SAMPLE_WIDTH):\n\t'''Convert audio waveform generator into packed sample generator.'''\n\t# select signed char, short, or in based on sample width\n\tfmt = { 1: '<B', 2: '<h', 4: '<i' }[width]\n\treturn (struct.pack(fmt, int(sample)) for sample in \\\n\t\t\tnormalize(hard_clip(generator, min, max),\\\n\t\t\t\tmin, max, -2**(width * 8 - 1), 2**(width * 8 - 1) - 1))", "response": "Convert audio waveform generator into packed sample generator."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nconverts list of audio waveform generators into list of packed sample generators.", "response": "def sample_all(generators, *args, **kwargs):\n\t'''Convert list of audio waveform generators into list of packed sample generators.'''\n\treturn [sample(gen, *args, **kwargs) for gen in  generators]"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nbuffer the generator into byte strings of buffer_size samples Return a generator that outputs reasonably sized byte strings containing buffer_size samples from the generator stream. This allows us to outputing big chunks of the audio stream to disk at once for faster writes.", "response": "def buffer(stream, buffer_size=BUFFER_SIZE):\n\t'''\n\tBuffer the generator into byte strings of buffer_size samples\n\n\tReturn a generator that outputs reasonably sized byte strings\n\tcontaining buffer_size samples from the generator stream. \n\n\tThis allows us to outputing big chunks of the audio stream to \n\tdisk at once for faster writes.\n\t'''\n\ti = iter(stream)\n\treturn iter(lambda: \"\".join(itertools.islice(i, buffer_size)), \"\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef wave_module_patched():\n\t'''True if wave module can write data size of 0xFFFFFFFF, False otherwise.'''\n\tf = StringIO()\n\tw = wave.open(f, \"wb\")\n\tw.setparams((1, 2, 44100, 0, \"NONE\", \"no compression\"))\n\tpatched = True\n\ttry:\n\t\tw.setnframes((0xFFFFFFFF - 36) / w.getnchannels() / w.getsampwidth())\n\t\tw._ensure_header_written(0)\n\texcept struct.error:\n\t\tpatched = False\n\t\tlogger.info(\"Error setting wave data size to 0xFFFFFFFF; wave module unpatched, setting sata size to 0x7FFFFFFF\")\n\t\tw.setnframes((0x7FFFFFFF - 36) / w.getnchannels() / w.getsampwidth())\n\t\tw._ensure_header_written(0)\n\treturn patched", "response": "True if wave module can write data size of 0xFFFFFFFF False otherwise."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nplay the contents of the generator using PyAudio.", "response": "def play(channels, blocking=True, raw_samples=False):\n\t'''\n\tPlay the contents of the generator using PyAudio\n\n\tPlay to the system soundcard using PyAudio. PyAudio, an otherwise optional\n\tdepenency, must be installed for this feature to work. \n\t'''\n\tif not pyaudio_loaded:\n\t\traise Exception(\"Soundcard playback requires PyAudio. Install with `pip install pyaudio`.\")\n\n\tchannel_count = 1 if hasattr(channels, \"next\") else len(channels)\n\twavgen = wav_samples(channels, raw_samples=raw_samples)\n\tp = pyaudio.PyAudio()\n\tstream = p.open(\n\t\tformat=p.get_format_from_width(SAMPLE_WIDTH),\n\t\tchannels=channel_count,\n\t\trate=FRAME_RATE,\n\t\toutput=True,\n\t\tstream_callback=_pyaudio_callback(wavgen) if not blocking else None\n\t)\n\tif blocking:\n\t\ttry:\n\t\t\tfor chunk in buffer(wavgen, 1024):\n\t\t\t\tstream.write(chunk)\n\t\texcept Exception:\n\t\t\traise\n\t\tfinally:\n\t\t\tif not stream.is_stopped():\n\t\t\t\tstream.stop_stream()\n\t\t\ttry:\n\t\t\t\tstream.close()\n\t\t\texcept Exception:\n\t\t\t\tpass\n\telse:\n\t\treturn stream"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncomputing the windowed sum of the given arrays. This is a slow function, used primarily for testing and validation of the faster version of ``windowed_sum()`` Parameters ---------- arrays : tuple of arrays arrays to window span : int or array of ints The span to use for the sum at each point. If array is provided, it must be broadcastable with ``indices`` indices : array the indices of the center of the desired windows. If ``None``, the indices are assumed to be ``range(len(arrays[0]))`` though these are not actually instantiated. t : array (optional) Times associated with the arrays tpowers : list (optional) Powers of t for each array sum period : float (optional) Period to use, if times are periodic. If supplied, input times must be arranged such that (t % period) is sorted! subtract_mid : boolean If true, then subtract the middle value from each sum Returns ------- arrays : tuple of ndarrays arrays containing the windowed sum of each input array", "response": "def windowed_sum_slow(arrays, span, t=None, indices=None, tpowers=0,\n                      period=None, subtract_mid=False):\n    \"\"\"Compute the windowed sum of the given arrays.\n\n    This is a slow function, used primarily for testing and validation\n    of the faster version of ``windowed_sum()``\n\n    Parameters\n    ----------\n    arrays : tuple of arrays\n        arrays to window\n    span : int or array of ints\n        The span to use for the sum at each point. If array is provided,\n        it must be broadcastable with ``indices``\n    indices : array\n        the indices of the center of the desired windows. If ``None``,\n        the indices are assumed to be ``range(len(arrays[0]))`` though\n        these are not actually instantiated.\n    t : array (optional)\n        Times associated with the arrays\n    tpowers : list (optional)\n        Powers of t for each array sum\n    period : float (optional)\n        Period to use, if times are periodic. If supplied, input times\n        must be arranged such that (t % period) is sorted!\n    subtract_mid : boolean\n        If true, then subtract the middle value from each sum\n\n    Returns\n    -------\n    arrays : tuple of ndarrays\n        arrays containing the windowed sum of each input array\n    \"\"\"\n    span = np.asarray(span, dtype=int)\n    if not np.all(span > 0):\n        raise ValueError(\"span values must be positive\")\n    \n    arrays = tuple(map(np.asarray, arrays))\n    N = arrays[0].size\n    if not all(a.shape == (N,) for a in arrays):\n        raise ValueError(\"sizes of provided arrays must match\")\n    \n    t_input = t\n    if t is not None:\n        t = np.asarray(t)\n        if t.shape != (N,):\n            raise ValueError(\"shape of t must match shape of arrays\")\n    else:\n        t = np.ones(N)\n    \n    tpowers = tpowers + np.zeros(len(arrays))\n    if len(tpowers) != len(arrays):\n        raise ValueError(\"tpowers must be broadcastable with number of arrays\")\n\n    if period:\n        if t_input is None:\n            raise ValueError(\"periodic requires t to be provided\")\n        t = t % period\n    \n    if indices is None:\n        indices = np.arange(N)\n    spans, indices = np.broadcast_arrays(span, indices)\n    \n    results = []\n    for tpower, array in zip(tpowers, arrays):\n        if period:\n            result = [sum(array[j % N]\n                          * (t[j % N] + (j // N) * period) ** tpower\n                          for j in range(i - s // 2,\n                                         i - s // 2 + s)\n                          if not (subtract_mid and j == i))\n                      for i, s in np.broadcast(indices, spans)]\n        else:\n            result = [sum(array[j] * t[j] ** tpower\n                          for j in range(max(0, i - s // 2),\n                                         min(N, i - s // 2 + s))\n                          if not (subtract_mid and j == i))\n                      for i, s in np.broadcast(indices, spans)]\n        results.append(np.asarray(result))\n        \n    return tuple(results)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef windowed_sum(arrays, span, t=None, indices=None, tpowers=0,\n                 period=None, subtract_mid=False):\n    \"\"\"Compute the windowed sum of the given arrays.\n\n    Parameters\n    ----------\n    arrays : tuple of arrays\n        arrays to window\n    span : int or array of ints\n        The span to use for the sum at each point. If array is provided,\n        it must be broadcastable with ``indices``\n    indices : array\n        the indices of the center of the desired windows. If ``None``,\n        the indices are assumed to be ``range(len(arrays[0]))`` though\n        these are not actually instantiated.\n    t : array (optional)\n        Times associated with the arrays\n    tpowers : list (optional)\n        Powers of t for each array sum\n    period : float (optional)\n        Period to use, if times are periodic. If supplied, input times\n        must be arranged such that (t % period) is sorted!\n    subtract_mid : boolean\n        If true, then subtract the middle value from each sum\n\n    Returns\n    -------\n    arrays : tuple of ndarrays\n        arrays containing the windowed sum of each input array\n    \"\"\"\n    span = np.asarray(span, dtype=int)\n    if not np.all(span > 0):\n        raise ValueError(\"span values must be positive\")\n    \n    arrays = tuple(map(np.asarray, arrays))\n    N = arrays[0].size\n    if not all(a.shape == (N,) for a in arrays):\n        raise ValueError(\"sizes of provided arrays must match\")\n    \n    t_input = t\n    if t is not None:\n        t = np.asarray(t)\n        if t.shape != (N,):\n            raise ValueError(\"shape of t must match shape of arrays \"\n                             \"t -> {0} arr -> {1}\".format(t.shape,\n                                                          arrays[0].shape))\n    else:\n        # XXX: special-case no t?\n        t = np.ones(N)\n    \n    tpowers = np.asarray(tpowers) + np.zeros(len(arrays))\n\n    if indices is not None:\n        span, indices = np.broadcast_arrays(span, indices)\n\n    # For the periodic case, re-call the function with padded arrays\n    if period:\n        if t_input is None:\n            raise ValueError(\"periodic requires t to be provided\")\n        t = t % period\n\n        t, arrays, sl = _pad_arrays(t, arrays, indices, span, period)\n        if len(t) > N:\n            # arrays are padded. Recursively call windowed_sum() and return.\n            if span.ndim == 0 and indices is None:\n                # fixed-span/no index case is done faster this way\n                arrs = windowed_sum(arrays, span, t=t, indices=indices,\n                                    tpowers=tpowers, period=None,\n                                    subtract_mid=subtract_mid)\n                return tuple([a[sl] for a in arrs])\n            else:\n                # this works for variable span and general indices\n                if indices is None:\n                    indices = np.arange(N)\n                indices = indices + sl.start\n                return windowed_sum(arrays, span, t=t, indices=indices,\n                                    tpowers=tpowers, period=None,\n                                    subtract_mid=subtract_mid)\n        else:\n            # No padding needed! We can carry-on as if it's a non-periodic case\n            period = None\n\n    # The rest of the algorithm now proceeds without reference to the period\n    # just as a sanity check...\n    assert not period\n\n    if span.ndim == 0:\n        # fixed-span case. Because of the checks & manipulations above\n        # we know here that indices=None\n        assert indices is None\n        window = np.ones(span)\n\n        def convolve_same(a, window):\n            if len(window) <= len(a):\n                res = np.convolve(a, window, mode='same')\n            else:\n                res = np.convolve(a, window, mode='full')\n                start = (len(window) - 1) // 2\n                res = res[start:start + len(a)]\n            return res\n        results = [convolve_same(a * t ** tp, window)\n                   for a, tp in zip(arrays, tpowers)]\n        indices = slice(None)\n\n    else:\n        # variable-span case. Use reduceat() in a clever way for speed.\n        if indices is None:\n            indices = np.arange(len(span))\n\n        # we checked this above, but just as a sanity check assert it here...\n        assert span.shape == indices.shape\n\n        mins = np.asarray(indices) - span // 2\n        results = []\n        for a, tp in zip(arrays, tpowers):\n            ranges = np.vstack([np.maximum(0, mins),\n                                np.minimum(len(a), mins+span)]).ravel('F')\n            results.append(np.add.reduceat(np.append(a * t ** tp, 0),\n                                           ranges)[::2])\n\n    # Subtract the midpoint if required: this is used in cross-validation\n    if subtract_mid:\n        results = [r - a[indices] * t[indices] ** tp\n                   for r, a, tp in zip(results, arrays, tpowers)]\n\n    return tuple(results)", "response": "Compute the windowed sum of the given arrays."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsearches all the available I2C bus numbers in the system", "response": "def get_i2c_bus_numbers(glober = glob.glob):\n        \"\"\"Search all the available I2C devices in the system\"\"\"\n        res = []\n        for device in glober(\"/dev/i2c-*\"):\n            r = re.match(\"/dev/i2c-([\\d]){1,2}\", device)\n            res.append(int(r.group(1)))\n        return res"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_led_register_from_name(self, name):\n        res = re.match('^led_([0-9]{1,2})$', name)\n        if res is None:\n            raise AttributeError(\"Unknown attribute: '%s'\" % name)\n        led_num = int(res.group(1))\n        if led_num < 0 or led_num > 15:\n            raise AttributeError(\"Unknown attribute: '%s'\" % name)\n        return self.calc_led_register(led_num)", "response": "Parse the name for the LED number and return the register number."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsetting the PWM value for the specified LED.", "response": "def set_pwm(self, led_num, value):\n        \"\"\"Set PWM value for the specified LED\n\n        :param led_num: LED number (0-15)\n        :param value: the 12 bit value (0-4095)\n        \"\"\"\n        self.__check_range('led_number', led_num)\n        self.__check_range('led_value', value)\n\n        register_low = self.calc_led_register(led_num)\n\n        self.write(register_low, value_low(value))\n        self.write(register_low + 1, value_high(value))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef sleep(self):\n        logger.debug(\"Sleep the controller\")\n        self.write(Registers.MODE_1, self.mode_1 | (1 << Mode1.SLEEP))", "response": "Send the controller to sleep"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nwrite a raw byte value to the specified register.", "response": "def write(self, reg, value):\n        \"\"\"Write raw byte value to the specified register\n\n        :param reg: the register number (0-69, 250-255)\n        :param value: byte value\n        \"\"\"\n        # TODO: check reg: 0-69, 250-255\n        self.__check_range('register_value', value)\n        logger.debug(\"Write '%s' to register '%s'\" %  (value, reg))\n        self.__bus.write_byte_data(self.__address, reg, value)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef set_pwm_frequency(self, value):\n        self.__check_range('pwm_frequency', value)\n        reg_val = self.calc_pre_scale(value)\n        logger.debug(\"Calculated prescale value is %s\" % reg_val)\n        self.sleep()\n        self.write(Registers.PRE_SCALE, reg_val)\n        self.wake()", "response": "Set the frequency for all PWM output"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncalculating the normalized Levenshtein distance between two strings", "response": "def levenshtein_norm(source, target):\n    \"\"\"Calculates the normalized Levenshtein distance between two string\n    arguments. The result will be a float in the range [0.0, 1.0], with 1.0\n    signifying the biggest possible distance between strings with these lengths\n    \"\"\"\n\n    # Compute Levenshtein distance using helper function. The max is always\n    # just the length of the longer string, so this is used to normalize result\n    # before returning it\n    distance = _levenshtein_compute(source, target, False)\n    return float(distance) / max(len(source), len(target))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef check_valid_color(color):\n    if color in list(mcolors.CSS4_COLORS.keys()) + [\"#4CB391\"]:\n        logging.info(\"Nanoplotter: Valid color {}.\".format(color))\n        return color\n    else:\n        logging.info(\"Nanoplotter: Invalid color {}, using default.\".format(color))\n        sys.stderr.write(\"Invalid color {}, using default.\\n\".format(color))\n        return \"#4CB391\"", "response": "Check if the color provided by the user is valid."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef check_valid_format(figformat):\n    fig = plt.figure()\n    if figformat in list(fig.canvas.get_supported_filetypes().keys()):\n        logging.info(\"Nanoplotter: valid output format {}\".format(figformat))\n        return figformat\n    else:\n        logging.info(\"Nanoplotter: invalid output format {}\".format(figformat))\n        sys.stderr.write(\"Invalid format {}, using default.\\n\".format(figformat))\n        return \"png\"", "response": "Check if the specified figure format is valid."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating bivariate scatter plot of x vs y.", "response": "def scatter(x, y, names, path, plots, color=\"#4CB391\", figformat=\"png\",\n            stat=None, log=False, minvalx=0, minvaly=0, title=None, plot_settings=None):\n    \"\"\"Create bivariate plots.\n\n    Create four types of bivariate plots of x vs y, containing marginal summaries\n    -A scatter plot with histograms on axes\n    -A hexagonal binned plot with histograms on axes\n    -A kernel density plot with density curves on axes\n    -A pauvre-style plot using code from https://github.com/conchoecia/pauvre\n    \"\"\"\n    logging.info(\"Nanoplotter: Creating {} vs {} plots using statistics from {} reads.\".format(\n        names[0], names[1], x.size))\n    if not contains_variance([x, y], names):\n        return []\n    sns.set(style=\"ticks\", **plot_settings)\n    maxvalx = np.amax(x)\n    maxvaly = np.amax(y)\n\n    plots_made = []\n\n    if plots[\"hex\"]:\n        hex_plot = Plot(\n            path=path + \"_hex.\" + figformat,\n            title=\"{} vs {} plot using hexagonal bins\".format(names[0], names[1]))\n        plot = sns.jointplot(\n            x=x,\n            y=y,\n            kind=\"hex\",\n            color=color,\n            stat_func=stat,\n            space=0,\n            xlim=(minvalx, maxvalx),\n            ylim=(minvaly, maxvaly),\n            height=10)\n        plot.set_axis_labels(names[0], names[1])\n        if log:\n            hex_plot.title = hex_plot.title + \" after log transformation of read lengths\"\n            ticks = [10**i for i in range(10) if not 10**i > 10 * (10**maxvalx)]\n            plot.ax_joint.set_xticks(np.log10(ticks))\n            plot.ax_marg_x.set_xticks(np.log10(ticks))\n            plot.ax_joint.set_xticklabels(ticks)\n        plt.subplots_adjust(top=0.90)\n        plot.fig.suptitle(title or \"{} vs {} plot\".format(names[0], names[1]), fontsize=25)\n        hex_plot.fig = plot\n        hex_plot.save(format=figformat)\n        plots_made.append(hex_plot)\n\n    sns.set(style=\"darkgrid\", **plot_settings)\n    if plots[\"dot\"]:\n        dot_plot = Plot(\n            path=path + \"_dot.\" + figformat,\n            title=\"{} vs {} plot using dots\".format(names[0], names[1]))\n        plot = sns.jointplot(\n            x=x,\n            y=y,\n            kind=\"scatter\",\n            color=color,\n            stat_func=stat,\n            xlim=(minvalx, maxvalx),\n            ylim=(minvaly, maxvaly),\n            space=0,\n            height=10,\n            joint_kws={\"s\": 1})\n        plot.set_axis_labels(names[0], names[1])\n        if log:\n            dot_plot.title = dot_plot.title + \" after log transformation of read lengths\"\n            ticks = [10**i for i in range(10) if not 10**i > 10 * (10**maxvalx)]\n            plot.ax_joint.set_xticks(np.log10(ticks))\n            plot.ax_marg_x.set_xticks(np.log10(ticks))\n            plot.ax_joint.set_xticklabels(ticks)\n        plt.subplots_adjust(top=0.90)\n        plot.fig.suptitle(title or \"{} vs {} plot\".format(names[0], names[1]), fontsize=25)\n        dot_plot.fig = plot\n        dot_plot.save(format=figformat)\n        plots_made.append(dot_plot)\n\n    if plots[\"kde\"]:\n        idx = np.random.choice(x.index, min(2000, len(x)), replace=False)\n        kde_plot = Plot(\n            path=path + \"_kde.\" + figformat,\n            title=\"{} vs {} plot using a kernel density estimation\".format(names[0], names[1]))\n        plot = sns.jointplot(\n            x=x[idx],\n            y=y[idx],\n            kind=\"kde\",\n            clip=((0, np.Inf), (0, np.Inf)),\n            xlim=(minvalx, maxvalx),\n            ylim=(minvaly, maxvaly),\n            space=0,\n            color=color,\n            stat_func=stat,\n            shade_lowest=False,\n            height=10)\n        plot.set_axis_labels(names[0], names[1])\n        if log:\n            kde_plot.title = kde_plot.title + \" after log transformation of read lengths\"\n            ticks = [10**i for i in range(10) if not 10**i > 10 * (10**maxvalx)]\n            plot.ax_joint.set_xticks(np.log10(ticks))\n            plot.ax_marg_x.set_xticks(np.log10(ticks))\n            plot.ax_joint.set_xticklabels(ticks)\n        plt.subplots_adjust(top=0.90)\n        plot.fig.suptitle(title or \"{} vs {} plot\".format(names[0], names[1]), fontsize=25)\n        kde_plot.fig = plot\n        kde_plot.save(format=figformat)\n        plots_made.append(kde_plot)\n\n    if plots[\"pauvre\"] and names == ['Read lengths', 'Average read quality'] and log is False:\n        pauvre_plot = Plot(\n            path=path + \"_pauvre.\" + figformat,\n            title=\"{} vs {} plot using pauvre-style @conchoecia\".format(names[0], names[1]))\n        sns.set(style=\"white\", **plot_settings)\n        margin_plot(df=pd.DataFrame({\"length\": x, \"meanQual\": y}),\n                    Y_AXES=False,\n                    title=title or \"Length vs Quality in Pauvre-style\",\n                    plot_maxlen=None,\n                    plot_minlen=0,\n                    plot_maxqual=None,\n                    plot_minqual=0,\n                    lengthbin=None,\n                    qualbin=None,\n                    BASENAME=\"whatever\",\n                    path=pauvre_plot.path,\n                    fileform=[figformat],\n                    dpi=600,\n                    TRANSPARENT=True,\n                    QUIET=True)\n        plots_made.append(pauvre_plot)\n    plt.close(\"all\")\n    return plots_made"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef contains_variance(arrays, names):\n    for ar, name in zip(arrays, names):\n        if np.std(ar) == 0:\n            sys.stderr.write(\n                \"No variation in '{}', skipping bivariate plots.\\n\".format(name.lower()))\n            logging.info(\"Nanoplotter: No variation in {}, skipping bivariate plot\".format(name))\n            return False\n    else:\n        return True", "response": "Check if a set of arrays contains a variance."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncreates histogram of normal and log transformed read lengths.", "response": "def length_plots(array, name, path, title=None, n50=None, color=\"#4CB391\", figformat=\"png\"):\n    \"\"\"Create histogram of normal and log transformed read lengths.\"\"\"\n    logging.info(\"Nanoplotter: Creating length plots for {}.\".format(name))\n    maxvalx = np.amax(array)\n    if n50:\n        logging.info(\"Nanoplotter: Using {} reads with read length N50 of {}bp and maximum of {}bp.\"\n                     .format(array.size, n50, maxvalx))\n    else:\n        logging.info(\"Nanoplotter: Using {} reads maximum of {}bp.\".format(array.size, maxvalx))\n\n    plots = []\n    HistType = namedtuple('HistType', 'weight name ylabel')\n    for h_type in [HistType(None, \"\", \"Number of reads\"),\n                   HistType(array, \"Weighted \", \"Number of bases\")]:\n        histogram = Plot(\n            path=path + h_type.name.replace(\" \", \"_\") + \"Histogram\"\n            + name.replace(' ', '') + \".\" + figformat,\n            title=h_type.name + \"Histogram of read lengths\")\n        ax = sns.distplot(\n            a=array,\n            kde=False,\n            hist=True,\n            bins=max(round(int(maxvalx) / 500), 10),\n            color=color,\n            hist_kws=dict(weights=h_type.weight,\n                          edgecolor=color,\n                          linewidth=0.2,\n                          alpha=0.8))\n        if n50:\n            plt.axvline(n50)\n            plt.annotate('N50', xy=(n50, np.amax([h.get_height() for h in ax.patches])), size=8)\n        ax.set(\n            xlabel='Read length',\n            ylabel=h_type.ylabel,\n            title=title or histogram.title)\n        plt.ticklabel_format(style='plain', axis='y')\n        histogram.fig = ax.get_figure()\n        histogram.save(format=figformat)\n        plt.close(\"all\")\n\n        log_histogram = Plot(\n            path=path + h_type.name.replace(\" \", \"_\") + \"LogTransformed_Histogram\"\n            + name.replace(' ', '') + \".\" + figformat,\n            title=h_type.name + \"Histogram of read lengths after log transformation\")\n        ax = sns.distplot(\n            a=np.log10(array),\n            kde=False,\n            hist=True,\n            color=color,\n            hist_kws=dict(weights=h_type.weight,\n                          edgecolor=color,\n                          linewidth=0.2,\n                          alpha=0.8))\n        ticks = [10**i for i in range(10) if not 10**i > 10 * maxvalx]\n        ax.set(\n            xticks=np.log10(ticks),\n            xticklabels=ticks,\n            xlabel='Read length',\n            ylabel=h_type.ylabel,\n            title=title or log_histogram.title)\n        if n50:\n            plt.axvline(np.log10(n50))\n            plt.annotate('N50', xy=(np.log10(n50), np.amax(\n                [h.get_height() for h in ax.patches])), size=8)\n        plt.ticklabel_format(style='plain', axis='y')\n        log_histogram.fig = ax.get_figure()\n        log_histogram.save(format=figformat)\n        plt.close(\"all\")\n        plots.extend([histogram, log_histogram])\n    plots.append(yield_by_minimal_length_plot(array=array,\n                                              name=name,\n                                              path=path,\n                                              title=title,\n                                              color=color,\n                                              figformat=figformat))\n    return plots"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef make_layout(maxval):\n    if maxval > 512:\n        return Layout(\n            structure=np.concatenate([np.array([list(range(10 * i + 1, i * 10 + 11))\n                                                for i in range(25)]) + j\n                                      for j in range(0, 3000, 250)],\n                                     axis=1),\n            template=np.zeros((25, 120)),\n            xticks=range(1, 121),\n            yticks=range(1, 26))\n    else:\n        layoutlist = []\n        for i, j in zip(\n                [33, 481, 417, 353, 289, 225, 161, 97],\n                [8, 456, 392, 328, 264, 200, 136, 72]):\n            for n in range(4):\n                layoutlist.append(list(range(i + n * 8, (i + n * 8) + 8, 1)) +\n                                  list(range(j + n * 8, (j + n * 8) - 8, -1)))\n        return Layout(\n            structure=np.array(layoutlist).transpose(),\n            template=np.zeros((16, 32)),\n            xticks=range(1, 33),\n            yticks=range(1, 17))", "response": "Make the physical layout of the MinION flowcell."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates a heatmap of the number of reads generated per channel using the number of reads generated per channel.", "response": "def spatial_heatmap(array, path, title=None, color=\"Greens\", figformat=\"png\"):\n    \"\"\"Taking channel information and creating post run channel activity plots.\"\"\"\n    logging.info(\"Nanoplotter: Creating heatmap of reads per channel using {} reads.\"\n                 .format(array.size))\n    activity_map = Plot(\n        path=path + \".\" + figformat,\n        title=\"Number of reads generated per channel\")\n    layout = make_layout(maxval=np.amax(array))\n    valueCounts = pd.value_counts(pd.Series(array))\n    for entry in valueCounts.keys():\n        layout.template[np.where(layout.structure == entry)] = valueCounts[entry]\n    plt.figure()\n    ax = sns.heatmap(\n        data=pd.DataFrame(layout.template, index=layout.yticks, columns=layout.xticks),\n        xticklabels=\"auto\",\n        yticklabels=\"auto\",\n        square=True,\n        cbar_kws={\"orientation\": \"horizontal\"},\n        cmap=color,\n        linewidths=0.20)\n    ax.set_title(title or activity_map.title)\n    activity_map.fig = ax.get_figure()\n    activity_map.save(format=figformat)\n    plt.close(\"all\")\n    return [activity_map]"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef main(database_dir, target_dir):\n    if not os.path.isdir(database_dir):\n        raise click.ClickException(\"Database directory does not exist!\")\n    try:\n        os.makedirs(target_dir)\n    except:\n        pass\n    try:\n        parse(database_dir, target_dir)\n    except CronosException as ex:\n        raise click.ClickException(ex.message)", "response": "Generate CSV files from a CronosPro database."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nchecking if the data is within a given timeframe and sort it if so.", "response": "def check_valid_time_and_sort(df, timescol, days=5, warning=True):\n    \"\"\"Check if the data contains reads created within the same `days` timeframe.\n\n    if not, print warning and only return part of the data which is within `days` days\n    Resetting the index twice to get also an \"index\" column for plotting the cum_yield_reads plot\n    \"\"\"\n    timediff = (df[timescol].max() - df[timescol].min()).days\n    if timediff < days:\n        return df.sort_values(timescol).reset_index(drop=True).reset_index()\n    else:\n        if warning:\n            sys.stderr.write(\n                \"\\nWarning: data generated is from more than {} days.\\n\".format(str(days)))\n            sys.stderr.write(\"Likely this indicates you are combining multiple runs.\\n\")\n            sys.stderr.write(\n                \"Plots based on time are invalid and therefore truncated to first {} days.\\n\\n\"\n                .format(str(days)))\n            logging.warning(\"Time plots truncated to first {} days: invalid timespan: {} days\"\n                            .format(str(days), str(timediff)))\n        return df[df[timescol] < timedelta(days=days)] \\\n            .sort_values(timescol) \\\n            .reset_index(drop=True) \\\n            .reset_index()"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncreates a sequence of time - vs - quality and cumulative yield plots.", "response": "def time_plots(df, path, title=None, color=\"#4CB391\", figformat=\"png\",\n               log_length=False, plot_settings=None):\n    \"\"\"Making plots of time vs read length, time vs quality and cumulative yield.\"\"\"\n    dfs = check_valid_time_and_sort(df, \"start_time\")\n    logging.info(\"Nanoplotter: Creating timeplots using {} reads.\".format(len(dfs)))\n    cumyields = cumulative_yield(dfs=dfs.set_index(\"start_time\"),\n                                 path=path,\n                                 figformat=figformat,\n                                 title=title,\n                                 color=color)\n    reads_pores_over_time = plot_over_time(dfs=dfs.set_index(\"start_time\"),\n                                           path=path,\n                                           figformat=figformat,\n                                           title=title,\n                                           color=color)\n    violins = violin_plots_over_time(dfs=dfs,\n                                     path=path,\n                                     figformat=figformat,\n                                     title=title,\n                                     log_length=log_length,\n                                     plot_settings=plot_settings)\n    return cumyields + reads_pores_over_time + violins"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef violin_or_box_plot(df, y, figformat, path, y_name,\n                       title=None, plot=\"violin\", log=False, palette=None):\n    \"\"\"Create a violin or boxplot from the received DataFrame.\n\n    The x-axis should be divided based on the 'dataset' column,\n    the y-axis is specified in the arguments\n    \"\"\"\n    comp = Plot(path=path + \"NanoComp_\" + y.replace(' ', '_') + '.' + figformat,\n                title=\"Comparing {}\".format(y))\n    if y == \"quals\":\n        comp.title = \"Comparing base call quality scores\"\n\n    if plot == 'violin':\n        logging.info(\"Nanoplotter: Creating violin plot for {}.\".format(y))\n        process_violin_and_box(ax=sns.violinplot(x=\"dataset\",\n                                                 y=y,\n                                                 data=df,\n                                                 inner=None,\n                                                 cut=0,\n                                                 palette=palette,\n                                                 linewidth=0),\n                               log=log,\n                               plot_obj=comp,\n                               title=title,\n                               y_name=y_name,\n                               figformat=figformat,\n                               ymax=np.amax(df[y]))\n    elif plot == 'box':\n        logging.info(\"Nanoplotter: Creating box plot for {}.\".format(y))\n        process_violin_and_box(ax=sns.boxplot(x=\"dataset\",\n                                              y=y,\n                                              data=df,\n                                              palette=palette),\n                               log=log,\n                               plot_obj=comp,\n                               title=title,\n                               y_name=y_name,\n                               figformat=figformat,\n                               ymax=np.amax(df[y]))\n    elif plot == 'ridge':\n        logging.info(\"Nanoplotter: Creating ridges plot for {}.\".format(y))\n        comp.fig, axes = joypy.joyplot(df,\n                                       by=\"dataset\",\n                                       column=y,\n                                       title=title or comp.title,\n                                       x_range=[-0.05, np.amax(df[y])])\n        if log:\n            xticks = [float(i.get_text()) for i in axes[-1].get_xticklabels()]\n            axes[-1].set_xticklabels([10**i for i in xticks])\n        axes[-1].set_xticklabels(axes[-1].get_xticklabels(), rotation=30, ha='center')\n        comp.save(format=figformat)\n    else:\n        logging.error(\"Unknown comp plot type {}\".format(plot))\n        sys.exit(\"Unknown comp plot type {}\".format(plot))\n    plt.close(\"all\")\n    return [comp]", "response": "Create a violin or boxplot from a DataFrame."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate barplots based on number of reads and total sum of nucleotides sequenced.", "response": "def output_barplot(df, figformat, path, title=None, palette=None):\n    \"\"\"Create barplots based on number of reads and total sum of nucleotides sequenced.\"\"\"\n    logging.info(\"Nanoplotter: Creating barplots for number of reads and total throughput.\")\n    read_count = Plot(path=path + \"NanoComp_number_of_reads.\" + figformat,\n                      title=\"Comparing number of reads\")\n    ax = sns.countplot(x=\"dataset\",\n                       data=df,\n                       palette=palette)\n    ax.set(ylabel='Number of reads',\n           title=title or read_count.title)\n    plt.xticks(rotation=30, ha='center')\n    read_count.fig = ax.get_figure()\n    read_count.save(format=figformat)\n    plt.close(\"all\")\n\n    throughput_bases = Plot(path=path + \"NanoComp_total_throughput.\" + figformat,\n                            title=\"Comparing throughput in gigabases\")\n    if \"aligned_lengths\" in df:\n        throughput = df.groupby('dataset')['aligned_lengths'].sum()\n        ylabel = 'Total gigabase aligned'\n    else:\n        throughput = df.groupby('dataset')['lengths'].sum()\n        ylabel = 'Total gigabase sequenced'\n    ax = sns.barplot(x=list(throughput.index),\n                     y=throughput / 1e9,\n                     palette=palette,\n                     order=df[\"dataset\"].unique())\n    ax.set(ylabel=ylabel,\n           title=title or throughput_bases.title)\n    plt.xticks(rotation=30, ha='center')\n    throughput_bases.fig = ax.get_figure()\n    throughput_bases.save(format=figformat)\n    plt.close(\"all\")\n    return read_count, throughput_bases"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncreates an overlay of length histograms", "response": "def overlay_histogram(df, path, palette=None):\n    \"\"\"\n    Use plotly to create an overlay of length histograms\n    Return html code, but also save as png\n\n    Only has 10 colors, which get recycled up to 5 times.\n    \"\"\"\n    if palette is None:\n        palette = plotly.colors.DEFAULT_PLOTLY_COLORS * 5\n\n    hist = Plot(path=path + \"NanoComp_OverlayHistogram.html\",\n                title=\"Histogram of read lengths\")\n    hist.html, hist.fig = plot_overlay_histogram(df, palette, title=hist.title)\n    hist.save()\n\n    hist_norm = Plot(path=path + \"NanoComp_OverlayHistogram_Normalized.html\",\n                     title=\"Normalized histogram of read lengths\")\n    hist_norm.html, hist_norm.fig = plot_overlay_histogram(\n        df, palette, title=hist_norm.title, histnorm=\"probability\")\n    hist_norm.save()\n\n    log_hist = Plot(path=path + \"NanoComp_OverlayLogHistogram.html\",\n                    title=\"Histogram of log transformed read lengths\")\n    log_hist.html, log_hist.fig = plot_log_histogram(df, palette, title=log_hist.title)\n    log_hist.save()\n\n    log_hist_norm = Plot(path=path + \"NanoComp_OverlayLogHistogram_Normalized.html\",\n                         title=\"Normalized histogram of log transformed read lengths\")\n    log_hist_norm.html, log_hist_norm.fig = plot_log_histogram(\n        df, palette, title=log_hist_norm.title, histnorm=\"probability\")\n    log_hist_norm.save()\n\n    return [hist, hist_norm, log_hist, log_hist_norm]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nplot a log histogram of the length of the dataset.", "response": "def plot_log_histogram(df, palette, title, histnorm=\"\"):\n    \"\"\"\n    Plot overlaying histograms with log transformation of length\n    Return both html and fig for png\n    \"\"\"\n    data = [go.Histogram(x=np.log10(df.loc[df[\"dataset\"] == d, \"lengths\"]),\n                         opacity=0.4,\n                         name=d,\n                         histnorm=histnorm,\n                         marker=dict(color=c))\n            for d, c in zip(df[\"dataset\"].unique(), palette)]\n    xtickvals = [10**i for i in range(10) if not 10**i > 10 * np.amax(df[\"lengths\"])]\n    html = plotly.offline.plot(\n        {\"data\": data,\n         \"layout\": go.Layout(barmode='overlay',\n                             title=title,\n                             xaxis=dict(tickvals=np.log10(xtickvals),\n                                        ticktext=xtickvals))},\n        output_type=\"div\",\n        show_link=False)\n    fig = go.Figure(\n        {\"data\": data,\n         \"layout\": go.Layout(barmode='overlay',\n                             title=title,\n                             xaxis=dict(tickvals=np.log10(xtickvals),\n                                        ticktext=xtickvals))})\n    return html, fig"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nparses a cronos database into CSV files in the out_folder.", "response": "def parse(db_folder, out_folder):\n    \"\"\"\n    Parse a cronos database.\n\n    Convert the database located in ``db_folder`` into CSV files in the\n    directory ``out_folder``.\n    \"\"\"\n    # The database structure, containing table and column definitions as\n    # well as other data.\n    stru_dat = get_file(db_folder, 'CroStru.dat')\n    # Index file for the database, which contains offsets for each record.\n    data_tad = get_file(db_folder, 'CroBank.tad')\n    # Actual data records, can only be decoded using CroBank.tad.\n    data_dat = get_file(db_folder, 'CroBank.dat')\n    if None in [stru_dat, data_tad, data_dat]:\n        raise CronosException(\"Not all database files are present.\")\n\n    meta, tables = parse_structure(stru_dat)\n\n    for table in tables:\n        # TODO: do we want to export the \"FL\" table?\n        if table['abbr'] == 'FL' and table['name'] == 'Files':\n            continue\n        fh = open(make_csv_file_name(meta, table, out_folder), 'w')\n        columns = table.get('columns')\n        writer = csv.writer(fh)\n        writer.writerow([encode_cell(c['name']) for c in columns])\n        for row in parse_data(data_tad, data_dat, table.get('id'), columns):\n            writer.writerow([encode_cell(c) for c in row])\n        fh.close()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef encode1(self):\n        data_uri = b64encode(open(self.path, 'rb').read()).decode('utf-8').replace('\\n', '')\n        return '<img src=\"data:image/png;base64,{0}\">'.format(data_uri)", "response": "Return the base64 encoding of the figure file and insert in html image tag."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the base64 encoding of the fig attribute and insert in html image tag.", "response": "def encode2(self):\n        \"\"\"Return the base64 encoding of the fig attribute and insert in html image tag.\"\"\"\n        buf = BytesIO()\n        self.fig.savefig(buf, format='png', bbox_inches='tight', dpi=100)\n        buf.seek(0)\n        string = b64encode(buf.read())\n        return '<img src=\"data:image/png;base64,{0}\">'.format(urlquote(string))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef rdlevenshtein_norm(source, target):\n\n    # Compute restricted Damerau-Levenshtein distance using helper function.\n    # The max is always just the length of the longer string, so this is used\n    # to normalize result before returning it\n    distance = _levenshtein_compute(source, target, True)\n    return float(distance) / max(len(source), len(target))", "response": "Calculates the normalized restricted Damerau - Levenshtein distance between two strings"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _levenshtein_compute(source, target, rd_flag):\n\n    # Create matrix of correct size (this is s_len + 1 * t_len + 1 so that the\n    # empty prefixes \"\" can also be included). The leftmost column represents\n    # transforming various source prefixes into an empty string, which can\n    # always be done by deleting all characters in the respective prefix, and\n    # the top row represents transforming the empty string into various target\n    # prefixes, which can always be done by inserting every character in the\n    # respective prefix. The ternary used to build the list should ensure that\n    # this row and column are now filled correctly\n    s_range = range(len(source) + 1)\n    t_range = range(len(target) + 1)\n    matrix = [[(i if j == 0 else j) for j in t_range] for i in s_range]\n\n    # Iterate through rest of matrix, filling it in with Levenshtein\n    # distances for the remaining prefix combinations\n    for i in s_range[1:]:\n        for j in t_range[1:]:\n            # Applies the recursive logic outlined above using the values\n            # stored in the matrix so far. The options for the last pair of\n            # characters are deletion, insertion, and substitution, which\n            # amount to dropping the source character, the target character,\n            # or both and then calculating the distance for the resulting\n            # prefix combo. If the characters at this point are the same, the\n            # situation can be thought of as a free substitution\n            del_dist = matrix[i - 1][j] + 1\n            ins_dist = matrix[i][j - 1] + 1\n            sub_trans_cost = 0 if source[i - 1] == target[j - 1] else 1\n            sub_dist = matrix[i - 1][j - 1] + sub_trans_cost\n\n            # Choose option that produces smallest distance\n            matrix[i][j] = min(del_dist, ins_dist, sub_dist)\n\n            # If restricted Damerau-Levenshtein was requested via the flag,\n            # then there may be a fourth option: transposing the current and\n            # previous characters in the source string. This can be thought of\n            # as a double substitution and has a similar free case, where the\n            # current and preceeding character in both strings is the same\n            if rd_flag and i > 1 and j > 1 and source[i - 1] == target[j - 2] \\\n                    and source[i - 2] == target[j - 1]:\n                trans_dist = matrix[i - 2][j - 2] + sub_trans_cost\n                matrix[i][j] = min(matrix[i][j], trans_dist)\n\n    # At this point, the matrix is full, and the biggest prefixes are just the\n    # strings themselves, so this is the desired distance\n    return matrix[len(source)][len(target)]", "response": "Compute the Levenshtein distance between two Unicode strings."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef main():\n    if sys.version_info < (2, 7):\n        sys.exit('crispy requires at least Python 2.7')\n    elif sys.version_info[0] == 3 and sys.version_info < (3, 4):\n        sys.exit('crispy requires at least Python 3.4')\n\n    kwargs = dict(\n        name='crispy',\n        version=get_version(),\n        description='Core-Level Spectroscopy Simulations in Python',\n        long_description=get_readme(),\n        license='MIT',\n        author='Marius Retegan',\n        author_email='marius.retegan@esrf.eu',\n        url='https://github.com/mretegan/crispy',\n        download_url='https://github.com/mretegan/crispy/releases',\n        keywords='gui, spectroscopy, simulation, synchrotron, science',\n        install_requires=get_requirements(),\n        platforms=[\n            'MacOS :: MacOS X',\n            'Microsoft :: Windows',\n            'POSIX :: Linux',\n        ],\n        packages=[\n            'crispy',\n            'crispy.gui',\n            'crispy.gui.uis',\n            'crispy.gui.icons',\n            'crispy.modules',\n            'crispy.modules.quanty',\n            'crispy.modules.orca',\n            'crispy.utils',\n        ],\n        package_data={\n            'crispy.gui.uis': [\n                '*.ui',\n                'quanty/*.ui',\n            ],\n            'crispy.gui.icons': [\n                '*.svg',\n            ],\n            'crispy.modules.quanty': [\n                'parameters/*.json.gz',\n                'templates/*.lua',\n            ],\n        },\n        classifiers=[\n            'Development Status :: 4 - Beta',\n            'Environment :: X11 Applications :: Qt',\n            'Intended Audience :: Education',\n            'Intended Audience :: Science/Research',\n            'License :: OSI Approved :: MIT License',\n            'Operating System :: MacOS :: MacOS X',\n            'Operating System :: Microsoft :: Windows',\n            'Operating System :: POSIX :: Linux',\n            'Programming Language :: Python :: 2.7',\n            'Programming Language :: Python :: 3.4',\n            'Programming Language :: Python :: 3.5',\n            'Programming Language :: Python :: 3.6',\n            'Programming Language :: Python :: 3.7',\n            'Topic :: Scientific/Engineering :: Visualization',\n        ]\n    )\n\n    # At the moment pip/setuptools doesn't play nice with shebang paths\n    # containing white spaces.\n    # See: https://github.com/pypa/pip/issues/2783\n    #      https://github.com/xonsh/xonsh/issues/879\n    # The most straight forward workaround is to have a .bat script to run\n    # crispy on Windows.\n\n    if 'win32' in sys.platform:\n        kwargs['scripts'] = ['scripts/crispy.bat']\n    else:\n        kwargs['scripts'] = ['scripts/crispy']\n\n    setup(**kwargs)", "response": "The main entry point of the crispy module."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef loadFromDisk(self, calculation):\n\n        suffixes = {\n            'Isotropic': 'iso',\n            'Circular Dichroism (R-L)': 'cd',\n            'Right Polarized (R)': 'r',\n            'Left Polarized (L)': 'l',\n            'Linear Dichroism (V-H)': 'ld',\n            'Vertical Polarized (V)': 'v',\n            'Horizontal Polarized (H)': 'h',\n        }\n\n        self.raw = list()\n        for spectrumName in self.toPlot:\n            suffix = suffixes[spectrumName]\n            path = '{}_{}.spec'.format(calculation.baseName, suffix)\n\n            try:\n                data = np.loadtxt(path, skiprows=5)\n            except (OSError, IOError) as e:\n                raise e\n\n            rows, columns = data.shape\n\n            if calculation.experiment in ['XAS', 'XPS', 'XES']:\n\n                xMin = calculation.xMin\n                xMax = calculation.xMax\n                xNPoints = calculation.xNPoints\n\n                if calculation.experiment == 'XES':\n                    x = np.linspace(xMin, xMax, xNPoints + 1)\n                    x = x[::-1]\n                    y = data[:, 2]\n                    y = y / np.abs(y.max())\n                else:\n                    x = np.linspace(xMin, xMax, xNPoints + 1)\n                    y = data[:, 2::2].flatten()\n\n                spectrum = Spectrum1D(x, y)\n                spectrum.name = spectrumName\n                if len(suffix) > 2:\n                    spectrum.shortName = suffix.title()\n                else:\n                    spectrum.shortName = suffix.upper()\n\n                if calculation.experiment in ['XAS', ]:\n                    spectrum.xLabel = 'Absorption Energy (eV)'\n                elif calculation.experiment in ['XPS', ]:\n                    spectrum.xLabel = 'Binding Energy (eV)'\n                elif calculation.experiment in ['XES', ]:\n                    spectrum.xLabel = 'Emission Energy (eV)'\n                spectrum.yLabel = 'Intensity (a.u.)'\n\n                self.broadenings = {'gaussian': (calculation.xGaussian, ), }\n            else:\n                xMin = calculation.xMin\n                xMax = calculation.xMax\n                xNPoints = calculation.xNPoints\n\n                yMin = calculation.yMin\n                yMax = calculation.yMax\n                yNPoints = calculation.yNPoints\n\n                x = np.linspace(xMin, xMax, xNPoints + 1)\n                y = np.linspace(yMin, yMax, yNPoints + 1)\n                z = data[:, 2::2]\n\n                spectrum = Spectrum2D(x, y, z)\n                spectrum.name = spectrumName\n                if len(suffix) > 2:\n                    spectrum.shortName = suffix.title()\n                else:\n                    spectrum.shortName = suffix.upper()\n\n                spectrum.xLabel = 'Incident Energy (eV)'\n                spectrum.yLabel = 'Energy Transfer (eV)'\n\n                self.broadenings = {'gaussian': (calculation.xGaussian,\n                                                 calculation.yGaussian), }\n\n            self.raw.append(spectrum)\n\n        # Process the spectra once they where read from disk.\n        self.process()", "response": "Read the spectra from the disk and store them in the object."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\npopulate the widget with the data stored in the state object.", "response": "def populateWidget(self):\n        \"\"\"\n        Populate the widget using data stored in the state\n        object. The order in which the individual widgets are populated\n        follows their arrangment.\n\n        The models are recreated every time the function is called.\n        This might seem to be an overkill, but in practice it is very fast.\n        Don't try to move the model creation outside this function; is not\n        worth the effort, and there is nothing to gain from it.\n        \"\"\"\n        self.elementComboBox.setItems(self.state._elements, self.state.element)\n        self.chargeComboBox.setItems(self.state._charges, self.state.charge)\n        self.symmetryComboBox.setItems(\n            self.state._symmetries, self.state.symmetry)\n        self.experimentComboBox.setItems(\n            self.state._experiments, self.state.experiment)\n        self.edgeComboBox.setItems(self.state._edges, self.state.edge)\n\n        self.temperatureLineEdit.setValue(self.state.temperature)\n        self.magneticFieldLineEdit.setValue(self.state.magneticField)\n\n        self.axesTabWidget.setTabText(0, str(self.state.xLabel))\n        self.xMinLineEdit.setValue(self.state.xMin)\n        self.xMaxLineEdit.setValue(self.state.xMax)\n        self.xNPointsLineEdit.setValue(self.state.xNPoints)\n        self.xLorentzianLineEdit.setList(self.state.xLorentzian)\n        self.xGaussianLineEdit.setValue(self.state.xGaussian)\n\n        self.k1LineEdit.setVector(self.state.k1)\n        self.eps11LineEdit.setVector(self.state.eps11)\n        self.eps12LineEdit.setVector(self.state.eps12)\n\n        if self.state.experiment in ['RIXS', ]:\n            if self.axesTabWidget.count() == 1:\n                tab = self.axesTabWidget.findChild(QWidget, 'yTab')\n                self.axesTabWidget.addTab(tab, tab.objectName())\n                self.axesTabWidget.setTabText(1, self.state.yLabel)\n            self.yMinLineEdit.setValue(self.state.yMin)\n            self.yMaxLineEdit.setValue(self.state.yMax)\n            self.yNPointsLineEdit.setValue(self.state.yNPoints)\n            self.yLorentzianLineEdit.setList(self.state.yLorentzian)\n            self.yGaussianLineEdit.setValue(self.state.yGaussian)\n            self.k2LineEdit.setVector(self.state.k2)\n            self.eps21LineEdit.setVector(self.state.eps21)\n            self.eps22LineEdit.setVector(self.state.eps22)\n            text = self.eps11Label.text()\n            text = re.sub('>[v\u03c3]', '>\u03c3', text)\n            self.eps11Label.setText(text)\n            text = self.eps12Label.text()\n            text = re.sub('>[h\u03c0]', '>\u03c0', text)\n            self.eps12Label.setText(text)\n        else:\n            self.axesTabWidget.removeTab(1)\n            text = self.eps11Label.text()\n            text = re.sub('>[v\u03c3]', '>v', text)\n            self.eps11Label.setText(text)\n            text = self.eps12Label.text()\n            text = re.sub('>[h\u03c0]', '>h', text)\n            self.eps12Label.setText(text)\n\n        # Create the spectra selection model.\n        self.spectraModel = SpectraModel(parent=self)\n        self.spectraModel.setModelData(\n            self.state.spectra.toCalculate,\n            self.state.spectra.toCalculateChecked)\n        self.spectraModel.checkStateChanged.connect(\n            self.updateSpectraCheckState)\n        self.spectraListView.setModel(self.spectraModel)\n        self.spectraListView.selectionModel().setCurrentIndex(\n            self.spectraModel.index(0, 0), QItemSelectionModel.Select)\n\n        self.fkLineEdit.setValue(self.state.fk)\n        self.gkLineEdit.setValue(self.state.gk)\n        self.zetaLineEdit.setValue(self.state.zeta)\n\n        # Create the Hamiltonian model.\n        self.hamiltonianModel = HamiltonianModel(parent=self)\n        self.hamiltonianModel.setModelData(self.state.hamiltonianData)\n        self.hamiltonianModel.setNodesCheckState(self.state.hamiltonianState)\n        if self.syncParametersCheckBox.isChecked():\n            self.hamiltonianModel.setSyncState(True)\n        else:\n            self.hamiltonianModel.setSyncState(False)\n        self.hamiltonianModel.dataChanged.connect(self.updateHamiltonianData)\n        self.hamiltonianModel.itemCheckStateChanged.connect(\n            self.updateHamiltonianNodeCheckState)\n\n        # Assign the Hamiltonian model to the Hamiltonian terms view.\n        self.hamiltonianTermsView.setModel(self.hamiltonianModel)\n        self.hamiltonianTermsView.selectionModel().setCurrentIndex(\n            self.hamiltonianModel.index(0, 0), QItemSelectionModel.Select)\n        self.hamiltonianTermsView.selectionModel().selectionChanged.connect(\n            self.selectedHamiltonianTermChanged)\n\n        # Assign the Hamiltonian model to the Hamiltonian parameters view.\n        self.hamiltonianParametersView.setModel(self.hamiltonianModel)\n        self.hamiltonianParametersView.expandAll()\n        self.hamiltonianParametersView.resizeAllColumnsToContents()\n        self.hamiltonianParametersView.setColumnWidth(0, 130)\n        self.hamiltonianParametersView.setRootIndex(\n            self.hamiltonianTermsView.currentIndex())\n\n        self.nPsisLineEdit.setValue(self.state.nPsis)\n        self.nPsisAutoCheckBox.setChecked(self.state.nPsisAuto)\n        self.nConfigurationsLineEdit.setValue(self.state.nConfigurations)\n\n        self.nConfigurationsLineEdit.setEnabled(False)\n        name = '{}-Ligands Hybridization'.format(self.state.block)\n        for termName in self.state.hamiltonianData:\n            if name in termName:\n                termState = self.state.hamiltonianState[termName]\n                if termState == 0:\n                    continue\n                else:\n                    self.nConfigurationsLineEdit.setEnabled(True)\n\n        if not hasattr(self, 'resultsModel'):\n            # Create the results model.\n            self.resultsModel = ResultsModel(parent=self)\n            self.resultsModel.itemNameChanged.connect(\n                self.updateCalculationName)\n            self.resultsModel.itemCheckStateChanged.connect(\n                self.updatePlotWidget)\n            self.resultsModel.dataChanged.connect(self.updatePlotWidget)\n            self.resultsModel.dataChanged.connect(self.updateResultsView)\n\n            # Assign the results model to the results view.\n            self.resultsView.setModel(self.resultsModel)\n            self.resultsView.selectionModel().selectionChanged.connect(\n                self.selectedResultsChanged)\n            self.resultsView.resizeColumnsToContents()\n            self.resultsView.horizontalHeader().setSectionsMovable(False)\n            self.resultsView.horizontalHeader().setSectionsClickable(False)\n            if sys.platform == 'darwin':\n                self.resultsView.horizontalHeader().setMaximumHeight(17)\n\n            # Add a context menu to the view.\n            self.resultsView.setContextMenuPolicy(Qt.CustomContextMenu)\n            self.resultsView.customContextMenuRequested[QPoint].connect(\n                self.showResultsContextMenu)\n\n        if not hasattr(self, 'resultDetailsDialog'):\n            self.resultDetailsDialog = QuantyResultDetailsDialog(parent=self)\n\n        self.updateMainWindowTitle(self.state.baseName)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nupdating the results view to contain only the result specified by the index.", "response": "def updateResultsView(self, index):\n        \"\"\"\n        Update the selection to contain only the result specified by\n        the index. This should be the last index of the model. Finally updade\n        the context menu.\n\n        The selectionChanged signal is used to trigger the update of\n        the Quanty dock widget and result details dialog.\n\n        :param index: Index of the last item of the model.\n        :type index: QModelIndex\n        \"\"\"\n\n        flags = (QItemSelectionModel.Clear | QItemSelectionModel.Rows |\n                 QItemSelectionModel.Select)\n        self.resultsView.selectionModel().select(index, flags)\n        self.resultsView.resizeColumnsToContents()\n        self.resultsView.setFocus()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef updatePlotWidget(self):\n        pw = self.getPlotWidget()\n        pw.reset()\n\n        results = self.resultsModel.getCheckedItems()\n\n        for result in results:\n            if isinstance(result, ExperimentalData):\n                spectrum = result.spectra['Expt']\n                spectrum.legend = '{}-{}'.format(result.index, 'Expt')\n                spectrum.xLabel = 'X'\n                spectrum.yLabel = 'Y'\n                spectrum.plot(plotWidget=pw)\n            else:\n                if len(results) > 1 and result.experiment in ['RIXS', ]:\n                    continue\n                for spectrum in result.spectra.processed:\n                    spectrum.legend = '{}-{}'.format(\n                        result.index, spectrum.shortName)\n                    if spectrum.name in result.spectra.toPlotChecked:\n                        spectrum.plot(plotWidget=pw)", "response": "Updates the plotting widget should not require any information about the current state of the widget."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef row(self):\n        if self.parent is not None:\n            children = self.parent.getChildren()\n            # The index method of the list object.\n            return children.index(self)\n        else:\n            return 0", "response": "Return the row of the child."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the index of the item in the model specified by the given row column and parent index.", "response": "def index(self, row, column, parent=QModelIndex()):\n        \"\"\"Return the index of the item in the model specified by the\n        given row, column, and parent index.\n        \"\"\"\n        if parent is not None and not parent.isValid():\n            parentItem = self.rootItem\n        else:\n            parentItem = self.item(parent)\n\n        childItem = parentItem.child(row)\n\n        if childItem:\n            index = self.createIndex(row, column, childItem)\n        else:\n            index = QModelIndex()\n\n        return index"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef parent(self, index):\n        childItem = self.item(index)\n        parentItem = childItem.parent\n\n        if parentItem == self.rootItem:\n            parentIndex = QModelIndex()\n        else:\n            parentIndex = self.createIndex(parentItem.row(), 0, parentItem)\n\n        return parentIndex", "response": "Return the index of the parent for a given index of the\n            child."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef rowCount(self, parentIndex):\n        if parentIndex.column() > 0:\n            return 0\n\n        if not parentIndex.isValid():\n            parentItem = self.rootItem\n        else:\n            parentItem = self.item(parentIndex)\n\n        return parentItem.childCount()", "response": "Return the number of rows under the given parent."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef data(self, index, role):\n        if not index.isValid():\n            return\n\n        item = self.item(index)\n        column = index.column()\n        value = item.getItemData(column)\n\n        if role == Qt.DisplayRole:\n            try:\n                if column == 1:\n                    # Display small values using scientific notation.\n                    if abs(float(value)) < 1e-3 and float(value) != 0.0:\n                        return '{0:8.1e}'.format(value)\n                    else:\n                        return '{0:8.3f}'.format(value)\n                else:\n                    return '{0:8.2f}'.format(value)\n            except ValueError:\n                return value\n        elif role == Qt.EditRole:\n            try:\n                value = float(value)\n                if abs(value) < 1e-3 and value != 0.0:\n                    return str('{0:8.1e}'.format(value))\n                else:\n                    return str('{0:8.3f}'.format(value))\n            except ValueError:\n                return str(value)\n        elif role == Qt.CheckStateRole:\n            if item.parent == self.rootItem and column == 0:\n                return item.getCheckState()\n        elif role == Qt.TextAlignmentRole:\n            if column > 0:\n                return Qt.AlignRight", "response": "Return the data for the item referred by index."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsets the role data for the item at index to value.", "response": "def setData(self, index, value, role):\n        \"\"\"Set the role data for the item at index to value.\"\"\"\n        if not index.isValid():\n            return False\n\n        item = self.item(index)\n        column = index.column()\n\n        if role == Qt.EditRole:\n            items = list()\n            items.append(item)\n\n            if self.sync:\n                parentIndex = self.parent(index)\n                # Iterate over the siblings of the parent index.\n                for sibling in self.siblings(parentIndex):\n                    siblingNode = self.item(sibling)\n                    for child in siblingNode.children:\n                        if child.getItemData(0) == item.getItemData(0):\n                            items.append(child)\n\n            for item in items:\n                columnData = str(item.getItemData(column))\n                if columnData and columnData != value:\n                    try:\n                        item.setItemData(column, float(value))\n                    except ValueError:\n                        return False\n                else:\n                    return False\n\n        elif role == Qt.CheckStateRole:\n            item.setCheckState(value)\n            if value == Qt.Unchecked or value == Qt.Checked:\n                state = value\n                self.itemCheckStateChanged.emit(index, state)\n\n        self.dataChanged.emit(index, index)\n\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef flags(self, index):\n        activeFlags = (Qt.ItemIsEnabled | Qt.ItemIsSelectable |\n                       Qt.ItemIsUserCheckable)\n\n        item = self.item(index)\n        column = index.column()\n\n        if column > 0 and not item.childCount():\n            activeFlags = activeFlags | Qt.ItemIsEditable\n\n        return activeFlags", "response": "Return the active flags for the given index. Add editable\n        flag to items other than the first column."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the data contained in the model.", "response": "def _getModelData(self, modelData, parentItem=None):\n        \"\"\"Return the data contained in the model.\"\"\"\n        if parentItem is None:\n            parentItem = self.rootItem\n\n        for item in parentItem.getChildren():\n            key = item.getItemData(0)\n            if item.childCount():\n                modelData[key] = odict()\n                self._getModelData(modelData[key], item)\n            else:\n                if isinstance(item.getItemData(2), float):\n                    modelData[key] = [item.getItemData(1), item.getItemData(2)]\n                else:\n                    modelData[key] = item.getItemData(1)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the check state of all items in a parent item.", "response": "def getNodesCheckState(self, parentItem=None):\n        \"\"\"Return the check state (disabled, tristate, enable) of all items\n        belonging to a parent.\n        \"\"\"\n        if parentItem is None:\n            parentItem = self.rootItem\n\n        checkStates = odict()\n        children = parentItem.getChildren()\n\n        for child in children:\n            checkStates[child.itemData[0]] = child.getCheckState()\n\n        return checkStates"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef calc_hexversion(major=0, minor=0, micro=0, releaselevel='dev', serial=0):\n    try:\n        releaselevel = int(releaselevel)\n    except ValueError:\n        releaselevel = RELEASE_LEVEL_VALUE.get(releaselevel, 0)\n\n    hex_version = int(serial)\n    hex_version |= releaselevel * 1 << 4\n    hex_version |= int(micro) * 1 << 8\n    hex_version |= int(minor) * 1 << 16\n    hex_version |= int(major) * 1 << 24\n    return hex_version", "response": "Calculate the hexadecimal version number from the tuple version_info."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating the context menu at the mouse position relative to the plot area.", "response": "def _contextMenu(self, pos):\n        \"\"\"Handle plot area customContextMenuRequested signal.\n\n        :param QPoint pos: Mouse position relative to plot area\n        \"\"\"\n        # Create the context menu.\n        menu = QMenu(self)\n        menu.addAction(self._zoomBackAction)\n\n        # Displaying the context menu at the mouse position requires\n        # a global position.\n        # The position received as argument is relative to PlotWidget's\n        # plot area, and thus needs to be converted.\n        plotArea = self.getWidgetHandle()\n        globalPosition = plotArea.mapToGlobal(pos)\n        menu.exec_(globalPosition)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef convolve_fft(array, kernel):\n\n    array = np.asarray(array, dtype=np.complex)\n    kernel = np.asarray(kernel, dtype=np.complex)\n\n    if array.ndim != kernel.ndim:\n        raise ValueError(\"Image and kernel must have same number of \"\n                         \"dimensions\")\n\n    array_shape = array.shape\n    kernel_shape = kernel.shape\n    new_shape = np.array(array_shape) + np.array(kernel_shape)\n\n    array_slices = []\n    kernel_slices = []\n    for (new_dimsize, array_dimsize, kernel_dimsize) in zip(\n            new_shape, array_shape, kernel_shape):\n        center = new_dimsize - (new_dimsize + 1) // 2\n        array_slices += [slice(center - array_dimsize // 2,\n                         center + (array_dimsize + 1) // 2)]\n        kernel_slices += [slice(center - kernel_dimsize // 2,\n                          center + (kernel_dimsize + 1) // 2)]\n\n    array_slices = tuple(array_slices)\n    kernel_slices = tuple(kernel_slices)\n\n    if not np.all(new_shape == array_shape):\n        big_array = np.zeros(new_shape, dtype=np.complex)\n        big_array[array_slices] = array\n    else:\n        big_array = array\n\n    if not np.all(new_shape == kernel_shape):\n        big_kernel = np.zeros(new_shape, dtype=np.complex)\n        big_kernel[kernel_slices] = kernel\n    else:\n        big_kernel = kernel\n\n    array_fft = np.fft.fftn(big_array)\n    kernel_fft = np.fft.fftn(np.fft.ifftshift(big_kernel))\n\n    rifft = np.fft.ifftn(array_fft * kernel_fft)\n\n    return rifft[array_slices].real", "response": "Convolve an array with a kernel using FFT."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncalculates the Euler angles only if the rotation matrix has positive determinant.", "response": "def euler_angles_and_eigenframes(self):\n        '''Calculate the Euler angles only if the rotation matrix\n           (eigenframe) has positive determinant.'''\n        signs = np.array([[1, 1, 1], [-1, 1, 1], [1, -1, 1],\n                          [1, 1, -1], [-1, -1, 1], [-1, 1, -1],\n                          [1, -1, -1], [-1, -1, -1]])\n        eulangs = []\n        eigframes = []\n        for i, sign in enumerate(signs):\n            eigframe = np.dot(self.eigvecs, np.diag(sign))\n            if np.linalg.det(eigframe) > 1e-4:\n                eigframes.append(np.array(eigframe))\n                eulangs.append(np.array(\n                    transformations.euler_from_matrix(eigframe, axes='szyz')))\n\n        self.eigframes = np.array(eigframes)\n        # The sign has to be inverted to be consistent with ORCA and EasySpin.\n        self.eulangs = -np.array(eulangs)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nskip a number of lines from the output.", "response": "def _skip_lines(self, n):\n        '''Skip a number of lines from the output.'''\n        for i in range(n):\n            self.line = next(self.output)\n        return self.line"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef parse(self):\n        '''Iterate over the lines and extract the required data.'''\n        for self.line in self.output:\n            # Parse general data: charge, multiplicity, coordinates, etc.\n            self.index = 0\n\n            if self.line[1:13] == 'Total Charge':\n                tokens = self.line.split()\n                self.charge = int(tokens[-1])\n\n            if (self.line[1:13] or self.line[0:12]) == 'Multiplicity':\n                tokens = self.line.split()\n                self.multiplicity = int(tokens[-1])\n\n            if self.line[0:33] == 'CARTESIAN COORDINATES (ANGSTROEM)':\n                if not hasattr(self, 'names'):\n                    self.names = dict()\n                if not hasattr(self, 'coords'):\n                    self.coords = dict()\n                self.line = self._skip_lines(2)\n                names = list()\n                coords = list()\n                while self.line.strip():\n                    tokens = self.line.split()\n                    names.append(tokens[0])\n                    x = float(tokens[1])\n                    y = float(tokens[2])\n                    z = float(tokens[3])\n                    coords.append((x, y, z))\n                    self.line = next(self.output)\n                self.names = np.array(names)\n                self.coords[self.index] = np.array(coords)\n\n            if self.line[22:50] == 'MULLIKEN POPULATION ANALYSIS':\n                if not hasattr(self, 'populations'):\n                    self.populations = dict()\n                self.line = self._skip_lines(6)\n                populations = list()\n                while self.line.strip() and 'Sum' not in self.line:\n                    tokens = self.line.split()\n                    populations.append((float(tokens[-2]), float(tokens[-1])))\n                    self.line = next(self.output)\n                self.populations['mulliken'][self.index] = np.array(populations) # noqa\n\n            # Parse data from the EPR/NMR module\n            if self.line[37:44] == 'EPR/NMR':\n                self.eprnmr = dict()\n\n            if self.line[0:19] == 'ELECTRONIC G-MATRIX':\n                self.line = self._skip_lines(4)\n                self.eprnmr['g']['tensor'] = self._parse_tensor()\n\n            if self.line[0:27] == 'ZERO-FIELD-SPLITTING TENSOR':\n                self.line = self._skip_lines(4)\n                self.eprnmr['zfs']['tensor'] = self._parse_tensor()\n\n            if self.line[1:8] == 'Nucleus':\n                tokens = self.line.split()\n                nucleus = int(re.findall(r'\\d+', tokens[1])[0])\n                while 'Raw HFC' not in self.line:\n                    self.line = self._skip_lines(1)\n                self.line = self._skip_lines(2)\n                self.eprnmr['hfc'][nucleus]['tensor'] = self._parse_tensor()\n                self.line = self._skip_lines(1)\n                self.eprnmr['hfc'][nucleus]['fc'] = self._parse_components()\n                self.eprnmr['hfc'][nucleus]['sd'] = self._parse_components()\n                self.line = self._skip_lines(1)\n                self.eprnmr['hfc'][nucleus]['orb'] = self._parse_components()\n                self.eprnmr['hfc'][nucleus]['dia'] = self._parse_components()\n\n            # Parse data from the MRCI module\n            if self.line[36:43] == 'M R C I':\n                self.mrci = dict()\n\n            if self.line[1:19] == 'SPIN-SPIN COUPLING':\n                self.line = self._skip_lines(4)\n                self.mrci['zfs']['ssc']['tensor'] = self._parse_tensor()\n\n            if self.line[1:30] == '2ND ORDER SPIN-ORBIT COUPLING':\n                while 'Second' not in self.line:\n                    self.line = self._skip_lines(1)\n                self.line = self._skip_lines(1)\n                self.mrci['zfs']['soc']['second_order']['0']['tensor'] = self._parse_tensor() # noqa\n                self.line = self._skip_lines(2)\n                self.mrci['zfs']['soc']['second_order']['m']['tensor'] = self._parse_tensor() # noqa\n                self.line = self._skip_lines(2)\n                self.mrci['zfs']['soc']['second_order']['p']['tensor'] = self._parse_tensor() # noqa\n\n            if self.line[1:42] == 'EFFECTIVE HAMILTONIAN SPIN-ORBIT COUPLING':\n                self.line = self._skip_lines(4)\n                self.mrci['zfs']['soc']['heff']['tensor'] = self._parse_tensor()", "response": "Iterate over the lines and extract the required data."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef __create_event(self):\n        if not event.contains(self.field, 'set', self.__validate):\n            event.listen(self.field, 'set', self.__validate, retval=True)", "response": "Create an SQLAlchemy event listening the set in a particular column."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nstopping the validation of the resource.", "response": "def stop(self):\n        \"\"\" Remove the listener to stop the validation\n        \"\"\"\n        if event.contains(self.field, 'set', self.__validate):\n            event.remove(self.field, 'set', self.__validate)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef solve_gfl(data, edges=None, weights=None,\n              minlam=0.2, maxlam=1000.0, numlam=30,\n              alpha=0.2, inflate=2., converge=1e-6,\n              maxsteps=1000000, lam=None, verbose=0,\n              missing_val=None, full_path=False,\n              loss='normal'):\n    '''A very easy-to-use version of GFL solver that just requires the data and\n    the edges.'''\n\n    #Fix no edge cases\n    if edges.shape[0] < 1:\n        return data\n\n    #Keep initial edges\n    init_edges = edges\n\n    if verbose:\n        print('Decomposing graph into trails')\n\n    if loss == 'binomial':\n        flat_data = data[0].flatten()\n        nonmissing_flat_data = flat_data, data[1].flatten()\n    else:\n        flat_data = data.flatten()\n        nonmissing_flat_data = flat_data\n\n    if edges is None:\n        if loss == 'binomial':\n            if verbose:\n                print('Using default edge set of a grid of same shape as the data: {0}'.format(data[0].shape))\n            edges = hypercube_edges(data[0].shape)\n        else:\n            if verbose:\n                print('Using default edge set of a grid of same shape as the data: {0}'.format(data.shape))\n            edges = hypercube_edges(data.shape)\n        if missing_val is not None:\n            if verbose:\n                print('Removing all data points whose data value is {0}'.format(missing_val))\n            edges = [(e1,e2) for (e1,e2) in edges if flat_data[e1] != missing_val and flat_data[e2] != missing_val]\n            if loss == 'binomial':\n                nonmissing_flat_data = flat_data[flat_data != missing_val], nonmissing_flat_data[1][flat_data != missing_val]\n            else:\n                nonmissing_flat_data = flat_data[flat_data != missing_val]\n\n\n    ########### Setup the graph\n    g = Graph()\n    g.add_edges_from(edges)\n    chains = decompose_graph(g, heuristic='greedy')\n    ntrails, trails, breakpoints, edges = chains_to_trails(chains)\n\n    if verbose:\n        print('Setting up trail solver')\n\n    ########### Setup the solver\n    if loss == 'normal':\n        solver = TrailSolver(alpha, inflate, maxsteps, converge)\n    elif loss == 'logistic':\n        solver = LogisticTrailSolver(alpha, inflate, maxsteps, converge)\n    elif loss == 'binomial':\n        solver = BinomialTrailSolver(alpha, inflate, maxsteps, converge)\n    else:\n        raise NotImplementedError('Loss must be normal, logistic, or binomial')\n\n    # Set the data and pre-cache any necessary structures\n    solver.set_data(nonmissing_flat_data, edges, ntrails, trails, breakpoints, weights=weights)\n\n    if verbose:\n        print('Solving')\n\n    ########### Run the solver\n    if lam:\n        # Fixed lambda\n        beta = solver.solve(lam)\n    else:\n        # Grid search to find the best lambda\n        beta = solver.solution_path(minlam, maxlam, numlam, verbose=max(0, verbose-1))\n        if not full_path:\n            beta = beta['best']\n\n    ########### Fix disconnected nodes\n    mask = np.ones_like(beta)\n    mask[init_edges[:,0]] = 0\n    mask[init_edges[:,1]] = 0\n    beta[mask>0] = data[mask>0]\n\n    return beta", "response": "A very easy - to - use version of GFL solver that just requires the data and the edges."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef ngayThangNam(nn, tt, nnnn, duongLich=True, timeZone=7):\n    thangNhuan = 0\n    # if nnnn > 1000 and nnnn < 3000 and nn > 0 and \\\n    if nn > 0 and \\\n       nn < 32 and tt < 13 and tt > 0:\n        if duongLich is True:\n            [nn, tt, nnnn, thangNhuan] = S2L(nn, tt, nnnn, timeZone=timeZone)\n        return [nn, tt, nnnn, thangNhuan]\n    else:\n        raise Exception(\"Ng\u00e0y, th\u00e1ng, n\u0103m kh\u00f4ng ch\u00ednh x\u00e1c.\")", "response": "Summary n\u0103m kh\u00f4ng ch\u00ednh x\u00e1c."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef canChiNgay(nn, tt, nnnn, duongLich=True, timeZone=7, thangNhuan=False):\n    if duongLich is False:\n        [nn, tt, nnnn] = L2S(nn, tt, nnnn, thangNhuan, timeZone)\n    jd = jdFromDate(nn, tt, nnnn)\n    # print jd\n    canNgay = (jd + 9) % 10 + 1\n    chiNgay = (jd + 1) % 12 + 1\n    return [canNgay, chiNgay]", "response": "Summary function to calculate the canNgay and chiNgay of a given entry."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef ngayThangNamCanChi(nn, tt, nnnn, duongLich=True, timeZone=7):\n    if duongLich is True:\n        [nn, tt, nnnn, thangNhuan] = \\\n            ngayThangNam(nn, tt, nnnn, timeZone=timeZone)\n    # Can c\u1ee7a th\u00e1ng\n    canThang = (nnnn * 12 + tt + 3) % 10 + 1\n    # Can chi c\u1ee7a n\u0103m\n    canNamSinh = (nnnn + 6) % 10 + 1\n    chiNam = (nnnn + 8) % 12 + 1\n\n    return [canThang, canNamSinh, chiNam]", "response": "Ng\u00e0y th\u00e1ng n\u0103m th\u00e1ng n\u0103m th\u00e1ng n\u0103m chi trong ti\u1ebfng Vi\u1ec7t."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef nguHanh(tenHanh):\n    if tenHanh in [\"Kim\", \"K\"]:\n        return {\"id\": 1, \"tenHanh\": \"Kim\", \"cuc\": 4, \"tenCuc\": \"Kim t\u1ee9 C\u1ee5c\",\n                \"css\": \"hanhKim\"}\n    elif tenHanh == \"Moc\" or tenHanh == \"M\":\n        return {\"id\": 2, \"tenHanh\": \"M\u1ed9c\", \"cuc\": 3, \"tenCuc\": \"M\u1ed9c tam C\u1ee5c\",\n                \"css\": \"hanhMoc\"}\n    elif tenHanh == \"Thuy\" or tenHanh == \"T\":\n        return {\"id\": 3, \"tenHanh\": \"Th\u1ee7y\", \"cuc\": 2, \"tenCuc\": \"Th\u1ee7y nh\u1ecb C\u1ee5c\",\n                \"css\": \"hanhThuy\"}\n    elif tenHanh == \"Hoa\" or tenHanh == \"H\":\n        return {\"id\": 4, \"tenHanh\": \"H\u1ecfa\", \"cuc\": 6, \"tenCuc\": \"H\u1ecfa l\u1ee5c C\u1ee5c\",\n                \"css\": \"hanhHoa\"}\n    elif tenHanh == \"Tho\" or tenHanh == \"O\":\n        return {\"id\": 5, \"tenHanh\": \"Th\u1ed5\", \"cuc\": 5, \"tenCuc\": \"Th\u1ed5 ng\u0169 C\u1ee5c\",\n                \"css\": \"hanhTho\"}\n    else:\n        raise Exception(\n            \"T\u00ean H\u00e0nh ph\u1ea3i thu\u1ed9c Kim (K), M\u1ed9c (M), Th\u1ee7y (T), \\\n             H\u1ecfa (H) ho\u1eb7c Th\u1ed5 (O)\")", "response": "Ngu Hanh - > Ngu Hanh"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef timTuVi(cuc, ngaySinhAmLich):\n    cungDan = 3  # V\u1ecb tr\u00ed cung D\u1ea7n ban \u0111\u1ea7u l\u00e0 3\n    cucBanDau = cuc\n    if cuc not in [2, 3, 4, 5, 6]:  # Tr\u00e1nh tr\u01b0\u1eddng h\u1ee3p infinite loop\n        raise Exception(\"S\u1ed1 c\u1ee5c ph\u1ea3i l\u00e0 2, 3, 4, 5, 6\")\n    while cuc < ngaySinhAmLich:\n        cuc += cucBanDau\n        cungDan += 1  # D\u1ecbch v\u1ecb tr\u00ed cung D\u1ea7n\n    saiLech = cuc - ngaySinhAmLich\n    if saiLech % 2 is 1:\n        saiLech = -saiLech  # N\u1ebfu sai l\u1ec7ch l\u00e0 ch\u1eb5n th\u00ec ti\u1ebfn, l\u1ebb th\u00ec l\u00f9i\n    return dichCung(cungDan, saiLech)", "response": "T\u00ecm v\u1ecb tr\u00ed c\u1ee7a sao T\u1eed vi\n   "}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef nt2aa(ntseq):\n    nt2num = {'A': 0, 'C': 1, 'G': 2, 'T': 3, 'a': 0, 'c': 1, 'g': 2, 't': 3}\n    aa_dict ='KQE*TPASRRG*ILVLNHDYTPASSRGCILVFKQE*TPASRRGWMLVLNHDYTPASSRGCILVF'\n    \n    return ''.join([aa_dict[nt2num[ntseq[i]] + 4*nt2num[ntseq[i+1]] + 16*nt2num[ntseq[i+2]]] for i in range(0, len(ntseq), 3) if i+2 < len(ntseq)])", "response": "Translate a nucleotide sequence into an amino acid sequence."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef nt2codon_rep(ntseq):\n    \n    #\n    nt2num = {'A': 0, 'C': 1, 'G': 2, 'T': 3, 'a': 0, 'c': 1, 'g': 2, 't': 3}\n    #Use single characters not in use to represent each individual codon --- this function is called in constructing the codon dictionary\n    codon_rep ='\\x80\\x81\\x82\\x83\\x84\\x85\\x86\\x87\\x88\\x89\\x8a\\x8b\\x8c\\x8d\\x8e\\x8f\\x90\\x91\\x92\\x93\\x94\\x95\\x96\\x97\\x98\\x99\\x9a\\x9b\\x9c\\x9d\\x9e\\x9f\\xa0\\xa1\\xa2\\xa3\\xa4\\xa5\\xa6\\xa7\\xa8\\xa9\\xaa\\xab\\xac\\xad\\xae\\xaf\\xb0\\xb1\\xb2\\xb3\\xb4\\xb5\\xb6\\xb7\\xb8\\xb9\\xba\\xbb\\xbc\\xbd\\xbe\\xbf'\n    \n    return ''.join([codon_rep[nt2num[ntseq[i]] + 4*nt2num[ntseq[i+1]] + 16*nt2num[ntseq[i+2]]] for i in range(0, len(ntseq), 3) if i+2 < len(ntseq)])", "response": "Represents a nucleotide sequence by sequence of codon symbols."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef cutR_seq(seq, cutR, max_palindrome):\n    complement_dict = {'A': 'T', 'C': 'G', 'G': 'C', 'T': 'A'} #can include lower case if wanted\n    if cutR < max_palindrome:\n        seq = seq + ''.join([complement_dict[nt] for nt in seq[cutR - max_palindrome:]][::-1]) #reverse complement palindrome insertions\n    else:\n        seq = seq[:len(seq) - cutR + max_palindrome] #deletions\n    \n    return seq", "response": "Cut genomic sequence from the right."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncuts genomic sequence from the left.", "response": "def cutL_seq(seq, cutL, max_palindrome):\n    \"\"\"Cut genomic sequence from the left.\n\n    Parameters\n    ----------\n    seq : str\n        Nucleotide sequence to be cut from the right\n    cutL : int\n        cutL - max_palindrome = how many nucleotides to cut from the left.\n        Negative cutL implies complementary palindromic insertions.\n    max_palindrome : int\n        Length of the maximum palindromic insertion.\n\n    Returns\n    -------\n    seq : str\n        Nucleotide sequence after being cut from the left\n    \n    Examples\n    --------\n    >>> cutL_seq('TGAACACTGAAGCTTTCTTT', 8, 4)\n    'CACTGAAGCTTTCTTT'\n    >>> cutL_seq('TGAACACTGAAGCTTTCTTT', 0, 4)\n    'TTCATGAACACTGAAGCTTTCTTT'\n    \n    \"\"\"\n    \n    complement_dict = {'A': 'T', 'C': 'G', 'G': 'C', 'T': 'A'} #can include lower case if wanted\n    if cutL < max_palindrome:\n        seq = ''.join([complement_dict[nt] for nt in seq[:max_palindrome - cutL]][::-1]) + seq #reverse complement palindrome insertions\n    else:\n        seq = seq[cutL-max_palindrome:] #deletions\n    \n    return seq"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nconstruct the sub_codons_right dictionary of amino acid suffixes.", "response": "def construct_codons_dict(alphabet_file = None):\n    \"\"\"Generate the sub_codons_right dictionary of codon suffixes.\n\n    syntax of custom alphabet_files:\n        \n    char: list,of,amino,acids,or,codons,separated,by,commas\n    \n    \n    Parameters\n    ----------\n    alphabet_file : str\n        File name for a custom alphabet definition. If no file is provided, the \n        default alphabet is used, i.e. standard amino acids, undetermined amino \n        acids (B, J, X, and Z), and single codon symbols.\n\n    Returns\n    -------\n    codons_dict : dict\n        Dictionary, keyed by the allowed 'amino acid' symbols with the values \n        being lists of codons corresponding to the symbol.\n    \n    \"\"\"\n    \n    #Some symbols can't be used in the CDR3 sequences in order to allow for\n    #regular expression parsing and general manipulation.\n    protected_symbols = [' ', '\\t', '\\n', '\\x0b', '\\x0c', '\\r', ':', ',', ';', '[', ']', '{', '}', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9']\n    \n    \n    #construct list of all 64 codons\n    codons = [i + j + k for i in 'ACGT' for j in 'ACGT' for k in 'ACGT']\n    \n    codons_dict = {}\n    #add standard amino acids symbols to the dict (i.e. 'ACDEFGHIKLMNPQRSTVWY*').\n    #these symbols CANNOT be overwritten by custom alphabet files\n    for codon in codons:\n        codons_dict[nt2aa(codon)] = codons_dict.get(nt2aa(codon), []) + [codon]\n                 \n    #add single codon symbols to allow for inframe ntseq pgen computation\n    #'\\x80\\x81\\x82\\x83\\x84\\x85\\x86\\x87\\x88\\x89\\x8a\\x8b\\x8c\\x8d\\x8e\\x8f\\x90\\x91\\x92\\x93\\x94\\x95\\x96\\x97\\x98\\x99\\x9a\\x9b\\x9c\\x9d\\x9e\\x9f\\xa0\\xa1\\xa2\\xa3\\xa4\\xa5\\xa6\\xa7\\xa8\\xa9\\xaa\\xab\\xac\\xad\\xae\\xaf\\xb0\\xb1\\xb2\\xb3\\xb4\\xb5\\xb6\\xb7\\xb8\\xb9\\xba\\xbb\\xbc\\xbd\\xbe\\xbf'\n    #these symbols CANNOT be overwritten by custom alphabet files\n    for codon in codons:\n        codons_dict[nt2codon_rep(codon)] = [codon]  \n    \n    #Check to see if custom alphabet file is supplied, else use default alphabet\n    \n    #Include standard ambigious amino acids.\n    #these symbols CAN be overwritten by custom alphabet files\n    expanded_alphabet = {}\n    expanded_alphabet['B'] = ['D','N']\n    expanded_alphabet['J'] = ['I', 'L']\n    expanded_alphabet['X'] = ['A','C','D','E','F','G','H','I','K','L','M','N','P','Q','R','S','T','V','W','Y']\n    expanded_alphabet['Z'] = ['E', 'Q']\n    if alphabet_file is not None: #Use custom alphabet file definitions\n        alphabet_f = open(alphabet_file, 'r')\n        for line in alphabet_f:\n            #assumed syntax is of a line is:\n            #s: a1, a2, a3, a4, a5, ..., aN\n            #where s is a single character symbol that isn't reserved, and all \n            #of the a's are either amino acid symbols or codons. Whitespaces\n            #will be stripped as will brackets if the a's are presented as a\n            #list.\n            c_symbol = line.split(':', 1)[0].strip(''.join(protected_symbols))\n            #Note there shouldn't be any additional colons -- this is a protected symbol.\n            c_aa_codon_list_str = line.split(':', 1)[1]\n            expanded_alphabet[c_symbol] = [x.strip(''.join(protected_symbols)) for x in c_aa_codon_list_str.split(',')]\n        \n        alphabet_f.close()\n    \n    \n    for symbol in expanded_alphabet.keys():\n        #Double check that the symbol isn't already used (important particularly for the single codon representation)\n        if symbol in codons_dict.keys():\n            print symbol + \" is already used as an 'amino acid' symbol for codons: \"\n            print codons_dict[symbol]\n            continue\n        elif not len(symbol) == 1: #Check that the custom symbol is a single character\n            print \"Can't use \" + symbol + \" as a custom 'amino acid' definitions as such symbols must be single characters.\"\n            continue\n        elif symbol in protected_symbols: #This elif shouldn't trigger due to the stripping of protected symbols.\n            print symbol + \" is a protected character\"\n        current_codon_collection = set()\n        for x in expanded_alphabet[symbol]:\n            if x in codons_dict.keys(): #Check if reference to an amino acid or other amino acid symbol\n                current_codon_collection = current_codon_collection.union(codons_dict[x]) #If so, add those codons to the new collection\n            elif x.upper() in codons: #Check if specifying a single codon\n                current_codon_collection.add(x.upper()) #If so, add the codon to the new collection\n            elif len(x) == 0: #fully stripped away\n                continue\n            else: #If not, don't recognize the addition and continue.\n                print 'Unfamiliar amino acid symbol or codon: ' + x\n                continue\n        codons_dict[symbol] = list(current_codon_collection)\n    \n                \n    return codons_dict"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngenerating the sub_codons_left dictionary of codon prefixes.", "response": "def generate_sub_codons_left(codons_dict):\n    \"\"\"Generate the sub_codons_left dictionary of codon prefixes.\n\n    Parameters\n    ----------\n    codons_dict : dict\n        Dictionary, keyed by the allowed 'amino acid' symbols with the values \n        being lists of codons corresponding to the symbol.\n\n    Returns\n    -------\n    sub_codons_left : dict\n        Dictionary of the 1 and 2 nucleotide prefixes (read from 5') for \n        each codon in an 'amino acid' grouping\n        \n    \"\"\"\n    sub_codons_left = {}\n    for aa in codons_dict.keys():\n        sub_codons_left[aa] = list(set([x[0] for x in codons_dict[aa]] + [x[:2] for x in codons_dict[aa]]))\n        \n    return sub_codons_left"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef generate_sub_codons_right(codons_dict):\n    sub_codons_right = {}\n    for aa in codons_dict.keys():\n        sub_codons_right[aa] = list(set([x[-1] for x in codons_dict[aa]] + [x[-2:] for x in codons_dict[aa]]))\n        \n    return sub_codons_right", "response": "Generate the sub_codons_right dictionary of codon suffixes."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ndetermining the type of a sequence.", "response": "def determine_seq_type(seq, aa_alphabet):\n    \"\"\"Determine the type of a sequence.\n    \n    Parameters\n    ----------\n\n    seq : str\n        Sequence to be typed.\n    aa_alphabet : str\n        String of all characters recoginized as 'amino acids'. (i.e. the keys\n        of codons_dict: aa_alphabet = ''.join(codons_dict.keys())  )\n\n    Returns\n    -------\n    seq_type : str\n        The type of sequence (ntseq, aaseq, regex, None) seq is.\n    \n    Example\n    --------\n    >>> determine_seq_type('TGTGCCAGCAGTTCCGAAGGGGCGGGAGGGCCCTCCCTGAGAGGTCATGAGCAGTTCTTC', aa_alphabet)\n    'ntseq'\n    >>> determine_seq_type('CSARDX[TV]GNX{0,}', aa_alphabet)\n    'regex\n    \n    \"\"\"\n    \n    if all([x in 'ACGTacgt' for x in seq]):\n        return 'ntseq'\n    elif all([x in aa_alphabet for x in seq]):\n        return 'aaseq'\n    elif all([x in aa_alphabet + '[]{}0123456789,']):\n        return 'regex'"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncalculates the steady state distribution of a 4 state markov transition matrix.", "response": "def calc_steady_state_dist(R):\n    \"\"\"Calculate the steady state dist of a 4 state markov transition matrix.\n\n    Parameters\n    ----------\n    R : ndarray\n        Markov transition matrix\n\n    Returns\n    -------\n    p_ss : ndarray\n        Steady state probability distribution\n        \n    \"\"\"\n    #Calc steady state distribution for a dinucleotide bias matrix\n    \n    w, v = np.linalg.eig(R)\n    \n    for i in range(4):\n        if np.abs(w[i] - 1) < 1e-8:\n            return np.real(v[:, i] / np.sum(v[:, i]))\n    return -1"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngenerating a random insertion sequence of length ins_len from the distribution C_Rvd and CP_first_nt.", "response": "def rnd_ins_seq(ins_len, C_R, CP_first_nt):\n    \"\"\"Generate a random insertion nucleotide sequence of length ins_len.\n\n    Draws the sequence identity (for a set length) from the distribution\n    defined by the dinucleotide markov model of transition matrix R.\n\n    Parameters\n    ----------\n    ins_len : int\n        Length of nucleotide sequence to be inserted.\n    C_R : ndarray\n        (4, 4) array of the cumulative transition probabilities defined by the\n        Markov transition matrix R\n    CP_first_nt : ndarray\n        (4,) array of the cumulative probabilities for the first inserted\n        nucleotide\n\n    Returns\n    -------\n    seq : str\n        Randomly generated insertion sequence of length ins_len.\n\n    Examples\n    --------\n    >>> rnd_ins_seq(7, CP_generative_model['C_Rvd'], CP_generative_model['C_first_nt_bias_insVD'])\n    'GATGGAC'\n    >>> rnd_ins_seq(7, CP_generative_model['C_Rvd'], CP_generative_model['C_first_nt_bias_insVD'])\n    'ACCCCCG'\n    >>> rnd_ins_seq(3, CP_generative_model['C_Rvd'], CP_generative_model['C_first_nt_bias_insVD'])\n    'GCC'\n\n    \"\"\"\n    nt2num = {'A': 0, 'C': 1, 'G': 2, 'T': 3}\n    num2nt = 'ACGT'\n\n    if ins_len == 0:\n        return ''\n\n    seq = num2nt[CP_first_nt.searchsorted(np.random.random())]\n    ins_len += -1\n\n    while ins_len > 0:\n        seq += num2nt[C_R[nt2num[seq[-1]], :].searchsorted(np.random.random())]\n        ins_len += -1\n\n    return seq"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngenerating a productive CDR3 sequence from a Monte Carlo draw of the model.", "response": "def gen_rnd_prod_CDR3(self, conserved_J_residues = 'FVW'):\n        \"\"\"Generate a productive CDR3 seq from a Monte Carlo draw of the model.\n\n        Parameters\n        ----------\n        conserved_J_residues : str, optional\n            Conserved amino acid residues defining the CDR3 on the J side (normally\n            F, V, and/or W)\n\n        Returns\n        -------\n        ntseq : str\n            Productive CDR3 nucleotide sequence\n        aaseq : str\n            CDR3 amino acid sequence (aaseq = nt2aa(ntseq))\n        V_choice : int\n            Index of V allele chosen to generate the CDR3 seq\n        J_choice : int\n            Index of J allele chosen to generate the CDR3 seq\n\n        \"\"\"\n        coding_pass = False\n\n        while ~coding_pass:\n            recomb_events = self.choose_random_recomb_events()\n            V_seq = self.cutV_genomic_CDR3_segs[recomb_events['V']]\n\n            #This both checks that the position of the conserved C is\n            #identified and that the V isn't fully deleted out of the CDR3\n            #region\n            if len(V_seq) <= max(recomb_events['delV'], 0):\n                continue\n            D_seq = self.cutD_genomic_CDR3_segs[recomb_events['D']]\n            J_seq = self.cutJ_genomic_CDR3_segs[recomb_events['J']]\n\n            #We check that the D and J aren't deleted more than allowed. Note\n            #the generative model really should reflect this structure already\n            if len(D_seq) < (recomb_events['delDl'] + recomb_events['delDr']) or len(J_seq) < recomb_events['delJ']:\n                continue\n\n            V_seq = V_seq[:len(V_seq) - recomb_events['delV']]\n            D_seq = D_seq[recomb_events['delDl']:len(D_seq)-recomb_events['delDr']]\n            J_seq = J_seq[recomb_events['delJ']:]\n\n            if (len(V_seq)+ len(D_seq) + len(J_seq) + recomb_events['insVD'] + recomb_events['insDJ']) % 3 != 0:\n                continue\n\n\n            insVD_seq = rnd_ins_seq(recomb_events['insVD'], self.C_Rvd, self.C_first_nt_bias_insVD)\n            insDJ_seq = rnd_ins_seq(recomb_events['insDJ'], self.C_Rdj, self.C_first_nt_bias_insDJ)[::-1] #have to reverse the DJ seq\n\n            #Translate to amino acid sequence, see if productive\n            ntseq = V_seq + insVD_seq + D_seq + insDJ_seq + J_seq\n            aaseq = nt2aa(ntseq)\n\n            if '*' not in aaseq and aaseq[0]=='C' and aaseq[-1] in conserved_J_residues:\n                return ntseq, aaseq, recomb_events['V'], recomb_events['J']"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsamples the genomic model for the VDJ recombination events.", "response": "def choose_random_recomb_events(self):\n        \"\"\"Sample the genomic model for VDJ recombination events.\n\n        Returns\n        -------\n        recomb_events : dict\n            Dictionary of the VDJ recombination events. These are\n            integers determining gene choice, deletions, and number of insertions.\n\n        Example\n        --------\n        >>> sequence_generation.choose_random_recomb_events()\n        {'D': 0, 'J': 13, 'V': 36, 'delDl': 2, 'delDr': 13, 'delJ': 10, 'delV': 5, 'insDJ': 6, 'insVD': 9}\n\n        \"\"\"\n\n        recomb_events = {}\n        recomb_events['V'] = self.CPV.searchsorted(np.random.random())\n\n        #For 2D arrays make sure to take advantage of a mod expansion to find indicies\n        DJ_choice = self.CPDJ.searchsorted(np.random.random())\n        recomb_events['D'] = DJ_choice/self.num_J_genes\n        recomb_events['J'] = DJ_choice % self.num_J_genes\n\n\n        #Refer to the correct slices for the dependent distributions\n        recomb_events['delV'] = self.given_V_CPdelV[recomb_events['V'], :].searchsorted(np.random.random())\n\n        recomb_events['delJ'] = self.given_J_CPdelJ[recomb_events['J'], :].searchsorted(np.random.random())\n\n        delDldelDr_choice = self.given_D_CPdelDldelDr[recomb_events['D'], :].searchsorted(np.random.random())\n\n        recomb_events['delDl'] = delDldelDr_choice/self.num_delDr_poss\n        recomb_events['delDr'] = delDldelDr_choice % self.num_delDr_poss\n\n        recomb_events['insVD'] = self.CinsVD.searchsorted(np.random.random())\n        recomb_events['insDJ'] = self.CinsDJ.searchsorted(np.random.random())\n\n        return recomb_events"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ngenerate a productive CDR3 sequence from a Monte Carlo draw of the model.", "response": "def gen_rnd_prod_CDR3(self, conserved_J_residues = 'FVW'):\n        \"\"\"Generate a productive CDR3 seq from a Monte Carlo draw of the model.\n\n        Parameters\n        ----------\n        conserved_J_residues : str, optional\n            Conserved amino acid residues defining the CDR3 on the J side (normally\n            F, V, and/or W)\n\n        Returns\n        -------\n        ntseq : str\n            Productive CDR3 nucleotide sequence\n        aaseq : str\n            CDR3 amino acid sequence (aaseq = nt2aa(ntseq))\n        V_choice : int\n            Index of V allele chosen to generate the CDR3 seq\n        J_choice : int\n            Index of J allele chosen to generate the CDR3 seq\n\n        \"\"\"\n\n        coding_pass = False\n\n        while ~coding_pass:\n            recomb_events = self.choose_random_recomb_events()\n            V_seq = self.cutV_genomic_CDR3_segs[recomb_events['V']]\n\n            #This both checks that the position of the conserved C is\n            #identified and that the V isn't fully deleted out of the CDR3\n            #region\n            if len(V_seq) <= max(recomb_events['delV'], 0):\n                continue\n            J_seq = self.cutJ_genomic_CDR3_segs[recomb_events['J']]\n\n            #We check that J isn't deleted more than allowed. Note the\n            #generative model really should reflect this structure already\n            if len(J_seq) < recomb_events['delJ']:\n                continue\n\n            V_seq = V_seq[:len(V_seq) - recomb_events['delV']]\n            J_seq = J_seq[recomb_events['delJ']:]\n\n            if (len(V_seq)+len(J_seq) + recomb_events['insVJ']) % 3 != 0:\n                continue\n\n\n            insVJ_seq = rnd_ins_seq(recomb_events['insVJ'], self.C_Rvj, self.C_first_nt_bias_insVJ)\n\n            #Translate to amino acid sequence, see if productive\n            ntseq = V_seq + insVJ_seq + J_seq\n            aaseq = nt2aa(ntseq)\n\n            if '*' not in aaseq and aaseq[0]=='C' and aaseq[-1] in conserved_J_residues:\n                return ntseq, aaseq, recomb_events['V'], recomb_events['J']"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nsample the genomic model for VDJ recombination events.", "response": "def choose_random_recomb_events(self):\n        \"\"\"Sample the genomic model for VDJ recombination events.\n\n        Returns\n        -------\n        recomb_events : dict\n            Dictionary of the VDJ recombination events. These are\n            integers determining gene choice, deletions, and number of insertions.\n\n        Example\n        --------\n        >>> sequence_generation.choose_random_recomb_events()\n        {'J': 13, 'V': 36, 'delJ': 10, 'delV': 5, 'insVJ': 3}\n\n        \"\"\"\n\n        recomb_events = {}\n\n        #For 2D arrays make sure to take advantage of a mod expansion to find indicies\n        VJ_choice = self.CPVJ.searchsorted(np.random.random())\n        recomb_events['V'] = VJ_choice/self.num_J_genes\n        recomb_events['J'] = VJ_choice % self.num_J_genes\n\n\n        #Refer to the correct slices for the dependent distributions\n        recomb_events['delV'] = self.given_V_CPdelV[recomb_events['V'], :].searchsorted(np.random.random())\n\n        recomb_events['delJ'] = self.given_J_CPdelJ[recomb_events['J'], :].searchsorted(np.random.random())\n        recomb_events['insVJ'] = self.CPinsVJ.searchsorted(np.random.random())\n\n        return recomb_events"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nupdate the rates for a source", "response": "def update_rates(self):\n        \"\"\"\n        Creates or updates rates for a source\n        \"\"\"\n        source, created = RateSource.objects.get_or_create(name=self.get_source_name())\n        source.base_currency = self.get_base_currency()\n        source.save()\n\n        for currency, value in six.iteritems(self.get_rates()):\n            try:\n                rate = Rate.objects.get(source=source, currency=currency)\n            except Rate.DoesNotExist:\n                rate = Rate(source=source, currency=currency)\n\n            rate.value = value\n            rate.save()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef sample_gtf(data, D, k, likelihood='gaussian', prior='laplace',\n                           lambda_hyperparams=None, lam_walk_stdev=0.01, lam0=1.,\n                           dp_hyperparameter=None, w_hyperparameters=None,\n                           iterations=7000, burn=2000, thin=10,\n                           robust=False, empirical=False,\n                           verbose=False):\n    '''Generate samples from the generalized graph trend filtering distribution via a modified Swendsen-Wang slice sampling algorithm.\n    Options for likelihood: gaussian, binomial, poisson. Options for prior: laplace, doublepareto.'''\n    Dk = get_delta(D, k)\n    dk_rows, dk_rowbreaks, dk_cols, dk_vals = decompose_delta(Dk)\n\n    if likelihood == 'gaussian':\n        y, w = data\n    elif likelihood == 'binomial':\n        trials, successes = data\n    elif likelihood == 'poisson':\n        obs = data\n    else:\n        raise Exception('Unknown likelihood type: {0}'.format(likelihood))\n\n    if prior == 'laplace':\n        if lambda_hyperparams == None:\n            lambda_hyperparams = (1., 1.)\n    elif prior == 'laplacegamma':\n        if lambda_hyperparams == None:\n            lambda_hyperparams = (1., 1.)\n        if dp_hyperparameter == None:\n            dp_hyperparameter = 1.\n    elif prior == 'doublepareto' or prior == 'doublepareto2':\n        if lambda_hyperparams == None:\n            lambda_hyperparams = (1.0, 1.0)\n        if dp_hyperparameter == None:\n            dp_hyperparameter = 0.1\n    elif prior == 'cauchy':\n        if lambda_hyperparams == None:\n            lambda_hyperparams = (1.0, 1.0)\n    else:\n        raise Exception('Unknown prior type: {0}.'.format(prior))\n\n    if robust and w_hyperparameters is None:\n        w_hyperparameters = (1., 1.)\n\n    # Run the Gibbs sampler\n    sample_size = (iterations - burn) / thin\n    beta_samples = np.zeros((sample_size, D.shape[1]), dtype='double')\n    lam_samples = np.zeros(sample_size, dtype='double')\n\n    if likelihood == 'gaussian':\n        if prior == 'laplace':\n            gflbayes_gaussian_laplace(len(y), y, w,\n                                      dk_rows, dk_rowbreaks, dk_cols, dk_vals,\n                                      lambda_hyperparams[0], lambda_hyperparams[1],\n                                      iterations, burn, thin,\n                                      double_matrix_to_c_pointer(beta_samples), lam_samples)\n        elif prior == 'laplacegamma':\n            if robust:\n                gflbayes_gaussian_laplace_gamma_robust(len(y), y, w,\n                                          dk_rows, dk_rowbreaks, dk_cols, dk_vals,\n                                          lambda_hyperparams[0], lambda_hyperparams[1],\n                                          dp_hyperparameter,\n                                          w_hyperparameters[0], w_hyperparameters[1],\n                                          iterations, burn, thin,\n                                          double_matrix_to_c_pointer(beta_samples), lam_samples)\n            else:    \n                gflbayes_gaussian_laplace_gamma(len(y), y, w,\n                                          dk_rows, dk_rowbreaks, dk_cols, dk_vals,\n                                          lambda_hyperparams[0], lambda_hyperparams[1],\n                                          dp_hyperparameter,\n                                          iterations, burn, thin,\n                                          double_matrix_to_c_pointer(beta_samples), lam_samples)\n        elif prior == 'doublepareto':\n            gflbayes_gaussian_doublepareto(len(y), y, w,\n                                      dk_rows, dk_rowbreaks, dk_cols, dk_vals,\n                                      lambda_hyperparams[0], lambda_hyperparams[1],\n                                      lam_walk_stdev, lam0, dp_hyperparameter,\n                                      iterations, burn, thin,\n                                      double_matrix_to_c_pointer(beta_samples), lam_samples)\n        elif prior == 'doublepareto2':\n            gflbayes_gaussian_doublepareto2(len(y), y, w,\n                                      dk_rows, dk_rowbreaks, dk_cols, dk_vals,\n                                      lambda_hyperparams[0], lambda_hyperparams[1],\n                                      dp_hyperparameter,\n                                      iterations, burn, thin,\n                                      double_matrix_to_c_pointer(beta_samples), lam_samples)\n        elif prior == 'cauchy':\n            gflbayes_gaussian_cauchy(len(y), y, w,\n                                      dk_rows, dk_rowbreaks, dk_cols, dk_vals,\n                                      lambda_hyperparams[0], lambda_hyperparams[1],\n                                      lam_walk_stdev, lam0,\n                                      iterations, burn, thin,\n                                      double_matrix_to_c_pointer(beta_samples), lam_samples)\n    elif likelihood == 'binomial':\n        if prior == 'laplace':\n            gflbayes_binomial_laplace(len(trials), trials, successes,\n                                      dk_rows, dk_rowbreaks, dk_cols, dk_vals,\n                                      lambda_hyperparams[0], lambda_hyperparams[1],\n                                      iterations, burn, thin,\n                                      double_matrix_to_c_pointer(beta_samples), lam_samples)\n        elif prior == 'doublepareto':\n            gflbayes_binomial_doublepareto(len(trials), trials, successes,\n                                      dk_rows, dk_rowbreaks, dk_cols, dk_vals,\n                                      lambda_hyperparams[0], lambda_hyperparams[1],\n                                      lam_walk_stdev, lam0, dp_hyperparameter,\n                                      iterations, burn, thin,\n                                      double_matrix_to_c_pointer(beta_samples), lam_samples)\n        elif prior == 'laplacegamma':\n            if empirical:\n                gflbayes_empirical_binomial_laplace_gamma(len(trials), trials, successes,\n                                          dk_rows, dk_rowbreaks, dk_cols, dk_vals,\n                                          lam0,\n                                          iterations, burn, thin,\n                                          double_matrix_to_c_pointer(beta_samples), lam_samples)\n            else:\n                gflbayes_binomial_laplace_gamma(len(trials), trials, successes,\n                                          dk_rows, dk_rowbreaks, dk_cols, dk_vals,\n                                          lambda_hyperparams[0], lambda_hyperparams[1],\n                                          dp_hyperparameter,\n                                          iterations, burn, thin,\n                                          double_matrix_to_c_pointer(beta_samples), lam_samples)\n    elif likelihood == 'poisson':\n        if prior == 'laplace':\n            gflbayes_poisson_laplace(len(obs), obs,\n                                      dk_rows, dk_rowbreaks, dk_cols, dk_vals,\n                                      lambda_hyperparams[0], lambda_hyperparams[1],\n                                      iterations, burn, thin,\n                                      double_matrix_to_c_pointer(beta_samples), lam_samples)\n        elif prior == 'doublepareto':\n            gflbayes_poisson_doublepareto(len(obs), obs,\n                                      dk_rows, dk_rowbreaks, dk_cols, dk_vals,\n                                      lambda_hyperparams[0], lambda_hyperparams[1],\n                                      lam_walk_stdev, lam0, dp_hyperparameter,\n                                      iterations, burn, thin,\n                                      double_matrix_to_c_pointer(beta_samples), lam_samples)\n    else:\n        raise Exception('Unknown likelihood type: {0}'.format(likelihood))\n\n    return (beta_samples,lam_samples)", "response": "Generate samples from a generalized graph trend filtering distribution via a modified Swendsen - Wang slice sampling algorithm."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef compute_regex_CDR3_template_pgen(self, regex_seq, V_usage_mask_in = None, J_usage_mask_in = None, print_warnings = True, raise_overload_warning = True):\n        \n        V_usage_mask, J_usage_mask = self.format_usage_masks(V_usage_mask_in, J_usage_mask_in, print_warnings)\n        \n        CDR3_seqs = self.list_seqs_from_regex(regex_seq, print_warnings, raise_overload_warning)\n        \n        pgen = 0\n        for  CDR3_seq in CDR3_seqs:\n            if len(CDR3_seq) == 0:\n                continue\n            pgen += self.compute_CDR3_pgen(CDR3_seq, V_usage_mask, J_usage_mask)\n    \n        return pgen", "response": "This function calculates the Pgen for all sequences that are consistent with a regular expression."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef compute_aa_CDR3_pgen(self, CDR3_seq, V_usage_mask_in = None, J_usage_mask_in = None, print_warnings = True):\n        if len(CDR3_seq) == 0:\n            return  0\n        for aa in CDR3_seq:\n            if aa not in self.codons_dict.keys():\n                #Check to make sure all symbols are accounted for\n                if print_warnings:\n                    print 'Invalid amino acid CDR3 sequence --- unfamiliar symbol: ' + aa\n                return 0    \n        \n        V_usage_mask, J_usage_mask = self.format_usage_masks(V_usage_mask_in, J_usage_mask_in, print_warnings)\n        \n        return self.compute_CDR3_pgen(CDR3_seq, V_usage_mask, J_usage_mask)", "response": "Compute the Pgen for the amino acid sequence CDR3_seq."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncompute Pgen of all seqs hamming dist 1 (in amino acids) from CDR3_seq. Please note that this function will list out all the sequences that are hamming distance 1 from the base sequence and then calculate the Pgen of each sequence in succession. THIS CAN BE SLOW as it computes Pgen for L+1 sequences where L = len(CDR3_seq). (Examples are TCRB sequences/model) Parameters ---------- CDR3_seq : str CDR3 sequence composed of amino acids (ONLY the standard amino acids). Pgens for all sequences of hamming distance 1 (in amino acid sequence) are summed. V_usage_mask_in : str or list An object to indicate which V alleles should be considered. The default input is None which returns the list of all productive V alleles. J_usage_mask_in : str or list An object to indicate which J alleles should be considered. The default input is None which returns the list of all productive J alleles. print_warnings : bool Determines whether warnings are printed or not. Default ON. Returns ------- pgen : float The sum of generation probabilities (Pgens) of the sequences at most hamming distance 1 (in amino acids) from CDR3_seq.", "response": "def compute_hamming_dist_1_pgen(self, CDR3_seq, V_usage_mask_in = None, J_usage_mask_in = None, print_warnings = True):\n        \"\"\"Compute Pgen of all seqs hamming dist 1 (in amino acids) from CDR3_seq.\n    \n        Please note that this function will list out all the \n        sequences that are hamming distance 1 from the base sequence and then \n        calculate the Pgen of each sequence in succession. THIS CAN BE SLOW \n        as it computes Pgen for L+1 sequences where L = len(CDR3_seq). (Examples \n        are TCRB sequences/model)\n    \n        Parameters\n        ----------\n        CDR3_seq : str\n            CDR3 sequence composed of amino acids (ONLY the standard amino acids).\n            Pgens for all sequences of hamming distance 1 (in amino acid sequence) \n            are summed.\n        V_usage_mask_in : str or list\n            An object to indicate which V alleles should be considered. The default\n            input is None which returns the list of all productive V alleles.\n        J_usage_mask_in : str or list\n            An object to indicate which J alleles should be considered. The default\n            input is None which returns the list of all productive J alleles.\n        print_warnings : bool\n            Determines whether warnings are printed or not. Default ON.\n    \n        Returns\n        -------\n        pgen : float\n            The sum of generation probabilities (Pgens) of the sequences at most\n            hamming distance 1 (in amino acids) from CDR3_seq.\n            \n        \"\"\"\n        \n        \n        #make sure that the symbol X is defined as the fully undetermined amino acid:\n        #X ~ ACDEFGHIKLMNPQRSTVWY\n        \n        V_usage_mask, J_usage_mask = self.format_usage_masks(V_usage_mask_in, J_usage_mask_in, print_warnings)\n        \n        if len(CDR3_seq) == 0:\n            return  0\n        for aa in CDR3_seq:\n            if aa not in 'ACDEFGHIKLMNPQRSTVWY':\n                #Check to make sure all symbols are accounted for\n                if print_warnings:\n                    print 'Invalid amino acid CDR3 sequence --- unfamiliar symbol: ' + aa\n                return 0\n        tot_pgen = 0\n        for i in range(len(CDR3_seq)):\n            tot_pgen += self.compute_CDR3_pgen(CDR3_seq[:i] + 'X' + CDR3_seq[i+1:], V_usage_mask, J_usage_mask)\n        tot_pgen += -(len(CDR3_seq) - 1)*self.compute_CDR3_pgen(CDR3_seq, V_usage_mask, J_usage_mask)\n        return tot_pgen"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncompute the Pgen for the inframe nucleotide sequence CDR3_ntseq.", "response": "def compute_nt_CDR3_pgen(self, CDR3_ntseq, V_usage_mask_in = None, J_usage_mask_in = None, print_warnings = True):\n        \"\"\"Compute Pgen for the inframe nucleotide sequence CDR3_ntseq.\n    \n        Conditioned on the V genes/alleles indicated in V_usage_mask_in and the \n        J genes/alleles in J_usage_mask_in. (Examples are TCRB sequences/model)\n    \n        Parameters\n        ----------\n        CDR3_ntseq : str\n            Inframe nucleotide sequence composed of ONLY A, C, G, or T (either \n            uppercase or lowercase).\n        V_usage_mask_in : str or list\n            An object to indicate which V alleles should be considered. The default\n            input is None which returns the list of all productive V alleles.\n        J_usage_mask_in : str or list\n            An object to indicate which J alleles should be considered. The default\n            input is None which returns the list of all productive J alleles.\n        print_warnings : bool\n            Determines whether warnings are printed or not. Default ON.\n    \n        Returns\n        -------\n        pgen : float64\n            The generation probability (Pgen) of the sequence\n        \n        Examples\n        --------\n        >>> generation_probability.compute_nt_CDR3_pgen('TGTGCCTGGAGTGTAGCTCCGGACAGGGGTGGCTACACCTTC')\n        3.2674893012379071e-12\n        >>> generation_probability.compute_nt_CDR3_pgen('TGTGCCTGGAGTGTAGCTCCGGACAGGGGTGGCTACACCTTC', 'TRBV30*01', 'TRBJ1-2*01')\n        2.3986503758867323e-12\n            \n        \"\"\"\n        \n        if not len(CDR3_ntseq)%3 == 0:\n            #Make sure sequence is inframe\n            if print_warnings:\n                print 'Invalid nucleotide CDR3 sequence --- out of frame sequence'\n            return 0\n        elif len(CDR3_ntseq) == 0:\n            return 0\n        else:\n            for nt in CDR3_ntseq:\n                if nt not in 'ACGTacgt':\n                    if print_warnings:\n                        print 'Invalid nucleotide CDR3 sequence --- unfamiliar nucleotide: ' + nt\n                    return 0\n        \n        V_usage_mask, J_usage_mask = self.format_usage_masks(V_usage_mask_in, J_usage_mask_in, print_warnings)\n        \n        return self.compute_CDR3_pgen(nt2codon_rep(CDR3_ntseq), V_usage_mask, J_usage_mask)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nformats the usage masks into lists of indices.", "response": "def format_usage_masks(self, V_usage_mask_in, J_usage_mask_in, print_warnings = True):\n        \"\"\"Format raw usage masks into lists of indices.\n    \n        Usage masks allows the Pgen computation to be conditioned on the V and J \n        gene/allele identities. The inputted masks are lists of strings, or a \n        single string, of the names of the genes or alleles to be conditioned on. \n        The default mask includes all productive V or J genes.\n    \n        Parameters\n        ----------\n        V_usage_mask_in : str or list\n            An object to indicate which V alleles should be considered. The default\n            input is None which returns the list of all productive V alleles.\n        J_usage_mask_in : str or list\n            An object to indicate which J alleles should be considered. The default\n            input is None which returns the list of all productive J alleles.\n        print_warnings : bool\n            Determines whether warnings are printed or not. Default ON.\n    \n        Returns\n        -------\n        V_usage_mask : list of integers\n            Indices of the V alleles to be considered in the Pgen computation\n        J_usage_mask : list of integers\n            Indices of the J alleles to be considered in the Pgen computation\n        \n        Examples\n        --------\n        >>> generation_probability.format_usage_masks('TRBV27*01','TRBJ1-1*01')\n        ([34], [0])\n        >>> generation_probability.format_usage_masks('TRBV27*01', '')\n        ([34], [0, 1, 2, 3, 4, 7, 8, 9, 10, 11, 12, 13])\n        >>> generation_probability.format_usage_masks(['TRBV27*01', 'TRBV13*01'], 'TRBJ1-1*01')\n        ([34, 18], [0])\n            \n        \"\"\"\n        #Format the V usage mask\n        if V_usage_mask_in is None: #Default case, use all productive V genes with non-zero probability\n            #V_usage_mask = [v for v, V in enumerate(ppp['cutV_genomic_CDR3_segs']) if len(V) > 0]\n            V_usage_mask = self.d_V_usage_mask\n        elif isinstance(V_usage_mask_in, list):\n            e_V_usage_mask = set()\n            for v in V_usage_mask_in:\n                try:\n                    e_V_usage_mask = e_V_usage_mask.union(self.V_mask_mapping[v])\n                except KeyError:\n                    if print_warnings:\n                        print 'Unfamiliar V gene/allele: ' + v\n                    pass\n            if len(e_V_usage_mask) == 0:\n                if print_warnings:\n                    print 'No recognized V genes/alleles. Using default V_usage_mask'\n                V_usage_mask = self.d_V_usage_mask\n            else:\n                V_usage_mask = list(e_V_usage_mask)\n        else:\n            try:\n                V_usage_mask = self.V_mask_mapping[V_usage_mask_in]\n            except KeyError:\n                #Do raise error here as the mask will be empty\n                if print_warnings:\n                    print 'Unfamiliar V usage mask: ' + str(V_usage_mask_in) + ', please check the allowed V alleles. Using default V_usage_mask'\n                V_usage_mask = self.d_V_usage_mask\n                \n                \n        #Format the J usage mask\n        if J_usage_mask_in is None: #Default case, use all productive J genes with non-zero probability\n            #J_usage_mask = [j for j, J in enumerate(ppp['cutJ_genomic_CDR3_segs']) if len(J) > 0]\n            J_usage_mask = self.d_J_usage_mask\n        elif isinstance(J_usage_mask_in, list):\n            e_J_usage_mask = set()\n            for j in J_usage_mask_in:\n                try:\n                    e_J_usage_mask = e_J_usage_mask.union(self.J_mask_mapping[j])\n                except KeyError:\n                    if print_warnings:\n                        print 'Unfamiliar J gene/allele: ' + j\n                    pass\n            if len(e_J_usage_mask) == 0:\n                if print_warnings:\n                    print 'No recognized J genes/alleles. Using default J_usage_mask'\n                J_usage_mask = self.d_J_usage_mask\n            else:\n                J_usage_mask = list(e_J_usage_mask)\n        else:\n            try:\n                J_usage_mask = self.J_mask_mapping[J_usage_mask_in]\n            except KeyError:\n                #Do raise error here as the mask will be empty\n                if print_warnings:\n                    print 'Unfamiliar J usage mask: ' + str(J_usage_mask_in) + ', please check the allowed J alleles. Using default J_usage_mask'\n                J_usage_mask = self.d_J_usage_mask\n                \n        return V_usage_mask, J_usage_mask"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef list_seqs_from_regex(self, regex_seq, print_warnings = True, raise_overload_warning = True):\n    \n        aa_symbols = ''.join(self.codons_dict)\n        \n        default_max_reps = 40\n    \n        #Check to make sure that expression is of the right form/symbols\n        \n        \n        #Identify bracket expressions\n        bracket_ex = [x for x in re.findall('\\[[' + aa_symbols + ']*?\\]|\\{\\d+,{0,1}\\d*\\}', regex_seq)]\n        \n        \n        split_seq  = re.split('\\[[' + aa_symbols + ']*?\\]|\\{\\d+,{0,1}\\d*\\}', regex_seq)\n        #Check that all remaining characters are in the codon dict\n        for aa in ''.join(split_seq):\n            if aa not in aa_symbols:\n                if print_warnings:\n                    print 'Unfamiliar symbol representing a codon:' + aa + ' --- check codon dictionary or the regex syntax'\n                return []\n        \n        \n        regex_list = [split_seq[i/2] if i%2 == 0 else bracket_ex[i/2] for i in range(len(bracket_ex) + len(split_seq)) if not (i%2 == 0 and len(split_seq[i/2]) ==  0)]\n        \n        max_num_seqs = 1\n        for l, ex in enumerate(regex_list[::-1]):\n            i = len(regex_list) - l - 1\n            if ex[0] == '[': #bracket expression\n                #check characters\n                for aa in ex.strip('[]'):\n                    if aa not in aa_symbols:\n                        if print_warnings:\n                            print 'Unfamiliar symbol representing a codon:' + aa + ' --- check codon dictionary'\n                        return []\n                max_num_seqs *= len(ex) - 2\n            elif ex[0] == '{': #curly bracket\n                if i == 0:\n                    if print_warnings:\n                        print \"Can't have {} expression at start of sequence\"\n                    return []\n                elif isinstance(regex_list[i-1], list):\n                    if print_warnings:\n                        print \"Two {} expressions in a row is not supported\"\n                    return []\n                elif regex_list[i-1][0] == '[':\n                    syms = regex_list[i-1].strip('[]')\n                    regex_list[i-1] = ''                \n                else:\n                    syms = regex_list[i-1][-1]\n                    regex_list[i-1] = regex_list[i-1][:-1]\n                if ',' not in ex:\n                    new_expression = [int(ex.strip('{}')), int(ex.strip('{}')), syms]\n                    max_num_seqs *= len(syms)**new_expression[0]\n                else:\n                    try:\n                        new_expression = [int(ex.strip('{}').split(',')[0]), int(ex.strip('{}').split(',')[1]), syms]\n                    except ValueError: #No max limit --- use default\n                        new_expression = [int(ex.strip('{}').split(',')[0]), default_max_reps, syms]\n                    if new_expression[0] > new_expression[1]:\n                        if print_warnings:\n                            print 'Check regex syntax --- should be {min,max}'\n                        return []\n                    max_num_seqs *= sum([len(syms)**n for n in range(new_expression[0], new_expression[1]+1)])/len(syms)\n                #print new_expression\n                regex_list[i] = new_expression\n                \n        if max_num_seqs > 10000 and raise_overload_warning:\n            if print_warnings:\n                answer = raw_input('Warning large number of sequences (estimated ' + str(max_num_seqs) + ' seqs) match the regular expression. Possible memory and time issues. Continue? (y/n)')\n                if not answer == 'y':\n                    print 'Canceling...'\n                    return []\n            else:\n                return []\n        #print regex_list\n        CDR3_seqs = ['']\n        for l, ex in enumerate(regex_list[::-1]):\n            i = len(regex_list) - l - 1\n            if isinstance(ex, list): #curly bracket case\n                c_seqs = ['']\n                f_seqs = []\n                for j in range(ex[1] + 1):\n                    if j in range(ex[0], ex[1]+1):\n                        f_seqs += c_seqs\n                    c_seqs = [aa + c_seq for aa in ex[2] for c_seq in c_seqs]\n                CDR3_seqs = [f_seq + CDR3_seq for f_seq in f_seqs for CDR3_seq in CDR3_seqs]\n            elif len(ex) == 0:\n                pass\n            elif ex[0] == '[': #square bracket case\n                CDR3_seqs = [aa + CDR3_seq for aa in ex.strip('[]') for CDR3_seq in CDR3_seqs]\n            else:\n                CDR3_seqs = [ex + CDR3_seq for CDR3_seq in CDR3_seqs]\n    \n    \n        return list(set(CDR3_seqs))", "response": "This function parses a limited regular expression vocabulary and lists all the sequences that match the regular expression."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef max_nt_to_aa_alignment_left(self, CDR3_seq, ntseq):    \n        \n        max_alignment = 0\n        if len(ntseq) == 0:\n            return 0\n        aa_aligned = True\n        while aa_aligned:\n            if ntseq[max_alignment:max_alignment+3] in self.codons_dict[CDR3_seq[max_alignment/3]]:\n                max_alignment += 3\n                if max_alignment/3 == len(CDR3_seq):\n                    return max_alignment\n            else:\n                break\n                aa_aligned = False\n        last_codon = ntseq[max_alignment:max_alignment+3]\n        codon_frag = ''\n        for nt in last_codon:\n            codon_frag += nt\n            if codon_frag in self.sub_codons_left[CDR3_seq[max_alignment/3]]:\n                max_alignment += 1\n            else:\n                break\n        return max_alignment", "response": "Find maximum match between CDR3_seq and ntseq from the left."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nfinding maximum match between CDR3_seq and ntseq from the right. Returns the length of the maximum match between CDR3_seq and ntseq.", "response": "def max_nt_to_aa_alignment_right(self, CDR3_seq, ntseq):\n        \"\"\"Find maximum match between CDR3_seq and ntseq from the right.\n    \n        This function returns the length of the maximum length nucleotide\n        subsequence of ntseq contiguous from the right (or 3' end) that is \n        consistent with the 'amino acid' sequence CDR3_seq\n    \n        Parameters\n        ----------\n        CDR3_seq : str\n            CDR3 sequence composed of 'amino acids' (single character symbols\n            each corresponding to a collection of codons as given by codons_dict).\n        ntseq : str\n            Genomic (J locus) nucleotide sequence to match. \n    \n        Returns\n        -------\n        max_alignment : int\n            Maximum length (in nucleotides) nucleotide sequence that matches the \n            CDR3 'amino acid' sequence.\n        \n        Example\n        --------\n        >>> generation_probability.max_nt_to_aa_alignment_right('CASSSEGAGGPSLRGHEQFF', 'TTCATGAACACTGAAGCTTTCTTT')\n        6\n            \n        \"\"\"\n        r_CDR3_seq = CDR3_seq[::-1] #reverse CDR3_seq\n        r_ntseq = ntseq[::-1] #reverse ntseq\n        max_alignment = 0\n        if len(ntseq) == 0:\n            return 0\n        aa_aligned = True\n        while aa_aligned:\n            if r_ntseq[max_alignment:max_alignment+3][::-1] in self.codons_dict[r_CDR3_seq[max_alignment/3]]:\n                max_alignment += 3\n                if max_alignment/3 == len(CDR3_seq):\n                    return max_alignment\n            else:\n                break\n                aa_aligned = False\n        r_last_codon = r_ntseq[max_alignment:max_alignment+3]\n        codon_frag = ''\n        for nt in r_last_codon:\n            codon_frag = nt + codon_frag\n            if codon_frag in self.sub_codons_right[r_CDR3_seq[max_alignment/3]]:\n                max_alignment += 1\n            else:\n                break\n        return max_alignment"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncompute the Pgen for a given amino acid sequence and V_usage_mask and J_usage_mask.", "response": "def compute_CDR3_pgen(self, CDR3_seq, V_usage_mask, J_usage_mask):\n        \"\"\"Compute Pgen for CDR3 'amino acid' sequence CDR3_seq from VDJ model.\n    \n        Conditioned on the already formatted V genes/alleles indicated in \n        V_usage_mask and the J genes/alleles in J_usage_mask. \n        (Examples are TCRB sequences/model)\n    \n        Parameters\n        ----------\n        CDR3_seq : str\n            CDR3 sequence composed of 'amino acids' (single character symbols\n            each corresponding to a collection of codons as given by codons_dict).\n        V_usage_mask : list\n            Indices of the V alleles to be considered in the Pgen computation\n        J_usage_mask : list\n            Indices of the J alleles to be considered in the Pgen computation\n    \n        Returns\n        -------\n        pgen : float\n            The generation probability (Pgen) of the sequence\n        \n        Examples\n        --------\n        >>> compute_CDR3_pgen('CAWSVAPDRGGYTF', ppp, [42], [1])\n        1.203646865765782e-10\n        >>> compute_CDR3_pgen(nt2codon_rep('TGTGCCTGGAGTGTAGCTCCGGACAGGGGTGGCTACACCTTC'), ppp, [42], [1])\n        2.3986503758867323e-12\n        >>> compute_CDR3_pgen('\\xbb\\x96\\xab\\xb8\\x8e\\xb6\\xa5\\x92\\xa8\\xba\\x9a\\x93\\x94\\x9f', ppp, [42], [1])\n        2.3986503758867323e-12\n        \n        \"\"\"\n        \n        \n        #Genomic V alignment/matching (contribution from P(V, delV)), return Pi_V\n        Pi_V, max_V_align = self.compute_Pi_V(CDR3_seq, V_usage_mask)\n        \n        #Include VD insertions (Rvd and PinsVD) to get the total contribution from the left (3') side. Return Pi_L\n        Pi_L = self.compute_Pi_L(CDR3_seq, Pi_V, max_V_align)\n        \n        #Genomic J alignment/matching (contribution from P(D, J, delJ)), return Pi_J_given_D\n        Pi_J_given_D, max_J_align = self.compute_Pi_J_given_D(CDR3_seq, J_usage_mask)\n        \n        #Include DJ insertions (Rdj and PinsDJ), return Pi_JinsDJ_given_D\n        Pi_JinsDJ_given_D = self.compute_Pi_JinsDJ_given_D(CDR3_seq, Pi_J_given_D, max_J_align)\n        \n        #Include D genomic contribution (P(delDl, delDr | D)) to complete the contribution from the right (5') side. Return Pi_R\n        Pi_R = self.compute_Pi_R(CDR3_seq, Pi_JinsDJ_given_D)\n        \n        pgen = 0\n        \n        #zip Pi_L and Pi_R together to get total pgen\n        for pos in range(len(CDR3_seq)*3 - 1):\n            pgen += np.dot(Pi_L[:, pos], Pi_R[:, pos+1])\n            \n        return pgen"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef compute_Pi_V(self, CDR3_seq, V_usage_mask):\n        #Note, the cutV_genomic_CDR3_segs INCLUDE the palindromic insertions and thus are max_palindrome nts longer than the template.\n        #furthermore, the genomic sequence should be pruned to start at the conserved C\n        \n        Pi_V = np.zeros((4, len(CDR3_seq)*3)) #Holds the aggregate weight for each nt possiblity and position\n        alignment_lengths = []\n        for V_in in V_usage_mask:\n            try:\n                cutV_gen_seg = self.cutV_genomic_CDR3_segs[V_in]\n            except IndexError:\n                print 'Check provided V usage mask. Contains indicies out of allowed range.'\n                continue\n            current_alignment_length = self.max_nt_to_aa_alignment_left(CDR3_seq, cutV_gen_seg)\n            alignment_lengths += [current_alignment_length]\n            current_Pi_V = np.zeros((4, len(CDR3_seq)*3))\n            \n            if current_alignment_length > 0:\n                #For first and last nt in a codon use PVdelV_nt_pos_vec\n                current_Pi_V[:, :current_alignment_length] = self.PVdelV_nt_pos_vec[V_in][:, :current_alignment_length]\n                for pos in range(1, current_alignment_length, 3): #for middle nt use PVdelV_2nd_nt_pos_per_aa_vec\n                    current_Pi_V[:, pos] = self.PVdelV_2nd_nt_pos_per_aa_vec[V_in][CDR3_seq[pos/3]][:, pos]\n                Pi_V[:, :current_alignment_length] += current_Pi_V[:, :current_alignment_length]\n        \n        return Pi_V, max(alignment_lengths)", "response": "This function computes the Pi array corresponding to the V genomic nucleotide sequence and the V_usage_mask. This function computes the Pi array corresponding to the V genomic nucleotide sequence and the V_usage_mask."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef compute_Pi_J_given_D(self, CDR3_seq, J_usage_mask):\n        \n        #Note, the cutJ_genomic_CDR3_segs INCLUDE the palindromic insertions and thus are max_palindrome nts longer than the template.\n        #furthermore, the genomic sequence should be pruned to start at a conserved region on the J side\n        num_D_genes = self.PD_given_J.shape[0]\n        Pi_J_given_D = [np.zeros((4, len(CDR3_seq)*3)) for i in range(num_D_genes)] #Holds the aggregate weight for each nt possiblity and position\n        alignment_lengths = []\n        for J_in in J_usage_mask:\n            try:\n                cutJ_gen_seg = self.cutJ_genomic_CDR3_segs[J_in]\n            except IndexError:\n                print 'Check provided V usage mask. Contains indicies out of allowed range.'\n                continue\n            current_alignment_length = self.max_nt_to_aa_alignment_right(CDR3_seq, cutJ_gen_seg)\n            alignment_lengths += [current_alignment_length]\n            current_Pi_J = np.zeros((4, len(CDR3_seq)*3))\n    \n            if current_alignment_length > 0:\n                #For first and last nt in a codon use PJdelJ_nt_pos_vec\n                current_Pi_J[:, -current_alignment_length:] = self.PJdelJ_nt_pos_vec[J_in][:, -current_alignment_length:]          \n                for pos in range(-2, -current_alignment_length-1, -3): #for middle nt use PJdelJ_2nd_nt_pos_per_aa_vec\n                    current_Pi_J[:, pos] = self.PJdelJ_2nd_nt_pos_per_aa_vec[J_in][CDR3_seq[pos/3]][:, pos]\n    \n            for D_in, pd_given_j in enumerate(self.PD_given_J[:, J_in]):\n                Pi_J_given_D[D_in][:, -current_alignment_length:] += pd_given_j*current_Pi_J[:, -current_alignment_length:]\n        \n        return Pi_J_given_D, max(alignment_lengths)", "response": "This function computes the Pi_J given the D and J_usage_mask. The method is used to compute the Pi_J given the D and J_usage_mask."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef compute_Pi_R(self, CDR3_seq, Pi_JinsDJ_given_D):\n        \n        \n        #Need to consider all D alignments from all possible positions and right deletions.\n        nt2num = {'A': 0, 'C': 1, 'G': 2, 'T': 3}\n        \n        #n_aaseq = [aa_dict[aa] for aa in CDR3_seq]\n        Pi_R = np.zeros((4, len(CDR3_seq)*3))\n        min_pos = -len(CDR3_seq)*3\n        \n        num_dell_pos, num_delr_pos, num_D_genes = self.PdelDldelDr_given_D.shape\n        \n        for D_in, cutD_gen_seg  in enumerate(self.cutD_genomic_CDR3_segs):\n            l_D_seg = len(cutD_gen_seg)\n            \n            #start position is first nt in a codon\n            for init_pos in range(-1,-len(CDR3_seq)*3-1,-3):\n                Pi_R[:, init_pos] += Pi_JinsDJ_given_D[D_in][:, init_pos]*self.zeroD_given_D[D_in]\n                second_pos_dict = {'A': np.zeros(4), 'C': np.zeros(4), 'G': np.zeros(4), 'T': np.zeros(4)}\n                codon_prefix_dict = {}\n    \n                for last_nt in 'ACGT':\n                    for second_nt in 'ACGT':\n                        codon_prefix_dict[last_nt + second_nt] = np.zeros(4)\n                        #for first_nt in ['ACGT'[nt] for nt in range(4) if Pi_JinsDJ_given_D[D_in][nt, init_pos] > 0]:\n                        for first_nt in 'ACGT':\n                            if last_nt + second_nt + first_nt in self.codons_dict[CDR3_seq[init_pos/3]]: #possible allowed codon\n                                second_pos_dict[second_nt][nt2num[last_nt]] += Pi_JinsDJ_given_D[D_in][nt2num[first_nt], init_pos] #base weight for middle pos nt\n                                codon_prefix_dict[last_nt + second_nt][0] += Pi_JinsDJ_given_D[D_in][nt2num[first_nt], init_pos] #base weight for last pos nt\n                for nt1 in 'ACGT':\n                    if np.sum(second_pos_dict[nt1]) == 0:\n                        second_pos_dict.pop(nt1, None)\n                    for nt2 in 'ACGT':\n                        if np.sum(codon_prefix_dict[nt1+nt2])== 0:\n                            codon_prefix_dict.pop(nt1+nt2, None)\n                            \n    #            if len(second_pos_dict)> 0:\n    #                print second_pos_dict\n    #                return -1\n                \n                for delDr in range(num_delr_pos):\n                    if self.min_delDl_given_DdelDr[D_in][delDr] == -1: # P(delDr | D) = 0 for this delDr --> move to next\n                        continue\n                    #Check if first nt from the D segment is okay\n                    if cutD_gen_seg[l_D_seg - delDr - 1] in second_pos_dict.keys():\n                        #The dell pos may be out of range of the PdelDldelDr_given_D -- check!\n                        if l_D_seg - delDr - 1 <= self.max_delDl_given_DdelDr[D_in][delDr]:\n                            Pi_R[:, init_pos - 1] += self.PdelDldelDr_given_D[l_D_seg - delDr - 1, delDr, D_in]*second_pos_dict[cutD_gen_seg[l_D_seg - delDr - 1]]\n                    else:\n                        continue #not okay, reject the alignment\n                    \n                    #Check if the second nt from the D segment is okay\n                    if cutD_gen_seg[l_D_seg - delDr - 2:l_D_seg - delDr] in codon_prefix_dict.keys():\n                        #The dell pos may be out of range of the PdelDldelDr_given_D -- check!\n                        if l_D_seg - delDr - 2 <= self.max_delDl_given_DdelDr[D_in][delDr]:\n                            Pi_R[0, init_pos - 2] += self.PdelDldelDr_given_D[l_D_seg - delDr - 2, delDr, D_in]*codon_prefix_dict[cutD_gen_seg[l_D_seg - delDr - 2:l_D_seg - delDr]][0]\n                        base_prob = codon_prefix_dict[cutD_gen_seg[l_D_seg - delDr - 2:l_D_seg - delDr]][0]\n                    else:\n                        continue #no longer aligned, move to next delDr\n                        \n                    #Enter main loop\n                    for pos in range(init_pos - 3, max(init_pos - l_D_seg + delDr, min_pos)-1, -1):\n                        #note delDl = D_pos\n                        D_pos = l_D_seg - delDr - 1 - ((init_pos - 1) - pos)\n                        \n                        #The dell pos may be out of range of the PdelDldelDr_given_D -- check!\n                        if D_pos > self.max_delDl_given_DdelDr[D_in][delDr]:\n                            current_PdelDldelDr = 0\n                        else:\n                            current_PdelDldelDr = self.PdelDldelDr_given_D[D_pos, delDr, D_in]\n                        #Position is the first nt in codon\n                        if pos%3 == 2:\n                            #check alignment\n                            if cutD_gen_seg[D_pos] in self.sub_codons_right[CDR3_seq[pos/3]]:\n                                Pi_R[:, pos] += current_PdelDldelDr*base_prob*self.PD_nt_pos_vec[D_in][:, D_pos]\n                            else:\n                                break #no longer aligned -- exit loop\n                        #Position is the second nt in codon\n                        elif pos%3 == 1:\n                            #check alignment\n                            if cutD_gen_seg[D_pos:D_pos + 2] in self.sub_codons_right[CDR3_seq[pos/3]]:\n                                Pi_R[:, pos] += current_PdelDldelDr*base_prob*self.PD_2nd_nt_pos_per_aa_vec[D_in][CDR3_seq[pos/3]][ :, D_pos]\n                            else:\n                                break #no longer aligned --- exit loop\n                        #Position is the last nt in codon\n                        else:\n                            #check alignment\n                            if cutD_gen_seg[D_pos:D_pos + 3] in self.codons_dict[CDR3_seq[pos/3]]:\n                                Pi_R[0, pos] += current_PdelDldelDr*base_prob\n                            else:\n                                break #no longer aligned --- exit loop\n                        \n                    \n                        \n            #start position is second nt in a codon\n            for init_pos in range(-2,-len(CDR3_seq)*3-1,-3):\n                Pi_R[:, init_pos] += Pi_JinsDJ_given_D[D_in][:, init_pos]*self.zeroD_given_D[D_in]\n                allowed_final_nts = ['ACGT'[nt] for nt in range(4) if Pi_JinsDJ_given_D[D_in][nt, init_pos] > 0]\n                \n                for delDr in range(num_delr_pos):\n                    if self.min_delDl_given_DdelDr[D_in][delDr] == -1: # P(delDr | D) = 0 for this delDr --> move to next\n                        continue\n                    #check first nt of the D region (last in the codon)\n                    if cutD_gen_seg[l_D_seg - delDr - 1] in allowed_final_nts: #first nt match\n                        base_prob = Pi_JinsDJ_given_D[D_in][nt2num[cutD_gen_seg[l_D_seg - delDr - 1]], init_pos]\n                        #The dell pos may be out of range of the PdelDldelDr_given_D -- check!\n                        if l_D_seg - delDr - 1 <= self.max_delDl_given_DdelDr[D_in][delDr]:\n                            Pi_R[0, init_pos-1] += self.PdelDldelDr_given_D[l_D_seg - delDr - 1, delDr, D_in]*base_prob\n                    else:\n                        continue #no alignment\n                        \n                    #Enter main loop\n                    for pos in range(init_pos - 2, max(init_pos - l_D_seg + delDr, min_pos)-1, -1):\n                        #note delDl = D_pos\n                        D_pos = l_D_seg - delDr - 1 - ((init_pos - 1) - pos)\n                        \n                        #The dell pos may be out of range of the PdelDldelDr_given_D -- check!\n                        if D_pos > self.max_delDl_given_DdelDr[D_in][delDr]:\n                            current_PdelDldelDr = 0\n                        else:\n                            current_PdelDldelDr = self.PdelDldelDr_given_D[D_pos, delDr, D_in]\n                        #Position is the first nt in codon\n                        if pos%3 == 2:\n                            #check alignment\n                            if cutD_gen_seg[D_pos] in self.sub_codons_right[CDR3_seq[pos/3]]:\n                                Pi_R[:, pos] += current_PdelDldelDr*base_prob*self.PD_nt_pos_vec[D_in][:, D_pos]\n                            else:\n                                break #no longer aligned -- exit loop\n                        #Position is the second nt in codon\n                        elif pos%3 == 1:\n                            #check alignment\n                            if cutD_gen_seg[D_pos:D_pos + 2] in self.sub_codons_right[CDR3_seq[pos/3]]:\n                                Pi_R[:, pos] += current_PdelDldelDr*base_prob*self.PD_2nd_nt_pos_per_aa_vec[D_in][CDR3_seq[pos/3]][ :, D_pos]\n                            else:\n                                break #no longer aligned --- exit loop\n                        #Position is the last nt in codon\n                        else:\n                            #check alignment\n                            if cutD_gen_seg[D_pos:D_pos + 3] in self.codons_dict[CDR3_seq[pos/3]]:\n                                Pi_R[0, pos] += current_PdelDldelDr*base_prob\n                            else:\n                                break #no longer aligned --- exit loop\n                \n            #start position is last nt in a codon\n            for init_pos in range(-3,-len(CDR3_seq)*3-1,-3):\n                Pi_R[0, init_pos] += Pi_JinsDJ_given_D[D_in][0, init_pos]*self.zeroD_given_D[D_in] \n                for delDr in range(num_delr_pos):\n                    if self.min_delDl_given_DdelDr[D_in][delDr] == -1: # P(delDr | D) = 0 for this delDr --> move to next\n                        continue\n                    base_prob = Pi_JinsDJ_given_D[D_in][0, init_pos]\n                    for pos in range(init_pos - 1, max(init_pos - l_D_seg + delDr, min_pos)-1, -1):\n                        #note delDl = D_pos\n                        D_pos = l_D_seg - delDr - 1 - ((init_pos - 1) - pos)\n                        \n                        #The dell pos may be out of range of the PdelDldelDr_given_D -- check!\n                        if D_pos > self.max_delDl_given_DdelDr[D_in][delDr]:\n                            current_PdelDldelDr = 0\n                        else:\n                            current_PdelDldelDr = self.PdelDldelDr_given_D[D_pos, delDr, D_in]\n                        #Position is the first nt in codon\n                        if pos%3 == 2:\n                            #check alignment\n                            if cutD_gen_seg[D_pos] in self.sub_codons_right[CDR3_seq[pos/3]]:\n                                Pi_R[:, pos] += current_PdelDldelDr*base_prob*self.PD_nt_pos_vec[D_in][:, D_pos]\n                            else:\n                                break #no longer aligned -- exit loop\n                        #Position is the second nt in codon\n                        elif pos%3 == 1:\n                            #check alignment\n                            if cutD_gen_seg[D_pos:D_pos + 2] in self.sub_codons_right[CDR3_seq[pos/3]]:\n                                Pi_R[:, pos] += current_PdelDldelDr*base_prob*self.PD_2nd_nt_pos_per_aa_vec[D_in][CDR3_seq[pos/3]][ :, D_pos]\n                            else:\n                                break #no longer aligned --- exit loop\n                        #Position is the last nt in codon\n                        else:\n                            #check alignment\n                            if cutD_gen_seg[D_pos:D_pos + 3] in self.codons_dict[CDR3_seq[pos/3]]:\n                                Pi_R[0, pos] += current_PdelDldelDr*base_prob\n                            else:\n                                break #no longer aligned --- exit loop\n                                \n        return Pi_R", "response": "This function computes the Pi array from the model factors of the D and JV sequences and the model factors of the D and JV sequences."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef compute_CDR3_pgen(self, CDR3_seq, V_usage_mask, J_usage_mask):\n        \n        #Genomic J alignment/matching (contribution from P(delJ | J)), return Pi_J and reduced J_usage_mask\n        Pi_J, r_J_usage_mask = self.compute_Pi_J(CDR3_seq, J_usage_mask)\n        \n        #Genomic V alignment/matching conditioned on J gene (contribution from P(V, J, delV)), return Pi_V_given_J\n        Pi_V_given_J, max_V_align = self.compute_Pi_V_given_J(CDR3_seq, V_usage_mask, r_J_usage_mask)\n        \n        #Include insertions (R and PinsVJ) to get the total contribution from the left (3') side conditioned on J gene. Return Pi_V_insVJ_given_J\n        Pi_V_insVJ_given_J = self.compute_Pi_V_insVJ_given_J(CDR3_seq, Pi_V_given_J, max_V_align)\n        \n        pgen = 0\n        #zip Pi_V_insVJ_given_J and Pi_J together for each J gene to get total pgen\n        for j in range(len(r_J_usage_mask)):\n            for pos in range(len(CDR3_seq)*3 - 1):\n                pgen += np.dot(Pi_V_insVJ_given_J[j][:, pos], Pi_J[j][:, pos+1])\n        return pgen", "response": "Compute the Pgen for a CDR3 amino acid sequence and return the Pi_J and reduced J_usage_mask."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef compute_Pi_V_given_J(self, CDR3_seq, V_usage_mask, J_usage_mask):\n        \n        #Note, the cutV_genomic_CDR3_segs INCLUDE the palindromic insertions and thus are max_palindrome nts longer than the template.\n        #furthermore, the genomic sequence should be pruned to start at the conserved C\n        \n        Pi_V_given_J = [np.zeros((4, len(CDR3_seq)*3)) for i in J_usage_mask] #Holds the aggregate weight for each nt possiblity and position\n        alignment_lengths = []\n        for V_in in V_usage_mask:\n            try:\n                cutV_gen_seg = self.cutV_genomic_CDR3_segs[V_in]\n            except IndexError:\n                print 'Check provided V usage mask. Contains indicies out of allowed range.'\n                continue\n            current_alignment_length = self.max_nt_to_aa_alignment_left(CDR3_seq, cutV_gen_seg)\n            alignment_lengths += [current_alignment_length]\n            current_Pi_V = np.zeros((4, len(CDR3_seq)*3))\n            \n            if current_alignment_length > 0:\n                #For first and last nt in a codon use PVdelV_nt_pos_vec\n                current_Pi_V[:, :current_alignment_length] = self.PVdelV_nt_pos_vec[V_in][:, :current_alignment_length]\n                for pos in range(1, current_alignment_length, 3): #for middle nt use PVdelV_2nd_nt_pos_per_aa_vec\n                    current_Pi_V[:, pos] = self.PVdelV_2nd_nt_pos_per_aa_vec[V_in][CDR3_seq[pos/3]][:, pos]\n                for j, J_in in enumerate(J_usage_mask):\n                    Pi_V_given_J[j][:, :current_alignment_length] += self.PVJ[V_in, J_in]*current_Pi_V[:, :current_alignment_length]\n        \n        return Pi_V_given_J, max(alignment_lengths)", "response": "This function computes the Pi array for a given V and J."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef compute_Pi_J(self, CDR3_seq, J_usage_mask):\n        #Note, the cutJ_genomic_CDR3_segs INCLUDE the palindromic insertions and thus are max_palindrome nts longer than the template.\n        #furthermore, the genomic sequence should be pruned to start at a conserved region on the J side\n        \n        Pi_J = [] #Holds the aggregate weight for each nt possiblity and position\n        r_J_usage_mask = []\n        for j, J_in in enumerate(J_usage_mask):\n            try:\n                cutJ_gen_seg = self.cutJ_genomic_CDR3_segs[J_in]\n            except IndexError:\n                print 'Check provided J usage mask. Contains indicies out of allowed range.'\n                continue\n            current_alignment_length = self.max_nt_to_aa_alignment_right(CDR3_seq, cutJ_gen_seg)\n            #alignment_lengths += [current_alignment_length]\n            current_Pi_J = np.zeros((4, len(CDR3_seq)*3))\n            \n            if current_alignment_length > 0:\n                #For first and last nt in a codon use PJdelJ_nt_pos_vec\n                current_Pi_J[:, -current_alignment_length:] = self.PJdelJ_nt_pos_vec[J_in][:, -current_alignment_length:]          \n                for pos in range(-2, -current_alignment_length-1, -3): #for middle nt use PJdelJ_2nd_nt_pos_per_aa_vec\n                    current_Pi_J[:, pos] = self.PJdelJ_2nd_nt_pos_per_aa_vec[J_in][CDR3_seq[pos/3]][:, pos]\n                if np.sum(current_Pi_J) > 0:\n                    Pi_J.append(current_Pi_J)\n                    r_J_usage_mask.append(J_in)\n        \n        return Pi_J, r_J_usage_mask", "response": "This function computes the Pi array corresponding to the J genomic nucleotide sequence and the J_usage mask."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef solve(self, lam):\n        '''Solves the GFL for a fixed value of lambda.'''\n        s = weighted_graphtf(self.nnodes, self.y, self.weights, lam,\n                             self.Dk.shape[0], self.Dk.shape[1], self.Dk.nnz,\n                             self.Dk.row.astype('int32'), self.Dk.col.astype('int32'), self.Dk.data.astype('double'),\n                             self.maxsteps, self.converge,\n                             self.beta, self.u)\n        self.steps.append(s)\n        return self.beta", "response": "Solves the GFL for a fixed value of lambda."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nfollows the solution path to find the best lambda value.", "response": "def solution_path(self, min_lambda, max_lambda, lambda_bins, verbose=0):\n        '''Follows the solution path to find the best lambda value.'''\n        self.u = np.zeros(self.Dk.shape[0], dtype='double')\n        lambda_grid = np.exp(np.linspace(np.log(max_lambda), np.log(min_lambda), lambda_bins))\n        aic_trace = np.zeros(lambda_grid.shape) # The AIC score for each lambda value\n        aicc_trace = np.zeros(lambda_grid.shape) # The AICc score for each lambda value (correcting for finite sample size)\n        bic_trace = np.zeros(lambda_grid.shape) # The BIC score for each lambda value\n        dof_trace = np.zeros(lambda_grid.shape) # The degrees of freedom of each final solution\n        log_likelihood_trace = np.zeros(lambda_grid.shape)\n        beta_trace = []\n        best_idx = None\n        best_plateaus = None\n\n        if self.edges is None:\n            self.edges = defaultdict(list)\n            elist = csr_matrix(self.D).indices.reshape((self.D.shape[0], 2))\n            for n1, n2 in elist:\n                self.edges[n1].append(n2)\n                self.edges[n2].append(n1)\n\n        # Solve the series of lambda values with warm starts at each point\n        for i, lam in enumerate(lambda_grid):\n            if verbose:\n                print('#{0} Lambda = {1}'.format(i, lam))\n\n            # Fit to the final values\n            beta = self.solve(lam)\n\n            if verbose:\n                print('Calculating degrees of freedom')\n\n            # Count the number of free parameters in the grid (dof) -- TODO: the graph trend filtering paper seems to imply we shouldn't multiply by (k+1)?\n            dof_vals = self.Dk_minus_one.dot(beta) if self.k > 0 else beta\n            plateaus = calc_plateaus(dof_vals, self.edges, rel_tol=0.01) if (self.k % 2) == 0 else nearly_unique(dof_vals, rel_tol=0.03)\n            dof_trace[i] = max(1,len(plateaus)) #* (k+1)\n\n            if verbose:\n                print('Calculating Information Criteria')\n\n            # Get the negative log-likelihood\n            log_likelihood_trace[i] = -0.5 * ((self.y - beta)**2).sum()\n\n            # Calculate AIC = 2k - 2ln(L)\n            aic_trace[i] = 2. * dof_trace[i] - 2. * log_likelihood_trace[i]\n            \n            # Calculate AICc = AIC + 2k * (k+1) / (n - k - 1)\n            aicc_trace[i] = aic_trace[i] + 2 * dof_trace[i] * (dof_trace[i]+1) / (len(beta) - dof_trace[i] - 1.)\n\n            # Calculate BIC = -2ln(L) + k * (ln(n) - ln(2pi))\n            bic_trace[i] = -2 * log_likelihood_trace[i] + dof_trace[i] * (np.log(len(beta)) - np.log(2 * np.pi))\n\n            # Track the best model thus far\n            if best_idx is None or bic_trace[i] < bic_trace[best_idx]:\n                best_idx = i\n                best_plateaus = plateaus\n\n            # Save the trace of all the resulting parameters\n            beta_trace.append(np.array(beta))\n            \n            if verbose:\n                print('DoF: {0} AIC: {1} AICc: {2} BIC: {3}\\n'.format(dof_trace[i], aic_trace[i], aicc_trace[i], bic_trace[i]))\n\n        if verbose:\n            print('Best setting (by BIC): lambda={0} [DoF: {1}, AIC: {2}, AICc: {3} BIC: {4}]'.format(lambda_grid[best_idx], dof_trace[best_idx], aic_trace[best_idx], aicc_trace[best_idx], bic_trace[best_idx]))\n\n        return {'aic': aic_trace,\n                'aicc': aicc_trace,\n                'bic': bic_trace,\n                'dof': dof_trace,\n                'loglikelihood': log_likelihood_trace,\n                'beta': np.array(beta_trace),\n                'lambda': lambda_grid,\n                'best_idx': best_idx,\n                'best': beta_trace[best_idx],\n                'plateaus': best_plateaus}"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsolving the GFL for a fixed value of lambda.", "response": "def solve(self, lam):\n        '''Solves the GFL for a fixed value of lambda.'''\n        s = weighted_graphtf_logit(self.nnodes, self.trials, self.successes, lam,\n                                 self.Dk.shape[0], self.Dk.shape[1], self.Dk.nnz,\n                                 self.Dk.row.astype('int32'), self.Dk.col.astype('int32'), self.Dk.data.astype('double'),\n                                 self.maxsteps, self.converge,\n                                 self.beta, self.u)\n        self.steps.append(s)\n        return self.beta"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nsolve the GFL for a fixed value of lambda.", "response": "def solve(self, lam):\n        '''Solves the GFL for a fixed value of lambda.'''\n        s = weighted_graphtf_poisson(self.nnodes, self.obs, lam,\n                                 self.Dk.shape[0], self.Dk.shape[1], self.Dk.nnz,\n                                 self.Dk.row.astype('int32'), self.Dk.col.astype('int32'), self.Dk.data.astype('double'),\n                                 self.maxsteps, self.converge,\n                                 self.beta, self.u)\n        self.steps.append(s)\n        return self.beta"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nconstruct the V and J mask mapping dictionaries.", "response": "def make_V_and_J_mask_mapping(self, genV, genJ):\n        \"\"\"Constructs the V and J mask mapping dictionaries.\n        \n        Parameters\n        ----------\n        genV : list\n            List of genomic V information.            \n        genJ : list\n            List of genomic J information.\n        \n        \"\"\"\n        #construct mapping between allele/gene names and index for custom V_usage_masks\n        V_allele_names = [V[0] for V in genV]\n        V_mask_mapping = {}\n        for v in set([x.split('*')[0] for x in V_allele_names]):\n            V_mask_mapping[v] = []\n        for v in set(['V'.join((x.split('*')[0]).split('V')[1:]) for x in V_allele_names]):\n            V_mask_mapping[v] = []\n        for i, v in enumerate(V_allele_names):\n            V_mask_mapping[v] = [i]\n            V_mask_mapping['V'.join((v.split('*')[0]).split('V')[1:])].append(i)\n            V_mask_mapping[v.split('*')[0]].append(i)      \n        \n        #construct mapping between allele/gene names and index for custom J_usage_masks\n        J_allele_names = [J[0] for J in genJ]\n        J_mask_mapping = {}\n        for j in set([x.split('*')[0] for x in J_allele_names]):\n            J_mask_mapping[j] = []\n        for j in set(['J'.join((x.split('*')[0]).split('J')[1:]) for x in J_allele_names]):\n            J_mask_mapping[j] = []\n        for i, j in enumerate(J_allele_names):\n            J_mask_mapping[j] = [i]\n            J_mask_mapping['J'.join((j.split('*')[0]).split('J')[1:])].append(i)\n            J_mask_mapping[j.split('*')[0]].append(i)\n            \n        self.V_allele_names = V_allele_names\n        self.V_mask_mapping = V_mask_mapping\n        self.J_allele_names = J_allele_names\n        self.J_mask_mapping = J_mask_mapping"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef preprocess_D_segs(self, generative_model, genomic_data):\n    \n        cutD_genomic_CDR3_segs = genomic_data.cutD_genomic_CDR3_segs\n        nt2num = {'A': 0, 'C': 1, 'G': 2, 'T': 3}\n        num_dell_pos, num_delr_pos, num_D_genes = generative_model.PdelDldelDr_given_D.shape\n        \n        #These arrays only include the nt identity information, not the PdelDldelDr_given_D info\n        PD_nt_pos_vec = [[]]*num_D_genes\n        PD_2nd_nt_pos_per_aa_vec = [[]]*num_D_genes\n        for D_in in range(num_D_genes):\n           \n            current_PD_nt_pos_vec = np.zeros((4, len(cutD_genomic_CDR3_segs[D_in])))\n            current_PD_2nd_nt_pos_per_aa_vec = {}\n            for aa in self.codons_dict.keys():\n                current_PD_2nd_nt_pos_per_aa_vec[aa] = np.zeros((4, len(cutD_genomic_CDR3_segs[D_in])))\n            \n            for pos, nt in enumerate(cutD_genomic_CDR3_segs[D_in]):\n                current_PD_nt_pos_vec[nt2num[nt], pos] = 1\n                for ins_nt in 'ACGT':\n                    for aa in self.codons_dict.keys():\n                        if ins_nt + cutD_genomic_CDR3_segs[D_in][pos:pos+2] in self.codons_dict[aa]:\n                            current_PD_2nd_nt_pos_per_aa_vec[aa][nt2num[ins_nt], pos] = 1\n                            \n            PD_nt_pos_vec[D_in] = current_PD_nt_pos_vec\n            PD_2nd_nt_pos_per_aa_vec[D_in] = current_PD_2nd_nt_pos_per_aa_vec\n        \n        min_delDl_given_DdelDr = [[]]*num_D_genes\n        max_delDl_given_DdelDr = [[]]*num_D_genes\n        zeroD_given_D = [[]]*num_D_genes\n        for D_in in range(num_D_genes):\n            current_min_delDl_given_delDr = [0]*num_delr_pos\n            current_max_delDl_given_delDr = [0]*num_delr_pos\n            current_zeroD = 0\n            for delr in range(num_delr_pos):\n                \n                if num_dell_pos > len(cutD_genomic_CDR3_segs[D_in])-delr:\n                    current_zeroD += generative_model.PdelDldelDr_given_D[len(cutD_genomic_CDR3_segs[D_in])-delr, delr, D_in]\n                \n                dell = 0\n                while generative_model.PdelDldelDr_given_D[dell, delr, D_in]==0 and dell<num_dell_pos-1:\n                    dell+=1\n                if generative_model.PdelDldelDr_given_D[dell, delr, D_in] == 0:\n                    current_min_delDl_given_delDr[delr] = -1\n                else:\n                    current_min_delDl_given_delDr[delr] = dell\n                if current_min_delDl_given_delDr[delr] == -1:\n                    current_max_delDl_given_delDr[delr] = -1\n                else:\n                    dell = num_dell_pos-1\n                    while generative_model.PdelDldelDr_given_D[dell, delr, D_in]==0 and dell>=0:\n                        dell -= 1\n                    if generative_model.PdelDldelDr_given_D[dell, delr, D_in] == 0:\n                        current_max_delDl_given_delDr[delr] = -1\n                    else:\n                        current_max_delDl_given_delDr[delr] = dell\n                \n            min_delDl_given_DdelDr[D_in] = current_min_delDl_given_delDr\n            max_delDl_given_DdelDr[D_in] = current_max_delDl_given_delDr\n            zeroD_given_D[D_in] = current_zeroD\n        \n        self.PD_nt_pos_vec = PD_nt_pos_vec\n        self.PD_2nd_nt_pos_per_aa_vec = PD_2nd_nt_pos_per_aa_vec\n        self.min_delDl_given_DdelDr = min_delDl_given_DdelDr \n        self.max_delDl_given_DdelDr = max_delDl_given_DdelDr\n        self.zeroD_given_D = zeroD_given_D", "response": "Preprocess the D sequences into Pi arrays."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngenerating the PJdelJ_nt_pos_vec and PJdelJ_2nd_nt_pos_per_aa_vec attributes for the VDJ object.", "response": "def generate_PJdelJ_nt_pos_vecs(self, generative_model, genomic_data):\n        \"\"\"Process P(J)*P(delJ|J) into Pi arrays.\n        \n        Sets the attributes PJdelJ_nt_pos_vec and PJdelJ_2nd_nt_pos_per_aa_vec.\n    \n        Parameters\n        ----------\n        generative_model : GenerativeModelVDJ\n            VDJ generative model class containing the model parameters.            \n        genomic_data : GenomicDataVDJ\n            VDJ genomic data class containing the V, D, and J germline \n            sequences and info.\n        \n        \"\"\"\n    \n        cutJ_genomic_CDR3_segs = genomic_data.cutJ_genomic_CDR3_segs\n        nt2num = {'A': 0, 'C': 1, 'G': 2, 'T': 3}\n        num_del_pos = generative_model.PdelJ_given_J.shape[0]\n    \n        num_D_genes, num_J_genes = generative_model.PDJ.shape\n        PJ = np.sum(generative_model.PDJ, axis = 0)\n    \n        PJdelJ_nt_pos_vec = [[]]*num_J_genes\n        PJdelJ_2nd_nt_pos_per_aa_vec = [[]]*num_J_genes\n        for J_in, pj in enumerate(PJ):\n            #We include the marginal PJ here\n            current_PJdelJ_nt_pos_vec = np.zeros((4, len(cutJ_genomic_CDR3_segs[J_in])))\n            current_PJdelJ_2nd_nt_pos_per_aa_vec  = {}\n            for aa in self.codons_dict.keys():\n                current_PJdelJ_2nd_nt_pos_per_aa_vec[aa] = np.zeros((4, len(cutJ_genomic_CDR3_segs[J_in])))\n    \n            for pos, nt in enumerate(cutJ_genomic_CDR3_segs[J_in]):\n                if pos >=  num_del_pos:\n                    continue\n                if (len(cutJ_genomic_CDR3_segs[J_in]) - pos)%3 == 1: #Start of a codon\n                    current_PJdelJ_nt_pos_vec[nt2num[nt], pos] = pj*generative_model.PdelJ_given_J[pos, J_in]\n                elif (len(cutJ_genomic_CDR3_segs[J_in]) - pos)%3 == 2: #Mid codon position\n                    for ins_nt in 'ACGT':\n                        #We need to find what possible codons are allowed for any aa (or motif)\n                        for aa in self.codons_dict.keys():\n                            if ins_nt + cutJ_genomic_CDR3_segs[J_in][pos:pos+2] in self.codons_dict[aa]:\n                                current_PJdelJ_2nd_nt_pos_per_aa_vec[aa][nt2num[ins_nt], pos] = pj*generative_model.PdelJ_given_J[pos, J_in]\n                                \n                elif (len(cutJ_genomic_CDR3_segs[J_in]) - pos)%3 == 0: #End  of codon\n                    current_PJdelJ_nt_pos_vec[0, pos] = pj*generative_model.PdelJ_given_J[pos, J_in]\n            PJdelJ_nt_pos_vec[J_in] = current_PJdelJ_nt_pos_vec\n            PJdelJ_2nd_nt_pos_per_aa_vec[J_in] = current_PJdelJ_2nd_nt_pos_per_aa_vec\n        \n        self.PJdelJ_nt_pos_vec = PJdelJ_nt_pos_vec\n        self.PJdelJ_2nd_nt_pos_per_aa_vec = PJdelJ_2nd_nt_pos_per_aa_vec"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef generate_VD_junction_transfer_matrices(self):\n        \n        nt2num = {'A': 0, 'C': 1, 'G': 2, 'T': 3}                \n        \n        #Compute Tvd\n        Tvd = {}\n        for aa in self.codons_dict.keys():\n            current_Tvd = np.zeros((4, 4))\n            for init_nt in 'ACGT':\n                for codon in self.codons_dict[aa]:\n                    current_Tvd[nt2num[codon[2]], nt2num[init_nt]] += self.Rvd[nt2num[codon[2]],nt2num[codon[1]]]*self.Rvd[nt2num[codon[1]],nt2num[codon[0]]] * self.Rvd[nt2num[codon[0]],nt2num[init_nt]]\n            Tvd[aa] = current_Tvd\n            \n        #Compute Svd\n        Svd = {}\n        for aa in self.codons_dict.keys():\n            current_Svd = np.zeros((4, 4))\n            for ins_nt in 'ACGT':\n                if any([codon.startswith(ins_nt) for codon in self.codons_dict[aa]]):\n                    current_Svd[nt2num[ins_nt], :] = self.Rvd[nt2num[ins_nt], :]\n                \n            Svd[aa] = current_Svd\n        \n        #Compute Dvd                \n        Dvd = {}\n        for aa in self.codons_dict.keys():\n            current_Dvd = np.zeros((4, 4))\n            for init_nt in 'ACGT':\n                for codon in self.codons_dict[aa]:\n                    current_Dvd[nt2num[codon[2]], nt2num[init_nt]] += self.Rvd[nt2num[codon[1]],nt2num[codon[0]]] * self.Rvd[nt2num[codon[0]],nt2num[init_nt]]\n            Dvd[aa] = current_Dvd\n     \n\n        #Compute lTvd\n        lTvd = {}\n        for aa in self.codons_dict.keys():\n            current_lTvd = np.zeros((4, 4))\n            for codon in self.codons_dict[aa]:\n                current_lTvd[nt2num[codon[2]], nt2num[codon[0]]] += self.Rvd[nt2num[codon[2]],nt2num[codon[1]]]*self.first_nt_bias_insVD[nt2num[codon[1]]]\n            lTvd[aa] = current_lTvd\n\n        \n        #Compute lDvd\n        lDvd = {}\n        for aa in self.codons_dict.keys():\n            current_lDvd = np.zeros((4, 4))\n            for codon in self.codons_dict[aa]:\n                current_lDvd[nt2num[codon[2]], nt2num[codon[0]]] += self.first_nt_bias_insVD[nt2num[codon[1]]]\n            lDvd[aa] = current_lDvd\n        \n        #Set the attributes\n        self.Tvd = Tvd\n        self.Svd = Svd\n        self.Dvd = Dvd\n        self.lTvd = lTvd\n        self.lDvd = lDvd", "response": "Compute the transfer matrices for the VD junction."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef generate_DJ_junction_transfer_matrices(self):\n        \n        nt2num = {'A': 0, 'C': 1, 'G': 2, 'T': 3}\n\n        #Compute Tdj    \n        Tdj = {}\n        for aa in self.codons_dict.keys():\n            current_Tdj = np.zeros((4, 4))\n            for init_nt in 'ACGT':\n                for codon in self.codons_dict[aa]:\n                    current_Tdj[nt2num[codon[0]], nt2num[init_nt]] += self.Rdj[nt2num[codon[0]],nt2num[codon[1]]]*self.Rdj[nt2num[codon[1]],nt2num[codon[2]]] * self.Rdj[nt2num[codon[2]],nt2num[init_nt]]\n            Tdj[aa] = current_Tdj\n        \n        #Compute Sdj\n        Sdj = {}\n        for aa in self.codons_dict.keys():\n            current_Sdj = np.zeros((4, 4))\n            for ins_nt in 'ACGT':\n                if any([codon.endswith(ins_nt) for codon in self.codons_dict[aa]]):\n                    current_Sdj[nt2num[ins_nt], :] = self.Rdj[nt2num[ins_nt], :]    \n            Sdj[aa] = current_Sdj\n        \n        #Compute Ddj\n        Ddj = {}\n        for aa in self.codons_dict.keys():\n            current_Ddj = np.zeros((4, 4))\n            for init_nt in 'ACGT':\n                for codon in self.codons_dict[aa]:\n                    current_Ddj[nt2num[codon[0]], nt2num[init_nt]] += self.Rdj[nt2num[codon[1]],nt2num[codon[2]]] * self.Rdj[nt2num[codon[2]],nt2num[init_nt]]\n            Ddj[aa] = current_Ddj\n        \n        #Compute rTdj\n        rTdj = {}\n        for aa in self.codons_dict.keys():\n            current_lTdj = np.zeros((4, 4))\n            for codon in self.codons_dict[aa]:\n                current_lTdj[nt2num[codon[0]], nt2num[codon[2]]] += self.Rdj[nt2num[codon[0]],nt2num[codon[1]]]*self.first_nt_bias_insDJ[nt2num[codon[1]]]\n            rTdj[aa] = current_lTdj\n        \n        #Compute rDdj\n        rDdj = {}\n        for aa in self.codons_dict.keys():\n            current_rDdj = np.zeros((4, 4))\n            for codon in self.codons_dict[aa]:\n                current_rDdj[nt2num[codon[0]], nt2num[codon[2]]] += self.first_nt_bias_insDJ[nt2num[codon[1]]]\n            rDdj[aa] = current_rDdj\n    \n        #Set the attributes\n        self.Tdj = Tdj\n        self.Sdj = Sdj\n        self.Ddj = Ddj\n        self.rTdj = rTdj\n        self.rDdj = rDdj", "response": "Compute the transfer matrices for the VD junction."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef generate_PVdelV_nt_pos_vecs(self, generative_model, genomic_data):\n    \n        cutV_genomic_CDR3_segs = genomic_data.cutV_genomic_CDR3_segs\n        nt2num = {'A': 0, 'C': 1, 'G': 2, 'T': 3}\n        num_del_pos = generative_model.PdelV_given_V.shape[0]\n        num_V_genes = generative_model.PdelV_given_V.shape[1]\n        PVdelV_nt_pos_vec = [[]]*num_V_genes\n        PVdelV_2nd_nt_pos_per_aa_vec = [[]]*num_V_genes\n        for V_in in range(num_V_genes):\n            current_PVdelV_nt_pos_vec = np.zeros((4, len(cutV_genomic_CDR3_segs[V_in])))\n            current_PVdelV_2nd_nt_pos_per_aa_vec = {}\n            for aa in self.codons_dict.keys():\n                current_PVdelV_2nd_nt_pos_per_aa_vec[aa] = np.zeros((4, len(cutV_genomic_CDR3_segs[V_in])))\n            for pos, nt in enumerate(cutV_genomic_CDR3_segs[V_in]):\n                if len(cutV_genomic_CDR3_segs[V_in]) - pos >  num_del_pos:\n                    continue\n                if pos%3 == 0: #Start of a codon\n                    current_PVdelV_nt_pos_vec[nt2num[nt], pos] = generative_model.PdelV_given_V[len(cutV_genomic_CDR3_segs[V_in])-pos-1, V_in]    \n                elif pos%3 == 1: #Mid codon position\n                    for ins_nt in 'ACGT':\n                        #We need to find what possible codons are allowed for any aa (or motif)\n                        for aa in self.codons_dict.keys():\n                            if cutV_genomic_CDR3_segs[V_in][pos-1:pos+1]+ ins_nt in self.codons_dict[aa]:\n                                current_PVdelV_2nd_nt_pos_per_aa_vec[aa][nt2num[ins_nt], pos] = generative_model.PdelV_given_V[len(cutV_genomic_CDR3_segs[V_in])-pos-1, V_in]            \n                elif pos%3 == 2: #End of codon\n                    current_PVdelV_nt_pos_vec[0, pos] = generative_model.PdelV_given_V[len(cutV_genomic_CDR3_segs[V_in])-pos-1, V_in]\n            PVdelV_nt_pos_vec[V_in] = current_PVdelV_nt_pos_vec\n            PVdelV_2nd_nt_pos_per_aa_vec[V_in] = current_PVdelV_2nd_nt_pos_per_aa_vec\n    \n        \n        self.PVdelV_nt_pos_vec = PVdelV_nt_pos_vec\n        self.PVdelV_2nd_nt_pos_per_aa_vec = PVdelV_2nd_nt_pos_per_aa_vec", "response": "Generate the PVdelV_nt_pos_vec and PVdelV_2nd_nt_pos_per_aa_vec attributes for the V and J germlinevines."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ngenerate the PJdelJ NT positives vectors for the given V and J.", "response": "def generate_PJdelJ_nt_pos_vecs(self, generative_model, genomic_data):\n        \"\"\"Process P(delJ|J) into Pi arrays.\n        \n        Set the attributes PJdelJ_nt_pos_vec and PJdelJ_2nd_nt_pos_per_aa_vec.\n    \n        Parameters\n        ----------\n        generative_model : GenerativeModelVJ\n            VJ generative model class containing the model parameters.            \n        genomic_data : GenomicDataVJ\n            VJ genomic data class containing the V and J germline \n            sequences and info.\n        \n        \"\"\"\n        \n        cutJ_genomic_CDR3_segs = genomic_data.cutJ_genomic_CDR3_segs\n        nt2num = {'A': 0, 'C': 1, 'G': 2, 'T': 3}\n        num_del_pos = generative_model.PdelJ_given_J.shape[0]\n    \n        num_D_genes, num_J_genes = generative_model.PVJ.shape\n    \n        PJdelJ_nt_pos_vec = [[]]*num_J_genes\n        PJdelJ_2nd_nt_pos_per_aa_vec = [[]]*num_J_genes\n        for J_in in range(num_J_genes):\n            current_PJdelJ_nt_pos_vec = np.zeros((4, len(cutJ_genomic_CDR3_segs[J_in])))\n            current_PJdelJ_2nd_nt_pos_per_aa_vec  = {}\n            for aa in self.codons_dict.keys():\n                current_PJdelJ_2nd_nt_pos_per_aa_vec[aa] = np.zeros((4, len(cutJ_genomic_CDR3_segs[J_in])))\n    \n            for pos, nt in enumerate(cutJ_genomic_CDR3_segs[J_in]):\n                if pos >=  num_del_pos:\n                    continue\n                if (len(cutJ_genomic_CDR3_segs[J_in]) - pos)%3 == 1: #Start of a codon\n                    current_PJdelJ_nt_pos_vec[nt2num[nt], pos] = generative_model.PdelJ_given_J[pos, J_in]\n                elif (len(cutJ_genomic_CDR3_segs[J_in]) - pos)%3 == 2: #Mid codon position\n                    for ins_nt in 'ACGT':\n                        #We need to find what possible codons are allowed for any aa (or motif)\n                        for aa in self.codons_dict.keys():\n                            if ins_nt + cutJ_genomic_CDR3_segs[J_in][pos:pos+2] in self.codons_dict[aa]:\n                                current_PJdelJ_2nd_nt_pos_per_aa_vec[aa][nt2num[ins_nt], pos] = generative_model.PdelJ_given_J[pos, J_in]\n                                \n                elif (len(cutJ_genomic_CDR3_segs[J_in]) - pos)%3 == 0: #End  of codon\n                    current_PJdelJ_nt_pos_vec[0, pos] = generative_model.PdelJ_given_J[pos, J_in]\n            PJdelJ_nt_pos_vec[J_in] = current_PJdelJ_nt_pos_vec\n            PJdelJ_2nd_nt_pos_per_aa_vec[J_in] = current_PJdelJ_2nd_nt_pos_per_aa_vec\n            \n        self.PJdelJ_nt_pos_vec = PJdelJ_nt_pos_vec\n        self.PJdelJ_2nd_nt_pos_per_aa_vec = PJdelJ_2nd_nt_pos_per_aa_vec"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef generate_VJ_junction_transfer_matrices(self):\n        \n        nt2num = {'A': 0, 'C': 1, 'G': 2, 'T': 3}                \n        \n        #Compute Tvj\n        Tvj = {}\n        for aa in self.codons_dict.keys():\n            current_Tvj = np.zeros((4, 4))\n            for init_nt in 'ACGT':\n                for codon in self.codons_dict[aa]:\n                    current_Tvj[nt2num[codon[2]], nt2num[init_nt]] += self.Rvj[nt2num[codon[2]],nt2num[codon[1]]]*self.Rvj[nt2num[codon[1]],nt2num[codon[0]]] * self.Rvj[nt2num[codon[0]],nt2num[init_nt]]\n            Tvj[aa] = current_Tvj\n    \n        #Compute Svj\n        Svj = {}\n        for aa in self.codons_dict.keys():\n            current_Svj = np.zeros((4, 4))\n            for ins_nt in 'ACGT':\n                if any([codon.startswith(ins_nt) for codon in self.codons_dict[aa]]):\n                    current_Svj[nt2num[ins_nt], :] = self.Rvj[nt2num[ins_nt], :]             \n            Svj[aa] = current_Svj\n        \n        #Compute Dvj               \n        Dvj = {}    \n        for aa in self.codons_dict.keys():\n            current_Dvj = np.zeros((4, 4))\n            for init_nt in 'ACGT':\n                for codon in self.codons_dict[aa]:\n                    current_Dvj[nt2num[codon[2]], nt2num[init_nt]] += self.Rvj[nt2num[codon[1]],nt2num[codon[0]]] * self.Rvj[nt2num[codon[0]],nt2num[init_nt]]\n            Dvj[aa] = current_Dvj\n\n        #Compute lTvj\n        lTvj = {}\n        for aa in self.codons_dict.keys():\n            current_lTvj = np.zeros((4, 4))\n            for codon in self.codons_dict[aa]:\n                current_lTvj[nt2num[codon[2]], nt2num[codon[0]]] += self.Rvj[nt2num[codon[2]],nt2num[codon[1]]]*self.first_nt_bias_insVJ[nt2num[codon[1]]]\n            lTvj[aa] = current_lTvj\n\n        #Compute lDvj        \n        lDvj = {}    \n        for aa in self.codons_dict.keys():\n            current_lDvj = np.zeros((4, 4))\n            for codon in self.codons_dict[aa]:\n                current_lDvj[nt2num[codon[2]], nt2num[codon[0]]] += self.first_nt_bias_insVJ[nt2num[codon[1]]]\n            lDvj[aa] = current_lDvj\n    \n\n        #Set the attributes\n        self.Tvj = Tvj\n        self.Svj = Svj\n        self.Dvj = Dvj\n        self.lTvj = lTvj\n        self.lDvj = lDvj", "response": "Generate the transfer matrices for the VJ junction."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nprints the DATA_DIRECTORY fields.", "response": "def showDataDirectoriesData(peInstance):\n    \"\"\" Prints the DATA_DIRECTORY fields. \"\"\"\n    \n    print \"[+] Data directories:\\n\"\n    dirs = peInstance.ntHeaders.optionalHeader.dataDirectory\n    counter = 1\n    for dir in dirs:\n        print \"[%d] --> Name: %s -- RVA: 0x%08x -- SIZE: 0x%08x\" % (counter,  dir.name.value,  dir.rva.value,  dir.size.value)\n        counter += 1"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef showSectionsHeaders(peInstance):\n    \n    print \"[+] Sections information:\\n\"\n    print \"--> NumberOfSections: %d\\n\" % peInstance.ntHeaders.fileHeader.numberOfSections.value\n    for section in peInstance.sectionHeaders:\n        fields = section.getFields()\n        for field in fields:\n            if isinstance(fields[field],  datatypes.String):\n                fmt = \"%s = %s\"\n            else:\n                fmt = \"%s = 0x%08x\"\n            print fmt % (field,  fields[field].value)\n        print \"\\n\"", "response": "Prints IMAGE_SECTION_HEADER for every section present in the file."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef showImports(peInstance):\n    \n    iidEntries = peInstance.ntHeaders.optionalHeader.dataDirectory[consts.IMPORT_DIRECTORY].info\n    if iidEntries:\n        for iidEntry in iidEntries:\n            fields = iidEntry.getFields()\n            print \"module: %s\" % iidEntry.metaData.moduleName.value\n            for field in fields:\n                print \"%s -> %x\" % (field,  fields[field].value)\n            \n            for iatEntry in iidEntry.iat:\n                fields = iatEntry.getFields()\n                for field in fields:\n                    print \"%s - %r\" % (field,  fields[field].value)\n                    \n            print \"\\n\"\n    else:\n        print \"The file does not have imported functions.\"", "response": "Shows the imports information."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef getFields(self):\n        d = {}\n        for i in self._attrsList:\n            key = i\n            value = getattr(self,  i)\n            d[key] = value\n        return d", "response": "Returns all the class attributues.\n        \n       "}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nparses the contents of the n - bit array and returns a new array.", "response": "def parse(readDataInstance,  arrayType,  arrayLength):\n        \"\"\"\n        Returns a new L{Array} object.\n        \n        @type readDataInstance: L{ReadData}\n        @param readDataInstance: The L{ReadData} object containing the array data.\n        \n        @type arrayType: int\n        @param arrayType: The type of L{Array} to be built.\n        \n        @type arrayLength: int\n        @param arrayLength: The length of the array passed as an argument.\n        \n        @rtype: L{Array}\n        @return: New L{Array} object.\n        \"\"\"\n        newArray = Array(arrayType)\n        \n        dataLength = len(readDataInstance)\n        \n        if arrayType is TYPE_DWORD:\n            toRead = arrayLength * 4\n            if dataLength >= toRead: \n                for i in range(arrayLength):\n                    newArray.append(DWORD(readDataInstance.readDword()))\n            else:\n                raise excep.DataLengthException(\"Not enough bytes to read.\")\n                \n        elif arrayType is TYPE_WORD:\n            toRead = arrayLength * 2\n            if dataLength >= toRead:\n                for i in range(arrayLength):\n                    newArray.append(DWORD(readDataInstance.readWord()))\n            else:\n                raise excep.DataLengthException(\"Not enough bytes to read.\")\n                \n        elif arrayType is TYPE_QWORD:\n            toRead = arrayLength * 8\n            if dataLength >= toRead:\n                for i in range(arrayLength):\n                    newArray.append(QWORD(readDataInstance.readQword()))\n            else:\n                raise excep.DataLengthException(\"Not enough bytes to read.\")\n                \n        elif arrayType is TYPE_BYTE:\n            for i in range(arrayLength):\n                newArray.append(BYTE(readDataInstance.readByte()))\n        \n        else:\n            raise excep.ArrayTypeException(\"Could\\'t create an array of type %d\" % arrayType)\n            \n        return newArray"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef calc_euler_tour(g, start, end):\n    '''Calculates an Euler tour over the graph g from vertex start to vertex end.\n    Assumes start and end are odd-degree vertices and that there are no other odd-degree\n    vertices.'''\n    even_g = nx.subgraph(g, g.nodes()).copy()\n    if end in even_g.neighbors(start):\n        # If start and end are neighbors, remove the edge\n        even_g.remove_edge(start, end)\n        comps = list(nx.connected_components(even_g))\n        # If the graph did not split, just find the euler circuit\n        if len(comps) == 1:\n            trail = list(nx.eulerian_circuit(even_g, start))\n            trail.append((start, end))\n        elif len(comps) == 2:\n            subg1 = nx.subgraph(even_g, comps[0])\n            subg2 = nx.subgraph(even_g, comps[1])\n            start_subg, end_subg = (subg1, subg2) if start in subg1.nodes() else (subg2, subg1)\n            trail = list(nx.eulerian_circuit(start_subg, start)) + [(start, end)] + list(nx.eulerian_circuit(end_subg, end))\n        else:\n            raise Exception('Unknown edge case with connected components of size {0}:\\n{1}'.format(len(comps), comps))\n    else:\n        # If they are not neighbors, we add an imaginary edge and calculate the euler circuit\n        even_g.add_edge(start, end)\n        circ = list(nx.eulerian_circuit(even_g, start))\n        try:\n            trail_start = circ.index((start, end))\n        except:\n            trail_start = circ.index((end, start))\n        trail = circ[trail_start+1:] + circ[:trail_start]\n    return trail", "response": "Calculates an Euler tour over the graph g from vertex start to vertex end."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef greedy_trails(subg, odds, verbose):\n    '''Greedily select trails by making the longest you can until the end'''\n    if verbose:\n        print('\\tCreating edge map')\n\n    edges = defaultdict(list)\n\n    for x,y in subg.edges():\n        edges[x].append(y)\n        edges[y].append(x)\n\n    if verbose:\n        print('\\tSelecting trails')\n\n    trails = []\n    for x in subg.nodes():\n        if verbose > 2:\n            print('\\t\\tNode {0}'.format(x))\n\n        while len(edges[x]) > 0:\n            y = edges[x][0]\n            trail = [(x,y)]\n            edges[x].remove(y)\n            edges[y].remove(x)\n            while len(edges[y]) > 0:\n                x = y\n                y = edges[y][0]\n                trail.append((x,y))\n                edges[x].remove(y)\n                edges[y].remove(x)\n            trails.append(trail)\n    return trails", "response": "Greedily select trails by making the longest you can until the end."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ndecompose a graph into a set of non - overlapping trails.", "response": "def decompose_graph(g, heuristic='tour', max_odds=20, verbose=0):\n    '''Decompose a graph into a set of non-overlapping trails.'''\n    # Get the connected subgraphs\n    subgraphs = [nx.subgraph(g, x).copy() for x in nx.connected_components(g)]\n\n    chains = []\n    num_subgraphs = len(subgraphs)\n    step = 0\n    while num_subgraphs > 0:\n        if verbose:\n            print('Step #{0} ({1} subgraphs)'.format(step, num_subgraphs))\n\n        for i in range(num_subgraphs-1, -1, -1):\n            subg = subgraphs[i]\n\n            # Get all odd-degree nodes\n            odds = [x for x,y in dict(nx.degree(subg)).items() if y % 2 == 1]\n\n            if verbose > 1:\n                if len(odds) == 0:\n                    print('\\t\\tNo odds')\n                elif len(odds) == 2:\n                    print('\\t\\tExactly 2 odds')\n                else:\n                    print('\\t\\t{0} odds'.format(len(odds)))\n            \n            # If there are no odd-degree edges, we can find an euler circuit\n            if len(odds) == 0:\n                trails = [list(nx.eulerian_circuit(subg))]\n            elif len(odds) == 2:\n                # If there are only two odd-degree edges, we can find an euler tour\n                trails = [calc_euler_tour(subg, odds[0], odds[1])]\n            elif heuristic in ['min', 'max', 'median', 'any']:\n                trails = select_odd_degree_trail(subg, odds, max_odds, heuristic, verbose)\n            elif heuristic == 'random':\n                trails = select_random_trail(subg, verbose)\n            elif heuristic == 'mindegree':\n                trails = select_min_degree_trail(subg, max_odds, verbose)\n            elif heuristic == 'ones':\n                trails = select_single_edge_trails(subg, verbose)\n            elif heuristic == 'tour':\n                trails = pseudo_tour_trails(subg, odds, verbose)\n            elif heuristic == 'greedy':\n                trails = greedy_trails(subg, odds, verbose)\n\n            if verbose > 2:\n                print('\\t\\tTrails: {0}'.format(len(trails)))\n\n            # Remove the trail\n            for trail in trails:\n                subg.remove_edges_from(trail)\n\n            # Add it to the list of chains\n            chains.extend(trails)\n            \n            # If the subgraph is empty, remove it from the list\n            if subg.number_of_edges() == 0:\n                del subgraphs[i]\n            else:\n                comps = list(nx.connected_components(subg))\n\n                # If the last edge split the graph, add the new subgraphs to the list of subgraphs\n                if len(comps) > 1:\n                    for x in comps:\n                        compg = nx.subgraph(subg, x)\n                        if compg.number_of_edges() > 0:\n                            subgraphs.append(compg)\n                    del subgraphs[i]\n\n        # Update the count of connected subgraphs\n        num_subgraphs = len(subgraphs)\n        step += 1\n\n    return chains"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a new Vector with the x y and z added.", "response": "def plus(self, a):\n        \"\"\" Add. \"\"\"\n        return Vector(self.x+a.x, self.y+a.y, self.z+a.z)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef minus(self, a):\n        return Vector(self.x-a.x, self.y-a.y, self.z-a.z)", "response": "Subtracts the vector a from self."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef times(self, a):\n        return Vector(self.x*a, self.y*a, self.z*a)", "response": "Multiply the Vector by a number."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ndividing by a vector.", "response": "def dividedBy(self, a):\n        \"\"\" Divide. \"\"\"\n        return Vector(self.x/a, self.y/a, self.z/a)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate a new vertex between this vertex and other by linearly interpolating all properties using a parameter of t.", "response": "def interpolate(self, other, t):\n        \"\"\"\n        Create a new vertex between this vertex and `other` by linearly\n        interpolating all properties using a parameter of `t`. Subclasses should\n        override this to interpolate additional properties.\n        \"\"\"\n        return Vertex(self.pos.lerp(other.pos, t), \n                          self.normal.lerp(other.normal, t))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef splitPolygon(self, polygon, coplanarFront, coplanarBack, front, back):\n        COPLANAR = 0 # all the vertices are within EPSILON distance from plane\n        FRONT = 1 # all the vertices are in front of the plane\n        BACK = 2 # all the vertices are at the back of the plane\n        SPANNING = 3 # some vertices are in front, some in the back\n\n        # Classify each point as well as the entire polygon into one of the above\n        # four classes.\n        polygonType = 0\n        vertexLocs = []\n        \n        numVertices = len(polygon.vertices)\n        for i in range(numVertices):\n            t = self.normal.dot(polygon.vertices[i].pos) - self.w\n            loc = -1\n            if t < -Plane.EPSILON: \n                loc = BACK\n            elif t > Plane.EPSILON: \n                loc = FRONT\n            else: \n                loc = COPLANAR\n            polygonType |= loc\n            vertexLocs.append(loc)\n    \n        # Put the polygon in the correct list, splitting it when necessary.\n        if polygonType == COPLANAR:\n            normalDotPlaneNormal = self.normal.dot(polygon.plane.normal)\n            if normalDotPlaneNormal > 0:\n                coplanarFront.append(polygon)\n            else:\n                coplanarBack.append(polygon)\n        elif polygonType == FRONT:\n            front.append(polygon)\n        elif polygonType == BACK:\n            back.append(polygon)\n        elif polygonType == SPANNING:\n            f = []\n            b = []\n            for i in range(numVertices):\n                j = (i+1) % numVertices\n                ti = vertexLocs[i]\n                tj = vertexLocs[j]\n                vi = polygon.vertices[i]\n                vj = polygon.vertices[j]\n                if ti != BACK: \n                    f.append(vi)\n                if ti != FRONT:\n                    if ti != BACK: \n                        b.append(vi.clone())\n                    else:\n                        b.append(vi)\n                if (ti | tj) == SPANNING:\n                    # interpolation weight at the intersection point\n                    t = (self.w - self.normal.dot(vi.pos)) / self.normal.dot(vj.pos.minus(vi.pos))\n                    # intersection point on the plane\n                    v = vi.interpolate(vj, t)\n                    f.append(v)\n                    b.append(v.clone())\n            if len(f) >= 3: \n                front.append(Polygon(f, polygon.shared))\n            if len(b) >= 3: \n                back.append(Polygon(b, polygon.shared))", "response": "Splits a polygon into two lists of coplanar polygons."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ninvert the solid space to empty space and empty space to solid space.", "response": "def invert(self):\n        \"\"\" \n        Convert solid space to empty space and empty space to solid space.\n        \"\"\"\n        for poly in self.polygons:\n            poly.flip()\n        self.plane.flip()\n        if self.front: \n            self.front.invert()\n        if self.back: \n            self.back.invert()\n        temp = self.front\n        self.front = self.back\n        self.back = temp"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nremoves all polygons in this BSP tree that are inside the other BSP tree.", "response": "def clipTo(self, bsp):\n        \"\"\" \n        Remove all polygons in this BSP tree that are inside the other BSP tree\n        `bsp`.\n        \"\"\"\n        self.polygons = bsp.clipPolygons(self.polygons)\n        if self.front: \n            self.front.clipTo(bsp)\n        if self.back: \n            self.back.clipTo(bsp)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a list of all polygons in this BSP tree.", "response": "def allPolygons(self):\n        \"\"\"\n        Return a list of all polygons in this BSP tree.\n        \"\"\"\n        polygons = self.polygons[:]\n        if self.front: \n            polygons.extend(self.front.allPolygons())\n        if self.back: \n            polygons.extend(self.back.allPolygons())\n        return polygons"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef build(self, polygons):\n        if len(polygons) == 0:\n            return\n        if not self.plane: \n            self.plane = polygons[0].plane.clone()\n        # add polygon to this node\n        self.polygons.append(polygons[0])\n        front = []\n        back = []\n        # split all other polygons using the first polygon's plane\n        for poly in polygons[1:]:\n            # coplanar front and back polygons go into self.polygons\n            self.plane.splitPolygon(poly, self.polygons, self.polygons,\n                                    front, back)\n        # recursively build the BSP tree\n        if len(front) > 0:\n            if not self.front:\n                self.front = BSPNode()\n            self.front.build(front)\n        if len(back) > 0:\n            if not self.back:\n                self.back = BSPNode()\n            self.back.build(back)", "response": "Builds a BSP tree out of a list of polygons."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the rate from the default currency to currency.", "response": "def get_rate(currency):\n    \"\"\"Returns the rate from the default currency to `currency`.\"\"\"\n    source = get_rate_source()\n    try:\n        return Rate.objects.get(source=source, currency=currency).value\n    except Rate.DoesNotExist:\n        raise CurrencyConversionException(\n            \"Rate for %s in %s do not exists. \"\n            \"Please run python manage.py update_rates\" % (\n                currency, source.name))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the default Rate Source and return it.", "response": "def get_rate_source():\n    \"\"\"Get the default Rate Source and return it.\"\"\"\n    backend = money_rates_settings.DEFAULT_BACKEND()\n    try:\n        return RateSource.objects.get(name=backend.get_source_name())\n    except RateSource.DoesNotExist:\n        raise CurrencyConversionException(\n            \"Rate for %s source do not exists. \"\n            \"Please run python manage.py update_rates\" % backend.get_source_name())"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef base_convert_money(amount, currency_from, currency_to):\n    source = get_rate_source()\n\n    # Get rate for currency_from.\n    if source.base_currency != currency_from:\n        rate_from = get_rate(currency_from)\n    else:\n        # If currency from is the same as base currency its rate is 1.\n        rate_from = Decimal(1)\n\n    # Get rate for currency_to.\n    rate_to = get_rate(currency_to)\n\n    if isinstance(amount, float):\n        amount = Decimal(amount).quantize(Decimal('.000001'))\n\n    # After finishing the operation, quantize down final amount to two points.\n    return ((amount / rate_from) * rate_to).quantize(Decimal(\"1.00\"))", "response": "Convert amount from currency_from to currency_to"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef convert_money(amount, currency_from, currency_to):\n    new_amount = base_convert_money(amount, currency_from, currency_to)\n    return moneyed.Money(new_amount, currency_to)", "response": "Convert amount from currency_from to currency_to and return a Money object of the converted amount."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef format_date(format_string=None, datetime_obj=None):\n    datetime_obj = datetime_obj or datetime.now()\n    if format_string is None:\n        seconds = int(datetime_obj.strftime(\"%s\"))\n        milliseconds = datetime_obj.microsecond // 1000\n        return str(seconds * 1000 + milliseconds)\n    else:\n        formatter = SimpleDateFormat(format_string)\n        return formatter.format_datetime(datetime_obj)", "response": "Formats a datetime object with Java SimpleDateFormat s - like string."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncheck if a given buffer is empty and returns a boolean indicating if it is full of zeros.", "response": "def allZero(buffer):\n    \"\"\"\n    Tries to determine if a buffer is empty.\n    \n    @type buffer: str\n    @param buffer: Buffer to test if it is empty.\n        \n    @rtype: bool\n    @return: C{True} if the given buffer is empty, i.e. full of zeros,\n        C{False} if it doesn't.\n    \"\"\"\n    allZero = True\n    for byte in buffer:\n        if byte != \"\\x00\":\n            allZero = False\n            break\n    return allZero"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nwrite a byte into the L { WriteData object object.", "response": "def writeByte(self, byte):\n        \"\"\"\n        Writes a byte into the L{WriteData} stream object.\n        \n        @type byte: int\n        @param byte: Byte value to write into the stream.\n        \"\"\"\n        self.data.write(pack(\"B\" if not self.signed else \"b\", byte))"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nwrites a word into the L { WriteData object object.", "response": "def writeWord(self, word):\n        \"\"\"\n        Writes a word value into the L{WriteData} stream object.\n        \n        @type word: int\n        @param word: Word value to write into the stream.\n        \"\"\"\n        self.data.write(pack(self.endianness + (\"H\" if not self.signed else \"h\"), word))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef writeDword(self, dword):\n        self.data.write(pack(self.endianness + (\"L\" if not self.signed else \"l\"), dword))", "response": "Writes a dword value into the L { WriteData object object."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nwriting a qword value into the L { WriteData object object.", "response": "def writeQword(self, qword):\n        \"\"\"\n        Writes a qword value into the L{WriteData} stream object.\n        \n        @type qword: int\n        @param qword: Qword value to write into the stream.\n        \"\"\"\n        self.data.write(pack(self.endianness + (\"Q\" if not self.signed else \"q\"),  qword))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef setOffset(self, value):\n        if value >= len(self.data.getvalue()):\n            raise excep.WrongOffsetValueException(\"Wrong offset value. Must be less than %d\" % len(self.data))\n        self.data.seek(value)", "response": "Sets the offset of the data in which the data is written."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef skipBytes(self, nroBytes):\n        self.data.seek(nroBytes + self.data.tell())", "response": "Skips the specified number of bytes from the current value of the APK."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef readDword(self):\n        dword = unpack(self.endianness + ('L' if not self.signed else 'l'), self.readAt(self.offset,  4))[0]\n        self.offset += 4\n        return dword", "response": "Reads a dword value from the L { ReadData } stream object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef readWord(self):\n        word = unpack(self.endianness + ('H' if not self.signed else 'h'), self.readAt(self.offset, 2))[0]\n        self.offset += 2\n        return word", "response": "Reads a word value from the L { ReadData object object."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef readByte(self):\n        byte = unpack('B' if not self.signed else 'b', self.readAt(self.offset, 1))[0]\n        self.offset += 1\n        return byte", "response": "Reads a byte value from the L { ReadData } stream object."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef readQword(self):\n        qword = unpack(self.endianness + ('Q' if not self.signed else 'b'),  self.readAt(self.offset, 8))[0]\n        self.offset += 8\n        return qword", "response": "Reads a qword value from the L { ReadData } stream object."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreading an ASCII string from the stream object.", "response": "def readString(self):\n        \"\"\"\n        Reads an ASCII string from the L{ReadData} stream object.\n        \n        @rtype: str\n        @return: An ASCII string read form the stream.\n        \"\"\"\n        resultStr = \"\"\n        while self.data[self.offset] != \"\\x00\":\n            resultStr += self.data[self.offset]\n            self.offset += 1\n        return resultStr"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreads an ASCII string aligned to the next align - bytes boundary.", "response": "def readAlignedString(self, align = 4):\n        \"\"\" \n        Reads an ASCII string aligned to the next align-bytes boundary.\n        \n        @type align: int\n        @param align: (Optional) The value we want the ASCII string to be aligned.\n        \n        @rtype: str\n        @return: A 4-bytes aligned (default) ASCII string.\n        \"\"\"\n        s = self.readString()\n        r = align - len(s) % align\n        while r:\n            s += self.data[self.offset]\n            self.offset += 1\n            r -= 1\n        return s.rstrip(\"\\x00\")"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef read(self, nroBytes):\n        if nroBytes > self.length - self.offset:\n            if self.log:\n                print \"Warning: Trying to read: %d bytes - only %d bytes left\" % (nroBytes,  self.length - self.offset)\n            nroBytes = self.length - self.offset\n\n        resultStr = self.data[self.offset:self.offset + nroBytes]\n        self.offset += nroBytes\n        return resultStr", "response": "Reads the contents of the n - bytes in the object at the current offset and returns it as a string."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef readAt(self, offset, size):\n        if offset > self.length:\n            if self.log:\n                print \"Warning: Trying to read: %d bytes - only %d bytes left\" % (nroBytes,  self.length - self.offset)\n            offset = self.length - self.offset\n        tmpOff = self.tell()\n        self.setOffset(offset)\n        r = self.read(size)\n        self.setOffset(tmpOff)\n        return r", "response": "Reads as many bytes as possible from the specified offset."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nsend a message to a specific channel.", "response": "def send(self, message, channel_name=None, fail_silently=False,\n             options=None):\n        # type: (Text, Optional[str], bool, Optional[SendOptions]) -> None\n        \"\"\"Send a notification to channels\n\n        :param message: A message\n        \"\"\"\n        if channel_name is None:\n            channels = self.settings[\"CHANNELS\"]\n        else:\n            try:\n                channels = {\n                    \"__selected__\": self.settings[\"CHANNELS\"][channel_name]\n                }\n            except KeyError:\n                raise Exception(\"channels does not exist %s\", channel_name)\n\n        for _, config in channels.items():\n            if \"_backend\" not in config:\n                raise ImproperlyConfigured(\n                    \"Specify the backend class in the channel configuration\")\n\n            backend = self._load_backend(config[\"_backend\"])  # type: Any\n            config = deepcopy(config)\n            del config[\"_backend\"]\n            channel = backend(**config)\n            channel.send(message, fail_silently=fail_silently, options=options)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nsend an HTTP request to the specified path. Returns the HTTPResponse object.", "response": "def request(self, method, path,\n                params=None, headers=None, cookies=None, data=None, json=None, allow_redirects=None, timeout=None):\n        \"\"\"\n        Prepares and sends an HTTP request. Returns the HTTPResponse object.\n\n        :param method: str\n        :param path: str\n        :return: response\n        :rtype: HTTPResponse\n        \"\"\"\n        headers = headers or {}\n        timeout = timeout if timeout is not None else self._timeout\n        allow_redirects = allow_redirects if allow_redirects is not None else self._allow_redirects\n\n        if self._keep_alive and self.__session is None:\n            self.__session = requests.Session()\n\n        if self.__session is not None and not self._use_cookies:\n            self.__session.cookies.clear()\n\n        address = self._bake_address(path)\n        req_headers = copy.deepcopy(self._additional_headers)\n        req_headers.update(headers)\n\n        response = http.request(method, address, session=self.__session,\n                                params=params, headers=headers, cookies=cookies, data=data, json=json,\n                                allow_redirects=allow_redirects, timeout=timeout)\n        if self._auto_assert_ok:\n            response.assert_ok()\n        return response"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef load_genomic_CDR3_anchor_pos_and_functionality(anchor_pos_file_name):\n    \n    anchor_pos_and_functionality = {}\n    anchor_pos_file = open(anchor_pos_file_name, 'r')\n    \n    first_line = True\n    for line in anchor_pos_file:\n        if first_line:\n            first_line = False\n            continue\n        \n        split_line = line.split(',')\n        split_line = [x.strip() for x in split_line]\n        anchor_pos_and_functionality[split_line[0]] = [int(split_line[1]), split_line[2].strip().strip('()')]\n\n    return anchor_pos_and_functionality", "response": "Reads the CDR3 anchor position and functionality from file."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef read_igor_V_gene_parameters(params_file_name):\n    params_file = open(params_file_name, 'r')\n    \n    V_gene_info = {}\n\n    in_V_gene_sec = False\n    for line in params_file:\n        if line.startswith('#GeneChoice;V_gene;'):\n            in_V_gene_sec = True\n        elif in_V_gene_sec:\n            if line[0] == '%':\n                split_line = line[1:].split(';')\n                V_gene_info[split_line[0]] = [split_line[1] , int(split_line[2])]\n            else:\n                break\n    params_file.close()\n    \n    genV = [[]]*len(V_gene_info.keys())\n    \n    for V_gene in V_gene_info.keys():\n        genV[V_gene_info[V_gene][1]] = [V_gene, '', V_gene_info[V_gene][0]]\n\n    return genV", "response": "Load raw genV from IGOR parameter file."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nload genD from IGOR parameter file.", "response": "def read_igor_D_gene_parameters(params_file_name):\n    \"\"\"Load genD from file.\n    \n    genD is a list of genomic D information. Each element is a list of the name\n    of the D allele and the germline sequence.\n\n    Parameters\n    ----------\n    params_file_name : str\n        File name for a IGOR parameter file.\n\n    Returns\n    -------\n    genD : list\n        List of genomic D information.\n    \n    \"\"\"\n    params_file = open(params_file_name, 'r')\n    \n    D_gene_info = {}\n\n    in_D_gene_sec = False\n    for line in params_file:\n        if line.startswith('#GeneChoice;D_gene;'):\n            in_D_gene_sec = True\n        elif in_D_gene_sec:\n            if line[0] == '%':\n                split_line = line[1:].split(';')\n                D_gene_info[split_line[0]] = [split_line[1] , int(split_line[2])]\n            else:\n                break\n    params_file.close()\n    \n    genD = [[]]*len(D_gene_info.keys())\n    \n    for D_gene in D_gene_info.keys():\n        genD[D_gene_info[D_gene][1]] = [D_gene, D_gene_info[D_gene][0]]\n\n    return genD"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef read_igor_J_gene_parameters(params_file_name):\n    params_file = open(params_file_name, 'r')\n    \n    J_gene_info = {}\n\n    in_J_gene_sec = False\n    for line in params_file:\n        if line.startswith('#GeneChoice;J_gene;'):\n            in_J_gene_sec = True\n        elif in_J_gene_sec:\n            if line[0] == '%':\n                split_line = line[1:].split(';')\n                J_gene_info[split_line[0]] = [split_line[1] , int(split_line[2])]\n            else:\n                break\n    params_file.close()\n    \n    genJ = [[]]*len(J_gene_info.keys())\n    \n    for J_gene in J_gene_info.keys():\n        genJ[J_gene_info[J_gene][1]] = [J_gene, '', J_gene_info[J_gene][0]]\n\n    return genJ", "response": "Load raw genJ from IGOR parameter file."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreads a GOR model marginals file and returns a dictionary with model parameters and dimension names.", "response": "def read_igor_marginals_txt(marginals_file_name , dim_names=False):\n    \"\"\"Load raw IGoR model marginals.\n    \n    Parameters\n    ----------\n    marginals_file_name : str\n        File name for a IGOR model marginals file.\n\n    Returns\n    -------\n    model_dict : dict\n        Dictionary with model marginals.\n    dimension_names_dict : dict\n        Dictionary that defines IGoR model dependecies.\n    \n    \"\"\"\n    with open(marginals_file_name,'r') as file:\n        #Model parameters are stored inside a dictionary of ndarrays\n        model_dict = {}\n        dimension_names_dict = {}\n        element_name=\"\"\n        first = True\n        first_dim_line = False\n        element_marginal_array = []\n        indices_array = []\n\n        for line in file:\n            strip_line = line.rstrip('\\n') #Remove end of line character\n            if strip_line[0]=='@':\n                first_dim_line = True\n                if not(first):\n                    #Add the previous to the dictionnary\n                    model_dict[element_name] = element_marginal_array\n                else:\n                    first = False\n\t\t\t\t\n                element_name = strip_line[1:]\n\n            if strip_line[0]=='$':\n                #define array dimensions\n                coma_index = strip_line.find(',')\n                dimensions = []\n\n                #Get rid of $Dim[\n                previous_coma_index = 4\n                while coma_index != -1:\n                    dimensions.append(int(strip_line[previous_coma_index+1:coma_index]))\n                    previous_coma_index = coma_index\n                    coma_index = strip_line.find(',',coma_index+1)\n\t\t\t\n                #Add last dimension and get rid of the closing bracket \n                dimensions.append(int(strip_line[previous_coma_index+1:-1]))\n\n                element_marginal_array = np.ndarray(shape=dimensions)\n\n            if strip_line[0]=='#':\n                if first_dim_line:\n                    dimensions_names = []\n                    if len(dimensions) > 1:\n                        comma_index = strip_line.find(',')\n                        opening_bracket_index = strip_line.find('[')\n                        while opening_bracket_index != -1:\n                            dimensions_names.append(strip_line[opening_bracket_index+1:comma_index])\n                            opening_bracket_index = strip_line.find('[',comma_index) \n                            comma_index = strip_line.find(',',opening_bracket_index)\n                    first_dim_line = False\n                    dimensions_names.append(element_name)\n                    dimension_names_dict[element_name] = dimensions_names\n                    \n                \n                #update indices\n                indices_array = []\n                if len(dimensions) > 1:\n                    comma_index = strip_line.find(',')\n                    closing_brack_index = strip_line.find(']')\t\t\t\t\t\n                    while closing_brack_index != -1:\n                        indices_array.append(int(strip_line[comma_index+1:closing_brack_index]))\n                        opening_bracket_index = strip_line.find('[',closing_brack_index) \n                        comma_index = strip_line.find(',',opening_bracket_index)\n                        closing_brack_index = strip_line.find(']',closing_brack_index+1)\n\t\t\t\t\n\n            if strip_line[0]=='%':\n                #read doubles\n                coma_index = strip_line.find(',')\n                marginals_values = []\n\n                #Get rid of the %\n                previous_coma_index = 0\n                while coma_index != -1:\n                    marginals_values.append(float(strip_line[previous_coma_index+1:coma_index]))\n                    previous_coma_index = coma_index\n                    coma_index = strip_line.find(',',coma_index+1)\n\t\t\t\n                #Add last dimension and get rid of the closing bracket \n                marginals_values.append(float(strip_line[previous_coma_index+1:]))\n                if len(marginals_values)!=dimensions[-1]:\n                    print \"problem\"\n                element_marginal_array[tuple(indices_array)] = marginals_values\n        model_dict[element_name] = element_marginal_array\t\t\t\t\n        \n        \n    return [model_dict,dimension_names_dict]"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef anchor_and_curate_genV_and_genJ(self, V_anchor_pos_file, J_anchor_pos_file):\n        \n        V_anchor_pos = load_genomic_CDR3_anchor_pos_and_functionality(V_anchor_pos_file)\n        J_anchor_pos = load_genomic_CDR3_anchor_pos_and_functionality(J_anchor_pos_file)\n        \n        for V in self.genV:\n            try:\n                if V_anchor_pos[V[0]][0] > 0 and V_anchor_pos[V[0]][1] == 'F': #Check for functionality\n                    V[1] = V[2][V_anchor_pos[V[0]][0]:]\n                else:\n                    V[1] = ''\n            except KeyError:\n                V[1] = ''\n    \n        for J in self.genJ:\n            try:\n                if J_anchor_pos[J[0]][0] > 0 and J_anchor_pos[J[0]][1] == 'F': #Check for functionality\n                    J[1] = J[2][:J_anchor_pos[J[0]][0]+3]\n                else:\n                    J[1] = ''\n            except KeyError:\n                J[1] = ''", "response": "Trim V and J germline sequences to the CDR3 region."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef generate_cutV_genomic_CDR3_segs(self):\n    \n        max_palindrome = self.max_delV_palindrome\n\n        self.cutV_genomic_CDR3_segs = []\n        for CDR3_V_seg in [x[1] for x in self.genV]:\n            if len(CDR3_V_seg) < max_palindrome:\n                self.cutV_genomic_CDR3_segs += [cutR_seq(CDR3_V_seg, 0, len(CDR3_V_seg))]\n            else:\n                self.cutV_genomic_CDR3_segs += [cutR_seq(CDR3_V_seg, 0, max_palindrome)]", "response": "Add palindromic inserted nucleotides to the genV attribute."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef generate_cutJ_genomic_CDR3_segs(self):\n        \n        max_palindrome = self.max_delJ_palindrome\n        self.cutJ_genomic_CDR3_segs = []\n        for CDR3_J_seg in [x[1] for x in self.genJ]:\n            if len(CDR3_J_seg) < max_palindrome:\n                self.cutJ_genomic_CDR3_segs += [cutL_seq(CDR3_J_seg, 0, len(CDR3_J_seg))]\n            else:\n                self.cutJ_genomic_CDR3_segs += [cutL_seq(CDR3_J_seg, 0, max_palindrome)]", "response": "Add palindromic inserted nucleotides to the genJ sequence."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nloads in genomic data from IGOR parameter file.", "response": "def load_igor_genomic_data(self, params_file_name, V_anchor_pos_file, J_anchor_pos_file):\n        \"\"\"Set attributes by loading in genomic data from IGoR parameter file.\n        \n        Sets attributes genV,  max_delV_palindrome, cutV_genomic_CDR3_segs, \n        genD, max_delDl_palindrome, max_delDr_palindrome, \n        cutD_genomic_CDR3_segs, genJ, max_delJ_palindrome, and \n        cutJ_genomic_CDR3_segs.\n        \n        Parameters\n        ----------\n        params_file_name : str\n            File name for a IGOR parameter file.\n        V_anchor_pos_file_name : str\n            File name for the conserved residue (C) locations and functionality \n            of each V genomic sequence.\n        J_anchor_pos_file_name : str\n            File name for the conserved residue (F/W) locations and \n            functionality of each J genomic sequence.\n        \n        \"\"\"\n        \n        self.genV = read_igor_V_gene_parameters(params_file_name)\n        self.genD = read_igor_D_gene_parameters(params_file_name)\n        self.genJ = read_igor_J_gene_parameters(params_file_name)\n        \n        self.anchor_and_curate_genV_and_genJ(V_anchor_pos_file, J_anchor_pos_file)\n \n        self.read_VDJ_palindrome_parameters(params_file_name) #Need palindrome info before generating cut_genomic_CDR3_segs\n\n        self.generate_cutV_genomic_CDR3_segs()\n        self.generate_cutD_genomic_CDR3_segs()\n        self.generate_cutJ_genomic_CDR3_segs()"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nadd palindromic inserted nucleotides to germline V sequences.", "response": "def generate_cutD_genomic_CDR3_segs(self):\n        \"\"\"Add palindromic inserted nucleotides to germline V sequences.\n        \n        The maximum number of palindromic insertions are appended to the\n        germline D segments so that delDl and delDr can index directly for number \n        of nucleotides to delete from a segment.\n        \n        Sets the attribute cutV_genomic_CDR3_segs.\n        \n        \"\"\"\n        max_palindrome_L = self.max_delDl_palindrome\n        max_palindrome_R = self.max_delDr_palindrome\n\n        self.cutD_genomic_CDR3_segs = []\n        for CDR3_D_seg in [x[1] for x in self.genD]:\n            if len(CDR3_D_seg) < min(max_palindrome_L, max_palindrome_R):\n                self.cutD_genomic_CDR3_segs += [cutR_seq(cutL_seq(CDR3_D_seg, 0, len(CDR3_D_seg)), 0, len(CDR3_D_seg))]\n            else:\n                self.cutD_genomic_CDR3_segs += [cutR_seq(cutL_seq(CDR3_D_seg, 0, max_palindrome_L), 0, max_palindrome_R)]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef read_VDJ_palindrome_parameters(self, params_file_name):\n        \n        params_file = open(params_file_name, 'r')\n        \n        \n        in_delV = False\n        in_delDl = False\n        in_delDr = False\n        in_delJ = False\n        \n        \n        for line in params_file:\n            if line.startswith('#Deletion;V_gene;'):\n                in_delV = True\n                in_delDl = False\n                in_delDr = False\n                in_delJ = False\n            elif line.startswith('#Deletion;D_gene;Three_prime;'):\n                in_delV = False\n                in_delDl = False\n                in_delDr = True\n                in_delJ = False\n            elif line.startswith('#Deletion;D_gene;Five_prime;'):\n                in_delV = False\n                in_delDl = True\n                in_delDr = False\n                in_delJ = False\n            elif line.startswith('#Deletion;J_gene;'):\n                in_delV = False\n                in_delDl = False\n                in_delDr = False\n                in_delJ = True\n            elif any([in_delV, in_delDl, in_delDr, in_delJ]) and line.startswith('%'):\n                if int(line.split(';')[-1]) == 0:\n                    if in_delV:\n                        self.max_delV_palindrome = np.abs(int(line.lstrip('%').split(';')[0]))\n                    elif in_delDl:\n                        self.max_delDl_palindrome = np.abs(int(line.lstrip('%').split(';')[0]))\n                    elif in_delDr:\n                        self.max_delDr_palindrome = np.abs(int(line.lstrip('%').split(';')[0]))\n                    elif in_delJ:\n                        self.max_delJ_palindrome = np.abs(int(line.lstrip('%').split(';')[0]))\n            else:\n                in_delV = False\n                in_delDl = False\n                in_delDr = False\n                in_delJ = False", "response": "Reads the VDJ and D and J palindrome parameters from a file."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef load_igor_genomic_data(self, params_file_name, V_anchor_pos_file, J_anchor_pos_file):\n        \n        self.genV = read_igor_V_gene_parameters(params_file_name)\n        self.genJ = read_igor_J_gene_parameters(params_file_name)\n        \n        self.anchor_and_curate_genV_and_genJ(V_anchor_pos_file, J_anchor_pos_file)\n        \n        self.read_igor_VJ_palindrome_parameters(params_file_name)\n        \n        self.generate_cutV_genomic_CDR3_segs()\n        self.generate_cutJ_genomic_CDR3_segs()", "response": "Load in genomic data from IGOR parameter file."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef read_igor_VJ_palindrome_parameters(self, params_file_name):\n        params_file = open(params_file_name, 'r')\n        \n        \n        in_delV = False\n        in_delJ = False\n        \n        \n        for line in params_file:\n            if line.startswith('#Deletion;V_gene;'):\n                in_delV = True\n                in_delJ = False\n            elif line.startswith('#Deletion;J_gene;'):\n                in_delV = False\n                in_delJ = True\n            elif any([in_delV, in_delJ]) and line.startswith('%'):\n                if int(line.split(';')[-1]) == 0:\n                    if in_delV:\n                        self.max_delV_palindrome = np.abs(int(line.lstrip('%').split(';')[0]))\n                    elif in_delJ:\n                        self.max_delJ_palindrome = np.abs(int(line.lstrip('%').split(';')[0]))\n            else:\n                in_delV = False\n                in_delJ = False", "response": "Reads the V and J palindrome parameters from a file."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef load_and_process_igor_model(self, marginals_file_name):\n        \n        \n        raw_model = read_igor_marginals_txt(marginals_file_name)\n        \n        self.PV = raw_model[0]['v_choice']\n        self.PinsVD = raw_model[0]['vd_ins']\n        self.PinsDJ = raw_model[0]['dj_ins']\n        self.PdelV_given_V = raw_model[0]['v_3_del'].T\n        self.PdelJ_given_J = raw_model[0]['j_5_del'].T\n        \n        #While this class assumes P(V, D, J) factorizes into P(V)*P(D, J), the B cell model\n        #infers allowing for the full correlation. Most of the correlation information is due to\n        #chromosomal correlation of alleles (i.e. what chromosome each allele is found on).\n        #While this information can be interesting for inference purposes, it is discarded here\n        #as generally these models may be use for CDR3s from individuals the models weren't inferred\n        #from (and thus the chromosomal correlations are incorrect). This also equates the T and B cell\n        #models. To reintroduce the chromosomal correlations use V and J usage masks after inferring the \n        #allele identities on each chromosome.\n        \n        if raw_model[1]['d_gene'] == ['j_choice', 'd_gene']:\n        #Factorized P(V, D, J) = P(V)*P(D, J) --- correct for T cell models\n            self.PDJ = np.multiply(raw_model[0]['d_gene'].T, raw_model[0]['j_choice'])\n        elif raw_model[1]['d_gene'] == ['v_choice', 'j_choice', 'd_gene']:\n        #Full P(V, D, J) for B cells --- need to compute the marginal P(D, J)\n            PVJ = np.multiply(raw_model[0]['j_choice'].T, raw_model[0]['v_choice']).T\n            PVDJ = np.zeros([raw_model[0]['d_gene'].shape[0], raw_model[0]['d_gene'].shape[2], raw_model[0]['d_gene'].shape[1]])\n            for v_in in range(raw_model[0]['d_gene'].shape[0]):\n                for j_in in range(raw_model[0]['d_gene'].shape[1]):\n                    PVDJ[v_in, :, j_in] = PVJ[v_in, j_in]*raw_model[0]['d_gene'][v_in, j_in, :]\n            self.PDJ = np.sum(PVDJ, 0)\n        else:\n            print 'Unrecognized model structure -- need to construct P(D, J)'\n            return 0\n        \n        self.PdelDldelDr_given_D = np.transpose(np.multiply(np.transpose(raw_model[0]['d_3_del'], (2, 0, 1)), raw_model[0]['d_5_del']), (2, 0 , 1))\n        Rvd_raw = raw_model[0]['vd_dinucl'].reshape((4, 4)).T\n        self.Rvd = np.multiply(Rvd_raw, 1/np.sum(Rvd_raw, axis = 0))\n        Rdj_raw = raw_model[0]['dj_dinucl'].reshape((4, 4)).T\n        self.Rdj = np.multiply(Rdj_raw, 1/np.sum(Rdj_raw, axis = 0))", "response": "Load and process a generative model from the IGoR Marginal File."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nloads attributes by reading a generative model from IGoR marginal file.", "response": "def load_and_process_igor_model(self, marginals_file_name):\n        \"\"\"Set attributes by reading a generative model from IGoR marginal file.\n        \n        Sets attributes PVJ, PdelV_given_V, PdelJ_given_J, PinsVJ, and Rvj.\n        \n        Parameters\n        ----------\n        marginals_file_name : str\n            File name for a IGoR model marginals file.\n        \n        \"\"\"\n        \n        raw_model = read_igor_marginals_txt(marginals_file_name)\n        \n        self.PinsVJ = raw_model[0]['vj_ins']\n        self.PdelV_given_V = raw_model[0]['v_3_del'].T\n        self.PdelJ_given_J = raw_model[0]['j_5_del'].T\n        self.PVJ = np.multiply( raw_model[0]['j_choice'].T, raw_model[0]['v_choice']).T\n        Rvj_raw = raw_model[0]['vj_dinucl'].reshape((4, 4)).T\n        self.Rvj = np.multiply(Rvj_raw, 1/np.sum(Rvj_raw, axis = 0))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nparsing the contents of the object with the corresponding data.", "response": "def parse(readDataInstance):\n        \"\"\"\n        Returns a new L{ImageBoundForwarderRefEntry} object.\n        \n        @type readDataInstance: L{ReadData}\n        @param readDataInstance: A L{ReadData} object with the corresponding data to generate a new L{ImageBoundForwarderRefEntry} object.\n        \n        @rtype: L{ImageBoundForwarderRefEntry}\n        @return: A new L{ImageBoundForwarderRefEntry} object.\n        \"\"\"\n        boundForwarderEntry = ImageBoundForwarderRefEntry()\n        boundForwarderEntry.timeDateStamp.value = readDataInstance.readDword()\n        boundForwarderEntry.offsetModuleName.value = readDataInstance.readWord()\n        boundForwarderEntry.reserved.value = readDataInstance.readWord()\n        return boundForwarderEntry"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nparse the contents of a L { ImageBoundForwarderRefEntry } object.", "response": "def parse(readDataInstance,  numberOfEntries):\n        \"\"\"\n        Returns a L{ImageBoundForwarderRef} array where every element is a L{ImageBoundForwarderRefEntry} object.\n        \n        @type readDataInstance: L{ReadData}\n        @param readDataInstance: A L{ReadData} object with the corresponding data to generate a new L{ImageBoundForwarderRef} object.\n        \n        @type numberOfEntries: int\n        @param numberOfEntries: The number of C{IMAGE_BOUND_FORWARDER_REF} entries in the array.\n        \n        @rtype: L{ImageBoundForwarderRef}\n        @return: A new L{ImageBoundForwarderRef} object.\n        \n        @raise DataLengthException: If the L{ReadData} instance has less data than C{NumberOfEntries} * sizeof L{ImageBoundForwarderRefEntry}.\n        \"\"\"\n        imageBoundForwarderRefsList = ImageBoundForwarderRef()\n        dLength = len(readDataInstance)\n        entryLength = ImageBoundForwarderRefEntry().sizeof()\n        toRead = numberOfEntries * entryLength\n        \n        if dLength >= toRead:\n            for i in range(numberOfEntries):\n                entryData = readDataInstance.read(entryLength)\n                rd = utils.ReadData(entryData)\n                imageBoundForwarderRefsList.append(ImageBoundForwarderRefEntry.parse(rd))\n        else:\n            raise excep.DataLengthException(\"Not enough bytes to read.\")\n        \n        return imageBoundForwarderRefsList"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef parse(readDataInstance):\n        ibd = ImageBoundImportDescriptor()\n        \n        entryData = readDataInstance.read(consts.SIZEOF_IMAGE_BOUND_IMPORT_ENTRY32)\n        readDataInstance.offset = 0\n        while not utils.allZero(entryData):\n            prevOffset = readDataInstance.offset\n            \n            boundEntry = ImageBoundImportDescriptorEntry.parse(readDataInstance)\n            \n            # if the parsed entry has numberOfModuleForwarderRefs we must adjust the value in the readDataInstance.offset field\n            # in order to point after the last ImageBoundForwarderRefEntry.\n            if boundEntry.numberOfModuleForwarderRefs.value:\n                readDataInstance.offset = prevOffset + (consts.SIZEOF_IMAGE_BOUND_FORWARDER_REF_ENTRY32 * boundEntry.numberOfModuleForwarderRefs.value)\n            else:\n                readDataInstance.offset = prevOffset\n            \n            ibd.append(boundEntry)\n            entryData = readDataInstance.read(consts.SIZEOF_IMAGE_BOUND_IMPORT_ENTRY32)\n            \n        return ibd", "response": "Parses the contents of the image bound forwarder file."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef parse(readDataInstance):\n        boundEntry = ImageBoundImportDescriptorEntry()\n        boundEntry.timeDateStamp.value = readDataInstance.readDword()\n        boundEntry.offsetModuleName.value = readDataInstance.readWord()\n        boundEntry.numberOfModuleForwarderRefs.value = readDataInstance.readWord()\n        \n        numberOfForwarderRefsEntries = boundEntry.numberOfModuleForwarderRefs .value\n        if numberOfForwarderRefsEntries:\n            bytesToRead = numberOfForwarderRefsEntries * ImageBoundForwarderRefEntry().sizeof()\n            rd = utils.ReadData(readDataInstance.read(bytesToRead))\n            boundEntry.forwarderRefsList = ImageBoundForwarderRef.parse(rd,  numberOfForwarderRefsEntries)\n            \n        return boundEntry", "response": "Parses the contents of an image - bound import descriptor entry."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nparsing the contents of a NIC - level directory into a new object.", "response": "def parse(readDataInstance):\n        \"\"\"\n        Returns a new L{TLSDirectory} object.\n        \n        @type readDataInstance: L{ReadData}\n        @param readDataInstance: A L{ReadData} object containing data to create a new L{TLSDirectory} object.\n        \n        @rtype: L{TLSDirectory}\n        @return: A new {TLSDirectory} object.\n        \"\"\"\n        tlsDir = TLSDirectory()\n        \n        tlsDir.startAddressOfRawData.value = readDataInstance.readDword()\n        tlsDir.endAddressOfRawData.value = readDataInstance.readDword()\n        tlsDir.addressOfIndex.value = readDataInstance.readDword()\n        tlsDir.addressOfCallbacks.value = readDataInstance.readDword()\n        tlsDir.sizeOfZeroFill.value = readDataInstance.readDword()\n        tlsDir.characteristics.value = readDataInstance.readDword()\n        return tlsDir"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nparses the contents of a L{TLSDirectory64} object.", "response": "def parse(readDataInstance):\n        \"\"\"\n        Returns a new L{TLSDirectory64} object.\n        \n        @type readDataInstance: L{ReadData}\n        @param readDataInstance: A L{ReadData} object containing data to create a new L{TLSDirectory64} object.\n        \n        @rtype: L{TLSDirectory64}\n        @return: A new L{TLSDirectory64} object.\n        \"\"\"\n        tlsDir = TLSDirectory64()\n        \n        tlsDir.startAddressOfRawData.value = readDataInstance.readQword()\n        tlsDir.endAddressOfRawData.value = readDataInstance.readQword()\n        tlsDir.addressOfIndex.value = readDataInstance.readQword()\n        tlsDir.addressOfCallbacks.value = readDataInstance.readQword()\n        tlsDir.sizeOfZeroFill.value = readDataInstance.readDword()\n        tlsDir.characteristics.value = readDataInstance.readDword()\n        return tlsDir"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nparse the contents of a ReadData object containing the contents of a new ImageLoadConfigDirectory64 object.", "response": "def parse(readDataInstance):\n        \"\"\"\n        Returns a new L{ImageLoadConfigDirectory64} object.\n        \n        @type readDataInstance: L{ReadData}\n        @param readDataInstance: A L{ReadData} object containing data to create a new L{ImageLoadConfigDirectory64} object.\n        \n        @rtype: L{ImageLoadConfigDirectory64}\n        @return: A new L{ImageLoadConfigDirectory64} object.\n        \"\"\"\n        configDir = ImageLoadConfigDirectory64()\n\n        configDir.size.value = readDataInstance.readDword()\n        configDir.timeDateStamp.value = readDataInstance.readDword()\n        configDir.majorVersion.value = readDataInstance.readWord()\n        configDir.minorVersion.value = readDataInstance.readWord()\n        configDir.globalFlagsClear.value = readDataInstance.readDword()\n        configDir.globalFlagsSet.value = readDataInstance.readDword()\n        configDir.criticalSectionDefaultTimeout.value = readDataInstance.readDword()\n        configDir.deCommitFreeBlockThreshold.value = readDataInstance.readQword()\n        configDir.deCommitTotalFreeThreshold.value = readDataInstance.readQword()\n        configDir.lockPrefixTable.value = readDataInstance.readQword()\n        configDir.maximumAllocationSize.value = readDataInstance.readQword()\n        configDir.virtualMemoryThreshold.value = readDataInstance.readQword()\n        configDir.processAffinityMask.value = readDataInstance.readQword()\n        configDir.processHeapFlags.value = readDataInstance.readDword()\n        configDir.cdsVersion.value = readDataInstance.readWord()\n        configDir.reserved1.value = readDataInstance.readWord()\n        configDir.editList.value = readDataInstance.readQword()\n        configDir.securityCookie.value = readDataInstance.readQword()\n        configDir.SEHandlerTable.value = readDataInstance.readQword()\n        configDir.SEHandlerCount.value = readDataInstance.readQword()\n\n        # Fields for Control Flow Guard\n        configDir.GuardCFCheckFunctionPointer.value = readDataInstance.readQword() # VA\n        configDir.Reserved2.value = readDataInstance.readQword()\n        configDir.GuardCFFunctionTable.value = readDataInstance.readQword() # VA\n        configDir.GuardCFFunctionCount.value = readDataInstance.readQword()\n        configDir.GuardFlags.value = readDataInstance.readQword()\n        return configDir"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef parse(readDataInstance):\n        reloc = ImageBaseRelocationEntry()\n        reloc.virtualAddress.value = readDataInstance.readDword()\n        reloc.sizeOfBlock.value = readDataInstance.readDword()\n        toRead = (reloc.sizeOfBlock.value - 8) / len(datatypes.WORD(0))\n        reloc.items = datatypes.Array.parse(readDataInstance,  datatypes.TYPE_WORD,  toRead)\n        return reloc", "response": "Parses the contents of the object as a list of bytes."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nparse the contents of the given object and returns a new object with the contents.", "response": "def parse(readDataInstance):\n        \"\"\"\n        Returns a new L{ImageDebugDirectory} object.\n        \n        @type readDataInstance: L{ReadData}\n        @param readDataInstance: A new L{ReadData} object with data to be parsed as a L{ImageDebugDirectory} object.\n        \n        @rtype: L{ImageDebugDirectory}\n        @return: A new L{ImageDebugDirectory} object.\n        \"\"\"\n        dbgDir = ImageDebugDirectory()\n\n        dbgDir.characteristics.value = readDataInstance.readDword()\n        dbgDir.timeDateStamp.value = readDataInstance.readDword()\n        dbgDir.majorVersion.value = readDataInstance.readWord()\n        dbgDir.minorVersion.value = readDataInstance.readWord()\n        dbgDir.type.value = readDataInstance.readDword()\n        dbgDir.sizeOfData.value = readDataInstance.readDword()\n        dbgDir.addressOfData.value = readDataInstance.readDword()\n        dbgDir.pointerToRawData.value = readDataInstance.readDword()\n        \n        return dbgDir"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef parse(readDataInstance,  nDebugEntries):\n        dbgEntries = ImageDebugDirectories()\n        \n        dataLength = len(readDataInstance)\n        toRead = nDebugEntries * consts.SIZEOF_IMAGE_DEBUG_ENTRY32\n        if dataLength >= toRead:\n            for i in range(nDebugEntries):\n                dbgEntry = ImageDebugDirectory.parse(readDataInstance)\n                dbgEntries.append(dbgEntry)\n        else:\n            raise excep.DataLengthException(\"Not enough bytes to read.\")\n        \n        return dbgEntries", "response": "Parses the contents of a L { ImageDebugDirectory } object."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef parse(readDataInstance):\n        iid = ImageImportDescriptorEntry()\n        iid.originalFirstThunk.value = readDataInstance.readDword()\n        iid.timeDateStamp.value = readDataInstance.readDword()\n        iid.forwarderChain.value = readDataInstance.readDword()\n        iid.name.value = readDataInstance.readDword()\n        iid.firstThunk.value = readDataInstance.readDword()\n        return iid", "response": "Parses the contents of the given object and returns a new object."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nparses the contents of a C { readDataInstance} object and returns a new object with the contents.", "response": "def parse(readDataInstance,  nEntries):\n        \"\"\"\n        Returns a new L{ImageImportDescriptor} object.\n        \n        @type readDataInstance: L{ReadData}\n        @param readDataInstance: A L{ReadData} object with data to be parsed as a L{ImageImportDescriptor} object.\n        \n        @type nEntries: int\n        @param nEntries: The number of L{ImageImportDescriptorEntry} objects in the C{readDataInstance} object.\n        \n        @rtype: L{ImageImportDescriptor}\n        @return: A new L{ImageImportDescriptor} object.\n        \n        @raise DataLengthException: If not enough data to read.\n        \"\"\"\n        importEntries = ImageImportDescriptor()\n        \n        dataLength = len(readDataInstance)\n        toRead = nEntries * consts.SIZEOF_IMAGE_IMPORT_ENTRY32\n        if dataLength >= toRead:\n            for i in range(nEntries):\n                importEntry = ImageImportDescriptorEntry.parse(readDataInstance)\n                importEntries.append(importEntry)\n        else:\n            raise excep.DataLengthException(\"Not enough bytes to read.\")\n            \n        return importEntries"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nparses the contents of the n - tuple in a L{ExportTableEntry } object.", "response": "def parse(readDataInstance):\n        \"\"\"\n        Returns a new L{ExportTableEntry} object.\n        \n        @type readDataInstance: L{ReadData}\n        @param readDataInstance: A L{ReadData} object with data to be parsed as a L{ExportTableEntry} object.\n        \n        @rtype: L{ExportTableEntry}\n        @return: A new L{ExportTableEntry} object.\n        \"\"\"\n        exportEntry = ExportTableEntry()\n\n        exportEntry.functionRva.value = readDataInstance.readDword()\n        exportEntry.nameOrdinal.value = readDataInstance.readWord()\n        exportEntry.nameRva.value = readDataInstance.readDword()\n        exportEntry.name.value = readDataInstance.readString()\n        return exportEntry"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nparsing the contents of the given object and returns a new object.", "response": "def parse(readDataInstance):\n        \"\"\"\n        Returns a new L{ImageExportTable} object.\n        \n        @type readDataInstance: L{ReadData}\n        @param readDataInstance: A L{ReadData} object with data to be parsed as a L{ImageExportTable} object.\n        \n        @rtype: L{ImageExportTable}\n        @return: A new L{ImageExportTable} object.\n        \"\"\"\n        et = ImageExportTable()\n        \n        et.characteristics.value = readDataInstance.readDword()\n        et.timeDateStamp.value = readDataInstance.readDword()\n        et.majorVersion.value = readDataInstance.readWord()\n        et.minorVersion.value = readDataInstance.readWord()\n        et.name.value = readDataInstance.readDword()\n        et.base.value = readDataInstance.readDword()\n        et.numberOfFunctions.value = readDataInstance.readDword()\n        et.numberOfNames.value = readDataInstance.readDword()\n        et.addressOfFunctions.value = readDataInstance.readDword()\n        et.addressOfNames.value = readDataInstance.readDword()\n        et.addressOfNameOrdinals.value = readDataInstance.readDword()\n        return et"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef parse(readDataInstance):\n        nd = NETDirectory()\n        \n        nd.directory = NetDirectory.parse(readDataInstance)\n        nd.netMetaDataHeader = NetMetaDataHeader.parse(readDataInstance)\n        nd.netMetaDataStreams = NetMetaDataStreams.parse(readDataInstance)\n        return nd", "response": "Parses the specified data instance into a new object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef parse(readDataInstance):\n        nd = NetDirectory()\n        \n        nd.cb.value = readDataInstance.readDword()\n        nd.majorRuntimeVersion.value= readDataInstance.readWord()\n        nd.minorRuntimeVersion.value = readDataInstance.readWord()\n        \n        nd.metaData.rva.value = readDataInstance.readDword()\n        nd.metaData.size.value = readDataInstance.readDword()\n        nd.metaData.name.value = \"MetaData\"\n        \n        nd.flags.value = readDataInstance.readDword()\n        nd.entryPointToken.value = readDataInstance.readDword()\n        \n        nd.resources.rva.value = readDataInstance.readDword()\n        nd.resources.size.value = readDataInstance.readDword()\n        nd.resources.name.value = \"Resources\"\n        \n        nd.strongNameSignature.rva.value = readDataInstance.readDword()\n        nd.strongNameSignature.size.value = readDataInstance.readDword()\n        nd.strongNameSignature.name.value = \"StrongNameSignature\"\n        \n        nd.codeManagerTable.rva.value = readDataInstance.readDword()\n        nd.codeManagerTable.size.value = readDataInstance.readDword()\n        nd.codeManagerTable.name.value = \"CodeManagerTable\"\n        \n        nd.vTableFixups.rva.value = readDataInstance.readDword()\n        nd.vTableFixups.size.value = readDataInstance.readDword()\n        nd.vTableFixups.name.value = \"VTableFixups\"\n        \n        nd.exportAddressTableJumps.rva.value = readDataInstance.readDword()\n        nd.exportAddressTableJumps.size.value = readDataInstance.readDword()\n        nd.exportAddressTableJumps.name.value = \"ExportAddressTableJumps\"\n        \n        nd.managedNativeHeader.rva.value = readDataInstance.readDword()\n        nd.managedNativeHeader.size.value = readDataInstance.readDword()\n        nd.managedNativeHeader.name.value = \"ManagedNativeHeader\"\n        \n        return nd", "response": "Parses the contents of a single entry point into a new object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nparse the contents of the n - tuple containing the key - value pairs of the key - value pairs and returns a new object.", "response": "def parse(readDataInstance):\n        \"\"\"\n        Returns a new L{NetMetaDataHeader} object.\n        \n        @type readDataInstance: L{ReadData}\n        @param readDataInstance: A L{ReadData} object with data to be parsed as a L{NetMetaDataHeader} object.\n        \n        @rtype: L{NetMetaDataHeader}\n        @return: A new L{NetMetaDataHeader} object.\n        \"\"\"\n        nmh = NetMetaDataHeader()\n        \n        nmh.signature.value = readDataInstance.readDword()\n        nmh.majorVersion.value = readDataInstance.readWord()\n        nmh.minorVersion.value = readDataInstance.readWord()\n        nmh.reserved.value = readDataInstance.readDword()\n        nmh.versionLength.value = readDataInstance.readDword()\n        nmh.versionString.value = readDataInstance.readAlignedString()\n        nmh.flags.value = readDataInstance.readWord()\n        nmh.numberOfStreams.value = readDataInstance.readWord()\n        return nmh"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef parse(readDataInstance):\n        n = NetMetaDataStreamEntry()\n        n.offset.value = readDataInstance.readDword()\n        n.size.value = readDataInstance.readDword()\n        n.name.value = readDataInstance.readAlignedString()\n        return n", "response": "Parses the n - tuple of the data contained in readDataInstance and returns a new object with the contents of the n - tuple."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nparses the n - bit n - bit n - bit n - bit n - bit n - bit n - bit n - bit n - bit n - bit n - bit n - bit n - bit n - bit n - bit n - bit n - bit n - bit n - bit n - bit n - bit n - bit n - bit n - bit n - bit n - bit n - bit n - bit n - bit n - bit n - bit n - bit n", "response": "def parse(readDataInstance,  nStreams):\n        \"\"\"\n        Returns a new L{NetMetaDataStreams} object.\n        \n        @type readDataInstance: L{ReadData}\n        @param readDataInstance: A L{ReadData} object with data to be parsed as a L{NetMetaDataStreams} object.\n        \n        @type nStreams: int\n        @param nStreams: The number of L{NetMetaDataStreamEntry} objects in the C{readDataInstance} object.\n        \n        @rtype: L{NetMetaDataStreams}\n        @return: A new L{NetMetaDataStreams} object.\n        \"\"\"\n        streams = NetMetaDataStreams()\n        \n        for i in range(nStreams):\n            streamEntry = NetMetaDataStreamEntry()\n            \n            streamEntry.offset.value = readDataInstance.readDword()\n            streamEntry.size.value = readDataInstance.readDword()\n            streamEntry.name.value = readDataInstance.readAlignedString()\n            \n            #streams.append(streamEntry)\n            streams.update({ i: streamEntry, streamEntry.name.value: streamEntry })\n\n        return streams"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nparsing the object containing the n - tuple of keys and returns a new object.", "response": "def parse(readDataInstance):\n        \"\"\"\n        Returns a new L{NetMetaDataTableHeader} object.\n        \n        @type readDataInstance: L{ReadData}\n        @param readDataInstance: A L{ReadData} object with data to be parsed as a L{NetMetaDataTableHeader} object.\n        \n        @rtype: L{NetMetaDataTableHeader}\n        @return: A new L{NetMetaDataTableHeader} object.\n        \"\"\"\n        th = NetMetaDataTableHeader()\n        \n        th.reserved_1.value = readDataInstance.readDword()\n        th.majorVersion.value = readDataInstance.readByte()\n        th.minorVersion.value = readDataInstance.readByte()\n        th.heapOffsetSizes.value = readDataInstance.readByte()\n        th.reserved_2.value = readDataInstance.readByte()\n        th.maskValid.value = readDataInstance.readQword()\n        th.maskSorted.value = readDataInstance.readQword()\n\n        return th"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nparsing the data from readDataInstance and returns a new object with the parsed data.", "response": "def parse(readDataInstance, netMetaDataStreams):\n        \"\"\"\n        Returns a new L{NetMetaDataTables} object.\n        \n        @type readDataInstance: L{ReadData}\n        @param readDataInstance: A L{ReadData} object with data to be parsed as a L{NetMetaDataTables} object.\n        \n        @rtype: L{NetMetaDataTables}\n        @return: A new L{NetMetaDataTables} object.\n        \"\"\"\n        dt = NetMetaDataTables()\n        dt.netMetaDataTableHeader = NetMetaDataTableHeader.parse(readDataInstance)\n        dt.tables = {}\n\n        metadataTableDefinitions = dotnet.MetadataTableDefinitions(dt, netMetaDataStreams)\n\n        for i in xrange(64):\n            dt.tables[i] = { \"rows\": 0 }\n            if dt.netMetaDataTableHeader.maskValid.value >> i & 1:\n                dt.tables[i][\"rows\"] = readDataInstance.readDword()\n            if i in dotnet.MetadataTableNames:\n                dt.tables[dotnet.MetadataTableNames[i]] = dt.tables[i]\n\n        for i in xrange(64):\n            dt.tables[i][\"data\"] = []\n            for j in range(dt.tables[i][\"rows\"]):\n                row = None\n                if i in metadataTableDefinitions:\n                    row = readDataInstance.readFields(metadataTableDefinitions[i])\n                dt.tables[i][\"data\"].append(row)\n\n        for i in xrange(64):\n            if i in dotnet.MetadataTableNames:\n                dt.tables[dotnet.MetadataTableNames[i]] = dt.tables[i][\"data\"]\n            dt.tables[i] = dt.tables[i][\"data\"]\n\n        return dt"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nparse the contents of a NetResources object.", "response": "def parse(readDataInstance):\n        \"\"\"\n        Returns a new L{NetResources} object.\n\n        @type readDataInstance: L{ReadData}\n        @param readDataInstance: A L{ReadData} object with data to be parsed as a L{NetResources} object.\n\n        @rtype: L{NetResources}\n        @return: A new L{NetResources} object.\n        \"\"\"\n        r = NetResources()\n\n        r.signature = readDataInstance.readDword()\n        if r.signature != 0xbeefcace:\n            return r\n\n        r.readerCount = readDataInstance.readDword()\n        r.readerTypeLength = readDataInstance.readDword()\n        r.readerType = utils.ReadData(readDataInstance.read(r.readerTypeLength)).readDotNetBlob()\n        r.version = readDataInstance.readDword()\n        r.resourceCount = readDataInstance.readDword()\n        r.resourceTypeCount = readDataInstance.readDword()\n\n        r.resourceTypes = []\n        for i in xrange(r.resourceTypeCount):\n            r.resourceTypes.append(readDataInstance.readDotNetBlob())\n\n        # aligned to 8 bytes\n        readDataInstance.skipBytes(8 - readDataInstance.tell() & 0x7)\n\n        r.resourceHashes = []\n        for i in xrange(r.resourceCount):\n            r.resourceHashes.append(readDataInstance.readDword())\n\n        r.resourceNameOffsets = []\n        for i in xrange(r.resourceCount):\n            r.resourceNameOffsets.append(readDataInstance.readDword())\n\n        r.dataSectionOffset = readDataInstance.readDword()\n\n        r.resourceNames = []\n        r.resourceOffsets = []\n        base = readDataInstance.tell()\n        for i in xrange(r.resourceCount):\n            readDataInstance.setOffset(base + r.resourceNameOffsets[i])\n            r.resourceNames.append(readDataInstance.readDotNetUnicodeString())\n            r.resourceOffsets.append(readDataInstance.readDword())\n\n        r.info = {}\n        for i in xrange(r.resourceCount):\n            readDataInstance.setOffset(r.dataSectionOffset + r.resourceOffsets[i])\n            r.info[i] = readDataInstance.read(len(readDataInstance))\n            r.info[r.resourceNames[i]] = r.info[i]\n\n        return r"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef verify_and_fill_address_paths_from_bip32key(address_paths, master_key, network):\n    '''\n    Take address paths and verifies their accuracy client-side.\n\n    Also fills in all the available metadata (WIF, public key, etc)\n    '''\n\n    assert network, network\n\n    wallet_obj = Wallet.deserialize(master_key, network=network)\n\n    address_paths_cleaned = []\n\n    for address_path in address_paths:\n        path = address_path['path']\n        input_address = address_path['address']\n        child_wallet = wallet_obj.get_child_for_path(path)\n\n        if child_wallet.to_address() != input_address:\n            err_msg = 'Client Side Verification Fail for %s on %s:\\n%s != %s' % (\n                    path,\n                    master_key,\n                    child_wallet.to_address(),\n                    input_address,\n                    )\n            raise Exception(err_msg)\n\n        pubkeyhex = child_wallet.get_public_key_hex(compressed=True)\n\n        server_pubkeyhex = address_path.get('public')\n        if server_pubkeyhex and server_pubkeyhex != pubkeyhex:\n            err_msg = 'Client Side Verification Fail for %s on %s:\\n%s != %s' % (\n                    path,\n                    master_key,\n                    pubkeyhex,\n                    server_pubkeyhex,\n                    )\n            raise Exception(err_msg)\n\n        address_path_cleaned = {\n            'pub_address': input_address,\n            'path': path,\n            'pubkeyhex': pubkeyhex,\n            }\n\n        if child_wallet.private_key:\n            privkeyhex = child_wallet.get_private_key_hex()\n            address_path_cleaned['wif'] = child_wallet.export_to_wif()\n            address_path_cleaned['privkeyhex'] = privkeyhex\n        address_paths_cleaned.append(address_path_cleaned)\n\n    return address_paths_cleaned", "response": "Takes a list of address paths and verifies their accuracy client - side."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef solution_path(self):\n        '''Follows the solution path of the generalized lasso to find the best lambda value.'''\n        lambda_grid = np.exp(np.linspace(np.log(self.max_lambda), np.log(self.min_lambda), self.lambda_bins))\n        aic_trace = np.zeros((len(self.bins),lambda_grid.shape[0])) # The AIC score for each lambda value\n        aicc_trace = np.zeros((len(self.bins),lambda_grid.shape[0])) # The AICc score for each lambda value (correcting for finite sample size)\n        bic_trace = np.zeros((len(self.bins),lambda_grid.shape[0])) # The BIC score for each lambda value\n        dof_trace = np.zeros((len(self.bins),lambda_grid.shape[0])) # The degrees of freedom of each final solution\n        log_likelihood_trace = np.zeros((len(self.bins),lambda_grid.shape[0]))\n        bic_best_idx = [None for _ in self.bins]\n        aic_best_idx = [None for _ in self.bins]\n        aicc_best_idx = [None for _ in self.bins]\n        bic_best_betas = [None for _ in self.bins]\n        aic_best_betas = [None for _ in self.bins]\n        aicc_best_betas = [None for _ in self.bins]\n        if self.k == 0 and self.trails is not None:\n            betas = [np.zeros(self.num_nodes, dtype='double') for _ in self.bins]\n            zs = [np.zeros(self.breakpoints[-1], dtype='double') for _ in self.bins]\n            us = [np.zeros(self.breakpoints[-1], dtype='double') for _ in self.bins]\n        else:\n            betas = [np.zeros(self.num_nodes, dtype='double') for _ in self.bins]\n            us = [np.zeros(self.Dk.shape[0], dtype='double') for _ in self.bins]\n        for i, _lambda in enumerate(lambda_grid):\n            if self.verbose:\n                print('\\n#{0} Lambda = {1}'.format(i, _lambda))\n\n            # Run the graph fused lasso over each bin with the current lambda value\n            initial_values = (betas, zs, us) if self.k == 0 and self.trails is not None else (betas, us)\n            self.run(_lambda, initial_values=initial_values)\n\n            if self.verbose > 1:\n                print('\\tCalculating degrees of freedom and information criteria')\n\n            for b, beta in enumerate(betas):\n                if self.bins_allowed is not None and b not in self.bins_allowed:\n                    continue\n\n                # Count the number of free parameters in the grid (dof)\n                # TODO: this is not really the true DoF, since a change in a higher node multiplies\n                # the DoF in the lower nodes\n                # dof_trace[b,i] = len(self.calc_plateaus(beta))\n                dof_vals = self.Dk_minus_one.dot(beta) if self.k > 0 else beta\n                plateaus = calc_plateaus(dof_vals, self.edges, rel_tol=0.01) if (self.k % 2) == 0 else nearly_unique(dof_vals, rel_tol=0.03)\n                #plateaus = calc_plateaus(dof_vals, self.edges, rel_tol=1e-5) if (self.k % 2) == 0 else nearly_unique(dof_vals, rel_tol=1e-5)\n                dof_trace[b,i] = max(1,len(plateaus)) #* (k+1)\n\n                # Get the negative log-likelihood\n                log_likelihood_trace[b,i] = self.data_log_likelihood(self.bins[b][-1], self.bins[b][-2], beta)\n\n                # Calculate AIC = 2k - 2ln(L)\n                aic_trace[b,i] = 2. * dof_trace[b,i] - 2. * log_likelihood_trace[b,i]\n                \n                # Calculate AICc = AIC + 2k * (k+1) / (n - k - 1)\n                aicc_trace[b,i] = aic_trace[b,i] + 2 * dof_trace[b,i] * (dof_trace[b,i]+1) / (self.num_nodes - dof_trace[b,i] - 1.)\n\n                # Calculate BIC = -2ln(L) + k * (ln(n) - ln(2pi))\n                bic_trace[b,i] = -2 * log_likelihood_trace[b,i] + dof_trace[b,i] * (np.log(self.num_nodes) - np.log(2 * np.pi))\n\n                # Track the best model thus far\n                if aic_best_idx[b] is None or aic_trace[b,i] < aic_trace[b,aic_best_idx[b]]:\n                    aic_best_idx[b] = i\n                    aic_best_betas[b] = np.array(beta)\n\n                # Track the best model thus far\n                if aicc_best_idx[b] is None or aicc_trace[b,i] < aicc_trace[b,aicc_best_idx[b]]:\n                    aicc_best_idx[b] = i\n                    aicc_best_betas[b] = np.array(beta)\n\n                # Track the best model thus far\n                if bic_best_idx[b] is None or bic_trace[b,i] < bic_trace[b,bic_best_idx[b]]:\n                    bic_best_idx[b] = i\n                    bic_best_betas[b] = np.array(beta)\n\n                if self.verbose and self.bins_allowed is not None:\n                    print('\\tBin {0} Log-Likelihood: {1} DoF: {2} AIC: {3} AICc: {4} BIC: {5}'.format(b, log_likelihood_trace[b,i], dof_trace[b,i], aic_trace[b,i], aicc_trace[b,i], bic_trace[b,i]))\n\n            if self.verbose and self.bins_allowed is None:\n                print('Overall Log-Likelihood: {0} DoF: {1} AIC: {2} AICc: {3} BIC: {4}'.format(log_likelihood_trace[:,i].sum(), dof_trace[:,i].sum(), aic_trace[:,i].sum(), aicc_trace[:,i].sum(), bic_trace[:,i].sum()))\n\n        if self.verbose:\n            print('')\n            print('Best settings per bin:')\n            for b, (aic_idx, aicc_idx, bic_idx) in enumerate(zip(aic_best_idx, aicc_best_idx, bic_best_idx)):\n                if self.bins_allowed is not None and b not in self.bins_allowed:\n                    continue\n                left, mid, right, trials, successes = self.bins[b]\n                print('\\tBin #{0} ([{1}, {2}], split={3}) lambda: AIC={4:.2f} AICC={5:.2f} BIC={6:.2f} DoF: AIC={7:.0f} AICC={8:.0f} BIC={9:.0f}'.format(\n                        b, left, right, mid,\n                        lambda_grid[aic_idx], lambda_grid[aicc_idx], lambda_grid[bic_idx],\n                        dof_trace[b,aic_idx], dof_trace[b,aicc_idx], dof_trace[b,bic_idx]))\n            print('')\n\n        if self.bins_allowed is None:\n            if self.verbose:\n                print('Creating densities from betas...')\n            bic_density = self.density_from_betas(bic_best_betas)\n            aic_density = self.density_from_betas(aic_best_betas)\n            aicc_density = self.density_from_betas(aicc_best_betas)\n            self.map_density = bic_density\n        else:\n            aic_density, aicc_density, bic_density = None, None, None\n        \n        self.map_betas = bic_best_betas\n\n        return {'aic': aic_trace,\n                'aicc': aicc_trace,\n                'bic': bic_trace,\n                'dof': dof_trace,\n                'loglikelihood': log_likelihood_trace,\n                'lambdas': lambda_grid,\n                'aic_betas': aic_best_betas,\n                'aicc_betas': aicc_best_betas,\n                'bic_betas': bic_best_betas,\n                'aic_best_idx': aic_best_idx,\n                'aicc_best_idx': aicc_best_idx,\n                'bic_best_idx': bic_best_idx,\n                'aic_densities': aic_density.reshape(self.data_shape),\n                'aicc_densities': aicc_density.reshape(self.data_shape),\n                'bic_densities': bic_density.reshape(self.data_shape)}", "response": "Follows the solution path of the generalized lasso to find the best lambda value."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef run(self, lam, initial_values=None):\n        '''Run the graph-fused logit lasso with a fixed lambda penalty.'''\n        if initial_values is not None:\n            if self.k == 0 and self.trails is not None:\n                betas, zs, us = initial_values\n            else:\n                betas, us = initial_values\n        else:\n            if self.k == 0 and self.trails is not None:\n                betas = [np.zeros(self.num_nodes, dtype='double') for _ in self.bins]\n                zs = [np.zeros(self.breakpoints[-1], dtype='double') for _ in self.bins]\n                us = [np.zeros(self.breakpoints[-1], dtype='double') for _ in self.bins]\n            else:\n                betas = [np.zeros(self.num_nodes, dtype='double') for _ in self.bins]\n                us = [np.zeros(self.Dk.shape[0], dtype='double') for _ in self.bins]\n\n        for j, (left, mid, right, trials, successes) in enumerate(self.bins):\n            if self.bins_allowed is not None and j not in self.bins_allowed:\n                continue\n\n            if self.verbose > 2:\n                print('\\tBin #{0} [{1},{2},{3}]'.format(j, left, mid, right))\n            # if self.verbose > 3:\n            #     print 'Trials:\\n{0}'.format(pretty_str(trials))\n            #     print ''\n            #     print 'Successes:\\n{0}'.format(pretty_str(successes))\n                \n            beta = betas[j]\n            u = us[j]\n\n            if self.k == 0 and self.trails is not None:\n                z = zs[j]\n                # Run the graph-fused lasso algorithm\n                self.graphfl(len(beta), trials, successes,\n                             self.ntrails, self.trails, self.breakpoints,\n                             lam, self.alpha, self.inflate,\n                             self.max_steps, self.converge,\n                             beta, z, u)\n            else:\n                # Run the graph trend filtering algorithm\n                self.graphtf(len(beta), trials, successes, lam,\n                                 self.Dk.shape[0], self.Dk.shape[1], self.Dk.nnz,\n                                 self.Dk.row.astype('int32'), self.Dk.col.astype('int32'), self.Dk.data.astype('double'),\n                                 self.max_steps, self.converge,\n                                 beta, u)\n                beta = np.clip(beta, 1e-12, 1-1e-12) # numerical stability\n                betas[j] = -np.log(1./beta - 1.) # convert back to natural parameter form\n\n        return (betas, zs, us) if self.k == 0 and self.trails is not None else (betas, us)", "response": "Run the graph - fused logit lasso with a fixed lambda penalty."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef data_log_likelihood(self, successes, trials, beta):\n        '''Calculates the log-likelihood of a Polya tree bin given the beta values.'''\n        return binom.logpmf(successes, trials, 1.0 / (1 + np.exp(-beta))).sum()", "response": "Calculates the log - likelihood of a Polya tree bin given the beta values."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nrunning the nose test", "response": "def run_nose(self, params):\n        \"\"\"\n        :type params: Params\n        \"\"\"\n        thread.set_index(params.thread_index)\n        log.debug(\"[%s] Starting nose iterations: %s\", params.worker_index, params)\n        assert isinstance(params.tests, list)\n        # argv.extend(['--with-apiritif', '--nocapture', '--exe', '--nologcapture'])\n\n        end_time = self.params.ramp_up + self.params.hold_for\n        end_time += time.time() if end_time else 0\n        time.sleep(params.delay)\n\n        plugin = ApiritifPlugin(self._writer)\n        self._writer.concurrency += 1\n\n        config = Config(env=os.environ, files=all_config_files(), plugins=DefaultPluginManager())\n        config.plugins.addPlugins(extraplugins=[plugin])\n        config.testNames = params.tests\n        config.verbosity = 3 if params.verbose else 0\n        if params.verbose:\n            config.stream = open(os.devnull, \"w\")  # FIXME: use \"with\", allow writing to file/log\n\n        iteration = 0\n        try:\n            while True:\n                log.debug(\"Starting iteration:: index=%d,start_time=%.3f\", iteration, time.time())\n                thread.set_iteration(iteration)\n                ApiritifTestProgram(config=config)\n                log.debug(\"Finishing iteration:: index=%d,end_time=%.3f\", iteration, time.time())\n\n                iteration += 1\n\n                # reasons to stop\n                if plugin.stop_reason:\n                    log.debug(\"[%s] finished prematurely: %s\", params.worker_index, plugin.stop_reason)\n                elif iteration >= params.iterations:\n                    log.debug(\"[%s] iteration limit reached: %s\", params.worker_index, params.iterations)\n                elif 0 < end_time <= time.time():\n                    log.debug(\"[%s] duration limit reached: %s\", params.worker_index, params.hold_for)\n                else:\n                    continue  # continue if no one is faced\n\n                break\n        finally:\n            self._writer.concurrency -= 1\n\n            if params.verbose:\n                config.stream.close()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _write_single_sample(self, sample):\n        bytes = sample.extras.get(\"responseHeadersSize\", 0) + 2 + sample.extras.get(\"responseBodySize\", 0)\n\n        message = sample.error_msg\n        if not message:\n            message = sample.extras.get(\"responseMessage\")\n        if not message:\n            for sample in sample.subsamples:\n                if sample.error_msg:\n                    message = sample.error_msg\n                    break\n                elif sample.extras.get(\"responseMessage\"):\n                    message = sample.extras.get(\"responseMessage\")\n                    break\n        self.writer.writerow({\n            \"timeStamp\": int(1000 * sample.start_time),\n            \"elapsed\": int(1000 * sample.duration),\n            \"Latency\": 0,  # TODO\n            \"label\": sample.test_case,\n\n            \"bytes\": bytes,\n\n            \"responseCode\": sample.extras.get(\"responseCode\"),\n            \"responseMessage\": message,\n            \"allThreads\": self.concurrency,  # TODO: there will be a problem aggregating concurrency for rare samples\n            \"success\": \"true\" if sample.status == \"PASSED\" else \"false\",\n        })\n        self.out_stream.flush()", "response": "Writes a single sample to the output stream."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef addError(self, test, error):\n        # test_dict will be None if startTest wasn't called (i.e. exception in setUp/setUpClass)\n        # status=BROKEN\n        if self.current_sample is not None:\n            assertion_name = error[0].__name__\n            error_msg = str(error[1]).split('\\n')[0]\n            error_trace = self._get_trace(error)\n            self.current_sample.add_assertion(assertion_name)\n            self.current_sample.set_assertion_failed(assertion_name, error_msg, error_trace)", "response": "addError - Called by the test when a test raises an uncaught exception\n           "}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef parse(readDataInstance):\n        d = Directory()\n        d.rva.value = readDataInstance.readDword()\n        d.size.value = readDataInstance.readDword()\n        return d", "response": "Parses a NDEF - like object."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef parse(readDataInstance):\n        if len(readDataInstance) == consts.IMAGE_NUMBEROF_DIRECTORY_ENTRIES * 8:\n            newDataDirectory = DataDirectory()\n            for i in range(consts.IMAGE_NUMBEROF_DIRECTORY_ENTRIES):\n                newDataDirectory[i].name.value = dirs[i]\n                newDataDirectory[i].rva.value = readDataInstance.readDword()\n                newDataDirectory[i].size.value = readDataInstance.readDword()\n        else:\n            raise excep.DirectoryEntriesLengthException(\"The IMAGE_NUMBEROF_DIRECTORY_ENTRIES does not match with the length of the passed argument.\")\n        return newDataDirectory", "response": "Parses the IMAGE_NUMBEROF_DIRECTORY_ENTRIES and returns a DataDirectory object containing the names rva and size."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncomputes Pgens from a file and output to another file.", "response": "def main():\n    \"\"\"Compute Pgens from a file and output to another file.\"\"\"\n\n    parser = OptionParser(conflict_handler=\"resolve\")\n\n    parser.add_option('--humanTRA', '--human_T_alpha', action='store_true', dest='humanTRA', default=False, help='use default human TRA model (T cell alpha chain)')\n    parser.add_option('--humanTRB', '--human_T_beta', action='store_true', dest='humanTRB', default=False, help='use default human TRB model (T cell beta chain)')\n    parser.add_option('--mouseTRB', '--mouse_T_beta', action='store_true', dest='mouseTRB', default=False, help='use default mouse TRB model (T cell beta chain)')\n    parser.add_option('--humanIGH', '--human_B_heavy', action='store_true', dest='humanIGH', default=False, help='use default human IGH model (B cell heavy chain)')\n    parser.add_option('--set_custom_model_VDJ', dest='vdj_model_folder', metavar='PATH/TO/FOLDER/', help='specify PATH/TO/FOLDER/ for a custom VDJ generative model')\n    parser.add_option('--set_custom_model_VJ', dest='vj_model_folder', metavar='PATH/TO/FOLDER/', help='specify PATH/TO/FOLDER/ for a custom VJ generative model')\n\n    parser.add_option('-i', '--infile', dest = 'infile_name',metavar='PATH/TO/FILE', help='read in CDR3 sequences (and optionally V/J masks) from PATH/TO/FILE')\n    parser.add_option('-o', '--outfile', dest = 'outfile_name', metavar='PATH/TO/FILE', help='write CDR3 sequences and pgens to PATH/TO/FILE')\n    parser.add_option('--seq_in', '--seq_index', type='int', metavar='INDEX', dest='seq_in_index', default = 0, help='specifies sequences to be read in are in column INDEX. Default is index 0 (the first column).')\n\n    parser.add_option('--v_in', '--v_mask_index', type='int', metavar='INDEX', dest='V_mask_index', help='specifies V_masks are found in column INDEX in the input file. Default is no V mask.')\n    parser.add_option('--j_in', '--j_mask_index', type='int', metavar='INDEX', dest='J_mask_index', help='specifies J_masks are found in column INDEX in the input file. Default is no J mask.')\n\n    parser.add_option('--v_mask', type='string', dest='V_mask', help='specify V usage to condition Pgen on for seqs read in as arguments.')\n    parser.add_option('--j_mask', type='string', dest='J_mask', help='specify J usage to condition Pgen on for seqs read in as arguments.')\n\n    parser.add_option('-m', '--max_number_of_seqs', type='int',metavar='N', dest='max_number_of_seqs', help='compute Pgens for at most N sequences.')\n    parser.add_option('--lines_to_skip', type='int',metavar='N', dest='lines_to_skip', default = 0, help='skip the first N lines of the file. Default is 0.')\n    parser.add_option('-a', '--alphabet_filename', dest='alphabet_filename', metavar='PATH/TO/FILE', help=\"specify PATH/TO/FILE defining a custom 'amino acid' alphabet. Default is no custom alphabet.\")\n    parser.add_option('--seq_type_out', type='choice',metavar='SEQ_TYPE', dest='seq_type_out',  choices=['all', 'ntseq', 'nucleotide', 'aaseq', 'amino_acid'], help=\"if read in sequences are ntseqs, declare what type of sequence to compute pgen for. Default is all. Choices: 'all', 'ntseq', 'nucleotide', 'aaseq', 'amino_acid'\")\n    parser.add_option('--skip_off','--skip_empty_off', action='store_true', dest = 'skip_empty', default=True, help='stop skipping empty or blank sequences/lines (if for example you want to keep line index fidelity between the infile and outfile).')\n\n    parser.add_option('--display_off', action='store_false', dest='display_seqs', default=True, help='turn the sequence display off (only applies in write-to-file mode). Default is on.')\n    parser.add_option('--num_lines_for_display', type='int', metavar='N', default = 50, dest='num_lines_for_display', help='N lines of the output file are displayed when sequence display is on. Also used to determine the number of sequences to average over for speed and time estimates.')\n    parser.add_option('--time_updates_off', action='store_false', dest='time_updates', default=True, help='turn time updates off (only applies when sequence display is disabled).')\n    parser.add_option('--seqs_per_time_update', type='float', metavar='N', default = 100, dest='seqs_per_time_update', help='specify the number of sequences between time updates. Default is 1e5.')\n\n    parser.add_option('-d', '--delimiter', type='choice', dest='delimiter',  choices=['tab', 'space', ',', ';', ':'], help=\"declare infile delimiter. Default is tab for .tsv input files, comma for .csv files, and any whitespace for all others. Choices: 'tab', 'space', ',', ';', ':'\")\n    parser.add_option('--raw_delimiter', type='str', dest='delimiter', help=\"declare infile delimiter as a raw string.\")\n    parser.add_option('--delimiter_out', type='choice', dest='delimiter_out',  choices=['tab', 'space', ',', ';', ':'], help=\"declare outfile delimiter. Default is tab for .tsv output files, comma for .csv files, and the infile delimiter for all others. Choices: 'tab', 'space', ',', ';', ':'\")\n    parser.add_option('--raw_delimiter_out', type='str', dest='delimiter_out', help=\"declare for the delimiter outfile as a raw string.\")\n    parser.add_option('--gene_mask_delimiter', type='choice', dest='gene_mask_delimiter',  choices=['tab', 'space', ',', ';', ':'], help=\"declare gene mask delimiter. Default comma unless infile delimiter is comma, then default is a semicolon. Choices: 'tab', 'space', ',', ';', ':'\")\n    parser.add_option('--raw_gene_mask_delimiter', type='str', dest='gene_mask_delimiter', help=\"declare delimiter of gene masks as a raw string.\")\n    parser.add_option('--comment_delimiter', type='str', dest='comment_delimiter', help=\"character or string to indicate comment or header lines to skip.\")\n\n\n    (options, args) = parser.parse_args()\n\n    #Check that the model is specified properly\n    main_folder = os.path.dirname(__file__)\n\n    default_models = {}\n    default_models['humanTRA'] = [os.path.join(main_folder, 'default_models', 'human_T_alpha'),  'VJ']\n    default_models['humanTRB'] = [os.path.join(main_folder, 'default_models', 'human_T_beta'), 'VDJ']\n    default_models['mouseTRB'] = [os.path.join(main_folder, 'default_models', 'mouse_T_beta'), 'VDJ']\n    default_models['humanIGH'] = [os.path.join(main_folder, 'default_models', 'human_B_heavy'), 'VDJ']\n\n    num_models_specified = sum([1 for x in default_models.keys() + ['vj_model_folder', 'vdj_model_folder'] if getattr(options, x)])\n\n    if num_models_specified == 1: #exactly one model specified\n        try:\n            d_model = [x for x in default_models.keys() if getattr(options, x)][0]\n            model_folder = default_models[d_model][0]\n            recomb_type = default_models[d_model][1]\n        except IndexError:\n            if options.vdj_model_folder: #custom VDJ model specified\n                model_folder = options.vdj_model_folder\n                recomb_type = 'VDJ'\n            elif options.vj_model_folder: #custom VJ model specified\n                model_folder = options.vj_model_folder\n                recomb_type = 'VJ'\n    elif num_models_specified == 0:\n        print 'Need to indicate generative model.'\n        print 'Exiting...'\n        return -1\n    elif num_models_specified > 1:\n        print 'Only specify one model'\n        print 'Exiting...'\n        return -1\n\n    #Check that all model and genomic files exist in the indicated model folder\n    if not os.path.isdir(model_folder):\n        print 'Check pathing... cannot find the model folder: ' + model_folder\n        print 'Exiting...'\n        return -1\n\n    params_file_name = os.path.join(model_folder,'model_params.txt')\n    marginals_file_name = os.path.join(model_folder,'model_marginals.txt')\n    V_anchor_pos_file = os.path.join(model_folder,'V_gene_CDR3_anchors.csv')\n    J_anchor_pos_file = os.path.join(model_folder,'J_gene_CDR3_anchors.csv')\n\n    for x in [params_file_name, marginals_file_name, V_anchor_pos_file, J_anchor_pos_file]:\n        if not os.path.isfile(x):\n            print 'Cannot find: ' + x\n            print 'Please check the files (and naming conventions) in the model folder ' + model_folder\n            print 'Exiting...'\n            return -1\n\n    alphabet_filename = options.alphabet_filename #used if a custom alphabet is to be specified\n    if alphabet_filename is not None:\n        if not os.path.isfile(alphabet_filename):\n            print 'Cannot find custom alphabet file: ' + infile_name\n            print 'Exiting...'\n            return -1\n\n    #Load up model based on recomb_type\n    #VDJ recomb case --- used for TCRB and IGH\n    if recomb_type == 'VDJ':\n        genomic_data = load_model.GenomicDataVDJ()\n        genomic_data.load_igor_genomic_data(params_file_name, V_anchor_pos_file, J_anchor_pos_file)\n        generative_model = load_model.GenerativeModelVDJ()\n        generative_model.load_and_process_igor_model(marginals_file_name)\n        pgen_model = generation_probability.GenerationProbabilityVDJ(generative_model, genomic_data, alphabet_filename)\n    #VJ recomb case --- used for TCRA and light chain\n    elif recomb_type == 'VJ':\n        genomic_data = load_model.GenomicDataVJ()\n        genomic_data.load_igor_genomic_data(params_file_name, V_anchor_pos_file, J_anchor_pos_file)\n        generative_model = load_model.GenerativeModelVJ()\n        generative_model.load_and_process_igor_model(marginals_file_name)\n        pgen_model = generation_probability.GenerationProbabilityVJ(generative_model, genomic_data, alphabet_filename)\n\n    aa_alphabet = ''.join(pgen_model.codons_dict.keys())\n\n    if options.infile_name is not None:\n        infile_name = options.infile_name\n\n        if not os.path.isfile(infile_name):\n            print 'Cannot find input file: ' + infile_name\n            print 'Exiting...'\n            return -1\n\n    if options.outfile_name is not None:\n        outfile_name = options.outfile_name\n        if os.path.isfile(outfile_name):\n            if not raw_input(outfile_name + ' already exists. Overwrite (y/n)? ').strip().lower() in ['y', 'yes']:\n                print 'Exiting...'\n                return -1\n\n    #Parse delimiter\n    delimiter = options.delimiter\n    if delimiter is None: #Default case\n        if options.infile_name is None:\n            delimiter = '\\t'\n        elif infile_name.endswith('.tsv'): #parse TAB separated value file\n            delimiter = '\\t'\n        elif infile_name.endswith('.csv'): #parse COMMA separated value file\n            delimiter = ','\n    else:\n        try:\n            delimiter = {'tab': '\\t', 'space': ' ', ',': ',', ';': ';', ':': ':'}[delimiter]\n        except KeyError:\n            pass #Other string passed as the delimiter.\n\n    #Parse delimiter_out\n    delimiter_out = options.delimiter_out\n    if delimiter_out is None: #Default case\n        if delimiter is None:\n            delimiter_out = '\\t'\n        else:\n            delimiter_out = delimiter\n        if options.outfile_name is None:\n            pass\n        elif outfile_name.endswith('.tsv'): #output TAB separated value file\n            delimiter_out = '\\t'\n        elif outfile_name.endswith('.csv'): #output COMMA separated value file\n            delimiter_out = ','\n    else:\n        try:\n            delimiter_out = {'tab': '\\t', 'space': ' ', ',': ',', ';': ';', ':': ':'}[delimiter_out]\n        except KeyError:\n            pass #Other string passed as the delimiter.\n\n    #Parse gene_delimiter\n    gene_mask_delimiter = options.gene_mask_delimiter\n    if gene_mask_delimiter is None: #Default case\n        gene_mask_delimiter = ','\n        if delimiter == ',':\n            gene_mask_delimiter = ';'\n    else:\n        try:\n            gene_mask_delimiter = {'tab': '\\t', 'space': ' ', ',': ',', ';': ';', ':': ':'}[gene_mask_delimiter]\n        except KeyError:\n            pass #Other string passed as the delimiter.\n\n\n    #More options\n    time_updates = options.time_updates\n    display_seqs = options.display_seqs\n    num_lines_for_display = options.num_lines_for_display\n    seq_in_index = options.seq_in_index #where in the line the sequence is after line.split(delimiter)\n    lines_to_skip = options.lines_to_skip #one method of skipping header\n    comment_delimiter = options.comment_delimiter #another method of skipping header\n    seqs_per_time_update = options.seqs_per_time_update\n    max_number_of_seqs = options.max_number_of_seqs\n    V_mask_index = options.V_mask_index #Default is not conditioning on V identity\n    J_mask_index = options.J_mask_index #Default is not conditioning on J identity\n    skip_empty = options.skip_empty\n\n    seq_type_out = options.seq_type_out #type of pgens to be computed. Can be ntseq, aaseq, or both\n    if seq_type_out is not None:\n        seq_type_out = {'all': None, 'ntseq': 'ntseq', 'nucleotide': 'ntseq', 'aaseq': 'aaseq', 'amino_acid': 'aaseq'}[seq_type_out]\n\n    if options.infile_name is None: #No infile specified -- args should be the input seqs\n        print_warnings = True\n        seqs = args\n        seq_types = [determine_seq_type(seq, aa_alphabet) for seq in seqs]\n        unrecognized_seqs = [seq for i, seq in enumerate(seqs) if seq_types[i] is None]\n        if len(unrecognized_seqs) > 0 and print_warnings:\n            print 'The following sequences/arguments were not recognized: ' + ', '.join(unrecognized_seqs)\n        seqs = [seq for i, seq in enumerate(seqs) if seq_types[i] is not None]\n        seq_types = [seq_type for seq_type in seq_types if seq_type is not None]\n\n\n        #Format V and J masks -- uniform for all argument input sequences\n        try:\n            V_mask = options.V_mask.split(',')\n            unrecognized_v_genes = [v for v in V_mask if v not in pgen_model.V_mask_mapping.keys()]\n            V_mask = [v for v in V_mask if v in pgen_model.V_mask_mapping.keys()]\n            if len(unrecognized_v_genes) > 0:\n                print 'These V genes/alleles are not recognized: ' + ', '.join(unrecognized_v_genes)\n            if len(V_mask) == 0:\n                print 'No recognized V genes/alleles in the provided V_mask. Continuing without conditioning on V usage.'\n                V_mask = None\n        except AttributeError:\n            V_mask = options.V_mask #Default is None, i.e. not conditioning on V identity\n\n        try:\n            J_mask = options.J_mask.split(',')\n            unrecognized_j_genes = [j for j in J_mask if j not in pgen_model.J_mask_mapping.keys()]\n            J_mask = [j for j in J_mask if j in pgen_model.J_mask_mapping.keys()]\n            if len(unrecognized_j_genes) > 0:\n                print 'These J genes/alleles are not recognized: ' + ', '.join(unrecognized_j_genes)\n            if len(J_mask) == 0:\n                print 'No recognized J genes/alleles in the provided J_mask. Continuing without conditioning on J usage.'\n                J_mask = None\n        except AttributeError:\n            J_mask = options.J_mask #Default is None, i.e. not conditioning on J identity\n\n        print ''\n        start_time = time.time()\n        for seq, seq_type in zip(seqs, seq_types):\n            if seq_type == 'aaseq':\n                c_pgen = pgen_model.compute_aa_CDR3_pgen(seq, V_mask, J_mask, print_warnings)\n                print 'Pgen of the amino acid sequence ' + seq + ': ' + str(c_pgen)\n                print ''\n            elif seq_type == 'regex':\n                c_pgen = pgen_model.compute_regex_CDR3_template_pgen(seq, V_mask, J_mask, print_warnings)\n                print 'Pgen of the regular expression sequence ' + seq + ': ' + str(c_pgen)\n                print ''\n            elif seq_type == 'ntseq':\n                if seq_type_out is None or seq_type_out == 'ntseq':\n                    c_pgen_nt = pgen_model.compute_nt_CDR3_pgen(seq, V_mask, J_mask, print_warnings)\n                    print 'Pgen of the nucleotide sequence ' + seq + ': ' + str(c_pgen_nt)\n                if seq_type_out is None or seq_type_out == 'aaseq':\n                    c_pgen_aa = pgen_model.compute_aa_CDR3_pgen(nt2aa(seq), V_mask, J_mask, print_warnings)\n                    print 'Pgen of the amino acid sequence nt2aa(' + seq + ') = ' + nt2aa(seq) + ': ' + str(c_pgen_aa)\n                print ''\n\n        c_time = time.time() - start_time\n        if c_time > 86400: #more than a day\n            c_time_str = '%d days, %d hours, %d minutes, and %.2f seconds.'%(int(c_time)/86400, (int(c_time)/3600)%24, (int(c_time)/60)%60, c_time%60)\n        elif c_time > 3600: #more than an hr\n            c_time_str = '%d hours, %d minutes, and %.2f seconds.'%((int(c_time)/3600)%24, (int(c_time)/60)%60, c_time%60)\n        elif c_time > 60: #more than a min\n            c_time_str = '%d minutes and %.2f seconds.'%((int(c_time)/60)%60, c_time%60)\n        else:\n            c_time_str = '%.2f seconds.'%(c_time)\n\n        print 'Completed pgen computation in: ' + c_time_str\n\n    else: #Read sequences in from file\n        print_warnings = False #Most cases of reading in from file should have warnings disabled\n        seqs = []\n        seq_types = []\n        V_usage_masks = []\n        J_usage_masks = []\n\n        infile = open(infile_name, 'r')\n\n        for i, line in enumerate(infile):\n            if comment_delimiter is not None: #Default case -- no comments/header delimiter\n                if line.startswith(comment_delimiter): #allow comments\n                    continue\n            if i < lines_to_skip:\n                continue\n\n            if delimiter is None: #Default delimiter is any whitespace\n                split_line = line.split()\n            else:\n                split_line = line.split(delimiter)\n\n            #Find the seq\n            try:\n                seq = split_line[seq_in_index].strip()\n                if len(seq.strip()) == 0:\n                    if skip_empty:\n                        continue\n                    else:\n                        seqs.append(seq) #keep the blank seq as a placeholder\n                        seq_types.append('aaseq')\n                else:\n                    seqs.append(seq)\n                    seq_types.append(determine_seq_type(seq, aa_alphabet))\n            except IndexError: #no index match for seq\n                if skip_empty and len(line.strip()) == 0:\n                    continue\n                print 'seq_in_index is out of range'\n                print 'Exiting...'\n                infile.close()\n                return -1\n\n            #Find and format V_usage_mask\n            if V_mask_index is None:\n                V_usage_masks.append(None) #default mask\n            else:\n                try:\n                    V_usage_mask = split_line[V_mask_index].strip().split(gene_mask_delimiter)\n                    #check that all V gene/allele names are recognized\n                    if all([v in pgen_model.V_mask_mapping for v in V_usage_mask]):\n                        V_usage_masks.append(V_usage_mask)\n                    else:\n                        print str(V_usage_mask) + \" is not a usable V_usage_mask composed exclusively of recognized V gene/allele names\"\n                        print 'Unrecognized V gene/allele names: ' + ', '.join([v for v in V_usage_mask if not v in pgen_model.V_mask_mapping.keys()])\n                        print 'Exiting...'\n                        infile.close()\n                        return -1\n                except IndexError: #no index match for V_mask_index\n                    print 'V_mask_index is out of range'\n                    print 'Exiting...'\n                    infile.close()\n                    return -1\n\n            #Find and format J_usage_mask\n            if J_mask_index is None:\n                J_usage_masks.append(None) #default mask\n            else:\n                try:\n                    J_usage_mask = split_line[J_mask_index].strip().split(gene_mask_delimiter)\n                    #check that all V gene/allele names are recognized\n                    if all([j in pgen_model.J_mask_mapping for j in J_usage_mask]):\n                        J_usage_masks.append(J_usage_mask)\n                    else:\n                        print str(J_usage_mask) + \" is not a usable J_usage_mask composed exclusively of recognized J gene/allele names\"\n                        print 'Unrecognized J gene/allele names: ' + ', '.join([j for j in J_usage_mask if not j in pgen_model.J_mask_mapping.keys()])\n                        print 'Exiting...'\n                        infile.close()\n                        return -1\n                except IndexError: #no index match for J_mask_index\n                    print 'J_mask_index is out of range'\n                    print 'Exiting...'\n                    infile.close()\n                    return -1\n\n            if max_number_of_seqs is not None:\n                if len(seqs) >= max_number_of_seqs:\n                    break\n\n\n        unrecognized_seqs = [seq for i, seq in enumerate(seqs) if seq_types[i] is None]\n        if len(unrecognized_seqs) > 0 and len(unrecognized_seqs) < len(seqs):\n            if print_warnings or options.outfile_name is not None:\n                print 'Some strings read in were not parsed as sequences -- they will be omitted.'\n                print 'Examples of improperly read strings: '\n                for unrecognized_seq in unrecognized_seqs[:10]:\n                    print unrecognized_seq\n            seqs = [seq for i, seq in enumerate(seqs) if seq_types[i] is not None]\n            V_usage_masks = [V_usage_mask for i, V_usage_mask in enumerate(V_usage_masks) if seq_types[i] is not None]\n            seq_types = [seq_type for seq_type in seq_types if seq_type is not None]\n        elif len(unrecognized_seqs) > 0 and len(unrecognized_seqs) == len(seqs):\n            print 'None of the read in strings were parsed as sequences. Check input file.'\n            print 'Examples of improperly read strings:'\n            for unrecognized_seq in unrecognized_seqs[:10]:\n                print unrecognized_seq\n            print 'Exiting...'\n            return -1\n\n        infile.close()\n\n\n        if options.outfile_name is not None: #OUTFILE SPECIFIED, allow printed info/display\n\n            print 'Successfully read in and formatted ' + str(len(seqs)) + ' sequences and any V or J usages.'\n            if display_seqs:\n                sys.stdout.write('\\r'+'Continuing to Pgen computation in 3... ')\n                sys.stdout.flush()\n                time.sleep(0.4)\n                sys.stdout.write('\\r'+'Continuing to Pgen computation in 2... ')\n                sys.stdout.flush()\n                time.sleep(0.4)\n                sys.stdout.write('\\r'+'Continuing to Pgen computation in 1... ')\n                sys.stdout.flush()\n                time.sleep(0.4)\n            else:\n                print 'Continuing to Pgen computation.'\n                print_warnings = True #Display is off, can print warnings\n\n            if display_seqs:\n                lines_for_display = []\n                times_for_speed_calc = [time.time()]\n\n            outfile = open(outfile_name, 'w')\n            start_time = time.time()\n            for i, seq in enumerate(seqs):\n                if seq_types[i] == 'aaseq':\n                    #Compute Pgen and print out\n                    c_pgen_line = seq + delimiter_out + str(pgen_model.compute_aa_CDR3_pgen(seq, V_usage_masks[i], J_usage_masks[i], print_warnings))\n                if seq_types[i] == 'regex':\n                    #Compute Pgen and print out\n                    c_pgen_line = seq + delimiter_out + str(pgen_model.compute_regex_CDR3_template_pgen(seq, V_usage_masks[i], J_usage_masks[i], print_warnings))\n                elif seq_types[i] == 'ntseq':\n                    ntseq = seq\n                    if len(ntseq) % 3 == 0: #inframe sequence\n                        aaseq = nt2aa(ntseq)\n                        #Compute Pgen and print out based on recomb_type and seq_type_out\n                        if seq_type_out is None:\n                            c_pgen_line = ntseq + delimiter_out + str(pgen_model.compute_nt_CDR3_pgen(ntseq, V_usage_masks[i], J_usage_masks[i], print_warnings)) + delimiter_out + aaseq + delimiter_out +  str(pgen_model.compute_aa_CDR3_pgen(aaseq, V_usage_masks[i], J_usage_masks[i], print_warnings))\n                        elif seq_type_out == 'ntseq':\n                            c_pgen_line = ntseq + delimiter_out + str(pgen_model.compute_nt_CDR3_pgen(ntseq, V_usage_masks[i], J_usage_masks[i], print_warnings))\n                        elif seq_type_out == 'aaseq':\n                            c_pgen_line = aaseq + delimiter_out + str(pgen_model.compute_aa_CDR3_pgen(aaseq, V_usage_masks[i], J_usage_masks[i], print_warnings))\n                    else: #out of frame sequence -- Pgens are 0 and use 'out_of_frame' for aaseq\n                        if seq_type_out is None:\n                            c_pgen_line = ntseq + delimiter_out + '0' + delimiter_out + 'out_of_frame' + delimiter_out + '0'\n                        elif seq_type_out == 'ntseq':\n                            c_pgen_line = ntseq + delimiter_out + '0'\n                        elif seq_type_out == 'aaseq':\n                            c_pgen_line = 'out_of_frame' + delimiter_out + '0'\n\n                outfile.write(c_pgen_line + '\\n')\n\n                #Print time update\n                if display_seqs:\n                    cc_time = time.time()\n                    c_time = cc_time - start_time\n                    times_for_speed_calc = [cc_time] + times_for_speed_calc[:num_lines_for_display]\n                    c_avg_speed = (len(times_for_speed_calc)-1)/float(times_for_speed_calc[0] - times_for_speed_calc[-1])\n\n                    #eta = ((len(seqs) - (i+1))/float(i+1))*c_time\n\n                    eta = (len(seqs) - (i+1))/c_avg_speed\n\n                    lines_for_display = [c_pgen_line] + lines_for_display[:num_lines_for_display]\n\n\n                    c_time_str = '%s hours, %s minutes, and %s seconds.'%(repr(int(c_time)/3600).rjust(3), repr((int(c_time)/60)%60).rjust(2), repr(int(c_time)%60).rjust(2))\n                    eta_str = '%s hours, %s minutes, and %s seconds.'%(repr(int(eta)/3600).rjust(3), repr((int(eta)/60)%60).rjust(2), repr(int(eta)%60).rjust(2))\n                    time_str = 'Time to compute Pgen on %s seqs: %s \\nEst. time for remaining %s seqs: %s'%(repr(i+1).rjust(9), c_time_str, repr(len(seqs) - (i + 1)).rjust(9), eta_str)\n                    speed_str = 'Current Pgen computation speed: %s seqs/min'%(repr(round((len(times_for_speed_calc)-1)*60/float(times_for_speed_calc[0] - times_for_speed_calc[-1]), 2)).rjust(8))\n                    display_str = '\\n'.join(lines_for_display[::-1]) + '\\n' + '-'*80 + '\\n' + time_str + '\\n' + speed_str + '\\n' + '-'*80\n                    print '\\033[2J' + display_str\n                elif (i+1)%seqs_per_time_update == 0 and time_updates:\n                    c_time = time.time() - start_time\n                    eta = ((len(seqs) - (i+1))/float(i+1))*c_time\n                    if c_time > 86400: #more than a day\n                        c_time_str = '%d days, %d hours, %d minutes, and %.2f seconds.'%(int(c_time)/86400, (int(c_time)/3600)%24, (int(c_time)/60)%60, c_time%60)\n                    elif c_time > 3600: #more than an hr\n                        c_time_str = '%d hours, %d minutes, and %.2f seconds.'%((int(c_time)/3600)%24, (int(c_time)/60)%60, c_time%60)\n                    elif c_time > 60: #more than a min\n                        c_time_str = '%d minutes and %.2f seconds.'%((int(c_time)/60)%60, c_time%60)\n                    else:\n                        c_time_str = '%.2f seconds.'%(c_time)\n\n                    if eta > 86400: #more than a day\n                        eta_str = '%d days, %d hours, %d minutes, and %.2f seconds.'%(int(eta)/86400, (int(eta)/3600)%24, (int(eta)/60)%60, eta%60)\n                    elif eta > 3600: #more than an hr\n                        eta_str = '%d hours, %d minutes, and %.2f seconds.'%((int(eta)/3600)%24, (int(eta)/60)%60, eta%60)\n                    elif eta > 60: #more than a min\n                        eta_str = '%d minutes and %.2f seconds.'%((int(eta)/60)%60, eta%60)\n                    else:\n                        eta_str = '%.2f seconds.'%(eta)\n\n                    print 'Pgen computed for %d sequences in: %s Estimated time remaining: %s'%(i+1, c_time_str, eta_str)\n\n            c_time = time.time() - start_time\n            if c_time > 86400: #more than a day\n                c_time_str = '%d days, %d hours, %d minutes, and %.2f seconds.'%(int(c_time)/86400, (int(c_time)/3600)%24, (int(c_time)/60)%60, c_time%60)\n            elif c_time > 3600: #more than an hr\n                c_time_str = '%d hours, %d minutes, and %.2f seconds.'%((int(c_time)/3600)%24, (int(c_time)/60)%60, c_time%60)\n            elif c_time > 60: #more than a min\n                c_time_str = '%d minutes and %.2f seconds.'%((int(c_time)/60)%60, c_time%60)\n            else:\n                c_time_str = '%.2f seconds.'%(c_time)\n            print 'Completed Pgen computation for %d sequences: in %s'%(len(seqs), c_time_str)\n\n            outfile.close()\n\n        else: #NO OUTFILE -- print directly to stdout\n            start_time = time.time()\n            for i, seq in enumerate(seqs):\n                if seq_types[i] == 'aaseq':\n                    #Compute Pgen and print out\n                    c_pgen_line = seq + delimiter_out + str(pgen_model.compute_aa_CDR3_pgen(seq, V_usage_masks[i], J_usage_masks[i], print_warnings))\n                if seq_types[i] == 'regex':\n                    #Compute Pgen and print out\n                    c_pgen_line = seq + delimiter_out + str(pgen_model.compute_regex_CDR3_template_pgen(seq, V_usage_masks[i], J_usage_masks[i], print_warnings))\n                elif seq_types[i] == 'ntseq':\n                    ntseq = seq\n                    if len(ntseq) % 3 == 0: #inframe sequence\n                        aaseq = nt2aa(ntseq)\n                        #Compute Pgen and print out based on recomb_type and seq_type_out\n                        if seq_type_out is None:\n                            c_pgen_line = ntseq + delimiter_out + str(pgen_model.compute_nt_CDR3_pgen(ntseq, V_usage_masks[i], J_usage_masks[i], print_warnings)) + delimiter_out + aaseq + delimiter_out +  str(pgen_model.compute_aa_CDR3_pgen(aaseq, V_usage_masks[i], J_usage_masks[i], print_warnings))\n                        elif seq_type_out == 'ntseq':\n                            c_pgen_line = ntseq + delimiter_out + str(pgen_model.compute_nt_CDR3_pgen(ntseq, V_usage_masks[i], J_usage_masks[i], print_warnings))\n                        elif seq_type_out == 'aaseq':\n                            c_pgen_line = aaseq + delimiter_out + str(pgen_model.compute_aa_CDR3_pgen(aaseq, V_usage_masks[i], J_usage_masks[i], print_warnings))\n                    else: #out of frame sequence -- Pgens are 0 and use 'out_of_frame' for aaseq\n                        if seq_type_out is None:\n                            c_pgen_line = ntseq + delimiter_out + '0' + delimiter_out + 'out_of_frame' + delimiter_out + '0'\n                        elif seq_type_out == 'ntseq':\n                            c_pgen_line = ntseq + delimiter_out + '0'\n                        elif seq_type_out == 'aaseq':\n                            c_pgen_line = 'out_of_frame' + delimiter_out + '0'\n\n                print c_pgen_line"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef create_plateaus(data, edges, plateau_size, plateau_vals, plateaus=None):\n    '''Creates plateaus of constant value in the data.'''\n    nodes = set(edges.keys())\n    if plateaus is None:\n        plateaus = []\n        for i in range(len(plateau_vals)):\n            if len(nodes) == 0:\n                break\n            node = np.random.choice(list(nodes))\n            nodes.remove(node)\n            plateau = [node]\n            available = set(edges[node]) & nodes\n            while len(nodes) > 0 and len(available) > 0 and len(plateau) < plateau_size:\n                node = np.random.choice(list(available))\n                plateau.append(node)\n                available |= nodes & set(edges[node])\n                available.remove(node)\n            nodes -= set(plateau)\n            plateaus.append(set(plateau))\n    for p,v in zip(plateaus, plateau_vals):\n        data[np.array(list(p), dtype=int)] = v\n    return plateaus", "response": "Creates plateaus of constant value in the data."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef matrix_str(p, decimal_places=2, print_zero=True, label_columns=False):\n    '''Pretty-print the matrix.'''\n    return '[{0}]'.format(\"\\n  \".join([(str(i) if label_columns else '') + vector_str(a, decimal_places, print_zero) for i, a in enumerate(p)]))", "response": "Pretty - print the matrix."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef vector_str(p, decimal_places=2, print_zero=True):\n    '''Pretty-print the vector values.'''\n    style = '{0:.' + str(decimal_places) + 'f}'\n    return '[{0}]'.format(\", \".join([' ' if not print_zero and a == 0 else style.format(a) for a in p]))", "response": "Pretty - print the vector values."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef calc_plateaus(beta, edges, rel_tol=1e-4, verbose=0):\n    '''Calculate the plateaus (degrees of freedom) of a graph of beta values in linear time.'''\n    if not isinstance(edges, dict):\n        raise Exception('Edges must be a map from each node to a list of neighbors.')\n    to_check = deque(range(len(beta)))\n    check_map = np.zeros(beta.shape, dtype=bool)\n    check_map[np.isnan(beta)] = True\n    plateaus = []\n\n    if verbose:\n        print('\\tCalculating plateaus...')\n\n    if verbose > 1:\n        print('\\tIndices to check {0} {1}'.format(len(to_check), check_map.shape))\n\n    # Loop until every beta index has been checked\n    while to_check:\n        if verbose > 1:\n            print('\\t\\tPlateau #{0}'.format(len(plateaus) + 1))\n\n        # Get the next unchecked point on the grid\n        idx = to_check.popleft()\n\n        # If we already have checked this one, just pop it off\n        while to_check and check_map[idx]:\n            try:\n                idx = to_check.popleft()\n            except:\n                break\n\n        # Edge case -- If we went through all the indices without reaching an unchecked one.\n        if check_map[idx]:\n            break\n\n        # Create the plateau and calculate the inclusion conditions\n        cur_plateau = set([idx])\n        cur_unchecked = deque([idx])\n        val = beta[idx]\n        min_member = val - rel_tol\n        max_member = val + rel_tol\n\n        # Check every possible boundary of the plateau\n        while cur_unchecked:\n            idx = cur_unchecked.popleft()\n            \n            # neighbors to check\n            local_check = []\n\n            # Generic graph case, get all neighbors of this node\n            local_check.extend(edges[idx])\n\n            # Check the index's unchecked neighbors\n            for local_idx in local_check:\n                if not check_map[local_idx] \\\n                    and beta[local_idx] >= min_member \\\n                    and beta[local_idx] <= max_member:\n                        # Label this index as being checked so it's not re-checked unnecessarily\n                        check_map[local_idx] = True\n\n                        # Add it to the plateau and the list of local unchecked locations\n                        cur_unchecked.append(local_idx)\n                        cur_plateau.add(local_idx)\n\n        # Track each plateau's indices\n        plateaus.append((val, cur_plateau))\n\n    # Returns the list of plateaus and their values\n    return plateaus", "response": "Calculate the plateaus of a graph of beta values in linear time."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates edge lists for an arbitrary hypercube.", "response": "def hypercube_edges(dims, use_map=False):\n    '''Create edge lists for an arbitrary hypercube. TODO: this is probably not the fastest way.'''\n    edges = []\n    nodes = np.arange(np.product(dims)).reshape(dims)\n    for i,d in enumerate(dims):\n        for j in range(d-1):\n            for n1, n2 in zip(np.take(nodes, [j], axis=i).flatten(), np.take(nodes,[j+1], axis=i).flatten()):\n                edges.append((n1,n2))\n    if use_map:\n        return edge_map_from_edge_list(edges)\n    return edges"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncalculates the k - th order trend filtering matrix given the oriented edge incidence matrix and the value of k.", "response": "def get_delta(D, k):\n    '''Calculate the k-th order trend filtering matrix given the oriented edge\n    incidence matrix and the value of k.'''\n    if k < 0:\n        raise Exception('k must be at least 0th order.')\n    result = D\n    for i in range(k):\n        result = D.T.dot(result) if i % 2 == 0 else D.dot(result)\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef decompose_delta(deltak):\n    '''Decomposes the k-th order trend filtering matrix into a c-compatible set\n    of arrays.'''\n    if not isspmatrix_coo(deltak):\n        deltak = coo_matrix(deltak)\n    dk_rows = deltak.shape[0]\n    dk_rowbreaks = np.cumsum(deltak.getnnz(1), dtype=\"int32\")\n    dk_cols = deltak.col.astype('int32')\n    dk_vals = deltak.data.astype('double')\n    return dk_rows, dk_rowbreaks, dk_cols, dk_vals", "response": "Decomposes the k - th order trend filtering matrix into a c - compatible set\n    of arrays."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef matrix_from_edges(edges):\n    '''Returns a sparse penalty matrix (D) from a list of edge pairs. Each edge\n    can have an optional weight associated with it.'''\n    max_col = 0\n    cols = []\n    rows = []\n    vals = []\n    if type(edges) is defaultdict:\n        edge_list = []\n        for i, neighbors in edges.items():\n            for j in neighbors:\n                if i <= j:\n                    edge_list.append((i,j))\n        edges = edge_list\n    for i, edge in enumerate(edges):\n        s, t = edge[0], edge[1]\n        weight = 1 if len(edge) == 2 else edge[2]\n        cols.append(min(s,t))\n        cols.append(max(s,t))\n        rows.append(i)\n        rows.append(i)\n        vals.append(weight)\n        vals.append(-weight)\n        if cols[-1] > max_col:\n            max_col = cols[-1]\n    return coo_matrix((vals, (rows, cols)), shape=(rows[-1]+1, max_col+1))", "response": "Returns a sparse penalty matrix D from a list of edge pairs. Each edge pair can have an optional weight associated with it."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget the Kolmogorov - Smirnov distance between two densities a and b.", "response": "def ks_distance(a, b):\n    '''Get the Kolmogorov-Smirnov (KS) distance between two densities a and b.'''\n    if len(a.shape) == 1:\n        return np.max(np.abs(a.cumsum() - b.cumsum()))\n    return np.max(np.abs(a.cumsum(axis=1) - b.cumsum(axis=1)), axis=1)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef tv_distance(a, b):\n    '''Get the Total Variation (TV) distance between two densities a and b.'''\n    if len(a.shape) == 1:\n        return np.sum(np.abs(a - b))\n    return np.sum(np.abs(a - b), axis=1)", "response": "Get the Total Variation ( TV ) distance between two densities a and b."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef jdFromDate(dd, mm, yy):\n    '''def jdFromDate(dd, mm, yy): Compute the (integral) Julian day number of\n    day dd/mm/yyyy, i.e., the number of days between 1/1/4713 BC\n    (Julian calendar) and dd/mm/yyyy.'''\n    a = int((14 - mm) / 12.)\n    y = yy + 4800 - a\n    m = mm + 12 * a - 3\n    jd = dd + int((153 * m + 2) / 5.) \\\n        + 365 * y + int(y / 4.) - int(y / 100.) \\\n        + int(y / 400.) - 32045\n    if (jd < 2299161):\n        jd = dd + int((153 * m + 2) / 5.) \\\n            + 365 * y + int(y / 4.) - 32083\n    return jd", "response": "Compute the Julian day number of the current date."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nconvert a Julian day number to day month year.", "response": "def jdToDate(jd):\n    '''def jdToDate(jd): Convert a Julian day number to day/month/year.\n                       jd is an integer.'''\n    if (jd > 2299160):\n        # After 5/10/1582, Gregorian calendar\n        a = jd + 32044\n        b = int((4 * a + 3) / 146097.)\n        c = a - int((b * 146097) / 4.)\n    else:\n        b = 0\n        c = jd + 32082\n    d = int((4 * c + 3) / 1461.)\n    e = c - int((1461 * d) / 4.)\n    m = int((5 * e + 2) / 153.)\n    day = e - int((153 * m + 2) / 5.) + 1\n    month = m + 3 - 12 * int(m / 10.)\n    year = b * 100 + d - 4800 + int(m / 10.)\n    return [day, month, year]"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef NewMoon(k):\n    '''def NewMoon(k): Compute the time of the k-th new moon after\n    the new moon of 1/1/1900 13:52 UCT (measured as the number of\n    days since 1/1/4713 BC noon UCT, e.g., 2451545.125 is 1/1/2000 15:00 UTC.\n    Returns a floating number, e.g., 2415079.9758617813 for k=2 or\n    2414961.935157746 for k=-2.'''\n    # Time in Julian centuries from 1900 January 0.5\n    T = k / 1236.85\n    T2 = T * T\n    T3 = T2 * T\n    dr = math.pi / 180.\n    Jd1 = 2415020.75933 + 29.53058868 * k \\\n        + 0.0001178 * T2 - 0.000000155 * T3\n    Jd1 = Jd1 + 0.00033 * math.sin(\n        (166.56 + 132.87 * T - 0.009173 * T2) * dr)\n    # Mean new moon\n    M = 359.2242 + 29.10535608 * k \\\n        - 0.0000333 * T2 - 0.00000347 * T3\n    # Sun's mean anomaly\n    Mpr = 306.0253 + 385.81691806 * k \\\n        + 0.0107306 * T2 + 0.00001236 * T3\n    # Moon's mean anomaly\n    F = 21.2964 + 390.67050646 * k - 0.0016528 * T2 \\\n        - 0.00000239 * T3\n    # Moon's argument of latitude\n    C1 = (0.1734 - 0.000393 * T) * math.sin(M * dr) \\\n        + 0.0021 * math.sin(2 * dr * M)\n    C1 = C1 - 0.4068 * math.sin(Mpr * dr) \\\n        + 0.0161 * math.sin(dr * 2 * Mpr)\n    C1 = C1 - 0.0004 * math.sin(dr * 3 * Mpr)\n    C1 = C1 + 0.0104 * math.sin(dr * 2 * F) \\\n        - 0.0051 * math.sin(dr * (M + Mpr))\n    C1 = C1 - 0.0074 * math.sin(dr * (M - Mpr)) \\\n        + 0.0004 * math.sin(dr * (2 * F + M))\n    C1 = C1 - 0.0004 * math.sin(dr * (2 * F - M)) \\\n        - 0.0006 * math.sin(dr * (2 * F + Mpr))\n    C1 = C1 + 0.0010 * math.sin(dr * (2 * F - Mpr)) \\\n        + 0.0005 * math.sin(dr * (2 * Mpr + M))\n    if (T < -11):\n        deltat = 0.001 + 0.000839 * T + 0.0002261 * T2 \\\n            - 0.00000845 * T3 - 0.000000081 * T * T3\n    else:\n        deltat = -0.000278 + 0.000265 * T + 0.000262 * T2\n    JdNew = Jd1 + C1 - deltat\n    return JdNew", "response": "Return a new moon in the current date."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef SunLongitude(jdn):\n    '''def SunLongitude(jdn): Compute the longitude of the sun at any time.\n    Parameter: floating number jdn, the number of days since 1/1/4713 BC noon.\n    '''\n    T = (jdn - 2451545.0) / 36525.\n    # Time in Julian centuries\n    # from 2000-01-01 12:00:00 GMT\n    T2 = T * T\n    dr = math.pi / 180.  # degree to radian\n    M = 357.52910 + 35999.05030 * T \\\n        - 0.0001559 * T2 - 0.00000048 * T * T2\n    # mean anomaly, degree\n    L0 = 280.46645 + 36000.76983 * T + 0.0003032 * T2\n    # mean longitude, degree\n    DL = (1.914600 - 0.004817 * T - 0.000014 * T2) \\\n        * math.sin(dr * M)\n    DL += (0.019993 - 0.000101 * T) * math.sin(dr * 2 * M) \\\n        + 0.000290 * math.sin(dr * 3 * M)\n    L = L0 + DL  # true longitude, degree\n    L = L * dr\n    L = L - math.pi * 2 * (float(L / (math.pi * 2)))\n    # Normalize to (0, 2*math.pi)\n    return L", "response": "Return the longitude of the sun at any time."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the day that starts the luner month11 of the given time zone.", "response": "def getLunarMonth11(yy, timeZone):\n    '''def getLunarMonth11(yy, timeZone):  Find the day that starts the luner month\n    11of the given year for the given time zone.'''\n    # off = jdFromDate(31, 12, yy) \\\n    #            - 2415021.076998695\n    off = jdFromDate(31, 12, yy) - 2415021.\n    k = int(off / 29.530588853)\n    nm = getNewMoonDay(k, timeZone)\n    sunLong = getSunLongitude(nm, timeZone)\n    # sun longitude at local midnight\n    if (sunLong >= 9):\n        nm = getNewMoonDay(k - 1, timeZone)\n    return nm"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the index of the leap month after the month starting on the day a11.", "response": "def getLeapMonthOffset(a11, timeZone):\n    '''def getLeapMonthOffset(a11, timeZone): Find the index of the leap month\n    after the month starting on the day a11.'''\n    k = int((a11 - 2415021.076998695) / 29.530588853 + 0.5)\n    last = 0\n    i = 1  # start with month following lunar month 11\n    arc = getSunLongitude(\n        getNewMoonDay(k + i, timeZone), timeZone)\n    while True:\n        last = arc\n        i += 1\n        arc = getSunLongitude(\n            getNewMoonDay(k + i, timeZone),\n            timeZone)\n        if not (arc != last and i < 14):\n            break\n    return i - 1"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef S2L(dd, mm, yy, timeZone=7):\n    '''def S2L(dd, mm, yy, timeZone = 7): Convert solar date dd/mm/yyyy to\n    the corresponding lunar date.'''\n    dayNumber = jdFromDate(dd, mm, yy)\n    k = int((dayNumber - 2415021.076998695) / 29.530588853)\n    monthStart = getNewMoonDay(k + 1, timeZone)\n    if (monthStart > dayNumber):\n        monthStart = getNewMoonDay(k, timeZone)\n    # alert(dayNumber + \" -> \" + monthStart)\n    a11 = getLunarMonth11(yy, timeZone)\n    b11 = a11\n    if (a11 >= monthStart):\n        lunarYear = yy\n        a11 = getLunarMonth11(yy - 1, timeZone)\n    else:\n        lunarYear = yy + 1\n        b11 = getLunarMonth11(yy + 1, timeZone)\n    lunarDay = dayNumber - monthStart + 1\n    diff = int((monthStart - a11) / 29.)\n\n    lunarLeap = 0\n    lunarMonth = diff + 11\n\n    if (b11 - a11 > 365):\n        leapMonthDiff = \\\n            getLeapMonthOffset(a11, timeZone)\n        if (diff >= leapMonthDiff):\n            lunarMonth = diff + 10\n            if (diff == leapMonthDiff):\n                lunarLeap = 1\n    if (lunarMonth > 12):\n        lunarMonth = lunarMonth - 12\n    if (lunarMonth >= 11 and diff < 4):\n        lunarYear -= 1\n    # print [lunarDay, lunarMonth, lunarYear, lunarLeap]\n    return \\\n        [lunarDay, lunarMonth, lunarYear, lunarLeap]", "response": "Convert solar date dd mm yy to a corresponding lunar date."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nconverts a lunar date to the corresponding solar date.", "response": "def L2S(lunarD, lunarM, lunarY, lunarLeap, tZ=7):\n    '''def L2S(lunarD, lunarM, lunarY, lunarLeap, tZ = 7): Convert a lunar date\n    to the corresponding solar date.'''\n    if (lunarM < 11):\n        a11 = getLunarMonth11(lunarY - 1, tZ)\n        b11 = getLunarMonth11(lunarY, tZ)\n    else:\n        a11 = getLunarMonth11(lunarY, tZ)\n        b11 = getLunarMonth11(lunarY + 1, tZ)\n    k = int(0.5 +\n            (a11 - 2415021.076998695) / 29.530588853)\n    off = lunarM - 11\n    if (off < 0):\n        off += 12\n    if (b11 - a11 > 365):\n        leapOff = getLeapMonthOffset(a11, tZ)\n        leapM = leapOff - 2\n        if (leapM < 0):\n            leapM += 12\n        if (lunarLeap != 0 and lunarM != leapM):\n            return [0, 0, 0]\n        elif (lunarLeap != 0 or off >= leapOff):\n            off += 1\n    monthStart = getNewMoonDay(k + off, tZ)\n    return jdToDate(monthStart + lunarD - 1)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nchecks if the given stream has the MZ signature.", "response": "def hasMZSignature(self, rd): \n        \"\"\"\n        Check for MZ signature.\n\n        @type rd: L{ReadData}\n        @param rd: A L{ReadData} object.\n\n        @rtype: bool\n        @return: True is the given L{ReadData} stream has the MZ signature. Otherwise, False.\n        \"\"\"\n        rd.setOffset(0)\n        sign = rd.read(2)\n        if sign == \"MZ\":\n            return True\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef hasPESignature(self, rd):\n        rd.setOffset(0)\n        e_lfanew_offset = unpack(\"<L\",  rd.readAt(0x3c, 4))[0]\n        sign = rd.readAt(e_lfanew_offset, 2)\n        if sign == \"PE\":\n            return True\n        return False", "response": "Check if the given stream has the PE signature."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nvalidate the structure of the loaded file.", "response": "def validate(self):\n        \"\"\"\n        Performs validations over some fields of the PE structure to determine if the loaded file has a valid PE format.\n        \n        @raise PEException: If an invalid value is found into the PE instance.\n        \"\"\"\n        # Ange Albertini (@angie4771) can kill me for this! :)\n        if self.dosHeader.e_magic.value != consts.MZ_SIGNATURE:\n            raise excep.PEException(\"Invalid MZ signature. Found %d instead of %d.\" % (self.dosHeader.magic.value, consts.MZ_SIGNATURE))\n        \n        if self.dosHeader.e_lfanew.value > len(self):\n            raise excep.PEException(\"Invalid e_lfanew value. Probably not a PE file.\")\n            \n        if self.ntHeaders.signature.value != consts.PE_SIGNATURE: \n            raise excep.PEException(\"Invalid PE signature. Found %d instead of %d.\" % (self.ntHeaders.optionaHeader.signature.value, consts.PE_SIGNATURE))\n            \n        if self.ntHeaders.optionalHeader.numberOfRvaAndSizes.value > 0x10:\n            print excep.PEWarning(\"Suspicious value for NumberOfRvaAndSizes: %d.\" % self.ntHeaders.optionaHeader.numberOfRvaAndSizes.value)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef readFile(self, pathToFile):\n        fd = open(pathToFile,  \"rb\")\n        data = fd.read()\n        fd.close()\n        return data", "response": "Reads the data from a file."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nwriting data from the object to a file.", "response": "def write(self, filename = \"\"):\n        \"\"\"\n        Writes data from L{PE} object to a file.\n        \n        @rtype: str\n        @return: The L{PE} stream data.\n\n        @raise IOError: If the file could not be opened for write operations.\n        \"\"\"\n        file_data = str(self)\n        if filename:\n            try:\n                self.__write(filename, file_data)\n            except IOError:\n                raise IOError(\"File could not be opened for write operations.\")\n        else:\n            return file_data"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nwrite data to a file.", "response": "def __write(self, thePath, theData):\n        \"\"\"\n        Write data to a file.\n        \n        @type thePath: str\n        @param thePath: The file path.\n        \n        @type theData: str\n        @param theData: The data to write.\n        \"\"\"    \n        fd = open(thePath, \"wb\")\n        fd.write(theData)\n        fd.close()"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nupdate the data in every directory in every L{Directory object.", "response": "def _updateDirectoriesData(self, peStr):\n        \"\"\"\n        Updates the data in every L{Directory} object.\n        \n        @type peStr: str\n        @param peStr: C{str} representation of the L{PE} object.\n        \n        @rtype: str\n        @return: A C{str} representation of the L{PE} object.\n        \"\"\"\n        dataDirs = self.ntHeaders.optionalHeader.dataDirectory\n        wr = utils.WriteData(data)\n        \n        for dir in dataDirs:\n            dataToWrite = str(dir.info)\n            if len(dataToWrite) != dir.size.value and self._verbose:\n                print excep.DataLengthException(\"Warning: current size of %s directory does not match with dataToWrite length %d.\" % (dir.size.value, len(dataToWrite)))\n            wr.setOffset(self.getOffsetFromRva(dir.rva.value))\n            wr.write(dataToWrite)\n        return str(wr)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _getPaddingDataToSectionOffset(self):\n        start = self._getPaddingToSectionOffset()\n        end = self.sectionHeaders[0].pointerToRawData.value - start\n        return self._data[start:start+end]", "response": "Returns the data between the last section header and the begenning of data from the first section."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the digital signature within a digital signed PE file.", "response": "def _getSignature(self, readDataInstance, dataDirectoryInstance):\n        \"\"\"\n        Returns the digital signature within a digital signed PE file.\n        \n        @type readDataInstance: L{ReadData}\n        @param readDataInstance: A L{ReadData} instance containing a PE file data.\n        \n        @type dataDirectoryInstance: L{DataDirectory}\n        @param dataDirectoryInstance: A L{DataDirectory} object containing the information about directories. \n        \n        @rtype: str\n        @return: A string with the digital signature.\n        \n        @raise InstanceErrorException: If the C{readDataInstance} or the C{dataDirectoryInstance} were not specified.\n        \"\"\"\n        signature = \"\"\n\n        if readDataInstance is not None and dataDirectoryInstance is not None:        \n            securityDirectory = dataDirectoryInstance[consts.SECURITY_DIRECTORY]\n            \n            if(securityDirectory.rva.value and securityDirectory.size.value):\n                readDataInstance.setOffset(self.getOffsetFromRva(securityDirectory.rva.value))\n                \n                signature = readDataInstance.read(securityDirectory.size.value)\n        else:\n            raise excep.InstanceErrorException(\"ReadData instance or DataDirectory instance not specified.\")\n            \n        return signature"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _getOverlay(self, readDataInstance, sectionHdrsInstance):\n        if readDataInstance is not None and sectionHdrsInstance is not None:            \n            # adjust the offset in readDataInstance to the RawOffset + RawSize of the last section\n            try:\n                offset = sectionHdrsInstance[-1].pointerToRawData.value + sectionHdrsInstance[-1].sizeOfRawData.value\n                readDataInstance.setOffset(offset)\n            except excep.WrongOffsetValueException:\n                if self._verbose:\n                    print \"It seems that the file has no overlay data.\"\n        else:\n            raise excep.InstanceErrorException(\"ReadData instance or SectionHeaders instance not specified.\")\n            \n        return readDataInstance.data[readDataInstance.offset:]", "response": "Returns the overlay data from the PE file."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nconvert an offset to an RVA.", "response": "def getOffsetFromRva(self, rva):\n        \"\"\"\n        Converts an offset to an RVA.\n        \n        @type rva: int\n        @param rva: The RVA to be converted.\n        \n        @rtype: int\n        @return: An integer value representing an offset in the PE file.\n        \"\"\"\n        offset = -1\n        s = self.getSectionByRva(rva)\n        \n        if s != offset:\n            offset = (rva - self.sectionHeaders[s].virtualAddress.value) + self.sectionHeaders[s].pointerToRawData.value\n        else:\n            offset = rva\n        \n        return offset"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nconverting a RVA to an offset.", "response": "def getRvaFromOffset(self, offset):\n        \"\"\"\n        Converts a RVA to an offset.\n        \n        @type offset: int\n        @param offset: The offset value to be converted to RVA.\n        \n        @rtype: int\n        @return: The RVA obtained from the given offset.\n        \"\"\"\n        rva = -1\n        s = self.getSectionByOffset(offset)\n        \n        if s:\n            rva = (offset - self.sectionHeaders[s].pointerToRawData.value) + self.sectionHeaders[s].virtualAddress.value\n            \n        return rva"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngives an offset in the file, tries to determine the section this offset belong to. @type offset: int @param offset: Offset value. @rtype: int @return: An index, starting at 0, that represents the section the given offset belongs to.", "response": "def getSectionByOffset(self, offset):\n        \"\"\"\n        Given an offset in the file, tries to determine the section this offset belong to.\n        \n        @type offset: int\n        @param offset: Offset value.\n        \n        @rtype: int\n        @return: An index, starting at 0, that represents the section the given offset belongs to.\n        \"\"\"\n        index = -1\n        for i in range(len(self.sectionHeaders)):\n            if (offset < self.sectionHeaders[i].pointerToRawData.value + self.sectionHeaders[i].sizeOfRawData.value):\n                index = i\n                break\n        return index"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ntry to find the section index by name.", "response": "def getSectionIndexByName(self, name):\n        \"\"\"\n        Given a string representing a section name, tries to find the section index.\n\n        @type name: str\n        @param name: A section name.\n\n        @rtype: int\n        @return: The index, starting at 0, of the section.\n        \"\"\"\n        index = -1\n        \n        if name:\n            for i in range(len(self.sectionHeaders)):\n                if self.sectionHeaders[i].name.value.find(name) >= 0:\n                    index = i\n                    break\n        return index"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngiving a RVA in the file, tries to determine the section this RVA belongs to. @type rva: int @param rva: RVA value. @rtype: int @return: An index, starting at 1, that represents the section the given RVA belongs to.", "response": "def getSectionByRva(self, rva):\n        \"\"\"\n        Given a RVA in the file, tries to determine the section this RVA belongs to.\n        \n        @type rva: int\n        @param rva: RVA value.\n        \n        @rtype: int\n        @return: An index, starting at 1, that represents the section the given RVA belongs to.\n        \"\"\"\n        \n        index = -1\n        if rva < self.sectionHeaders[0].virtualAddress.value:\n            return index\n        \n        for i in range(len(self.sectionHeaders)):\n            fa = self.ntHeaders.optionalHeader.fileAlignment.value\n            prd = self.sectionHeaders[i].pointerToRawData.value\n            srd = self.sectionHeaders[i].sizeOfRawData.value\n            if len(str(self)) - self._adjustFileAlignment(prd,  fa) < srd:\n                size = self.sectionHeaders[i].misc.value\n            else:\n                size = max(srd,  self.sectionHeaders[i].misc.value)\n            if (self.sectionHeaders[i].virtualAddress.value <= rva) and rva < (self.sectionHeaders[i].virtualAddress.value + size):\n                index = i\n                break\n\n        return index"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the offset to the last section header present in the PE file.", "response": "def _getPaddingToSectionOffset(self):\n        \"\"\"\n        Returns the offset to last section header present in the PE file.\n        \n        @rtype: int\n        @return: The offset where the end of the last section header resides in the PE file.\n        \"\"\"\n        return len(str(self.dosHeader) + str(self.dosStub) + str(self.ntHeaders) + str(self.sectionHeaders))"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nparses all the directories in the PE file.", "response": "def fullLoad(self):\n        \"\"\"Parse all the directories in the PE file.\"\"\"\n        self._parseDirectories(self.ntHeaders.optionalHeader.dataDirectory, self.PE_TYPE)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _internalParse(self, readDataInstance):\n        self.dosHeader = DosHeader.parse(readDataInstance)\n        \n        self.dosStub = readDataInstance.read(self.dosHeader.e_lfanew.value - readDataInstance.offset)\n        self.ntHeaders = NtHeaders.parse(readDataInstance)\n        \n        if self.ntHeaders.optionalHeader.magic.value == consts.PE32:\n            self.PE_TYPE = consts.PE32\n        elif self.ntHeaders.optionalHeader.magic.value == consts.PE64:\n            self.PE_TYPE = consts.PE64\n            readDataInstance.setOffset(readDataInstance.tell() - OptionalHeader().sizeof())\n            self.ntHeaders.optionalHeader = OptionalHeader64.parse(readDataInstance)\n            \n        self.sectionHeaders = SectionHeaders.parse(readDataInstance,  self.ntHeaders.fileHeader.numberOfSections.value)\n\n        # as padding is possible between the last section header and the beginning of the first section\n        # we must adjust the offset in readDataInstance to point to the first byte of the first section.\n        readDataInstance.setOffset(self.sectionHeaders[0].pointerToRawData.value)\n        \n        self.sections = Sections.parse(readDataInstance,  self.sectionHeaders)\n        \n        self.overlay = self._getOverlay(readDataInstance,  self.sectionHeaders)\n        self.signature = self._getSignature(readDataInstance,  self.ntHeaders.optionalHeader.dataDirectory)\n        \n        if not self._fastLoad:\n            self._parseDirectories(self.ntHeaders.optionalHeader.dataDirectory, self.PE_TYPE)", "response": "Internal method to parse the contents of a file."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nadds a new section to the existing instance.", "response": "def addSection(self, data, name =\".pype32\\x00\", flags = 0x60000000):\n        \"\"\"\n        Adds a new section to the existing L{PE} instance.\n        \n        @type data: str\n        @param data: The data to be added in the new section.\n        \n        @type name: str\n        @param name: (Optional) The name for the new section.\n        \n        @type flags: int\n        @param flags: (Optional) The attributes for the new section.\n        \"\"\"\n        fa = self.ntHeaders.optionalHeader.fileAlignment.value\n        sa = self.ntHeaders.optionalHeader.sectionAlignment.value\n\n        padding = \"\\xcc\" * (fa - len(data))\n        sh = SectionHeader()\n        \n        if len(self.sectionHeaders):\n            # get the va, vz, ra and rz of the last section in the array of section headers\n            vaLastSection = self.sectionHeaders[-1].virtualAddress.value\n            sizeLastSection = self.sectionHeaders[-1].misc.value\n            pointerToRawDataLastSection = self.sectionHeaders[-1].pointerToRawData.value\n            sizeOfRawDataLastSection = self.sectionHeaders[-1].sizeOfRawData.value\n            \n            sh.virtualAddress.value = self._adjustSectionAlignment(vaLastSection + sizeLastSection,  fa, sa)\n            sh.pointerToRawData.value = self._adjustFileAlignment(pointerToRawDataLastSection + sizeOfRawDataLastSection,  fa)\n\n        sh.misc.value = self._adjustSectionAlignment(len(data),  fa,  sa) or consts.DEFAULT_PAGE_SIZE\n        sh.sizeOfRawData.value = self._adjustFileAlignment(len(data),  fa) or consts.DEFAULT_FILE_ALIGNMENT            \n        sh.characteristics.value = flags\n        sh.name.value = name\n        \n        self.sectionHeaders.append(sh)\n        self.sections.append(data + padding)\n        \n        self.ntHeaders.fileHeader.numberOfSections.value += 1"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef extendSection(self, sectionIndex, data):\n        \n        fa = self.ntHeaders.optionalHeader.fileAlignment.value\n        sa = self.ntHeaders.optionalHeader.sectionAlignment.value \n        \n        if len(self.sectionHeaders):\n            if len(self.sectionHeaders) == sectionIndex:\n                try:\n                    # we are in the last section or self.sectionHeaders has only 1 sectionHeader instance\n                    vzLastSection = self.sectionHeaders[-1].misc.value \n                    rzLastSection = self.sectionHeaders[-1].sizeOfRawData.value\n                    \n                    self.sectionHeaders[-1].misc.value = self._adjustSectionAlignment(vzLastSection + len(data), fa,  sa)\n                    self.sectionHeaders[-1].sizeOfRawData.value = self._adjustFileAlignment(rzLastSection + len(data),  fa)\n                    \n                    vz = self.sectionHeaders[-1].misc.value \n                    rz = self.sectionHeaders[-1].sizeOfRawData.value\n                    \n                except IndexError:\n                    raise IndexError(\"list index out of range.\")\n                    \n                if vz < rz:\n                    print \"WARNING: VirtualSize (%x) is less than SizeOfRawData (%x)\" % (vz,  rz)\n                    \n                if len(data) % fa == 0:\n                    self.sections[-1] += data\n                else:\n                    self.sections[-1] += data + \"\\xcc\" * (fa - len(data) % fa)\n                \n            else:\n                # if it is not the last section ...\n                try:\n                    # adjust data of the section the user wants to extend\n                    counter = sectionIndex - 1\n                    \n                    vzCurrentSection = self.sectionHeaders[counter].misc.value\n                    rzCurrentSection = self.sectionHeaders[counter].sizeOfRawData.value\n                    \n                    self.sectionHeaders[counter].misc.value = self._adjustSectionAlignment(vzCurrentSection + len(data),  fa,  sa)\n                    self.sectionHeaders[counter].sizeOfRawData.value = self._adjustFileAlignment(rzCurrentSection + len(data),  fa)\n\n                    if len(data) % fa == 0:\n                        self.sections[counter] += data\n                    else:\n                        self.sections[counter] += data + \"\\xcc\" * (fa - len(data) % fa)\n                         \n                    counter += 1\n                    \n                    while(counter != len(self.sectionHeaders)):\n                        vzPreviousSection = self.sectionHeaders[counter - 1].misc.value\n                        vaPreviousSection = self.sectionHeaders[counter - 1].virtualAddress.value\n                        rzPreviousSection = self.sectionHeaders[counter - 1].sizeOfRawData.value\n                        roPreviousSection = self.sectionHeaders[counter - 1].pointerToRawData.value\n                        \n                        # adjust VA and RO of the next section\n                        self.sectionHeaders[counter].virtualAddress.value = self._adjustSectionAlignment(vzPreviousSection + vaPreviousSection,  fa,  sa)\n                        self.sectionHeaders[counter].pointerToRawData.value = self._adjustFileAlignment(rzPreviousSection + roPreviousSection,  fa)\n                        \n                        vz = self.sectionHeaders[counter].virtualAddress.value \n                        rz = self.sectionHeaders[counter].pointerToRawData.value\n                        \n                        if vz < rz:\n                            print \"WARNING: VirtualSize (%x) is less than SizeOfRawData (%x)\" % (vz,  rz)\n                            \n                        counter += 1\n                    \n                except IndexError:\n                    raise IndexError(\"list index out of range.\")\n                \n        else:\n            raise excep.SectionHeadersException(\"There is no section to extend.\")", "response": "Extends an existing section in the instance."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nfix the necessary fields in the PE file instance in order to create a valid PE32 PE32. i. e. SizeOfImage.", "response": "def _fixPe(self):\n        \"\"\"\n        Fixes the necessary fields in the PE file instance in order to create a valid PE32. i.e. SizeOfImage.\n        \"\"\"\n        sizeOfImage = 0\n        for sh in self.sectionHeaders:\n            sizeOfImage += sh.misc\n        self.ntHeaders.optionaHeader.sizeoOfImage.value = self._sectionAlignment(sizeOfImage + 0x1000)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nadjusts the value of the file alignment parameter.", "response": "def _adjustFileAlignment(self, value, fileAlignment):\n        \"\"\"\n        Align a value to C{FileAligment}.\n       \n        @type value: int\n        @param value: The value to align.\n        \n        @type fileAlignment: int\n        @param fileAlignment: The value to be used to align the C{value} parameter.\n        \n        @rtype: int\n        @return: The aligned value.\n        \"\"\"\n        if fileAlignment > consts.DEFAULT_FILE_ALIGNMENT:\n            if not utils.powerOfTwo(fileAlignment):\n                print \"Warning: FileAlignment is greater than DEFAULT_FILE_ALIGNMENT (0x200) and is not power of two.\"\n        \n        if fileAlignment < consts.DEFAULT_FILE_ALIGNMENT:\n            return value\n            \n        if fileAlignment and value % fileAlignment:\n            return ((value / fileAlignment) + 1) * fileAlignment\n            \n        return value"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _adjustSectionAlignment(self, value, fileAlignment, sectionAlignment):\n        if fileAlignment < consts.DEFAULT_FILE_ALIGNMENT:\n            if fileAligment != sectionAlignment:\n                print \"FileAlignment does not match SectionAlignment.\"\n        \n        if sectionAlignment < consts.DEFAULT_PAGE_SIZE:\n            sectionAlignment = fileAlignment\n            \n        if sectionAlignment and value % sectionAlignment:\n            return sectionAlignment * ((value / sectionAlignment) + 1)\n        return value", "response": "Adjusts the value of a key to match the file alignment and section alignment."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a C { DWORD } from a given RVA.", "response": "def getDwordAtRva(self, rva):\n        \"\"\"\n        Returns a C{DWORD} from a given RVA. \n        \n        @type rva: int\n        @param rva: The RVA to get the C{DWORD} from.\n        \n        @rtype: L{DWORD}\n        @return: The L{DWORD} obtained at the given RVA.\n        \"\"\"\n        return datatypes.DWORD.parse(utils.ReadData(self.getDataAtRva(rva,  4)))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a C { WORD } from a given RVA.", "response": "def getWordAtRva(self, rva):\n        \"\"\"\n        Returns a C{WORD} from a given RVA. \n        \n        @type rva: int\n        @param rva: The RVA to get the C{WORD} from.\n        \n        @rtype: L{WORD}\n        @return: The L{WORD} obtained at the given RVA.\n        \"\"\"\n        return datatypes.WORD.parse(utils.ReadData(self.getDataAtRva(rva,  2)))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef getDwordAtOffset(self, offset):\n        return datatypes.DWORD.parse(utils.ReadData(self.getDataAtOffset(offset,  4)))", "response": "Returns a C { DWORD } from a given offset."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef getWordAtOffset(self, offset):\n        return datatypes.WORD.parse(utils.ReadData(self.getDataAtOffset(offset, 2)))", "response": "Returns a C { WORD } from a given offset."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef getQwordAtRva(self, rva):\n        return datatypes.QWORD.parse(utils.ReadData(self.getDataAtRva(rva,  8)))", "response": "Returns a C { QWORD } from a given RVA."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef getQwordAtOffset(self, offset):\n        return datatypes.QWORD.parse(utils.ReadData(self.getDataAtOffset(offset,  8)))", "response": "Returns a C { QWORD } from a given offset."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef getDataAtRva(self, rva, size):\n        return self.getDataAtOffset(self.getOffsetFromRva(rva),  size)", "response": "Gets the binary data at a given RVA."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting the binary data at a given offset.", "response": "def getDataAtOffset(self, offset, size):\n        \"\"\"\n        Gets binary data at a given offset.\n        \n        @type offset: int\n        @param offset: The offset to get the data from.\n        \n        @type size: int\n        @param size: The size of the data to be obtained.\n        \n        @rtype: str\n        @return: The data obtained at the given offset.\n        \"\"\"\n        data = str(self)\n        return data[offset:offset+size]"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a L { String } object from a given RVA.", "response": "def readStringAtRva(self, rva):\n        \"\"\"\n        Returns a L{String} object from a given RVA. \n        \n        @type rva: int\n        @param rva: The RVA to get the string from.\n        \n        @rtype: L{String}\n        @return: A new L{String} object from the given RVA.\n        \"\"\"\n        d = self.getDataAtRva(rva,  1)\n        resultStr = datatypes.String(\"\")\n        while d != \"\\x00\":\n            resultStr.value += d\n            rva += 1\n            d = self.getDataAtRva(rva, 1)\n        return resultStr"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ndetermine if the current instance is an executable file.", "response": "def isExe(self):\n        \"\"\"\n        Determines if the current L{PE} instance is an Executable file.\n        \n        @rtype: bool\n        @return: C{True} if the current L{PE} instance is an Executable file. Otherwise, returns C{False}.\n        \"\"\"\n        if not self.isDll() and not self.isDriver() and ( consts.IMAGE_FILE_EXECUTABLE_IMAGE & self.ntHeaders.fileHeader.characteristics.value) == consts.IMAGE_FILE_EXECUTABLE_IMAGE:\n            return True\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ndetermining if the current L { PE } instance is a Dynamic Link Library file.", "response": "def isDll(self):\n        \"\"\"\n        Determines if the current L{PE} instance is a Dynamic Link Library file.\n        \n        @rtype: bool\n        @return: C{True} if the current L{PE} instance is a DLL. Otherwise, returns C{False}.\n        \"\"\"\n        if (consts.IMAGE_FILE_DLL & self.ntHeaders.fileHeader.characteristics.value) == consts.IMAGE_FILE_DLL:\n            return True\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef isDriver(self):\n        modules = []\n        imports = self.ntHeaders.optionalHeader.dataDirectory[consts.IMPORT_DIRECTORY].info\n        for module in imports:\n            modules.append(module.metaData.moduleName.value.lower())\n        \n        if set([\"ntoskrnl.exe\", \"hal.dll\", \"ndis.sys\", \"bootvid.dll\", \"kdcom.dll\"]).intersection(modules):\n            return True\n        return False", "response": "Determines if the current L { PE } instance is a driver."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef isPe32(self):\n        if self.ntHeaders.optionalHeader.magic.value == consts.PE32:\n            return True\n        return False", "response": "Determines if the current instance is a PE32 file."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ndetermines if the current instance is a PE64 file.", "response": "def isPe64(self):\n        \"\"\"\n        Determines if the current L{PE} instance is a PE64 file.\n        \n        @rtype: bool\n        @return: C{True} if the current L{PE} instance is a PE64 file. Otherwise, returns C{False}.\n        \"\"\"\n        if self.ntHeaders.optionalHeader.magic.value == consts.PE64:\n            return True\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ndetermines if the current instance is bounded i. e. has a C { BED_IMPORT_DIRECTORY }.", "response": "def isPeBounded(self):\n        \"\"\"\n        Determines if the current L{PE} instance is bounded, i.e. has a C{BOUND_IMPORT_DIRECTORY}.\n        \n        @rtype: bool\n        @return: Returns C{True} if the current L{PE} instance is bounded. Otherwise, returns C{False}.\n        \"\"\"\n        boundImportsDir = self.ntHeaders.optionalHeader.dataDirectory[consts.BOUND_IMPORT_DIRECTORY]\n        if boundImportsDir.rva.value and boundImportsDir.size.value:\n            return True\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef isNXEnabled(self):\n        return self.ntHeaders.optionalHeader.dllCharacteristics.value & consts.IMAGE_DLL_CHARACTERISTICS_NX_COMPAT == consts.IMAGE_DLL_CHARACTERISTICS_NX_COMPAT", "response": "Determines if the NX characteristics of the current L { PE } instance is set to NXCOMPAT."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndetermine if the current L { PE } instance has the CFG flag enabled.", "response": "def isCFGEnabled(self):\n        \"\"\"\n        Determines if the current L{PE} instance has CFG (Control Flow Guard) flag enabled.\n        @see: U{http://blogs.msdn.com/b/vcblog/archive/2014/12/08/visual-studio-2015-preview-work-in-progress-security-feature.aspx}\n        @see: U{https://msdn.microsoft.com/en-us/library/dn919635%%28v=vs.140%%29.aspx}\n\n        @rtype: bool\n        @return: Returns C{True} if the current L{PE} instance has the CFG flag enabled. Otherwise, return C{False}.\n        \"\"\"\n        return self.ntHeaders.optionalHeader.dllCharacteristics.value & consts.IMAGE_DLL_CHARACTERISTICS_GUARD_CF == consts.IMAGE_DLL_CHARACTERISTICS_GUARD_CF"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ndetermining if the ASLR characteristics of the current L{PE} instance is enabled.", "response": "def isASLREnabled(self):\n        \"\"\"\n        Determines if the current L{PE} instance has the DYNAMICBASE (Use address space layout randomization) flag enabled.\n        @see: U{http://msdn.microsoft.com/en-us/library/bb384887.aspx}\n\n        @rtype: bool\n        @return: Returns C{True} if the current L{PE} instance has the DYNAMICBASE flag enabled. Otherwise, returns C{False}.\n        \"\"\"\n        return self.ntHeaders.optionalHeader.dllCharacteristics.value & consts.IMAGE_DLL_CHARACTERISTICS_DYNAMIC_BASE == consts.IMAGE_DLL_CHARACTERISTICS_DYNAMIC_BASE"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef isSAFESEHEnabled(self):\n        NOSEH = -1\n        SAFESEH_OFF = 0\n        SAFESEH_ON = 1\n\n        if self.ntHeaders.optionalHeader.dllCharacteristics.value & consts.IMAGE_DLL_CHARACTERISTICS_NO_SEH:\n            return NOSEH\n\n        loadConfigDir = self.ntHeaders.optionalHeader.dataDirectory[consts.CONFIGURATION_DIRECTORY]\n        if loadConfigDir.info:\n            if loadConfigDir.info.SEHandlerTable.value:\n                return SAFESEH_ON\n        return SAFESEH_OFF", "response": "Determines if the current L { PE } instance has the SAFESEH flag enabled. Returns C { True } if SAFESEH is off or - 1 if SAFESEH is set to NO. Returns C { False } if SAFESEH is set to OFF or - 1 if SAFESEH is set to NO. Returns C { false } if SAFESEH is set to OFF or - 1 if SAFESEH is set to NOSEH is set to NOSEH is set to NO."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _parseDirectories(self, dataDirectoryInstance, magic = consts.PE32):\n        directories = [(consts.EXPORT_DIRECTORY, self._parseExportDirectory),\\\n                         (consts.IMPORT_DIRECTORY, self._parseImportDirectory),\\\n                         (consts.RESOURCE_DIRECTORY, self._parseResourceDirectory),\\\n                         (consts.EXCEPTION_DIRECTORY, self._parseExceptionDirectory),\\\n                         (consts.RELOCATION_DIRECTORY, self._parseRelocsDirectory),\\\n                         (consts.TLS_DIRECTORY, self._parseTlsDirectory),\\\n                         (consts.DEBUG_DIRECTORY, self._parseDebugDirectory),\\\n                         (consts.BOUND_IMPORT_DIRECTORY, self._parseBoundImportDirectory),\\\n                         (consts.DELAY_IMPORT_DIRECTORY, self._parseDelayImportDirectory),\\\n                         (consts.CONFIGURATION_DIRECTORY, self._parseLoadConfigDirectory),\\\n                         (consts.NET_METADATA_DIRECTORY, self._parseNetDirectory)]\n        \n        for directory in directories:\n            dir = dataDirectoryInstance[directory[0]]\n            if dir.rva.value and dir.size.value:\n                try:\n                    dataDirectoryInstance[directory[0]].info = directory[1](dir.rva.value, dir.size.value, magic)\n                except Exception as e:\n                    print excep.PEWarning(\"Error parsing PE directory: %s.\" % directory[1].__name__.replace(\"_parse\", \"\"))", "response": "Parses all the directories in the instance."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _parseResourceDirectory(self, rva, size, magic = consts.PE32):\n        return self.getDataAtRva(rva, size)", "response": "Parses the C { IMAGE_RESOURCE_DIRECTORY } directory."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _parseExceptionDirectory(self, rva, size, magic = consts.PE32):\n        return self.getDataAtRva(rva, size)", "response": "Parses the C { IMAGE_EXCEPTION_DIRECTORY } directory."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nparse the delay imports directory.", "response": "def _parseDelayImportDirectory(self, rva, size, magic = consts.PE32):\n        \"\"\"\n        Parses the delay imports directory.\n        \n        @type rva: int \n        @param rva: The RVA where the delay imports directory starts.\n        \n        @type size: int\n        @param size: The size of the delay imports directory.\n        \n        @type magic: int\n        @param magic: (Optional) The type of PE. This value could be L{consts.PE32} or L{consts.PE64}.\n        \n        @rtype: str\n        @return: The delay imports directory data.\n        \"\"\"\n        return self.getDataAtRva(rva, size)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _parseBoundImportDirectory(self, rva, size, magic = consts.PE32):\n        data = self.getDataAtRva(rva, size)\n        rd = utils.ReadData(data)\n        boundImportDirectory = directories.ImageBoundImportDescriptor.parse(rd)\n        \n        # parse the name of every bounded import.\n        for i in range(len(boundImportDirectory) - 1):\n            if hasattr(boundImportDirectory[i],  \"forwarderRefsList\"):\n                if boundImportDirectory[i].forwarderRefsList:\n                    for forwarderRefEntry in boundImportDirectory[i].forwarderRefsList:\n                        offset = forwarderRefEntry.offsetModuleName.value\n                        forwarderRefEntry.moduleName = self.readStringAtRva(offset + rva)\n                        \n            offset = boundImportDirectory[i].offsetModuleName.value\n            boundImportDirectory[i].moduleName = self.readStringAtRva(offset + rva)\n        return boundImportDirectory", "response": "Parses the bound import directory."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nparsing IMAGE_LOAD_CONFIG_DIRECTORY and returns a new object.", "response": "def _parseLoadConfigDirectory(self, rva, size, magic = consts.PE32):\n        \"\"\"\n        Parses IMAGE_LOAD_CONFIG_DIRECTORY.\n        \n        @type rva: int \n        @param rva: The RVA where the IMAGE_LOAD_CONFIG_DIRECTORY starts.\n        \n        @type size: int\n        @param size: The size of the IMAGE_LOAD_CONFIG_DIRECTORY.\n        \n        @type magic: int\n        @param magic: (Optional) The type of PE. This value could be L{consts.PE32} or L{consts.PE64}.\n        \n        @rtype: L{ImageLoadConfigDirectory}\n        @return: A new L{ImageLoadConfigDirectory}. \n        @note: if the L{PE} instance is a PE64 file then a new L{ImageLoadConfigDirectory64} is returned.\n        \"\"\"\n        # print \"RVA: %x - SIZE: %x\" % (rva, size)\n\n        # I've found some issues when parsing the IMAGE_LOAD_CONFIG_DIRECTORY in some DLLs. \n        # There is an inconsistency with the size of the struct between MSDN docs and VS.\n        # sizeof(IMAGE_LOAD_CONFIG_DIRECTORY) should be 0x40, in fact, that's the size Visual Studio put\n        # in the directory table, even if the DLL was compiled with SAFESEH:ON. But If that is the case, the sizeof the\n        # struct should be 0x48.\n        # more information here: http://www.accuvant.com/blog/old-meets-new-microsoft-windows-safeseh-incompatibility\n        data = self.getDataAtRva(rva, directories.ImageLoadConfigDirectory().sizeof())\n        rd = utils.ReadData(data)\n\n        if magic == consts.PE32:\n            return directories.ImageLoadConfigDirectory.parse(rd)\n        elif magic == consts.PE64:\n            return directories.ImageLoadConfigDirectory64.parse(rd)\n        else:\n            raise excep.InvalidParameterException(\"Wrong magic\")"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _parseTlsDirectory(self, rva, size, magic = consts.PE32):\n        data = self.getDataAtRva(rva, size)\n        rd = utils.ReadData(data)\n        \n        if magic == consts.PE32:\n            return directories.TLSDirectory.parse(rd)\n        elif magic == consts.PE64:\n            return directories.TLSDirectory64.parse(rd)\n        else:\n            raise excep.InvalidParameterException(\"Wrong magic\")", "response": "Parses the TLS directory."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _parseRelocsDirectory(self, rva, size, magic = consts.PE32):\n        data = self.getDataAtRva(rva,  size)\n        #print \"Length Relocation data: %x\" % len(data)\n        rd = utils.ReadData(data)\n        \n        relocsArray = directories.ImageBaseRelocation()\n        while rd.offset < size:\n            relocEntry = directories.ImageBaseRelocationEntry.parse(rd)\n            relocsArray.append(relocEntry)\n        return relocsArray", "response": "Parses the relocation directory."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _parseExportDirectory(self, rva, size, magic = consts.PE32):\n        data = self.getDataAtRva(rva,  size)\n        rd = utils.ReadData(data)\n        \n        iet = directories.ImageExportTable.parse(rd)\n        \n        auxFunctionRvaArray = list()\n        \n        numberOfNames = iet.numberOfNames.value\n        addressOfNames = iet.addressOfNames.value\n        addressOfNameOrdinals = iet.addressOfNameOrdinals.value\n        addressOfFunctions = iet.addressOfFunctions.value\n        \n        # populate the auxFunctionRvaArray\n        for i in xrange(iet.numberOfFunctions.value):\n            auxFunctionRvaArray.append(self.getDwordAtRva(addressOfFunctions).value)\n            addressOfFunctions += datatypes.DWORD().sizeof()\n            \n        for i in xrange(numberOfNames):\n            \n            nameRva = self.getDwordAtRva(addressOfNames).value\n            nameOrdinal = self.getWordAtRva(addressOfNameOrdinals).value\n            exportName = self.readStringAtRva(nameRva).value\n            \n            entry = directories.ExportTableEntry()\n            \n            ordinal = nameOrdinal + iet.base.value\n            #print \"Ordinal value: %d\" % ordinal\n            entry.ordinal.value = ordinal\n            \n            entry.nameOrdinal.vaue = nameOrdinal\n            entry.nameRva.value = nameRva\n            entry.name.value = exportName\n            entry.functionRva.value = auxFunctionRvaArray[nameOrdinal]\n            \n            iet.exportTable.append(entry)\n            \n            addressOfNames += datatypes.DWORD().sizeof()\n            addressOfNameOrdinals += datatypes.WORD().sizeof()\n        \n        #print \"export table length: %d\" % len(iet.exportTable)\n        \n        #print \"auxFunctionRvaArray: %r\" % auxFunctionRvaArray\n        for i in xrange(iet.numberOfFunctions.value):\n            #print \"auxFunctionRvaArray[%d]: %x\" % (i,  auxFunctionRvaArray[i])\n            if auxFunctionRvaArray[i] != iet.exportTable[i].functionRva.value:\n                entry = directories.ExportTableEntry()\n                \n                entry.functionRva.value = auxFunctionRvaArray[i]\n                entry.ordinal.value = iet.base.value + i\n                \n                iet.exportTable.append(entry)\n        \n        #print \"export table length: %d\" % len(iet.exportTable)\n        sorted(iet.exportTable, key=lambda entry:entry.ordinal)\n        return iet", "response": "Parses the C { IMAGE_EXPORT_DIRECTORY } directory and returns a new object."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nparse the C { IMAGE_DEBUG_DIRECTORY } directory.", "response": "def _parseDebugDirectory(self, rva, size, magic = consts.PE32):\n        \"\"\"\n        Parses the C{IMAGE_DEBUG_DIRECTORY} directory.\n        @see: U{http://msdn.microsoft.com/es-es/library/windows/desktop/ms680307(v=vs.85).aspx}\n        \n        @type rva: int \n        @param rva: The RVA where the C{IMAGE_DEBUG_DIRECTORY} directory starts.\n        \n        @type size: int\n        @param size: The size of the C{IMAGE_DEBUG_DIRECTORY} directory.\n        \n        @type magic: int\n        @param magic: (Optional) The type of PE. This value could be L{consts.PE32} or L{consts.PE64}.\n        \n        @rtype: L{ImageDebugDirectory}\n        @return: A new L{ImageDebugDirectory} object.\n        \"\"\"        \n        debugDirData = self.getDataAtRva(rva, size)\n        numberOfEntries = size / consts.SIZEOF_IMAGE_DEBUG_ENTRY32\n        rd = utils.ReadData(debugDirData)\n        return directories.ImageDebugDirectories.parse(rd,  numberOfEntries)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nparsing the C { IMAGE_IMPORT_DIRECTORY } directory and returns a new object.", "response": "def _parseImportDirectory(self, rva, size, magic = consts.PE32):\n        \"\"\"\n        Parses the C{IMAGE_IMPORT_DIRECTORY} directory.\n        \n        @type rva: int \n        @param rva: The RVA where the C{IMAGE_IMPORT_DIRECTORY} directory starts.\n        \n        @type size: int\n        @param size: The size of the C{IMAGE_IMPORT_DIRECTORY} directory.\n        \n        @type magic: int\n        @param magic: (Optional) The type of PE. This value could be L{consts.PE32} or L{consts.PE64}.\n        \n        @rtype: L{ImageImportDescriptor}\n        @return: A new L{ImageImportDescriptor} object.\n        \n        @raise InvalidParameterException: If wrong magic was specified.\n        \"\"\"\n        #print \"RVA: %x - Size: %x\" % (rva, size)        \n        importsDirData = self.getDataAtRva(rva,  size)\n        #print \"Length importsDirData: %d\" % len(importsDirData)\n        numberOfEntries = size / consts.SIZEOF_IMAGE_IMPORT_ENTRY32\n        rd = utils.ReadData(importsDirData)\n        \n        # In .NET binaries, the size of the data directory corresponding to the import table\n        # is greater than the number of bytes in the file. Thats why we check for the last group of 5 null bytes\n        # that indicates the end of the IMAGE_IMPORT_DESCRIPTOR array.\n        rdAux = utils.ReadData(importsDirData)\n        count = 0\n        entry = rdAux.read(consts.SIZEOF_IMAGE_IMPORT_ENTRY32)\n        while rdAux.offset < len(rdAux.data) and not utils.allZero(entry):\n            try:\n                entry = rdAux.read(consts.SIZEOF_IMAGE_IMPORT_ENTRY32)\n                count += 1\n            except excep.DataLengthException:\n                if self._verbose:\n                    print \"[!] Warning: DataLengthException detected!.\"\n                \n        if numberOfEntries - 1 > count:\n            numberOfEntries = count + 1\n\n        iid = directories.ImageImportDescriptor.parse(rd, numberOfEntries)\n        iidLength = len(iid)\n        \n        peIsBounded = self.isPeBounded()\n        \n        if magic == consts.PE64:\n            ORDINAL_FLAG = consts.IMAGE_ORDINAL_FLAG64\n            ADDRESS_MASK = consts.ADDRESS_MASK64\n        elif magic == consts.PE32:\n            ORDINAL_FLAG = consts.IMAGE_ORDINAL_FLAG\n            ADDRESS_MASK = consts.ADDRESS_MASK32\n        else:\n            raise InvalidParameterException(\"magic value %d is not PE64 nor PE32.\" % magic)\n        \n        for i in range(iidLength -1):\n            if iid[i].originalFirstThunk.value != 0:\n                iltRva = iid[i].originalFirstThunk.value\n                iatRva = iid[i].firstThunk.value\n                \n                if magic == consts.PE64:\n                    entry = self.getQwordAtRva(iltRva).value\n                elif magic == consts.PE32:\n                    entry = self.getDwordAtRva(iltRva).value\n\n                while entry != 0:\n                    \n                    if magic == consts.PE64:\n                        iatEntry = directories.ImportAddressTableEntry64()\n                    elif magic == consts.PE32:\n                        iatEntry = directories.ImportAddressTableEntry()\n                        \n                    iatEntry.originalFirstThunk.value = entry\n                    \n                    if iatEntry.originalFirstThunk.value & ORDINAL_FLAG:\n                        iatEntry.hint.value = None\n                        iatEntry.name.value = iatEntry.originalFirstThunk.value & ADDRESS_MASK\n                    else: \n                        iatEntry.hint.value = self.getWordAtRva(iatEntry.originalFirstThunk.value).value\n                        iatEntry.name.value = self.readStringAtRva(iatEntry.originalFirstThunk.value + 2).value\n                    \n                    if magic == consts.PE64:\n                        iatEntry.firstThunk.value = self.getQwordAtRva(iatRva).value\n                        iltRva += 8\n                        iatRva += 8\n                        entry = self.getQwordAtRva(iltRva).value\n                    elif magic == consts.PE32:\n                        iatEntry.firstThunk.value = self.getDwordAtRva(iatRva).value                        \n                        iltRva += 4\n                        iatRva += 4\n                        entry = self.getDwordAtRva(iltRva).value                        \n                    \n                    iid[i].iat.append(iatEntry)\n                    \n            else:\n                iatRva = iid[i].firstThunk.value\n                \n                if magic == consts.PE64:\n                    entry = self.getQwordAtRva(iatRva).value\n                elif magic == consts.PE32:\n                    entry = self.getDwordAtRva(iatRva).value\n                    \n                while entry != 0:\n\n                    if magic == consts.PE64:\n                        iatEntry = directories.ImportAddressTableEntry64()\n                    elif magic == consts.PE32:\n                        iatEntry = directories.ImportAddressTableEntry()\n                    \n                    iatEntry.firstThunk.value = entry\n                    iatEntry.originalFirstThunk.value = 0\n                    \n                    if not peIsBounded:\n                        ft = iatEntry.firstThunk.value\n\n                        if ft & ORDINAL_FLAG:\n                            iatEntry.hint.value = None\n                            iatEntry.name.value = ft & ADDRESS_MASK\n                        else:\n                            iatEntry.hint.value = self.getWordAtRva(ft).value\n                            iatEntry.name.value = self.readStringAtRva(ft + 2).value                            \n                    else:\n                        iatEntry.hint.value = None\n                        iatEntry.name.value = None\n                \n                    if magic == consts.PE64:\n                        iatRva += 8\n                        entry = self.getQwordAtRva(iatRva).value\n                    elif magic == consts.PE32:\n                        iatRva += 4\n                        entry = self.getDwordAtRva(iatRva).value\n\n                    iid[i].iat.append(iatEntry)\n             \n            iid[i].metaData.moduleName.value = self.readStringAtRva(iid[i].name.value).value\n            iid[i].metaData.numberOfImports.value = len(iid[i].iat)\n        return iid"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nparses the. NET Directory and returns a new object containing the properties of the NET Directory and the attributes of the NET Directory.", "response": "def _parseNetDirectory(self, rva, size, magic = consts.PE32):\n        \"\"\"\n        Parses the NET directory.\n        @see: U{http://www.ntcore.com/files/dotnetformat.htm}\n        \n        @type rva: int \n        @param rva: The RVA where the NET directory starts.\n        \n        @type size: int\n        @param size: The size of the NET directory.\n        \n        @type magic: int\n        @param magic: (Optional) The type of PE. This value could be L{consts.PE32} or L{consts.PE64}.\n        \n        @rtype: L{NETDirectory}\n        @return: A new L{NETDirectory} object.\n        \"\"\"        \n        if not rva or not size:\n            return None\n\n        # create a NETDirectory class to hold the data\n        netDirectoryClass = directories.NETDirectory()\n\n        # parse the .NET Directory\n        netDir = directories.NetDirectory.parse(utils.ReadData(self.getDataAtRva(rva,  size)))\n\n        netDirectoryClass.directory = netDir\n\n        # get the MetaData RVA and Size\n        mdhRva = netDir.metaData.rva.value\n        mdhSize = netDir.metaData.size.value\n\n        # read all the MetaData\n        rd = utils.ReadData(self.getDataAtRva(mdhRva, mdhSize))\n\n        # parse the MetaData headers\n        netDirectoryClass.netMetaDataHeader = directories.NetMetaDataHeader.parse(rd)\n\n        # parse the NET metadata streams\n        numberOfStreams = netDirectoryClass.netMetaDataHeader.numberOfStreams.value\n        netDirectoryClass.netMetaDataStreams = directories.NetMetaDataStreams.parse(rd, numberOfStreams)\n\n        for i in range(numberOfStreams):\n            stream = netDirectoryClass.netMetaDataStreams[i]\n            name = stream.name.value\n            rd.setOffset(stream.offset.value)\n            rd2 = utils.ReadData(rd.read(stream.size.value))\n            stream.info = []\n            if name == \"#~\" or i == 0:\n                stream.info = rd2\n            elif name == \"#Strings\" or i == 1:\n                while len(rd2) > 0:\n                    offset = rd2.tell()\n                    stream.info.append({ offset: rd2.readDotNetString() })\n            elif name == \"#US\" or i == 2:\n                while len(rd2) > 0:\n                    offset = rd2.tell()\n                    stream.info.append({ offset: rd2.readDotNetUnicodeString() })\n            elif name == \"#GUID\" or i == 3:\n                while len(rd2) > 0:\n                    offset = rd2.tell()\n                    stream.info.append({ offset: rd2.readDotNetGuid() })\n            elif name == \"#Blob\" or i == 4:\n                while len(rd2) > 0:\n                    offset = rd2.tell()\n                    stream.info.append({ offset: rd2.readDotNetBlob() })\n\n        for i in range(numberOfStreams):\n            stream = netDirectoryClass.netMetaDataStreams[i]\n            name = stream.name.value\n            if name == \"#~\" or i == 0:\n                stream.info = directories.NetMetaDataTables.parse(stream.info, netDirectoryClass.netMetaDataStreams)\n\n        # parse .NET resources\n        # get the Resources RVA and Size\n        resRva = netDir.resources.rva.value\n        resSize = netDir.resources.size.value\n\n        # read all the MetaData\n        rd = utils.ReadData(self.getDataAtRva(resRva, resSize))\n\n        resources = []\n\n        for i in netDirectoryClass.netMetaDataStreams[0].info.tables[\"ManifestResource\"]:\n            offset = i[\"offset\"]\n            rd.setOffset(offset)\n            size = rd.readDword()\n            data = rd.read(size)\n            if data[:4] == \"\\xce\\xca\\xef\\xbe\":\n                data = directories.NetResources.parse(utils.ReadData(data))\n            resources.append({ \"name\": i[\"name\"], \"offset\": offset + 4, \"size\": size, \"data\": data })\n\n        netDirectoryClass.directory.resources.info = resources\n\n        return netDirectoryClass"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nparses the contents of a DOS header and returns a new object.", "response": "def parse(readDataInstance):\n        \"\"\"\n        Returns a new L{DosHeader} object.\n        \n        @type readDataInstance: L{ReadData}\n        @param readDataInstance: A L{ReadData} object with data to be parsed as a L{DosHeader} object.\n        \n        @rtype: L{DosHeader}\n        @return: A new L{DosHeader} object.\n        \"\"\"\n        dosHdr = DosHeader()\n\n        dosHdr.e_magic.value  = readDataInstance.readWord()\n        dosHdr.e_cblp.value  = readDataInstance.readWord()\n        dosHdr.e_cp.value  = readDataInstance.readWord()\n        dosHdr.e_crlc.value  = readDataInstance.readWord()\n        dosHdr.e_cparhdr.value  = readDataInstance.readWord()\n        dosHdr.e_minalloc.value  = readDataInstance.readWord()\n        dosHdr.e_maxalloc.value  = readDataInstance.readWord()\n        dosHdr.e_ss.value  = readDataInstance.readWord()\n        dosHdr.e_sp.value  = readDataInstance.readWord()\n        dosHdr.e_csum.value  = readDataInstance.readWord()\n        dosHdr.e_ip.value  = readDataInstance.readWord()\n        dosHdr.e_cs.value  = readDataInstance.readWord()\n        dosHdr.e_lfarlc.value  = readDataInstance.readWord()\n        dosHdr.e_ovno.value  = readDataInstance.readWord()\n        \n        dosHdr.e_res = datatypes.Array(datatypes.TYPE_WORD)\n        for i in range(4):\n            dosHdr.e_res.append(datatypes.WORD(readDataInstance.readWord()))\n            \n        dosHdr.e_oemid.value  = readDataInstance.readWord()\n        dosHdr.e_oeminfo.value  = readDataInstance.readWord()\n\n        dosHdr.e_res2 = datatypes.Array(datatypes.TYPE_WORD)\n        for i in range (10):\n            dosHdr.e_res2.append(datatypes.WORD(readDataInstance.readWord()))\n        \n        dosHdr.e_lfanew.value = readDataInstance.readDword()\n        return dosHdr"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nparse the contents of the nt - headers object.", "response": "def parse(readDataInstance):\n        \"\"\"\n        Returns a new L{NtHeaders} object.\n        \n        @type readDataInstance: L{ReadData}\n        @param readDataInstance: A L{ReadData} object with data to be parsed as a L{NtHeaders} object.\n        \n        @rtype: L{NtHeaders}\n        @return: A new L{NtHeaders} object.\n        \"\"\"\n        nt = NtHeaders()\n        nt.signature.value = readDataInstance.readDword()\n        nt.fileHeader = FileHeader.parse(readDataInstance)\n        nt.optionalHeader = OptionalHeader.parse(readDataInstance)\n        return nt"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef parse(readDataInstance):\n        fh = FileHeader()\n        fh.machine.value  = readDataInstance.readWord()\n        fh.numberOfSections.value  = readDataInstance.readWord()\n        fh.timeDateStamp.value  = readDataInstance.readDword()\n        fh.pointerToSymbolTable.value  = readDataInstance.readDword()\n        fh.numberOfSymbols.value  = readDataInstance.readDword()\n        fh.sizeOfOptionalHeader.value  = readDataInstance.readWord()\n        fh.characteristics.value = readDataInstance.readWord()\n        return fh", "response": "Parses the contents of the specified file header and returns a new object with the contents."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nparsing the contents of readDataInstance into a new object containing the contents of the containing entry point.", "response": "def parse(readDataInstance):\n        \"\"\"\n        Returns a new L{OptionalHeader} object.\n        \n        @type readDataInstance: L{ReadData}\n        @param readDataInstance: A L{ReadData} object with data to be parsed as a L{OptionalHeader} object.\n        \n        @rtype: L{OptionalHeader}\n        @return: A new L{OptionalHeader} object.\n        \"\"\"\n        oh = OptionalHeader()\n\n        oh.magic.value  = readDataInstance.readWord()\n        oh.majorLinkerVersion.value  = readDataInstance.readByte()\n        oh.minorLinkerVersion.value  = readDataInstance.readByte()\n        oh.sizeOfCode.value  = readDataInstance.readDword()\n        oh.sizeOfInitializedData.value  = readDataInstance.readDword()\n        oh.sizeOfUninitializedData.value  = readDataInstance.readDword()\n        oh.addressOfEntryPoint.value  = readDataInstance.readDword()\n        oh.baseOfCode.value  = readDataInstance.readDword()\n        oh.baseOfData.value  = readDataInstance.readDword()\n        oh.imageBase.value  = readDataInstance.readDword()\n        oh.sectionAlignment.value  = readDataInstance.readDword()\n        oh.fileAlignment.value  = readDataInstance.readDword()\n        oh.majorOperatingSystemVersion.value  = readDataInstance.readWord()\n        oh.minorOperatingSystemVersion.value  = readDataInstance.readWord()\n        oh.majorImageVersion.value  = readDataInstance.readWord()\n        oh.minorImageVersion.value  = readDataInstance.readWord()\n        oh.majorSubsystemVersion.value  = readDataInstance.readWord()\n        oh.minorSubsystemVersion.value  = readDataInstance.readWord()\n        oh.win32VersionValue.value  = readDataInstance.readDword()\n        oh.sizeOfImage.value  = readDataInstance.readDword()\n        oh.sizeOfHeaders.value  = readDataInstance.readDword()\n        oh.checksum.value  = readDataInstance.readDword()\n        oh.subsystem.value  = readDataInstance.readWord()\n        oh.dllCharacteristics.value  = readDataInstance.readWord()\n        oh.sizeOfStackReserve.value  = readDataInstance.readDword()\n        oh.sizeOfStackCommit.value  = readDataInstance.readDword()\n        oh.sizeOfHeapReserve.value  = readDataInstance.readDword()\n        oh.sizeOfHeapCommit.value  = readDataInstance.readDword()\n        oh.loaderFlags.value  = readDataInstance.readDword()\n        oh.numberOfRvaAndSizes.value  = readDataInstance.readDword()\n        \n        dirs = readDataInstance.read(consts.IMAGE_NUMBEROF_DIRECTORY_ENTRIES * 8)\n\n        oh.dataDirectory = datadirs.DataDirectory.parse(utils.ReadData(dirs))\n\n        return oh"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef parse(readDataInstance):\n        sh = SectionHeader()\n        sh.name.value = readDataInstance.read(8)\n        sh.misc.value  = readDataInstance.readDword()\n        sh.virtualAddress.value  = readDataInstance.readDword()\n        sh.sizeOfRawData.value  = readDataInstance.readDword()\n        sh.pointerToRawData.value  = readDataInstance.readDword()\n        sh.pointerToRelocations.value  = readDataInstance.readDword()\n        sh.pointerToLineNumbers.value  = readDataInstance.readDword()\n        sh.numberOfRelocations.value  = readDataInstance.readWord()\n        sh.numberOfLinesNumbers.value  = readDataInstance.readWord()\n        sh.characteristics.value  = readDataInstance.readDword()\n        return sh", "response": "Parses the contents of the readDataInstance into a new SectionHeader object."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef parse(readDataInstance,  numberOfSectionHeaders):\n        sHdrs = SectionHeaders(numberOfSectionHeaders = 0)\n        \n        for i in range(numberOfSectionHeaders):\n            sh = SectionHeader()\n            \n            sh.name.value = readDataInstance.read(8)\n            sh.misc.value = readDataInstance.readDword()\n            sh.virtualAddress.value = readDataInstance.readDword()\n            sh.sizeOfRawData.value = readDataInstance.readDword()\n            sh.pointerToRawData.value = readDataInstance.readDword()\n            sh.pointerToRelocations.value = readDataInstance.readDword()\n            sh.pointerToLineNumbers.value = readDataInstance.readDword()\n            sh.numberOfRelocations.value = readDataInstance.readWord()\n            sh.numberOfLinesNumbers.value = readDataInstance.readWord()\n            sh.characteristics.value = readDataInstance.readDword()\n        \n            sHdrs.append(sh)\n        \n        return sHdrs", "response": "Parses the contents of the specified number of section headers."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef parse(readDataInstance,  sectionHeadersInstance):\n        sData = Sections()\n        \n        for sectionHdr in sectionHeadersInstance:\n            \n            if sectionHdr.sizeOfRawData.value > len(readDataInstance.data):\n                print \"Warning: SizeOfRawData is larger than file.\"\n            \n            if sectionHdr.pointerToRawData.value > len(readDataInstance.data):\n                print \"Warning: PointerToRawData points beyond the end of the file.\"\n            \n            if sectionHdr.misc.value > 0x10000000:\n                print \"Warning: VirtualSize is extremely large > 256MiB.\"\n            \n            if sectionHdr.virtualAddress.value > 0x10000000:\n                print \"Warning: VirtualAddress is beyond 0x10000000\"\n            \n            # skip sections with pointerToRawData == 0. According to PECOFF, it contains uninitialized data\n            if sectionHdr.pointerToRawData.value:\n                sData.append(readDataInstance.read(sectionHdr.sizeOfRawData.value))\n        \n        return sData", "response": "Parses the data from the PECOFF file and returns a new object with the parsed data."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_addresses_on_both_chains(wallet_obj, used=None, zero_balance=None):\n    '''\n    Get addresses across both subchains based on the filter criteria passed in\n\n    Returns a list of dicts of the following form:\n        [\n            {'address': '1abc123...', 'path': 'm/0/9', 'pubkeyhex': '0123456...'},\n            ...,\n        ]\n\n    Dicts may also contain WIF and privkeyhex if wallet_obj has private key\n    '''\n    mpub = wallet_obj.serialize_b58(private=False)\n\n    wallet_name = get_blockcypher_walletname_from_mpub(\n            mpub=mpub,\n            subchain_indices=[0, 1],\n            )\n\n    wallet_addresses = get_wallet_addresses(\n            wallet_name=wallet_name,\n            api_key=BLOCKCYPHER_API_KEY,\n            is_hd_wallet=True,\n            used=used,\n            zero_balance=zero_balance,\n            coin_symbol=coin_symbol_from_mkey(mpub),\n            )\n    verbose_print('wallet_addresses:')\n    verbose_print(wallet_addresses)\n\n    if wallet_obj.private_key:\n        master_key = wallet_obj.serialize_b58(private=True)\n    else:\n        master_key = mpub\n\n    chains_address_paths_cleaned = []\n    for chain in wallet_addresses['chains']:\n        if chain['chain_addresses']:\n            chain_address_paths = verify_and_fill_address_paths_from_bip32key(\n                    address_paths=chain['chain_addresses'],\n                    master_key=master_key,\n                    network=guess_network_from_mkey(mpub),\n                    )\n            chain_address_paths_cleaned = {\n                    'index': chain['index'],\n                    'chain_addresses': chain_address_paths,\n                    }\n            chains_address_paths_cleaned.append(chain_address_paths_cleaned)\n\n    return chains_address_paths_cleaned", "response": "Get addresses across both subchains based on the filter criteria passed in\n    Returns a list of dicts of the same format as wallet_obj."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef register_unused_addresses(wallet_obj, subchain_index, num_addrs=1):\n    '''\n    Hit /derive to register new unused_addresses on a subchain_index and verify them client-side\n\n    Returns a list of dicts of the following form:\n        [\n            {'address': '1abc123...', 'path': 'm/0/9', 'public': '0123456...'},\n            ...,\n        ]\n    '''\n\n    verbose_print('register_unused_addresses called on subchain %s for %s addrs' % (\n        subchain_index,\n        num_addrs,\n        ))\n\n    assert type(subchain_index) is int, subchain_index\n    assert type(num_addrs) is int, num_addrs\n    assert num_addrs > 0\n\n    mpub = wallet_obj.serialize_b58(private=False)\n    coin_symbol = coin_symbol_from_mkey(mpub)\n    wallet_name = get_blockcypher_walletname_from_mpub(\n            mpub=mpub,\n            subchain_indices=[0, 1],\n            )\n    network = guess_network_from_mkey(mpub)\n\n    # register new address(es)\n    derivation_response = derive_hd_address(\n            api_key=BLOCKCYPHER_API_KEY,\n            wallet_name=wallet_name,\n            num_addresses=num_addrs,\n            subchain_index=subchain_index,\n            coin_symbol=coin_symbol,\n            )\n\n    verbose_print('derivation_response:')\n    verbose_print(derivation_response)\n\n    address_paths = derivation_response['chains'][0]['chain_addresses']\n\n    # verify new addresses client-side\n    full_address_paths = verify_and_fill_address_paths_from_bip32key(\n            address_paths=address_paths,\n            master_key=mpub,\n            network=network,\n            )\n\n    return full_address_paths", "response": "This function is used to register new unused addresses on a subchain."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef dump_all_keys_or_addrs(wallet_obj):\n    '''\n    Offline-enabled mechanism to dump addresses\n    '''\n\n    print_traversal_warning()\n\n    puts('\\nDo you understand this warning?')\n    if not confirm(user_prompt=DEFAULT_PROMPT, default=False):\n        puts(colored.red('Dump Cancelled!'))\n        return\n\n    mpub = wallet_obj.serialize_b58(private=False)\n\n    if wallet_obj.private_key:\n        desc_str = 'private keys'\n    else:\n        desc_str = 'addresses'\n        puts('Displaying Public Addresses Only')\n        puts('For Private Keys, please open bcwallet with your Master Private Key:\\n')\n        priv_to_display = '%s123...' % first4mprv_from_mpub(mpub=mpub)\n        print_bcwallet_basic_priv_opening(priv_to_display=priv_to_display)\n\n    puts('How many %s (on each chain) do you want to dump?' % desc_str)\n    puts('Enter \"b\" to go back.\\n')\n\n    num_keys = get_int(\n            user_prompt=DEFAULT_PROMPT,\n            max_int=10**5,\n            default_input='5',\n            show_default=True,\n            quit_ok=True,\n            )\n\n    if num_keys is False:\n        return\n\n    if wallet_obj.private_key:\n        print_childprivkey_warning()\n\n    puts('-' * 70)\n    for chain_int in (0, 1):\n        for current in range(0, num_keys):\n            path = \"m/%d/%d\" % (chain_int, current)\n            if current == 0:\n                if chain_int == 0:\n                    print_external_chain()\n                    print_key_path_header()\n                elif chain_int == 1:\n                    print_internal_chain()\n                    print_key_path_header()\n            child_wallet = wallet_obj.get_child_for_path(path)\n            if wallet_obj.private_key:\n                wif_to_use = child_wallet.export_to_wif()\n            else:\n                wif_to_use = None\n            print_path_info(\n                    address=child_wallet.to_address(),\n                    path=path,\n                    wif=wif_to_use,\n                    coin_symbol=coin_symbol_from_mkey(mpub),\n                    )\n\n    puts(colored.blue('\\nYou can compare this output to bip32.org'))", "response": "A simple mechanism to dump all keys or addresses"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef dump_selected_keys_or_addrs(wallet_obj, used=None, zero_balance=None):\n    '''\n    Works for both public key only or private key access\n    '''\n    if wallet_obj.private_key:\n        content_str = 'private keys'\n    else:\n        content_str = 'addresses'\n\n    if not USER_ONLINE:\n        puts(colored.red('\\nInternet connection required, would you like to dump *all* %s instead?' % (\n            content_str,\n            content_str,\n            )))\n        if confirm(user_prompt=DEFAULT_PROMPT, default=True):\n            dump_all_keys_or_addrs(wallet_obj=wallet_obj)\n        else:\n            return\n\n    mpub = wallet_obj.serialize_b58(private=False)\n\n    if wallet_obj.private_key is None:\n        puts('Displaying Public Addresses Only')\n        puts('For Private Keys, please open bcwallet with your Master Private Key:\\n')\n        priv_to_display = '%s123...' % first4mprv_from_mpub(mpub=mpub)\n\n        print_bcwallet_basic_priv_opening(priv_to_display=priv_to_display)\n\n    chain_address_objs = get_addresses_on_both_chains(\n            wallet_obj=wallet_obj,\n            used=used,\n            zero_balance=zero_balance,\n            )\n\n    if wallet_obj.private_key and chain_address_objs:\n        print_childprivkey_warning()\n\n    addr_cnt = 0\n    for chain_address_obj in chain_address_objs:\n        if chain_address_obj['index'] == 0:\n            print_external_chain()\n        elif chain_address_obj['index'] == 1:\n            print_internal_chain()\n        print_key_path_header()\n        for address_obj in chain_address_obj['chain_addresses']:\n\n            print_path_info(\n                    address=address_obj['pub_address'],\n                    wif=address_obj.get('wif'),\n                    path=address_obj['path'],\n                    coin_symbol=coin_symbol_from_mkey(mpub),\n                    )\n\n            addr_cnt += 1\n\n    if addr_cnt:\n        puts(colored.blue('\\nYou can compare this output to bip32.org'))\n    else:\n        puts('No matching %s in this subset. Would you like to dump *all* %s instead?' % (\n            content_str,\n            content_str,\n            ))\n        if confirm(user_prompt=DEFAULT_PROMPT, default=True):\n            dump_all_keys_or_addrs(wallet_obj=wallet_obj)", "response": "Dumps all keys and addresses on both private keys and internal keys."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nhoming screen of the wallet.", "response": "def wallet_home(wallet_obj):\n    '''\n    Loaded on bootup (and stays in while loop until quitting)\n    '''\n    mpub = wallet_obj.serialize_b58(private=False)\n\n    if wallet_obj.private_key is None:\n        print_pubwallet_notice(mpub=mpub)\n    else:\n        print_bcwallet_basic_pub_opening(mpub=mpub)\n\n    coin_symbol = coin_symbol_from_mkey(mpub)\n    if USER_ONLINE:\n        wallet_name = get_blockcypher_walletname_from_mpub(\n                mpub=mpub,\n                subchain_indices=[0, 1],\n                )\n\n        # Instruct blockcypher to track the wallet by pubkey\n        create_hd_wallet(\n                wallet_name=wallet_name,\n                xpubkey=mpub,\n                api_key=BLOCKCYPHER_API_KEY,\n                coin_symbol=coin_symbol,\n                subchain_indices=[0, 1],  # for internal and change addresses\n                )\n\n        # Display balance info\n        display_balance_info(wallet_obj=wallet_obj)\n\n    # Go to home screen\n    while True:\n        puts('-' * 70 + '\\n')\n\n        if coin_symbol in ('bcy', 'btc-testnet'):\n            display_shortname = COIN_SYMBOL_MAPPINGS[coin_symbol]['display_shortname']\n            if coin_symbol == 'bcy':\n                faucet_url = 'https://accounts.blockcypher.com/blockcypher-faucet'\n            elif coin_symbol == 'btc-testnet':\n                faucet_url = 'https://accounts.blockcypher.com/testnet-faucet'\n            puts('Get free %s faucet coins:' % display_shortname)\n            puts(colored.blue(faucet_url))\n            puts()\n\n            if coin_symbol == 'btc-testnet':\n                puts('Please consider returning unused testnet coins to mwmabpJVisvti3WEP5vhFRtn3yqHRD9KNP so we can distribute them to others.\\n')\n\n        puts('What do you want to do?:')\n        if not USER_ONLINE:\n            puts(\"(since you are NOT connected to BlockCypher, many choices are disabled)\")\n        with indent(2):\n            puts(colored.cyan('1: Show balance and transactions'))\n            puts(colored.cyan('2: Show new receiving addresses'))\n            puts(colored.cyan('3: Send funds (more options here)'))\n\n        with indent(2):\n            if wallet_obj.private_key:\n                puts(colored.cyan('0: Dump private keys and addresses (advanced users only)'))\n            else:\n                puts(colored.cyan('0: Dump addresses (advanced users only)'))\n\n            puts(colored.cyan('\\nq: Quit bcwallet\\n'))\n\n        choice = choice_prompt(\n                user_prompt=DEFAULT_PROMPT,\n                acceptable_responses=range(0, 3+1),\n                quit_ok=True,\n                default_input='1',\n                )\n        verbose_print('Choice: %s' % choice)\n\n        if choice is False:\n            puts(colored.green('Thanks for using bcwallet!'))\n            print_keys_not_saved()\n            break\n        elif choice == '1':\n            display_recent_txs(wallet_obj=wallet_obj)\n        elif choice == '2':\n            display_new_receiving_addresses(wallet_obj=wallet_obj)\n        elif choice == '3':\n            send_chooser(wallet_obj=wallet_obj)\n        elif choice == '0':\n            dump_private_keys_or_addrs_chooser(wallet_obj=wallet_obj)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nsolve the DP GFL for a fixed value of lambda.", "response": "def solve(self, lam):\n        '''Solves the GFL for a fixed value of lambda.'''\n        if self.penalty == 'dp':\n            return self.solve_dp(lam)\n        if self.penalty == 'gfl':\n            return self.solve_gfl(lam)\n        if self.penalty == 'gamlasso':\n            return self.solve_gfl(lam)\n        raise Exception('Unknown penalty type: {0}'.format(self.penalty))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nsolve the Graph - fused double Pareto ( non - convex local optima only )", "response": "def solve_dp(self, lam):\n        '''Solves the Graph-fused double Pareto (non-convex, local optima only)'''\n        cur_converge = self.converge+1\n        step = 0\n        # Get an initial estimate using the GFL\n        self.solve_gfl(lam)\n        beta2 = np.copy(self.beta)\n        while cur_converge > self.converge and step < self.max_dp_steps:\n            # Weight each edge differently\n            u = lam / (1 + np.abs(self.beta[self.trails[::2]] - self.beta[self.trails[1::2]]))\n            # Swap the beta buffers\n            temp = self.beta\n            self.beta = beta2\n            beta2 = temp\n            # Solve the edge-weighted GFL problem, which updates beta\n            self.solve_gfl(u)\n            # Check for convergence\n            cur_converge = np.sqrt(((self.beta - beta2)**2).sum())\n            step += 1\n        self.steps.append(step)\n        return self.beta"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef solve_gamlasso(self, lam):\n        '''Solves the Graph-fused gamma lasso via POSE (Taddy, 2013)'''\n        weights = lam / (1 + self.gamma * np.abs(self.beta[self.trails[::2]] - self.beta[self.trails[1::2]]))\n        s = self.solve_gfl(u)\n        self.steps.append(s)\n        return self.beta", "response": "Solves the Graph - fused gamma lasso via POSE ( Taddy 2013 )"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef solution_path(self, min_lambda, max_lambda, lambda_bins, verbose=0):\n        '''Follows the solution path to find the best lambda value.'''\n        lambda_grid = np.exp(np.linspace(np.log(max_lambda), np.log(min_lambda), lambda_bins))\n        aic_trace = np.zeros(lambda_grid.shape) # The AIC score for each lambda value\n        aicc_trace = np.zeros(lambda_grid.shape) # The AICc score for each lambda value (correcting for finite sample size)\n        bic_trace = np.zeros(lambda_grid.shape) # The BIC score for each lambda value\n        dof_trace = np.zeros(lambda_grid.shape) # The degrees of freedom of each final solution\n        log_likelihood_trace = np.zeros(lambda_grid.shape)\n        beta_trace = []\n        best_idx = None\n        best_plateaus = None\n\n        # Solve the series of lambda values with warm starts at each point\n        for i, lam in enumerate(lambda_grid):\n            if verbose:\n                print('#{0} Lambda = {1}'.format(i, lam))\n\n            # Fit to the final values\n            beta = self.solve(lam)\n\n            if verbose:\n                print('Calculating degrees of freedom')\n\n            # Count the number of free parameters in the grid (dof)\n            plateaus = calc_plateaus(beta, self.edges)\n            dof_trace[i] = len(plateaus)\n\n            if verbose:\n                print('Calculating AIC')\n\n            # Get the negative log-likelihood\n            log_likelihood_trace[i] = self.log_likelihood(beta)\n\n            # Calculate AIC = 2k - 2ln(L)\n            aic_trace[i] = 2. * dof_trace[i] - 2. * log_likelihood_trace[i]\n            \n            # Calculate AICc = AIC + 2k * (k+1) / (n - k - 1)\n            aicc_trace[i] = aic_trace[i] + 2 * dof_trace[i] * (dof_trace[i]+1) / (len(beta) - dof_trace[i] - 1.)\n\n            # Calculate BIC = -2ln(L) + k * (ln(n) - ln(2pi))\n            bic_trace[i] = -2 * log_likelihood_trace[i] + dof_trace[i] * (np.log(len(beta)) - np.log(2 * np.pi))\n\n            # Track the best model thus far\n            if best_idx is None or bic_trace[i] < bic_trace[best_idx]:\n                best_idx = i\n                best_plateaus = plateaus\n\n            # Save the trace of all the resulting parameters\n            beta_trace.append(np.array(beta))\n            \n            if verbose:\n                print('DoF: {0} AIC: {1} AICc: {2} BIC: {3}'.format(dof_trace[i], aic_trace[i], aicc_trace[i], bic_trace[i]))\n\n        if verbose:\n            print('Best setting (by BIC): lambda={0} [DoF: {1}, AIC: {2}, AICc: {3} BIC: {4}]'.format(lambda_grid[best_idx], dof_trace[best_idx], aic_trace[best_idx], aicc_trace[best_idx], bic_trace[best_idx]))\n\n        return {'aic': aic_trace,\n                'aicc': aicc_trace,\n                'bic': bic_trace,\n                'dof': dof_trace,\n                'loglikelihood': log_likelihood_trace,\n                'beta': np.array(beta_trace),\n                'lambda': lambda_grid,\n                'best_idx': best_idx,\n                'best': beta_trace[best_idx],\n                'plateaus': best_plateaus}", "response": "Follows the solution path to find the best lambda value."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngenerates sequences from a CDR3 cell.", "response": "def main():\n    \"\"\" Generate sequences.\"\"\"\n\n    parser = OptionParser(conflict_handler=\"resolve\")\n\n    parser.add_option('--humanTRA', '--human_T_alpha', action='store_true', dest='humanTRA', default=False, help='use default human TRA model (T cell alpha chain)')\n    parser.add_option('--humanTRB', '--human_T_beta', action='store_true', dest='humanTRB', default=False, help='use default human TRB model (T cell beta chain)')\n    parser.add_option('--mouseTRB', '--mouse_T_beta', action='store_true', dest='mouseTRB', default=False, help='use default mouse TRB model (T cell beta chain)')\n    parser.add_option('--humanIGH', '--human_B_heavy', action='store_true', dest='humanIGH', default=False, help='use default human IGH model (B cell heavy chain)')\n    parser.add_option('--VDJ_model_folder', dest='vdj_model_folder', metavar='PATH/TO/FOLDER/', help='specify PATH/TO/FOLDER/ for a custom VDJ generative model')\n    parser.add_option('--VJ_model_folder', dest='vj_model_folder', metavar='PATH/TO/FOLDER/', help='specify PATH/TO/FOLDER/ for a custom VJ generative model')\n    parser.add_option('-o', '--outfile', dest = 'outfile_name', metavar='PATH/TO/FILE', help='write CDR3 sequences to PATH/TO/FILE')\n\n    parser.add_option('-n', '--num_seqs', type='float', metavar='N', default = 0, dest='num_seqs_to_generate', help='specify the number of sequences to generate.')\n    parser.add_option('--seed', type='int', dest='seed', help='set seed for pseudorandom number generator. Default is to not set a seed.')\n    parser.add_option('--seqs_per_time_update', type='float', default = 100000, dest='seqs_per_time_update', help='specify the number of sequences between time updates. Default is 1e5')\n    parser.add_option('--conserved_J_residues', type='string', default = 'FVW', dest='conserved_J_residues', help=\"specify conserved J residues. Default is 'FVW'.\")\n    parser.add_option('--time_updates_off', action='store_false', dest='time_updates', default=True, help='turn time updates off.')\n    parser.add_option('--seq_type', type='choice', default = 'all', dest='seq_type',  choices=['all', 'ntseq', 'nucleotide', 'aaseq', 'amino_acid'], help=\"declare sequence type for output sequences. Choices: 'all' [default], 'ntseq', 'nucleotide', 'aaseq', 'amino_acid'\")\n    parser.add_option('--record_genes_off', action='store_false', dest=\"record_genes\", default=True, help='turn off recording V and J gene info.')\n    parser.add_option('-d', '--delimiter', type='choice', dest='delimiter',  choices=['tab', 'space', ',', ';', ':'], help=\"declare delimiter choice. Default is tab for .tsv output files, comma for .csv files, and tab for all others. Choices: 'tab', 'space', ',', ';', ':'\")\n    parser.add_option('--raw_delimiter', type='str', dest='delimiter', help=\"declare delimiter choice as a raw string.\")\n\n\n    (options, args) = parser.parse_args()\n\n    main_folder = os.path.dirname(__file__)\n\n    default_models = {}\n    default_models['humanTRA'] = [os.path.join(main_folder, 'default_models', 'human_T_alpha'),  'VJ']\n    default_models['humanTRB'] = [os.path.join(main_folder, 'default_models', 'human_T_beta'), 'VDJ']\n    default_models['mouseTRB'] = [os.path.join(main_folder, 'default_models', 'mouse_T_beta'), 'VDJ']\n    default_models['humanIGH'] = [os.path.join(main_folder, 'default_models', 'human_B_heavy'), 'VDJ']\n\n    num_models_specified = sum([1 for x in default_models.keys() + ['vj_model_folder', 'vdj_model_folder'] if getattr(options, x)])\n\n    if num_models_specified == 1: #exactly one model specified\n        try:\n            d_model = [x for x in default_models.keys() if getattr(options, x)][0]\n            model_folder = default_models[d_model][0]\n            recomb_type = default_models[d_model][1]\n        except IndexError:\n            if options.vdj_model_folder: #custom VDJ model specified\n                model_folder = options.vdj_model_folder\n                recomb_type = 'VDJ'\n            elif options.vj_model_folder: #custom VJ model specified\n                model_folder = options.vj_model_folder\n                recomb_type = 'VJ'\n    elif num_models_specified == 0:\n        print 'Need to indicate generative model.'\n        print 'Exiting...'\n        return -1\n    elif num_models_specified > 1:\n        print 'Only specify one model'\n        print 'Exiting...'\n        return -1\n\n    #Check that all model and genomic files exist in the indicated model folder\n    if not os.path.isdir(model_folder):\n        print 'Check pathing... cannot find the model folder: ' + model_folder\n        print 'Exiting...'\n        return -1\n\n    params_file_name = os.path.join(model_folder,'model_params.txt')\n    marginals_file_name = os.path.join(model_folder,'model_marginals.txt')\n    V_anchor_pos_file = os.path.join(model_folder,'V_gene_CDR3_anchors.csv')\n    J_anchor_pos_file = os.path.join(model_folder,'J_gene_CDR3_anchors.csv')\n\n    for x in [params_file_name, marginals_file_name, V_anchor_pos_file, J_anchor_pos_file]:\n        if not os.path.isfile(x):\n            print 'Cannot find: ' + x\n            print 'Please check the files (and naming conventions) in the model folder ' + model_folder\n            print 'Exiting...'\n            return -1\n\n\n    if options.outfile_name is not None:\n        outfile_name = options.outfile_name\n        if os.path.isfile(outfile_name):\n            if not raw_input(outfile_name + ' already exists. Overwrite (y/n)? ').strip().lower() in ['y', 'yes']:\n                print 'Exiting...'\n                return -1\n\n    #Parse arguments\n\n    num_seqs_to_generate = int(options.num_seqs_to_generate)\n\n    if num_seqs_to_generate <= 0:\n        print 'Need to specify num_seqs (number of sequences to generate).'\n        print 'Exiting...'\n        return -1\n\n    #Parse default delimiter\n    delimiter = options.delimiter\n    if delimiter is None:\n        delimiter = '\\t'\n        if options.outfile_name is not None:\n            if outfile_name.endswith('.tsv'):\n                delimiter = '\\t'\n            elif outfile_name.endswith('.csv'):\n                delimiter = ','\n    else:\n        try:\n            delimiter = {'tab': '\\t', 'space': ' ', ',': ',', ';': ';', ':': ':'}[delimiter]\n        except KeyError:\n            pass #Other raw string.\n\n    #Optional flags\n    seq_type = {'all': 'all', 'ntseq': 'ntseq', 'nucleotide': 'ntseq', 'aaseq': 'aaseq', 'amino_acid': 'aaseq'}[options.seq_type]\n    record_genes = options.record_genes\n    seqs_per_time_update = int(options.seqs_per_time_update)\n    time_updates = options.time_updates\n    conserved_J_residues = options.conserved_J_residues\n\n    if options.seed is not None:\n        np.random.seed(options.seed)\n\n    #VDJ recomb case --- used for TCRB and IGH\n    if recomb_type == 'VDJ':\n        genomic_data = load_model.GenomicDataVDJ()\n        genomic_data.load_igor_genomic_data(params_file_name, V_anchor_pos_file, J_anchor_pos_file)\n        generative_model = load_model.GenerativeModelVDJ()\n        generative_model.load_and_process_igor_model(marginals_file_name)\n        seq_gen = sequence_generation.SequenceGenerationVDJ(generative_model, genomic_data)\n    #VJ recomb case --- used for TCRA and light chain\n    elif recomb_type == 'VJ':\n        genomic_data = load_model.GenomicDataVJ()\n        genomic_data.load_igor_genomic_data(params_file_name, V_anchor_pos_file, J_anchor_pos_file)\n        generative_model = load_model.GenerativeModelVJ()\n        generative_model.load_and_process_igor_model(marginals_file_name)\n        seq_gen = sequence_generation.SequenceGenerationVJ(generative_model, genomic_data)\n\n\n    V_gene_names = [V[0].split('*')[0] for V in genomic_data.genV]\n    J_gene_names = [J[0].split('*')[0] for J in genomic_data.genJ]\n\n    if options.outfile_name is not None:\n        outfile = open(outfile_name, 'w')\n\n        print 'Starting sequence generation... '\n        start_time = time.time()\n        for i in range(num_seqs_to_generate):\n            ntseq, aaseq, V_in, J_in = seq_gen.gen_rnd_prod_CDR3(conserved_J_residues)\n            if seq_type == 'all': #default, include both ntseq and aaseq\n                current_line_out = ntseq + delimiter + aaseq\n            elif seq_type == 'ntseq': #only record ntseq\n                current_line_out = ntseq\n            elif seq_type == 'aaseq': #only record aaseq\n                current_line_out = aaseq\n\n            if record_genes:\n                current_line_out += delimiter + V_gene_names[V_in] + delimiter + J_gene_names[J_in]\n            outfile.write(current_line_out + '\\n')\n\n            if (i+1)%seqs_per_time_update == 0 and time_updates:\n                c_time = time.time() - start_time\n                eta = ((num_seqs_to_generate - (i+1))/float(i+1))*c_time\n                if c_time > 86400: #more than a day\n                    c_time_str = '%d days, %d hours, %d minutes, and %.2f seconds.'%(int(c_time)/86400, (int(c_time)/3600)%24, (int(c_time)/60)%60, c_time%60)\n                elif c_time > 3600: #more than an hr\n                    c_time_str = '%d hours, %d minutes, and %.2f seconds.'%((int(c_time)/3600)%24, (int(c_time)/60)%60, c_time%60)\n                elif c_time > 60: #more than a min\n                    c_time_str = '%d minutes and %.2f seconds.'%((int(c_time)/60)%60, c_time%60)\n                else:\n                    c_time_str = '%.2f seconds.'%(c_time)\n\n                if eta > 86400: #more than a day\n                    eta_str = '%d days, %d hours, %d minutes, and %.2f seconds.'%(int(eta)/86400, (int(eta)/3600)%24, (int(eta)/60)%60, eta%60)\n                elif eta > 3600: #more than an hr\n                    eta_str = '%d hours, %d minutes, and %.2f seconds.'%((int(eta)/3600)%24, (int(eta)/60)%60, eta%60)\n                elif eta > 60: #more than a min\n                    eta_str = '%d minutes and %.2f seconds.'%((int(eta)/60)%60, eta%60)\n                else:\n                    eta_str = '%.2f seconds.'%(eta)\n\n                print '%d sequences generated in %s Estimated time remaining: %s'%(i+1, c_time_str, eta_str)\n\n        c_time = time.time() - start_time\n        if c_time > 86400: #more than a day\n            c_time_str = '%d days, %d hours, %d minutes, and %.2f seconds.'%(int(c_time)/86400, (int(c_time)/3600)%24, (int(c_time)/60)%60, c_time%60)\n        elif c_time > 3600: #more than an hr\n            c_time_str = '%d hours, %d minutes, and %.2f seconds.'%((int(c_time)/3600)%24, (int(c_time)/60)%60, c_time%60)\n        elif c_time > 60: #more than a min\n            c_time_str = '%d minutes and %.2f seconds.'%((int(c_time)/60)%60, c_time%60)\n        else:\n            c_time_str = '%.2f seconds.'%(c_time)\n        print 'Completed generating all %d sequences in %s'%(num_seqs_to_generate, c_time_str)\n        outfile.close()\n\n    else: #print to stdout\n        for i in range(num_seqs_to_generate):\n            ntseq, aaseq, V_in, J_in = seq_gen.gen_rnd_prod_CDR3(conserved_J_residues)\n            if seq_type == 'all': #default, include both ntseq and aaseq\n                current_line_out = ntseq + delimiter + aaseq\n            elif seq_type == 'ntseq': #only record ntseq\n                current_line_out = ntseq\n            elif seq_type == 'aaseq': #only record aaseq\n                current_line_out = aaseq\n\n            if record_genes:\n                current_line_out += delimiter + V_gene_names[V_in] + delimiter + J_gene_names[J_in]\n            print current_line_out"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nsend merge commands to Netmiko.", "response": "def _send_merge_commands(self, config, file_config):\n        \"\"\"\n        Netmiko is being used to push set commands.\n        \"\"\"\n        if self.loaded is False:\n            if self._save_backup() is False:\n                raise MergeConfigException('Error while storing backup '\n                                           'config.')\n        if self.ssh_connection is False:\n            self._open_ssh()\n\n        if file_config:\n            if isinstance(config, str):\n                config = config.splitlines()\n        else:\n            if isinstance(config, str):\n                config = str(config).split()\n\n        self.ssh_device.send_config_set(config)\n        self.loaded = True\n        self.merge_config = True"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the config diffs from Netmiko", "response": "def compare_config(self):\n        \"\"\"\n        Netmiko is being used to obtain config diffs because pan-python\n        doesn't support the needed command.\n        \"\"\"\n        if self.ssh_connection is False:\n            self._open_ssh()\n\n        self.ssh_device.exit_config_mode()\n        diff = self.ssh_device.send_command(\"show config diff\")\n        return diff.strip()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncommitting the configuration of the current state of the user.", "response": "def commit_config(self):\n        \"\"\"\n        Netmiko is being used to commit the configuration because it takes\n        a better care of results compared to pan-python.\n        \"\"\"\n        if self.loaded:\n            if self.ssh_connection is False:\n                self._open_ssh()\n            try:\n                self.ssh_device.commit()\n                time.sleep(3)\n                self.loaded = False\n                self.changed = True\n            except:   # noqa\n                if self.merge_config:\n                    raise MergeConfigException('Error while commiting config')\n                else:\n                    raise ReplaceConfigException('Error while commiting config')\n        else:\n            raise ReplaceConfigException('No config loaded.')"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef rollback(self):\n        if self.changed:\n            rollback_cmd = '<load><config><from>{0}</from></config></load>'.format(self.backup_file)\n            self.device.op(cmd=rollback_cmd)\n            time.sleep(5)\n\n            if self.ssh_connection is False:\n                self._open_ssh()\n            try:\n                self.ssh_device.commit()\n                self.loaded = False\n                self.changed = False\n                self.merge_config = False\n            except:    # noqa\n                ReplaceConfigException(\"Error while loading backup config\")", "response": "Rollback the backup configuration"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning LLDP neighbors details.", "response": "def get_lldp_neighbors(self):\n        \"\"\"Return LLDP neighbors details.\"\"\"\n\n        neighbors = {}\n\n        cmd = '<show><lldp><neighbors>all</neighbors></lldp></show>'\n        try:\n            self.device.op(cmd=cmd)\n            lldp_table_xml = xmltodict.parse(self.device.xml_root())\n            lldp_table_json = json.dumps(lldp_table_xml['response']['result']['entry'])\n            lldp_table = json.loads(lldp_table_json)\n        except AttributeError:\n            lldp_table = []\n\n        for lldp_item in lldp_table:\n\n            local_int = lldp_item['@name']\n\n            if local_int not in neighbors.keys():\n                neighbors[local_int] = []\n            try:\n                lldp_neighs = lldp_item.get('neighbors').get('entry')\n            except AttributeError:\n                lldp_neighs = ''\n            if isinstance(lldp_neighs, dict):\n                lldp_neighs = [lldp_neighs]\n\n            for neighbor in lldp_neighs:\n                n = {}\n                n['hostname'] = neighbor['system-name']\n                n['port'] = neighbor['port-id']\n                neighbors[local_int].append(n)\n        return neighbors"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_route_to(self, destination='', protocol=''):\n\n        # Note, it should be possible to query the FIB:\n        # \"<show><routing><fib></fib></routing></show>\"\n        # To add informations to this getter\n        routes = {}\n\n        if destination:\n            destination = \"<destination>{0}</destination>\".format(destination)\n        if protocol:\n            protocol = \"<type>{0}</type>\".format(protocol)\n\n        cmd = \"<show><routing><route>{0}{1}</route></routing></show>\".format(protocol, destination)\n        try:\n            self.device.op(cmd=cmd)\n            routes_table_xml = xmltodict.parse(self.device.xml_root())\n            routes_table_json = json.dumps(routes_table_xml['response']['result']['entry'])\n            routes_table = json.loads(routes_table_json)\n        except (AttributeError, KeyError):\n            routes_table = []\n\n        if isinstance(routes_table, dict):\n            routes_table = [routes_table]\n\n        for route in routes_table:\n            d = {\n                'current_active': False,\n                'last_active': False,\n                'age': -1,\n                'next_hop': u'',\n                'protocol': u'',\n                'outgoing_interface': u'',\n                'preference': -1,\n                'inactive_reason': u'',\n                'routing_table': u'default',\n                'selected_next_hop': False,\n                'protocol_attributes': {}\n            }\n            destination = route['destination']\n            flags = route['flags']\n\n            if 'A' in flags:\n                d['current_active'] = True\n            else:\n                d['current_active'] = False\n            if 'C' in flags:\n                d['protocol'] = \"connect\"\n            if 'S' in flags:\n                d['protocol'] = \"static\"\n            if 'R' in flags:\n                d['protocol'] = \"rip\"\n            if 'R' in flags:\n                d['protocol'] = \"rip\"\n            if 'O' in flags:\n                d['protocol'] = \"ospf\"\n            if 'B' in flags:\n                d['protocol'] = \"bgp\"\n            if 'H' in flags:\n                d['protocol'] = \"host\"\n            if route['age'] is not None:\n                d['age'] = int(route['age'])\n            if route['nexthop'] is not None:\n                d['next_hop'] = route['nexthop']\n            if route['interface'] is not None:\n                d['outgoing_interface'] = route['interface']\n            if route['metric'] is not None:\n                d['preference'] = int(route['metric'])\n            if route['virtual-router'] is not None:\n                d['routing_table'] = route['virtual-router']\n\n            if destination not in routes.keys():\n                routes[destination] = []\n            routes[destination].append(d)\n\n        return routes", "response": "Get route details to a specific destination learned from a certain protocol."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_interfaces_ip(self):\n        '''Return IP interface data.'''\n\n        def extract_ip_info(parsed_intf_dict):\n            '''\n            IPv4:\n              - Primary IP is in the '<ip>' tag. If no v4 is configured the return value is 'N/A'.\n              - Secondary IP's are in '<addr>'. If no secondaries, this field is not returned by\n                the xmltodict.parse() method.\n\n            IPv6:\n              - All addresses are returned in '<addr6>'. If no v6 configured, this is not returned\n                either by xmltodict.parse().\n\n            Example of XML response for an intf with multiple IPv4 and IPv6 addresses:\n\n            <response status=\"success\">\n              <result>\n                <ifnet>\n                  <entry>\n                    <name>ethernet1/5</name>\n                    <zone/>\n                    <fwd>N/A</fwd>\n                    <vsys>1</vsys>\n                    <dyn-addr/>\n                    <addr6>\n                      <member>fe80::d61d:71ff:fed8:fe14/64</member>\n                      <member>2001::1234/120</member>\n                    </addr6>\n                    <tag>0</tag>\n                    <ip>169.254.0.1/30</ip>\n                    <id>20</id>\n                    <addr>\n                      <member>1.1.1.1/28</member>\n                    </addr>\n                  </entry>\n                  {...}\n                </ifnet>\n                <hw>\n                  {...}\n                </hw>\n              </result>\n            </response>\n            '''\n            intf = parsed_intf_dict['name']\n            _ip_info = {intf: {}}\n\n            v4_ip = parsed_intf_dict.get('ip')\n            secondary_v4_ip = parsed_intf_dict.get('addr')\n            v6_ip = parsed_intf_dict.get('addr6')\n\n            if v4_ip != 'N/A':\n                address, pref = v4_ip.split('/')\n                _ip_info[intf].setdefault('ipv4', {})[address] = {'prefix_length': int(pref)}\n\n            if secondary_v4_ip is not None:\n                members = secondary_v4_ip['member']\n                if not isinstance(members, list):\n                    # If only 1 secondary IP is present, xmltodict converts field to a string, else\n                    # it converts it to a list of strings.\n                    members = [members]\n                for address in members:\n                    address, pref = address.split('/')\n                    _ip_info[intf].setdefault('ipv4', {})[address] = {'prefix_length': int(pref)}\n\n            if v6_ip is not None:\n                members = v6_ip['member']\n                if not isinstance(members, list):\n                    # Same \"1 vs many -> string vs list of strings\" comment.\n                    members = [members]\n                for address in members:\n                    address, pref = address.split('/')\n                    _ip_info[intf].setdefault('ipv6', {})[address] = {'prefix_length': int(pref)}\n\n            # Reset dictionary if no addresses were found.\n            if _ip_info == {intf: {}}:\n                _ip_info = {}\n\n            return _ip_info\n\n        ip_interfaces = {}\n        cmd = \"<show><interface>all</interface></show>\"\n\n        self.device.op(cmd=cmd)\n        interface_info_xml = xmltodict.parse(self.device.xml_root())\n        interface_info_json = json.dumps(\n            interface_info_xml['response']['result']['ifnet']['entry']\n        )\n        interface_info = json.loads(interface_info_json)\n\n        if isinstance(interface_info, dict):\n            # Same \"1 vs many -> dict vs list of dicts\" comment.\n            interface_info = [interface_info]\n\n        for interface_dict in interface_info:\n            ip_info = extract_ip_info(interface_dict)\n            if ip_info:\n                ip_interfaces.update(ip_info)\n\n        return ip_interfaces", "response": "Return IP interface data."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a new CSG that is refined by adding all vertices to each edge and adding middle points to each edge.", "response": "def refine(self):\n        \"\"\"\n        Return a refined CSG. To each polygon, a middle point is added to each edge and to the center \n        of the polygon\n        \"\"\"\n        newCSG = CSG()\n        for poly in self.polygons:\n\n            verts = poly.vertices\n            numVerts = len(verts)\n\n            if numVerts == 0:\n                continue\n\n            midPos = reduce(operator.add, [v.pos for v in verts]) / float(numVerts)\n            midNormal = None\n            if verts[0].normal is not None:\n                midNormal = poly.plane.normal\n            midVert = Vertex(midPos, midNormal)\n\n            newVerts = verts + \\\n                       [verts[i].interpolate(verts[(i + 1)%numVerts], 0.5) for i in range(numVerts)] + \\\n                       [midVert]\n\n            i = 0\n            vs = [newVerts[i], newVerts[i+numVerts], newVerts[2*numVerts], newVerts[2*numVerts-1]]\n            newPoly = Polygon(vs, poly.shared)\n            newPoly.shared = poly.shared\n            newPoly.plane = poly.plane\n            newCSG.polygons.append(newPoly)\n\n            for i in range(1, numVerts):\n                vs = [newVerts[i], newVerts[numVerts+i], newVerts[2*numVerts], newVerts[numVerts+i-1]]\n                newPoly = Polygon(vs, poly.shared)\n                newCSG.polygons.append(newPoly)\n                \n        return newCSG"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef translate(self, disp):\n        d = Vector(disp[0], disp[1], disp[2])\n        for poly in self.polygons:\n            for v in poly.vertices:\n                v.pos = v.pos.plus(d)", "response": "Translate the set of vertices in the hierarchy."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nrotates the object by the given angle in radians.", "response": "def rotate(self, axis, angleDeg):\n        \"\"\"\n        Rotate geometry.\n           axis: axis of rotation (array of floats)\n           angleDeg: rotation angle in degrees\n        \"\"\"\n        ax = Vector(axis[0], axis[1], axis[2]).unit()\n        cosAngle = math.cos(math.pi * angleDeg / 180.)\n        sinAngle = math.sin(math.pi * angleDeg / 180.)\n\n        def newVector(v):\n            vA = v.dot(ax)\n            vPerp = v.minus(ax.times(vA))\n            vPerpLen = vPerp.length()\n            if vPerpLen == 0:\n                # vector is parallel to axis, no need to rotate\n                return v\n            u1 = vPerp.unit()\n            u2 = u1.cross(ax)\n            vCosA = vPerpLen*cosAngle\n            vSinA = vPerpLen*sinAngle\n            return ax.times(vA).plus(u1.times(vCosA).plus(u2.times(vSinA)))\n\n        for poly in self.polygons:\n            for vert in poly.vertices:\n                vert.pos = newVector(vert.pos)\n                normal = vert.normal\n                if normal.length() > 0:\n                    vert.normal = newVector(vert.normal)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns list of vertices polygons and total number of vertices in the polygon connectivity list.", "response": "def toVerticesAndPolygons(self):\n        \"\"\"\n        Return list of vertices, polygons (cells), and the total\n        number of vertex indices in the polygon connectivity list\n        (count).\n        \"\"\"\n        offset = 1.234567890\n        verts = []\n        polys = []\n        vertexIndexMap = {}\n        count = 0\n        for poly in self.polygons:\n            verts = poly.vertices\n            cell = []\n            for v in poly.vertices:\n                p = v.pos\n                # use string key to remove degeneracy associated\n                # very close points. The format %.10e ensures that\n                # points differing in the 11 digits and higher are \n                # treated as the same. For instance 1.2e-10 and \n                # 1.3e-10 are essentially the same.\n                vKey = '%.10e,%.10e,%.10e' % (p[0] + offset, \n                                              p[1] + offset, \n                                              p[2] + offset)\n                if not vKey in vertexIndexMap:\n                    vertexIndexMap[vKey] = len(vertexIndexMap)\n                index = vertexIndexMap[vKey]\n                cell.append(index)\n                count += 1\n            polys.append(cell)\n        # sort by index\n        sortedVertexIndex = sorted(vertexIndexMap.items(),\n                                   key=operator.itemgetter(1))\n        verts = []\n        for v, i in sortedVertexIndex:\n            p = []\n            for c in v.split(','):\n                p.append(float(c) - offset)\n            verts.append(tuple(p))\n        return verts, polys, count"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nsave polygons in VTK file.", "response": "def saveVTK(self, filename):\n        \"\"\"\n        Save polygons in VTK file.\n        \"\"\"\n        with open(filename, 'w') as f:\n            f.write('# vtk DataFile Version 3.0\\n')\n            f.write('pycsg output\\n')\n            f.write('ASCII\\n')\n            f.write('DATASET POLYDATA\\n')\n        \n            verts, cells, count = self.toVerticesAndPolygons()\n\n            f.write('POINTS {0} float\\n'.format(len(verts)))\n            for v in verts:\n                f.write('{0} {1} {2}\\n'.format(v[0], v[1], v[2]))\n            numCells = len(cells)\n            f.write('POLYGONS {0} {1}\\n'.format(numCells, count + numCells))\n            for cell in cells:\n                f.write('{0} '.format(len(cell)))\n                for index in cell:\n                    f.write('{0} '.format(index))\n                f.write('\\n')"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a new CSG solid representing the union of two sets of space in either this solid or the other solid.", "response": "def union(self, csg):\n        \"\"\"\n        Return a new CSG solid representing space in either this solid or in the\n        solid `csg`. Neither this solid nor the solid `csg` are modified.::\n        \n            A.union(B)\n        \n            +-------+            +-------+\n            |       |            |       |\n            |   A   |            |       |\n            |    +--+----+   =   |       +----+\n            +----+--+    |       +----+       |\n                 |   B   |            |       |\n                 |       |            |       |\n                 +-------+            +-------+\n        \"\"\"\n        a = BSPNode(self.clone().polygons)\n        b = BSPNode(csg.clone().polygons)\n        a.clipTo(b)\n        b.clipTo(a)\n        b.invert()\n        b.clipTo(a)\n        b.invert()\n        a.build(b.allPolygons());\n        return CSG.fromPolygons(a.allPolygons())"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a new CSG solid with solid and empty space switched. This solid is not modified.", "response": "def inverse(self):\n        \"\"\"\n        Return a new CSG solid with solid and empty space switched. This solid is\n        not modified.\n        \"\"\"\n        csg = self.clone()\n        map(lambda p: p.flip(), csg.polygons)\n        return csg"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nconstructs a solid cuboid.", "response": "def cube(cls, center=[0,0,0], radius=[1,1,1]):\n        \"\"\"\n        Construct an axis-aligned solid cuboid. Optional parameters are `center` and\n        `radius`, which default to `[0, 0, 0]` and `[1, 1, 1]`. The radius can be\n        specified using a single number or a list of three numbers, one for each axis.\n        \n        Example code::\n        \n            cube = CSG.cube(\n              center=[0, 0, 0],\n              radius=1\n            )\n        \"\"\"\n        c = Vector(0, 0, 0)\n        r = [1, 1, 1]\n        if isinstance(center, list): c = Vector(center)\n        if isinstance(radius, list): r = radius\n        else: r = [radius, radius, radius]\n\n        polygons = list(map(\n            lambda v: Polygon( \n                list(map(lambda i: \n                    Vertex(\n                        Vector(\n                            c.x + r[0] * (2 * bool(i & 1) - 1),\n                            c.y + r[1] * (2 * bool(i & 2) - 1),\n                            c.z + r[2] * (2 * bool(i & 4) - 1)\n                        ), \n                        None\n                    ), v[0]))),\n                    [\n                        [[0, 4, 6, 2], [-1, 0, 0]],\n                        [[1, 3, 7, 5], [+1, 0, 0]],\n                        [[0, 1, 5, 4], [0, -1, 0]],\n                        [[2, 6, 7, 3], [0, +1, 0]],\n                        [[0, 2, 3, 1], [0, 0, -1]],\n                        [[4, 5, 7, 6], [0, 0, +1]]\n                    ]))\n        return CSG.fromPolygons(polygons)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef sphere(cls, **kwargs):\n        center = kwargs.get('center', [0.0, 0.0, 0.0])\n        if isinstance(center, float):\n            center = [center, center, center]\n        c = Vector(center)\n        r = kwargs.get('radius', 1.0)\n        if isinstance(r, list) and len(r) > 2:\n            r = r[0]\n        slices = kwargs.get('slices', 16)\n        stacks = kwargs.get('stacks', 8)\n        polygons = []\n        def appendVertex(vertices, theta, phi):\n            d = Vector(\n                math.cos(theta) * math.sin(phi),\n                math.cos(phi),\n                math.sin(theta) * math.sin(phi))\n            vertices.append(Vertex(c.plus(d.times(r)), d))\n            \n        dTheta = math.pi * 2.0 / float(slices)\n        dPhi = math.pi / float(stacks)\n\n        j0 = 0\n        j1 = j0 + 1\n        for i0 in range(0, slices):\n            i1 = i0 + 1\n            #  +--+\n            #  | /\n            #  |/\n            #  +\n            vertices = []\n            appendVertex(vertices, i0 * dTheta, j0 * dPhi)\n            appendVertex(vertices, i1 * dTheta, j1 * dPhi)\n            appendVertex(vertices, i0 * dTheta, j1 * dPhi)\n            polygons.append(Polygon(vertices))\n\n        j0 = stacks - 1\n        j1 = j0 + 1\n        for i0 in range(0, slices):\n            i1 = i0 + 1\n            #  +\n            #  |\\\n            #  | \\\n            #  +--+\n            vertices = []\n            appendVertex(vertices, i0 * dTheta, j0 * dPhi)\n            appendVertex(vertices, i1 * dTheta, j0 * dPhi)\n            appendVertex(vertices, i0 * dTheta, j1 * dPhi)\n            polygons.append(Polygon(vertices))\n            \n        for j0 in range(1, stacks - 1):\n            j1 = j0 + 0.5\n            j2 = j0 + 1\n            for i0 in range(0, slices):\n                i1 = i0 + 0.5\n                i2 = i0 + 1\n                #  +---+\n                #  |\\ /|\n                #  | x |\n                #  |/ \\|\n                #  +---+\n                verticesN = []\n                appendVertex(verticesN, i1 * dTheta, j1 * dPhi)\n                appendVertex(verticesN, i2 * dTheta, j2 * dPhi)\n                appendVertex(verticesN, i0 * dTheta, j2 * dPhi)\n                polygons.append(Polygon(verticesN))\n                verticesS = []\n                appendVertex(verticesS, i1 * dTheta, j1 * dPhi)\n                appendVertex(verticesS, i0 * dTheta, j0 * dPhi)\n                appendVertex(verticesS, i2 * dTheta, j0 * dPhi)\n                polygons.append(Polygon(verticesS))\n                verticesW = []\n                appendVertex(verticesW, i1 * dTheta, j1 * dPhi)\n                appendVertex(verticesW, i0 * dTheta, j2 * dPhi)\n                appendVertex(verticesW, i0 * dTheta, j0 * dPhi)\n                polygons.append(Polygon(verticesW))\n                verticesE = []\n                appendVertex(verticesE, i1 * dTheta, j1 * dPhi)\n                appendVertex(verticesE, i2 * dTheta, j0 * dPhi)\n                appendVertex(verticesE, i2 * dTheta, j2 * dPhi)\n                polygons.append(Polygon(verticesE))\n                \n        return CSG.fromPolygons(polygons)", "response": "Returns a new instance of the class containing all of the objects in the current sphere."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef cylinder(cls, **kwargs):\n        s = kwargs.get('start', Vector(0.0, -1.0, 0.0))\n        e = kwargs.get('end', Vector(0.0, 1.0, 0.0))\n        if isinstance(s, list):\n            s = Vector(*s)\n        if isinstance(e, list):\n            e = Vector(*e)\n        r = kwargs.get('radius', 1.0)\n        slices = kwargs.get('slices', 16)\n        ray = e.minus(s)\n\n        axisZ = ray.unit()\n        isY = (math.fabs(axisZ.y) > 0.5)\n        axisX = Vector(float(isY), float(not isY), 0).cross(axisZ).unit()\n        axisY = axisX.cross(axisZ).unit()\n        start = Vertex(s, axisZ.negated())\n        end = Vertex(e, axisZ.unit())\n        polygons = []\n        \n        def point(stack, angle, normalBlend):\n            out = axisX.times(math.cos(angle)).plus(\n                axisY.times(math.sin(angle)))\n            pos = s.plus(ray.times(stack)).plus(out.times(r))\n            normal = out.times(1.0 - math.fabs(normalBlend)).plus(\n                axisZ.times(normalBlend))\n            return Vertex(pos, normal)\n            \n        dt = math.pi * 2.0 / float(slices)\n        for i in range(0, slices):\n            t0 = i * dt\n            i1 = (i + 1) % slices\n            t1 = i1 * dt\n            polygons.append(Polygon([start.clone(), \n                                     point(0., t0, -1.), \n                                     point(0., t1, -1.)]))\n            polygons.append(Polygon([point(0., t1, 0.), \n                                     point(0., t0, 0.),\n                                     point(1., t0, 0.), \n                                     point(1., t1, 0.)]))\n            polygons.append(Polygon([end.clone(), \n                                     point(1., t1, 1.), \n                                     point(1., t0, 1.)]))\n        \n        return CSG.fromPolygons(polygons)", "response": "Returns a new instance of the class A cylinder is defined by the given parameters."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a new object that represents the cone at the specified start end radius and tapering of the cone at the specified taper angle.", "response": "def cone(cls, **kwargs):\n        \"\"\" Returns a cone.\n            \n            Kwargs:\n                start (list): Start of cone, default [0, -1, 0].\n                \n                end (list): End of cone, default [0, 1, 0].\n                \n                radius (float): Maximum radius of cone at start, default 1.0.\n                \n                slices (int): Number of slices, default 16.\n        \"\"\"\n        s = kwargs.get('start', Vector(0.0, -1.0, 0.0))\n        e = kwargs.get('end', Vector(0.0, 1.0, 0.0))\n        if isinstance(s, list):\n            s = Vector(*s)\n        if isinstance(e, list):\n            e = Vector(*e)\n        r = kwargs.get('radius', 1.0)\n        slices = kwargs.get('slices', 16)\n        ray = e.minus(s)\n        \n        axisZ = ray.unit()\n        isY = (math.fabs(axisZ.y) > 0.5)\n        axisX = Vector(float(isY), float(not isY), 0).cross(axisZ).unit()\n        axisY = axisX.cross(axisZ).unit()\n        startNormal = axisZ.negated()\n        start = Vertex(s, startNormal)\n        polygons = []\n        \n        taperAngle = math.atan2(r, ray.length())\n        sinTaperAngle = math.sin(taperAngle)\n        cosTaperAngle = math.cos(taperAngle)\n        def point(angle):\n            # radial direction pointing out\n            out = axisX.times(math.cos(angle)).plus(\n                axisY.times(math.sin(angle)))\n            pos = s.plus(out.times(r))\n            # normal taking into account the tapering of the cone\n            normal = out.times(cosTaperAngle).plus(axisZ.times(sinTaperAngle))\n            return pos, normal\n\n        dt = math.pi * 2.0 / float(slices)\n        for i in range(0, slices):\n            t0 = i * dt\n            i1 = (i + 1) % slices\n            t1 = i1 * dt\n            # coordinates and associated normal pointing outwards of the cone's\n            # side\n            p0, n0 = point(t0)\n            p1, n1 = point(t1)\n            # average normal for the tip\n            nAvg = n0.plus(n1).times(0.5)\n            # polygon on the low side (disk sector)\n            polyStart = Polygon([start.clone(), \n                                 Vertex(p0, startNormal), \n                                 Vertex(p1, startNormal)])\n            polygons.append(polyStart)\n            # polygon extending from the low side to the tip\n            polySide = Polygon([Vertex(p0, n0), Vertex(e, nAvg), Vertex(p1, n1)])\n            polygons.append(polySide)\n\n        return CSG.fromPolygons(polygons)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef load(filename, *, gzipped=None, byteorder='big'):\r\n    if gzipped is not None:\r\n        return File.load(filename, gzipped, byteorder)\r\n\r\n    # if we don't know we read the magic number\r\n    with open(filename, 'rb') as buff:\r\n        magic_number = buff.read(2)\r\n        buff.seek(0)\r\n\r\n        if magic_number == b'\\x1f\\x8b':\r\n            buff = gzip.GzipFile(fileobj=buff)\r\n\r\n        return File.from_buffer(buff, byteorder)", "response": "Load the nbt file at the specified location."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef from_buffer(cls, buff, byteorder='big'):\r\n        self = cls.parse(buff, byteorder)\r\n        self.filename = getattr(buff, 'name', self.filename)\r\n        self.gzipped = isinstance(buff, gzip.GzipFile)\r\n        self.byteorder = byteorder\r\n        return self", "response": "Load a nbt file from a file - like object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef load(cls, filename, gzipped, byteorder='big'):\r\n        open_file = gzip.open if gzipped else open\r\n        with open_file(filename, 'rb') as buff:\r\n            return cls.from_buffer(buff, byteorder)", "response": "Read and parse and return the file at the specified location."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nwrite the instance attributes to a file.", "response": "def save(self, filename=None, *, gzipped=None, byteorder=None):\r\n        \"\"\"Write the file at the specified location.\r\n\r\n        The `gzipped` keyword only argument indicates if the file should\r\n        be gzipped. The `byteorder` keyword only argument lets you\r\n        specify whether the file should be big-endian or little-endian.\r\n\r\n        If the method is called without any argument, it will default to\r\n        the instance attributes and use the file's `filename`,\r\n        `gzipped` and `byteorder` attributes. Calling the method without\r\n        a `filename` will raise a `ValueError` if the `filename` of the\r\n        file is `None`.\r\n        \"\"\"\r\n        if gzipped is None:\r\n            gzipped = self.gzipped\r\n        if filename is None:\r\n            filename = self.filename\r\n\r\n        if filename is None:\r\n            raise ValueError('No filename specified')\r\n\r\n        open_file = gzip.open if gzipped else open\r\n        with open_file(filename, 'wb') as buff:\r\n            self.write(buff, byteorder or self.byteorder)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nchanging method return value from raw API output to collection of models ridge", "response": "def return_collection(collection_type):\n    \"\"\"Change method return value from raw API output to collection of models\n    \"\"\"\n    def outer_func(func):\n        @functools.wraps(func)\n        def inner_func(self, *pargs, **kwargs):\n            result = func(self, *pargs, **kwargs)\n            return list(map(collection_type, result))\n        return inner_func\n    return outer_func"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nupdates related objects when the Stop is updated", "response": "def post_save_stop(sender, instance, **kwargs):\n    '''Update related objects when the Stop is updated'''\n    from multigtfs.models.trip import Trip\n    trip_ids = instance.stoptime_set.filter(\n        trip__shape=None).values_list('trip_id', flat=True).distinct()\n    for trip in Trip.objects.filter(id__in=trip_ids):\n        trip.update_geometry()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _do_post_request_tasks(self, response_data):\n        try:\n            sess_ops = response_data.get('ops', [])\n        except AttributeError:\n            pass\n        else:\n            self._session_ops.extend(sess_ops)", "response": "Handle actions that need to be done with every response_data."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _build_request(self, method, url, params=None):\n        full_params = self._get_base_params()\n        if params is not None:\n            full_params.update(params)\n        try:\n            request_func = lambda u, d: \\\n                getattr(self._connector, method.lower())(u, params=d,\n                    headers=self._request_headers)\n        except AttributeError:\n            raise ApiException('Invalid request method')\n        # TODO: need to catch a network here and raise as ApiNetworkException\n\n        def do_request():\n            logger.debug('Sending %s request \"%s\" with params: %r',\n                method, url, full_params)\n            try:\n                resp = request_func(url, full_params)\n                logger.debug('Received response code: %d', resp.status_code)\n            except requests.RequestException as err:\n                raise ApiNetworkException(err)\n\n            try:\n                resp_json = resp.json()\n            except TypeError:\n                resp_json = resp.json\n\n            method_returns_list = False\n            try:\n                resp_json['error']\n            except TypeError:\n                logger.warn('Api method did not return map: %s', method)\n                method_returns_list = True\n            except KeyError:\n                logger.warn('Api method did not return map with error key: %s', method)\n\n            if method_returns_list is None:\n                raise ApiBadResponseException(resp.content)\n            elif method_returns_list:\n                data = resp_json\n            else:\n                try:\n                    if resp_json['error']:\n                        raise ApiError('%s: %s' % (resp_json['code'], resp_json['message']))\n                except KeyError:\n                    data = resp_json\n                else:\n                    data = resp_json['data']\n                    self._do_post_request_tasks(data)\n            self._last_response = resp\n            return data\n        return do_request", "response": "Build a function to do an API request"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _build_request_url(self, secure, api_method):\n        if secure:\n            proto = ANDROID_MANGA.PROTOCOL_SECURE\n        else:\n            proto = ANDROID_MANGA.PROTOCOL_INSECURE\n        req_url = ANDROID_MANGA.API_URL.format(\n            protocol=proto,\n            api_method=api_method\n        )\n        return req_url", "response": "Build a URL for a request based on the current configuration."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef cr_login(self, response):\n        self._state_params['auth'] = response['auth']\n        self._user_data = response['user']\n        if not self.logged_in:\n            raise ApiLoginFailure(response)", "response": "Login using email and username and password"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nhandle data loaded from database.", "response": "def from_db_value(self, value, expression, connection, context):\n        '''Handle data loaded from database.'''\n        if value is None:\n            return value\n        return self.parse_seconds(value)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef to_python(self, value):\n        '''Handle data from serialization and form clean() methods.'''\n        if isinstance(value, Seconds):\n            return value\n        if value in self.empty_values:\n            return None\n        return self.parse_seconds(value)", "response": "Handle data from serialization and form clean() methods."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nparsing string into Seconds instances.", "response": "def parse_seconds(value):\n        '''\n        Parse string into Seconds instances.\n\n        Handled formats:\n        HH:MM:SS\n        HH:MM\n        SS\n        '''\n        svalue = str(value)\n        colons = svalue.count(':')\n        if colons == 2:\n            hours, minutes, seconds = [int(v) for v in svalue.split(':')]\n        elif colons == 1:\n            hours, minutes = [int(v) for v in svalue.split(':')]\n            seconds = 0\n        elif colons == 0:\n            hours = 0\n            minutes = 0\n            seconds = int(svalue)\n        else:\n            raise ValueError('Must be in seconds or HH:MM:SS format')\n        return Seconds.from_hms(hours, minutes, seconds)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nprepares value for database storage.", "response": "def get_prep_value(self, value):\n        '''Prepare value for database storage.'''\n        if isinstance(value, Seconds):\n            return value.seconds\n        elif value:\n            return self.parse_seconds(value).seconds\n        else:\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the positions and colors of all intervals inside the colorbar.", "response": "def calculate_colorbar(self):\n        \"\"\"\n        Returns the positions and colors of all intervals inside the colorbar.\n        \"\"\"\n        self._base._process_values()\n        self._base._find_range()\n        X, Y = self._base._mesh()\n        C = self._base._values[:, np.newaxis]\n        return X, Y, C"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncalculates the ticks for the current locale.", "response": "def calculate_ticks(self):\n        \"\"\"\n        Returns the sequence of ticks (colorbar data locations),\n        ticklabels (strings), and the corresponding offset string.\n        \"\"\"\n        current_version = packaging.version.parse(matplotlib.__version__)\n        critical_version = packaging.version.parse('3.0.0')\n\n        if current_version > critical_version:\n            locator, formatter = self._base._get_ticker_locator_formatter()\n            return self._base._ticker(locator, formatter)\n        else:\n            return self._base._ticker()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget the media formats for a given media id.", "response": "def get_media_formats(self, media_id):\n        \"\"\"CR doesn't seem to provide the video_format and video_quality params\n        through any of the APIs so we have to scrape the video page\n        \"\"\"\n        url = (SCRAPER.API_URL + 'media-' + media_id).format(\n            protocol=SCRAPER.PROTOCOL_INSECURE)\n        format_pattern = re.compile(SCRAPER.VIDEO.FORMAT_PATTERN)\n        formats = {}\n\n        for format, param in iteritems(SCRAPER.VIDEO.FORMAT_PARAMS):\n            resp = self._connector.get(url, params={param: '1'})\n            if not resp.ok:\n                continue\n            try:\n                match = format_pattern.search(resp.content)\n            except TypeError:\n                match = format_pattern.search(resp.text)\n            if match:\n                formats[format] = (int(match.group(1)), int(match.group(2)))\n        return formats"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nparse a literal nbt string and return the resulting tag.", "response": "def parse_nbt(literal):\n    \"\"\"Parse a literal nbt string and return the resulting tag.\"\"\"\n    parser = Parser(tokenize(literal))\n    tag = parser.parse()\n\n    cursor = parser.token_span[1]\n    leftover = literal[cursor:]\n    if leftover.strip():\n        parser.token_span = cursor, cursor + len(leftover)\n        raise parser.error(f'Expected end of string but got {leftover!r}')\n\n    return tag"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nmatching and yield all the tokens of the input string.", "response": "def tokenize(string):\n    \"\"\"Match and yield all the tokens of the input string.\"\"\"\n    for match in TOKENS_REGEX.finditer(string):\n        yield Token(match.lastgroup, match.group().strip(), match.span())"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nmoves to the next token in the token stream.", "response": "def next(self):\n        \"\"\"Move to the next token in the token stream.\"\"\"\n        self.current_token = next(self.token_stream, None)\n        if self.current_token is None:\n            self.token_span = self.token_span[1], self.token_span[1]\n            raise self.error('Unexpected end of input')\n        self.token_span = self.current_token.span\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nparsing and return an nbt literal from the token stream.", "response": "def parse(self):\n        \"\"\"Parse and return an nbt literal from the token stream.\"\"\"\n        token_type = self.current_token.type.lower()\n        handler = getattr(self, f'parse_{token_type}', None)\n        if handler is None:\n            raise self.error(f'Invalid literal {self.current_token.value!r}')\n        return handler()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef parse_number(self):\n        value = self.current_token.value\n        suffix = value[-1].lower()\n\n        try:\n            if suffix in NUMBER_SUFFIXES:\n                return NUMBER_SUFFIXES[suffix](value[:-1])\n            return Double(value) if '.' in value else Int(value)\n        except (OutOfRange, ValueError):\n            return String(value)", "response": "Parse a number from the token stream."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nparses a regular unquoted string from the token stream.", "response": "def parse_string(self):\n        \"\"\"Parse a regular unquoted string from the token stream.\"\"\"\n        aliased_value = LITERAL_ALIASES.get(self.current_token.value.lower())\n        if aliased_value is not None:\n            return aliased_value\n        return String(self.current_token.value)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nyields the item tokens in a comma - separated tag collection.", "response": "def collect_tokens_until(self, token_type):\n        \"\"\"Yield the item tokens in a comma-separated tag collection.\"\"\"\n        self.next()\n        if self.current_token.type == token_type:\n            return\n\n        while True:\n            yield self.current_token\n\n            self.next()\n            if self.current_token.type == token_type:\n                return\n\n            if self.current_token.type != 'COMMA':\n                raise self.error(f'Expected comma but got '\n                                 f'{self.current_token.value!r}')\n            self.next()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef parse_compound(self):\n        compound_tag = Compound()\n\n        for token in self.collect_tokens_until('CLOSE_COMPOUND'):\n            item_key = token.value\n            if token.type not in ('NUMBER', 'STRING', 'QUOTED_STRING'):\n                raise self.error(f'Expected compound key but got {item_key!r}')\n\n            if token.type == 'QUOTED_STRING':\n                item_key = self.unquote_string(item_key)\n\n            if self.next().current_token.type != 'COLON':\n                raise self.error(f'Expected colon but got '\n                                 f'{self.current_token.value!r}')\n            self.next()\n            compound_tag[item_key] = self.parse()\n        return compound_tag", "response": "Parse a compound from the token stream."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef array_items(self, number_type, *, number_suffix=''):\n        for token in self.collect_tokens_until('CLOSE_BRACKET'):\n            is_number = token.type == 'NUMBER'\n            value = token.value.lower()\n            if not (is_number and value.endswith(number_suffix)):\n                raise self.error(f'Invalid {number_type} array element '\n                                 f'{token.value!r}')\n            yield int(value.replace(number_suffix, ''))", "response": "Parse and yield array items from the token stream."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nparses a list from the token stream.", "response": "def parse_list(self):\n        \"\"\"Parse a list from the token stream.\"\"\"\n        try:\n            return List([self.parse() for _ in\n                         self.collect_tokens_until('CLOSE_BRACKET')])\n        except IncompatibleItemType as exc:\n            raise self.error(f'Item {str(exc.item)!r} is not a '\n                             f'{exc.subtype.__name__} tag') from None"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef unquote_string(self, string):\n        value = string[1:-1]\n\n        forbidden_sequences = {ESCAPE_SUBS[STRING_QUOTES[string[0]]]}\n        valid_sequences = set(ESCAPE_SEQUENCES) - forbidden_sequences\n\n        for seq in ESCAPE_REGEX.findall(value):\n            if seq not in valid_sequences:\n                raise self.error(f'Invalid escape sequence \"{seq}\"')\n\n        for seq, sub in ESCAPE_SEQUENCES.items():\n            value = value.replace(seq, sub)\n\n        return value", "response": "Return the unquoted value of a quoted string."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a function that will open a file in a zipfile by name.", "response": "def opener_from_zipfile(zipfile):\n    \"\"\"\n    Returns a function that will open a file in a zipfile by name.\n\n    For Python3 compatibility, the raw file will be converted to text.\n    \"\"\"\n\n    def opener(filename):\n        inner_file = zipfile.open(filename)\n        if PY3:\n            from io import TextIOWrapper\n            return TextIOWrapper(inner_file)\n        else:\n            return inner_file\n\n    return opener"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nwrite CSV row data which may include text.", "response": "def write_text_rows(writer, rows):\n    '''Write CSV row data which may include text.'''\n    for row in rows:\n        try:\n            writer.writerow(row)\n        except UnicodeEncodeError:\n            # Python 2 csv does badly with unicode outside of ASCII\n            new_row = []\n            for item in row:\n                if isinstance(item, text_type):\n                    new_row.append(item.encode('utf-8'))\n                else:\n                    new_row.append(item)\n            writer.writerow(new_row)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nserializing an nbt tag to its literal representation.", "response": "def serialize_tag(tag, *, indent=None, compact=False, quote=None):\n    \"\"\"Serialize an nbt tag to its literal representation.\"\"\"\n    serializer = Serializer(indent=indent, compact=compact, quote=quote)\n    return serializer.serialize(tag)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nincreasing the level of indentation by one.", "response": "def depth(self):\n        \"\"\"Increase the level of indentation by one.\"\"\"\n        if self.indentation is None:\n            yield\n        else:\n            previous = self.previous_indent\n            self.previous_indent = self.indent\n            self.indent += self.indentation\n            yield\n            self.indent = self.previous_indent\n            self.previous_indent = previous"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn whether the specified tag should be expanded.", "response": "def should_expand(self, tag):\n        \"\"\"Return whether the specified tag should be expanded.\"\"\"\n        return self.indentation is not None and tag and (\n            not self.previous_indent or (\n                tag.serializer == 'list'\n                and tag.subtype.serializer in ('array', 'list', 'compound')\n            ) or (\n                tag.serializer == 'compound'\n            )\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef escape_string(self, string):\n        if self.quote:\n            quote = self.quote\n        else:\n            found = QUOTE_REGEX.search(string)\n            quote = STRING_QUOTES[found.group()] if found else next(iter(STRING_QUOTES))\n\n        for match, seq in ESCAPE_SUBS.items():\n            if match == quote or match not in STRING_QUOTES:\n                string = string.replace(match, seq)\n\n        return f'{quote}{string}{quote}'", "response": "Return the escaped literal representation of an nbt string."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nescape the compound key if it can t be represented unquoted.", "response": "def stringify_compound_key(self, key):\n        \"\"\"Escape the compound key if it can't be represented unquoted.\"\"\"\n        if UNQUOTED_COMPOUND_KEY.match(key):\n            return key\n        return self.escape_string(key)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the literal representation of a tag.", "response": "def serialize(self, tag):\n        \"\"\"Return the literal representation of a tag.\"\"\"\n        handler = getattr(self, f'serialize_{tag.serializer}', None)\n        if handler is None:\n            raise TypeError(f'Can\\'t serialize {type(tag)!r} instance')\n        return handler(tag)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the literal representation of a numeric tag.", "response": "def serialize_numeric(self, tag):\n        \"\"\"Return the literal representation of a numeric tag.\"\"\"\n        str_func = int.__str__ if isinstance(tag, int) else float.__str__\n        return str_func(tag) + tag.suffix"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the literal representation of an array tag.", "response": "def serialize_array(self, tag):\n        \"\"\"Return the literal representation of an array tag.\"\"\"\n        elements = self.comma.join(f'{el}{tag.item_suffix}' for el in tag)\n        return f'[{tag.array_prefix}{self.semicolon}{elements}]'"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the literal representation of a list tag.", "response": "def serialize_list(self, tag):\n        \"\"\"Return the literal representation of a list tag.\"\"\"\n        separator, fmt = self.comma, '[{}]'\n\n        with self.depth():\n            if self.should_expand(tag):\n                separator, fmt = self.expand(separator, fmt)\n\n            return fmt.format(separator.join(map(self.serialize, tag)))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef serialize_compound(self, tag):\n        separator, fmt = self.comma, '{{{}}}'\n\n        with self.depth():\n            if self.should_expand(tag):\n                separator, fmt = self.expand(separator, fmt)\n\n            return fmt.format(separator.join(\n                f'{self.stringify_compound_key(key)}{self.colon}{self.serialize(value)}'\n                for key, value in tag.items()\n            ))", "response": "Return the literal representation of a compound tag."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the _column_map without unused optional fields", "response": "def populated_column_map(self):\n        '''Return the _column_map without unused optional fields'''\n        column_map = []\n        cls = self.model\n        for csv_name, field_pattern in cls._column_map:\n            # Separate the local field name from foreign columns\n            if '__' in field_pattern:\n                field_name = field_pattern.split('__', 1)[0]\n            else:\n                field_name = field_pattern\n\n            # Handle point fields\n            point_match = re_point.match(field_name)\n            if point_match:\n                field = None\n            else:\n                field = cls._meta.get_field(field_name)\n\n            # Only add optional columns if they are used in the records\n            if field and field.blank and not field.has_default():\n                kwargs = {field_name: get_blank_value(field)}\n                if self.exclude(**kwargs).exists():\n                    column_map.append((csv_name, field_pattern))\n            else:\n                column_map.append((csv_name, field_pattern))\n        return column_map"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef in_feed(self, feed):\n        '''Return the objects in the target feed'''\n        kwargs = {self.model._rel_to_feed: feed}\n        return self.filter(**kwargs)", "response": "Return the objects in the target feed"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef import_txt(cls, txt_file, feed, filter_func=None):\n        '''Import from the GTFS text file'''\n\n        # Setup the conversion from GTFS to Django Format\n        # Conversion functions\n        def no_convert(value): return value\n\n        def date_convert(value): return datetime.strptime(value, '%Y%m%d')\n\n        def bool_convert(value): return (value == '1')\n\n        def char_convert(value): return (value or '')\n\n        def null_convert(value): return (value or None)\n\n        def point_convert(value):\n            \"\"\"Convert latitude / longitude, strip leading +.\"\"\"\n            if value.startswith('+'):\n                return value[1:]\n            else:\n                return (value or 0.0)\n\n        cache = {}\n\n        def default_convert(field):\n            def get_value_or_default(value):\n                if value == '' or value is None:\n                    return field.get_default()\n                else:\n                    return value\n            return get_value_or_default\n\n        def instance_convert(field, feed, rel_name):\n            def get_instance(value):\n                if value.strip():\n                    related = field.related_model\n                    key1 = \"{}:{}\".format(related.__name__, rel_name)\n                    key2 = text_type(value)\n\n                    # Load existing objects\n                    if key1 not in cache:\n                        pairs = related.objects.filter(\n                            **{related._rel_to_feed: feed}).values_list(\n                            rel_name, 'id')\n                        cache[key1] = dict((text_type(x), i) for x, i in pairs)\n\n                    # Create new?\n                    if key2 not in cache[key1]:\n                        kwargs = {\n                            related._rel_to_feed: feed,\n                            rel_name: value}\n                        cache[key1][key2] = related.objects.create(\n                            **kwargs).id\n                    return cache[key1][key2]\n                else:\n                    return None\n            return get_instance\n\n        # Check unique fields\n        column_names = [c for c, _ in cls._column_map]\n        for unique_field in cls._unique_fields:\n            assert unique_field in column_names, \\\n                '{} not in {}'.format(unique_field, column_names)\n\n        # Map of field_name to converters from GTFS to Django format\n        val_map = dict()\n        name_map = dict()\n        point_map = dict()\n        for csv_name, field_pattern in cls._column_map:\n            # Separate the local field name from foreign columns\n            if '__' in field_pattern:\n                field_base, rel_name = field_pattern.split('__', 1)\n                field_name = field_base + '_id'\n            else:\n                field_name = field_base = field_pattern\n            # Use the field name in the name mapping\n            name_map[csv_name] = field_name\n\n            # Is it a point field?\n            point_match = re_point.match(field_name)\n            if point_match:\n                field = None\n            else:\n                field = cls._meta.get_field(field_base)\n\n            # Pick a conversion function for the field\n            if point_match:\n                converter = point_convert\n            elif isinstance(field, models.DateField):\n                converter = date_convert\n            elif isinstance(field, models.BooleanField):\n                converter = bool_convert\n            elif isinstance(field, models.CharField):\n                converter = char_convert\n            elif field.is_relation:\n                converter = instance_convert(field, feed, rel_name)\n                assert not isinstance(field, models.ManyToManyField)\n            elif field.null:\n                converter = null_convert\n            elif field.has_default():\n                converter = default_convert(field)\n            else:\n                converter = no_convert\n\n            if point_match:\n                index = int(point_match.group('index'))\n                point_map[csv_name] = (index, converter)\n            else:\n                val_map[csv_name] = converter\n\n        # Read and convert the source txt\n        csv_reader = reader(txt_file, skipinitialspace=True)\n        unique_line = dict()\n        count = 0\n        first = True\n        extra_counts = defaultdict(int)\n        new_objects = []\n        for row in csv_reader:\n            if first:\n                # Read the columns\n                columns = row\n                if columns[0].startswith(CSV_BOM):\n                    columns[0] = columns[0][len(CSV_BOM):]\n                first = False\n                continue\n\n            if filter_func and not filter_func(zip(columns, row)):\n                continue\n\n            if not row:\n                continue\n\n            # Read a data row\n            fields = dict()\n            point_coords = [None, None]\n            ukey_values = {}\n            if cls._rel_to_feed == 'feed':\n                fields['feed'] = feed\n            for column_name, value in zip(columns, row):\n                if column_name not in name_map:\n                    val = null_convert(value)\n                    if val is not None:\n                        fields.setdefault('extra_data', {})[column_name] = val\n                        extra_counts[column_name] += 1\n                elif column_name in val_map:\n                    fields[name_map[column_name]] = val_map[column_name](value)\n                else:\n                    assert column_name in point_map\n                    pos, converter = point_map[column_name]\n                    point_coords[pos] = converter(value)\n\n                # Is it part of the unique key?\n                if column_name in cls._unique_fields:\n                    ukey_values[column_name] = value\n\n            # Join the lat/long into a point\n            if point_map:\n                assert point_coords[0] and point_coords[1]\n                fields['point'] = \"POINT(%s)\" % (' '.join(point_coords))\n\n            # Is the item unique?\n            ukey = tuple(ukey_values.get(u) for u in cls._unique_fields)\n            if ukey in unique_line:\n                logger.warning(\n                    '%s line %d is a duplicate of line %d, not imported.',\n                    cls._filename, csv_reader.line_num, unique_line[ukey])\n                continue\n            else:\n                unique_line[ukey] = csv_reader.line_num\n\n            # Create after accumulating a batch\n            new_objects.append(cls(**fields))\n            if len(new_objects) % batch_size == 0:  # pragma: no cover\n                cls.objects.bulk_create(new_objects)\n                count += len(new_objects)\n                logger.info(\n                    \"Imported %d %s\",\n                    count, cls._meta.verbose_name_plural)\n                new_objects = []\n\n        # Create remaining objects\n        if new_objects:\n            cls.objects.bulk_create(new_objects)\n\n        # Take note of extra fields\n        if extra_counts:\n            extra_columns = feed.meta.setdefault(\n                'extra_columns', {}).setdefault(cls.__name__, [])\n            for column in columns:\n                if column in extra_counts and column not in extra_columns:\n                    extra_columns.append(column)\n            feed.save()\n        return len(unique_line)", "response": "Import from the GTFS text file."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nexporting records as a GTFS comma - separated file", "response": "def export_txt(cls, feed):\n        '''Export records as a GTFS comma-separated file'''\n        objects = cls.objects.in_feed(feed)\n\n        # If no records, return None\n        if not objects.exists():\n            return\n\n        # Get the columns used in the dataset\n        column_map = objects.populated_column_map()\n        columns, fields = zip(*column_map)\n        extra_columns = feed.meta.get(\n            'extra_columns', {}).get(cls.__name__, [])\n\n        # Get sort order\n        if hasattr(cls, '_sort_order'):\n            sort_fields = cls._sort_order\n        else:\n            sort_fields = []\n            for field in fields:\n                base_field = field.split('__', 1)[0]\n                point_match = re_point.match(base_field)\n                if point_match:\n                    continue\n                field_type = cls._meta.get_field(base_field)\n                assert not isinstance(field_type, ManyToManyField)\n                sort_fields.append(field)\n\n        # Create CSV writer\n        out = StringIO()\n        csv_writer = writer(out, lineterminator='\\n')\n\n        # Write header row\n        header_row = [text_type(c) for c in columns]\n        header_row.extend(extra_columns)\n        write_text_rows(csv_writer, [header_row])\n\n        # Report the work to be done\n        total = objects.count()\n        logger.info(\n            '%d %s to export...',\n            total, cls._meta.verbose_name_plural)\n\n        # Populate related items cache\n        model_to_field_name = {}\n        cache = {}\n        for field_name in fields:\n            if '__' in field_name:\n                local_field_name, subfield_name = field_name.split('__', 1)\n                field = cls._meta.get_field(local_field_name)\n                field_type = field.related_model\n                model_name = field_type.__name__\n                if model_name in model_to_field_name:\n                    # Already loaded this model under a different field name\n                    cache[field_name] = cache[model_to_field_name[model_name]]\n                else:\n                    # Load all feed data for this model\n                    pairs = field_type.objects.in_feed(\n                        feed).values_list('id', subfield_name)\n                    cache[field_name] = dict(\n                        (i, text_type(x)) for i, x in pairs)\n                    cache[field_name][None] = u''\n                    model_to_field_name[model_name] = field_name\n\n        # Assemble the rows, writing when we hit batch size\n        count = 0\n        rows = []\n        for item in objects.order_by(*sort_fields).iterator():\n            row = []\n            for csv_name, field_name in column_map:\n                obj = item\n                point_match = re_point.match(field_name)\n                if '__' in field_name:\n                    # Return relations from cache\n                    local_field_name = field_name.split('__', 1)[0]\n                    field_id = getattr(obj, local_field_name + '_id')\n                    row.append(cache[field_name][field_id])\n                elif point_match:\n                    # Get the lat or long from the point\n                    name, index = point_match.groups()\n                    field = getattr(obj, name)\n                    row.append(field.coords[int(index)])\n                else:\n                    # Handle other field types\n                    field = getattr(obj, field_name) if obj else ''\n                    if isinstance(field, date):\n                        formatted = field.strftime(u'%Y%m%d')\n                        row.append(text_type(formatted))\n                    elif isinstance(field, bool):\n                        row.append(1 if field else 0)\n                    elif field is None:\n                        row.append(u'')\n                    else:\n                        row.append(text_type(field))\n            for col in extra_columns:\n                row.append(obj.extra_data.get(col, u''))\n            rows.append(row)\n            if len(rows) % batch_size == 0:  # pragma: no cover\n                write_text_rows(csv_writer, rows)\n                count += len(rows)\n                logger.info(\n                    \"Exported %d %s\",\n                    count, cls._meta.verbose_name_plural)\n                rows = []\n\n        # Write rows smaller than batch size\n        write_text_rows(csv_writer, rows)\n        return out.getvalue()"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nturns an AndroidApi s method into a function that builds the request and sends it to the actual method.", "response": "def make_android_api_method(req_method, secure=True, version=0):\n    \"\"\"Turn an AndroidApi's method into a function that builds the request,\n    sends it, then passes the response to the actual method. Should be used\n    as a decorator.\n    \"\"\"\n    def outer_func(func):\n        def inner_func(self, **kwargs):\n            req_url = self._build_request_url(secure, func.__name__, version)\n            req_func = self._build_request(req_method, req_url, params=kwargs)\n            response = req_func()\n            func(self, response)\n            return response\n        return inner_func\n    return outer_func"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget the params that will be included with every request", "response": "def _get_base_params(self):\n        \"\"\"Get the params that will be included with every request\n        \"\"\"\n        base_params = {\n            'locale':       self._get_locale(),\n            'device_id':    ANDROID.DEVICE_ID,\n            'device_type':  ANDROID.APP_PACKAGE,\n            'access_token': ANDROID.ACCESS_TOKEN,\n            'version':      ANDROID.APP_CODE,\n        }\n        base_params.update(dict((k, v) \\\n            for k, v in iteritems(self._state_params) \\\n                if v is not None))\n        return base_params"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _build_request_url(self, secure, api_method, version):\n        if secure:\n            proto = ANDROID.PROTOCOL_SECURE\n        else:\n            proto = ANDROID.PROTOCOL_INSECURE\n        req_url = ANDROID.API_URL.format(\n            protocol=proto,\n            api_method=api_method,\n            version=version\n        )\n        return req_url", "response": "Build a URL for a API method request."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn True if the user is premium for a given media type.", "response": "def is_premium(self, media_type):\n        \"\"\"Get if the session is premium for a given media type\n\n        @param str media_type       Should be one of ANDROID.MEDIA_TYPE_*\n        @return bool\n        \"\"\"\n        if self.logged_in:\n            if media_type in self._user_data['premium']:\n                return True\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef login(self, response):\n        self._state_params['auth'] = response['auth']\n        self._user_data = response['user']\n        if not self.logged_in:\n            raise ApiLoginFailure(response)", "response": "Login using email username and password"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef read_numeric(fmt, buff, byteorder='big'):\r\n    try:\r\n        fmt = fmt[byteorder]\r\n        return fmt.unpack(buff.read(fmt.size))[0]\r\n    except StructError:\r\n        return 0\r\n    except KeyError as exc:\r\n        raise ValueError('Invalid byte order') from exc", "response": "Read a numeric value from a file - like object."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef write_numeric(fmt, value, buff, byteorder='big'):\r\n    try:\r\n        buff.write(fmt[byteorder].pack(value))\r\n    except KeyError as exc:\r\n        raise ValueError('Invalid byte order') from exc", "response": "Write a numeric value to a file - like object."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nread a string from a file - like object.", "response": "def read_string(buff, byteorder='big'):\r\n    \"\"\"Read a string from a file-like object.\"\"\"\r\n    length = read_numeric(USHORT, buff, byteorder)\r\n    return buff.read(length).decode('utf-8')"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef write_string(value, buff, byteorder='big'):\r\n    data = value.encode('utf-8')\r\n    write_numeric(USHORT, len(data), buff, byteorder)\r\n    buff.write(data)", "response": "Write a string to a file - like object."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef infer_list_subtype(items):\r\n        subtype = End\r\n\r\n        for item in items:\r\n            item_type = type(item)\r\n            if not issubclass(item_type, Base):\r\n                continue\r\n\r\n            if subtype is End:\r\n                subtype = item_type\r\n                if not issubclass(subtype, List):\r\n                    return subtype\r\n            elif subtype is not item_type:\r\n                stype, itype = subtype, item_type\r\n                generic = List\r\n                while issubclass(stype, List) and issubclass(itype, List):\r\n                    stype, itype = stype.subtype, itype.subtype\r\n                    generic = List[generic]\r\n\r\n                if stype is End:\r\n                    subtype = item_type\r\n                elif itype is not End:\r\n                    return generic.subtype\r\n        return subtype", "response": "Infer a list subtype from a collection of items."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncasting list item to the appropriate tag type.", "response": "def cast_item(cls, item):\r\n        \"\"\"Cast list item to the appropriate tag type.\"\"\"\r\n        if not isinstance(item, cls.subtype):\r\n            incompatible = isinstance(item, Base) and not any(\r\n                issubclass(cls.subtype, tag_type) and isinstance(item, tag_type)\r\n                for tag_type in cls.all_tags.values()\r\n            )\r\n            if incompatible:\r\n                raise IncompatibleItemType(item, cls.subtype)\r\n\r\n            try:\r\n                return cls.subtype(item)\r\n            except EndInstantiation:\r\n                raise ValueError('List tags without an explicit subtype must '\r\n                                 'either be empty or instantiated with '\r\n                                 'elements from which a subtype can be '\r\n                                 'inferred') from None\r\n            except (IncompatibleItemType, CastError):\r\n                raise\r\n            except Exception as exc:\r\n                raise CastError(item, cls.subtype) from exc\r\n        return item"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ngenerate the encryption key for a given media item.", "response": "def _build_encryption_key(self, subtitle_id, key_size=ENCRYPTION_KEY_SIZE):\n        \"\"\"Generate the encryption key for a given media item\n\n        Encryption key is basically just\n        sha1(<magic value based on subtitle_id> + '\"#$&).6CXzPHw=2N_+isZK') then\n        padded with 0s to 32 chars\n\n        @param int subtitle_id\n        @param int key_size\n        @return str\n        \"\"\"\n\n        # generate a 160-bit SHA1 hash\n        sha1_hash = hashlib.new('sha1', self._build_hash_secret((1, 2)) +\n            self._build_hash_magic(subtitle_id)).digest()\n        # pad to 256-bit hash for 32 byte key\n        sha1_hash += '\\x00' * max(key_size - len(sha1_hash), 0)\n        return sha1_hash[:key_size]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nbuild the other half of the encryption key hash", "response": "def _build_hash_magic(self, subtitle_id):\n        \"\"\"Build the other half of the encryption key hash\n\n        I have no idea what is going on here\n\n        @param int subtitle_id\n        @return str\n        \"\"\"\n\n        media_magic = self.HASH_MAGIC_CONST ^ subtitle_id\n        hash_magic = media_magic ^ media_magic >> 3 ^ media_magic * 32\n        return str(hash_magic)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _build_hash_secret(self, seq_seed, seq_len=HASH_SECRET_LENGTH,\n            mod_value=HASH_SECRET_MOD_CONST):\n        \"\"\"Build a seed for the hash based on the Fibonacci sequence\n\n        Take first `seq_len` + len(`seq_seed`) characters of Fibonacci\n        sequence, starting with `seq_seed`, and applying e % `mod_value` +\n        `HASH_SECRET_CHAR_OFFSET` to the resulting sequence, then return as\n        a string\n\n        @param tuple|list seq_seed\n        @param int seq_len\n        @param int mod_value\n        @return str\n        \"\"\"\n\n        # make sure we use a list, tuples are immutable\n        fbn_seq = list(seq_seed)\n        for i in range(seq_len):\n            fbn_seq.append(fbn_seq[-1] + fbn_seq[-2])\n        hash_secret = list(map(\n            lambda c: chr(c % mod_value + self.HASH_SECRET_CHAR_OFFSET),\n            fbn_seq[2:]))\n        return ''.join(hash_secret)", "response": "Builds a seed for the hash based on the Fibonacci sequence and the length of the sequence and the mod_value."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef format(self, subtitles):\n        logger.debug('Formatting subtitles (id=%s) with %s',\n            subtitles.id, self.__class__.__name__)\n        return self._format(subtitles).encode('utf-8')", "response": "Turn a string containing the subs xml document into the formatted\n        subtitle string"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef require_session_started(func):\n    @functools.wraps(func)\n    def inner_func(self, *pargs, **kwargs):\n        if not self.session_started:\n            logger.info('Starting session for required meta method')\n            self.start_session()\n        return func(self, *pargs, **kwargs)\n    return inner_func", "response": "Decorator to check if API sessions are started and start them if not"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef require_android_logged_in(func):\n    @functools.wraps(func)\n    @require_session_started\n    def inner_func(self, *pargs, **kwargs):\n        if not self._android_api.logged_in:\n            logger.info('Logging into android API for required meta method')\n            if not self.has_credentials:\n                raise ApiLoginFailure(\n                    'Login is required but no credentials were provided')\n            self._android_api.login(account=self._state['username'],\n                password=self._state['password'])\n        return func(self, *pargs, **kwargs)\n    return inner_func", "response": "Decorator to check if andoid API is logged in and login if not"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef optional_manga_logged_in(func):\n    @functools.wraps(func)\n    @require_session_started\n    def inner_func(self, *pargs, **kwargs):\n        if not self._manga_api.logged_in and self.has_credentials:\n            logger.info('Logging into android manga API for optional meta method')\n            self._manga_api.cr_login(account=self._state['username'],\n                password=self._state['password'])\n        return func(self, *pargs, **kwargs)\n    return inner_func", "response": "Decorator to check if andoid manga API is logged in and login if credentials were provided."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef require_ajax_logged_in(func):\n    @functools.wraps(func)\n    def inner_func(self, *pargs, **kwargs):\n        if not self._ajax_api.logged_in:\n            logger.info('Logging into AJAX API for required meta method')\n            if not self.has_credentials:\n                raise ApiLoginFailure(\n                    'Login is required but no credentials were provided')\n            self._ajax_api.User_Login(name=self._state['username'],\n                password=self._state['password'])\n        return func(self, *pargs, **kwargs)\n    return inner_func", "response": "Decorator to check if ajax API is logged in and login if not"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nstarts the underlying APIs sessions", "response": "def start_session(self):\n        \"\"\"Start the underlying APIs sessions\n\n        Calling this is not required, it will be called automatically if\n        a method that needs a session is called\n\n        @return bool\n        \"\"\"\n        self._android_api.start_session()\n        self._manga_api.cr_start_session()\n        return self.session_started"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef login(self, username, password):\n        # we could get stuck in an inconsistent state if got an exception while\n        # trying to login with different credentials than what is stored so\n        # we rollback the state to prevent that\n        state_snapshot = self._state.copy()\n        try:\n            self._ajax_api.User_Login(name=username, password=password)\n            self._android_api.login(account=username, password=password)\n            self._manga_api.cr_login(account=username, password=password)\n        except Exception as err:\n            # something went wrong, rollback\n            self._state = state_snapshot\n            raise err\n        self._state['username'] = username\n        self._state['password'] = password\n        return self.logged_in", "response": "Login with the given username and password"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef list_anime_series(self, sort=META.SORT_ALPHA, limit=META.MAX_SERIES, offset=0):\n        result = self._android_api.list_series(\n            media_type=ANDROID.MEDIA_TYPE_ANIME,\n            filter=sort,\n            limit=limit,\n            offset=offset)\n        return result", "response": "Get a list of anime series"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget a list of drama series in the android api", "response": "def list_drama_series(self, sort=META.SORT_ALPHA, limit=META.MAX_SERIES, offset=0):\n        \"\"\"Get a list of drama series\n\n        @param str sort     pick how results should be sorted, should be one\n                                of META.SORT_*\n        @param int limit    limit number of series to return, there doesn't\n                                seem to be an upper bound\n        @param int offset   list series starting from this offset, for pagination\n        @return list<crunchyroll.models.Series>\n        \"\"\"\n        result = self._android_api.list_series(\n            media_type=ANDROID.MEDIA_TYPE_DRAMA,\n            filter=sort,\n            limit=limit,\n            offset=offset)\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets a list of manga series", "response": "def list_manga_series(self, filter=None, content_type='jp_manga'):\n        \"\"\"Get a list of manga series\n        \"\"\"\n\n        result = self._manga_api.list_series(filter, content_type)\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef search_anime_series(self, query_string):\n        result = self._android_api.list_series(\n            media_type=ANDROID.MEDIA_TYPE_ANIME,\n            filter=ANDROID.FILTER_PREFIX + query_string)\n        return result", "response": "Search anime series list by series name case - sensitive\n                                       "}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nsearch drama series list by series name case - sensitive", "response": "def search_drama_series(self, query_string):\n        \"\"\"Search drama series list by series name, case-sensitive\n\n        @param str query_string     string to search for, note that the search\n                                        is very simplistic and only matches against\n                                        the start of the series name, ex) search\n                                        for \"space\" matches \"Space Brothers\" but\n                                        wouldn't match \"Brothers Space\"\n        @return list<crunchyroll.models.Series>\n        \"\"\"\n        result = self._android_api.list_series(\n            media_type=ANDROID.MEDIA_TYPE_DRAMA,\n            filter=ANDROID.FILTER_PREFIX + query_string)\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef search_manga_series(self, query_string):\n\n        result = self._manga_api.list_series()\n        return [series for series in result \\\n            if series['locale']['enUS']['name'].lower().startswith(\n                query_string.lower())]", "response": "Search the manga series list by name case - insensitive by name"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nlisting the media for a given series or collection.", "response": "def list_media(self, series, sort=META.SORT_DESC, limit=META.MAX_MEDIA, offset=0):\n        \"\"\"List media for a given series or collection\n\n        @param crunchyroll.models.Series series the series to search for\n        @param str sort                         choose the ordering of the\n                                                    results, only META.SORT_DESC\n                                                    is known to work\n        @param int limit                        limit size of results\n        @param int offset                       start results from this index,\n                                                    for pagination\n        @return list<crunchyroll.models.Media>\n        \"\"\"\n        params = {\n            'sort': sort,\n            'offset': offset,\n            'limit': limit,\n        }\n        params.update(self._get_series_query_dict(series))\n        result = self._android_api.list_media(**params)\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsearches for media from a series starting with query_string case - sensitive elib.", "response": "def search_media(self, series, query_string):\n        \"\"\"Search for media from a series starting with query_string, case-sensitive\n\n        @param crunchyroll.models.Series series     the series to search in\n        @param str query_string                     the search query, same restrictions\n                                                        as `search_anime_series`\n        @return list<crunchyroll.models.Media>\n        \"\"\"\n        params = {\n            'sort': ANDROID.FILTER_PREFIX + query_string,\n        }\n        params.update(self._get_series_query_dict(series))\n        result = self._android_api.list_media(**params)\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_media_stream(self, media_item, format, quality):\n        result = self._ajax_api.VideoPlayer_GetStandardConfig(\n            media_id=media_item.media_id,\n            video_format=format,\n            video_quality=quality)\n        return MediaStream(result)", "response": "Get the stream data for a given media item"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef unfold_subtitle_stub(self, subtitle_stub):\n        return Subtitle(self._ajax_api.Subtitle_GetXml(\n            subtitle_script_id=int(subtitle_stub.id)))", "response": "Turn a SubtitleStub into a full Subtitle object"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the available media formats for a given media item", "response": "def get_stream_formats(self, media_item):\n        \"\"\"Get the available media formats for a given media item\n\n        @param crunchyroll.models.Media\n        @return dict\n        \"\"\"\n        scraper = ScraperApi(self._ajax_api._connector)\n        formats = scraper.get_media_formats(media_item.media_id)\n        return formats"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nlists the series in the queue optionally filtering by type of media", "response": "def list_queue(self, media_types=[META.TYPE_ANIME, META.TYPE_DRAMA]):\n        \"\"\"List the series in the queue, optionally filtering by type of media\n\n        @param list<str> media_types    a list of media types to filter the queue\n                                            with, should be of META.TYPE_*\n        @return list<crunchyroll.models.Series>\n        \"\"\"\n        result = self._android_api.queue(media_types='|'.join(media_types))\n        return [queue_item['series'] for queue_item in result]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef add_to_queue(self, series):\n        result = self._android_api.add_to_queue(series_id=series.series_id)\n        return result", "response": "Add a series to the queue."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nremoving a series from the queue.", "response": "def remove_from_queue(self, series):\n        \"\"\"Remove a series from the queue\n\n        @param crunchyroll.models.Series series\n        @return bool\n        \"\"\"\n        result = self._android_api.remove_from_queue(series_id=series.series_id)\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef schema(name, dct, *, strict=False):\r\n    return type(name, (CompoundSchema,), {'__slots__': (), 'schema': dct,\r\n                                          'strict': strict})", "response": "Create a compound tag schema."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncasts schema item to the appropriate tag type.", "response": "def cast_item(cls, key, value):\r\n        \"\"\"Cast schema item to the appropriate tag type.\"\"\"\r\n        schema_type = cls.schema.get(key)\r\n        if schema_type is None:\r\n            if cls.strict:\r\n                raise TypeError(f'Invalid key {key!r}')\r\n        elif not isinstance(value, schema_type):\r\n            try:\r\n                return schema_type(value)\r\n            except CastError:\r\n                raise\r\n            except Exception as exc:\r\n                raise CastError(value, schema_type) from exc\r\n        return value"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nrun a bash command and returns the output of the command.", "response": "def call(command, silent=False):\n    \"\"\" Runs a bash command safely, with shell=false, catches any non-zero\n        return codes.  Raises slightly modified CalledProcessError exceptions\n        on failures.\n        Note: command is a string and cannot include pipes.\"\"\"\n    try:\n        if silent:\n            with open(os.devnull, 'w')  as FNULL:\n                return subprocess.check_call(command_to_array(command), stdout=FNULL)\n        else:\n            # Using the defaults, shell=False, no i/o redirection.\n            return check_call(command_to_array(command))\n    except CalledProcessError as e:\n        # We are modifying the error itself for 2 reasons.  1) it WILL contain\n        # login credentials when run_mongodump is run, 2) CalledProcessError is\n        # slightly not-to-spec (the message variable is blank), which means\n        # cronutils.ErrorHandler would report unlabeled stack traces.\n        e.message = \"%s failed with error code %s\" % (e.cmd[0], e.returncode)\n        e.cmd = e.cmd[0] + \" [arguments stripped for security]\"\n        raise e"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ntars and bzips a directory.", "response": "def tarbz(source_directory_path, output_file_full_path, silent=False):\n    \"\"\" Tars and bzips a directory, preserving as much metadata as possible.\n        Adds '.tbz' to the provided output file name. \"\"\"\n    output_directory_path = output_file_full_path.rsplit(\"/\", 1)[0]\n    create_folders(output_directory_path)\n    # Note: default compression for bzip is supposed to be -9, highest compression.\n    full_tar_file_path = output_file_full_path + \".tbz\"\n    if path.exists(full_tar_file_path):\n        raise Exception(\"%s already exists, aborting.\" % (full_tar_file_path))\n    \n    # preserve permissions, create file, use files (not tape devices), preserve\n    # access time.  tar is the only program in the universe to use (dstn, src).\n    tar_command = (\"tar jpcfvC %s %s %s\" %\n                   (full_tar_file_path, source_directory_path, \"./\"))\n    call(tar_command, silent=silent)\n    return full_tar_file_path"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nrestore your mongo database backup from a. tbz file created using this library.", "response": "def untarbz(source_file_path, output_directory_path, silent=False):\n    \"\"\" Restores your mongo database backup from a .tbz created using this library.\n    This function will ensure that a directory is created at the file path\n    if one does not exist already.\n    \n    If used in conjunction with this library's mongodump operation, the backup\n    data will be extracted directly into the provided directory path.\n    \n    This command will fail if the output directory is not empty as existing files\n    with identical names are not overwritten by tar. \"\"\"\n    \n    if not path.exists(source_file_path):\n        raise Exception(\"the provided tar file %s does not exist.\" % (source_file_path))\n    \n    if output_directory_path[0:1] == \"./\":\n        output_directory_path = path.abspath(output_directory_path)\n    if output_directory_path[0] != \"/\":\n        raise Exception(\"your output directory path must start with '/' or './'; you used: %s\"\n                        % (output_directory_path))\n    create_folders(output_directory_path)\n    if listdir(output_directory_path):\n        raise Exception(\"Your output directory isn't empty.  Aborting as \"\n                        + \"exiting files are not overwritten by tar.\")\n    \n    untar_command = (\"tar jxfvkCp %s %s --atime-preserve \" %\n                     (source_file_path, output_directory_path))\n    call(untar_command, silent=silent)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ndetermine if any of the items in the value list for the given attribute contains value.", "response": "def value_contains(self, value, attribute):\n        \"\"\"\n        Determine if any of the items in the value list for the given\n        attribute contain value.\n        \"\"\"\n        for item in self[attribute]:\n            if value in item:\n                return True\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nclearing all search defaults for the specified names.", "response": "def clear_search_defaults(self, args=None):\n        \"\"\"\n        Clear all search defaults specified by the list of parameter names\n        given as ``args``.  If ``args`` is not given, then clear all existing\n        search defaults.\n\n        Examples::\n\n            conn.set_search_defaults(scope=ldap.SCOPE_BASE, attrs=['cn'])\n            conn.clear_search_defaults(['scope'])\n            conn.clear_search_defaults()\n        \"\"\"\n        if args is None:\n            self._search_defaults.clear()\n        else:\n            for arg in args:\n                if arg in self._search_defaults:\n                    del self._search_defaults[arg]"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef search(self, filter, base_dn=None, attrs=None, scope=None,\n               timeout=None, limit=None):\n        \"\"\"\n        Search the directory.\n        \"\"\"\n        if base_dn is None:\n            base_dn = self._search_defaults.get('base_dn', '')\n        if attrs is None:\n            attrs = self._search_defaults.get('attrs', None)\n        if scope is None:\n            scope = self._search_defaults.get('scope', ldap.SCOPE_SUBTREE)\n        if timeout is None:\n            timeout = self._search_defaults.get('timeout', -1)\n        if limit is None:\n            limit = self._search_defaults.get('limit', 0)\n\n        results = self.connection.search_ext_s(\n            base_dn, scope, filter, attrs, timeout=timeout, sizelimit=limit)\n        return self.to_items(results)", "response": "Search the directory for a specific entry."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get(self, *args, **kwargs):\n        results = self.search(*args, **kwargs)\n        num_results = len(results)\n        if num_results == 1:\n            return results[0]\n        if num_results > 1:\n            raise MultipleObjectsFound()\n        raise ObjectNotFound()", "response": "Get a single object."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef authenticate(self, dn='', password=''):\n        try:\n            self.connection.simple_bind_s(dn, password)\n        except tuple(self.failed_authentication_exceptions):\n            return False\n        else:\n            return True", "response": "Authenticate given dn and password using a simple bind operation."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncompares the attr of the entry dn with given value.", "response": "def compare(self, dn, attr, value):\n        \"\"\"\n        Compare the ``attr`` of the entry ``dn`` with given ``value``.\n\n        This is a convenience wrapper for the ldap library's ``compare``\n        function that returns a boolean value instead of 1 or 0.\n        \"\"\"\n        return self.connection.compare_s(dn, attr, value) == 1"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_property_func(key):\n    def get_it(obj):\n        try:\n            return getattr(obj, key)\n        except AttributeError:\n            return obj.tags.get(key)\n    return get_it", "response": "Get the accessor function for an instance to look for key."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef list_billing(region, filter_by_kwargs):\n    conn = boto.ec2.cloudwatch.connect_to_region(region)\n    metrics = conn.list_metrics(metric_name='EstimatedCharges')\n    # Filtering is based on metric Dimensions.  Only really valuable one is\n    # ServiceName.\n    if filter_by_kwargs:\n        filter_key = filter_by_kwargs.keys()[0]\n        filter_value = filter_by_kwargs.values()[0]\n        if filter_value:\n            filtered_metrics = [x for x in metrics if x.dimensions.get(filter_key) and x.dimensions.get(filter_key)[0] == filter_value]\n        else:\n            # ServiceName=''\n            filtered_metrics = [x for x in metrics if not x.dimensions.get(filter_key)]\n    else:\n        filtered_metrics = metrics\n    return filtered_metrics", "response": "List available billing metrics"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nlist running ec2 instances.", "response": "def list_cloudfront(region, filter_by_kwargs):\n    \"\"\"List running ec2 instances.\"\"\"\n    conn = boto.connect_cloudfront()\n    instances = conn.get_all_distributions()\n    return lookup(instances, filter_by=filter_by_kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef list_ec2(region, filter_by_kwargs):\n    conn = boto.ec2.connect_to_region(region)\n    instances = conn.get_only_instances()\n    return lookup(instances, filter_by=filter_by_kwargs)", "response": "List running ec2 instances."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef list_ebs(region, filter_by_kwargs):\n    conn = boto.ec2.connect_to_region(region)\n    instances = conn.get_all_volumes()\n    return lookup(instances, filter_by=filter_by_kwargs)", "response": "List running ebs volumes."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nlisting all load balancers in a region.", "response": "def list_elb(region, filter_by_kwargs):\n    \"\"\"List all load balancers.\"\"\"\n    conn = boto.ec2.elb.connect_to_region(region)\n    instances = conn.get_all_load_balancers()\n    return lookup(instances, filter_by=filter_by_kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nlists all RDS thingys in a given region.", "response": "def list_rds(region, filter_by_kwargs):\n    \"\"\"List all RDS thingys.\"\"\"\n    conn = boto.rds.connect_to_region(region)\n    instances = conn.get_all_dbinstances()\n    return lookup(instances, filter_by=filter_by_kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef list_elasticache(region, filter_by_kwargs):\n    conn = boto.elasticache.connect_to_region(region)\n    req = conn.describe_cache_clusters()\n    data = req[\"DescribeCacheClustersResponse\"][\"DescribeCacheClustersResult\"][\"CacheClusters\"]\n    if filter_by_kwargs:\n        clusters = [x['CacheClusterId'] for x in data if x[filter_by_kwargs.keys()[0]] == filter_by_kwargs.values()[0]]\n    else:\n        clusters = [x['CacheClusterId'] for x in data]\n    return clusters", "response": "List all ElastiCache Clusters in a given region."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef list_autoscaling_group(region, filter_by_kwargs):\n    conn = boto.ec2.autoscale.connect_to_region(region)\n    groups = conn.get_all_groups()\n    return lookup(groups, filter_by=filter_by_kwargs)", "response": "List all Auto Scaling Groups in a given region."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef list_sqs(region, filter_by_kwargs):\n    conn = boto.sqs.connect_to_region(region)\n    queues = conn.get_all_queues()\n    return lookup(queues, filter_by=filter_by_kwargs)", "response": "List all SQS Queues."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef list_kinesis_applications(region, filter_by_kwargs):\n    conn = boto.kinesis.connect_to_region(region)\n    streams = conn.list_streams()['StreamNames']\n    kinesis_streams = {}\n    for stream_name in streams:\n        shard_ids = []\n        shards = conn.describe_stream(stream_name)['StreamDescription']['Shards']\n        for shard in shards:\n            shard_ids.append(shard['ShardId'])\n        kinesis_streams[stream_name] = shard_ids\n    return kinesis_streams", "response": "List all the kinesis applications along with the shards for each stream"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nlisting all DynamoDB tables.", "response": "def list_dynamodb(region, filter_by_kwargs):\n    \"\"\"List all DynamoDB tables.\"\"\"\n    conn = boto.dynamodb.connect_to_region(region)\n    tables = conn.list_tables()\n    return lookup(tables, filter_by=filter_by_kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef register(self, callback_id: str, handler: Any, name: str = \"*\") -> None:\n        LOG.info(\"Registering %s, %s to %s\", callback_id, name, handler)\n        if name not in self._routes[callback_id]:\n            self._routes[callback_id][name] = []\n\n        self._routes[callback_id][name].append(handler)", "response": "Register a new handler for a specific action."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndispatch the given action.", "response": "def dispatch(self, action: Action) -> Any:\n        \"\"\"\n        Yields handlers matching the incoming :class:`slack.actions.Action` `callback_id`.\n\n        Args:\n            action: :class:`slack.actions.Action`\n\n        Yields:\n            handler\n        \"\"\"\n        LOG.debug(\"Dispatching action %s, %s\", action[\"type\"], action[\"callback_id\"])\n\n        if action[\"type\"] == \"interactive_message\":\n            yield from self._dispatch_interactive_message(action)\n        elif action[\"type\"] in (\"dialog_submission\", \"message_action\"):\n            yield from self._dispatch_action(action)\n        else:\n            raise UnknownActionType(action)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef comittoapi(api):\n    global USED_API\n    assert USED_API is None, \"committoapi called again!\"\n    check = [\"PyQt4\", \"PyQt5\", \"PySide\", \"PySide2\"]\n    assert api in [QT_API_PYQT5, QT_API_PYQT4, QT_API_PYSIDE, QT_API_PYSIDE2]\n    for name in check:\n        if name.lower() != api and name in sys.modules:\n            raise RuntimeError(\n                \"{} was already imported. Cannot commit to {}!\"\n                .format(name, api)\n            )\n    else:\n        api = _intern(api)\n        USED_API = api\n        AnyQt.__SELECTED_API = api\n        AnyQt.USED_API = api", "response": "Commit to the use of specified Qt api."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_metadata(dist):\n    if not dist.has_metadata('PKG-INFO'):\n        return\n\n    msg = email.message_from_string(dist.get_metadata('PKG-INFO'))\n    metadata = {}\n    for header in [l for l in msg._headers]:\n        metadata[header[0]] = header[1]\n\n    return metadata", "response": "Returns dictionary of metadata for given distribution"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nadds command - line options for this plugin.", "response": "def add_options(self, parser):\n        \"\"\"Add command-line options for this plugin.\n\n        The base plugin class adds --with-$name by default, used to enable the\n        plugin. \n        \"\"\"\n        parser.add_option(\"--with-%s\" % self.name,\n                          action=\"store_true\",\n                          dest=self.enable_opt,\n                          help=\"Enable plugin %s: %s\" %\n                          (self.__class__.__name__, self.help())\n                          )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef configure(self, options, conf):\n        self.conf = conf\n        if hasattr(options, self.enable_opt):\n            self.enabled = getattr(options, self.enable_opt)", "response": "Configure the base plugin and system based on selected options."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns help for this plugin.", "response": "def help(self):\n        \"\"\"Return help for this plugin. This will be output as the help\n        section of the --with-$name option that enables the plugin.\n        \"\"\"\n        if self.__class__.__doc__:\n            # doc sections are often indented; compress the spaces\n            return textwrap.dedent(self.__class__.__doc__)\n        return \"(no help available)\""}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef raise_for_status(\n    status: int, headers: MutableMapping, data: MutableMapping\n) -> None:\n    \"\"\"\n    Check request response status\n\n    Args:\n        status: Response status\n        headers: Response headers\n        data: Response data\n\n    Raises:\n        :class:`slack.exceptions.RateLimited`: For 429 status code\n        :class:`slack.exceptions:HTTPException`:\n    \"\"\"\n    if status != 200:\n        if status == 429:\n\n            if isinstance(data, str):\n                error = data\n            else:\n                error = data.get(\"error\", \"ratelimited\")\n\n            try:\n                retry_after = int(headers.get(\"Retry-After\", 1))\n            except ValueError:\n                retry_after = 1\n            raise exceptions.RateLimited(retry_after, error, status, headers, data)\n        else:\n            raise exceptions.HTTPException(status, headers, data)", "response": "Raise an exception for the status code."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nchecks request response for Slack API error and raise exception if not ok", "response": "def raise_for_api_error(headers: MutableMapping, data: MutableMapping) -> None:\n    \"\"\"\n    Check request response for Slack API error\n\n    Args:\n        headers: Response headers\n        data: Response data\n\n    Raises:\n        :class:`slack.exceptions.SlackAPIError`\n    \"\"\"\n\n    if not data[\"ok\"]:\n        raise exceptions.SlackAPIError(data.get(\"error\", \"unknow_error\"), headers, data)\n\n    if \"warning\" in data:\n        LOG.warning(\"Slack API WARNING: %s\", data[\"warning\"])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ndecoding the response body for application / json content - type load the body as a dictionary", "response": "def decode_body(headers: MutableMapping, body: bytes) -> dict:\n    \"\"\"\n    Decode the response body\n\n    For 'application/json' content-type load the body as a dictionary\n\n    Args:\n        headers: Response headers\n        body: Response body\n\n    Returns:\n        decoded body\n    \"\"\"\n\n    type_, encoding = parse_content_type(headers)\n    decoded_body = body.decode(encoding)\n\n    # There is one api that just returns `ok` instead of json. In order to have a consistent API we decided to modify the returned payload into a dict.\n    if type_ == \"application/json\":\n        payload = json.loads(decoded_body)\n    else:\n        if decoded_body == \"ok\":\n            payload = {\"ok\": True}\n        else:\n            payload = {\"ok\": False, \"data\": decoded_body}\n\n    return payload"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef parse_content_type(headers: MutableMapping) -> Tuple[Optional[str], str]:\n    content_type = headers.get(\"content-type\")\n    if not content_type:\n        return None, \"utf-8\"\n    else:\n        type_, parameters = cgi.parse_header(content_type)\n        encoding = parameters.get(\"charset\", \"utf-8\")\n        return type_, encoding", "response": "Parse the content - type and encoding of the response."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef prepare_request(\n    url: Union[str, methods],\n    data: Optional[MutableMapping],\n    headers: Optional[MutableMapping],\n    global_headers: MutableMapping,\n    token: str,\n    as_json: Optional[bool] = None,\n) -> Tuple[str, Union[str, MutableMapping], MutableMapping]:\n    \"\"\"\n    Prepare outgoing request\n\n    Create url, headers, add token to the body and if needed json encode it\n\n    Args:\n        url: :class:`slack.methods` item or string of url\n        data: Outgoing data\n        headers: Custom headers\n        global_headers: Global headers\n        token: Slack API token\n        as_json: Post JSON to the slack API\n    Returns:\n        :py:class:`tuple` (url, body, headers)\n    \"\"\"\n\n    if isinstance(url, methods):\n        as_json = as_json or url.value[3]\n        real_url = url.value[0]\n    else:\n        real_url = url\n        as_json = False\n\n    if not headers:\n        headers = {**global_headers}\n    else:\n        headers = {**global_headers, **headers}\n\n    payload: Optional[Union[str, MutableMapping]] = None\n    if real_url.startswith(HOOK_URL) or (real_url.startswith(ROOT_URL) and as_json):\n        payload, headers = _prepare_json_request(data, token, headers)\n    elif real_url.startswith(ROOT_URL) and not as_json:\n        payload = _prepare_form_encoded_request(data, token)\n    else:\n        real_url = ROOT_URL + real_url\n        payload = _prepare_form_encoded_request(data, token)\n\n    return real_url, payload, headers", "response": "Prepare outgoing request for slack API"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ndecode incoming response into a dict.", "response": "def decode_response(status: int, headers: MutableMapping, body: bytes) -> dict:\n    \"\"\"\n    Decode incoming response\n\n    Args:\n        status: Response status\n        headers: Response headers\n        body: Response body\n\n    Returns:\n        Response data\n    \"\"\"\n    data = decode_body(headers, body)\n    raise_for_status(status, headers, data)\n    raise_for_api_error(headers, data)\n\n    return data"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef find_iteration(\n    url: Union[methods, str],\n    itermode: Optional[str] = None,\n    iterkey: Optional[str] = None,\n) -> Tuple[str, str]:\n    \"\"\"\n    Find iteration mode and iteration key for a given :class:`slack.methods`\n\n    Args:\n        url: :class:`slack.methods` or string url\n        itermode: Custom iteration mode\n        iterkey: Custom iteration key\n\n    Returns:\n        :py:class:`tuple` (itermode, iterkey)\n    \"\"\"\n    if isinstance(url, methods):\n        if not itermode:\n            itermode = url.value[1]\n        if not iterkey:\n            iterkey = url.value[2]\n\n    if not iterkey or not itermode:\n        raise ValueError(\"Iteration not supported for: {}\".format(url))\n    elif itermode not in ITERMODE:\n        raise ValueError(\"Iteration not supported for: {}\".format(itermode))\n\n    return itermode, iterkey", "response": "Find iteration mode and iteration key for a given url."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef prepare_iter_request(\n    url: Union[methods, str],\n    data: MutableMapping,\n    *,\n    iterkey: Optional[str] = None,\n    itermode: Optional[str] = None,\n    limit: int = 200,\n    itervalue: Optional[Union[str, int]] = None,\n) -> Tuple[MutableMapping, str, str]:\n    \"\"\"\n    Prepare outgoing iteration request\n\n    Args:\n        url: :class:`slack.methods` item or string of url\n        data: Outgoing data\n        limit: Maximum number of results to return per call.\n        iterkey: Key in response data to iterate over (required for url string).\n        itermode: Iteration mode (required for url string) (one of `cursor`, `page` or `timeline`)\n        itervalue: Value for current iteration (cursor hash, page or timestamp depending on the itermode)\n    Returns:\n        :py:class:`tuple` (data, iterkey, itermode)\n    \"\"\"\n    itermode, iterkey = find_iteration(url, itermode, iterkey)\n\n    if itermode == \"cursor\":\n        data[\"limit\"] = limit\n        if itervalue:\n            data[\"cursor\"] = itervalue\n    elif itermode == \"page\":\n        data[\"count\"] = limit\n        if itervalue:\n            data[\"page\"] = itervalue\n    elif itermode == \"timeline\":\n        data[\"count\"] = limit\n        if itervalue:\n            data[\"latest\"] = itervalue\n\n    return data, iterkey, itermode", "response": "Prepare outgoing iteration request."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef decode_iter_request(data: dict) -> Optional[Union[str, int]]:\n    if \"response_metadata\" in data:\n        return data[\"response_metadata\"].get(\"next_cursor\")\n    elif \"paging\" in data:\n        current_page = int(data[\"paging\"].get(\"page\", 1))\n        max_page = int(data[\"paging\"].get(\"pages\", 1))\n\n        if current_page < max_page:\n            return current_page + 1\n    elif \"has_more\" in data and data[\"has_more\"] and \"latest\" in data:\n        return data[\"messages\"][-1][\"ts\"]\n\n    return None", "response": "Decode incoming response from an iteration request"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef discard_event(event: events.Event, bot_id: str = None) -> bool:\n    if event[\"type\"] in SKIP_EVENTS:\n        return True\n    elif bot_id and isinstance(event, events.Message):\n        if event.get(\"bot_id\") == bot_id:\n            LOG.debug(\"Ignoring event: %s\", event)\n            return True\n        elif \"message\" in event and event[\"message\"].get(\"bot_id\") == bot_id:\n            LOG.debug(\"Ignoring event: %s\", event)\n            return True\n    return False", "response": "Check if the incoming event needs to be discarded"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef validate_request_signature(\n    body: str, headers: MutableMapping, signing_secret: str\n) -> None:\n    \"\"\"\n    Validate incoming request signature using the application signing secret.\n\n    Contrary to the ``team_id`` and ``verification_token`` verification this method is not called by ``slack-sansio`` when creating object from incoming HTTP request. Because the body of the request needs to be provided as text and not decoded as json beforehand.\n\n    Args:\n        body: Raw request body\n        headers: Request headers\n        signing_secret: Application signing_secret\n\n    Raise:\n        :class:`slack.exceptions.InvalidSlackSignature`: when provided and calculated signature do not match\n        :class:`slack.exceptions.InvalidTimestamp`: when incoming request timestamp is more than 5 minutes old\n    \"\"\"\n\n    request_timestamp = int(headers[\"X-Slack-Request-Timestamp\"])\n\n    if (int(time.time()) - request_timestamp) > (60 * 5):\n        raise exceptions.InvalidTimestamp(timestamp=request_timestamp)\n\n    slack_signature = headers[\"X-Slack-Signature\"]\n    calculated_signature = (\n        \"v0=\"\n        + hmac.new(\n            signing_secret.encode(\"utf-8\"),\n            f\"\"\"v0:{headers[\"X-Slack-Request-Timestamp\"]}:{body}\"\"\".encode(\"utf-8\"),\n            digestmod=hashlib.sha256,\n        ).hexdigest()\n    )\n\n    if not hmac.compare_digest(slack_signature, calculated_signature):\n        raise exceptions.InvalidSlackSignature(slack_signature, calculated_signature)", "response": "Validate incoming request signature using the application signing secret."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef backup(mongo_username, mongo_password, local_backup_directory_path, database=None,\r\n           attached_directory_path=None, custom_prefix=\"backup\",\r\n           mongo_backup_directory_path=\"/tmp/mongo_dump\",\r\n           s3_bucket=None, s3_access_key_id=None, s3_secret_key=None,\r\n           purge_local=None, purge_attached=None, cleanup=True, silent=False):\r\n    \"\"\"\r\n    Runs a backup operation to At Least a local directory.\r\n    You must provide mongodb credentials along with a a directory for a dump\r\n    operation and a directory to contain your compressed backup.\r\n    \r\n        backup_prefix: optionally provide a prefix to be prepended to your backups,\r\n            by default the prefix is \"backup\".\r\n        database: optionally provide the name of one specific database to back up\r\n            (instead of backing up all databases on the MongoDB server)\r\n        attached_directory_path: makes a second copy of the backup to a different\r\n            directory.  This directory is checked before other operations and\r\n            will raise an error if it cannot be found.\r\n        s3_bucket: if you have an Amazon Web Services S3 account you can\r\n            automatically upload the backup to an S3 Bucket you provide;\r\n            requires s3_access_key_id and s3_secret key to be passed as well\r\n        s3_access_key_id, s3_secret_key: credentials for your AWS account.\r\n        purge_local: An integer value, the number of days of backups to purge\r\n            from local_backup_directory_path after operations have completed.\r\n        purge_attached: An integer value, the number of days of backups to purge\r\n            from attached_directory_path after operations have completed.\r\n        cleanup: set to False to leave the mongo_backup_directory_path after operations\r\n            have completed.\r\n    \"\"\"\r\n    \r\n    if attached_directory_path:\r\n        if not path.exists(attached_directory_path):\r\n            raise Exception(\"ERROR.  Would have to create %s for your attached storage, make sure that file paths already exist and re-run\"\r\n                            % (attached_directory_path))\r\n    \r\n    # Dump mongo, tarbz, copy to attached storage, upload to s3, purge, clean.\r\n    full_file_name_path = local_backup_directory_path + custom_prefix + time_string()\r\n    mongodump(mongo_username, mongo_password, mongo_backup_directory_path, database, silent=silent)\r\n    \r\n    local_backup_file = tarbz(mongo_backup_directory_path, full_file_name_path, silent=silent)\r\n    \r\n    if attached_directory_path:\r\n        copy(local_backup_file, attached_directory_path + local_backup_file.split(\"/\")[-1])\r\n    \r\n    if s3_bucket:\r\n        s3_upload(local_backup_file, s3_bucket, s3_access_key_id, s3_secret_key)\r\n    \r\n    if purge_local:\r\n        purge_date = (datetime.utcnow().replace(second=0, microsecond=0) -\r\n                       timedelta(days=purge_local))\r\n        purge_old_files(purge_date, local_backup_directory_path, custom_prefix=custom_prefix)\r\n    \r\n    if purge_attached and attached_directory_path:\r\n        purge_date = (datetime.utcnow().replace(second=0, microsecond=0) -\r\n                       timedelta(days=purge_attached))\r\n        purge_old_files(purge_date, attached_directory_path, custom_prefix=custom_prefix)\r\n    \r\n    if cleanup:\r\n        rmtree(mongo_backup_directory_path)", "response": "Creates a backup of the specified database and optionally deletes the backup from the specified directory."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nrestores a single mongorestore file.", "response": "def restore(mongo_user, mongo_password, backup_tbz_path,\r\n            backup_directory_output_path=\"/tmp/mongo_dump\",\r\n            drop_database=False, cleanup=True, silent=False,\r\n            skip_system_and_user_files=False):\r\n    \"\"\"\r\n    Runs mongorestore with source data from the provided .tbz backup, using\r\n    the provided username and password.\r\n    The contents of the .tbz will be dumped into the provided backup directory,\r\n    and that folder will be deleted after a successful mongodb restore unless\r\n    cleanup is set to False.\r\n    \r\n    Note: the skip_system_and_user_files is intended for use with the changes\r\n    in user architecture introduced in mongodb version 2.6.\r\n    \r\n    Warning: Setting drop_database to True will drop the ENTIRE\r\n    CURRENTLY RUNNING DATABASE before restoring.\r\n    \r\n    Mongorestore requires a running mongod process, in addition the provided\r\n    user must have restore permissions for the database.  A mongolia superuser\r\n    will have more than adequate permissions, but a regular user may not.\r\n    By default this function will clean up the output of the untar operation.\r\n    \"\"\"\r\n    if not path.exists(backup_tbz_path):\r\n        raise Exception(\"the provided tar file %s does not exist.\" % (backup_tbz_path))\r\n    \r\n    untarbz(backup_tbz_path, backup_directory_output_path, silent=silent)\r\n    \r\n    if skip_system_and_user_files:\r\n        system_and_users_path = \"%s/admin\" % backup_directory_output_path\r\n        if path.exists(system_and_users_path):\r\n            rmtree(system_and_users_path)\r\n    \r\n    mongorestore(mongo_user, mongo_password, backup_directory_output_path,\r\n                 drop_database=drop_database, silent=silent)\r\n    if cleanup:\r\n        rmtree(backup_directory_output_path)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nrunning mongodump on the provided credentials on the running mongodump process.", "response": "def mongodump(mongo_user, mongo_password, mongo_dump_directory_path, database=None, silent=False):\r\n    \"\"\" Runs mongodump using the provided credentials on the running mongod\r\n        process.\r\n        \r\n        WARNING: This function will delete the contents of the provided\r\n        directory before it runs. \"\"\"\r\n    if path.exists(mongo_dump_directory_path):\r\n        # If a backup dump already exists, delete it\r\n        rmtree(mongo_dump_directory_path)\r\n    if silent:\r\n        dump_command = (\"mongodump --quiet -u %s -p %s -o %s\"\r\n                        % (mongo_user, mongo_password, mongo_dump_directory_path))\r\n    else:\r\n        dump_command = (\"mongodump -u %s -p %s -o %s\"\r\n                        % (mongo_user, mongo_password, mongo_dump_directory_path))\r\n    if database:\r\n        dump_command += (\" --db %s\" % database)\r\n    call(dump_command, silent=silent)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_backup_file_time_tag(file_name, custom_prefix=\"backup\"):\r\n    name_string = file_name[len(custom_prefix):]\r\n    time_tag = name_string.split(\".\", 1)[0]\r\n    return datetime.strptime(time_tag, DATETIME_FORMAT)", "response": "Returns a datetime object computed from a file name string with a datetime object formatted based on DATETIME_FORMAT."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef purge_old_files(date_time, directory_path, custom_prefix=\"backup\"):\r\n    for file_name in listdir(directory_path):\r\n        try:\r\n            file_date_time = get_backup_file_time_tag(file_name, custom_prefix=custom_prefix)\r\n        except ValueError as e:\r\n            if \"does not match format\" in e.message:\r\n                print(\"WARNING. file(s) in %s do not match naming convention.\"\r\n                      % (directory_path))\r\n                continue\r\n            raise e\r\n        if file_date_time < date_time:\r\n            remove(directory_path + file_name)", "response": "Removes all files in the specified directory that are older than the provided datetime."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets a download URI for a package.", "response": "def get_download_uri(package_name, version, source, index_url=None):\n\n    \"\"\"\n    Use setuptools to search for a package's URI\n\n    @returns: URI string\n    \"\"\"\n    tmpdir = None\n    force_scan = True\n    develop_ok = False\n    if not index_url:\n        index_url = 'http://cheeseshop.python.org/pypi'\n\n    if version:\n        pkg_spec = \"%s==%s\" % (package_name, version)\n    else:\n        pkg_spec = package_name\n    req = pkg_resources.Requirement.parse(pkg_spec)\n    pkg_index = MyPackageIndex(index_url)\n    try:\n        pkg_index.fetch_distribution(req, tmpdir, force_scan, source,\n                develop_ok)\n    except DownloadURI as url:\n        #Remove #egg=pkg-dev\n        clean_url = url.value.split(\"#\")[0]\n        #If setuptools is asked for an egg and there isn't one, it will\n        #return source if available, which we don't want.\n        if not source and not clean_url.endswith(\".egg\") and \\\n                not clean_url.endswith(\".EGG\"):\n            return\n        else:\n            return clean_url"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning list of all installed packages", "response": "def get_pkglist():\n    \"\"\"\n    Return list of all installed packages\n\n    Note: It returns one project name per pkg no matter how many versions\n    of a particular package is installed\n\n    @returns: list of project name strings for every installed pkg\n\n    \"\"\"\n\n    dists = Distributions()\n    projects = []\n    for (dist, _active) in dists.get_distributions(\"all\"):\n        if dist.project_name not in projects:\n            projects.append(dist.project_name)\n    return projects"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef register(self, command: str, handler: Any):\n\n        if not command.startswith(\"/\"):\n            command = f\"/{command}\"\n\n        LOG.info(\"Registering %s to %s\", command, handler)\n        self._routes[command].append(handler)", "response": "Register a new handler for a specific command"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef dispatch(self, command: Command) -> Iterator[Any]:\n        LOG.debug(\"Dispatching command %s\", command[\"command\"])\n        for callback in self._routes[command[\"command\"]]:\n            yield callback", "response": "Dispatches the given command to the registered handlers."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef setpreferredapi(api):\n    global __PREFERRED_API\n    if __SELECTED_API is not None:\n        raise RuntimeError(\"A Qt api {} was already selected\"\n                           .format(__SELECTED_API))\n\n    if api.lower() not in {\"pyqt4\", \"pyqt5\", \"pyside\", \"pyside2\"}:\n        raise ValueError(api)\n    __PREFERRED_API = api.lower()", "response": "Sets the preferred Qt API."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nselecting an API to use.", "response": "def selectapi(api):\n    \"\"\"\n    Select an Qt API to use.\n\n    This can only be set once and before any of the Qt modules are explicitly\n    imported.\n    \"\"\"\n    global __SELECTED_API, USED_API\n    if api.lower() not in {\"pyqt4\", \"pyqt5\", \"pyside\", \"pyside2\"}:\n        raise ValueError(api)\n\n    if __SELECTED_API is not None and __SELECTED_API.lower() != api.lower():\n        raise RuntimeError(\"A Qt API {} was already selected\"\n                           .format(__SELECTED_API))\n    elif __SELECTED_API is None:\n        __SELECTED_API = api.lower()\n        from . import _api\n        USED_API = _api.USED_API"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the highest available version for a package in a list of versions", "response": "def get_highest_version(versions):\n    \"\"\"\n    Returns highest available version for a package in a list of versions\n    Uses pkg_resources to parse the versions\n\n    @param versions: List of PyPI package versions\n    @type versions: List of strings\n\n    @returns: string of a PyPI package version\n\n\n    \"\"\"\n    sorted_versions = []\n    for ver in versions:\n        sorted_versions.append((pkg_resources.parse_version(ver), ver))\n\n    sorted_versions = sorted(sorted_versions)\n    sorted_versions.reverse()\n    return sorted_versions[0][1]"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_distributions(self, show, pkg_name=\"\", version=\"\"):\n        #pylint: disable-msg=W0612\n        #'name' is a placeholder for the sorted list\n        for name, dist in self.get_alpha(show, pkg_name, version):\n            ver = dist.version\n            for package in self.environment[dist.project_name]:\n                if ver == package.version:\n                    if show == \"nonactive\" and dist not in self.working_set:\n                        yield (dist, self.query_activated(dist))\n                    elif show == \"active\" and dist in self.working_set:\n                        yield (dist, self.query_activated(dist))\n                    elif show == \"all\":\n                        yield (dist, self.query_activated(dist))", "response": "Yields installed packages and True or False depending on active state."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_alpha(self, show, pkg_name=\"\", version=\"\"):\n        alpha_list = []\n        for dist in self.get_packages(show):\n            if pkg_name and dist.project_name != pkg_name:\n                #Only checking for a single package name\n                pass\n            elif version and dist.version != version:\n                #Only checking for a single version of a package\n                pass\n            else:\n                alpha_list.append((dist.project_name + dist.version, dist))\n        alpha_list.sort()\n        return alpha_list", "response": "Returns a list of alphabetized packages that contain the same name and version."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_packages(self, show):\n\n\n        if show == 'nonactive' or show == \"all\":\n            all_packages = []\n            for package in self.environment:\n                #There may be multiple versions of same packages\n                for i in range(len(self.environment[package])):\n                    if self.environment[package][i]:\n                        all_packages.append(self.environment[package][i])\n            return all_packages\n        else:\n            # Only activated packages\n            return self.working_set", "response": "Return list of pkg_resources Distributions filtered by active status or all status"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn case - sensitive name given any - case package name.", "response": "def case_sensitive_name(self, package_name):\n        \"\"\"\n        Return case-sensitive package name given any-case package name\n\n        @param project_name: PyPI project name\n        @type project_name: string\n\n        \"\"\"\n        if len(self.environment[package_name]):\n            return self.environment[package_name][0].project_name"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef cache_incr(self, key):\n        cache.set(key, cache.get(key, 0) + 1, self.expire_after())", "response": "Non - atomic increment operation. Not optimal but\n consistent across different cache backends."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef call_plugins(plugins, method, *arg, **kw):\n    for plug in plugins:\n        func = getattr(plug, method, None)\n        if func is None:\n            continue\n        #LOG.debug(\"call plugin %s: %s\", plug.name, method)\n        result = func(*arg, **kw)\n        if result is not None:\n            return result\n    return None", "response": "Call all method on plugins in list that define it with provided\n    arguments."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nloads plugins either builtin or others.", "response": "def load_plugins(builtin=True, others=True):\n    \"\"\"Load plugins, either builtin, others, or both.\n    \"\"\"\n    for entry_point in pkg_resources.iter_entry_points('yolk.plugins'):\n        #LOG.debug(\"load plugin %s\" % entry_point)\n        try:\n            plugin = entry_point.load()\n        except KeyboardInterrupt:\n            raise\n        except Exception as err_msg:\n            # never want a plugin load to exit yolk\n            # but we can't log here because the logger is not yet\n            # configured\n            warn(\"Unable to load plugin %s: %s\" % \\\n                    (entry_point, err_msg), RuntimeWarning)\n            continue\n        if plugin.__module__.startswith('yolk.plugins'):\n            if builtin:\n                yield plugin\n        elif others:\n            yield plugin"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef s3_connect(bucket_name, s3_access_key_id, s3_secret_key):\n    conn = connect_s3(s3_access_key_id, s3_secret_key)\n    try:\n        return conn.get_bucket(bucket_name)\n    except S3ResponseError as e:\n        if e.status == 403:\n            raise Exception(\"Bad Amazon S3 credentials.\")\n        raise", "response": "Connect to the provided S3 bucket and return a Boto object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nlist the contents of the S3 bucket that end in. tbz and match the passed prefix.", "response": "def s3_list(s3_bucket, s3_access_key_id, s3_secret_key, prefix=None):\n    \"\"\" Lists the contents of the S3 bucket that end in .tbz and match\n        the passed prefix, if any. \"\"\"\n    bucket = s3_connect(s3_bucket, s3_access_key_id, s3_secret_key)\n    return sorted([key.name for key in bucket.list()\n                   if key.name.endswith(\".tbz\")\n                   and (prefix is None or key.name.startswith(prefix))])"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ndownloading the file matching the provided key in the provided bucket and writes it to the provided path.", "response": "def s3_download(output_file_path, s3_bucket, s3_access_key_id, s3_secret_key,\n                s3_file_key=None, prefix=None):\n    \"\"\" Downloads the file matching the provided key, in the provided bucket,\n        from Amazon S3.\n        \n        If s3_file_key is none, it downloads the last file\n        from the provided bucket with the .tbz extension, filtering by\n        prefix if it is provided. \"\"\"\n    bucket = s3_connect(s3_bucket, s3_access_key_id, s3_secret_key)\n    if not s3_file_key:\n        keys = s3_list(s3_bucket, s3_access_key_id, s3_secret_key, prefix)\n        if not keys:\n            raise Exception(\"Target S3 bucket is empty\")\n        s3_file_key = keys[-1]\n    key = Key(bucket, s3_file_key)\n    with open(output_file_path, \"w+\") as f:\n        f.write(key.read())"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nupload the contents of the file to Amazon S3.", "response": "def s3_upload(source_file_path, bucket_name, s3_access_key_id, s3_secret_key):\n    \"\"\" Uploads the to Amazon S3 the contents of the provided file, keyed\n        with the name of the file. \"\"\"\n    key = s3_key(bucket_name, s3_access_key_id, s3_secret_key)\n    file_name = source_file_path.split(\"/\")[-1]\n    key.key = file_name\n    if key.exists():\n        raise Exception(\"s3 key %s already exists for current period.\"\n                        % (file_name))\n    key.set_contents_from_filename(source_file_path)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nfixes the itemChange method of PyQt5 QGraphicsItem. itemChange to return the new version of the object.", "response": "def fix_pyqt5_QGraphicsItem_itemChange():\n    \"\"\"\n    Attempt to remedy:\n    https://www.riverbankcomputing.com/pipermail/pyqt/2016-February/037015.html\n    \"\"\"\n    from PyQt5.QtWidgets import QGraphicsObject, QGraphicsItem\n\n    class Obj(QGraphicsObject):\n        def itemChange(self, change, value):\n            return QGraphicsObject.itemChange(self, change, value)\n\n    obj = Obj()\n    parent = Obj()\n    obj.setParentItem(parent)\n\n    if obj.parentItem() is None:\n        # There was probably already some signal defined using QObject's\n        # subclass from QtWidgets.\n        # We will monkey patch the QGraphicsItem.itemChange and explicitly\n        # sip.cast all input and output QGraphicsItem instances\n        import sip\n        QGraphicsItem_itemChange_old = QGraphicsItem.itemChange\n\n        # All the QGraphicsItem.ItemChange flags which accept/return\n        # a QGraphicsItem\n        changeset = {\n            QGraphicsItem.ItemParentChange,\n            QGraphicsItem.ItemParentHasChanged,\n            QGraphicsItem.ItemChildAddedChange,\n            QGraphicsItem.ItemChildRemovedChange,\n        }\n\n        def QGraphicsItem_itemChange(self, change, value):\n            if change in changeset:\n                if isinstance(value, QGraphicsItem):\n                    value = sip.cast(value, QGraphicsItem)\n                rval = QGraphicsItem_itemChange_old(self, change, value)\n                if isinstance(rval, QGraphicsItem):\n                    rval = sip.cast(rval, QGraphicsItem)\n                return rval\n            else:\n                return QGraphicsItem_itemChange_old(self, change, value)\n\n        QGraphicsItem.itemChange = QGraphicsItem_itemChange\n        warnings.warn(\"Monkey patching QGraphicsItem.itemChange\",\n                      RuntimeWarning)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef validate_pypi_opts(opt_parser):\n\n    (options, remaining_args) = opt_parser.parse_args()\n    options_pkg_specs = [ options.versions_available,\n            options.query_metadata_pypi,\n            options.show_download_links,\n            options.browse_website,\n            options.fetch,\n            options.show_deps,\n            ]\n    for pkg_spec in options_pkg_specs:\n        if pkg_spec:\n            return pkg_spec", "response": "Check parse options that require pkg_spec"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nwrite a line to stdout if it isn t in the blacklist", "response": "def write(self, inline):\n        \"\"\"\n        Write a line to stdout if it isn't in a blacklist\n\n        Try to get the name of the calling module to see if we want\n        to filter it. If there is no calling module, use current\n        frame in case there's a traceback before there is any calling module\n        \"\"\"\n        frame = inspect.currentframe().f_back\n        if frame:\n            mod = frame.f_globals.get('__name__')\n        else:\n            mod = sys._getframe(0).f_globals.get('__name__')\n        if not mod in self.modulenames:\n            self.stdout.write(inline)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting all available plugins with the given method.", "response": "def get_plugin(self, method):\n        \"\"\"\n        Return plugin object if CLI option is activated and method exists\n\n        @param method: name of plugin's method we're calling\n        @type method: string\n\n        @returns: list of plugins with `method`\n\n        \"\"\"\n        all_plugins = []\n        for entry_point in pkg_resources.iter_entry_points('yolk.plugins'):\n            plugin_obj = entry_point.load()\n            plugin = plugin_obj()\n            plugin.configure(self.options, None)\n            if plugin.enabled:\n                if not hasattr(plugin, method):\n                    self.logger.warn(\"Error: plugin has no method: %s\" % method)\n                    plugin = None\n                else:\n                    all_plugins.append(plugin)\n        return all_plugins"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set_log_level(self):\n\n        if self.options.debug:\n            self.logger.setLevel(logging.DEBUG)\n        elif self.options.quiet:\n            self.logger.setLevel(logging.ERROR)\n        else:\n            self.logger.setLevel(logging.INFO)\n        self.logger.addHandler(logging.StreamHandler())\n        return self.logger", "response": "Set log level according to command - line options\n           "}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef run(self):\n        opt_parser = setup_opt_parser()\n        (self.options, remaining_args) = opt_parser.parse_args()\n        logger = self.set_log_level()\n\n        pkg_spec = validate_pypi_opts(opt_parser)\n        if not pkg_spec:\n            pkg_spec = remaining_args\n        self.pkg_spec = pkg_spec\n\n        if not self.options.pypi_search and (len(sys.argv) == 1 or\\\n                len(remaining_args) > 2):\n            opt_parser.print_help()\n            return 2\n\n        #Options that depend on querying installed packages, not PyPI.\n        #We find the proper case for package names if they are installed,\n        #otherwise PyPI returns the correct case.\n        if self.options.show_deps or self.options.show_all or \\\n                self.options.show_active or self.options.show_non_active  or \\\n                (self.options.show_updates and pkg_spec):\n            want_installed = True\n        else:\n            want_installed = False\n        #show_updates may or may not have a pkg_spec\n        if not want_installed or self.options.show_updates:\n            self.pypi = CheeseShop(self.options.debug)\n            #XXX: We should return 2 here if we couldn't create xmlrpc server\n\n        if pkg_spec:\n            (self.project_name, self.version, self.all_versions) = \\\n                    self.parse_pkg_ver(want_installed)\n            if want_installed and not self.project_name:\n                logger.error(\"%s is not installed.\" % pkg_spec[0])\n                return 1\n\n        #I could prefix all these with 'cmd_' and the methods also\n        #and then iterate over the `options` dictionary keys...\n        commands = ['show_deps', 'query_metadata_pypi', 'fetch',\n                'versions_available', 'show_updates', 'browse_website',\n                'show_download_links', 'pypi_search', 'show_pypi_changelog',\n                'show_pypi_releases', 'yolk_version', 'show_all',\n                'show_active', 'show_non_active', 'show_entry_map',\n                'show_entry_points']\n\n        #Run first command it finds, and only the first command, then return\n        #XXX: Check if more than one command was set in options and give error?\n        for action in commands:\n            if getattr(self.options, action):\n                return getattr(self, action)()\n        opt_parser.print_help()", "response": "Perform actions based on CLI options and return status code."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef show_updates(self):\n        dists = Distributions()\n        if self.project_name:\n            #Check for a single package\n            pkg_list = [self.project_name]\n        else:\n            #Check for every installed package\n            pkg_list = get_pkglist()\n        found = None\n        for pkg in pkg_list:\n            for (dist, active) in dists.get_distributions(\"all\", pkg,\n                    dists.get_highest_installed(pkg)):\n                (project_name, versions) = \\\n                        self.pypi.query_versions_pypi(dist.project_name)\n                if versions:\n\n                    #PyPI returns them in chronological order,\n                    #but who knows if its guaranteed in the API?\n                    #Make sure we grab the highest version:\n\n                    newest = get_highest_version(versions)\n                    if newest != dist.version:\n\n                        #We may have newer than what PyPI knows about\n\n                        if pkg_resources.parse_version(dist.version) < \\\n                            pkg_resources.parse_version(newest):\n                            found = True\n                            print(\" %s %s (%s)\" % (project_name, dist.version,\n                                    newest))\n        if not found and self.project_name:\n            self.logger.info(\"You have the latest version installed.\")\n        elif not found:\n            self.logger.info(\"No newer packages found at The Cheese Shop\")\n        return 0", "response": "Show the available updates on PyPI and the latest version installed."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nshowing list of installed activated or non - activated packages", "response": "def show_distributions(self, show):\n        \"\"\"\n        Show list of installed activated OR non-activated packages\n\n        @param show: type of pkgs to show (all, active or nonactive)\n        @type show: string\n\n        @returns: None or 2 if error\n        \"\"\"\n        show_metadata = self.options.metadata\n\n        #Search for any plugins with active CLI options with add_column() method\n        plugins = self.get_plugin(\"add_column\")\n\n        #Some locations show false positive for 'development' packages:\n        ignores = [\"/UNIONFS\", \"/KNOPPIX.IMG\"]\n\n        #Check if we're in a workingenv\n        #See http://cheeseshop.python.org/pypi/workingenv.py\n        workingenv = os.environ.get('WORKING_ENV')\n        if workingenv:\n            ignores.append(workingenv)\n\n        dists = Distributions()\n        results = None\n        for (dist, active) in dists.get_distributions(show, self.project_name,\n                self.version):\n            metadata = get_metadata(dist)\n            for prefix in ignores:\n                if dist.location.startswith(prefix):\n                    dist.location = dist.location.replace(prefix, \"\")\n            #Case-insensitve search because of Windows\n            if dist.location.lower().startswith(get_python_lib().lower()):\n                develop = \"\"\n            else:\n                develop = dist.location\n            if metadata:\n                add_column_text = \"\"\n                for my_plugin in plugins:\n                    #See if package is 'owned' by a package manager such as\n                    #portage, apt, rpm etc.\n                    #add_column_text += my_plugin.add_column(filename) + \" \"\n                    add_column_text += my_plugin.add_column(dist) + \" \"\n                self.print_metadata(metadata, develop, active, add_column_text)\n            else:\n                print(str(dist) + \" has no metadata\")\n            results = True\n        if not results and self.project_name:\n            if self.version:\n                pkg_spec = \"%s==%s\" % (self.project_name, self.version)\n            else:\n                pkg_spec = \"%s\" % self.project_name\n            if show == \"all\":\n                self.logger.error(\"There are no versions of %s installed.\" \\\n                        % pkg_spec)\n            else:\n                self.logger.error(\"There are no %s versions of %s installed.\" \\\n                        % \\\n                        (show, pkg_spec))\n            return 2\n        elif show == \"all\" and results and self.options.fields:\n            print(\"Versions with '*' are non-active.\")\n            print(\"Versions with '!' are deployed in development mode.\")"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nprint out formatted metadata for a single package.", "response": "def print_metadata(self, metadata, develop, active, installed_by):\n        \"\"\"\n        Print out formatted metadata\n        @param metadata: package's metadata\n        @type metadata:  pkg_resources Distribution obj\n\n        @param develop: path to pkg if its deployed in development mode\n        @type develop: string\n\n        @param active: show if package is activated or not\n        @type active: boolean\n\n        @param installed_by: Shows if pkg was installed by a package manager other\n                             than setuptools\n        @type installed_by: string\n\n        @returns: None\n\n        \"\"\"\n        show_metadata = self.options.metadata\n        if self.options.fields:\n            fields = self.options.fields.split(',')\n            fields = map(str.strip, fields)\n        else:\n            fields = []\n        version = metadata['Version']\n\n        #When showing all packages, note which are not active:\n        if active:\n            if fields:\n                active_status = \"\"\n            else:\n                active_status = \"active\"\n        else:\n            if fields:\n                active_status = \"*\"\n            else:\n                active_status = \"non-active\"\n        if develop:\n            if fields:\n                development_status = \"! (%s)\" % develop\n            else:\n                development_status = \"development (%s)\" % develop\n        else:\n            development_status = installed_by\n        status = \"%s %s\" % (active_status, development_status)\n        if fields:\n            print('%s (%s)%s %s' % (metadata['Name'], version, active_status,\n                                    development_status))\n        else:\n            # Need intelligent justification\n            print(metadata['Name'].ljust(15) + \" - \" + version.ljust(12) + \\\n                \" - \" + status)\n        if fields:\n            #Only show specific fields, using case-insensitive search\n            fields = map(str.lower, fields)\n            for field in metadata.keys():\n                if field.lower() in fields:\n                    print('    %s: %s' % (field, metadata[field]))\n            print()\n        elif show_metadata:\n            #Print all available metadata fields\n            for field in metadata.keys():\n                if field != 'Name' and field != 'Summary':\n                    print('    %s: %s' % (field, metadata[field]))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef show_deps(self):\n\n        pkgs = pkg_resources.Environment()\n\n        for pkg in pkgs[self.project_name]:\n            if not self.version:\n                print(pkg.project_name, pkg.version)\n\n            i = len(pkg._dep_map.values()[0])\n            if i:\n                while i:\n                    if not self.version or self.version and \\\n                            pkg.version == self.version:\n                        if self.version and i == len(pkg._dep_map.values()[0]):\n                            print(pkg.project_name, pkg.version)\n                        print(\"  \" + str(pkg._dep_map.values()[0][i - 1]))\n                    i -= 1\n            else:\n                self.logger.info(\\\n                    \"No dependency information was supplied with the package.\")\n                return 1\n        return 0", "response": "Show dependencies for the specified package."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef show_pypi_changelog(self):\n        hours = self.options.show_pypi_changelog\n        if not hours.isdigit():\n            self.logger.error(\"Error: You must supply an integer.\")\n            return 1\n\n        try:\n            changelog = self.pypi.changelog(int(hours))\n        except XMLRPCFault as err_msg:\n            self.logger.error(err_msg)\n            self.logger.error(\"ERROR: Couldn't retrieve changelog.\")\n            return 1\n\n        last_pkg = ''\n        for entry in changelog:\n            pkg = entry[0]\n            if pkg != last_pkg:\n                print(\"%s %s\\n\\t%s\" % (entry[0], entry[1], entry[3]))\n                last_pkg = pkg\n            else:\n                print(\"\\t%s\" % entry[3])\n\n        return 0", "response": "Show detailed PyPI ChangeLog for the last hours."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nshows PyPI releases for the last number of hours.", "response": "def show_pypi_releases(self):\n        \"\"\"\n        Show PyPI releases for the last number of `hours`\n\n        @returns: 0 = success or 1 if failed to retrieve from XML-RPC server\n\n        \"\"\"\n        try:\n            hours = int(self.options.show_pypi_releases)\n        except ValueError:\n            self.logger.error(\"ERROR: You must supply an integer.\")\n            return 1\n        try:\n            latest_releases = self.pypi.updated_releases(hours)\n        except XMLRPCFault as err_msg:\n            self.logger.error(err_msg)\n            self.logger.error(\"ERROR: Couldn't retrieve latest releases.\")\n            return 1\n\n        for release in latest_releases:\n            print(\"%s %s\" % (release[0], release[1]))\n        return 0"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef show_download_links(self):\n        #In case they specify version as 'dev' instead of using -T svn,\n        #don't show three svn URI's\n        if self.options.file_type == \"all\" and self.version == \"dev\":\n            self.options.file_type = \"svn\"\n\n        if self.options.file_type == \"svn\":\n            version = \"dev\"\n        else:\n            if self.version:\n                version = self.version\n            else:\n                version = self.all_versions[0]\n        if self.options.file_type == \"all\":\n            #Search for source, egg, and svn\n            self.print_download_uri(version, True)\n            self.print_download_uri(version, False)\n            self.print_download_uri(\"dev\", True)\n        else:\n            if self.options.file_type == \"source\":\n                source = True\n            else:\n                source = False\n            self.print_download_uri(version, source)\n        return 0", "response": "Print the download links for a specific pkg."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nprinting the download URL for the current version and source.", "response": "def print_download_uri(self, version, source):\n        \"\"\"\n        @param version: version number or 'dev' for svn\n        @type version: string\n\n        @param source: download source or egg\n        @type source: boolean\n\n        @returns: None\n\n        \"\"\"\n\n        if version == \"dev\":\n            pkg_type = \"subversion\"\n            source = True\n        elif source:\n            pkg_type = \"source\"\n        else:\n            pkg_type = \"egg\"\n\n        #Use setuptools monkey-patch to grab url\n        url = get_download_uri(self.project_name, version, source,\n                self.options.pypi_index)\n        if url:\n            print(\"%s\" % url)\n        else:\n            self.logger.info(\"No download URL found for %s\" % pkg_type)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ndownload a package from the remote repository.", "response": "def fetch(self):\n        \"\"\"\n        Download a package\n\n        @returns: 0 = success or 1 if failed download\n\n        \"\"\"\n        #Default type to download\n        source = True\n        directory = \".\"\n\n        if self.options.file_type == \"svn\":\n            version = \"dev\"\n            svn_uri = get_download_uri(self.project_name, \\\n                    \"dev\", True)\n            if svn_uri:\n                directory = self.project_name + \"_svn\"\n                return self.fetch_svn(svn_uri, directory)\n            else:\n                self.logger.error(\\\n                    \"ERROR: No subversion repository found for %s\" % \\\n                    self.project_name)\n                return 1\n        elif self.options.file_type == \"source\":\n            source = True\n        elif self.options.file_type == \"egg\":\n            source = False\n\n        uri = get_download_uri(self.project_name, self.version, source)\n        if uri:\n            return self.fetch_uri(directory, uri)\n        else:\n            self.logger.error(\"No %s URI found for package: %s \" % \\\n                    (self.options.file_type, self.project_name))\n            return 1"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef fetch_uri(self, directory, uri):\n        filename = os.path.basename(urlparse(uri)[2])\n        if os.path.exists(filename):\n            self.logger.error(\"ERROR: File exists: \" + filename)\n            return 1\n\n        try:\n            downloaded_filename, headers = urlretrieve(uri, filename)\n            self.logger.info(\"Downloaded ./\" + filename)\n        except IOError as err_msg:\n            self.logger.error(\"Error downloading package %s from URL %s\"  \\\n                    % (filename, uri))\n            self.logger.error(str(err_msg))\n            return 1\n\n        if headers.gettype() in [\"text/html\"]:\n            dfile = open(downloaded_filename)\n            if re.search(\"404 Not Found\", \"\".join(dfile.readlines())):\n                dfile.close()\n                self.logger.error(\"'404 Not Found' error\")\n                return 1\n            dfile.close()\n        return 0", "response": "Download a file from a URI and store it in the local cache."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nfetching the current version of the current version of the svn repository and store it in the given directory.", "response": "def fetch_svn(self, svn_uri, directory):\n        \"\"\"\n        Fetch subversion repository\n\n        @param svn_uri: subversion repository uri to check out\n        @type svn_uri: string\n\n        @param directory: directory to download to\n        @type directory: string\n\n        @returns: 0 = success or 1 for failed download\n\n\n        \"\"\"\n        if not command_successful(\"svn --version\"):\n            self.logger.error(\"ERROR: Do you have subversion installed?\")\n            return 1\n        if os.path.exists(directory):\n            self.logger.error(\"ERROR: Checkout directory exists - %s\" \\\n                    % directory)\n            return 1\n        try:\n            os.mkdir(directory)\n        except OSError as err_msg:\n            self.logger.error(\"ERROR: \" + str(err_msg))\n            return 1\n        cwd = os.path.realpath(os.curdir)\n        os.chdir(directory)\n        self.logger.info(\"Doing subversion checkout for %s\" % svn_uri)\n        status, output = run_command(\"/usr/bin/svn co %s\" % svn_uri)\n        self.logger.info(output)\n        os.chdir(cwd)\n        self.logger.info(\"subversion checkout is in directory './%s'\" \\\n                % directory)\n        return 0"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef browse_website(self, browser=None):\n        if len(self.all_versions):\n            metadata = self.pypi.release_data(self.project_name, \\\n                    self.all_versions[0])\n            self.logger.debug(\"DEBUG: browser: %s\" % browser)\n            if metadata.has_key(\"home_page\"):\n                self.logger.info(\"Launching browser: %s\" \\\n                        % metadata[\"home_page\"])\n                if browser == 'konqueror':\n                    browser = webbrowser.Konqueror()\n                else:\n                    browser = webbrowser.get()\n                    browser.open(metadata[\"home_page\"], 2)\n                return 0\n\n        self.logger.error(\"No homepage URL found.\")\n        return 1", "response": "Launches a web browser at the project s homepage."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nqueries PyPI pkg metadata from PyPI.", "response": "def query_metadata_pypi(self):\n        \"\"\"\n        Show pkg metadata queried from PyPI\n\n        @returns: 0\n\n        \"\"\"\n        if self.version and self.version in self.all_versions:\n            metadata = self.pypi.release_data(self.project_name, self.version)\n        else:\n            #Give highest version\n            metadata = self.pypi.release_data(self.project_name, \\\n                    self.all_versions[0])\n\n        if metadata:\n            for key in metadata.keys():\n                if not self.options.fields or (self.options.fields and \\\n                        self.options.fields==key):\n                    print(\"%s: %s\" % (key, metadata[key]))\n        return 0"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef versions_available(self):\n\n        if self.version:\n            spec = \"%s==%s\" % (self.project_name, self.version)\n        else:\n            spec = self.project_name\n\n        if self.all_versions and self.version in self.all_versions:\n            print_pkg_versions(self.project_name, [self.version])\n        elif not self.version and self.all_versions:\n            print_pkg_versions(self.project_name, self.all_versions)\n        else:\n            if self.version:\n                self.logger.error(\"No pacakge found for version %s\" \\\n                        % self.version)\n            else:\n                self.logger.error(\"No pacakge found for %s\" % self.project_name)\n            return 1\n        return 0", "response": "Query PyPI for a particular version or all versions of a package."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nparsing a Cheese Shop package search string and return a dictionary with the spec and operator", "response": "def parse_search_spec(self, spec):\n        \"\"\"\n        Parse search args and return spec dict for PyPI\n        * Owwww, my eyes!. Re-write this.\n\n        @param spec: Cheese Shop package search spec\n                     e.g.\n                     name=Cheetah\n                     license=ZPL\n                     license=ZPL AND name=Cheetah\n        @type spec: string\n\n        @returns:  tuple with spec and operator\n        \"\"\"\n\n        usage = \\\n            \"\"\"You can search PyPI by the following:\n     name\n     version\n     author\n     author_email\n     maintainer\n     maintainer_email\n     home_page\n     license\n     summary\n     description\n     keywords\n     platform\n     download_url\n\n     e.g. yolk -S name=Cheetah\n          yolk -S name=yolk AND license=PSF\n          \"\"\"\n\n        if not spec:\n            self.logger.error(usage)\n            return (None, None)\n\n        try:\n            spec = (\" \").join(spec)\n            operator = 'AND'\n            first = second = \"\"\n            if \" AND \" in spec:\n                (first, second) = spec.split('AND')\n            elif \" OR \" in spec:\n                (first, second) = spec.split('OR')\n                operator = 'OR'\n            else:\n                first = spec\n            (key1, term1) = first.split('=')\n            key1 = key1.strip()\n            if second:\n                (key2, term2) = second.split('=')\n                key2 = key2.strip()\n\n            spec = {}\n            spec[key1] = term1\n            if second:\n                spec[key2] = term2\n        except:\n            self.logger.error(usage)\n            spec = operator = None\n        return (spec, operator)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef pypi_search(self):\n        spec = self.pkg_spec\n        #Add remainging cli arguments to options.pypi_search\n        search_arg = self.options.pypi_search\n        spec.insert(0, search_arg.strip())\n\n        (spec, operator) = self.parse_search_spec(spec)\n        if not spec:\n            return 1\n        for pkg in self.pypi.search(spec, operator):\n            if pkg['summary']:\n                summary = pkg['summary'].encode('utf-8')\n            else:\n                summary = \"\"\n            print(\"\"\"%s (%s):\n        %s\n    \"\"\" % (pkg['name'].encode('utf-8'), pkg[\"version\"],\n                    summary))\n        return 0", "response": "Search PyPI by metadata keyword\n        e. g. yolk - S name = yolk AND license = GPL"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nshow entry map for a package", "response": "def show_entry_map(self):\n        \"\"\"\n        Show entry map for a package\n\n        @param dist: package\n        @param type: srting\n\n        @returns: 0 for success or 1 if error\n        \"\"\"\n        pprinter = pprint.PrettyPrinter()\n        try:\n            entry_map = pkg_resources.get_entry_map(self.options.show_entry_map)\n            if entry_map:\n                pprinter.pprint(entry_map)\n        except pkg_resources.DistributionNotFound:\n            self.logger.error(\"Distribution not found: %s\" \\\n                    % self.options.show_entry_map)\n            return 1\n        return 0"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nshows entry points for a module.", "response": "def show_entry_points(self):\n        \"\"\"\n        Show entry points for a module\n\n        @returns: 0 for success or 1 if error\n\n        \"\"\"\n        found = False\n        for entry_point in \\\n                pkg_resources.iter_entry_points(self.options.show_entry_points):\n            found = True\n            try:\n                plugin = entry_point.load()\n                print(plugin.__module__)\n                print(\"   %s\" % entry_point)\n                if plugin.__doc__:\n                    print(plugin.__doc__)\n                print\n            except ImportError:\n                pass\n        if not found:\n            self.logger.error(\"No entry points found for %s\" \\\n                    % self.options.show_entry_points)\n            return 1\n        return 0"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nparses the version of a package from the CLI args", "response": "def parse_pkg_ver(self, want_installed):\n        \"\"\"\n        Return tuple with project_name and version from CLI args\n        If the user gave the wrong case for the project name, this corrects it\n\n        @param want_installed: whether package we want is installed or not\n        @type want_installed: boolean\n\n        @returns: tuple(project_name, version, all_versions)\n\n        \"\"\"\n        all_versions = []\n\n        arg_str = (\"\").join(self.pkg_spec)\n        if \"==\" not in arg_str:\n            #No version specified\n            project_name = arg_str\n            version = None\n        else:\n            (project_name, version) = arg_str.split(\"==\")\n            project_name = project_name.strip()\n            version = version.strip()\n        #Find proper case for package name\n        if want_installed:\n            dists = Distributions()\n            project_name = dists.case_sensitive_name(project_name)\n        else:\n            (project_name, all_versions) = \\\n                    self.pypi.query_versions_pypi(project_name)\n\n            if not len(all_versions):\n                msg = \"I'm afraid we have no '%s' at \" % project_name\n                msg += \"The Cheese Shop. A little Red Leicester, perhaps?\"\n                self.logger.error(msg)\n                sys.exit(2)\n        return (project_name, version, all_versions)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef install_backport_hook(api):\n    if api == USED_API:\n        raise ValueError\n\n    sys.meta_path.insert(0, ImportHookBackport(api))", "response": "Install a backport import hook for Qt4 api"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ninstall a deny import hook for Qt api.", "response": "def install_deny_hook(api):\n    \"\"\"\n    Install a deny import hook for Qt api.\n\n    Parameters\n    ----------\n    api : str\n        The Qt api whose import should be prevented\n\n    Example\n    -------\n    >>> install_deny_import(\"pyqt4\")\n    >>> import PyQt4\n    Traceback (most recent call last):...\n    ImportError: Import of PyQt4 is denied.\n\n    \"\"\"\n    if api == USED_API:\n        raise ValueError\n\n    sys.meta_path.insert(0, ImportHookDeny(api))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nrunning command and return its return code and its output", "response": "def run_command(cmd, env=None, max_timeout=None):\n    \"\"\"\n    Run command and return its return status code and its output\n\n    \"\"\"\n    arglist = cmd.split()\n\n    output = os.tmpfile()\n    try:\n        pipe = Popen(arglist, stdout=output, stderr=STDOUT, env=env)\n    except Exception as errmsg:\n        return 1, errmsg\n\n    # Wait only max_timeout seconds.\n    if max_timeout:\n        start = time.time()\n        while pipe.poll() is None:\n            time.sleep(0.1)\n            if time.time() - start > max_timeout:\n                os.kill(pipe.pid, signal.SIGINT)\n                pipe.wait()\n                return 1, \"Time exceeded\"\n\n    pipe.wait()\n    output.seek(0)\n    return pipe.returncode, output.read()"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\nasync def iter(\n        self,\n        url: Union[str, methods],\n        data: Optional[MutableMapping] = None,\n        headers: Optional[MutableMapping] = None,\n        *,\n        limit: int = 200,\n        iterkey: Optional[str] = None,\n        itermode: Optional[str] = None,\n        minimum_time: Optional[int] = None,\n        as_json: Optional[bool] = None\n    ) -> AsyncIterator[dict]:\n        \"\"\"\n        Iterate over a slack API method supporting pagination\n\n        When using :class:`slack.methods` the request is made `as_json` if available\n\n        Args:\n            url: :class:`slack.methods` or url string\n            data: JSON encodable MutableMapping\n            headers:\n            limit: Maximum number of results to return per call.\n            iterkey: Key in response data to iterate over (required for url string).\n            itermode: Iteration mode (required for url string) (one of `cursor`, `page` or `timeline`)\n            minimum_time: Minimum elapsed time (in seconds) between two calls to the Slack API (default to 0).\n             If not reached the client will sleep for the remaining time.\n            as_json: Post JSON to the slack API\n        Returns:\n            Async iterator over `response_data[key]`\n\n        \"\"\"\n        itervalue = None\n\n        if not data:\n            data = {}\n\n        last_request_time = None\n        while True:\n            current_time = time.time()\n            if (\n                minimum_time\n                and last_request_time\n                and last_request_time + minimum_time > current_time\n            ):\n                await self.sleep(last_request_time + minimum_time - current_time)\n\n            data, iterkey, itermode = sansio.prepare_iter_request(\n                url,\n                data,\n                iterkey=iterkey,\n                itermode=itermode,\n                limit=limit,\n                itervalue=itervalue,\n            )\n            last_request_time = time.time()\n            response_data = await self.query(url, data, headers, as_json)\n            itervalue = sansio.decode_iter_request(response_data)\n            for item in response_data[iterkey]:\n                yield item\n\n            if not itervalue:\n                break", "response": "Iterate over a slack API method supporting pagination."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\nasync def _incoming_from_rtm(\n        self, url: str, bot_id: str\n    ) -> AsyncIterator[events.Event]:\n        \"\"\"\n        Connect and discard incoming RTM event if necessary.\n\n        :param url: Websocket url\n        :param bot_id: Bot ID\n        :return: Incoming events\n        \"\"\"\n        async for data in self._rtm(url):\n            event = events.Event.from_rtm(json.loads(data))\n            if sansio.need_reconnect(event):\n                break\n            elif sansio.discard_event(event, bot_id):\n                continue\n            else:\n                yield event", "response": "Connect and discard incoming RTM event if necessary."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nhandles the login action.", "response": "def login(request, template_name='registration/login.html',\n          redirect_field_name=REDIRECT_FIELD_NAME,\n          authentication_form=AuthenticationForm,\n          current_app=None, extra_context=None):\n    \"\"\"\n    Displays the login form and handles the login action.\n    \"\"\"\n    redirect_to = request.POST.get(redirect_field_name,\n                                   request.GET.get(redirect_field_name, ''))\n\n    if request.method == \"POST\":\n        form = authentication_form(data=request.POST, request=request)\n        if form.is_valid():\n            netloc = urlparse(redirect_to)[1]\n\n            # Use default setting if redirect_to is empty\n            if not redirect_to:\n                redirect_to = settings.LOGIN_REDIRECT_URL\n\n            # Heavier security check -- don't allow redirection to a different\n            # host.\n            elif netloc and netloc != request.get_host():\n                redirect_to = settings.LOGIN_REDIRECT_URL\n\n            # Okay, security checks complete. Log the user in.\n            auth_login(request, form.get_user())\n\n            return redirect(redirect_to)\n    else:\n        form = authentication_form(request)\n\n    current_site = get_current_site(request)\n\n    context = {\n        'form': form,\n        redirect_field_name: redirect_to,\n        'site': current_site,\n        'site_name': current_site.name,\n    }\n    if extra_context is not None:\n        context.update(extra_context)\n    request.current_app = current_app\n    return TemplateResponse(request, template_name, context)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef package_manager_owns(self, dist):\n        #Installed by distutils/setuptools or external package manager?\n        #If location is in site-packages dir, check for .egg-info file\n        if dist.location.lower() == get_python_lib().lower():\n            filename = os.path.join(dist.location, dist.egg_name() + \".egg-info\")\n        else:\n            filename = dist.location\n\n        status, output = getstatusoutput(\"/usr/bin/acmefile -q %s\" % filename)\n        #status == 0 (file was installed by Acme)\n        #status == 256 (file was not installed by Acme)\n        if status == 0:\n            return self.name\n        else:\n            return \"\"", "response": "Returns True if package manager owns file"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef check_proxy_setting():\n    try:\n        http_proxy = os.environ['HTTP_PROXY']\n    except KeyError:\n        return\n\n    if not http_proxy.startswith('http://'):\n        match = re.match('(http://)?([-_\\.A-Za-z]+):(\\d+)', http_proxy)\n        #if not match:\n        #    raise Exception('Proxy format not recognised: [%s]' % http_proxy)\n        os.environ['HTTP_PROXY'] = 'http://%s:%s' % (match.group(2),\n                match.group(3))\n    return", "response": "Checks if the environmental variable HTTP_PROXY is set and returns the transport for xmlrpc."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nfiltering URL of specified file type.", "response": "def filter_url(pkg_type, url):\n    \"\"\"\n    Returns URL of specified file type\n    'source', 'egg', or 'all'\n    \"\"\"\n    bad_stuff = [\"?modtime\", \"#md5=\"]\n    for junk in bad_stuff:\n        if junk in url:\n            url = url.split(junk)[0]\n            break\n\n    #pkg_spec==dev (svn)\n    if url.endswith(\"-dev\"):\n        url = url.split(\"#egg=\")[0]\n\n    if pkg_type == \"all\":\n        return url\n\n    elif pkg_type == \"source\":\n        valid_source_types = [\".tgz\", \".tar.gz\", \".zip\", \".tbz2\", \".tar.bz2\"]\n        for extension in valid_source_types:\n            if url.lower().endswith(extension):\n                return url\n\n    elif pkg_type == \"egg\":\n        if url.lower().endswith(\".egg\"):\n            return url"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef request(self, host, handler, request_body, verbose):\n        '''Send xml-rpc request using proxy'''\n        #We get a traceback if we don't have this attribute:\n        self.verbose = verbose\n        url = 'http://' + host + handler\n        request = urllib2.Request(url)\n        request.add_data(request_body)\n        # Note: 'Host' and 'Content-Length' are added automatically\n        request.add_header('User-Agent', self.user_agent)\n        request.add_header('Content-Type', 'text/xml')\n        proxy_handler = urllib2.ProxyHandler()\n        opener = urllib2.build_opener(proxy_handler)\n        fhandle = opener.open(request)\n        return(self.parse_response(fhandle))", "response": "Send xml - rpc request using proxy"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_cache(self):\n        #This is used by external programs that import `CheeseShop` and don't\n        #want a cache file written to ~/.pypi and query PyPI every time.\n        if self.no_cache:\n            self.pkg_list = self.list_packages()\n            return\n\n        if not os.path.exists(self.yolk_dir):\n            os.mkdir(self.yolk_dir)\n        if os.path.exists(self.pkg_cache_file):\n            self.pkg_list = self.query_cached_package_list()\n        else:\n            self.logger.debug(\"DEBUG: Fetching package list cache from PyPi...\")\n            self.fetch_pkg_list()", "response": "Get a package name list from disk cache or PyPI cache."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_xmlrpc_server(self):\n        check_proxy_setting()\n        if os.environ.has_key('XMLRPC_DEBUG'):\n            debug = 1\n        else:\n            debug = 0\n        try:\n            return xmlrpclib.Server(XML_RPC_SERVER, transport=ProxyTransport(), verbose=debug)\n        except IOError:\n            self.logger(\"ERROR: Can't connect to XML-RPC server: %s\" \\\n                    % XML_RPC_SERVER)", "response": "Returns PyPI s XML - RPC server instance"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef query_versions_pypi(self, package_name):\n        if not package_name in self.pkg_list:\n            self.logger.debug(\"Package %s not in cache, querying PyPI...\" \\\n                    % package_name)\n            self.fetch_pkg_list()\n        #I have to set version=[] for edge cases like \"Magic file extensions\"\n        #but I'm not sure why this happens. It's included with Python or\n        #because it has a space in it's name?\n        versions = []\n        for pypi_pkg in self.pkg_list:\n            if pypi_pkg.lower() == package_name.lower():\n                if self.debug:\n                    self.logger.debug(\"DEBUG: %s\" % package_name)\n                versions = self.package_releases(pypi_pkg)\n                package_name = pypi_pkg\n                break\n        return (package_name, versions)", "response": "Fetch list of available versions for a package from the CheeseShop"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns list of pickled package names from PYPI", "response": "def query_cached_package_list(self):\n        \"\"\"Return list of pickled package names from PYPI\"\"\"\n        if self.debug:\n            self.logger.debug(\"DEBUG: reading pickled cache file\")\n        return cPickle.load(open(self.pkg_cache_file, \"r\"))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef fetch_pkg_list(self):\n        self.logger.debug(\"DEBUG: Fetching package name list from PyPI\")\n        package_list = self.list_packages()\n        cPickle.dump(package_list, open(self.pkg_cache_file, \"w\"))\n        self.pkg_list = package_list", "response": "Fetch and cache master list of package names from PYPI"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nquerying PYPI via XMLRPC interface using search spec", "response": "def search(self, spec, operator):\n        '''Query PYPI via XMLRPC interface using search spec'''\n        return self.xmlrpc.search(spec, operator.lower())"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef release_data(self, package_name, version):\n        try:\n            return self.xmlrpc.release_data(package_name, version)\n        except xmlrpclib.Fault:\n            #XXX Raises xmlrpclib.Fault if you give non-existant version\n            #Could this be server bug?\n            return", "response": "Query PYPI via XMLRPC interface for a pkg s metadata"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nqueries PyPI via XMLRPC interface for a pkg s available versions", "response": "def package_releases(self, package_name):\n        \"\"\"Query PYPI via XMLRPC interface for a pkg's available versions\"\"\"\n        if self.debug:\n            self.logger.debug(\"DEBUG: querying PyPI for versions of \" \\\n                    + package_name)\n        return self.xmlrpc.package_releases(package_name)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_download_urls(self, package_name, version=\"\", pkg_type=\"all\"):\n\n        if version:\n            versions = [version]\n        else:\n\n            #If they don't specify version, show em all.\n\n            (package_name, versions) = self.query_versions_pypi(package_name)\n\n        all_urls = []\n        for ver in versions:\n            metadata = self.release_data(package_name, ver)\n            for urls in self.release_urls(package_name, ver):\n                if pkg_type == \"source\" and urls['packagetype'] == \"sdist\":\n                    all_urls.append(urls['url'])\n                elif pkg_type == \"egg\" and \\\n                        urls['packagetype'].startswith(\"bdist\"):\n                    all_urls.append(urls['url'])\n                elif pkg_type == \"all\":\n                    #All\n                    all_urls.append(urls['url'])\n\n            #Try the package's metadata directly in case there's nothing\n            #returned by XML-RPC's release_urls()\n            if metadata and metadata.has_key('download_url') and \\\n                        metadata['download_url'] != \"UNKNOWN\" and \\\n                        metadata['download_url'] != None:\n                if metadata['download_url'] not in all_urls:\n                    if pkg_type != \"all\":\n                        url = filter_url(pkg_type, metadata['download_url'])\n                        if url:\n                            all_urls.append(url)\n        return all_urls", "response": "Query PyPI for pkg download URI for a packge"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a deep copy of the event.", "response": "def clone(self) -> \"Event\":\n        \"\"\"\n        Clone the event\n\n        Returns:\n            :class:`slack.events.Event`\n\n        \"\"\"\n        return self.__class__(copy.deepcopy(self.event), copy.deepcopy(self.metadata))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef from_rtm(cls, raw_event: MutableMapping) -> \"Event\":\n        if raw_event[\"type\"].startswith(\"message\"):\n            return Message(raw_event)\n        else:\n            return Event(raw_event)", "response": "Create an event from a JSON decoded data coming from the RTM API."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef from_http(\n        cls,\n        raw_body: MutableMapping,\n        verification_token: Optional[str] = None,\n        team_id: Optional[str] = None,\n    ) -> \"Event\":\n        \"\"\"\n        Create an event with data coming from the HTTP Event API.\n\n        If the event type is a message a :class:`slack.events.Message` is returned.\n\n        Args:\n            raw_body: Decoded body of the Event API request\n            verification_token: Slack verification token used to verify the request came from slack\n            team_id: Verify the event is for the correct team\n\n        Returns:\n            :class:`slack.events.Event` or :class:`slack.events.Message`\n\n        Raises:\n            :class:`slack.exceptions.FailedVerification`: when `verification_token` or `team_id` does not match the\n                                                          incoming event's.\n        \"\"\"\n        if verification_token and raw_body[\"token\"] != verification_token:\n            raise exceptions.FailedVerification(raw_body[\"token\"], raw_body[\"team_id\"])\n\n        if team_id and raw_body[\"team_id\"] != team_id:\n            raise exceptions.FailedVerification(raw_body[\"token\"], raw_body[\"team_id\"])\n\n        if raw_body[\"event\"][\"type\"].startswith(\"message\"):\n            return Message(raw_body[\"event\"], metadata=raw_body)\n        else:\n            return Event(raw_body[\"event\"], metadata=raw_body)", "response": "Create an event from the HTTP request body."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef response(self, in_thread: Optional[bool] = None) -> \"Message\":\n        data = {\"channel\": self[\"channel\"]}\n\n        if in_thread:\n            if \"message\" in self:\n                data[\"thread_ts\"] = (\n                    self[\"message\"].get(\"thread_ts\") or self[\"message\"][\"ts\"]\n                )\n            else:\n                data[\"thread_ts\"] = self.get(\"thread_ts\") or self[\"ts\"]\n        elif in_thread is None:\n            if \"message\" in self and \"thread_ts\" in self[\"message\"]:\n                data[\"thread_ts\"] = self[\"message\"][\"thread_ts\"]\n            elif \"thread_ts\" in self:\n                data[\"thread_ts\"] = self[\"thread_ts\"]\n\n        return Message(data)", "response": "Create a new response message."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nserialize the message for sending to Slack API", "response": "def serialize(self) -> dict:\n        \"\"\"\n        Serialize the message for sending to slack API\n\n        Returns:\n            serialized message\n        \"\"\"\n        data = {**self}\n        if \"attachments\" in self:\n            data[\"attachments\"] = json.dumps(self[\"attachments\"])\n        return data"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef register(self, event_type: str, handler: Any, **detail: Any) -> None:\n        LOG.info(\"Registering %s, %s to %s\", event_type, detail, handler)\n        if len(detail) > 1:\n            raise ValueError(\"Only one detail can be provided for additional routing\")\n        elif not detail:\n            detail_key, detail_value = \"*\", \"*\"\n        else:\n            detail_key, detail_value = detail.popitem()\n\n        if detail_key not in self._routes[event_type]:\n            self._routes[event_type][detail_key] = {}\n\n        if detail_value not in self._routes[event_type][detail_key]:\n            self._routes[event_type][detail_key][detail_value] = []\n\n        self._routes[event_type][detail_key][detail_value].append(handler)", "response": "Register a new handler for a specific event type."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef dispatch(self, event: Event) -> Iterator[Any]:\n        LOG.debug('Dispatching event \"%s\"', event.get(\"type\"))\n        if event[\"type\"] in self._routes:\n            for detail_key, detail_values in self._routes.get(\n                event[\"type\"], {}\n            ).items():\n                event_value = event.get(detail_key, \"*\")\n                yield from detail_values.get(event_value, [])\n        else:\n            return", "response": "Dispatches the event to the handlers that match the routing of the incoming event."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef register(\n        self,\n        pattern: str,\n        handler: Any,\n        flags: int = 0,\n        channel: str = \"*\",\n        subtype: Optional[str] = None,\n    ) -> None:\n        \"\"\"\n        Register a new handler for a specific :class:`slack.events.Message`.\n\n        The routing is based on regex pattern matching the message text and the incoming slack channel.\n\n        Args:\n            pattern: Regex pattern matching the message text.\n            handler: Callback\n            flags: Regex flags.\n            channel: Slack channel ID. Use * for any.\n            subtype: Message subtype\n        \"\"\"\n        LOG.debug('Registering message endpoint \"%s: %s\"', pattern, handler)\n        match = re.compile(pattern, flags)\n\n        if subtype not in self._routes[channel]:\n            self._routes[channel][subtype] = dict()\n\n        if match in self._routes[channel][subtype]:\n            self._routes[channel][subtype][match].append(handler)\n        else:\n            self._routes[channel][subtype][match] = [handler]", "response": "Register a new handler for a specific message."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nyielding handlers matching the routing of the incoming message.", "response": "def dispatch(self, message: Message) -> Iterator[Any]:\n        \"\"\"\n        Yields handlers matching the routing of the incoming :class:`slack.events.Message`\n\n        Args:\n            message: :class:`slack.events.Message`\n\n        Yields:\n            handler\n        \"\"\"\n        if \"text\" in message:\n            text = message[\"text\"] or \"\"\n        elif \"message\" in message:\n            text = message[\"message\"].get(\"text\", \"\")\n        else:\n            text = \"\"\n\n        msg_subtype = message.get(\"subtype\")\n\n        for subtype, matchs in itertools.chain(\n            self._routes[message[\"channel\"]].items(), self._routes[\"*\"].items()\n        ):\n            if msg_subtype == subtype or subtype is None:\n                for match, endpoints in matchs.items():\n                    if match.search(text):\n                        yield from endpoints"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef query(  # type: ignore\n        self,\n        url: Union[str, methods],\n        data: Optional[MutableMapping] = None,\n        headers: Optional[MutableMapping] = None,\n        as_json: Optional[bool] = None,\n    ) -> dict:\n        \"\"\"\n        Query the slack API\n\n        When using :class:`slack.methods` the request is made `as_json` if available\n\n        Args:\n            url: :class:`slack.methods` or url string\n            data: JSON encodable MutableMapping\n            headers: Custom headers\n            as_json: Post JSON to the slack API\n        Returns:\n            dictionary of slack API response data\n\n        \"\"\"\n        url, body, headers = sansio.prepare_request(\n            url=url,\n            data=data,\n            headers=headers,\n            global_headers=self._headers,\n            token=self._token,\n        )\n        return self._make_query(url, body, headers)", "response": "Query the slack API for the specified resource."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef rtm(  # type: ignore\n        self, url: Optional[str] = None, bot_id: Optional[str] = None\n    ) -> Iterator[events.Event]:\n        \"\"\"\n        Iterate over event from the RTM API\n\n        Args:\n            url: Websocket connection url\n            bot_id: Connecting bot ID\n\n        Returns:\n            :class:`slack.events.Event` or :class:`slack.events.Message`\n\n        \"\"\"\n        while True:\n            bot_id = bot_id or self._find_bot_id()\n            url = url or self._find_rtm_url()\n            for event in self._incoming_from_rtm(url, bot_id):\n                yield event\n            url = None", "response": "Iterate over events from the RTM API."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ndisplay the login form for the given HttpRequest.", "response": "def login(self, request, extra_context=None):\n        \"\"\"\n        Displays the login form for the given HttpRequest.\n        \"\"\"\n        context = {\n            'title': _('Log in'),\n            'app_path': request.get_full_path(),\n        }\n        if (REDIRECT_FIELD_NAME not in request.GET and\n                REDIRECT_FIELD_NAME not in request.POST):\n            context[REDIRECT_FIELD_NAME] = request.get_full_path()\n        context.update(extra_context or {})\n        defaults = {\n            'extra_context': context,\n            'current_app': self.name,\n            'authentication_form': self.login_form or AdminAuthenticationForm,\n            'template_name': self.login_template or 'admin/login.html',\n        }\n        return login(request, **defaults)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_config(config_file):\n    def load(fp):\n        try:\n            return yaml.safe_load(fp)\n        except yaml.YAMLError as e:\n            sys.stderr.write(text_type(e))\n            sys.exit(1)  # TODO document exit codes\n\n    if config_file == '-':\n        return load(sys.stdin)\n    if not os.path.exists(config_file):\n        sys.stderr.write('ERROR: Must either run next to config.yaml or'\n            ' specify a config file.\\n' + __doc__)\n        sys.exit(2)\n    with open(config_file) as fp:\n        return load(fp)", "response": "Get configuration from a file."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_options(config_options, local_options, cli_options):\n    options = DEFAULT_OPTIONS.copy()\n    if config_options is not None:\n        options.update(config_options)\n    if local_options is not None:\n        options.update(local_options)\n    if cli_options is not None:\n        options.update(cli_options)\n    return options", "response": "Get the options to use for the base base."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef output_results(results, metric, options):\n    formatter = options['Formatter']\n    context = metric.copy()  # XXX might need to sanitize this\n    try:\n        context['dimension'] = list(metric['Dimensions'].values())[0]\n    except AttributeError:\n        context['dimension'] = ''\n    for result in results:\n        stat_keys = metric['Statistics']\n        if not isinstance(stat_keys, list):\n            stat_keys = [stat_keys]\n        for statistic in stat_keys:\n            context['statistic'] = statistic\n            # get and then sanitize metric name, first copy the unit name from the\n            # result to the context to keep the default format happy\n            context['Unit'] = result['Unit']\n            metric_name = (formatter % context).replace('/', '.').lower()\n            line = '{0} {1} {2}\\n'.format(\n                metric_name,\n                result[statistic],\n                timegm(result['Timestamp'].timetuple()),\n            )\n            sys.stdout.write(line)", "response": "Output the results to stdout."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ndownloads the file at gsuri to localpath.", "response": "def download_to_path(self, gsuri, localpath, binary_mode=False, tmpdir=None):\n        \"\"\"\n        This method is analogous to \"gsutil cp gsuri localpath\", but in a\n        programatically accesible way. The only difference is that we\n        have to make a guess about the encoding of the file to not upset\n        downstream file operations. If you are downloading a VCF, then\n        \"False\" is great. If this is a BAM file you are asking for, you\n        should enable the \"binary_mode\" to make sure file doesn't get\n        corrupted.\n\n        gsuri: full GS-based URI, e.g. gs://cohorts/rocks.txt\n        localpath: the path for the downloaded file, e.g. /mnt/cohorts/yep.txt\n        binary_mode: (logical) if yes, the binary file operations will be\n                     used; if not, standard ascii-based ones.\n        \"\"\"\n        bucket_name, gs_rel_path = self.parse_uri(gsuri)\n        # And now request the handles for bucket and the file\n        bucket = self._client.get_bucket(bucket_name)\n        # Just assignment, no downloading (yet)\n        ablob = bucket.get_blob(gs_rel_path)\n        if not ablob:\n            raise GoogleStorageIOError(\n                \"No such file on Google Storage: '{}'\".format(gs_rel_path))\n\n        # A tmp file to serve intermediate phase\n        # should be on same filesystem as localpath\n        tmp_fid, tmp_file_path = tempfile.mkstemp(text=(not binary_mode),\n                                                  dir=tmpdir)\n        # set chunk_size to reasonable default\n        # https://github.com/GoogleCloudPlatform/google-cloud-python/issues/2222\n        ablob.chunk_size = 1<<30\n        # Download starts in a sec....\n        ablob.download_to_filename(client=self._client, filename=tmp_file_path)\n        # ... end download ends. Let's move our finished file over.\n\n        # You will see that below, instead of directly writing to a file\n        # we are instead first using a different file and then move it to\n        # its final location. We are doing this because we don't want\n        # corrupted/incomplete data to be around as much as possible.\n        return os.rename(tmp_file_path, localpath)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef round_float(f, digits, rounding=ROUND_HALF_UP):\n    return Decimal(str(f)).quantize(Decimal(10) ** (-1 * digits),\n                                    rounding=rounding)", "response": "Round a float to a number of digits."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a string representing a float.", "response": "def float_str(f, min_digits=2, max_digits=6):\n    \"\"\"\n    Returns a string representing a float, where the number of\n    significant digits is min_digits unless it takes more digits\n    to hit a non-zero digit (and the number is 0 < x < 1).\n    We stop looking for a non-zero digit after max_digits.\n    \"\"\"\n    if f >= 1 or f <= 0:\n        return str(round_float(f, min_digits))\n    start_str = str(round_float(f, max_digits))\n    digits = start_str.split(\".\")[1]\n    non_zero_indices = []\n    for i, digit in enumerate(digits):\n        if digit != \"0\":\n            non_zero_indices.append(i + 1)\n    # Only saw 0s.\n    if len(non_zero_indices) == 0:\n        num_digits = min_digits\n    else:\n        # Of the non-zero digits, pick the num_digit'th of those (including any zeros)\n        min_non_zero_indices = range(non_zero_indices[0], non_zero_indices[-1] + 1)[:min_digits]\n        num_digits = min_non_zero_indices[-1]\n    return str(round_float(f, num_digits))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef default_format(self):\n        user = self.user\n        if user.first_name is not None:\n            return self.full_name\n        elif user.username is not None:\n            return user.username\n        else:\n            return str(user.id)", "response": "Returns the default format of the user."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef full_name(self):\n        formatted_user = []\n        if self.user.first_name is not None:\n            formatted_user.append(self.user.first_name)\n        if self.user.last_name is not None:\n            formatted_user.append(self.user.last_name)\n        return \" \".join(formatted_user)", "response": "Returns the full name of the user in a human readable format."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the full name of the user and the username of the user.", "response": "def full_format(self):\n        \"\"\"\n        Returns the full name (first and last parts), and the username between brackets if the user has it.\n        If there is no info about the user, returns the user id between < and >.\n        \"\"\"\n        formatted_user = self.full_name\n        if self.user.username is not None:\n            formatted_user += \" [\" + self.user.username + \"]\"\n        if not formatted_user:\n            formatted_user = self._id()\n        return formatted_user"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef full_data(self):\n        data = [\n            self.full_name,\n            self._username(),\n            self._id(),\n            self._language_code(),\n            self._is_bot()\n        ]\n        return \" \".join(filter(None, data))", "response": "Returns the full data for the user in the format of name username id language code bot_or_user."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the full data for the current user in the format of a chat.", "response": "def full_data(self):\n        \"\"\"\n        Returns all the info available for the chat in the following format:\n            title [username] (type) <id>\n        If any data is not available, it is not added.\n        \"\"\"\n        data = [\n            self.chat.title,\n            self._username(),\n            self._type(),\n            self._id()\n        ]\n        return \" \".join(filter(None, data))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef count_function(func):\n    # Fall back to Cohort-level defaults.\n    @use_defaults\n    @wraps(func)\n    def wrapper(row, cohort, filter_fn=None, normalized_per_mb=None, **kwargs):\n        per_patient_data = func(row=row,\n                                cohort=cohort,\n                                filter_fn=filter_fn,\n                                normalized_per_mb=normalized_per_mb,\n                                **kwargs)\n        patient_id = row[\"patient_id\"]\n        if patient_id in per_patient_data:\n            count = len(per_patient_data[patient_id])\n            if normalized_per_mb:\n                count /= float(get_patient_to_mb(cohort)[patient_id])\n            return count\n        return np.nan\n    return wrapper", "response": "Decorator for functions that return a dict of collections that should be counted up."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a function that counts variants that are filtered by the provided filterable_variant_function.", "response": "def count_variants_function_builder(function_name, filterable_variant_function=None):\n    \"\"\"\n    Creates a function that counts variants that are filtered by the provided filterable_variant_function.\n    The filterable_variant_function is a function that takes a filterable_variant and returns True or False.\n\n    Users of this builder need not worry about applying e.g. the Cohort's default `filter_fn`. That will be applied as well.\n    \"\"\"\n    @count_function\n    def count(row, cohort, filter_fn, normalized_per_mb, **kwargs):\n        def count_filter_fn(filterable_variant, **kwargs):\n            assert filter_fn is not None, \"filter_fn should never be None, but it is.\"\n            return ((filterable_variant_function(filterable_variant) if filterable_variant_function is not None else True) and\n                    filter_fn(filterable_variant, **kwargs))\n        patient_id = row[\"patient_id\"]\n        return cohort.load_variants(\n            patients=[cohort.patient_from_id(patient_id)],\n            filter_fn=count_filter_fn,\n            **kwargs)\n    count.__name__ = function_name\n    count.__doc__ = str(\"\".join(inspect.getsourcelines(filterable_variant_function)[0])) if filterable_variant_function is not None else \"\"\n    return count"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef count_effects_function_builder(function_name, only_nonsynonymous, filterable_effect_function=None):\n    @count_function\n    def count(row, cohort, filter_fn, normalized_per_mb, **kwargs):\n        def count_filter_fn(filterable_effect, **kwargs):\n            assert filter_fn is not None, \"filter_fn should never be None, but it is.\"\n            return ((filterable_effect_function(filterable_effect) if filterable_effect_function is not None else True) and\n                    filter_fn(filterable_effect, **kwargs))\n        # This only loads one effect per variant.\n        patient_id = row[\"patient_id\"]\n        return cohort.load_effects(\n            only_nonsynonymous=only_nonsynonymous,\n            patients=[cohort.patient_from_id(patient_id)],\n            filter_fn=count_filter_fn,\n            **kwargs)\n    count.__name__ = function_name\n    count.__doc__ = ((\"only_nonsynonymous=%s\\n\" % only_nonsynonymous) +\n                     str(\"\".join(inspect.getsourcelines(filterable_effect_function)[0])) if filterable_effect_function is not None else \"\")\n    # Keep track of these to be able to query the returned function for these attributes\n    count.only_nonsynonymous = only_nonsynonymous\n    count.filterable_effect_function = filterable_effect_function\n    return count", "response": "Creates a function that counts effects that are filtered by the provided filterable_effect_function."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef median_vaf_purity(row, cohort, **kwargs):\n    patient_id = row[\"patient_id\"]\n    patient = cohort.patient_from_id(patient_id)\n    variants = cohort.load_variants(patients=[patient], filter_fn=no_filter)\n    if patient_id in variants.keys():\n        variants = variants[patient_id]\n    else:\n        return np.nan\n    def grab_vaf(variant):\n        filterable_variant = FilterableVariant(variant, variants, patient)\n        return variant_stats_from_variant(variant, filterable_variant.variant_metadata).tumor_stats.variant_allele_frequency\n    vafs = [grab_vaf(variant) for variant in variants]\n    return 2 * pd.Series(vafs).median()", "response": "Estimate purity based on 2 * median VAF."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncalculate the boostrapped AUC for a given column trying to predict a pred_col.", "response": "def bootstrap_auc(df, col, pred_col, n_bootstrap=1000):\n    \"\"\"\n    Calculate the boostrapped AUC for a given col trying to predict a pred_col.\n\n    Parameters\n    ----------\n    df : pandas.DataFrame\n    col : str\n        column to retrieve the values from\n    pred_col : str\n        the column we're trying to predict\n    n_boostrap : int\n        the number of bootstrap samples\n\n    Returns\n    -------\n    list : AUCs for each sampling\n    \"\"\"\n    scores = np.zeros(n_bootstrap)\n    old_len = len(df)\n    df.dropna(subset=[col], inplace=True)\n    new_len = len(df)\n    if new_len < old_len:\n        logger.info(\"Dropping NaN values in %s to go from %d to %d rows\" % (col, old_len, new_len))\n    preds = df[pred_col].astype(int)\n    for i in range(n_bootstrap):\n        sampled_counts, sampled_pred = resample(df[col], preds)\n        if is_single_class(sampled_pred, col=pred_col):\n            continue\n        scores[i] = roc_auc_score(sampled_pred, sampled_counts)\n    return scores"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set_callbacks(self, worker_start_callback: callable, worker_end_callback: callable, are_async: bool = False):\n        # We are setting self.worker_start_callback and self.worker_end_callback\n        # to lambdas instead of saving them in private vars and moving the lambda logic\n        # to a member function for, among other reasons, making callback updates atomic,\n        # ie. once a callback has been posted, it will be executed as it was in that\n        # moment, any call to set_callbacks will only affect callbacks posted since they\n        # were updated, but not to any pending callback.\n\n        # If callback is async, execute the start callback in the calling thread\n        scheduler = self.immediate if are_async else self.background\n        self.worker_start_callback = lambda worker: scheduler(Work(\n            lambda: worker_start_callback(worker), \"worker_start_callback:\" + worker.name\n        ))\n\n        # As the end callback is called *just* before the thread dies,\n        # there is no problem running it on the thread\n        self.worker_end_callback = lambda worker: self.immediate(Work(\n            lambda: worker_end_callback(worker), \"worker_end_callback:\" + worker.name\n        ))", "response": "Set the callbacks for the current thread."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _start_worker(self, worker: Worker):\n        # This function is called from main thread and from worker pools threads to start their children threads\n        with self.running_workers_lock:\n            self.running_workers.append(worker)\n        thread = SchedulerThread(worker, self._worker_ended)\n        thread.start()\n        # This may or may not be posted to a background thread (see set_callbacks)\n        self.worker_start_callback(worker)", "response": "Starts a worker thread and sets the callback to the worker thread."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef new_worker(self, name: str):\n        if not self.running:\n            return self.immediate_worker\n        worker = self._new_worker(name)\n        self._start_worker(worker)\n        return worker", "response": "Creates a new Worker and starts a new Thread with it. Returns the Worker."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncreates a new worker pool and starts it.", "response": "def new_worker_pool(self, name: str, min_workers: int = 0, max_workers: int = 1,\n                        max_seconds_idle: int = DEFAULT_WORKER_POOL_MAX_SECONDS_IDLE):\n        \"\"\"\n        Creates a new worker pool and starts it.\n        Returns the Worker that schedules works to the pool.\n        \"\"\"\n        if not self.running:\n            return self.immediate_worker\n        worker = self._new_worker_pool(name, min_workers, max_workers, max_seconds_idle)\n        self._start_worker_pool(worker)\n        return worker"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning this Cohort as a DataFrame and optionally include additional columns using on.", "response": "def as_dataframe(self, on=None, join_with=None, join_how=None,\n                     return_cols=False, rename_cols=False,\n                     keep_paren_contents=True, **kwargs):\n        \"\"\"\n        Return this Cohort as a DataFrame, and optionally include additional columns\n        using `on`.\n\n        on : str or function or list or dict, optional\n            - A column name.\n            - Or a function that creates a new column for comparison, e.g. count.snv_count.\n            - Or a list of column-generating functions or column names.\n            - Or a map of new column names to their column-generating functions or column names.\n\n        If `on` is a function or functions, kwargs is passed to those functions.\n        Otherwise kwargs is ignored.\n\n        Other parameters\n        ----------------\n        `return_cols`: (bool)\n            If True, return column names generated via `on` along with the `DataFrame`\n            as a `DataFrameHolder` tuple.\n        `rename_cols`: (bool)\n            If True, then return columns using \"stripped\" column names\n            (\"stripped\" means lower-case names without punctuation other than `_`)\n            See `utils.strip_column_names` for more details\n            defaults to False\n        `keep_paren_contents`: (bool)\n            If True, then contents of column names within parens are kept.\n            If False, contents of column names within-parens are dropped.\n            Defaults to True\n        ----------\n\n        Return : `DataFrame` (or `DataFrameHolder` if `return_cols` is True)\n        \"\"\"\n        df = self._as_dataframe_unmodified(join_with=join_with, join_how=join_how)\n        if on is None:\n            return DataFrameHolder.return_obj(None, df, return_cols)\n\n        if type(on) == str:\n            return DataFrameHolder.return_obj(on, df, return_cols)\n\n        def apply_func(on, col, df):\n            \"\"\"\n            Sometimes we have functions that, by necessity, have more parameters\n            than just `row`. We construct a function with just the `row` parameter\n            so it can be sent to `DataFrame.apply`. We hackishly pass `cohort`\n            (as `self`) along if the function accepts a `cohort` argument.\n            \"\"\"\n            on_argnames = on.__code__.co_varnames\n            if \"cohort\" not in on_argnames:\n                func = lambda row: on(row=row, **kwargs)\n            else:\n                func = lambda row: on(row=row, cohort=self, **kwargs)\n\n            if self.show_progress:\n                tqdm.pandas(desc=col)\n                df[col] = df.progress_apply(func, axis=1) ## depends on tqdm on prev line\n            else:\n                df[col] = df.apply(func, axis=1)\n            return DataFrameHolder(col, df)\n\n        def func_name(func, num=0):\n            return func.__name__ if not is_lambda(func) else \"column_%d\" % num\n\n        def is_lambda(func):\n            return func.__name__ == (lambda: None).__name__\n\n        if type(on) == FunctionType:\n            return apply_func(on, func_name(on), df).return_self(return_cols)\n\n        if len(kwargs) > 0:\n            logger.warning(\"Note: kwargs used with multiple functions; passing them to all functions\")\n\n        if type(on) == dict:\n            cols = []\n            for key, value in on.items():\n                if type(value) == str:\n                    df[key] = df[value]\n                    col = key\n                elif type(value) == FunctionType:\n                    col, df = apply_func(on=value, col=key, df=df)\n                else:\n                    raise ValueError(\"A value of `on`, %s, is not a str or function\" % str(value))\n                cols.append(col)\n        if type(on) == list:\n            cols = []\n            for i, elem in enumerate(on):\n                if type(elem) == str:\n                    col = elem\n                elif type(elem) == FunctionType:\n                    col = func_name(elem, i)\n                    col, df = apply_func(on=elem, col=col, df=df)\n                cols.append(col)\n\n        if rename_cols:\n            rename_dict = _strip_column_names(df.columns, keep_paren_contents=keep_paren_contents)\n            df.rename(columns=rename_dict, inplace=True)\n            cols = [rename_dict[col] for col in cols]\n        return DataFrameHolder(cols, df).return_self(return_cols)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nloading a single DataFrame from the DataFrameLoader with the specified name.", "response": "def load_dataframe(self, df_loader_name):\n        \"\"\"\n        Instead of joining a DataFrameJoiner with the Cohort in `as_dataframe`, sometimes\n        we may want to just directly load a particular DataFrame.\n        \"\"\"\n        logger.debug(\"loading dataframe: {}\".format(df_loader_name))\n        # Get the DataFrameLoader object corresponding to this name.\n        df_loaders = [df_loader for df_loader in self.df_loaders if df_loader.name == df_loader_name]\n\n        if len(df_loaders) == 0:\n            raise ValueError(\"No DataFrameLoader with name %s\" % df_loader_name)\n        if len(df_loaders) > 1:\n            raise ValueError(\"Multiple DataFrameLoaders with name %s\" % df_loader_name)\n\n        return df_loaders[0].load_dataframe()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning name of function in the cache", "response": "def _get_function_name(self, fn, default=\"None\"):\n        \"\"\" Return name of function, using default value if function not defined\n        \"\"\"\n        if fn is None:\n            fn_name = default\n        else:\n            fn_name = fn.__name__\n        return fn_name"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nloading a dictionary of patient_id to VariantCollection that contains all the variants that are present in the given patients.", "response": "def load_variants(self, patients=None, filter_fn=None, **kwargs):\n        \"\"\"Load a dictionary of patient_id to varcode.VariantCollection\n\n        Parameters\n        ----------\n        patients : str, optional\n            Filter to a subset of patients\n        filter_fn : function\n            Takes a FilterableVariant and returns a boolean. Only variants returning True are preserved.\n            Overrides default self.filter_fn. `None` passes through to self.filter_fn.\n\n        Returns\n        -------\n        merged_variants\n            Dictionary of patient_id to VariantCollection\n        \"\"\"\n        filter_fn = first_not_none_param([filter_fn, self.filter_fn], no_filter)\n        filter_fn_name = self._get_function_name(filter_fn)\n        logger.debug(\"loading variants with filter_fn: {}\".format(filter_fn_name))\n        patient_variants = {}\n\n        for patient in self.iter_patients(patients):\n            variants = self._load_single_patient_variants(patient, filter_fn, **kwargs)\n            if variants is not None:\n                patient_variants[patient.id] = variants\n        return patient_variants"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _hash_filter_fn(self, filter_fn, **kwargs):\n        filter_fn_name = self._get_function_name(filter_fn, default=\"filter-none\")\n        logger.debug(\"Computing hash for filter_fn: {} with kwargs {}\".format(filter_fn_name, str(dict(**kwargs))))\n        # hash function source code\n        fn_source = str(dill.source.getsource(filter_fn))\n        pickled_fn_source = pickle.dumps(fn_source) ## encode as byte string\n        hashed_fn_source = int(hashlib.sha1(pickled_fn_source).hexdigest(), 16) % (10 ** 11)\n        # hash kwarg values\n        kw_dict = dict(**kwargs)\n        kw_hash = list()\n        if not kw_dict:\n            kw_hash = [\"default\"]\n        else:\n            [kw_hash.append(\"{}-{}\".format(key, h)) for (key, h) in sorted(kw_dict.items())]\n        # hash closure vars - for case where filter_fn is defined within closure of filter_fn\n        closure = []\n        nonlocals = inspect.getclosurevars(filter_fn).nonlocals\n        for (key, val) in nonlocals.items():\n            ## capture hash for any function within closure\n            if inspect.isfunction(val):\n                closure.append(self._hash_filter_fn(val))\n        closure.sort() # Sorted for file name consistency\n        closure_str = \"null\" if len(closure) == 0 else \"-\".join(closure)\n        # construct final string comprising hashed components\n        hashed_fn = \".\".join([\"-\".join([filter_fn_name,\n                                        str(hashed_fn_source)]),\n                              \".\".join(kw_hash),\n                              closure_str]\n                            )\n        return hashed_fn", "response": "Construct a hash for a function and keyword arguments"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nload filtered merged variants for a single patient optionally using cache", "response": "def _load_single_patient_variants(self, patient, filter_fn, use_cache=True, **kwargs):\n        \"\"\" Load filtered, merged variants for a single patient, optionally using cache\n\n            Note that filtered variants are first merged before filtering, and\n                each step is cached independently. Turn on debug statements for more\n                details about cached files.\n\n            Use `_load_single_patient_merged_variants` to see merged variants without filtering.\n        \"\"\"\n        if filter_fn is None:\n            use_filtered_cache = False\n        else:\n            filter_fn_name = self._get_function_name(filter_fn)\n            logger.debug(\"loading variants for patient {} with filter_fn {}\".format(patient.id, filter_fn_name))\n            use_filtered_cache = use_cache\n\n        ## confirm that we can get cache-name (else don't use filtered cache)\n        if use_filtered_cache:\n            logger.debug(\"... identifying filtered-cache file name\")\n            try:\n                ## try to load filtered variants from cache\n                filtered_cache_file_name = \"%s-variants.%s.pkl\" % (self.merge_type,\n                                                                   self._hash_filter_fn(filter_fn, **kwargs))\n            except:\n                logger.warning(\"... error identifying filtered-cache file name for patient {}: {}\".format(\n                        patient.id, filter_fn_name))\n                use_filtered_cache = False\n            else:\n                logger.debug(\"... trying to load filtered variants from cache: {}\".format(filtered_cache_file_name))\n                try:\n                    cached = self.load_from_cache(self.cache_names[\"variant\"], patient.id, filtered_cache_file_name)\n                    if cached is not None:\n                        return cached\n                except:\n                    logger.warning(\"Error loading variants from cache for patient: {}\".format(patient.id))\n                    pass\n\n        ## get merged variants\n        logger.debug(\"... getting merged variants for: {}\".format(patient.id))\n        merged_variants = self._load_single_patient_merged_variants(patient, use_cache=use_cache)\n\n        # Note None here is different from 0. We want to preserve None\n        if merged_variants is None:\n            logger.info(\"Variants did not exist for patient %s\" % patient.id)\n            return None\n\n        logger.debug(\"... applying filters to variants for: {}\".format(patient.id))\n        filtered_variants = filter_variants(variant_collection=merged_variants,\n                                            patient=patient,\n                                            filter_fn=filter_fn,\n                                            **kwargs)\n        if use_filtered_cache:\n            logger.debug(\"... saving filtered variants to cache: {}\".format(filtered_cache_file_name))\n            self.save_to_cache(filtered_variants, self.cache_names[\"variant\"], patient.id, filtered_cache_file_name)\n        return filtered_variants"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _load_single_patient_merged_variants(self, patient, use_cache=True):\n        logger.debug(\"loading merged variants for patient {}\".format(patient.id))\n        no_variants = False\n        try:\n            # get merged-variants from cache\n            if use_cache:\n                ## load unfiltered variants into list of collections\n                variant_cache_file_name = \"%s-variants.pkl\" % (self.merge_type)\n                merged_variants = self.load_from_cache(self.cache_names[\"variant\"], patient.id, variant_cache_file_name)\n                if merged_variants is not None:\n                    return merged_variants\n            # get variant collections from file\n            variant_collections = []\n            optional_maf_cols = [\"t_ref_count\", \"t_alt_count\", \"n_ref_count\", \"n_alt_count\"]\n            if self.additional_maf_cols is not None:\n                optional_maf_cols.extend(self.additional_maf_cols)\n            for patient_variants in patient.variants_list:\n                if type(patient_variants) == str:\n                    if \".vcf\" in patient_variants:\n                        try:\n                            variant_collections.append(varcode.load_vcf_fast(patient_variants))\n                        # StopIteration is thrown for empty VCFs. For an empty VCF, don't append any variants,\n                        # and don't throw an error. But do record a warning, in case the StopIteration was\n                        # thrown for another reason.\n                        except StopIteration as e:\n                            logger.warning(\"Empty VCF (or possibly a VCF error) for patient {}: {}\".format(\n                                patient.id, str(e)))\n                    elif \".maf\" in patient_variants:\n                        # See variant_stats.maf_somatic_variant_stats\n                        variant_collections.append(\n                            varcode.load_maf(\n                                patient_variants,\n                                optional_cols=optional_maf_cols,\n                                encoding=\"latin-1\"))\n                    else:\n                        raise ValueError(\"Don't know how to read %s\" % patient_variants)\n                elif type(patient_variants) == VariantCollection:\n                    variant_collections.append(patient_variants)\n                else:\n                    raise ValueError(\"Don't know how to read %s\" % patient_variants)\n            # merge variant-collections\n            if len(variant_collections) == 0:\n                no_variants = True\n            elif len(variant_collections) == 1:\n                # There is nothing to merge\n                variants = variant_collections[0]\n                merged_variants = variants\n            else:\n                merged_variants = self._merge_variant_collections(variant_collections, self.merge_type)\n        except IOError:\n            no_variants = True\n\n        # Note that this is the number of variant collections and not the number of\n        # variants. 0 variants will lead to 0 neoantigens, for example, but 0 variant\n        # collections will lead to NaN variants and neoantigens.\n        if no_variants:\n            print(\"Variants did not exist for patient %s\" % patient.id)\n            merged_variants = None\n\n        # save merged variants to file\n        if use_cache:\n            self.save_to_cache(merged_variants, self.cache_names[\"variant\"], patient.id, variant_cache_file_name)\n        return merged_variants", "response": "Load merged variants for a single patient."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef load_polyphen_annotations(self, as_dataframe=False,\n                                  filter_fn=None):\n        \"\"\"Load a dataframe containing polyphen2 annotations for all variants\n\n        Parameters\n        ----------\n        database_file : string, sqlite\n            Path to the WHESS/Polyphen2 SQLite database.\n            Can be downloaded and bunzip2\"ed from http://bit.ly/208mlIU\n        filter_fn : function\n            Takes a FilterablePolyphen and returns a boolean.\n            Only annotations returning True are preserved.\n            Overrides default self.filter_fn. `None` passes through to self.filter_fn.\n\n        Returns\n        -------\n        annotations\n            Dictionary of patient_id to a DataFrame that contains annotations\n        \"\"\"\n        filter_fn = first_not_none_param([filter_fn, self.filter_fn], no_filter)\n        patient_annotations = {}\n        for patient in self:\n            annotations = self._load_single_patient_polyphen(\n                patient,\n                filter_fn=filter_fn)\n            if annotations is not None:\n                annotations[\"patient_id\"] = patient.id\n                patient_annotations[patient.id] = annotations\n        if as_dataframe:\n            return pd.concat(patient_annotations.values())\n        return patient_annotations", "response": "Load a dataframe containing polyphen2 annotations for all variants."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef load_effects(self, patients=None, only_nonsynonymous=False,\n                     all_effects=False, filter_fn=None, **kwargs):\n        \"\"\"Load a dictionary of patient_id to varcode.EffectCollection\n\n        Note that this only loads one effect per variant.\n\n        Parameters\n        ----------\n        patients : str, optional\n            Filter to a subset of patients\n        only_nonsynonymous : bool, optional\n            If true, load only nonsynonymous effects, default False\n        all_effects : bool, optional\n            If true, return all effects rather than only the top-priority effect per variant\n        filter_fn : function\n            Takes a FilterableEffect and returns a boolean. Only effects returning True are preserved.\n            Overrides default self.filter_fn. `None` passes through to self.filter_fn.\n\n        Returns\n        -------\n        effects\n             Dictionary of patient_id to varcode.EffectCollection\n        \"\"\"\n        filter_fn = first_not_none_param([filter_fn, self.filter_fn], no_filter)\n        filter_fn_name = self._get_function_name(filter_fn)\n        logger.debug(\"loading effects with filter_fn {}\".format(filter_fn_name))\n        patient_effects = {}\n        for patient in self.iter_patients(patients):\n            effects = self._load_single_patient_effects(\n                patient, only_nonsynonymous, all_effects, filter_fn, **kwargs)\n            if effects is not None:\n                patient_effects[patient.id] = effects\n        return patient_effects", "response": "Loads all effects for a set of patients."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef load_kallisto(self):\n        kallisto_data = pd.concat(\n            [self._load_single_patient_kallisto(patient) for patient in self],\n            copy=False\n        )\n\n        if self.kallisto_ensembl_version is None:\n            raise ValueError(\"Required a kallisto_ensembl_version but none was specified\")\n\n        ensembl_release = cached_release(self.kallisto_ensembl_version)\n\n        kallisto_data[\"gene_name\"] = \\\n            kallisto_data[\"target_id\"].map(lambda t: ensembl_release.gene_name_of_transcript_id(t))\n\n        # sum counts across genes\n        kallisto_data = \\\n            kallisto_data.groupby([\"patient_id\", \"gene_name\"])[[\"est_counts\"]].sum().reset_index()\n\n        return kallisto_data", "response": "Load Kallisto transcript quantification data for a cohort s patients."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _load_single_patient_kallisto(self, patient):\n        data = pd.read_csv(patient.tumor_sample.kallisto_path, sep=\"\\t\")\n        data[\"patient_id\"] = patient.id\n        return data", "response": "Load Kallisto gene quantification given a patient"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _load_single_patient_cufflinks(self, patient, filter_ok):\n        data = pd.read_csv(patient.tumor_sample.cufflinks_path, sep=\"\\t\")\n        data[\"patient_id\"] = patient.id\n\n        if filter_ok:\n            # Filter to OK FPKM counts\n            data = data[data[\"FPKM_status\"] == \"OK\"]\n        return data", "response": "Load Cufflinks gene quantification given a patient"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_filtered_isovar_epitopes(self, epitopes, ic50_cutoff):\n        mutant_binding_predictions = []\n        for binding_prediction in epitopes:\n            peptide = binding_prediction.peptide\n            peptide_offset = binding_prediction.offset\n            isovar_row = dict(binding_prediction.source_sequence_key)\n            is_mutant = contains_mutant_residues(\n                peptide_start_in_protein=peptide_offset,\n                peptide_length=len(peptide),\n                mutation_start_in_protein=isovar_row[\"variant_aa_interval_start\"],\n                mutation_end_in_protein=isovar_row[\"variant_aa_interval_end\"])\n            if is_mutant and binding_prediction.value <= ic50_cutoff:\n                mutant_binding_predictions.append(binding_prediction)\n        return EpitopeCollection(mutant_binding_predictions)", "response": "This method returns a list of epitope collections that are only filtered by the Ic50 cutoff."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nplotting an ROC curve for benefit and a given variable", "response": "def plot_roc_curve(self, on, bootstrap_samples=100, ax=None, **kwargs):\n        \"\"\"Plot an ROC curve for benefit and a given variable\n\n        Parameters\n        ----------\n        on : str or function or list or dict\n            See `cohort.load.as_dataframe`\n        bootstrap_samples : int, optional\n            Number of boostrap samples to use to compute the AUC\n        ax : Axes, default None\n            Axes to plot on\n\n        Returns\n        -------\n        (mean_auc_score, plot): (float, matplotlib plot)\n            Returns the average AUC for the given predictor over `bootstrap_samples`\n            and the associated ROC curve\n        \"\"\"\n        plot_col, df = self.as_dataframe(on, return_cols=True, **kwargs)\n        df = filter_not_null(df, \"benefit\")\n        df = filter_not_null(df, plot_col)\n        df.benefit = df.benefit.astype(bool)\n        return roc_curve_plot(df, plot_col, \"benefit\", bootstrap_samples, ax=ax)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef plot_benefit(self, on, benefit_col=\"benefit\", label=\"Response\", ax=None,\n                     alternative=\"two-sided\", boolean_value_map={},\n                     order=None, **kwargs):\n        \"\"\"Plot a comparison of benefit/response in the cohort on a given variable\n        \"\"\"\n        no_benefit_plot_name = \"No %s\" % self.benefit_plot_name\n        boolean_value_map = boolean_value_map or {True: self.benefit_plot_name, False: no_benefit_plot_name}\n        order = order or [no_benefit_plot_name, self.benefit_plot_name]\n\n        return self.plot_boolean(on=on,\n                                 boolean_col=benefit_col,\n                                 alternative=alternative,\n                                 boolean_label=label,\n                                 boolean_value_map=boolean_value_map,\n                                 order=order,\n                                 ax=ax,\n                                 **kwargs)", "response": "Plot a comparison of benefit and response in the cohort on a given variable\n       "}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef plot_boolean(self,\n                     on,\n                     boolean_col,\n                     plot_col=None,\n                     boolean_label=None,\n                     boolean_value_map={},\n                     order=None,\n                     ax=None,\n                     alternative=\"two-sided\",\n                     **kwargs):\n        \"\"\"Plot a comparison of `boolean_col` in the cohort on a given variable via\n        `on` or `col`.\n\n        If the variable (through `on` or `col`) is binary this will compare\n        odds-ratios and perform a Fisher's exact test.\n\n        If the variable is numeric, this will compare the distributions through\n        a Mann-Whitney test and plot the distributions with box-strip plot\n\n        Parameters\n        ----------\n        on : str or function or list or dict\n            See `cohort.load.as_dataframe`\n        plot_col : str, optional\n            If on has many columns, this is the one whose values we are plotting.\n            If on has a single column, this is unnecessary.\n            We might want many columns if, e.g. we're generating boolean_col from a\n            function as well.\n        boolean_col : str\n            Column name of boolean column to plot or compare against.\n        boolean_label : None, optional\n            Label to give boolean column in the plot\n        boolean_value_map : dict, optional\n            Map of conversions for values in the boolean column, i.e. {True: 'High', False: 'Low'}\n        order : None, optional\n            Order of the labels on the x-axis\n        ax : None, optional\n            Axes to plot on\n        alternative : str, optional\n            Choose the sidedness of the mannwhitneyu or Fisher's Exact test.\n\n        Returns\n        -------\n        (Test statistic, p-value): (float, float)\n\n        \"\"\"\n        cols, df = self.as_dataframe(on, return_cols=True, **kwargs)\n        plot_col = self.plot_col_from_cols(cols=cols, plot_col=plot_col)\n        df = filter_not_null(df, boolean_col)\n        df = filter_not_null(df, plot_col)\n\n        if boolean_label:\n            df[boolean_label] = df[boolean_col]\n            boolean_col = boolean_label\n\n        condition_value = None\n        if boolean_value_map:\n            assert set(boolean_value_map.keys()) == set([True, False]), \\\n                \"Improper mapping of boolean column provided\"\n            df[boolean_col] = df[boolean_col].map(lambda v: boolean_value_map[v])\n            condition_value = boolean_value_map[True]\n\n        if df[plot_col].dtype == \"bool\":\n            results = fishers_exact_plot(\n                data=df,\n                condition1=boolean_col,\n                condition2=plot_col,\n                condition1_value=condition_value,\n                alternative=alternative,\n                order=order,\n                ax=ax)\n        else:\n            results = mann_whitney_plot(\n                data=df,\n                condition=boolean_col,\n                distribution=plot_col,\n                condition_value=condition_value,\n                alternative=alternative,\n                order=order,\n                ax=ax)\n        return results", "response": "Plot a comparison of boolean_col in the cohort on a given variable via the Mann - Whitney test and perform a Fisher s Exact test."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nplotting a Kaplan Meier survival curve by splitting the cohort into two groups.", "response": "def plot_survival(self,\n                      on,\n                      how=\"os\",\n                      survival_units=\"Days\",\n                      strata=None,\n                      ax=None,\n                      ci_show=False,\n                      with_condition_color=\"#B38600\",\n                      no_condition_color=\"#A941AC\",\n                      with_condition_label=None,\n                      no_condition_label=None,\n                      color_map=None,\n                      label_map=None,\n                      color_palette=\"Set2\",\n                      threshold=None, **kwargs):\n        \"\"\"Plot a Kaplan Meier survival curve by splitting the cohort into two groups\n        Parameters\n        ----------\n        on : str or function or list or dict\n            See `cohort.load.as_dataframe`\n        how : {\"os\", \"pfs\"}, optional\n            Whether to plot OS (overall survival) or PFS (progression free survival)\n        survival_units : str\n            Unit of time for the survival measure, i.e. Days or Months\n        strata : str\n            (optional) column name of stratifying variable\n        ci_show : bool\n            Display the confidence interval around the survival curve\n        threshold : int, \"median\", \"median-per-strata\" or None (optional)\n            Threshold of `col` on which to split the cohort\n        \"\"\"\n        assert how in [\"os\", \"pfs\"], \"Invalid choice of survival plot type %s\" % how\n        cols, df = self.as_dataframe(on, return_cols=True, **kwargs)\n        plot_col = self.plot_col_from_cols(cols=cols, only_allow_one=True)\n        df = filter_not_null(df, plot_col)\n        results = plot_kmf(\n            df=df,\n            condition_col=plot_col,\n            xlabel=survival_units,\n            ylabel=\"Overall Survival (%)\" if how == \"os\" else \"Progression-Free Survival (%)\",\n            censor_col=\"deceased\" if how == \"os\" else \"progressed_or_deceased\",\n            survival_col=how,\n            strata_col=strata,\n            threshold=threshold,\n            ax=ax,\n            ci_show=ci_show,\n            with_condition_color=with_condition_color,\n            no_condition_color=no_condition_color,\n            with_condition_label=with_condition_label,\n            no_condition_label=no_condition_label,\n            color_palette=color_palette,\n            label_map=label_map,\n            color_map=color_map,\n        )\n        return results"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef plot_correlation(self, on, x_col=None, plot_type=\"jointplot\", stat_func=pearsonr, show_stat_func=True, plot_kwargs={}, **kwargs):\n        if plot_type not in [\"boxplot\", \"barplot\", \"jointplot\", \"regplot\"]:\n            raise ValueError(\"Invalid plot_type %s\" % plot_type)\n        plot_cols, df = self.as_dataframe(on, return_cols=True, **kwargs)\n        if len(plot_cols) != 2:\n            raise ValueError(\"Must be comparing two columns, but there are %d columns\" % len(plot_cols))\n        for plot_col in plot_cols:\n            df = filter_not_null(df, plot_col)\n        if x_col is None:\n            x_col = plot_cols[0]\n            y_col = plot_cols[1]\n        else:\n            if x_col == plot_cols[0]:\n                y_col = plot_cols[1]\n            else:\n                y_col = plot_cols[0]\n        series_x = df[x_col]\n        series_y = df[y_col]\n        coeff, p_value = stat_func(series_x, series_y)\n        if plot_type == \"jointplot\":\n            plot = sb.jointplot(data=df, x=x_col, y=y_col,\n                                stat_func=stat_func if show_stat_func else None,\n                                **plot_kwargs)\n        elif plot_type == \"regplot\":\n            plot = sb.regplot(data=df, x=x_col, y=y_col,\n                              **plot_kwargs)\n        elif plot_type == \"boxplot\":\n            plot = stripboxplot(data=df, x=x_col, y=y_col, **plot_kwargs)\n        else:\n            plot = sb.barplot(data=df, x=x_col, y=y_col, **plot_kwargs)\n        return CorrelationResults(coeff=coeff, p_value=p_value, stat_func=stat_func,\n                                  series_x=series_x, series_y=series_y, plot=plot)", "response": "Plot the correlation between two variables."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _list_patient_ids(self):\n        results = []\n        for patient in self:\n            results.append(patient.id)\n        return(results)", "response": "Utility function to return a list of patient ids in the Cohort\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef summarize_provenance_per_cache(self):\n        provenance_summary = {}\n        df = self.as_dataframe()\n        for cache in self.cache_names:\n            cache_name = self.cache_names[cache]\n            cache_provenance = None\n            num_discrepant = 0\n            this_cache_dir = path.join(self.cache_dir, cache_name)\n            if path.exists(this_cache_dir):\n                for patient_id in self._list_patient_ids():\n                    patient_cache_dir = path.join(this_cache_dir, patient_id)\n                    try:\n                        this_provenance = self.load_provenance(patient_cache_dir = patient_cache_dir)\n                    except:\n                        this_provenance = None\n                    if this_provenance:\n                        if not(cache_provenance):\n                            cache_provenance = this_provenance\n                        else:\n                            num_discrepant += compare_provenance(this_provenance, cache_provenance)\n                if num_discrepant == 0:\n                    provenance_summary[cache_name] = cache_provenance\n                else:\n                    provenance_summary[cache_name] = None\n        return(provenance_summary)", "response": "Utility function to summarize provenance files for all items in a cache."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef summarize_dataframe(self):\n        if self.dataframe_hash:\n            return(self.dataframe_hash)\n        else:\n            df = self._as_dataframe_unmodified()\n            return(self.dataframe_hash)", "response": "Summarize the default dataframe for this cohort using a hash function."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef summarize_data_sources(self):\n        provenance_file_summary = self.summarize_provenance()\n        dataframe_hash = self.summarize_dataframe()\n        results = {\n            \"provenance_file_summary\": provenance_file_summary,\n            \"dataframe_hash\": dataframe_hash\n        }\n        return(results)", "response": "Utility function to summarize data sources for this Cohort"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef strelka_somatic_variant_stats(variant, variant_metadata):\n\n    sample_info = variant_metadata[\"sample_info\"]\n    # Ensure there are exactly two samples in the VCF, a tumor and normal\n    assert len(sample_info) == 2, \"More than two samples found in the somatic VCF\"\n    tumor_stats = _strelka_variant_stats(variant, sample_info[\"TUMOR\"])\n    normal_stats = _strelka_variant_stats(variant, sample_info[\"NORMAL\"])\n    return SomaticVariantStats(tumor_stats=tumor_stats, normal_stats=normal_stats)", "response": "Parse out the variant calling statistics for a given variant from a Strelka VCF and return a SomaticVariantStats object"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _strelka_variant_stats(variant, sample_info):\n    \n    if variant.is_deletion or variant.is_insertion:\n        # ref: https://sites.google.com/site/strelkasomaticvariantcaller/home/somatic-variant-output\n        ref_depth = int(sample_info['TAR'][0]) # number of reads supporting ref allele (non-deletion)\n        alt_depth = int(sample_info['TIR'][0]) # number of reads supporting alt allele (deletion)\n        depth = ref_depth + alt_depth\n    else:\n        # Retrieve the Tier 1 counts from Strelka\n        ref_depth = int(sample_info[variant.ref+\"U\"][0])\n        alt_depth = int(sample_info[variant.alt+\"U\"][0])\n        depth = alt_depth + ref_depth\n    if depth > 0:\n        vaf = float(alt_depth) / depth\n    else:\n        # unclear how to define vaf if no reads support variant\n        # up to user to interpret this (hopefully filtered out in QC settings)\n        vaf = None\n\n    return VariantStats(depth=depth, alt_depth=alt_depth, variant_allele_frequency=vaf)", "response": "Parse a single sample s variant calling statistics based on Strelka VCF output"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef mutect_somatic_variant_stats(variant, variant_metadata):\n\n    sample_info = variant_metadata[\"sample_info\"]\n    # Ensure there are exactly two samples in the VCF, a tumor and normal\n    assert len(sample_info) == 2, \"More than two samples found in the somatic VCF\"\n\n    # Find the sample with the genotype field set to variant in the VCF\n    tumor_sample_infos = [info for info in sample_info.values() if info[\"GT\"] == \"0/1\"]\n\n    # Ensure there is only one such sample\n    assert len(tumor_sample_infos) == 1, \"More than one tumor sample found in the VCF file\"\n\n    tumor_sample_info = tumor_sample_infos[0]\n    normal_sample_info = [info for info in sample_info.values() if info[\"GT\"] != \"0/1\"][0]\n\n    tumor_stats = _mutect_variant_stats(variant, tumor_sample_info)\n    normal_stats = _mutect_variant_stats(variant, normal_sample_info)\n    return SomaticVariantStats(tumor_stats=tumor_stats, normal_stats=normal_stats)", "response": "Parse out the variant calling statistics for a given variant in a Mutect VCF and return a SomaticVariantStats object"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nparse a single sample s variant calling statistics based on Mutect s V1 VCF output", "response": "def _mutect_variant_stats(variant, sample_info):\n    \"\"\"Parse a single sample\"s variant calling statistics based on Mutect\"s (v1) VCF output\n\n    Parameters\n    ----------\n    variant : varcode.Variant\n    sample_info : dict\n        Dictionary of Mutect-specific variant calling fields\n\n    Returns\n    -------\n    VariantStats\n    \"\"\"\n\n    # Parse out the AD (or allele depth field), which is an array of [REF_DEPTH, ALT_DEPTH]\n    ref_depth, alt_depth = sample_info[\"AD\"]\n    depth = int(ref_depth) + int(alt_depth)\n    vaf = float(alt_depth) / depth\n\n    return VariantStats(depth=depth, alt_depth=alt_depth, variant_allele_frequency=vaf)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nparsing out the variant calling statistics for a given variant from a MAF file.", "response": "def maf_somatic_variant_stats(variant, variant_metadata):\n    \"\"\"\n    Parse out the variant calling statistics for a given variant from a MAF file\n\n    Assumes the MAF format described here: https://www.biostars.org/p/161298/#161777\n\n    Parameters\n    ----------\n    variant : varcode.Variant\n    variant_metadata : dict\n        Dictionary of metadata for this variant\n\n    Returns\n    -------\n    SomaticVariantStats\n    \"\"\"\n    tumor_stats = None\n    normal_stats = None\n    if \"t_ref_count\" in variant_metadata:\n        tumor_stats = _maf_variant_stats(variant, variant_metadata, prefix=\"t\")\n    if \"n_ref_count\" in variant_metadata:\n        normal_stats = _maf_variant_stats(variant, variant_metadata, prefix=\"n\")\n    return SomaticVariantStats(tumor_stats=tumor_stats, normal_stats=normal_stats)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns True if variant_file given is in strelka format", "response": "def _vcf_is_strelka(variant_file, variant_metadata):\n    \"\"\"Return True if variant_file given is in strelka format\n    \"\"\"\n    if \"strelka\" in variant_file.lower():\n        return True\n    elif \"NORMAL\" in variant_metadata[\"sample_info\"].keys():\n        return True\n    else:\n        vcf_reader = vcf.Reader(open(variant_file, \"r\"))\n        try:\n            vcf_type = vcf_reader.metadata[\"content\"]\n        except KeyError:\n            vcf_type = \"\"\n        if \"strelka\" in vcf_type.lower():\n            return True\n    return False"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nparse the variant calling stats from a single variant calling file.", "response": "def variant_stats_from_variant(variant,\n                               metadata,\n                               merge_fn=(lambda all_stats: \\\n                                max(all_stats, key=(lambda stats: stats.tumor_stats.depth)))):\n    \"\"\"Parse the variant calling stats from a variant called from multiple variant files. The stats are merged\n    based on `merge_fn`\n\n    Parameters\n    ----------\n    variant : varcode.Variant\n    metadata : dict\n        Dictionary of variant file to variant calling metadata from that file\n    merge_fn : function\n        Function from list of SomaticVariantStats to single SomaticVariantStats.\n        This is used if a variant is called by multiple callers or appears in multiple VCFs.\n        By default, this uses the data from the caller that had a higher tumor depth.\n\n    Returns\n    -------\n    SomaticVariantStats\n    \"\"\"\n    all_stats = []\n    for (variant_file, variant_metadata) in metadata.items():\n        if _vcf_is_maf(variant_file=variant_file):\n            stats = maf_somatic_variant_stats(variant, variant_metadata)\n        elif _vcf_is_strelka(variant_file=variant_file,\n                             variant_metadata=variant_metadata):\n            stats = strelka_somatic_variant_stats(variant, variant_metadata)\n        elif _vcf_is_mutect(variant_file=variant_file,\n                            variant_metadata=variant_metadata):\n            stats = mutect_somatic_variant_stats(variant, variant_metadata)\n        else:\n            raise ValueError(\"Cannot parse sample fields, variant file {} is from an unsupported caller.\".format(variant_file))\n        all_stats.append(stats)\n    return merge_fn(all_stats)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting a new item from the queue and execute it.", "response": "def _get_and_execute(self):\n        \"\"\"\n        :return: True if it should continue running, False if it should end its execution.\n        \"\"\"\n        try:\n            work = self.queue.get(timeout=self.max_seconds_idle)\n        except queue.Empty:\n            # max_seconds_idle has been exhausted, exiting\n            self.end_notify()\n            return False\n        else:\n            self._work(work)\n            self.queue.task_done()\n            return True"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef format(self, full_info: bool = False):\n        chat = self.api_object\n        if full_info:\n            self.__format_full(chat)\n        else:\n            self.__format_simple(chat)", "response": ":param full_info: If True, adds more info about the chat. Please, note that this additional info requires\n            to make up to THREE synchronous api calls."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a list of all the settings that are set in the current session", "response": "def list(self):\n        \"\"\"\n        :rtype: list(setting_name, value, default_value, is_set, is_supported)\n        \"\"\"\n        settings = []\n        for setting in _SETTINGS:\n            value = self.get(setting)\n            is_set = self.is_set(setting)\n            default_value = self.get_default_value(setting)\n            is_supported = True\n            settings.append((setting, value, default_value, is_set, is_supported))\n        for setting in sorted(self.settings_state.list_keys()):\n            if not self.is_supported(setting):\n                value = self.get(setting)\n                default_value = None\n                is_set = True\n                is_supported = False\n                settings.append((setting, value, default_value, is_set, is_supported))\n        return settings"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef load_ensembl_coverage(cohort, coverage_path, min_tumor_depth, min_normal_depth=0,\n                          pageant_dir_fn=None):\n    \"\"\"\n    Load in Pageant CoverageDepth results with Ensembl loci.\n\n    coverage_path is a path to Pageant CoverageDepth output directory, with\n    one subdirectory per patient and a `cdf.csv` file inside each patient subdir.\n\n    If min_normal_depth is 0, calculate tumor coverage. Otherwise, calculate\n    join tumor/normal coverage.\n\n    pageant_dir_fn is a function that takes in a Patient and produces a Pageant\n    dir name.\n\n    Last tested with Pageant CoverageDepth version 1ca9ed2.\n    \"\"\"\n    # Function to grab the pageant file name using the Patient\n    if pageant_dir_fn is None:\n        pageant_dir_fn = lambda patient: patient.id\n\n    columns_both = [\n        \"depth1\", # Normal\n        \"depth2\", # Tumor\n        \"onBP1\",\n        \"onBP2\",\n        \"numOnLoci\",\n        \"fracBPOn1\",\n        \"fracBPOn2\",\n        \"fracLociOn\",\n        \"offBP1\",\n        \"offBP2\",\n        \"numOffLoci\",\n        \"fracBPOff1\",\n        \"fracBPOff2\",\n        \"fracLociOff\",\n    ]\n    columns_single = [\n        \"depth\",\n        \"onBP\",\n        \"numOnLoci\",\n        \"fracBPOn\",\n        \"fracLociOn\",\n        \"offBP\",\n        \"numOffLoci\",\n        \"fracBPOff\",\n        \"fracLociOff\"\n    ]\n    if min_normal_depth < 0:\n        raise ValueError(\"min_normal_depth must be >= 0\")\n    use_tumor_only = (min_normal_depth == 0)\n    columns = columns_single if use_tumor_only else columns_both\n    ensembl_loci_dfs = []\n    for patient in cohort:\n        patient_ensembl_loci_df = pd.read_csv(\n            path.join(coverage_path, pageant_dir_fn(patient), \"cdf.csv\"),\n            names=columns,\n            header=1)\n        # pylint: disable=no-member\n        # pylint gets confused by read_csv\n        if use_tumor_only:\n            depth_mask = (patient_ensembl_loci_df.depth == min_tumor_depth)\n        else:\n            depth_mask = (\n                (patient_ensembl_loci_df.depth1 == min_normal_depth) &\n                (patient_ensembl_loci_df.depth2 == min_tumor_depth))\n        patient_ensembl_loci_df = patient_ensembl_loci_df[depth_mask]\n        assert len(patient_ensembl_loci_df) == 1, (\n            \"Incorrect number of tumor={}, normal={} depth loci results: {} for patient {}\".format(\n                min_tumor_depth, min_normal_depth, len(patient_ensembl_loci_df), patient))\n        patient_ensembl_loci_df[\"patient_id\"] = patient.id\n        ensembl_loci_dfs.append(patient_ensembl_loci_df)\n    ensembl_loci_df = pd.concat(ensembl_loci_dfs)\n    ensembl_loci_df[\"MB\"] = ensembl_loci_df.numOnLoci / 1000000.0\n    return ensembl_loci_df[[\"patient_id\", \"numOnLoci\", \"MB\"]]", "response": "Load the ensembl loci coverage data from a path to a pageant coverage file."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a fraction of the vertical size of the plot.", "response": "def vertical_percent(plot, percent=0.1):\n    \"\"\"\n    Using the size of the y axis, return a fraction of that size.\n    \"\"\"\n    plot_bottom, plot_top = plot.get_ylim()\n    return percent * (plot_top - plot_bottom)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef hide_ticks(plot, min_tick_value=None, max_tick_value=None):\n    for tick, tick_value in zip(plot.get_yticklabels(), plot.get_yticks()):\n        tick_label = as_numeric(tick_value)\n        if tick_label:\n            if (min_tick_value is not None and tick_label < min_tick_value or \n                 max_tick_value is not None and tick_label > max_tick_value):\n                tick.set_visible(False)", "response": "Hide all the ticks that are outside of the given limits."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef add_significance_indicator(plot, col_a=0, col_b=1, significant=False):\n    plot_bottom, plot_top = plot.get_ylim()\n    # Give the plot a little room for the significance indicator\n    line_height = vertical_percent(plot, 0.1)\n    # Add some extra spacing below the indicator\n    plot_top = plot_top + line_height\n    # Add some extra spacing above the indicator\n    plot.set_ylim(top=plot_top + line_height * 2)\n    color = \"black\"\n    line_top = plot_top + line_height\n    plot.plot([col_a, col_a, col_b, col_b], [plot_top, line_top, line_top, plot_top], lw=1.5, color=color)\n    indicator = \"*\" if significant else \"ns\"\n    plot.text((col_a + col_b) * 0.5, line_top, indicator, ha=\"center\", va=\"bottom\", color=color)", "response": "Add a p - value significance indicator."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef stripboxplot(x, y, data, ax=None, significant=None, **kwargs):\n    ax = sb.boxplot(\n        x=x,\n        y=y,\n        data=data,\n        ax=ax,\n        fliersize=0,\n        **kwargs\n    )\n\n    plot = sb.stripplot(\n        x=x,\n        y=y,\n        data=data,\n        ax=ax,\n        jitter=kwargs.pop(\"jitter\", 0.05),\n        color=kwargs.pop(\"color\", \"0.3\"),\n        **kwargs\n    )\n\n    if data[y].min() >= 0:\n        hide_negative_y_ticks(plot)\n    if significant is not None:\n        add_significance_indicator(plot=plot, significant=significant)\n\n    return plot", "response": "Overlay a stripplot on top of a boxplot."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nperform a Fisher s Exact test on two binary columns.", "response": "def fishers_exact_plot(data, condition1, condition2, ax=None,\n                       condition1_value=None,\n                       alternative=\"two-sided\", **kwargs):\n    \"\"\"\n    Perform a Fisher's exact test to compare to binary columns\n\n    Parameters\n    ----------\n    data: Pandas dataframe\n        Dataframe to retrieve information from\n\n    condition1: str\n        First binary column to compare (and used for test sidedness)\n\n    condition2: str\n        Second binary column to compare\n\n    ax : Axes, default None\n        Axes to plot on\n\n    condition1_value:\n        If `condition1` is not a binary column, split on =/!= to condition1_value\n\n    alternative:\n        Specify the sidedness of the test: \"two-sided\", \"less\"\n        or \"greater\"\n    \"\"\"\n    plot = sb.barplot(\n        x=condition1,\n        y=condition2,\n        ax=ax,\n        data=data,\n        **kwargs\n    )\n\n    plot.set_ylabel(\"Percent %s\" % condition2)\n    condition1_mask = get_condition_mask(data, condition1, condition1_value)\n    count_table = pd.crosstab(data[condition1], data[condition2])\n    print(count_table)\n    oddsratio, p_value = fisher_exact(count_table, alternative=alternative)\n    add_significance_indicator(plot=plot, significant=p_value <= 0.05)\n    only_percentage_ticks(plot)\n\n    if alternative != \"two-sided\":\n        raise ValueError(\"We need to better understand the one-sided Fisher's Exact test\")\n    sided_str = \"two-sided\"\n    print(\"Fisher's Exact Test: OR: {}, p-value={} ({})\".format(oddsratio, p_value, sided_str))\n    return FishersExactResults(oddsratio=oddsratio,\n                               p_value=p_value,\n                               sided_str=sided_str,\n                               with_condition1_series=data[condition1_mask][condition2],\n                               without_condition1_series=data[~condition1_mask][condition2],\n                               plot=plot)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate a box plot comparing a binary column and perform Mann - Whitney test.", "response": "def mann_whitney_plot(data,\n                      condition,\n                      distribution,\n                      ax=None,\n                      condition_value=None,\n                      alternative=\"two-sided\",\n                      skip_plot=False,\n                      **kwargs):\n    \"\"\"\n    Create a box plot comparing a condition and perform a\n    Mann Whitney test to compare the distribution in condition A v B\n\n    Parameters\n    ----------\n    data: Pandas dataframe\n        Dataframe to retrieve information from\n\n    condition: str\n        Column to use as the splitting criteria\n\n    distribution: str\n        Column to use as the Y-axis or distribution in the test\n\n    ax : Axes, default None\n        Axes to plot on\n\n    condition_value:\n        If `condition` is not a binary column, split on =/!= to condition_value\n\n    alternative:\n        Specify the sidedness of the Mann-Whitney test: \"two-sided\", \"less\"\n        or \"greater\"\n\n    skip_plot:\n        Calculate the test statistic and p-value, but don't plot.\n    \"\"\"\n    condition_mask = get_condition_mask(data, condition, condition_value)\n    U, p_value = mannwhitneyu(\n        data[condition_mask][distribution],\n        data[~condition_mask][distribution],\n        alternative=alternative\n    )\n\n    plot = None\n    if not skip_plot:\n        plot = stripboxplot(\n            x=condition,\n            y=distribution,\n            data=data,\n            ax=ax,\n            significant=p_value <= 0.05,\n            **kwargs\n        )\n\n    sided_str = sided_str_from_alternative(alternative, condition)\n    print(\"Mann-Whitney test: U={}, p-value={} ({})\".format(U, p_value, sided_str))\n    return MannWhitneyResults(U=U,\n                              p_value=p_value,\n                              sided_str=sided_str,\n                              with_condition_series=data[condition_mask][distribution],\n                              without_condition_series=data[~condition_mask][distribution],\n                              plot=plot)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef roc_curve_plot(data, value_column, outcome_column, bootstrap_samples=100, ax=None):\n    scores = bootstrap_auc(df=data,\n                           col=value_column,\n                           pred_col=outcome_column,\n                           n_bootstrap=bootstrap_samples)\n    mean_bootstrap_auc = scores.mean()\n    print(\"{}, Bootstrap (samples = {}) AUC:{}, std={}\".format(\n        value_column, bootstrap_samples, mean_bootstrap_auc, scores.std()))\n\n    outcome = data[outcome_column].astype(int)\n    values = data[value_column]\n    fpr, tpr, thresholds = roc_curve(outcome, values)\n\n    if ax is None:\n        ax = plt.gca()\n\n    roc_plot = ax.plot(fpr, tpr, lw=1, label=value_column)\n\n    ax.set_xlim([-0.05, 1.05])\n    ax.set_ylim([-0.05, 1.05])\n    ax.set_xlabel('False Positive Rate')\n    ax.set_ylabel('True Positive Rate')\n    ax.legend(loc=2, borderaxespad=0.)\n    ax.set_title('{} ROC Curve (n={})'.format(value_column, len(values)))\n\n    return (mean_bootstrap_auc, roc_plot)", "response": "Create a ROC curve and compute the bootstrap AUC for the given variable and outcome"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_cache_dir(cache_dir, cache_root_dir=None, *args, **kwargs):\n    cache_dir = cache_dir.format(*args, **kwargs)\n    if path.isabs(cache_dir):\n        if cache_root_dir is not None:\n            logger.warning('cache_dir ({}) is a full path; ignoring cache_root_dir'.format(cache_dir))\n        return cache_dir\n    if cache_root_dir is not None:\n        return path.join(cache_root_dir, cache_dir)\n    else:\n        logger.warning(\"cache dir is not full path & cache_root_dir not given. Caching may not work as expected!\")\n    return None", "response": "Return full cache_dir according to given args and kwargs"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ngive an object and a dictionary give the object new attributes from that dictionary.", "response": "def set_attributes(obj, additional_data):\n    \"\"\"\n    Given an object and a dictionary, give the object new attributes from that dictionary.\n\n    Uses _strip_column_name to git rid of whitespace/uppercase/special characters.\n    \"\"\"\n    for key, value in additional_data.items():\n        if hasattr(obj, key):\n            raise ValueError(\"Key %s in additional_data already exists in this object\" % key)\n        setattr(obj, _strip_column_name(key), value)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef return_obj(cols, df, return_cols=False):\n        df_holder = DataFrameHolder(cols=cols, df=df)\n        return df_holder.return_self(return_cols=return_cols)", "response": "Construct a DataFrameHolder and then return either that or the DataFrame."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _plot_kmf_single(df,\n                     condition_col,\n                     survival_col,\n                     censor_col,\n                     threshold,\n                     title,\n                     xlabel,\n                     ylabel,\n                     ax,\n                     with_condition_color,\n                     no_condition_color,\n                     with_condition_label,\n                     no_condition_label,\n                     color_map,\n                     label_map,\n                     color_palette,\n                     ci_show,\n                     print_as_title):\n    \"\"\"\n    Helper function to produce a single KM survival plot, among observations in df by groups defined by condition_col.\n\n    All inputs are required - this function is intended to be called by `plot_kmf`.\n    \"\"\"\n    # make color inputs consistent hex format\n    if colors.is_color_like(with_condition_color):\n        with_condition_color = colors.to_hex(with_condition_color)\n    if colors.is_color_like(no_condition_color):\n        no_condition_color = colors.to_hex(no_condition_color)\n    ## prepare data to be plotted; producing 3 outputs:\n    # - `condition`, series containing category labels to be plotted\n    # - `label_map` (mapping condition values to plot labels)\n    # - `color_map` (mapping condition values to plotted colors)\n    if threshold is not None:\n        is_median = threshold == \"median\"\n        if is_median:\n            threshold = df[condition_col].median()\n        label_suffix = float_str(threshold)\n        condition = df[condition_col] > threshold\n        default_label_no_condition = \"%s \u2264 %s\" % (condition_col, label_suffix)\n        if is_median:\n            label_suffix += \" (median)\"\n        default_label_with_condition = \"%s > %s\" % (condition_col, label_suffix)\n        with_condition_label = with_condition_label or default_label_with_condition\n        no_condition_label = no_condition_label or default_label_no_condition\n        if not label_map:\n            label_map = {False: no_condition_label,\n                         True: with_condition_label}\n        if not color_map:\n            color_map = {False: no_condition_color,\n                         True: with_condition_color}\n    elif df[condition_col].dtype == 'O' or df[condition_col].dtype.name == \"category\":\n        condition = df[condition_col].astype(\"category\")\n        if not label_map:\n            label_map = dict()\n            [label_map.update({condition_value: '{} = {}'.format(condition_col,\n                                                        condition_value)})\n                     for condition_value in condition.unique()]\n        if not color_map:\n            rgb_values = sb.color_palette(color_palette, len(label_map.keys()))\n            hex_values = [colors.to_hex(col) for col in rgb_values]\n            color_map = dict(zip(label_map.keys(), hex_values))\n    elif df[condition_col].dtype == 'bool':\n        condition = df[condition_col]\n        default_label_with_condition = \"= {}\".format(condition_col)\n        default_label_no_condition = \"\u00ac {}\".format(condition_col)\n        with_condition_label = with_condition_label or default_label_with_condition\n        no_condition_label = no_condition_label or default_label_no_condition\n        if not label_map:\n            label_map = {False: no_condition_label,\n                         True: with_condition_label}\n        if not color_map:\n            color_map = {False: no_condition_color,\n                         True: with_condition_color}\n    else:\n        raise ValueError('Don\\'t know how to plot data of type\\\n                         {}'.format(df[condition_col].dtype))\n\n    # produce kmf plot for each category (group) identified above\n    kmf = KaplanMeierFitter()\n    grp_desc = list()\n    grp_survival_data = dict()\n    grp_event_data = dict()\n    grp_names = list(condition.unique())\n    for grp_name, grp_df in df.groupby(condition):\n        grp_survival = grp_df[survival_col]\n        grp_event = (grp_df[censor_col].astype(bool))\n        grp_label = label_map[grp_name]\n        grp_color = color_map[grp_name]\n        kmf.fit(grp_survival, grp_event, label=grp_label)\n        desc_str = \"# {}: {}\".format(grp_label, len(grp_survival))\n        grp_desc.append(desc_str)\n        grp_survival_data[grp_name] = grp_survival\n        grp_event_data[grp_name] = grp_event\n        if ax:\n            ax = kmf.plot(ax=ax, show_censors=True, ci_show=ci_show, color=grp_color)\n        else:\n            ax = kmf.plot(show_censors=True, ci_show=ci_show, color=grp_color)\n\n    ## format the plot\n    # Set the y-axis to range 0 to 1\n    ax.set_ylim(0, 1)\n    y_tick_vals = ax.get_yticks()\n    ax.set_yticklabels([\"%d\" % int(y_tick_val * 100) for y_tick_val in y_tick_vals])\n    # plot title\n    if title:\n        ax.set_title(title)\n    elif print_as_title:\n        ax.set_title(' | '.join(grp_desc))\n    else:\n        [print(desc) for desc in grp_desc]\n    # axis labels\n    if xlabel:\n        ax.set_xlabel(xlabel)\n    if ylabel:\n        ax.set_ylabel(ylabel)\n    \n    ## summarize analytical version of results\n    ## again using same groups as are plotted\n    if len(grp_names) == 2:\n        # use log-rank test for 2 groups\n        results = logrank_test(grp_survival_data[grp_names[0]],\n                               grp_survival_data[grp_names[1]],\n                               event_observed_A=grp_event_data[grp_names[0]],\n                               event_observed_B=grp_event_data[grp_names[1]])\n    elif len(grp_names) == 1:\n        # no analytical result for 1 or 0 groups\n        results = NullSurvivalResults()\n    else:\n        # cox PH fitter for >2 groups\n        cf = CoxPHFitter()\n        cox_df = patsy.dmatrix('+'.join([condition_col, survival_col,\n                                         censor_col]),\n                               df, return_type='dataframe')\n        del cox_df['Intercept']\n        results = cf.fit(cox_df, survival_col, event_col=censor_col)\n        results.print_summary()\n    # add metadata to results object so caller can print them\n    results.survival_data_series = grp_survival_data\n    results.event_data_series = grp_event_data\n    results.desc = grp_desc\n    return results", "response": "Helper function to produce a single KM survival plot."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef plot_kmf(df,\n             condition_col,\n             censor_col,\n             survival_col,\n             strata_col=None,\n             threshold=None,\n             title=None,\n             xlabel=None,\n             ylabel=None,\n             ax=None,\n             with_condition_color=\"#B38600\",\n             no_condition_color=\"#A941AC\",\n             with_condition_label=None,\n             no_condition_label=None,\n             color_map=None,\n             label_map=None,\n             color_palette=\"Set1\",\n             ci_show=False,\n             print_as_title=False):\n    \"\"\"\n    Plot survival curves by splitting the dataset into two groups based on\n    condition_col. Report results for a log-rank test (if two groups are plotted)\n    or CoxPH survival analysis (if >2 groups) for association with survival.\n\n    Regarding definition of groups:\n        If condition_col is numeric, values are split into 2 groups.\n             - if threshold is defined, the groups are split on being > or < condition_col\n             - if threshold == 'median', the threshold is set to the median of condition_col\n        If condition_col is categorical or string, results are plotted for each unique value in the dataset.\n        If condition_col is None, results are plotted for all observations\n\n    Currently, if `strata_col` is given, the results are repeated among each stratum of the df.\n    A truly \"stratified\" analysis is not yet supported by may be soon.\n\n    Parameters\n    ----------\n        df: dataframe\n        condition_col: string, column which contains the condition to split on\n        survival_col: string, column which contains the survival time\n        censor_col: string,\n        strata_col: optional string, denoting column containing data to\n                    stratify by (default: None)\n        threshold: int or string, if int, condition_col is thresholded at int,\n                                  if 'median', condition_col thresholded\n                                  at its median\n                                  if 'median-per-strata', & if stratified analysis\n                                  then condition_col thresholded by strata\n        title: Title for the plot, default None\n        ax: an existing matplotlib ax, optional, default None\n             note: not currently supported when `strata_col` is not None\n        with_condition_color: str, hex code color for the with-condition curve\n        no_condition_color: str, hex code color for the no-condition curve\n        with_condition_label: str, optional, label for True condition case\n        no_condition_label: str, optional, label for False condition case\n        color_map: dict, optional, mapping of hex-values to condition text\n          in the form of {value_name: color_hex_code}.\n          defaults to `sb.color_palette` using `default_color_palette` name,\n          or *_condition_color options in case of boolean operators.\n        label_map: dict, optional, mapping of labels to condition text.\n          defaults to \"condition_name = condition_value\", or *_condition_label\n          options in case of boolean operators.\n        color_palette: str, optional, name of sb.color_palette to use\n          if color_map not provided.\n        print_as_title: bool, optional, whether or not to print text\n          within the plot's title vs. stdout, default False\n    \"\"\"\n    \n    # set reasonable default threshold value depending on type of condition_col\n    if threshold is None:\n        if df[condition_col].dtype != \"bool\" and \\\n            np.issubdtype(df[condition_col].dtype, np.number):\n                threshold = \"median\"\n    # check inputs for threshold for validity\n    elif isinstance(threshold, numbers.Number):\n        logger.debug(\"threshold value is numeric\")\n    elif threshold not in (\"median\", \"median-per-strata\"):\n        raise ValueError(\"invalid input for threshold. Must be numeric, None, 'median', or 'median-per-strata'.\")\n    elif threshold == \"median-per-strata\" and strata_col is None:\n        raise ValueError(\"threshold given was 'median-per-strata' and yet `strata_col` was None. Did you mean 'median'?\")\n\n    # construct kwarg dict to pass to _plot_kmf_single.\n    # start with args that do not vary according to strata_col\n    arglist = dict(\n            condition_col=condition_col,\n            survival_col=survival_col,\n            censor_col=censor_col,\n            threshold=threshold,\n            with_condition_color=with_condition_color,\n            no_condition_color=no_condition_color,\n            with_condition_label=with_condition_label,\n            no_condition_label=no_condition_label,\n            color_map=color_map,\n            label_map=label_map,\n            xlabel=xlabel,\n            ylabel=ylabel,\n            ci_show=ci_show,\n            color_palette=color_palette,\n            print_as_title=print_as_title)\n\n    # if strata_col is None, pass all parameters to _plot_kmf_single\n    if strata_col is None:\n        arglist.update(dict(\n            df=df,\n            title=title,\n            ax=ax))\n        return _plot_kmf_single(**arglist)\n    else:\n        # prepare for stratified analysis\n        if threshold == \"median\":\n            # by default, \"median\" threshold should be intra-strata median\n            arglist[\"threshold\"] = df[condition_col].dropna().median()\n        elif threshold == \"median-per-strata\":\n            arglist[\"threshold\"] = \"median\"\n        # create axis / subplots for stratified results\n        if ax is not None:\n            raise ValueError(\"ax not supported with stratified analysis.\")\n        n_strata = len(df[strata_col].unique())\n        f, ax = plt.subplots(n_strata, sharex=True)\n        # create results dict to hold per-strata results\n        results = dict()\n        # call _plot_kmf_single for each of the strata\n        for i, (strat_name, strat_df) in enumerate(df.groupby(strata_col)):\n            if n_strata == 1:\n                arglist[\"ax\"] = ax\n            else:\n                arglist[\"ax\"] = ax[i]\n            subtitle = \"{}: {}\".format(strata_col, strat_name)\n            arglist[\"title\"] = subtitle\n            arglist[\"df\"] = strat_df\n            results[subtitle] = plot_kmf(**arglist)\n            [print(desc) for desc in results[subtitle].desc]\n        if title:\n            f.suptitle(title)\n        return results", "response": "Plots survival curves for a single log - rank test."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef concat(self, formatted_text):\n        assert self._is_compatible(formatted_text), \"Cannot concat text with different modes\"\n        self.text += formatted_text.text\n        return self", "response": "Concatenates the current text with the given formatted text."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef join(self, formatted_texts):\n        formatted_texts = list(formatted_texts)  # so that after the first iteration elements are not lost if generator\n        for formatted_text in formatted_texts:\n            assert self._is_compatible(formatted_text), \"Cannot join text with different modes\"\n        self.text = self.text.join((formatted_text.text for formatted_text in formatted_texts))\n        return self", "response": "Joins the given list of formatted_texts into the current one."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nconcatenates the format_args and format_kwargs into this object.", "response": "def concat(self, *args, **kwargs):\n        \"\"\"\n        :type args: FormattedText\n        :type kwargs: FormattedText\n        \"\"\"\n        for arg in args:\n            assert self.formatted_text._is_compatible(arg), \"Cannot concat text with different modes\"\n            self.format_args.append(arg.text)\n        for kwarg in kwargs:\n            value = kwargs[kwarg]\n            assert self.formatted_text._is_compatible(value), \"Cannot concat text with different modes\"\n            self.format_kwargs[kwarg] = value.text\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef random_cohort(size, cache_dir, data_dir=None,\n                  min_random_variants=None,\n                  max_random_variants=None,\n                  seed_val=1234):\n    \"\"\"\n    Parameters\n    ----------\n    min_random_variants: optional, int\n        Minimum number of random variants to be generated per patient.\n    max_random_variants: optional, int\n        Maximum number of random variants to be generated per patient.\n    \"\"\"\n    seed(seed_val)\n    d = {}\n    d[\"id\"] = [str(id) for id in range(size)]\n    d[\"age\"] = choice([10, 15, 28, 32, 59, 62, 64, 66, 68], size)\n    d[\"smoker\"] = choice([False, True], size)\n    d[\"OS\"] = [randint(10, 1000) for i in range(size)]\n    d[\"PFS\"] = [int(os * 0.6) for os in d[\"OS\"]]\n    d[\"benefit\"] = [pfs < 50 for pfs in d[\"PFS\"]]\n    d[\"random\"] = [randint(100) for i in range(size)]\n    d[\"random_boolean\"] = choice([False, True], size)\n    d[\"benefit_correlate\"] = [randint(50) if benefit else randint(20) for benefit in d[\"benefit\"]]\n    d[\"benefit_correlate_boolean\"] = [True if corr > 10 else False for corr in d[\"benefit_correlate\"]]\n    d[\"deceased\"] = choice([False, True], size)\n    d[\"progressed_or_deceased\"] = [deceased or choice([False, True]) for deceased in d[\"deceased\"]]\n    df = pd.DataFrame(d)\n    patients = []\n    for i, row in df.iterrows():\n        snv_vcf_paths = None\n        if max_random_variants is not None and min_random_variants is not None:\n            if data_dir is None:\n                raise ValueError(\"data_dir must be provided if random variants are being generated.\")\n            vcf_path = path.join(data_dir, \"patient_%s_mutect.vcf\" % row[\"id\"])\n            generate_simple_vcf(\n                vcf_path, generate_random_missense_variants(num_variants=randint(min_random_variants, max_random_variants)))\n            snv_vcf_paths = [vcf_path]\n        patient = Patient(\n            id=row[\"id\"],\n            os=row[\"OS\"],\n            pfs=row[\"PFS\"],\n            benefit=row[\"benefit\"],\n            deceased=row[\"deceased\"],\n            progressed_or_deceased=row[\"progressed_or_deceased\"],\n            hla_alleles=[\"HLA-A02:01\"],\n            variants={\"snv\": snv_vcf_paths},\n            additional_data=row)\n        patients.append(patient)\n    return Cohort(\n        patients=patients,\n        cache_dir=cache_dir,\n        mhc_class=RandomBindingPredictor)", "response": "Generate random patients for a single patient."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef generate_random_missense_variants(num_variants=10, max_search=100000, reference=\"GRCh37\"):\n    variants = []\n    for i in range(max_search):\n        bases = [\"A\", \"C\", \"T\", \"G\"]\n        random_ref = choice(bases)\n        bases.remove(random_ref)\n        random_alt = choice(bases)\n        random_contig = choice([\"1\", \"2\", \"3\", \"4\", \"5\"])\n        random_variant = Variant(contig=random_contig, start=randint(1, 1000000),\n                                 ref=random_ref, alt=random_alt, ensembl=reference)\n        try:\n            effects = random_variant.effects()\n            for effect in effects:\n                if isinstance(effect, Substitution):\n                    variants.append(random_variant)\n                    break\n        except:\n            continue\n        if len(variants) == num_variants:\n            break\n    return VariantCollection(variants)", "response": "Generate a random collection of missense variants."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef generate_simple_vcf(filename, variant_collection):\n    contigs = []\n    positions = []\n    refs = []\n    alts = []\n    for variant in variant_collection:\n        contigs.append(\"chr\" + variant.contig)\n        positions.append(variant.start)\n        refs.append(variant.ref)\n        alts.append(variant.alt)\n    df = pd.DataFrame()\n    df[\"contig\"] = contigs\n    df[\"position\"] = positions\n    df[\"id\"] = [\".\"] * len(variant_collection)\n    df[\"ref\"] = refs\n    df[\"alt\"] = alts\n    df[\"qual\"] = [\".\"] * len(variant_collection)\n    df[\"filter\"] = [\".\"] * len(variant_collection)\n    df[\"info\"] = [\".\"] * len(variant_collection)\n    df[\"format\"] = [\"GT:AD:DP\"] * len(variant_collection)\n    normal_ref_depths = [randint(1, 10) for v in variant_collection]\n    normal_alt_depths = [randint(1, 10) for v in variant_collection]\n    df[\"n1\"] = [\"0:%d,%d:%d\" % (normal_ref_depths[i], normal_alt_depths[i],\n                                normal_ref_depths[i] + normal_alt_depths[i])\n                for i in range(len(variant_collection))]\n    tumor_ref_depths = [randint(1, 10) for v in variant_collection]\n    tumor_alt_depths = [randint(1, 10) for v in variant_collection]\n    df[\"t1\"] = [\"0/1:%d,%d:%d\" % (tumor_ref_depths[i], tumor_alt_depths[i], tumor_ref_depths[i] + tumor_alt_depths[i])\n                for i in range(len(variant_collection))]\n\n    with open(filename, \"w\") as f:\n        f.write(\"##fileformat=VCFv4.1\\n\")\n        f.write(\"##reference=file:///projects/ngs/resources/gatk/2.3/ucsc.hg19.fasta\\n\")\n\n    with open(filename, \"a\") as f:\n        df.to_csv(f, sep=\"\\t\", index=None, header=None)", "response": "Generate a very simple VCF file for each variant in a variant_collection."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nlook up folder contents of path.", "response": "def list_folder(self, path):\n        \"\"\"Looks up folder contents of `path.`\"\"\"\n        # Inspired by https://github.com/rspivak/sftpserver/blob/0.3/src/sftpserver/stub_sftp.py#L70\n        try:\n            folder_contents = []\n            for f in os.listdir(path):\n                attr = paramiko.SFTPAttributes.from_stat(os.stat(os.path.join(path, f)))\n                attr.filename = f\n                folder_contents.append(attr)\n            return folder_contents\n        except OSError as e:\n            return SFTPServer.convert_errno(e.errno)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nfilters variants from the Variant Collection", "response": "def filter_variants(variant_collection, patient, filter_fn, **kwargs):\n    \"\"\"Filter variants from the Variant Collection\n\n    Parameters\n    ----------\n    variant_collection : varcode.VariantCollection\n    patient : cohorts.Patient\n    filter_fn: function\n        Takes a FilterableVariant and returns a boolean. Only variants returning True are preserved.\n\n    Returns\n    -------\n    varcode.VariantCollection\n        Filtered variant collection, with only the variants passing the filter\n    \"\"\"\n    if filter_fn:\n        return variant_collection.clone_with_new_elements([\n            variant\n            for variant in variant_collection\n            if filter_fn(FilterableVariant(\n                        variant=variant,\n                        variant_collection=variant_collection,\n                        patient=patient,\n                        ), **kwargs)\n        ])\n    else:\n        return variant_collection"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef filter_effects(effect_collection, variant_collection, patient, filter_fn, all_effects, **kwargs):\n    def top_priority_maybe(effect_collection):\n        \"\"\"\n        Always (unless all_effects=True) take the top priority effect per variant\n        so we end up with a single effect per variant.\n        \"\"\"\n        if all_effects:\n            return effect_collection\n        return EffectCollection(list(effect_collection.top_priority_effect_per_variant().values()))\n\n    def apply_filter_fn(filter_fn, effect):\n        \"\"\"\n        Return True if filter_fn is true for the effect or its alternate_effect.\n        If no alternate_effect, then just return True if filter_fn is True.\n        \"\"\"\n        applied = filter_fn(FilterableEffect(\n            effect=effect,\n            variant_collection=variant_collection,\n            patient=patient), **kwargs)\n        if hasattr(effect, \"alternate_effect\"):\n            applied_alternate = filter_fn(FilterableEffect(\n                effect=effect.alternate_effect,\n                variant_collection=variant_collection,\n                patient=patient), **kwargs)\n            return applied or applied_alternate\n        return applied\n\n    if filter_fn:\n        return top_priority_maybe(EffectCollection([\n            effect\n            for effect in effect_collection\n            if apply_filter_fn(filter_fn, effect)]))\n    else:\n        return top_priority_maybe(effect_collection)", "response": "Filter variants from the Effect Collection and return a new effect collection."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef count_lines_in(filename):\n    \"Count lines in a file\"\n    f = open(filename)                  \n    lines = 0\n    buf_size = 1024 * 1024\n    read_f = f.read # loop optimization\n    \n    buf = read_f(buf_size)\n    while buf:\n        lines += buf.count('\\n')\n        buf = read_f(buf_size)\n    \n    return lines", "response": "Count lines in a file"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef view_name_from(path):\n    \"Resolve a path to the full python module name of the related view function\"\n    try:\n        return CACHED_VIEWS[path]\n        \n    except KeyError:\n        view = resolve(path)\n        module = path\n        name = ''\n        if hasattr(view.func, '__module__'):\n            module = resolve(path).func.__module__\n        if hasattr(view.func, '__name__'):\n            name = resolve(path).func.__name__\n        \n        view =  \"%s.%s\" % (module, name)\n        CACHED_VIEWS[path] = view\n        return view", "response": "Resolve a path to the full python module name of the related view function"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef generate_table_from(data):\n    \"Output a nicely formatted ascii table\"\n    table = Texttable(max_width=120)\n    table.add_row([\"view\", \"method\", \"status\", \"count\", \"minimum\", \"maximum\", \"mean\", \"stdev\", \"queries\", \"querytime\"]) \n    table.set_cols_align([\"l\", \"l\", \"l\", \"r\", \"r\", \"r\", \"r\", \"r\", \"r\", \"r\"])\n\n    for item in sorted(data):\n        mean = round(sum(data[item]['times'])/data[item]['count'], 3)\n\n        mean_sql = round(sum(data[item]['sql'])/data[item]['count'], 3)\n        mean_sqltime = round(sum(data[item]['sqltime'])/data[item]['count'], 3)\n        \n        sdsq = sum([(i - mean) ** 2 for i in data[item]['times']])\n        try:\n            stdev = '%.2f' % ((sdsq / (len(data[item]['times']) - 1)) ** .5)\n        except ZeroDivisionError:\n            stdev = '0.00'\n\n        minimum = \"%.2f\" % min(data[item]['times'])\n        maximum = \"%.2f\" % max(data[item]['times'])\n        table.add_row([data[item]['view'], data[item]['method'], data[item]['status'], data[item]['count'], minimum, maximum, '%.3f' % mean, stdev, mean_sql, mean_sqltime])\n\n    return table.draw()", "response": "Output a nicely formatted ascii table"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ngive a log file and regex group and extract the performance data", "response": "def analyze_log_file(logfile, pattern, reverse_paths=True, progress=True):\n    \"Given a log file and regex group and extract the performance data\"\n    if progress:\n        lines = count_lines_in(logfile)\n        pbar = ProgressBar(widgets=[Percentage(), Bar()], maxval=lines+1).start()\n        counter = 0\n    \n    data = {}\n    \n    compiled_pattern = compile(pattern)\n    for line in fileinput.input([logfile]):\n        \n        if progress:\n            counter = counter + 1\n        \n        parsed = compiled_pattern.findall(line)[0]\n        date = parsed[0]\n        method = parsed[1]\n        path = parsed[2]\n        status = parsed[3]\n        time = parsed[4]\n        sql = parsed[5]\n        sqltime = parsed[6]\n\n        try:\n            ignore = False\n            for ignored_path in IGNORE_PATHS:\n                compiled_path = compile(ignored_path)\n                if compiled_path.match(path):\n                    ignore = True\n            if not ignore:\n                if reverse_paths:\n                    view = view_name_from(path)\n                else:\n                    view = path\n                key = \"%s-%s-%s\" % (view, status, method)\n                try:\n                    data[key]['count'] = data[key]['count'] + 1\n                    data[key]['times'].append(float(time))\n                    data[key]['sql'].append(int(sql))\n                    data[key]['sqltime'].append(float(sqltime))\n                except KeyError:\n                    data[key] = {\n                        'count': 1,\n                        'status': status,\n                        'view': view,\n                        'method': method,\n                        'times': [float(time)],\n                        'sql': [int(sql)],\n                        'sqltime': [float(sqltime)],\n                    }\n        except Resolver404:\n            pass\n        \n        if progress:\n            pbar.update(counter)\n    \n    if progress:\n        pbar.finish()\n    \n    return data"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate a string representation of this collection showing up to limit items.", "response": "def to_string(self, limit=None):\n        \"\"\"\n        Create a string representation of this collection, showing up to\n        `limit` items.\n        \"\"\"\n        header = self.short_string()\n        if len(self) == 0:\n            return header\n        contents = \"\"\n        element_lines = [\n            \"  -- %s\" % (element,)\n            for element in self.elements[:limit]\n        ]\n        contents = \"\\n\".join(element_lines)\n\n        if limit is not None and len(self.elements) > limit:\n            contents += \"\\n  ... and %d more\" % (len(self) - limit)\n        return \"%s\\n%s\" % (header, contents)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_instance(cls, state):\n        if cls.instance is None:\n            cls.instance = UserStorageHandler(state)\n        return cls.instance", "response": "Returns the instance of the class based on the given state."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _get_active_threads_names():\n        active_threads = threading.enumerate()\n        return FormattedText().join(\n            [\n                FormattedText().newline().normal(\" - {name}\").start_format().bold(name=thread.name).end_format()\n                for thread in active_threads\n            ]\n        )", "response": "Return a string with the active threads."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef format(self, member_info: bool = False):\n        user = self.api_object\n        self.__format_user(user)\n        if member_info and self.chat.type != CHAT_TYPE_PRIVATE:\n            self._add_empty()\n            self.__format_member(user)", "response": "Formats the user and chat members."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nlog error failing silently on error", "response": "def safe_log_error(self, error: Exception, *info: str):\n        \"\"\"Log error failing silently on error\"\"\"\n        self.__do_safe(lambda: self.logger.error(error, *info))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef safe_log_info(self, *info: str):\n        self.__do_safe(lambda: self.logger.info(*info))", "response": "Log info failing silently on error"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef wald_wolfowitz(sequence):\n    R = n_runs = sum(1 for s in groupby(sequence, lambda a: a))\n\n    n = float(sum(1 for s in sequence if s == sequence[0]))\n    m = float(sum(1 for s in sequence if s != sequence[0]))\n\n    # expected mean runs\n    ER = ((2 * n * m ) / (n + m)) + 1\n    # expected variance runs\n    VR = (2 * n * m * (2 * n * m - n - m )) / ((n + m)**2 * (n + m - 1))\n    O = (ER - 1) * (ER - 2) / (n + m - 1.)\n    assert VR - O < 0.001, (VR, O)\n\n    SD = math.sqrt(VR)\n    # Z-score\n    Z = (R - ER) / SD\n\n    return {'z': Z, 'mean': ER, 'sd': SD, 'p': zprob(Z), 'n_runs': R}", "response": "A wald - wolfowitz test for the WALD - Wolfowitz runs test."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef auto_correlation(sequence):\n    if isinstance(sequence, basestring):\n        sequence = map(int, sequence)\n    seq = np.array(list(sequence), dtype=np.float)\n    dseq = np.column_stack((seq[1:], seq[:-1]))\n    slope, intercept, r, ttp, see = linregress(seq[1:], seq[:-1])\n    cc = np.corrcoef(dseq, rowvar=0)[0][1]\n    return {'slope': slope, 'intercept': intercept, 'r-squared': r ** 2,\n            'p': ttp, 'see': see, 'auto_correlation': cc}", "response": "test for the autocorrelation of a sequence between t and t - 1\n   "}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _parse_header_links(response):\n    values = response.headers.getRawHeaders(b'link', [b''])\n    value = b','.join(values).decode('ascii')\n    with LOG_HTTP_PARSE_LINKS(raw_link=value) as action:\n        links = {}\n        replace_chars = u' \\'\"'\n        for val in re.split(u', *<', value):\n            try:\n                url, params = val.split(u';', 1)\n            except ValueError:\n                url, params = val, u''\n\n            link = {}\n            link[u'url'] = url.strip(u'<> \\'\"')\n            for param in params.split(u';'):\n                try:\n                    key, value = param.split(u'=')\n                except ValueError:\n                    break\n                link[key.strip(replace_chars)] = value.strip(replace_chars)\n            links[link.get(u'rel') or link.get(u'url')] = link\n        action.add_success_fields(parsed_links=links)\n        return links", "response": "Parse the Link header field."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _default_client(jws_client, reactor, key, alg):\n    if jws_client is None:\n        pool = HTTPConnectionPool(reactor)\n        agent = Agent(reactor, pool=pool)\n        jws_client = JWSClient(HTTPClient(agent=agent), key, alg)\n    return jws_client", "response": "Create a default client if one hasn t already been created."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nfinding a suitable challenge combination that consists of a single challenge that the responder can satisfy.", "response": "def _find_supported_challenge(authzr, responders):\n    \"\"\"\n    Find a challenge combination that consists of a single challenge that the\n    responder can satisfy.\n\n    :param ~acme.messages.AuthorizationResource auth: The authorization to\n        examine.\n\n    :type responder: List[`~txacme.interfaces.IResponder`]\n    :param responder: The possible responders to use.\n\n    :raises NoSupportedChallenges: When a suitable challenge combination is not\n        found.\n\n    :rtype: Tuple[`~txacme.interfaces.IResponder`,\n            `~acme.messages.ChallengeBody`]\n    :return: The responder and challenge that were found.\n    \"\"\"\n    matches = [\n        (responder, challbs[0])\n        for challbs in authzr.body.resolved_combinations\n        for responder in responders\n        if [challb.typ for challb in challbs] == [responder.challenge_type]]\n    if len(matches) == 0:\n        raise NoSupportedChallenges(authzr)\n    else:\n        return matches[0]"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef answer_challenge(authzr, client, responders):\n    responder, challb = _find_supported_challenge(authzr, responders)\n    response = challb.response(client.key)\n\n    def _stop_responding():\n        return maybeDeferred(\n            responder.stop_responding,\n            authzr.body.identifier.value,\n            challb.chall,\n            response)\n    return (\n        maybeDeferred(\n            responder.start_responding,\n            authzr.body.identifier.value,\n            challb.chall,\n            response)\n        .addCallback(lambda _: client.answer_challenge(challb, response))\n        .addCallback(lambda _: _stop_responding)\n        )", "response": "Complete an authorization using a responder."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\npoll an authorization until it is in a state other than pending processing or a timeout is reached.", "response": "def poll_until_valid(authzr, clock, client, timeout=300.0):\n    \"\"\"\n    Poll an authorization until it is in a state other than pending or\n    processing.\n\n    :param ~acme.messages.AuthorizationResource auth: The authorization to\n        complete.\n    :param clock: The ``IReactorTime`` implementation to use; usually the\n        reactor, when not testing.\n    :param .Client client: The ACME client.\n    :param float timeout: Maximum time to poll in seconds, before giving up.\n\n    :raises txacme.client.AuthorizationFailed: if the authorization is no\n        longer in the pending, processing, or valid states.\n    :raises: ``twisted.internet.defer.CancelledError`` if the authorization was\n        still in pending or processing state when the timeout was reached.\n\n    :rtype: Deferred[`~acme.messages.AuthorizationResource`]\n    :return: A deferred firing when the authorization has completed/failed; if\n             the authorization is valid, the authorization resource will be\n             returned.\n    \"\"\"\n    def repoll(result):\n        authzr, retry_after = result\n        if authzr.body.status in {STATUS_PENDING, STATUS_PROCESSING}:\n            return (\n                deferLater(clock, retry_after, lambda: None)\n                .addCallback(lambda _: client.poll(authzr))\n                .addCallback(repoll)\n                )\n        if authzr.body.status != STATUS_VALID:\n            raise AuthorizationFailed(authzr)\n        return authzr\n\n    def cancel_timeout(result):\n        if timeout_call.active():\n            timeout_call.cancel()\n        return result\n    d = client.poll(authzr).addCallback(repoll)\n    timeout_call = clock.callLater(timeout, d.cancel)\n    d.addBoth(cancel_timeout)\n    return d"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef from_url(cls, reactor, url, key, alg=RS256, jws_client=None):\n        action = LOG_ACME_CONSUME_DIRECTORY(\n            url=url, key_type=key.typ, alg=alg.name)\n        with action.context():\n            check_directory_url_type(url)\n            jws_client = _default_client(jws_client, reactor, key, alg)\n            return (\n                DeferredContext(jws_client.get(url.asText()))\n                .addCallback(json_content)\n                .addCallback(messages.Directory.from_json)\n                .addCallback(\n                    tap(lambda d: action.add_success_fields(directory=d)))\n                .addCallback(cls, reactor, key, jws_client)\n                .addActionFinish())", "response": "Construct a new client from an ACME directory at a given URL."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating a new registration with the ACME server.", "response": "def register(self, new_reg=None):\n        \"\"\"\n        Create a new registration with the ACME server.\n\n        :param ~acme.messages.NewRegistration new_reg: The registration message\n            to use, or ``None`` to construct one.\n\n        :return: The registration resource.\n        :rtype: Deferred[`~acme.messages.RegistrationResource`]\n        \"\"\"\n        if new_reg is None:\n            new_reg = messages.NewRegistration()\n        action = LOG_ACME_REGISTER(registration=new_reg)\n        with action.context():\n            return (\n                DeferredContext(\n                    self.update_registration(\n                        new_reg, uri=self.directory[new_reg]))\n                .addErrback(self._maybe_registered, new_reg)\n                .addCallback(\n                    tap(lambda r: action.add_success_fields(registration=r)))\n                .addActionFinish())"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the URI if there is one.", "response": "def _maybe_location(cls, response, uri=None):\n        \"\"\"\n        Get the Location: if there is one.\n        \"\"\"\n        location = response.headers.getRawHeaders(b'location', [None])[0]\n        if location is not None:\n            return location.decode('ascii')\n        return uri"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _maybe_registered(self, failure, new_reg):\n        failure.trap(ServerError)\n        response = failure.value.response\n        if response.code == http.CONFLICT:\n            reg = new_reg.update(\n                resource=messages.UpdateRegistration.resource_type)\n            uri = self._maybe_location(response)\n            return self.update_registration(reg, uri=uri)\n        return failure", "response": "If the registration already exists we should just load it."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef agree_to_tos(self, regr):\n        return self.update_registration(\n            regr.update(\n                body=regr.body.update(\n                    agreement=regr.terms_of_service)))", "response": "Accept the terms - of - service for a registration resource."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsubmits a new registration to the server to update it.", "response": "def update_registration(self, regr, uri=None):\n        \"\"\"\n        Submit a registration to the server to update it.\n\n        :param ~acme.messages.RegistrationResource regr: The registration to\n            update.  Can be a :class:`~acme.messages.NewRegistration` instead,\n            in order to create a new registration.\n        :param str uri: The url to submit to.  Must be\n            specified if a :class:`~acme.messages.NewRegistration` is provided.\n\n        :return: The updated registration resource.\n        :rtype: Deferred[`~acme.messages.RegistrationResource`]\n        \"\"\"\n        if uri is None:\n            uri = regr.uri\n        if isinstance(regr, messages.RegistrationResource):\n            message = messages.UpdateRegistration(**dict(regr.body))\n        else:\n            message = regr\n        action = LOG_ACME_UPDATE_REGISTRATION(uri=uri, registration=message)\n        with action.context():\n            return (\n                DeferredContext(self._client.post(uri, message))\n                .addCallback(self._parse_regr_response, uri=uri)\n                .addCallback(self._check_regr, regr)\n                .addCallback(\n                    tap(lambda r: action.add_success_fields(registration=r)))\n                .addActionFinish())"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _parse_regr_response(self, response, uri=None, new_authzr_uri=None,\n                             terms_of_service=None):\n        \"\"\"\n        Parse a registration response from the server.\n        \"\"\"\n        links = _parse_header_links(response)\n        if u'terms-of-service' in links:\n            terms_of_service = links[u'terms-of-service'][u'url']\n        if u'next' in links:\n            new_authzr_uri = links[u'next'][u'url']\n        if new_authzr_uri is None:\n            raise errors.ClientError('\"next\" link missing')\n        return (\n            response.json()\n            .addCallback(\n                lambda body:\n                messages.RegistrationResource(\n                    body=messages.Registration.from_json(body),\n                    uri=self._maybe_location(response, uri=uri),\n                    new_authzr_uri=new_authzr_uri,\n                    terms_of_service=terms_of_service))\n            )", "response": "Parse a registration response from the server."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nchecks that a registration response contains the expected registration.", "response": "def _check_regr(self, regr, new_reg):\n        \"\"\"\n        Check that a registration response contains the registration we were\n        expecting.\n        \"\"\"\n        body = getattr(new_reg, 'body', new_reg)\n        for k, v in body.items():\n            if k == 'resource' or not v:\n                continue\n            if regr.body[k] != v:\n                raise errors.UnexpectedUpdate(regr)\n        if regr.body.key != self.key.public_key():\n            raise errors.UnexpectedUpdate(regr)\n        return regr"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef request_challenges(self, identifier):\n        action = LOG_ACME_CREATE_AUTHORIZATION(identifier=identifier)\n        with action.context():\n            message = messages.NewAuthorization(identifier=identifier)\n            return (\n                DeferredContext(\n                    self._client.post(self.directory[message], message))\n                .addCallback(self._expect_response, http.CREATED)\n                .addCallback(self._parse_authorization)\n                .addCallback(self._check_authorization, identifier)\n                .addCallback(\n                    tap(lambda a: action.add_success_fields(authorization=a)))\n                .addActionFinish())", "response": "Create a new authorization resource."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nensuring we got the expected response code.", "response": "def _expect_response(cls, response, code):\n        \"\"\"\n        Ensure we got the expected response code.\n        \"\"\"\n        if response.code != code:\n            raise errors.ClientError(\n                'Expected {!r} response but got {!r}'.format(\n                    code, response.code))\n        return response"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _parse_authorization(cls, response, uri=None):\n        links = _parse_header_links(response)\n        try:\n            new_cert_uri = links[u'next'][u'url']\n        except KeyError:\n            raise errors.ClientError('\"next\" link missing')\n        return (\n            response.json()\n            .addCallback(\n                lambda body: messages.AuthorizationResource(\n                    body=messages.Authorization.from_json(body),\n                    uri=cls._maybe_location(response, uri=uri),\n                    new_cert_uri=new_cert_uri))\n            )", "response": "Parse an authorization resource."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _check_authorization(cls, authzr, identifier):\n        if authzr.body.identifier != identifier:\n            raise errors.UnexpectedUpdate(authzr)\n        return authzr", "response": "Check that the authorization we got is the one we expected."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nresponding to an authorization challenge.", "response": "def answer_challenge(self, challenge_body, response):\n        \"\"\"\n        Respond to an authorization challenge.\n\n        :param ~acme.messages.ChallengeBody challenge_body: The challenge being\n            responded to.\n        :param ~acme.challenges.ChallengeResponse response: The response to the\n            challenge.\n\n        :return: The updated challenge resource.\n        :rtype: Deferred[`~acme.messages.ChallengeResource`]\n        \"\"\"\n        action = LOG_ACME_ANSWER_CHALLENGE(\n            challenge_body=challenge_body, response=response)\n        with action.context():\n            return (\n                DeferredContext(\n                    self._client.post(challenge_body.uri, response))\n                .addCallback(self._parse_challenge)\n                .addCallback(self._check_challenge, challenge_body)\n                .addCallback(\n                    tap(lambda c:\n                        action.add_success_fields(challenge_resource=c)))\n                .addActionFinish())"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _parse_challenge(cls, response):\n        links = _parse_header_links(response)\n        try:\n            authzr_uri = links['up']['url']\n        except KeyError:\n            raise errors.ClientError('\"up\" link missing')\n        return (\n            response.json()\n            .addCallback(\n                lambda body: messages.ChallengeResource(\n                    authzr_uri=authzr_uri,\n                    body=messages.ChallengeBody.from_json(body)))\n            )", "response": "Parse a challenge resource."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _check_challenge(cls, challenge, challenge_body):\n        if challenge.uri != challenge_body.uri:\n            raise errors.UnexpectedUpdate(challenge.uri)\n        return challenge", "response": "Check that the challenge resource we got is the one we expected."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef poll(self, authzr):\n        action = LOG_ACME_POLL_AUTHORIZATION(authorization=authzr)\n        with action.context():\n            return (\n                DeferredContext(self._client.get(authzr.uri))\n                # Spec says we should get 202 while pending, Boulder actually\n                # sends us 200 always, so just don't check.\n                # .addCallback(self._expect_response, http.ACCEPTED)\n                .addCallback(\n                    lambda res:\n                    self._parse_authorization(res, uri=authzr.uri)\n                    .addCallback(\n                        self._check_authorization, authzr.body.identifier)\n                    .addCallback(\n                        lambda authzr:\n                        (authzr,\n                         self.retry_after(res, _now=self._clock.seconds)))\n                )\n                .addCallback(tap(\n                    lambda a_r: action.add_success_fields(\n                        authorization=a_r[0], retry_after=a_r[1])))\n                .addActionFinish())", "response": "Poll an authorization from the server."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef retry_after(cls, response, default=5, _now=time.time):\n        val = response.headers.getRawHeaders(b'retry-after', [default])[0]\n        try:\n            return int(val)\n        except ValueError:\n            return http.stringToDatetime(val) - _now()", "response": "Parse the Retry - After value from a response."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef request_issuance(self, csr):\n        action = LOG_ACME_REQUEST_CERTIFICATE()\n        with action.context():\n            return (\n                DeferredContext(\n                    self._client.post(\n                        self.directory[csr], csr,\n                        content_type=DER_CONTENT_TYPE,\n                        headers=Headers({b'Accept': [DER_CONTENT_TYPE]})))\n                .addCallback(self._expect_response, http.CREATED)\n                .addCallback(self._parse_certificate)\n                .addActionFinish())", "response": "Request a certificate.\n\n        Authorizations should have already been completed for all of the names\n        requested in the CSR.\n\n        Note that unlike `acme.client.Client.request_issuance`, the certificate\n        resource will have the body data as raw bytes.\n\n        ..  seealso:: `txacme.util.csr_for_names`\n\n        ..  todo:: Delayed issuance is not currently supported, the server must\n                   issue the requested certificate immediately.\n\n        :param csr: A certificate request message: normally\n            `txacme.messages.CertificateRequest` or\n            `acme.messages.CertificateRequest`.\n\n        :rtype: Deferred[`acme.messages.CertificateResource`]\n        :return: The issued certificate."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nparsing a response containing a certificate resource.", "response": "def _parse_certificate(cls, response):\n        \"\"\"\n        Parse a response containing a certificate resource.\n        \"\"\"\n        links = _parse_header_links(response)\n        try:\n            cert_chain_uri = links[u'up'][u'url']\n        except KeyError:\n            cert_chain_uri = None\n        return (\n            response.content()\n            .addCallback(\n                lambda body: messages.CertificateResource(\n                    uri=cls._maybe_location(response),\n                    cert_chain_uri=cert_chain_uri,\n                    body=body))\n            )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef fetch_chain(self, certr, max_length=10):\n        action = LOG_ACME_FETCH_CHAIN()\n        with action.context():\n            if certr.cert_chain_uri is None:\n                return succeed([])\n            elif max_length < 1:\n                raise errors.ClientError('chain too long')\n            return (\n                DeferredContext(\n                    self._client.get(\n                        certr.cert_chain_uri,\n                        content_type=DER_CONTENT_TYPE,\n                        headers=Headers({b'Accept': [DER_CONTENT_TYPE]})))\n                .addCallback(self._parse_certificate)\n                .addCallback(\n                    lambda issuer:\n                    self.fetch_chain(issuer, max_length=max_length - 1)\n                    .addCallback(lambda chain: [issuer] + chain))\n                .addActionFinish())", "response": "Fetch the intermediary chain for a certificate."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nwrapping a JSONDeSerializable object in JWS.", "response": "def _wrap_in_jws(self, nonce, obj):\n        \"\"\"\n        Wrap ``JSONDeSerializable`` object in JWS.\n\n        ..  todo:: Implement ``acmePath``.\n\n        :param ~josepy.interfaces.JSONDeSerializable obj:\n        :param bytes nonce:\n\n        :rtype: `bytes`\n        :return: JSON-encoded data\n        \"\"\"\n        with LOG_JWS_SIGN(key_type=self._key.typ, alg=self._alg.name,\n                          nonce=nonce):\n            jobj = obj.json_dumps().encode()\n            return (\n                JWS.sign(\n                    payload=jobj, key=self._key, alg=self._alg, nonce=nonce)\n                .json_dumps()\n                .encode())"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _check_response(cls, response, content_type=JSON_CONTENT_TYPE):\n        def _got_failure(f):\n            f.trap(ValueError)\n            return None\n\n        def _got_json(jobj):\n            if 400 <= response.code < 600:\n                if response_ct == JSON_ERROR_CONTENT_TYPE and jobj is not None:\n                    raise ServerError(\n                        messages.Error.from_json(jobj), response)\n                else:\n                    # response is not JSON object\n                    raise errors.ClientError(response)\n            elif response_ct != content_type:\n                raise errors.ClientError(\n                    'Unexpected response Content-Type: {0!r}'.format(\n                        response_ct))\n            elif content_type == JSON_CONTENT_TYPE and jobj is None:\n                raise errors.ClientError(response)\n            return response\n\n        response_ct = response.headers.getRawHeaders(\n            b'Content-Type', [None])[0]\n        action = LOG_JWS_CHECK_RESPONSE(\n            expected_content_type=content_type,\n            response_content_type=response_ct)\n        with action.context():\n            # TODO: response.json() is called twice, once here, and\n            # once in _get and _post clients\n            return (\n                DeferredContext(response.json())\n                .addErrback(_got_failure)\n                .addCallback(_got_json)\n                .addActionFinish())", "response": "Check the response content and its type."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nsend a request to the JWS.", "response": "def _send_request(self, method, url, *args, **kwargs):\n        \"\"\"\n        Send HTTP request.\n\n        :param str method: The HTTP method to use.\n        :param str url: The URL to make the request to.\n\n        :return: Deferred firing with the HTTP response.\n        \"\"\"\n        action = LOG_JWS_REQUEST(url=url)\n        with action.context():\n            headers = kwargs.setdefault('headers', Headers())\n            headers.setRawHeaders(b'user-agent', [self._user_agent])\n            kwargs.setdefault('timeout', self.timeout)\n            return (\n                DeferredContext(\n                    self._treq.request(method, url, *args, **kwargs))\n                .addCallback(\n                    tap(lambda r: action.add_success_fields(\n                        code=r.code,\n                        content_type=r.headers.getRawHeaders(\n                            b'content-type', [None])[0])))\n                .addActionFinish())"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsending a HEAD request without checking the response.", "response": "def head(self, url, *args, **kwargs):\n        \"\"\"\n        Send HEAD request without checking the response.\n\n        Note that ``_check_response`` is not called, as there will be no\n        response body to check.\n\n        :param str url: The URL to make the request to.\n        \"\"\"\n        with LOG_JWS_HEAD().context():\n            return DeferredContext(\n                self._send_request(u'HEAD', url, *args, **kwargs)\n                ).addActionFinish()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nsend a GET request and check response.", "response": "def get(self, url, content_type=JSON_CONTENT_TYPE, **kwargs):\n        \"\"\"\n        Send GET request and check response.\n\n        :param str method: The HTTP method to use.\n        :param str url: The URL to make the request to.\n\n        :raises txacme.client.ServerError: If server response body carries HTTP\n            Problem (draft-ietf-appsawg-http-problem-00).\n        :raises acme.errors.ClientError: In case of other protocol errors.\n\n        :return: Deferred firing with the checked HTTP response.\n        \"\"\"\n        with LOG_JWS_GET().context():\n            return (\n                DeferredContext(self._send_request(u'GET', url, **kwargs))\n                .addCallback(self._check_response, content_type=content_type)\n                .addActionFinish())"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _add_nonce(self, response):\n        nonce = response.headers.getRawHeaders(\n            REPLAY_NONCE_HEADER, [None])[0]\n        with LOG_JWS_ADD_NONCE(raw_nonce=nonce) as action:\n            if nonce is None:\n                raise errors.MissingNonce(response)\n            else:\n                try:\n                    decoded_nonce = Header._fields['nonce'].decode(\n                        nonce.decode('ascii')\n                    )\n                    action.add_success_fields(nonce=decoded_nonce)\n                except DeserializationError as error:\n                    raise errors.BadNonce(nonce, error)\n                self._nonces.add(decoded_nonce)\n                return response", "response": "Add a nonce from a response we received."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget a nonce to use in a request.", "response": "def _get_nonce(self, url):\n        \"\"\"\n        Get a nonce to use in a request, removing it from the nonces on hand.\n        \"\"\"\n        action = LOG_JWS_GET_NONCE()\n        if len(self._nonces) > 0:\n            with action:\n                nonce = self._nonces.pop()\n                action.add_success_fields(nonce=nonce)\n                return succeed(nonce)\n        else:\n            with action.context():\n                return (\n                    DeferredContext(self.head(url))\n                    .addCallback(self._add_nonce)\n                    .addCallback(lambda _: self._nonces.pop())\n                    .addCallback(tap(\n                        lambda nonce: action.add_success_fields(nonce=nonce)))\n                    .addActionFinish())"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\npost an object and check the response.", "response": "def _post(self, url, obj, content_type, **kwargs):\n        \"\"\"\n        POST an object and check the response.\n\n        :param str url: The URL to request.\n        :param ~josepy.interfaces.JSONDeSerializable obj: The serializable\n            payload of the request.\n        :param bytes content_type: The expected content type of the response.\n\n        :raises txacme.client.ServerError: If server response body carries HTTP\n            Problem (draft-ietf-appsawg-http-problem-00).\n        :raises acme.errors.ClientError: In case of other protocol errors.\n        \"\"\"\n        with LOG_JWS_POST().context():\n            headers = kwargs.setdefault('headers', Headers())\n            headers.setRawHeaders(b'content-type', [JSON_CONTENT_TYPE])\n            return (\n                DeferredContext(self._get_nonce(url))\n                .addCallback(self._wrap_in_jws, obj)\n                .addCallback(\n                    lambda data: self._send_request(\n                        u'POST', url, data=data, **kwargs))\n                .addCallback(self._add_nonce)\n                .addCallback(self._check_response, content_type=content_type)\n                .addActionFinish())"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef post(self, url, obj, content_type=JSON_CONTENT_TYPE, **kwargs):\n        def retry_bad_nonce(f):\n            f.trap(ServerError)\n            # The current RFC draft defines the namespace as\n            # urn:ietf:params:acme:error:<code>, but earlier drafts (and some\n            # current implementations) use urn:acme:error:<code> instead. We\n            # don't really care about the namespace here, just the error code.\n            if f.value.message.typ.split(':')[-1] == 'badNonce':\n                # If one nonce is bad, others likely are too. Let's clear them\n                # and re-add the one we just got.\n                self._nonces.clear()\n                self._add_nonce(f.value.response)\n                return self._post(url, obj, content_type, **kwargs)\n            return f\n        return (\n            self._post(url, obj, content_type, **kwargs)\n            .addErrback(retry_bad_nonce))", "response": "POST an object and check the response."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncreates a Thread but always set daemon.", "response": "def _daemon_thread(*a, **kw):\n    \"\"\"\n    Create a `threading.Thread`, but always set ``daemon``.\n    \"\"\"\n    thread = Thread(*a, **kw)\n    thread.daemon = True\n    return thread"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _defer_to_worker(deliver, worker, work, *args, **kwargs):\n    deferred = Deferred()\n\n    def wrapped_work():\n        try:\n            result = work(*args, **kwargs)\n        except BaseException:\n            f = Failure()\n            deliver(lambda: deferred.errback(f))\n        else:\n            deliver(lambda: deferred.callback(result))\n    worker.do(wrapped_work)\n    return deferred", "response": "Run a task in a worker and deliver the result as a Deferred in the reactor thread."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsplits the zone portion off from a DNS label.", "response": "def _split_zone(server_name, zone_name):\n    \"\"\"\n    Split the zone portion off from a DNS label.\n\n    :param str server_name: The full DNS label.\n    :param str zone_name: The zone name suffix.\n    \"\"\"\n    server_name = server_name.rstrip(u'.')\n    zone_name = zone_name.rstrip(u'.')\n    if not (server_name == zone_name or\n            server_name.endswith(u'.' + zone_name)):\n        raise NotInZone(server_name=server_name, zone_name=zone_name)\n    return server_name[:-len(zone_name)].rstrip(u'.')"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _get_existing(driver, zone_name, server_name, validation):\n    if zone_name is None:\n        zones = sorted(\n            (z for z\n             in driver.list_zones()\n             if server_name.rstrip(u'.')\n                .endswith(u'.' + z.domain.rstrip(u'.'))),\n            key=lambda z: len(z.domain),\n            reverse=True)\n        if len(zones) == 0:\n            raise NotInZone(server_name=server_name, zone_name=None)\n    else:\n        zones = [\n            z for z\n            in driver.list_zones()\n            if z.domain == zone_name]\n        if len(zones) == 0:\n            raise ZoneNotFound(zone_name=zone_name)\n    zone = zones[0]\n    subdomain = _split_zone(server_name, zone.domain)\n    existing = [\n        record for record\n        in zone.list_records()\n        if record.name == subdomain and\n        record.type == 'TXT' and\n        record.data == validation]\n    return zone, existing, subdomain", "response": "Get existing validation records."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _validation(response):\n    h = hashlib.sha256(response.key_authorization.encode(\"utf-8\"))\n    return b64encode(h.digest()).decode()", "response": "Get the validation value for a challenge response."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef load_or_create_client_key(pem_path):\n    acme_key_file = pem_path.asTextMode().child(u'client.key')\n    if acme_key_file.exists():\n        key = serialization.load_pem_private_key(\n            acme_key_file.getContent(),\n            password=None,\n            backend=default_backend())\n    else:\n        key = generate_private_key(u'rsa')\n        acme_key_file.setContent(\n            key.private_bytes(\n                encoding=serialization.Encoding.PEM,\n                format=serialization.PrivateFormat.TraditionalOpenSSL,\n                encryption_algorithm=serialization.NoEncryption()))\n    return JWKRSA(key=key)", "response": "Load the client key from a directory creating it if it does not exist."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _parse(reactor, directory, pemdir, *args, **kwargs):\n    def colon_join(items):\n        return ':'.join([item.replace(':', '\\\\:') for item in items])\n    sub = colon_join(list(args) + ['='.join(item) for item in kwargs.items()])\n    pem_path = FilePath(pemdir).asTextMode()\n    acme_key = load_or_create_client_key(pem_path)\n    return AutoTLSEndpoint(\n        reactor=reactor,\n        directory=directory,\n        client_creator=partial(Client.from_url, key=acme_key, alg=RS256),\n        cert_store=DirectoryStore(pem_path),\n        cert_mapping=HostDirectoryMap(pem_path),\n        sub_endpoint=serverFromString(reactor, sub))", "response": "Parse a txacme endpoint description."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef lazyread(f, delimiter):\n    # Get an empty string to start with.  We need to make sure that if the\n    # file is opened in binary mode, we're using byte strings, and similar\n    # for Unicode.  Otherwise trying to update the running string will\n    # hit a TypeError.\n    try:\n        running = f.read(0)\n    except Exception as e:\n\n        # The boto3 APIs don't let you read zero bytes from an S3 object, but\n        # they always return bytestrings, so in this case we know what to\n        # start with.\n        if e.__class__.__name__ == 'IncompleteReadError':\n            running = b''\n        else:\n            raise\n\n    while True:\n        new_data = f.read(1024)\n\n        # When a call to read() returns nothing, we're at the end of the file.\n        if not new_data:\n            yield running\n            return\n\n        # Otherwise, update the running stream and look for instances of\n        # the delimiter.  Remember we might have read more than one delimiter\n        # since the last time we checked\n        running += new_data\n        while delimiter in running:\n            curr, running = running.split(delimiter, 1)\n            yield curr + delimiter", "response": "Generator which continually reads a file into a next instance of the specified delimiter."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngenerates a random private key using sensible parameters.", "response": "def generate_private_key(key_type):\n    \"\"\"\n    Generate a random private key using sensible parameters.\n\n    :param str key_type: The type of key to generate. One of: ``rsa``.\n    \"\"\"\n    if key_type == u'rsa':\n        return rsa.generate_private_key(\n            public_exponent=65537, key_size=2048, backend=default_backend())\n    raise ValueError(key_type)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef generate_tls_sni_01_cert(server_name, key_type=u'rsa',\n                             _generate_private_key=None):\n    \"\"\"\n    Generate a certificate/key pair for responding to a tls-sni-01 challenge.\n\n    :param str server_name: The SAN the certificate should have.\n    :param str key_type: The type of key to generate; usually not necessary.\n\n    :rtype: ``Tuple[`~cryptography.x509.Certificate`, PrivateKey]``\n    :return: A tuple of the certificate and private key.\n    \"\"\"\n    key = (_generate_private_key or generate_private_key)(key_type)\n    name = x509.Name([\n        x509.NameAttribute(NameOID.COMMON_NAME, u'acme.invalid')])\n    cert = (\n        x509.CertificateBuilder()\n        .subject_name(name)\n        .issuer_name(name)\n        .not_valid_before(datetime.now() - timedelta(seconds=3600))\n        .not_valid_after(datetime.now() + timedelta(seconds=3600))\n        .serial_number(int(uuid.uuid4()))\n        .public_key(key.public_key())\n        .add_extension(\n            x509.SubjectAlternativeName([x509.DNSName(server_name)]),\n            critical=False)\n        .sign(\n            private_key=key,\n            algorithm=hashes.SHA256(),\n            backend=default_backend())\n        )\n    return (cert, key)", "response": "Generate a certificate and private key pair for responding to a TLS - SNI - 01 challenge."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef tap(f):\n    @wraps(f)\n    def _cb(res, *a, **kw):\n        d = maybeDeferred(f, res, *a, **kw)\n        d.addCallback(lambda ignored: res)\n        return d\n    return _cb", "response": "Tap a Deferred callback chain with a function whose return value is\n    ignored."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef decode_csr(b64der):\n    try:\n        return x509.load_der_x509_csr(\n            decode_b64jose(b64der), default_backend())\n    except ValueError as error:\n        raise DeserializationError(error)", "response": "Decode a JOSE Base - 64 DER - encoded CSR."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef csr_for_names(names, key):\n    if len(names) == 0:\n        raise ValueError('Must have at least one name')\n    if len(names[0]) > 64:\n        common_name = u'san.too.long.invalid'\n    else:\n        common_name = names[0]\n    return (\n        x509.CertificateSigningRequestBuilder()\n        .subject_name(x509.Name([\n            x509.NameAttribute(NameOID.COMMON_NAME, common_name)]))\n        .add_extension(\n            x509.SubjectAlternativeName(list(map(x509.DNSName, names))),\n            critical=False)\n        .sign(key, hashes.SHA256(), default_backend()))", "response": "Generate a certificate signing request for the given names and private key."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nwrapping parse function to avoid await calls raising a SyntaxError", "response": "def _wrap_parse(code, filename):\n        \"\"\"\n        async wrapper is required to avoid await calls raising a SyntaxError\n        \"\"\"\n        code = 'async def wrapper():\\n' + indent(code, ' ')\n        return ast.parse(code, filename=filename).body[0].body[0].value"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ndetermines the URL corresponding to Python object", "response": "def linkcode_resolve(domain, info):\n    \"\"\"\n    Determine the URL corresponding to Python object\n    \"\"\"\n    if domain != 'py':\n        return None\n    modname = info['module']\n    fullname = info['fullname']\n    submod = sys.modules.get(modname)\n    if submod is None:\n        return None\n    obj = submod\n    for part in fullname.split('.'):\n        try:\n            obj = getattr(obj, part)\n        except:\n            return None\n    try:\n        fn = inspect.getsourcefile(obj)\n    except:\n        fn = None\n    if not fn:\n        return None\n    try:\n        source, lineno = inspect.findsource(obj)\n    except:\n        lineno = None\n    if lineno:\n        linespec = \"#L%d\" % (lineno + 1)\n    else:\n        linespec = \"\"\n    fn = relpath(fn, start='..')\n    return \"https://github.com/mithrandi/txacme/blob/%s/%s%s\" % (\n        txacme_version_info['full-revisionid'], fn, linespec)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef layer_to_solr(self, layer):\n        success = True\n        message = 'Synced layer id %s to Solr' % layer.id\n\n        layer_dict, message = layer2dict(layer)\n        if not layer_dict:\n            success = False\n        else:\n            layer_json = json.dumps(layer_dict)\n            try:\n                url_solr_update = '%s/solr/hypermap/update/json/docs' % SEARCH_URL\n                headers = {\"content-type\": \"application/json\"}\n                params = {\"commitWithin\": 1500}\n                res = requests.post(url_solr_update, data=layer_json, params=params,  headers=headers)\n                res = res.json()\n                if 'error' in res:\n                    success = False\n                    message = \"Error syncing layer id %s to Solr: %s\" % (layer.id, res[\"error\"].get(\"msg\"))\n            except Exception, e:\n                success = False\n                message = \"Error syncing layer id %s to Solr: %s\" % (layer.id, sys.exc_info()[1])\n                LOGGER.error(e, exc_info=True)\n        if success:\n            LOGGER.info(message)\n        else:\n            LOGGER.error(message)\n        return success, message", "response": "Sync a layer in Solr."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef clear_solr(self, catalog=\"hypermap\"):\n        solr_url = \"{0}/solr/{1}\".format(SEARCH_URL, catalog)\n        solr = pysolr.Solr(solr_url, timeout=60)\n        solr.delete(q='*:*')\n        LOGGER.debug('Solr core cleared')", "response": "Clear all indexes in the solr core"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nupdate the schema of the current core", "response": "def update_schema(self, catalog=\"hypermap\"):\n        \"\"\"\n        set the mapping in solr.\n        :param catalog: core\n        :return:\n        \"\"\"\n        schema_url = \"{0}/solr/{1}/schema\".format(SEARCH_URL, catalog)\n        print schema_url\n\n        # create a special type to draw better heatmaps.\n        location_rpt_quad_5m_payload = {\n            \"add-field-type\": {\n                \"name\": \"location_rpt_quad_5m\",\n                \"class\": \"solr.SpatialRecursivePrefixTreeFieldType\",\n                \"geo\": False,\n                \"worldBounds\": \"ENVELOPE(-180, 180, 180, -180)\",\n                \"prefixTree\": \"packedQuad\",\n                \"distErrPct\": \"0.025\",\n                \"maxDistErr\": \"0.001\",\n                \"distanceUnits\": \"degrees\"\n            }\n        }\n        requests.post(schema_url, json=location_rpt_quad_5m_payload)\n\n        # create a special type to implement ngrm text for search.\n        text_ngrm_payload = {\n            \"add-field-type\": {\n                \"name\": \"text_ngrm\",\n                \"class\": \"solr.TextField\",\n                \"positionIncrementGap\": \"100\",\n                \"indexAnalyzer\": {\n                    \"tokenizer\": {\n                        \"class\": \"solr.WhitespaceTokenizerFactory\"\n                    },\n                    \"filters\": [\n                        {\n                            \"class\": \"solr.NGramFilterFactory\",\n                            \"minGramSize\": \"1\",\n                            \"maxGramSize\": \"50\"\n                        }, {\n                            \"class\": \"solr.LowerCaseFilterFactory\"\n                        }\n                    ]\n                },\n                \"queryAnalyzer\": {\n                    \"tokenizer\": {\n                        \"class\": \"solr.WhitespaceTokenizerFactory\"\n                    },\n                    \"filters\": [\n                        {\n                            \"class\": \"solr.LowerCaseFilterFactory\",\n                        }\n                    ]\n                }\n            }\n        }\n        requests.post(schema_url, json=text_ngrm_payload)\n\n        # now the other fields\n        fields = [\n            {\"name\": \"abstract\", \"type\": \"string\"},\n            {\"name\": \"abstract_txt\", \"type\": \"text_ngrm\"},\n            {\"name\": \"area\", \"type\": \"pdouble\"},\n            {\"name\": \"availability\", \"type\": \"string\"},\n            {\"name\": \"bbox\", \"type\": \"location_rpt_quad_5m\"},\n            {\"name\": \"domain_name\", \"type\": \"string\"},\n            {\"name\": \"is_public\", \"type\": \"boolean\"},\n            {\"name\": \"is_valid\", \"type\": \"boolean\"},\n            {\"name\": \"keywords\", \"type\": \"string\", \"multiValued\": True},\n            {\"name\": \"last_status\", \"type\": \"boolean\"},\n            {\"name\": \"layer_category\", \"type\": \"string\"},\n            {\"name\": \"layer_date\", \"type\": \"pdate\", \"docValues\": True},\n            {\"name\": \"layer_datetype\", \"type\": \"string\"},\n            {\"name\": \"layer_id\", \"type\": \"plong\"},\n            {\"name\": \"layer_originator\", \"type\": \"string\"},\n            {\"name\": \"layer_originator_txt\", \"type\": \"text_ngrm\"},\n            {\"name\": \"layer_username\", \"type\": \"string\"},\n            {\"name\": \"layer_username_txt\", \"type\": \"text_ngrm\"},\n            {\"name\": \"location\", \"type\": \"string\"},\n            {\"name\": \"max_x\", \"type\": \"pdouble\"},\n            {\"name\": \"max_y\", \"type\": \"pdouble\"},\n            {\"name\": \"min_x\", \"type\": \"pdouble\"},\n            {\"name\": \"min_y\", \"type\": \"pdouble\"},\n            {\"name\": \"name\", \"type\": \"string\"},\n            {\"name\": \"recent_reliability\", \"type\": \"pdouble\"},\n            {\"name\": \"reliability\", \"type\": \"pdouble\"},\n            {\"name\": \"service_id\", \"type\": \"plong\"},\n            {\"name\": \"service_type\", \"type\": \"string\"},\n            {\"name\": \"srs\", \"type\": \"string\", \"multiValued\": True},\n            {\"name\": \"tile_url\", \"type\": \"string\"},\n            {\"name\": \"title\", \"type\": \"string\"},\n            {\"name\": \"title_txt\", \"type\": \"text_ngrm\"},\n            {\"name\": \"type\", \"type\": \"string\"},\n            {\"name\": \"url\", \"type\": \"string\"},\n            {\"name\": \"uuid\", \"type\": \"string\", \"required\": True},\n            {\"name\": \"centroid_y\", \"type\": \"pdouble\"},\n            {\"name\": \"centroid_x\", \"type\": \"pdouble\"},\n        ]\n\n        copy_fields = [\n            {\"source\": \"*\", \"dest\": \"_text_\"},\n            {\"source\": \"title\", \"dest\": \"title_txt\"},\n            {\"source\": \"abstract\", \"dest\": \"abstract_txt\"},\n            {\"source\": \"layer_originator\", \"dest\": \"layer_originator_txt\"},\n            {\"source\": \"layer_username\", \"dest\": \"layer_username_txt\"},\n        ]\n\n        headers = {\n            \"Content-type\": \"application/json\"\n        }\n\n        for field in fields:\n            data = {\n                \"add-field\": field\n            }\n            requests.post(schema_url, json=data, headers=headers)\n\n        for field in copy_fields:\n            data = {\n                \"add-copy-field\": field\n            }\n            print data\n            requests.post(schema_url, json=data, headers=headers)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates a layer from a metadata record.", "response": "def create_layer_from_metadata_xml(resourcetype, xml, monitor=False, service=None, catalog=None):\n    \"\"\"\n    Create a layer / keyword list from a metadata record if it does not already exist.\n    \"\"\"\n    from models import gen_anytext, Layer\n\n    if resourcetype == 'http://www.opengis.net/cat/csw/2.0.2':  # Dublin core\n        md = CswRecord(etree.fromstring(xml))\n\n    layer = Layer(\n        is_monitored=monitor,\n        name=md.title,\n        title=md.title,\n        abstract=md.abstract,\n        xml=xml,\n        service=service,\n        catalog=catalog,\n        anytext=gen_anytext(md.title, md.abstract, md.subjects)\n    )\n\n    if hasattr(md, 'alternative'):\n        layer.name = md.alternative\n\n    if md.bbox is not None:\n        layer.bbox_x0 = format_float(md.bbox.minx)\n        layer.bbox_y0 = format_float(md.bbox.miny)\n        layer.bbox_x1 = format_float(md.bbox.maxx)\n        layer.bbox_y1 = format_float(md.bbox.maxy)\n\n        layer.wkt_geometry = bbox2wktpolygon([md.bbox.minx, md.bbox.miny, md.bbox.maxx, md.bbox.maxy])\n\n    return layer, md.subjects"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef create_service_from_endpoint(endpoint, service_type, title=None, abstract=None, catalog=None):\n    from models import Service\n    if Service.objects.filter(url=endpoint, catalog=catalog).count() == 0:\n        # check if endpoint is valid\n        request = requests.get(endpoint)\n        if request.status_code == 200:\n            LOGGER.debug('Creating a %s service for endpoint=%s catalog=%s' % (service_type, endpoint, catalog))\n            service = Service(\n                        type=service_type, url=endpoint, title=title, abstract=abstract,\n                        csw_type='service', catalog=catalog\n                        )\n            service.save()\n            return service\n        else:\n            LOGGER.warning('This endpoint is invalid, status code is %s' % request.status_code)\n    else:\n        LOGGER.warning('A service for this endpoint %s in catalog %s already exists' % (endpoint, catalog))\n        return None", "response": "Create a service from an endpoint."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngenerating services from an endpoint.", "response": "def create_services_from_endpoint(url, catalog, greedy_opt=True):\n    \"\"\"\n    Generate service/services from an endpoint.\n    WMS, WMTS, TMS endpoints correspond to a single service.\n    ESRI, CSW endpoints corrispond to many services.\n    :return: imported, message\n    \"\"\"\n\n    # this variable will collect any exception message during the routine.\n    # will be used in the last step to send a message if \"detected\" var is False.\n    messages = []\n\n    num_created = 0\n    endpoint = get_sanitized_endpoint(url)\n    try:\n        urllib2.urlopen(endpoint, timeout=10)\n    except Exception as e:\n        message = traceback.format_exception(*sys.exc_info())\n        LOGGER.error('Cannot open this endpoint: %s' % endpoint)\n        LOGGER.error('ERROR MESSAGE: %s' % message)\n        LOGGER.error(e, exc_info=True)\n\n        return False, message\n\n    detected = False\n\n    # handle specific service types for some domains (WorldMap, Wrapper...)\n    parsed_uri = urlparse(endpoint)\n    domain = '{uri.scheme}://{uri.netloc}/'.format(uri=parsed_uri)\n    if domain == 'http://worldmap.harvard.edu/':\n        service_type = 'Hypermap:WorldMap'\n        title = 'Harvard WorldMap'\n        abstract = 'Harvard WorldMap'\n        endpoint = domain\n        detected = True\n    if domain in [\n        'http://maps.nypl.org/',\n        'http://mapwarper.net/',\n        'http://warp.worldmap.harvard.edu/',\n    ]:\n        service_type = 'Hypermap:WARPER'\n        title = 'Warper at %s' % domain\n        abstract = 'Warper at %s' % domain\n        detected = True\n\n    # test if it is CSW, WMS, TMS, WMTS or Esri\n    # CSW\n    try:\n        csw = CatalogueServiceWeb(endpoint)\n        service_type = 'OGC:CSW'\n        service_links = {}\n        detected = True\n\n        typenames = 'csw:Record'\n        outputschema = 'http://www.opengis.net/cat/csw/2.0.2'\n\n        if 'csw_harvest_pagesize' in settings.REGISTRY_PYCSW['manager']:\n            pagesize = int(settings.REGISTRY_PYCSW['manager']['csw_harvest_pagesize'])\n        else:\n            pagesize = 10\n\n        LOGGER.debug('Harvesting CSW %s' % endpoint)\n        # now get all records\n        # get total number of records to loop against\n        try:\n            csw.getrecords2(typenames=typenames, resulttype='hits',\n                            outputschema=outputschema)\n            matches = csw.results['matches']\n        except:  # this is a CSW, but server rejects query\n            raise RuntimeError(csw.response)\n\n        if pagesize > matches:\n            pagesize = matches\n\n        LOGGER.info('Harvesting %d CSW records' % matches)\n\n        # loop over all catalogue records incrementally\n        for r in range(1, matches+1, pagesize):\n            LOGGER.info('Parsing %s from %s' % (r, matches))\n            try:\n                csw.getrecords2(typenames=typenames, startposition=r,\n                                maxrecords=pagesize, outputschema=outputschema, esn='full')\n            except Exception as err:  # this is a CSW, but server rejects query\n                raise RuntimeError(csw.response)\n            for k, v in csw.records.items():\n                # try to parse metadata\n                try:\n                    LOGGER.info('Looking for service links')\n\n                    LOGGER.debug('Looking for service links via dct:references')\n                    if v.references:\n                        for ref in v.references:\n                            scheme = None\n\n                            if ref['scheme'] in [st[0] for st in SERVICE_TYPES]:\n                                if ref['url'] not in service_links:\n                                    scheme = ref['scheme']\n                                    service_links[ref['url']] = scheme\n                            else:  # loose detection\n                                scheme = detect_metadata_url_scheme(ref['url'])\n                                if scheme is not None:\n                                    if ref['url'] not in service_links:\n                                        service_links[ref['url']] = scheme\n\n                            if scheme is None:\n                                continue\n                            try:\n                                service = create_service_from_endpoint(ref['url'], scheme, catalog=catalog)\n\n                                if service is not None:\n                                    num_created = num_created + 1\n                                    LOGGER.info('Found %s services on endpoint' % num_created)\n                            except Exception, e:\n                                LOGGER.error('Could not create service for %s : %s' % (scheme, ref['url']))\n                                LOGGER.error(e, exc_info=True)\n                    LOGGER.debug('Looking for service links via the GeoNetwork-ish dc:URI')\n                    if v.uris:\n                        for u in v.uris:  # loose detection\n                            scheme = detect_metadata_url_scheme(u['url'])\n                            if scheme is not None:\n                                if u['url'] not in service_links:\n                                    service_links[u['url']] = scheme\n                            else:\n                                continue\n\n                            try:\n                                service = create_service_from_endpoint(u['url'], scheme, catalog=catalog)\n\n                                if service is not None:\n                                    num_created = num_created + 1\n                                    LOGGER.info('Found %s services on endpoint' % num_created)\n                            except Exception, e:\n                                LOGGER.error('Could not create service for %s : %s' % (scheme, u['url']))\n                                LOGGER.error(e, exc_info=True)\n\n                except Exception as err:  # parsing failed for some reason\n                    LOGGER.warning('Metadata parsing failed %s', err)\n                    LOGGER.error(err, exc_info=True)\n\n    except XMLSyntaxError as e:\n        # This is not XML, so likely not a CSW. Moving on.\n        pass\n    except Exception as e:\n        LOGGER.error(e, exc_info=True)\n        messages.append(str(e))\n\n    # WMS\n    if not detected:\n        try:\n            service = get_wms_version_negotiate(endpoint, timeout=10)\n            service_type = 'OGC:WMS'\n            title = service.identification.title,\n            abstract = service.identification.abstract\n            detected = True\n        except XMLSyntaxError as e:\n            # This is not XML, so likely not a WMS. Moving on.\n            pass\n        except Exception as e:\n            LOGGER.error(e, exc_info=True)\n            messages.append(str(e))\n\n    # TMS\n    if not detected:\n        try:\n            service = TileMapService(endpoint, timeout=10)\n            service_type = 'OSGeo:TMS'\n            title = service.identification.title,\n            abstract = service.identification.abstract\n            detected = True\n        except XMLSyntaxError as e:\n            # This is not XML, so likely not a TsMS. Moving on.\n            pass\n        except Exception as e:\n            LOGGER.error(e, exc_info=True)\n            messages.append(str(e))\n\n    # WMTS\n    if not detected:\n        try:\n            # @tomkralidis timeout is not implemented for WebMapTileService?\n            service = WebMapTileService(endpoint)\n            service_type = 'OGC:WMTS'\n            title = service.identification.title,\n            abstract = service.identification.abstract\n            detected = True\n        except XMLSyntaxError as e:\n            # This is not XML, so likely not a WMTS. Moving on.\n            pass\n        except Exception as e:\n            LOGGER.error(e, exc_info=True)\n            messages.append(str(e))\n\n    # if detected, let's create the service\n    if detected and service_type != 'OGC:CSW':\n        try:\n            service = create_service_from_endpoint(\n                endpoint,\n                service_type,\n                title,\n                abstract=abstract,\n                catalog=catalog\n            )\n            if service is not None:\n                num_created = num_created + 1\n        except XMLSyntaxError as e:\n            # This is not XML, so likely not a OGC:CSW. Moving on.\n            pass\n        except Exception as e:\n            LOGGER.error(e, exc_info=True)\n            messages.append(str(e))\n\n    # Esri\n    # a good sample is here: https://gis.ngdc.noaa.gov/arcgis/rest/services\n\n    # we can safely assume the following condition (at least it is true for 1170 services)\n    # we need to test this as arcrest.Folder can freeze with not esri url such as this one:\n    # http://hh.worldmap.harvard.edu/admin/aggregator/service/?q=%2Frest%2Fservices\n\n    if '/rest/services' in endpoint:\n        if not detected:\n            try:\n                esri = arcrest.Folder(endpoint)\n                service_type = 'ESRI'\n                detected = True\n\n                service_to_process, folder_to_process = esri.services, esri.folders\n                if not greedy_opt:\n                    folder_to_process = []\n                    sections = service_url_parse(url)\n                    service_to_process = get_single_service(esri, sections)\n\n                processed_services = process_esri_services(service_to_process, catalog)\n                num_created = num_created + len(processed_services)\n\n                for folder in folder_to_process:\n                    folder_services = process_esri_services(folder.services, catalog)\n                    num_created = num_created + len(folder_services)\n\n            except Exception as e:\n                LOGGER.error(e, exc_info=True)\n                messages.append(str(e))\n\n    if detected:\n        return True, '%s service/s created' % num_created\n    else:\n        m = '|'.join(messages)\n        return False, 'ERROR! Could not detect service type for ' \\\n                      'endpoint %s or already existing. messages=(%s)' % (endpoint, m)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nfunction that parses from url the service and folder of services.", "response": "def service_url_parse(url):\n    \"\"\"\n    Function that parses from url the service and folder of services.\n    \"\"\"\n    endpoint = get_sanitized_endpoint(url)\n    url_split_list = url.split(endpoint + '/')\n    if len(url_split_list) != 0:\n        url_split_list = url_split_list[1].split('/')\n    else:\n        raise Exception('Wrong url parsed')\n\n    # Remove unnecessary items from list of the split url.\n    parsed_url = [s for s in url_split_list if '?' not in s if 'Server' not in s]\n\n    return parsed_url"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngiving coordinates in spherical mercator return a lon lat tuple.", "response": "def inverse_mercator(xy):\n    \"\"\"\n    Given coordinates in spherical mercator, return a lon,lat tuple.\n    \"\"\"\n    lon = (xy[0] / 20037508.34) * 180\n    lat = (xy[1] / 20037508.34) * 180\n    lat = 180 / math.pi * \\\n        (2 * math.atan(math.exp(lat * math.pi / 180)) - math.pi / 2)\n    return (lon, lat)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_wms_version_negotiate(url, timeout=10):\n\n    try:\n        LOGGER.debug('Trying a WMS 1.3.0 GetCapabilities request')\n        return WebMapService(url, version='1.3.0', timeout=timeout)\n    except Exception as err:\n        LOGGER.warning('WMS 1.3.0 support not found: %s', err)\n        LOGGER.debug('Trying a WMS 1.1.1 GetCapabilities request instead')\n        return WebMapService(url, version='1.1.1', timeout=timeout)", "response": "Wrapper function to perform version negotiation against owslib. wms. WebMapService"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_sanitized_endpoint(url):\n    # sanitize esri\n    sanitized_url = url.rstrip()\n    esri_string = '/rest/services'\n    if esri_string in url:\n        match = re.search(esri_string, sanitized_url)\n        sanitized_url = url[0:(match.start(0)+len(esri_string))]\n    return sanitized_url", "response": "Sanitize an endpoint as removing unneeded parameters\n   "}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_esri_service_name(url):\n    result = re.search('rest/services/(.*)/[MapServer|ImageServer]', url)\n    if result is None:\n        return url\n    else:\n        return result.group(1)", "response": "A method to get a service name from an esri endpoint."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the extent of an ESRI resource", "response": "def get_esri_extent(esriobj):\n    \"\"\"\n    Get the extent of an ESRI resource\n    \"\"\"\n\n    extent = None\n    srs = None\n\n    if 'fullExtent' in esriobj._json_struct:\n        extent = esriobj._json_struct['fullExtent']\n    if 'extent' in esriobj._json_struct:\n        extent = esriobj._json_struct['extent']\n\n    try:\n        srs = extent['spatialReference']['wkid']\n    except KeyError, err:\n        LOGGER.error(err, exc_info=True)\n\n    return [extent, srs]"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef bbox2wktpolygon(bbox):\n\n    minx = float(bbox[0])\n    miny = float(bbox[1])\n    maxx = float(bbox[2])\n    maxy = float(bbox[3])\n    return 'POLYGON((%.2f %.2f, %.2f %.2f, %.2f %.2f, %.2f %.2f, %.2f %.2f))' \\\n        % (minx, miny, minx, maxy, maxx, maxy, maxx, miny, minx, miny)", "response": "Return a WKT Polygon of a simple bounding box list of strings"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_solr_date(pydate, is_negative):\n    # check if date is valid and then set it to solr format YYYY-MM-DDThh:mm:ssZ\n    try:\n        if isinstance(pydate, datetime.datetime):\n            solr_date = '%sZ' % pydate.isoformat()[0:19]\n            if is_negative:\n                LOGGER.debug('%s This layer has a negative date' % solr_date)\n                solr_date = '-%s' % solr_date\n            return solr_date\n        else:\n            return None\n    except Exception, e:\n        LOGGER.error(e, exc_info=True)\n        return None", "response": "Returns a date in a valid Solr format from a string."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a custom date representation of the given layer.", "response": "def get_date(layer):\n    \"\"\"\n    Returns a custom date representation. A date can be detected or from metadata.\n    It can be a range or a simple date in isoformat.\n    \"\"\"\n    date = None\n    sign = '+'\n    date_type = 1\n    layer_dates = layer.get_layer_dates()\n    # we index the first date!\n    if layer_dates:\n        sign = layer_dates[0][0]\n        date = layer_dates[0][1]\n        date_type = layer_dates[0][2]\n    if date is None:\n        date = layer.created\n    # layer date > 2300 is invalid for sure\n    # TODO put this logic in date miner\n    if date.year > 2300:\n        date = None\n    if date_type == 0:\n        date_type = \"Detected\"\n    if date_type == 1:\n        date_type = \"From Metadata\"\n    return get_solr_date(date, (sign == '-')), date_type"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a json representation of a layer.", "response": "def layer2dict(layer):\n    \"\"\"\n    Return a json representation for a layer.\n    \"\"\"\n\n    category = None\n    username = None\n\n    # bbox must be valid before proceeding\n    if not layer.has_valid_bbox():\n        message = 'Layer id: %s has a not valid bbox' % layer.id\n        return None, message\n\n    # we can proceed safely\n    bbox = [float(layer.bbox_x0), float(layer.bbox_y0), float(layer.bbox_x1), float(layer.bbox_y1)]\n    minX = bbox[0]\n    minY = bbox[1]\n    maxX = bbox[2]\n    maxY = bbox[3]\n    # coords hack needed by solr\n    if (minX < -180):\n        minX = -180\n    if (maxX > 180):\n        maxX = 180\n    if (minY < -90):\n        minY = -90\n    if (maxY > 90):\n        maxY = 90\n    rectangle = box(minX, minY, maxX, maxY)\n    wkt = \"ENVELOPE({:f},{:f},{:f},{:f})\".format(minX, maxX, maxY, minY)\n    halfWidth = (maxX - minX) / 2.0\n    halfHeight = (maxY - minY) / 2.0\n    area = (halfWidth * 2) * (halfHeight * 2)\n    domain = get_domain(layer.service.url)\n    if hasattr(layer, 'layerwm'):\n        category = layer.layerwm.category\n        username = layer.layerwm.username\n    abstract = layer.abstract\n    if abstract:\n        abstract = strip_tags(layer.abstract)\n    else:\n        abstract = ''\n    if layer.type == \"WM\":\n        originator = username\n    else:\n        originator = domain\n\n    layer_dict = {\n                    'id': layer.id,\n                    'uuid': str(layer.uuid),\n                    'type': 'Layer',\n                    'layer_id': layer.id,\n                    'name': layer.name,\n                    'title': layer.title,\n                    'layer_originator': originator,\n                    'service_id': layer.service.id,\n                    'service_type': layer.service.type,\n                    'layer_category': category,\n                    'layer_username': username,\n                    'url': layer.url,\n                    'keywords': [kw.name for kw in layer.keywords.all()],\n                    'reliability': layer.reliability,\n                    'recent_reliability': layer.recent_reliability,\n                    'last_status': layer.last_status,\n                    'is_public': layer.is_public,\n                    'is_valid': layer.is_valid,\n                    'availability': 'Online',\n                    'location': '{\"layerInfoPage\": \"' + layer.get_absolute_url + '\"}',\n                    'abstract': abstract,\n                    'domain_name': layer.service.get_domain\n                    }\n\n    solr_date, date_type = get_date(layer)\n    if solr_date is not None:\n        layer_dict['layer_date'] = solr_date\n        layer_dict['layer_datetype'] = date_type\n    if bbox is not None:\n        layer_dict['min_x'] = minX\n        layer_dict['min_y'] = minY\n        layer_dict['max_x'] = maxX\n        layer_dict['max_y'] = maxY\n        layer_dict['area'] = area\n        layer_dict['bbox'] = wkt\n        layer_dict['centroid_x'] = rectangle.centroid.x\n        layer_dict['centroid_y'] = rectangle.centroid.y\n        srs_list = [srs.encode('utf-8') for srs in layer.service.srs.values_list('code', flat=True)]\n        layer_dict['srs'] = srs_list\n    if layer.get_tile_url():\n        layer_dict['tile_url'] = layer.get_tile_url()\n\n    message = 'Layer %s successfully converted to json' % layer.id\n    return layer_dict, message"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef detect_metadata_url_scheme(url):\n\n    scheme = None\n    url_lower = url.lower()\n\n    if any(x in url_lower for x in ['wms', 'service=wms']):\n        scheme = 'OGC:WMS'\n    if any(x in url_lower for x in ['wmts', 'service=wmts']):\n        scheme = 'OGC:WMTS'\n    elif all(x in url for x in ['/MapServer', 'f=json']):\n        scheme = 'ESRI:ArcGIS:MapServer'\n    elif all(x in url for x in ['/ImageServer', 'f=json']):\n        scheme = 'ESRI:ArcGIS:ImageServer'\n\n    return scheme", "response": "detect whether a url is a Service type that HHypermap supports"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef serialize_checks(check_set):\n    check_set_list = []\n    for check in check_set.all()[:25]:\n        check_set_list.append(\n            {\n                'datetime': check.checked_datetime.isoformat(),\n                'value': check.response_time,\n                'success': 1 if check.success else 0\n            }\n        )\n    return check_set_list", "response": "Serialize a check_set for raphael\n   "}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef domains(request):\n    url = ''\n    query = '*:*&facet=true&facet.limit=-1&facet.pivot=domain_name,service_id&wt=json&indent=true&rows=0'\n    if settings.SEARCH_TYPE == 'elasticsearch':\n        url = '%s/select?q=%s' % (settings.SEARCH_URL, query)\n    if settings.SEARCH_TYPE == 'solr':\n        url = '%s/solr/hypermap/select?q=%s' % (settings.SEARCH_URL, query)\n    LOGGER.debug(url)\n    response = urllib2.urlopen(url)\n    data = response.read().replace('\\n', '')\n    # stats\n    layers_count = Layer.objects.all().count()\n    services_count = Service.objects.all().count()\n    template = loader.get_template('aggregator/index.html')\n    context = RequestContext(request, {\n        'data': data,\n        'layers_count': layers_count,\n        'services_count': services_count,\n    })\n    return HttpResponse(template.render(context))", "response": "A page with number of services and layers faceted on domains."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef layer_mapproxy(request, catalog_slug, layer_uuid, path_info):\n    layer = get_object_or_404(Layer,\n                              uuid=layer_uuid,\n                              catalog__slug=catalog_slug)\n\n    # for WorldMap layers we need to use the url of the layer\n    if layer.service.type == 'Hypermap:WorldMap':\n        layer.service.url = layer.url\n\n    # Set up a mapproxy app for this particular layer\n    mp, yaml_config = get_mapproxy(layer)\n\n    query = request.META['QUERY_STRING']\n\n    if len(query) > 0:\n        path_info = path_info + '?' + query\n\n    params = {}\n    headers = {\n            'X-Script-Name': '/registry/{0}/layer/{1}/map/'.format(catalog_slug, layer.id),\n            'X-Forwarded-Host': request.META['HTTP_HOST'],\n            'HTTP_HOST': request.META['HTTP_HOST'],\n            'SERVER_NAME': request.META['SERVER_NAME'],\n            }\n\n    if path_info == '/config':\n        response = HttpResponse(yaml_config, content_type='text/plain')\n        return response\n\n    # Get a response from MapProxy as if it was running standalone.\n    mp_response = mp.get(path_info, params, headers)\n\n    # Create a Django response from the MapProxy WSGI response.\n    response = HttpResponse(mp_response.body, status=mp_response.status_int)\n    for header, value in mp_response.headers.iteritems():\n        response[header] = value\n\n    return response", "response": "Get Layer with matching catalog and uuid"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef parse_datetime(date_str):\n    is_common_era = True\n    date_str_parts = date_str.split(\"-\")\n    if date_str_parts and date_str_parts[0] == '':\n        is_common_era = False\n        # for now, only support BCE years\n\n        # assume the datetime comes complete, but\n        # when it comes only the year, add the missing datetime info:\n        if len(date_str_parts) == 2:\n            date_str = date_str + \"-01-01T00:00:00Z\"\n\n    parsed_datetime = {\n        'is_common_era': is_common_era,\n        'parsed_datetime': None\n    }\n\n    if is_common_era:\n        if date_str == '*':\n            return parsed_datetime  # open ended.\n\n        default = datetime.datetime.now().replace(\n            hour=0, minute=0, second=0, microsecond=0,\n            day=1, month=1\n        )\n        parsed_datetime['parsed_datetime'] = parse(date_str, default=default)\n        return parsed_datetime\n\n    parsed_datetime['parsed_datetime'] = date_str\n    return parsed_datetime", "response": "Parses a date string to a dictionary of datetime objects."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef parse_solr_time_range_as_pair(time_filter):\n    pattern = \"\\\\[(.*) TO (.*)\\\\]\"\n    matcher = re.search(pattern, time_filter)\n    if matcher:\n        return matcher.group(1), matcher.group(2)\n    else:\n        raise Exception(\"Regex {0} couldn't parse {1}\".format(pattern, time_filter))", "response": "Parse Solr time range as a pair of time range."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef parse_datetime_range(time_filter):\n\n    if not time_filter:\n        time_filter = \"[* TO *]\"\n\n    start, end = parse_solr_time_range_as_pair(time_filter)\n    start, end = parse_datetime(start), parse_datetime(end)\n    return start, end", "response": "Parse the time range of a Solr query parameter into a start and end datetime tuple."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef parse_ISO8601(time_gap):\n    matcher = None\n\n    if time_gap.count(\"T\"):\n        units = {\n            \"H\": (\"HOURS\", isodate.Duration(hours=1)),\n            \"M\": (\"MINUTES\", isodate.Duration(minutes=1)),\n            \"S\": (\"SECONDS\", isodate.Duration(seconds=1))\n        }\n        matcher = re.search(\"PT(\\d+)([HMS])\", time_gap)\n        if matcher:\n            quantity = int(matcher.group(1))\n            unit = matcher.group(2)\n            return quantity, units.get(unit)\n        else:\n            raise Exception(\"Does not match the pattern: {}\".format(time_gap))\n    else:\n        units = {\n            \"Y\": (\"YEARS\", isodate.Duration(years=1)),\n            \"M\": (\"MONTHS\", isodate.Duration(months=1)),\n            \"W\": (\"WEEKS\", isodate.Duration(weeks=1)),\n            \"D\": (\"DAYS\", isodate.Duration(days=1))\n        }\n        matcher = re.search(\"P(\\d+)([YMWD])\", time_gap)\n        if matcher:\n            quantity = int(matcher.group(1))\n            unit = matcher.group(2)\n        else:\n            raise Exception(\"Does not match the pattern: {}\".format(time_gap))\n\n    return quantity, units.get(unit)", "response": "Parse ISO8601 time_gap into a tuple with quantity and unit of time."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncompute a gap that seems reasonable considering natural time units and limit.", "response": "def compute_gap(start, end, time_limit):\n    \"\"\"\n    Compute a gap that seems reasonable, considering natural time units and limit.\n    # TODO: make it to be reasonable.\n    # TODO: make it to be small unit of time sensitive.\n    :param start: datetime\n    :param end: datetime\n    :param time_limit: gaps count\n    :return: solr's format duration.\n    \"\"\"\n    if is_range_common_era(start, end):\n        duration = end.get(\"parsed_datetime\") - start.get(\"parsed_datetime\")\n        unit = int(math.ceil(duration.days / float(time_limit)))\n        return \"+{0}DAYS\".format(unit)\n    else:\n        # at the moment can not do maths with BCE dates.\n        # those dates are relatively big, so 100 years are reasonable in those cases.\n        # TODO: calculate duration on those cases.\n        return \"+100YEARS\""}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nconvert a gap time to SORL format", "response": "def gap_to_sorl(time_gap):\n    \"\"\"\n    P1D to +1DAY\n    :param time_gap:\n    :return: solr's format duration.\n    \"\"\"\n    quantity, unit = parse_ISO8601(time_gap)\n    if unit[0] == \"WEEKS\":\n        return \"+{0}DAYS\".format(quantity * 7)\n    else:\n        return \"+{0}{1}\".format(quantity, unit[0])"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef request_time_facet(field, time_filter, time_gap, time_limit=100):\n    start, end = parse_datetime_range(time_filter)\n\n    key_range_start = \"f.{0}.facet.range.start\".format(field)\n    key_range_end = \"f.{0}.facet.range.end\".format(field)\n    key_range_gap = \"f.{0}.facet.range.gap\".format(field)\n    key_range_mincount = \"f.{0}.facet.mincount\".format(field)\n\n    if time_gap:\n        gap = gap_to_sorl(time_gap)\n    else:\n        gap = compute_gap(start, end, time_limit)\n\n    value_range_start = start.get(\"parsed_datetime\")\n    if start.get(\"is_common_era\"):\n        value_range_start = start.get(\"parsed_datetime\").isoformat().replace(\"+00:00\", \"\") + \"Z\"\n\n    value_range_end = start.get(\"parsed_datetime\")\n    if end.get(\"is_common_era\"):\n        value_range_end = end.get(\"parsed_datetime\").isoformat().replace(\"+00:00\", \"\") + \"Z\"\n\n    value_range_gap = gap\n\n    params = {\n        'facet.range': field,\n        key_range_start: value_range_start,\n        key_range_end: value_range_end,\n        key_range_gap: value_range_gap,\n        key_range_mincount: 1\n    }\n\n    return params", "response": "Request a time facet query builder for a given field."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nparsing Solr Geo Range as Pair", "response": "def parse_solr_geo_range_as_pair(geo_box_str):\n    \"\"\"\n    :param geo_box_str: [-90,-180 TO 90,180]\n    :return: (\"-90,-180\", \"90,180\")\n    \"\"\"\n    pattern = \"\\\\[(.*) TO (.*)\\\\]\"\n    matcher = re.search(pattern, geo_box_str)\n    if matcher:\n        return matcher.group(1), matcher.group(2)\n    else:\n        raise Exception(\"Regex {0} could not parse {1}\".format(pattern, geo_box_str))"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nparse a shapely. geometry. box into shapely. geometry. box", "response": "def parse_geo_box(geo_box_str):\n    \"\"\"\n    parses [-90,-180 TO 90,180] to a shapely.geometry.box\n    :param geo_box_str:\n    :return:\n    \"\"\"\n\n    from_point_str, to_point_str = parse_solr_geo_range_as_pair(geo_box_str)\n    from_point = parse_lat_lon(from_point_str)\n    to_point = parse_lat_lon(to_point_str)\n    rectangle = box(from_point[0], from_point[1], to_point[0], to_point[1])\n    return rectangle"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef request_heatmap_facet(field, hm_filter, hm_grid_level, hm_limit):\n\n    if not hm_filter:\n        hm_filter = '[-90,-180 TO 90,180]'\n\n    params = {\n        'facet': 'on',\n        'facet.heatmap': field,\n        'facet.heatmap.geom': hm_filter\n    }\n\n    if hm_grid_level:\n        # note: aHmLimit is ignored in this case\n        params['facet.heatmap.gridLevel'] = hm_grid_level\n    else:\n        # Calculate distErr that will approximate aHmLimit many cells as an upper bound\n        rectangle = parse_geo_box(hm_filter)\n        degrees_side_length = rectangle.length / 2\n        cell_side_length = math.sqrt(float(hm_limit))\n        cell_side_length_degrees = degrees_side_length / cell_side_length * 2\n        params['facet.heatmap.distErr'] = str(float(cell_side_length_degrees))\n        # TODO: not sure about if returning correct param values.\n\n    # get_params = urllib.urlencode(params)\n    return params", "response": "Request a heatmap facet query builder for a given field."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ntranslate asterisk to min and max", "response": "def asterisk_to_min_max(field, time_filter, search_engine_endpoint, actual_params=None):\n    \"\"\"\n    traduce [* TO *] to something like [MIN-INDEXED-DATE TO MAX-INDEXED-DATE]\n    :param field: map the stats to this field.\n    :param time_filter: this is the value to be translated. think in \"[* TO 2000]\"\n    :param search_engine_endpoint: solr core\n    :param actual_params: (not implemented) to merge with other params.\n    :return: translated time filter\n    \"\"\"\n\n    if actual_params:\n        raise NotImplemented(\"actual_params\")\n\n    start, end = parse_solr_time_range_as_pair(time_filter)\n    if start == '*' or end == '*':\n        params_stats = {\n            \"q\": \"*:*\",\n            \"rows\": 0,\n            \"stats.field\": field,\n            \"stats\": \"true\",\n            \"wt\": \"json\"\n        }\n        res_stats = requests.get(search_engine_endpoint, params=params_stats)\n\n        if res_stats.ok:\n\n            stats_date_field = res_stats.json()[\"stats\"][\"stats_fields\"][field]\n            date_min = stats_date_field[\"min\"]\n            date_max = stats_date_field[\"max\"]\n\n            if start != '*':\n                date_min = start\n            if end != '*':\n                date_max = end\n\n            time_filter = \"[{0} TO {1}]\".format(date_min, date_max)\n\n    return time_filter"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_service(raw_xml):\n    from pycsw.core.etree import etree\n\n    parsed = etree.fromstring(raw_xml, etree.XMLParser(resolve_entities=False))\n\n    # <dc:format>OGC:WMS</dc:format>\n    source_tag = parsed.find(\"{http://purl.org/dc/elements/1.1/}source\")\n    # <dc:source>\n    #    http://ngamaps.geointapps.org/arcgis/services/RIO/Rio_Foundation_Transportation/MapServer/WMSServer\n    # </dc:source>\n    format_tag = parsed.find(\"{http://purl.org/dc/elements/1.1/}format\")\n\n    service_url = None\n    service_type = None\n\n    if hasattr(source_tag, 'text'):\n        service_url = source_tag.text\n\n    if hasattr(format_tag, 'text'):\n        service_type = format_tag.text\n\n    if hasattr(format_tag, 'text'):\n        service_type = format_tag.text\n\n    service, created = Service.objects.get_or_create(url=service_url,\n                                                     is_monitored=False,\n                                                     type=service_type)\n    # TODO: dont hardcode SRS, get them from the parsed XML.\n    srs, created = SpatialReferenceSystem.objects.get_or_create(code=\"EPSG:4326\")\n    service.srs.add(srs)\n\n    return service", "response": "Get a service object based on the XML metadata"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nqueries by list of identifiers", "response": "def query_ids(self, ids):\n        \"\"\"\n        Query by list of identifiers\n        \"\"\"\n\n        results = self._get_repo_filter(Layer.objects).filter(uuid__in=ids).all()\n\n        if len(results) == 0:  # try services\n            results = self._get_repo_filter(Service.objects).filter(uuid__in=ids).all()\n\n        return results"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nquerying by property domain values", "response": "def query_domain(self, domain, typenames, domainquerytype='list', count=False):\n        \"\"\"\n        Query by property domain values\n        \"\"\"\n\n        objects = self._get_repo_filter(Layer.objects)\n\n        if domainquerytype == 'range':\n            return [tuple(objects.aggregate(Min(domain), Max(domain)).values())]\n        else:\n            if count:\n                return [(d[domain], d['%s__count' % domain])\n                        for d in objects.values(domain).annotate(Count(domain))]\n            else:\n                return objects.values_list(domain).distinct()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nquery to get latest or earliest update to repository", "response": "def query_insert(self, direction='max'):\n        \"\"\"\n        Query to get latest (default) or earliest update to repository\n        \"\"\"\n        if direction == 'min':\n            return Layer.objects.aggregate(\n                Min('last_updated'))['last_updated__min'].strftime('%Y-%m-%dT%H:%M:%SZ')\n        return self._get_repo_filter(Layer.objects).aggregate(\n            Max('last_updated'))['last_updated__max'].strftime('%Y-%m-%dT%H:%M:%SZ')"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef query(self, constraint, sortby=None, typenames=None, maxrecords=10, startposition=0):\n\n        # run the raw query and get total\n        # we want to exclude layers which are not valid, as it is done in the search engine\n        if 'where' in constraint:  # GetRecords with constraint\n            query = self._get_repo_filter(Layer.objects).filter(\n                is_valid=True).extra(where=[constraint['where']], params=constraint['values'])\n        else:  # GetRecords sans constraint\n            query = self._get_repo_filter(Layer.objects).filter(is_valid=True)\n\n        total = query.count()\n\n        # apply sorting, limit and offset\n        if sortby is not None:\n            if 'spatial' in sortby and sortby['spatial']:  # spatial sort\n                desc = False\n                if sortby['order'] == 'DESC':\n                    desc = True\n                query = query.all()\n                return [str(total),\n                        sorted(query,\n                               key=lambda x: float(util.get_geometry_area(getattr(x, sortby['propertyname']))),\n                               reverse=desc,\n                               )[startposition:startposition+int(maxrecords)]]\n            else:\n                if sortby['order'] == 'DESC':\n                    pname = '-%s' % sortby['propertyname']\n                else:\n                    pname = sortby['propertyname']\n                return [str(total),\n                        query.order_by(pname)[startposition:startposition+int(maxrecords)]]\n        else:  # no sort\n            return [str(total), query.all()[startposition:startposition+int(maxrecords)]]", "response": "Query records from underlying repository"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef insert(self, resourcetype, source, insert_date=None):\n\n        caller = inspect.stack()[1][3]\n\n        if caller == 'transaction':  # insert of Layer\n            hhclass = 'Layer'\n            source = resourcetype\n            resourcetype = resourcetype.csw_schema\n        else:  # insert of service\n            hhclass = 'Service'\n            if resourcetype not in HYPERMAP_SERVICE_TYPES.keys():\n                raise RuntimeError('Unsupported Service Type')\n\n        return self._insert_or_update(resourcetype, source, mode='insert', hhclass=hhclass)", "response": "Insert a record into the repository."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ninserts or update a record in the repository", "response": "def _insert_or_update(self, resourcetype, source, mode='insert', hhclass='Service'):\n        \"\"\"\n        Insert or update a record in the repository\n        \"\"\"\n\n        keywords = []\n\n        if self.filter is not None:\n            catalog = Catalog.objects.get(id=int(self.filter.split()[-1]))\n\n        try:\n            if hhclass == 'Layer':\n                # TODO: better way of figuring out duplicates\n                match = Layer.objects.filter(name=source.name,\n                                             title=source.title,\n                                             abstract=source.abstract,\n                                             is_monitored=False)\n                matches = match.all()\n                if matches:\n                    if mode == 'insert':\n                        raise RuntimeError('HHypermap error: Layer %d \\'%s\\' already exists' % (\n                                           matches[0].id, source.title))\n                    elif mode == 'update':\n                        match.update(\n                            name=source.name,\n                            title=source.title,\n                            abstract=source.abstract,\n                            is_monitored=False,\n                            xml=source.xml,\n                            wkt_geometry=source.wkt_geometry,\n                            anytext=util.get_anytext([source.title, source.abstract, source.keywords_csv])\n                        )\n\n                service = get_service(source.xml)\n                res, keywords = create_layer_from_metadata_xml(resourcetype, source.xml,\n                                                               monitor=False, service=service,\n                                                               catalog=catalog)\n\n                res.save()\n\n                LOGGER.debug('Indexing layer with id %s on search engine' % res.uuid)\n                index_layer(res.id, use_cache=True)\n\n            else:\n                if resourcetype == 'http://www.opengis.net/cat/csw/2.0.2':\n                    res = Endpoint(url=source, catalog=catalog)\n                else:\n                    res = Service(type=HYPERMAP_SERVICE_TYPES[resourcetype], url=source, catalog=catalog)\n\n                res.save()\n\n            if keywords:\n                for kw in keywords:\n                    res.keywords.add(kw)\n        except Exception as err:\n            raise RuntimeError('HHypermap error: %s' % err)\n\n        # return a list of ids that were inserted or updated\n        ids = []\n\n        if hhclass == 'Layer':\n            ids.append({'identifier': res.uuid, 'title': res.title})\n        else:\n            if resourcetype == 'http://www.opengis.net/cat/csw/2.0.2':\n                for res in Endpoint.objects.filter(url=source).all():\n                    ids.append({'identifier': res.uuid, 'title': res.url})\n            else:\n                for res in Service.objects.filter(url=source).all():\n                    ids.append({'identifier': res.uuid, 'title': res.title})\n\n        return ids"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef delete(self, constraint):\n\n        results = self._get_repo_filter(Service.objects).extra(where=[constraint['where']],\n                                                               params=constraint['values']).all()\n        deleted = len(results)\n        results.delete()\n        return deleted", "response": "Delete a record from the repository"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _get_repo_filter(self, query):\n        if self.filter is not None:\n            return query.extra(where=[self.filter])\n        return query", "response": "Apply repository wide side filter"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef to_meshlevel(meshcode):\n\n    length = len(str(meshcode))\n    if length == 4:\n        return 1\n\n    if length == 5:\n        return 40000\n\n    if length == 6:\n        return 2\n\n    if length == 7:\n        if meshcode[6:7] in ['1','2','3','4']:\n            return 5000\n\n        if meshcode[6:7] == '6':\n            return 8000\n\n        if meshcode[6:7] == '5':\n            return 20000\n\n        if meshcode[6:7] == '7':\n            return 16000\n\n    if length == 8:\n        return 3\n\n    if length == 9:\n        if meshcode[8:9] in ['1','2','3','4']:\n            return 4\n\n        if meshcode[8:9] == '5':\n            return 2000\n\n        if meshcode[8:9] == '6':\n            return 2500\n\n        if meshcode[8:9] == '7':\n            return 4000\n\n    if length == 10:\n        if meshcode[9:10] in ['1','2','3','4']:\n            return 5\n\n    if length == 11:\n        if meshcode[10:11] in ['1','2','3','4']:\n            return 6\n\n    raise ValueError('the meshcode is unsupported.')", "response": "Returns the number of nodes in a given meshcode."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef to_meshpoint(meshcode, lat_multiplier, lon_multiplier):\n\n    def mesh_cord(func_higher_cord, func_unit_cord, func_multiplier):\n        return func_higher_cord() + func_unit_cord() * func_multiplier()\n\n    lat_multiplier_lv = lambda: lat_multiplier\n\n    lon_multiplier_lv = lambda: lon_multiplier\n\n    lat_multiplier_lv1 = _functools.partial(\n        lambda meshcode: int(meshcode[0:2]), meshcode=meshcode)\n\n    lon_multiplier_lv1 = _functools.partial(\n        lambda meshcode: int(meshcode[2:4]), meshcode=meshcode)\n\n    lat_multiplier_40000 = _functools.partial(\n        lambda meshcode: int(bin(int(meshcode[4:5])-1)[2:].zfill(2)[0:1]), meshcode=meshcode)\n\n    lon_multiplier_40000 = _functools.partial(\n        lambda meshcode: int(bin(int(meshcode[4:5])-1)[2:].zfill(2)[1:2]), meshcode=meshcode)\n\n    lat_multiplier_20000 = _functools.partial(\n        lambda meshcode: int(bin(int(meshcode[5:6])-1)[2:].zfill(2)[0:1]), meshcode=meshcode)\n\n    lon_multiplier_20000 = _functools.partial(\n        lambda meshcode: int(bin(int(meshcode[5:6])-1)[2:].zfill(2)[1:2]), meshcode=meshcode)\n\n    lat_multiplier_16000 = _functools.partial(\n        lambda meshcode: int(meshcode[4:5])/2, meshcode=meshcode)\n\n    lon_multiplier_16000 = _functools.partial(\n        lambda meshcode: int(meshcode[5:6])/2, meshcode=meshcode)\n\n    lat_multiplier_lv2 = _functools.partial(\n        lambda meshcode: int(meshcode[4:5]), meshcode=meshcode)\n\n    lon_multiplier_lv2 = _functools.partial(\n        lambda meshcode: int(meshcode[5:6]), meshcode=meshcode)\n\n    lat_multiplier_8000 = _functools.partial(\n        lambda meshcode: int(meshcode[4:5]), meshcode=meshcode)\n\n    lon_multiplier_8000 = _functools.partial(\n        lambda meshcode: int(meshcode[5:6]), meshcode=meshcode)\n\n    lat_multiplier_5000 = _functools.partial(\n        lambda meshcode: int(bin(int(meshcode[6:7])-1)[2:].zfill(2)[0:1]), meshcode=meshcode)\n\n    lon_multiplier_5000 = _functools.partial(\n        lambda meshcode: int(bin(int(meshcode[6:7])-1)[2:].zfill(2)[1:2]), meshcode=meshcode)\n\n    lat_multiplier_4000 = _functools.partial(\n        lambda meshcode: int(bin(int(meshcode[7:8])-1)[2:].zfill(2)[0:1]), meshcode=meshcode)\n\n    lon_multiplier_4000 = _functools.partial(\n        lambda meshcode: int(bin(int(meshcode[7:8])-1)[2:].zfill(2)[1:2]), meshcode=meshcode)\n\n    lat_multiplier_2500 = _functools.partial(\n        lambda meshcode: int(bin(int(meshcode[7:8])-1)[2:].zfill(2)[0:1]), meshcode=meshcode)\n\n    lon_multiplier_2500 = _functools.partial(\n        lambda meshcode: int(bin(int(meshcode[7:8])-1)[2:].zfill(2)[1:2]), meshcode=meshcode)\n\n    lat_multiplier_2000 = _functools.partial(\n        lambda meshcode: int(meshcode[6:7])/2, meshcode=meshcode)\n\n    lon_multiplier_2000 = _functools.partial(\n        lambda meshcode: int(meshcode[7:8])/2, meshcode=meshcode)\n\n    lat_multiplier_lv3 = _functools.partial(\n        lambda meshcode: int(meshcode[6:7]), meshcode=meshcode)\n\n    lon_multiplier_lv3 = _functools.partial(\n        lambda meshcode: int(meshcode[7:8]), meshcode=meshcode)\n\n    lat_multiplier_lv4 = _functools.partial(\n        lambda meshcode: int(bin(int(meshcode[8:9])-1)[2:].zfill(2)[0:1]), meshcode=meshcode)\n\n    lon_multiplier_lv4 = _functools.partial(\n        lambda meshcode: int(bin(int(meshcode[8:9])-1)[2:].zfill(2)[1:2]), meshcode=meshcode)\n\n    lat_multiplier_lv5 = _functools.partial(\n        lambda meshcode: int(bin(int(meshcode[9:10])-1)[2:].zfill(2)[0:1]), meshcode=meshcode)\n\n    lon_multiplier_lv5 = _functools.partial(\n        lambda meshcode: int(bin(int(meshcode[9:10])-1)[2:].zfill(2)[1:2]), meshcode=meshcode)\n\n    lat_multiplier_lv6 = _functools.partial(\n        lambda meshcode: int(bin(int(meshcode[10:11])-1)[2:].zfill(2)[0:1]), meshcode=meshcode)\n\n    lon_multiplier_lv6 = _functools.partial(\n        lambda meshcode: int(bin(int(meshcode[10:11])-1)[2:].zfill(2)[1:2]), meshcode=meshcode)\n\n    mesh_lv1_default_lat = _functools.partial(\n        mesh_cord,\n        func_higher_cord=lambda: 0,\n        func_unit_cord=_unit_lat_lv1,\n        func_multiplier=lat_multiplier_lv1)\n\n    mesh_lv1_default_lon = _functools.partial(\n        mesh_cord,\n        func_higher_cord=lambda: 100,\n        func_unit_cord=_unit_lon_lv1,\n        func_multiplier=lon_multiplier_lv1)\n\n    mesh_40000_default_lat = _functools.partial(\n        mesh_cord,\n        func_higher_cord=mesh_lv1_default_lat,\n        func_unit_cord=_unit_lat_40000,\n        func_multiplier=lat_multiplier_40000)\n\n    mesh_40000_default_lon = _functools.partial(\n        mesh_cord,\n        func_higher_cord=mesh_lv1_default_lon,\n        func_unit_cord=_unit_lon_40000,\n        func_multiplier=lon_multiplier_40000)\n\n    mesh_20000_default_lat = _functools.partial(\n        mesh_cord,\n        func_higher_cord=mesh_40000_default_lat,\n        func_unit_cord=_unit_lat_20000,\n        func_multiplier=lat_multiplier_20000)\n\n    mesh_20000_default_lon = _functools.partial(\n        mesh_cord,\n        func_higher_cord=mesh_40000_default_lon,\n        func_unit_cord=_unit_lon_20000,\n        func_multiplier=lon_multiplier_20000)\n\n    mesh_16000_default_lat = _functools.partial(\n        mesh_cord,\n        func_higher_cord=mesh_lv1_default_lat,\n        func_unit_cord=_unit_lat_16000,\n        func_multiplier=lat_multiplier_16000)\n\n    mesh_16000_default_lon = _functools.partial(\n        mesh_cord,\n        func_higher_cord=mesh_lv1_default_lon,\n        func_unit_cord=_unit_lon_16000,\n        func_multiplier=lon_multiplier_16000)\n\n    mesh_lv2_default_lat = _functools.partial(\n        mesh_cord,\n        func_higher_cord=mesh_lv1_default_lat,\n        func_unit_cord=_unit_lat_lv2,\n        func_multiplier=lat_multiplier_lv2)\n\n    mesh_lv2_default_lon = _functools.partial(\n        mesh_cord,\n        func_higher_cord=mesh_lv1_default_lon,\n        func_unit_cord=_unit_lon_lv2,\n        func_multiplier=lon_multiplier_lv2)\n\n    mesh_8000_default_lat = _functools.partial(\n        mesh_cord,\n        func_higher_cord=mesh_lv1_default_lat,\n        func_unit_cord=_unit_lat_8000,\n        func_multiplier=lat_multiplier_8000)\n\n    mesh_8000_default_lon = _functools.partial(\n        mesh_cord,\n        func_higher_cord=mesh_lv1_default_lon,\n        func_unit_cord=_unit_lon_8000,\n        func_multiplier=lon_multiplier_8000)\n\n    mesh_5000_default_lat = _functools.partial(\n        mesh_cord,\n        func_higher_cord=mesh_lv2_default_lat,\n        func_unit_cord=_unit_lat_5000,\n        func_multiplier=lat_multiplier_5000)\n\n    mesh_5000_default_lon = _functools.partial(\n        mesh_cord,\n        func_higher_cord=mesh_lv2_default_lon,\n        func_unit_cord=_unit_lon_5000,\n        func_multiplier=lon_multiplier_5000)\n\n    mesh_4000_default_lat = _functools.partial(\n        mesh_cord,\n        func_higher_cord=mesh_8000_default_lat,\n        func_unit_cord=_unit_lat_4000,\n        func_multiplier=lat_multiplier_4000)\n\n    mesh_4000_default_lon = _functools.partial(\n        mesh_cord,\n        func_higher_cord=mesh_8000_default_lon,\n        func_unit_cord=_unit_lon_4000,\n        func_multiplier=lon_multiplier_4000)\n\n    mesh_2500_default_lat = _functools.partial(\n        mesh_cord,\n        func_higher_cord=mesh_5000_default_lat,\n        func_unit_cord=_unit_lat_2500,\n        func_multiplier=lat_multiplier_2500)\n\n    mesh_2500_default_lon = _functools.partial(\n        mesh_cord,\n        func_higher_cord=mesh_5000_default_lon,\n        func_unit_cord=_unit_lon_2500,\n        func_multiplier=lon_multiplier_2500)\n\n    mesh_2000_default_lat = _functools.partial(\n        mesh_cord,\n        func_higher_cord=mesh_lv2_default_lat,\n        func_unit_cord=_unit_lat_2000,\n        func_multiplier=lat_multiplier_2000)\n\n    mesh_2000_default_lon = _functools.partial(\n        mesh_cord,\n        func_higher_cord=mesh_lv2_default_lon,\n        func_unit_cord=_unit_lon_2000,\n        func_multiplier=lon_multiplier_2000)\n\n    mesh_lv3_default_lat = _functools.partial(\n        mesh_cord,\n        func_higher_cord=mesh_lv2_default_lat,\n        func_unit_cord=_unit_lat_lv3,\n        func_multiplier=lat_multiplier_lv3)\n\n    mesh_lv3_default_lon = _functools.partial(\n        mesh_cord,\n        func_higher_cord=mesh_lv2_default_lon,\n        func_unit_cord=_unit_lon_lv3,\n        func_multiplier=lon_multiplier_lv3)\n\n    mesh_lv4_default_lat = _functools.partial(\n        mesh_cord,\n        func_higher_cord=mesh_lv3_default_lat,\n        func_unit_cord=_unit_lat_lv4,\n        func_multiplier=lat_multiplier_lv4)\n\n    mesh_lv4_default_lon = _functools.partial(\n        mesh_cord,\n        func_higher_cord=mesh_lv3_default_lon,\n        func_unit_cord=_unit_lon_lv4,\n        func_multiplier=lon_multiplier_lv4)\n\n    mesh_lv5_default_lat = _functools.partial(\n        mesh_cord,\n        func_higher_cord=mesh_lv4_default_lat,\n        func_unit_cord=_unit_lat_lv5,\n        func_multiplier=lat_multiplier_lv5)\n\n    mesh_lv5_default_lon = _functools.partial(\n        mesh_cord,\n        func_higher_cord=mesh_lv4_default_lon,\n        func_unit_cord=_unit_lon_lv5,\n        func_multiplier=lon_multiplier_lv5)\n\n    mesh_lv6_default_lat = _functools.partial(\n        mesh_cord,\n        func_higher_cord=mesh_lv5_default_lat,\n        func_unit_cord=_unit_lat_lv6,\n        func_multiplier=lat_multiplier_lv6)\n\n    mesh_lv6_default_lon = _functools.partial(\n        mesh_cord,\n        func_higher_cord=mesh_lv5_default_lon,\n        func_unit_cord=_unit_lon_lv6,\n        func_multiplier=lon_multiplier_lv6)\n\n    mesh_lv1_lat = _functools.partial(\n        mesh_cord,\n        func_higher_cord=mesh_lv1_default_lat,\n        func_unit_cord=_unit_lat_lv1,\n        func_multiplier=lat_multiplier_lv)\n\n    mesh_lv1_lon = _functools.partial(\n        mesh_cord,\n        func_higher_cord=mesh_lv1_default_lon,\n        func_unit_cord=_unit_lon_lv1,\n        func_multiplier=lon_multiplier_lv)\n\n    mesh_40000_lat = _functools.partial(\n        mesh_cord,\n        func_higher_cord=mesh_40000_default_lat,\n        func_unit_cord=_unit_lat_40000,\n        func_multiplier=lat_multiplier_lv)\n\n    mesh_40000_lon = _functools.partial(\n        mesh_cord,\n        func_higher_cord=mesh_40000_default_lon,\n        func_unit_cord=_unit_lon_40000,\n        func_multiplier=lon_multiplier_lv)\n\n    mesh_20000_lat = _functools.partial(\n        mesh_cord,\n        func_higher_cord=mesh_20000_default_lat,\n        func_unit_cord=_unit_lat_20000,\n        func_multiplier=lat_multiplier_lv)\n\n    mesh_20000_lon = _functools.partial(\n        mesh_cord,\n        func_higher_cord=mesh_20000_default_lon,\n        func_unit_cord=_unit_lon_20000,\n        func_multiplier=lon_multiplier_lv)\n\n    mesh_16000_lat = _functools.partial(\n        mesh_cord,\n        func_higher_cord=mesh_16000_default_lat,\n        func_unit_cord=_unit_lat_16000,\n        func_multiplier=lat_multiplier_lv)\n\n    mesh_16000_lon = _functools.partial(\n        mesh_cord,\n        func_higher_cord=mesh_16000_default_lon,\n        func_unit_cord=_unit_lon_16000,\n        func_multiplier=lon_multiplier_lv)\n\n    mesh_lv2_lat = _functools.partial(\n        mesh_cord,\n        func_higher_cord=mesh_lv2_default_lat,\n        func_unit_cord=_unit_lat_lv2,\n        func_multiplier=lat_multiplier_lv)\n\n    mesh_lv2_lon = _functools.partial(\n        mesh_cord,\n        func_higher_cord=mesh_lv2_default_lon,\n        func_unit_cord=_unit_lon_lv2,\n        func_multiplier=lon_multiplier_lv)\n\n    mesh_8000_lat = _functools.partial(\n        mesh_cord,\n        func_higher_cord=mesh_8000_default_lat,\n        func_unit_cord=_unit_lat_8000,\n        func_multiplier=lat_multiplier_lv)\n\n    mesh_8000_lon = _functools.partial(\n        mesh_cord,\n        func_higher_cord=mesh_8000_default_lon,\n        func_unit_cord=_unit_lon_8000,\n        func_multiplier=lon_multiplier_lv)\n\n    mesh_5000_lat = _functools.partial(\n        mesh_cord,\n        func_higher_cord=mesh_5000_default_lat,\n        func_unit_cord=_unit_lat_5000,\n        func_multiplier=lat_multiplier_lv)\n\n    mesh_5000_lon = _functools.partial(\n        mesh_cord,\n        func_higher_cord=mesh_5000_default_lon,\n        func_unit_cord=_unit_lon_5000,\n        func_multiplier=lon_multiplier_lv)\n\n    mesh_4000_lat = _functools.partial(\n        mesh_cord,\n        func_higher_cord=mesh_4000_default_lat,\n        func_unit_cord=_unit_lat_4000,\n        func_multiplier=lat_multiplier_lv)\n\n    mesh_4000_lon = _functools.partial(\n        mesh_cord,\n        func_higher_cord=mesh_4000_default_lon,\n        func_unit_cord=_unit_lon_4000,\n        func_multiplier=lon_multiplier_lv)\n\n    mesh_2500_lat = _functools.partial(\n        mesh_cord,\n        func_higher_cord=mesh_2500_default_lat,\n        func_unit_cord=_unit_lat_2500,\n        func_multiplier=lat_multiplier_lv)\n\n    mesh_2500_lon = _functools.partial(\n        mesh_cord,\n        func_higher_cord=mesh_2500_default_lon,\n        func_unit_cord=_unit_lon_2500,\n        func_multiplier=lon_multiplier_lv)\n\n    mesh_2000_lat = _functools.partial(\n        mesh_cord,\n        func_higher_cord=mesh_2000_default_lat,\n        func_unit_cord=_unit_lat_2000,\n        func_multiplier=lat_multiplier_lv)\n\n    mesh_2000_lon = _functools.partial(\n        mesh_cord,\n        func_higher_cord=mesh_2000_default_lon,\n        func_unit_cord=_unit_lon_2000,\n        func_multiplier=lon_multiplier_lv)\n\n    mesh_lv3_lat = _functools.partial(\n        mesh_cord,\n        func_higher_cord=mesh_lv3_default_lat,\n        func_unit_cord=_unit_lat_lv3,\n        func_multiplier=lat_multiplier_lv)\n\n    mesh_lv3_lon = _functools.partial(\n        mesh_cord,\n        func_higher_cord=mesh_lv3_default_lon,\n        func_unit_cord=_unit_lon_lv3,\n        func_multiplier=lon_multiplier_lv)\n\n    mesh_lv4_lat = _functools.partial(\n        mesh_cord,\n        func_higher_cord=mesh_lv4_default_lat,\n        func_unit_cord=_unit_lat_lv4,\n        func_multiplier=lat_multiplier_lv)\n\n    mesh_lv4_lon = _functools.partial(\n        mesh_cord,\n        func_higher_cord=mesh_lv4_default_lon,\n        func_unit_cord=_unit_lon_lv4,\n        func_multiplier=lon_multiplier_lv)\n\n    mesh_lv5_lat = _functools.partial(\n        mesh_cord,\n        func_higher_cord=mesh_lv5_default_lat,\n        func_unit_cord=_unit_lat_lv5,\n        func_multiplier=lat_multiplier_lv)\n\n    mesh_lv5_lon = _functools.partial(\n        mesh_cord,\n        func_higher_cord=mesh_lv5_default_lon,\n        func_unit_cord=_unit_lon_lv5,\n        func_multiplier=lon_multiplier_lv)\n\n    mesh_lv6_lat = _functools.partial(\n        mesh_cord,\n        func_higher_cord=mesh_lv6_default_lat,\n        func_unit_cord=_unit_lat_lv6,\n        func_multiplier=lat_multiplier_lv)\n\n    mesh_lv6_lon = _functools.partial(\n        mesh_cord,\n        func_higher_cord=mesh_lv6_default_lon,\n        func_unit_cord=_unit_lon_lv6,\n        func_multiplier=lon_multiplier_lv)\n\n    level = to_meshlevel(meshcode)\n\n    if level == 1:\n        return mesh_lv1_lat(), mesh_lv1_lon()\n\n    if level == 40000:\n        return mesh_40000_lat(), mesh_40000_lon()\n\n    if level == 20000:\n        return mesh_20000_lat(), mesh_20000_lon()\n\n    if level == 16000:\n        return mesh_16000_lat(), mesh_16000_lon()\n\n    if level == 2:\n        return mesh_lv2_lat(), mesh_lv2_lon()\n\n    if level == 8000:\n        return mesh_8000_lat(), mesh_8000_lon()\n\n    if level == 5000:\n        return mesh_5000_lat(), mesh_5000_lon()\n\n    if level == 4000:\n        return mesh_4000_lat(), mesh_4000_lon()\n\n    if level == 2500:\n        return mesh_2500_lat(), mesh_2500_lon()\n\n    if level == 2000:\n        return mesh_2000_lat(), mesh_2000_lon()\n\n    if level == 3:\n        return mesh_lv3_lat(), mesh_lv3_lon()\n\n    if level == 4:\n        return mesh_lv4_lat(), mesh_lv4_lon()\n\n    if level == 5:\n        return mesh_lv5_lat(), mesh_lv5_lon()\n\n    if level == 6:\n        return mesh_lv6_lat(), mesh_lv6_lon()\n\n    raise ValueError(\"the level is unsupported.\")", "response": "Convert a meshcode to a meshpoint."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nchecks the permissions http method and login state.", "response": "def check(func):\n    \"\"\" \n    Check the permissions, http method and login state.\n    \"\"\"\n    def iCheck(request, *args, **kwargs):\n        if not request.method == \"POST\":\n            return HttpResponseBadRequest(\"Must be POST request.\")\n        follow = func(request, *args, **kwargs)\n        if request.is_ajax():\n            return HttpResponse('ok')\n        try:\n            if 'next' in request.GET:\n                return HttpResponseRedirect(request.GET.get('next'))\n            if 'next' in request.POST:\n                return HttpResponseRedirect(request.POST.get('next'))\n            return HttpResponseRedirect(follow.target.get_absolute_url())\n        except (AttributeError, TypeError):\n            if 'HTTP_REFERER' in request.META:\n                return HttpResponseRedirect(request.META.get('HTTP_REFERER', '/'))\n            if follow:\n                return HttpResponseServerError('\"%s\" object of type ``%s`` has no method ``get_absolute_url()``.' % (\n                    unicode(follow.target), follow.target.__class__))\n            return HttpResponseServerError('No follow object and `next` parameter found.')\n    return iCheck"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nregistering a model class to be follow - able.", "response": "def register(model, field_name=None, related_name=None, lookup_method_name='get_follows'):\n    \"\"\"\n    This registers any model class to be follow-able.\n    \n    \"\"\"\n    if model in registry:\n        return\n\n    registry.append(model)\n    \n    if not field_name:\n        field_name = 'target_%s' % model._meta.module_name\n    \n    if not related_name:\n        related_name = 'follow_%s' % model._meta.module_name\n    \n    field = ForeignKey(model, related_name=related_name, null=True,\n        blank=True, db_index=True)\n    \n    field.contribute_to_class(Follow, field_name)\n    setattr(model, lookup_method_name, get_followers_for_object)\n    model_map[model] = [related_name, field_name]"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef follow(user, obj):\n    follow, created = Follow.objects.get_or_create(user, obj)\n    return follow", "response": "Make a user follow an object"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nmaking a user unfollow an object", "response": "def unfollow(user, obj):\n    \"\"\" Make a user unfollow an object \"\"\"\n    try:\n        follow = Follow.objects.get_follows(obj).get(user=user)\n        follow.delete()\n        return follow \n    except Follow.DoesNotExist:\n        pass"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef validate_q_time(self, value):\n        if value:\n            try:\n                range = utils.parse_datetime_range_to_solr(value)\n                return range\n            except Exception as e:\n                raise serializers.ValidationError(e.message)\n\n        return value", "response": "Validate the q_time field."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nvalidate the value of the QGE field.", "response": "def validate_q_geo(self, value):\n        \"\"\"\n        Would be for example: [-90,-180 TO 90,180]\n        \"\"\"\n        if value:\n            try:\n                rectangle = utils.parse_geo_box(value)\n                return \"[{0},{1} TO {2},{3}]\".format(\n                    rectangle.bounds[0],\n                    rectangle.bounds[1],\n                    rectangle.bounds[2],\n                    rectangle.bounds[3],\n                )\n            except Exception as e:\n                raise serializers.ValidationError(e.message)\n\n        return value"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nvalidate a time filter.", "response": "def validate_a_time_filter(self, value):\n        \"\"\"\n        Would be for example: [2013-03-01 TO 2013-04-01:00:00:00] and/or [* TO *]\n        \"\"\"\n        if value:\n            try:\n                utils.parse_datetime_range(value)\n            except Exception as e:\n                raise serializers.ValidationError(e.message)\n\n        return value"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the name of the field on the model.", "response": "def fname(self, model_or_obj_or_qs):\n        \"\"\" \n        Return the field name on the :class:`Follow` model for ``model_or_obj_or_qs``.\n        \"\"\"\n        if isinstance(model_or_obj_or_qs, QuerySet):\n            _, fname = model_map[model_or_obj_or_qs.model]\n        else:\n            cls = model_or_obj_or_qs if inspect.isclass(model_or_obj_or_qs) else model_or_obj_or_qs.__class__\n            _, fname = model_map[cls]\n        return fname"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef create(self, user, obj, **kwargs):\n        follow = Follow(user=user)\n        follow.target = obj\n        follow.save()\n        return follow", "response": "Create a new follow link between a user and an object."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_or_create(self, user, obj, **kwargs):\n        if not self.is_following(user, obj):\n            return self.create(user, obj, **kwargs), True\n        return self.get_follows(obj).get(user=user), False", "response": "Returns a tuple with the Follow and whether the user is following the object."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef is_following(self, user, obj):\n        if isinstance(user, AnonymousUser):\n            return False        \n        return 0 < self.get_follows(obj).filter(user=user).count()", "response": "Returns True if user is following obj"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn all the followers of a model or a queryset.", "response": "def get_follows(self, model_or_obj_or_qs):\n        \"\"\"\n        Returns all the followers of a model, an object or a queryset.\n        \"\"\"\n        fname = self.fname(model_or_obj_or_qs)\n        \n        if isinstance(model_or_obj_or_qs, QuerySet):\n            return self.filter(**{'%s__in' % fname: model_or_obj_or_qs})\n        \n        if inspect.isclass(model_or_obj_or_qs):\n            return self.exclude(**{fname:None})\n\n        return self.filter(**{fname:model_or_obj_or_qs})"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate the event regressors for one event type.", "response": "def create_event_regressors(self, event_times_indices, covariates = None, durations = None):\n        \"\"\"create_event_regressors creates the part of the design matrix corresponding to one event type. \n\n            :param event_times_indices: indices in the resampled data, on which the events occurred.\n            :type event_times_indices: numpy array, (nr_events)\n            :param covariates: covariates belonging to this event type. If None, covariates with a value of 1 for all events are created and used internally.\n            :type covariates: numpy array, (nr_events)\n            :param durations: durations belonging to this event type. If None, durations with a value of 1 sample for all events are created and used internally.\n            :type durations: numpy array, (nr_events)\n            :returns: This event type's part of the design matrix.\n        \"\"\"\n\n        # check covariates\n        if covariates is None:\n            covariates = np.ones(self.event_times_indices.shape)\n\n        # check/create durations, convert from seconds to samples time, and compute mean duration for this event type.\n        if durations is None:\n            durations = np.ones(self.event_times_indices.shape)\n        else:\n            durations = np.round(durations*self.deconvolution_frequency).astype(int)\n        mean_duration = np.mean(durations)\n\n        # set up output array\n        regressors_for_event = np.zeros((self.deconvolution_interval_size, self.resampled_signal_size))\n\n        # fill up output array by looping over events.\n        for cov, eti, dur in zip(covariates, event_times_indices, durations):\n            valid = True\n            if eti < 0:\n                self.logger.debug('deconv samples are starting before the data starts.')\n                valid = False\n            if eti+self.deconvolution_interval_size > self.resampled_signal_size:\n                self.logger.debug('deconv samples are continuing after the data stops.')\n                valid = False\n            if eti > self.resampled_signal_size:\n                self.logger.debug('event falls outside of the scope of the data.')\n                valid = False\n\n            if valid: # only incorporate sensible events.\n                # calculate the design matrix that belongs to this event.\n                this_event_design_matrix = (np.diag(np.ones(self.deconvolution_interval_size)) * cov)\n                over_durations_dm = np.copy(this_event_design_matrix)\n                if dur > 1: # if this event has a non-unity duration, duplicate the stick regressors in the time direction\n                    for d in np.arange(1,dur):\n                        over_durations_dm[d:] += this_event_design_matrix[:-d]\n                    # and correct for differences in durations between different regressor types.\n                    over_durations_dm /= mean_duration\n                # add the designmatrix for this event to the full design matrix for this type of event.\n                regressors_for_event[:,eti:int(eti+self.deconvolution_interval_size)] += over_durations_dm\n        \n        return regressors_for_event"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating the design matrix for each covariate.", "response": "def create_design_matrix(self, demean = False, intercept = True):\n        \"\"\"create_design_matrix calls create_event_regressors for each of the covariates in the self.covariates dict. self.designmatrix is created and is shaped (nr_regressors, self.resampled_signal.shape[-1])\n        \"\"\"\n        self.design_matrix = np.zeros((int(self.number_of_event_types*self.deconvolution_interval_size), self.resampled_signal_size))\n\n        for i, covariate in enumerate(self.covariates.keys()):\n            # document the creation of the designmatrix step by step\n            self.logger.debug('creating regressor for ' + covariate)\n            indices = np.arange(i*self.deconvolution_interval_size,(i+1)*self.deconvolution_interval_size, dtype = int)\n            # here, we implement the dot-separated encoding of events and covariates\n            if len(covariate.split('.')) > 0:\n                which_event_time_indices = covariate.split('.')[0]\n            else:\n                which_event_time_indices = covariate\n            self.design_matrix[indices] = self.create_event_regressors( self.event_times_indices[which_event_time_indices], \n                                                                        self.covariates[covariate], \n                                                                        self.durations[which_event_time_indices])\n\n        if demean:\n            # we expect the data to be demeaned. \n            # it's an option whether the regressors should be, too\n            self.design_matrix = (self.design_matrix.T - self.design_matrix.mean(axis = -1)).T\n        if intercept:\n            # similarly, intercept is a choice.\n            self.design_matrix = np.vstack((self.design_matrix, np.ones((1,self.design_matrix.shape[-1]))))\n        \n        self.logger.debug('created %s design_matrix' % (str(self.design_matrix.shape)))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef add_continuous_regressors_to_design_matrix(self, regressors):\n        previous_design_matrix_shape = self.design_matrix.shape\n        if len(regressors.shape) == 1:\n            regressors = regressors[np.newaxis, :]\n        if regressors.shape[1] != self.resampled_signal.shape[1]:\n            self.logger.warning('additional regressor shape %s does not conform to designmatrix shape %s' % (regressors.shape, self.resampled_signal.shape))\n        # and, an vstack append\n        self.design_matrix = np.vstack((self.design_matrix, regressors))\n        self.logger.debug('added %s continuous regressors to %s design_matrix, shape now %s' % (str(regressors.shape), str(previous_design_matrix_shape), str(self.design_matrix.shape)))", "response": "Adds continuously sampled regressors to the design matrix."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef regress(self, method = 'lstsq'):\n\n        if method is 'lstsq':\n            self.betas, residuals_sum, rank, s = LA.lstsq(self.design_matrix.T, self.resampled_signal.T)\n            self.residuals = self.resampled_signal - self.predict_from_design_matrix(self.design_matrix)\n        elif method is 'sm_ols':\n            import statsmodels.api as sm\n\n            assert self.resampled_signal.shape[0] == 1, \\\n                    'signal input into statsmodels OLS cannot contain multiple signals at once, present shape %s' % str(self.resampled_signal.shape)\n            model = sm.OLS(np.squeeze(self.resampled_signal),self.design_matrix.T)\n            results = model.fit()\n            # make betas and residuals that are compatible with the LA.lstsq type.\n            self.betas = np.array(results.params).reshape((self.design_matrix.shape[0], self.resampled_signal.shape[0]))\n            self.residuals = np.array(results.resid).reshape(self.resampled_signal.shape)\n\n        self.logger.debug('performed %s regression on %s design_matrix and %s signal' % (method, str(self.design_matrix.shape), str(self.resampled_signal.shape)))", "response": "regress computes the linear least squares regression of the design matrix on the data."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nperforming k - folds ridge regression on the design_matrix.", "response": "def ridge_regress(self, cv = 20, alphas = None ):\n        \"\"\"perform k-folds cross-validated ridge regression on the design_matrix. To be used when the design matrix contains very collinear regressors. For cross-validation and ridge fitting, we use sklearn's RidgeCV functionality. Note: intercept is not fit, and data are not prenormalized. \n\n            :param cv: cross-validated folds, inherits RidgeCV cv argument's functionality.\n            :type cv: int, standard = 20\n            :param alphas: values of penalization parameter to be traversed by the procedure, inherits RidgeCV cv argument's functionality. Standard value, when parameter is None, is np.logspace(7, 0, 20)\n            :type alphas: numpy array, from >0 to 1. \n            :returns: instance variables 'betas' (nr_betas x nr_signals) and 'residuals' (nr_signals x nr_samples) are created.\n        \"\"\"\n        if alphas is None:\n            alphas = np.logspace(7, 0, 20)\n        self.rcv = linear_model.RidgeCV(alphas=alphas, \n                fit_intercept=False, \n                cv=cv) \n        self.rcv.fit(self.design_matrix.T, self.resampled_signal.T)\n\n        self.betas = self.rcv.coef_.T\n        self.residuals = self.resampled_signal - self.rcv.predict(self.design_matrix.T)\n\n        self.logger.debug('performed ridge regression on %s design_matrix and %s signal, resulting alpha value is %f' % (str(self.design_matrix.shape), str(self.resampled_signal.shape), self.rcv.alpha_))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef betas_for_cov(self, covariate = '0'):\n        # find the index in the designmatrix of the current covariate\n        this_covariate_index = list(self.covariates.keys()).index(covariate)\n        return self.betas[int(this_covariate_index*self.deconvolution_interval_size):int((this_covariate_index+1)*self.deconvolution_interval_size)]", "response": "returns the beta values associated with a specific covariate"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef betas_for_events(self):\n        self.betas_per_event_type = np.zeros((len(self.covariates), self.deconvolution_interval_size, self.resampled_signal.shape[0]))\n        for i, covariate in enumerate(self.covariates.keys()):\n            self.betas_per_event_type[i] = self.betas_for_cov(covariate)", "response": "Creates an array of betas per event type for each outcome."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef predict_from_design_matrix(self, design_matrix):\n        # check if we have already run the regression - which is necessary\n        assert hasattr(self, 'betas'), 'no betas found, please run regression before prediction'\n        assert design_matrix.shape[0] == self.betas.shape[0], \\\n                    'designmatrix needs to have the same number of regressors as the betas already calculated'\n\n        # betas = np.copy(self.betas.T, order=\"F\", dtype = np.float32)\n        # f_design_matrix = np.copy(design_matrix, order = \"F\", dtype = np.float32)\n\n        prediction = np.dot(self.betas.astype(np.float32).T, design_matrix.astype(np.float32))\n\n        return prediction", "response": "predict_from_design_matrix predicts signals given a design matrix."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef calculate_rsq(self):\n        assert hasattr(self, 'betas'), 'no betas found, please run regression before rsq'\n\n        explained_times = self.design_matrix.sum(axis = 0) != 0\n\n        explained_signal = self.predict_from_design_matrix(self.design_matrix)\n        self.rsq = 1.0 - np.sum((explained_signal[:,explained_times] - self.resampled_signal[:,explained_times])**2, axis = -1) / np.sum(self.resampled_signal[:,explained_times].squeeze()**2, axis = -1)\n        self.ssr = np.sum((explained_signal[:,explained_times] - self.resampled_signal[:,explained_times])**2, axis = -1)\n        return np.squeeze(self.rsq)", "response": "calculate_rsq calculates coefficient of determination or r - squared defined here as 1. 0 - SS_res / SS_tot. rsq is only calculated for those timepoints in the data for which the design matrix is non - zero. ssr is only calculated for those timepoints in the data for which the design matrix is non - zero."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef bootstrap_on_residuals(self, nr_repetitions = 1000):\n        assert self.resampled_signal.shape[0] == 1, \\\n                    'signal input into bootstrap_on_residuals cannot contain signals from multiple channels at once, present shape %s' % str(self.resampled_signal.shape)\n        assert hasattr(self, 'betas'), 'no betas found, please run regression before bootstrapping'\n\n        # create bootstrap data by taking the residuals\n        bootstrap_data = np.zeros((self.resampled_signal_size, nr_repetitions))\n        explained_signal = self.predict_from_design_matrix(self.design_matrix).T\n\n        for x in range(bootstrap_data.shape[-1]): # loop over bootstrapsamples\n            bootstrap_data[:,x] = (self.residuals.T[np.random.permutation(self.resampled_signal_size)] + explained_signal).squeeze()\n\n        self.bootstrap_betas, bs_residuals, rank, s = LA.lstsq(self.design_matrix.T, bootstrap_data)\n\n        self.bootstrap_betas_per_event_type = np.zeros((len(self.covariates), self.deconvolution_interval_size, nr_repetitions))\n\n        for i, covariate in enumerate(list(self.covariates.keys())):\n            # find the index in the designmatrix of the current covariate\n            this_covariate_index = list(self.covariates.keys()).index(covariate)\n            self.bootstrap_betas_per_event_type[i] = self.bootstrap_betas[this_covariate_index*self.deconvolution_interval_size:(this_covariate_index+1)*self.deconvolution_interval_size]", "response": "This function computes the bootstraps on the residuals of the current betas and creates the residuals for each event."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nindexes all layers in the Django cache.", "response": "def index_cached_layers(self):\n    \"\"\"\n    Index and unindex all layers in the Django cache (Index all layers who have been checked).\n    \"\"\"\n    from hypermap.aggregator.models import Layer\n\n    if SEARCH_TYPE == 'solr':\n        from hypermap.aggregator.solr import SolrHypermap\n        solrobject = SolrHypermap()\n    else:\n        from hypermap.aggregator.elasticsearch_client import ESHypermap\n        from elasticsearch import helpers\n        es_client = ESHypermap()\n\n    layers_cache = cache.get('layers')\n    deleted_layers_cache = cache.get('deleted_layers')\n\n    # 1. added layers cache\n    if layers_cache:\n        layers_list = list(layers_cache)\n        LOGGER.debug('There are %s layers in cache: %s' % (len(layers_list), layers_list))\n\n        batch_size = settings.REGISTRY_SEARCH_BATCH_SIZE\n        batch_lists = [layers_list[i:i+batch_size] for i in range(0, len(layers_list), batch_size)]\n\n        for batch_list_ids in batch_lists:\n            layers = Layer.objects.filter(id__in=batch_list_ids)\n\n            if batch_size > len(layers):\n                batch_size = len(layers)\n\n            LOGGER.debug('Syncing %s/%s layers to %s: %s' % (batch_size, len(layers_cache), layers, SEARCH_TYPE))\n\n            try:\n                # SOLR\n                if SEARCH_TYPE == 'solr':\n                    success, layers_errors_ids = solrobject.layers_to_solr(layers)\n                    if success:\n                        # remove layers from cache here\n                        layers_cache = layers_cache.difference(set(batch_list_ids))\n                        LOGGER.debug('Removing layers with id %s from cache' % batch_list_ids)\n                        cache.set('layers', layers_cache)\n                # ES\n                elif SEARCH_TYPE == 'elasticsearch':\n                    with_bulk, success = True, False\n                    layers_to_index = [es_client.layer_to_es(layer, with_bulk) for layer in layers]\n                    message = helpers.bulk(es_client.es, layers_to_index)\n\n                    # Check that all layers where indexed...if not, don't clear cache.\n                    # TODO: Check why es does not index all layers at first.\n                    len_indexed_layers = message[0]\n                    if len_indexed_layers == len(layers):\n                        LOGGER.debug('%d layers indexed successfully' % (len_indexed_layers))\n                        success = True\n                    if success:\n                        # remove layers from cache here\n                        layers_cache = layers_cache.difference(set(batch_list_ids))\n                        cache.set('layers', layers_cache)\n                else:\n                    raise Exception(\"Incorrect SEARCH_TYPE=%s\" % SEARCH_TYPE)\n            except Exception as e:\n                LOGGER.error('Layers were NOT indexed correctly')\n                LOGGER.error(e, exc_info=True)\n    else:\n        LOGGER.debug('No cached layers to add in search engine.')\n\n    # 2. deleted layers cache\n    if deleted_layers_cache:\n        layers_list = list(deleted_layers_cache)\n        LOGGER.debug('There are %s layers in cache for deleting: %s' % (len(layers_list), layers_list))\n        # TODO implement me: batch layer index deletion\n        for layer_id in layers_list:\n            # SOLR\n            if SEARCH_TYPE == 'solr':\n                if Layer.objects.filter(pk=layer_id).exists():\n                    layer = Layer.objects.get(id=layer_id)\n                    unindex_layer(layer.id, use_cache=False)\n                    deleted_layers_cache = deleted_layers_cache.difference(set([layer_id]))\n                    cache.set('deleted_layers', deleted_layers_cache)\n            else:\n                # TODO implement me\n                raise NotImplementedError\n    else:\n        LOGGER.debug('No cached layers to remove in search engine.')"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nremove all checks from a service.", "response": "def remove_service_checks(self, service_id):\n    \"\"\"\n    Remove all checks from a service.\n    \"\"\"\n    from hypermap.aggregator.models import Service\n    service = Service.objects.get(id=service_id)\n\n    service.check_set.all().delete()\n    layer_to_process = service.layer_set.all()\n    for layer in layer_to_process:\n        layer.check_set.all().delete()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef index_service(self, service_id):\n\n    from hypermap.aggregator.models import Service\n    service = Service.objects.get(id=service_id)\n\n    if not service.is_valid:\n        LOGGER.debug('Not indexing service with id %s in search engine as it is not valid' % service.id)\n        return\n\n    LOGGER.debug('Indexing service %s' % service.id)\n    layer_to_process = service.layer_set.all()\n\n    for layer in layer_to_process:\n        if not settings.REGISTRY_SKIP_CELERY:\n            index_layer(layer.id, use_cache=True)\n        else:\n            index_layer(layer.id)", "response": "Index a service in search engine."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef index_layer(self, layer_id, use_cache=False):\n\n    from hypermap.aggregator.models import Layer\n    layer = Layer.objects.get(id=layer_id)\n\n    if not layer.is_valid:\n        LOGGER.debug('Not indexing or removing layer with id %s in search engine as it is not valid' % layer.id)\n        unindex_layer(layer.id, use_cache)\n        return\n\n    if layer.was_deleted:\n        LOGGER.debug('Not indexing or removing layer with id %s in search engine as was_deleted is true' % layer.id)\n        unindex_layer(layer.id, use_cache)\n        return\n\n    # 1. if we use cache\n    if use_cache:\n        LOGGER.debug('Caching layer with id %s for syncing with search engine' % layer.id)\n        layers = cache.get('layers')\n        if layers is None:\n            layers = set([layer.id])\n        else:\n            layers.add(layer.id)\n        cache.set('layers', layers)\n        return\n\n    # 2. if we don't use cache\n    # TODO: Make this function more DRY\n    # by abstracting the common bits.\n    if SEARCH_TYPE == 'solr':\n        from hypermap.aggregator.solr import SolrHypermap\n        LOGGER.debug('Syncing layer %s to solr' % layer.name)\n        solrobject = SolrHypermap()\n        success, message = solrobject.layer_to_solr(layer)\n        # update the error message if using celery\n        if not settings.REGISTRY_SKIP_CELERY:\n            if not success:\n                self.update_state(\n                    state=states.FAILURE,\n                    meta=message\n                    )\n                raise Ignore()\n    elif SEARCH_TYPE == 'elasticsearch':\n        from hypermap.aggregator.elasticsearch_client import ESHypermap\n        LOGGER.debug('Syncing layer %s to es' % layer.name)\n        esobject = ESHypermap()\n        success, message = esobject.layer_to_es(layer)\n        # update the error message if using celery\n        if not settings.REGISTRY_SKIP_CELERY:\n            if not success:\n                self.update_state(\n                    state=states.FAILURE,\n                    meta=message\n                    )\n                raise Ignore()", "response": "Index a layer in the search backend."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef unindex_layers_with_issues(self, use_cache=False):\n    from hypermap.aggregator.models import Issue, Layer, Service\n    from django.contrib.contenttypes.models import ContentType\n\n    layer_type = ContentType.objects.get_for_model(Layer)\n    service_type = ContentType.objects.get_for_model(Service)\n\n    for issue in Issue.objects.filter(content_type__pk=layer_type.id):\n        unindex_layer(issue.content_object.id, use_cache)\n\n    for issue in Issue.objects.filter(content_type__pk=service_type.id):\n        for layer in issue.content_object.layer_set.all():\n            unindex_layer(layer.id, use_cache)", "response": "Remove the index for layers in search backend which are linked to an issue."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nremoves the index for a layer in the search backend.", "response": "def unindex_layer(self, layer_id, use_cache=False):\n    \"\"\"\n    Remove the index for a layer in the search backend.\n    If cache is set, append it to the list of removed layers, if it isn't send the transaction right away.\n    \"\"\"\n\n    from hypermap.aggregator.models import Layer\n    layer = Layer.objects.get(id=layer_id)\n\n    if use_cache:\n        LOGGER.debug('Caching layer with id %s for being removed from search engine' % layer.id)\n        deleted_layers = cache.get('deleted_layers')\n        if deleted_layers is None:\n            deleted_layers = set([layer.id])\n        else:\n            deleted_layers.add(layer.id)\n        cache.set('deleted_layers', deleted_layers)\n        return\n\n    if SEARCH_TYPE == 'solr':\n        from hypermap.aggregator.solr import SolrHypermap\n        LOGGER.debug('Removing layer %s from solr' % layer.id)\n        try:\n            solrobject = SolrHypermap()\n            solrobject.remove_layer(layer.uuid)\n        except Exception:\n            LOGGER.error('Layer NOT correctly removed from Solr')\n    elif SEARCH_TYPE == 'elasticsearch':\n        # TODO implement me\n        pass"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nindex all layers in search engine.", "response": "def index_all_layers(self):\n    \"\"\"\n    Index all layers in search engine.\n    \"\"\"\n    from hypermap.aggregator.models import Layer\n\n    if not settings.REGISTRY_SKIP_CELERY:\n        layers_cache = set(Layer.objects.filter(is_valid=True).values_list('id', flat=True))\n        deleted_layers_cache = set(Layer.objects.filter(is_valid=False).values_list('id', flat=True))\n        cache.set('layers', layers_cache)\n        cache.set('deleted_layers', deleted_layers_cache)\n    else:\n        for layer in Layer.objects.all():\n            index_layer(layer.id)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nupdate the last num_layers layers in the WorldMap service.", "response": "def update_last_wm_layers(self, service_id, num_layers=10):\n    \"\"\"\n    Update and index the last added and deleted layers (num_layers) in WorldMap service.\n    \"\"\"\n    from hypermap.aggregator.models import Service\n\n    LOGGER.debug(\n        'Updating the index the last %s added and %s deleted layers in WorldMap service'\n        % (num_layers, num_layers)\n                )\n    service = Service.objects.get(id=service_id)\n    # TODO raise error if service type is not WM type\n    if service.type == 'Hypermap:WorldMapLegacy':\n        from hypermap.aggregator.models import update_layers_wm_legacy as update_layers_wm\n    if service.type == 'Hypermap:WorldMap':\n        from hypermap.aggregator.models import update_layers_geonode_wm as update_layers_wm\n\n    update_layers_wm(service, num_layers)\n\n    # Remove in search engine last num_layers that were deleted\n    LOGGER.debug('Removing the index for the last %s deleted layers' % num_layers)\n    layer_to_unindex = service.layer_set.filter(was_deleted=True).order_by('-last_updated')[0:num_layers]\n    for layer in layer_to_unindex:\n        if not settings.REGISTRY_SKIP_CELERY:\n            unindex_layer(layer.id, use_cache=True)\n        else:\n            unindex_layer(layer.id)\n\n    # Add/Update in search engine last num_layers that were added\n    LOGGER.debug('Adding/Updating the index for the last %s added layers' % num_layers)\n    layer_to_index = service.layer_set.filter(was_deleted=False).order_by('-last_updated')[0:num_layers]\n    for layer in layer_to_index:\n        if not settings.REGISTRY_SKIP_CELERY:\n            index_layer(layer.id, use_cache=True)\n        else:\n            index_layer(layer.id)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a WKT Polygon of a simple bounding box list", "response": "def bbox2wktpolygon(bbox):\n    \"\"\"\n    Return OGC WKT Polygon of a simple bbox list\n    \"\"\"\n\n    try:\n        minx = float(bbox[0])\n        miny = float(bbox[1])\n        maxx = float(bbox[2])\n        maxy = float(bbox[3])\n\n    except:\n        LOGGER.debug(\"Invalid bbox, setting it to a zero POLYGON\")\n        minx = 0\n        miny = 0\n        maxx = 0\n        maxy = 0\n\n    return 'POLYGON((%.2f %.2f, %.2f %.2f, %.2f %.2f, %.2f %.2f, %.2f %.2f))' \\\n        % (minx, miny, minx, maxy, maxx, maxy, maxx, miny, minx, miny)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating a csw : Record XML document from harvested metadata", "response": "def create_metadata_record(**kwargs):\n    \"\"\"\n    Create a csw:Record XML document from harvested metadata\n    \"\"\"\n\n    if 'srs' in kwargs:\n        srs = kwargs['srs']\n    else:\n        srs = '4326'\n\n    modified = '%sZ' % datetime.datetime.utcnow().isoformat().split('.')[0]\n\n    nsmap = Namespaces().get_namespaces(['csw', 'dc', 'dct', 'ows'])\n\n    e = etree.Element(nspath_eval('csw:Record', nsmap), nsmap=nsmap)\n\n    etree.SubElement(e, nspath_eval('dc:identifier', nsmap)).text = kwargs['identifier']\n    etree.SubElement(e, nspath_eval('dc:title', nsmap)).text = kwargs['title']\n    if 'alternative' in kwargs:\n        etree.SubElement(e, nspath_eval('dct:alternative', nsmap)).text = kwargs['alternative']\n    etree.SubElement(e, nspath_eval('dct:modified', nsmap)).text = modified\n    etree.SubElement(e, nspath_eval('dct:abstract', nsmap)).text = kwargs['abstract']\n    etree.SubElement(e, nspath_eval('dc:type', nsmap)).text = kwargs['type']\n    etree.SubElement(e, nspath_eval('dc:format', nsmap)).text = kwargs['format']\n    etree.SubElement(e, nspath_eval('dc:source', nsmap)).text = kwargs['source']\n\n    if 'relation' in kwargs:\n        etree.SubElement(e, nspath_eval('dc:relation', nsmap)).text = kwargs['relation']\n\n    if 'keywords' in kwargs:\n        if kwargs['keywords'] is not None:\n            for keyword in kwargs['keywords']:\n                etree.SubElement(e, nspath_eval('dc:subject', nsmap)).text = keyword\n\n    for link in kwargs['links']:\n        etree.SubElement(e, nspath_eval('dct:references', nsmap), scheme=link[0]).text = link[1]\n\n    bbox2 = loads(kwargs['wkt_geometry']).bounds\n    bbox = etree.SubElement(e, nspath_eval('ows:BoundingBox', nsmap),\n                            crs='http://www.opengis.net/def/crs/EPSG/0/%s' % srs,\n                            dimensions='2')\n\n    etree.SubElement(bbox, nspath_eval('ows:LowerCorner', nsmap)).text = '%s %s' % (bbox2[1], bbox2[0])\n    etree.SubElement(bbox, nspath_eval('ows:UpperCorner', nsmap)).text = '%s %s' % (bbox2[3], bbox2[2])\n\n    return etree.tostring(e, pretty_print=True)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef gen_anytext(*args):\n\n    bag = []\n\n    for term in args:\n        if term is not None:\n            if isinstance(term, list):\n                for term2 in term:\n                    if term2 is not None:\n                        bag.append(term2)\n            else:\n                bag.append(term)\n    return ' '.join(bag)", "response": "Convenience function to create bag of words for anytext property"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef update_layers_wmts(service):\n    try:\n        wmts = WebMapTileService(service.url)\n\n        # set srs\n        # WMTS is always in 4326\n        srs, created = SpatialReferenceSystem.objects.get_or_create(code='EPSG:4326')\n        service.srs.add(srs)\n\n        service.update_validity()\n\n        layer_names = list(wmts.contents)\n        layer_n = 0\n        total = len(layer_names)\n        for layer_name in layer_names:\n            ows_layer = wmts.contents[layer_name]\n            LOGGER.debug('Updating layer %s' % ows_layer.name)\n            layer, created = Layer.objects.get_or_create(name=ows_layer.name, service=service, catalog=service.catalog)\n            if layer.active:\n                links = [['OGC:WMTS', service.url],\n                         ['OGC:WMTS', settings.SITE_URL.rstrip('/') + '/' + layer.get_url_endpoint()]]\n                layer.type = 'OGC:WMTS'\n                layer.title = ows_layer.title\n                layer.abstract = ows_layer.abstract\n                # keywords\n                # @tomkralidis wmts does not seem to support this attribute\n                keywords = None\n                if hasattr(ows_layer, 'keywords'):\n                    keywords = ows_layer.keywords\n                    for keyword in keywords:\n                        layer.keywords.add(keyword)\n                layer.url = service.url\n                layer.page_url = layer.get_absolute_url\n                links.append([\n                    'WWW:LINK',\n                    settings.SITE_URL.rstrip('/') + layer.page_url\n                ])\n                bbox = list(ows_layer.boundingBoxWGS84 or (-179.0, -89.0, 179.0, 89.0))\n                layer.bbox_x0 = bbox[0]\n                layer.bbox_y0 = bbox[1]\n                layer.bbox_x1 = bbox[2]\n                layer.bbox_y1 = bbox[3]\n                layer.wkt_geometry = bbox2wktpolygon(bbox)\n                layer.xml = create_metadata_record(\n                    identifier=str(layer.uuid),\n                    source=service.url,\n                    links=links,\n                    format='OGC:WMS',\n                    type=layer.csw_type,\n                    relation=service.id_string,\n                    title=ows_layer.title,\n                    alternative=ows_layer.name,\n                    abstract=layer.abstract,\n                    keywords=keywords,\n                    wkt_geometry=layer.wkt_geometry\n                )\n                layer.anytext = gen_anytext(layer.title, layer.abstract, keywords)\n                layer.save()\n                # dates\n                add_mined_dates(layer)\n            layer_n = layer_n + 1\n            # exits if DEBUG_SERVICES\n            LOGGER.debug(\"Updating layer n. %s/%s\" % (layer_n, total))\n            if DEBUG_SERVICES and layer_n == DEBUG_LAYER_NUMBER:\n                return\n    except Exception as err:\n        message = \"update_layers_wmts: {0}\".format(\n            err\n        )\n        check = Check(\n            content_object=service,\n            success=False,\n            response_time=0,\n            message=message\n        )\n        check.save()", "response": "Update layers for an OGC WMTS service."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nupdating layers for a WorldMap instance.", "response": "def update_layers_geonode_wm(service, num_layers=None):\n    \"\"\"\n    Update layers for a WorldMap instance.\n    Sample endpoint: http://localhost:8000/\n    \"\"\"\n    wm_api_url = urlparse.urljoin(service.url, 'worldmap/api/2.8/layer/?format=json')\n\n    if num_layers:\n        total = num_layers\n    else:\n        response = requests.get(wm_api_url)\n        data = json.loads(response.content)\n        total = data['meta']['total_count']\n\n    # set srs\n    # WorldMap supports only 4326, 900913, 3857\n    for crs_code in ['EPSG:4326', 'EPSG:900913', 'EPSG:3857']:\n        srs, created = SpatialReferenceSystem.objects.get_or_create(code=crs_code)\n        service.srs.add(srs)\n\n    service.update_validity()\n\n    layer_n = 0\n    limit = 10\n\n    for i in range(0, total, limit):\n        try:\n            url = (\n                    '%s&order_by=-date&offset=%s&limit=%s' % (wm_api_url, i, limit)\n            )\n            LOGGER.debug('Fetching %s' % url)\n            response = requests.get(url)\n            data = json.loads(response.content)\n            for row in data['objects']:\n                typename = row['typename']\n                # name = typename.split(':')[1]\n                name = typename\n                uuid = row['uuid']\n                LOGGER.debug('Updating layer %s' % name)\n                title = row['title']\n                abstract = row['abstract']\n                bbox = row['bbox']\n                page_url = urlparse.urljoin(service.url, 'data/%s' % name)\n                category = ''\n                if 'topic_category' in row:\n                    category = row['topic_category']\n                username = ''\n                if 'owner_username' in row:\n                    username = row['owner_username']\n                temporal_extent_start = ''\n                if 'temporal_extent_start' in row:\n                    temporal_extent_start = row['temporal_extent_start']\n                temporal_extent_end = ''\n                if 'temporal_extent_end' in row:\n                    temporal_extent_end = row['temporal_extent_end']\n                # we use the geoserver virtual layer getcapabilities for wm endpoint\n                # TODO we should port make geoserver port configurable some way...\n                # endpoint = urlparse.urljoin(service.url, 'geoserver/geonode/%s/wms?' % name)\n                endpoint = urlparse.urljoin(service.url, 'geoserver/wms?')\n                endpoint = endpoint.replace('8000', '8080')\n                print endpoint\n                if 'is_public' in row:\n                    is_public = row['is_public']\n                layer, created = Layer.objects.get_or_create(\n                    service=service, catalog=service.catalog, name=name, uuid=uuid)\n                if created:\n                    LOGGER.debug('Added a new layer in registry: %s, %s' % (name, uuid))\n                if layer.active:\n                    links = [['Hypermap:WorldMap', endpoint]]\n                    # update fields\n                    layer.type = 'Hypermap:WorldMap'\n                    layer.title = title\n                    layer.abstract = abstract\n                    layer.is_public = is_public\n                    layer.url = endpoint\n                    layer.page_url = page_url\n                    # category and owner username\n                    layer_wm, created = LayerWM.objects.get_or_create(layer=layer)\n                    layer_wm.category = category\n                    layer_wm.username = username\n                    layer_wm.temporal_extent_start = temporal_extent_start\n                    layer_wm.temporal_extent_end = temporal_extent_end\n                    layer_wm.save()\n                    # bbox [x0, y0, x1, y1]\n                    # check if it is a valid bbox (TODO improve this check)\n                    # bbox = bbox.replace('-inf', 'None')\n                    # bbox = bbox.replace('inf', 'None')\n                    # if bbox.count(',') == 3:\n                    #    bbox_list = bbox[1:-1].split(',')\n                    # else:\n                    #    bbox_list = [None, None, None, None]\n                    x0 = format_float(bbox[0])\n                    x1 = format_float(bbox[1])\n                    y0 = format_float(bbox[2])\n                    y1 = format_float(bbox[3])\n                    # In many cases for some reason to be fixed GeoServer has x coordinates flipped in WM.\n                    x0, x1 = flip_coordinates(x0, x1)\n                    y0, y1 = flip_coordinates(y0, y1)\n                    layer.bbox_x0 = x0\n                    layer.bbox_y0 = y0\n                    layer.bbox_x1 = x1\n                    layer.bbox_y1 = y1\n                    # keywords\n                    keywords = []\n                    for keyword in row['keywords']:\n                        keywords.append(keyword['name'])\n                    layer.keywords.all().delete()\n                    for keyword in keywords:\n                        layer.keywords.add(keyword)\n                    layer.wkt_geometry = bbox2wktpolygon([x0, y0, x1, y1])\n                    layer.xml = create_metadata_record(\n                        identifier=str(layer.uuid),\n                        source=endpoint,\n                        links=links,\n                        format='Hypermap:WorldMap',\n                        type=layer.csw_type,\n                        relation=service.id_string,\n                        title=layer.title,\n                        alternative=name,\n                        abstract=layer.abstract,\n                        keywords=keywords,\n                        wkt_geometry=layer.wkt_geometry\n                    )\n                    layer.anytext = gen_anytext(layer.title, layer.abstract, keywords)\n                    layer.save()\n                    # dates\n                    add_mined_dates(layer)\n                    add_metadata_dates_to_layer([layer_wm.temporal_extent_start, layer_wm.temporal_extent_end], layer)\n                    layer_n = layer_n + 1\n                    # exits if DEBUG_SERVICES\n                    LOGGER.debug(\"Updated layer n. %s/%s\" % (layer_n, total))\n                    if DEBUG_SERVICES and layer_n == DEBUG_LAYER_NUMBER:\n                        return\n\n        except Exception as err:\n            LOGGER.error('Error! %s' % err)\n\n    # update deleted layers. For now we check the whole set of deleted layers\n    # we should optimize it if the list will grow\n    # TODO implement the actions application\n    url = urlparse.urljoin(service.url, 'worldmap/api/2.8/actionlayerdelete/?format=json')\n    LOGGER.debug('Fetching %s for detecting deleted layers' % url)\n    try:\n        response = requests.get(url)\n        data = json.loads(response.content)\n        for deleted_layer in data['objects']:\n            if Layer.objects.filter(uuid=deleted_layer['args']).count() > 0:\n                layer = Layer.objects.get(uuid=deleted_layer['args'])\n                layer.was_deleted = True\n                layer.save()\n                LOGGER.debug('Layer %s marked as deleted' % layer.uuid)\n    except Exception as err:\n        LOGGER.error('Error! %s' % err)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef update_layers_warper(service):\n    params = {'field': 'title', 'query': '', 'show_warped': '1', 'format': 'json'}\n    headers = {'Content-Type': 'application/json', 'Accept': 'application/json'}\n    request = requests.get(service.url, headers=headers, params=params)\n\n    try:\n        records = json.loads(request.content)\n        total_pages = int(records['total_pages'])\n\n        # set srs\n        # Warper supports only 4326, 900913, 3857\n        for crs_code in ['EPSG:4326', 'EPSG:900913', 'EPSG:3857']:\n            srs, created = SpatialReferenceSystem.objects.get_or_create(code=crs_code)\n            service.srs.add(srs)\n\n        service.update_validity()\n\n        for i in range(1, total_pages + 1):\n            params = {'field': 'title', 'query': '', 'show_warped': '1', 'format': 'json', 'page': i}\n            request = requests.get(service.url, headers=headers, params=params)\n            records = json.loads(request.content)\n            LOGGER.debug('Fetched %s' % request.url)\n            layers = records['items']\n            layer_n = 0\n            total = len(layers)\n            for layer in layers:\n                name = layer['id']\n                title = layer['title']\n                abstract = layer['description']\n                bbox = layer['bbox']\n                # dates\n                dates = []\n                if 'published_date' in layer:\n                    dates.append(layer['published_date'])\n                if 'date_depicted' in layer:\n                    dates.append(layer['date_depicted'])\n                if 'depicts_year' in layer:\n                    dates.append(layer['depicts_year'])\n                if 'issue_year' in layer:\n                    dates.append(layer['issue_year'])\n                layer, created = Layer.objects.get_or_create(name=name, service=service, catalog=service.catalog)\n                if layer.active:\n                    # update fields\n                    # links = [['OGC:WMTS', settings.SITE_URL.rstrip('/') + '/' + layer.get_url_endpoint()]]\n                    layer.type = 'Hypermap:WARPER'\n                    layer.title = title\n                    layer.abstract = abstract\n                    layer.is_public = True\n                    layer.url = '%s/wms/%s?' % (service.url, name)\n                    layer.page_url = '%s/%s' % (service.url, name)\n                    # bbox\n                    x0 = None\n                    y0 = None\n                    x1 = None\n                    y1 = None\n                    if bbox:\n                        bbox_list = bbox.split(',')\n                        x0 = format_float(bbox_list[0])\n                        y0 = format_float(bbox_list[1])\n                        x1 = format_float(bbox_list[2])\n                        y1 = format_float(bbox_list[3])\n                    layer.bbox_x0 = x0\n                    layer.bbox_y0 = y0\n                    layer.bbox_x1 = x1\n                    layer.bbox_y1 = y1\n                    layer.save()\n                    # dates\n                    add_mined_dates(layer)\n                    add_metadata_dates_to_layer(dates, layer)\n                layer_n = layer_n + 1\n                # exits if DEBUG_SERVICES\n                LOGGER.debug(\"Updating layer n. %s/%s\" % (layer_n, total))\n                if DEBUG_SERVICES and layer_n == DEBUG_LAYER_NUMBER:\n                    return\n\n    except Exception as err:\n        message = \"update_layers_warper: {0}. request={1} response={2}\".format(\n            err,\n            service.url,\n            request.text\n        )\n        check = Check(\n            content_object=service,\n            success=False,\n            response_time=0,\n            message=message\n        )\n        check.save()", "response": "Update layers for a Warper service."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nupdating the layers of an ESRI REST MapServer.", "response": "def update_layers_esri_mapserver(service, greedy_opt=False):\n    \"\"\"\n    Update layers for an ESRI REST MapServer.\n    Sample endpoint: https://gis.ngdc.noaa.gov/arcgis/rest/services/SampleWorldCities/MapServer/?f=json\n    \"\"\"\n    try:\n        esri_service = ArcMapService(service.url)\n        # set srs\n        # both mapserver and imageserver exposes just one srs at the service level\n        # not sure if other ones are supported, for now we just store this one\n\n        # not sure why this is needed, for now commenting out\n        # if wkt_text:\n        #     params = {'exact': 'True', 'error': 'True', 'mode': 'wkt', 'terms': wkt_text}\n        #     req = requests.get('http://prj2epsg.org/search.json', params=params)\n        #     object = json.loads(req.content)\n        #     srs = int(object['codes'][0]['code'])\n\n        srs_code = esri_service.spatialReference.wkid\n        srs, created = SpatialReferenceSystem.objects.get_or_create(code=srs_code)\n        service.srs.add(srs)\n\n        service.update_validity()\n\n        # check if it has a WMS interface\n        if 'supportedExtensions' in esri_service._json_struct and greedy_opt:\n            if 'WMSServer' in esri_service._json_struct['supportedExtensions']:\n                # we need to change the url\n                # http://cga1.cga.harvard.edu/arcgis/rest/services/ecuador/ecuadordata/MapServer?f=pjson\n                # http://cga1.cga.harvard.edu/arcgis/services/ecuador/\n                # ecuadordata/MapServer/WMSServer?request=GetCapabilities&service=WMS\n                wms_url = service.url.replace('/rest/services/', '/services/')\n                if '?f=pjson' in wms_url:\n                    wms_url = wms_url.replace('?f=pjson', 'WMSServer?')\n                if '?f=json' in wms_url:\n                    wms_url = wms_url.replace('?f=json', 'WMSServer?')\n                LOGGER.debug('This ESRI REST endpoint has an WMS interface to process: %s' % wms_url)\n                # import here as otherwise is circular (TODO refactor)\n                from utils import create_service_from_endpoint\n                create_service_from_endpoint(wms_url, 'OGC:WMS', catalog=service.catalog)\n        # now process the REST interface\n        layer_n = 0\n        total = len(esri_service.layers)\n        for esri_layer in esri_service.layers:\n            # in some case the json is invalid\n            # esri_layer._json_struct\n            # {u'currentVersion': 10.01,\n            # u'error':\n            # {u'message': u'An unexpected error occurred processing the request.', u'code': 500, u'details': []}}\n            if 'error' not in esri_layer._json_struct:\n                LOGGER.debug('Updating layer %s' % esri_layer.name)\n                layer, created = Layer.objects.get_or_create(\n                    name=esri_layer.id,\n                    service=service,\n                    catalog=service.catalog\n                )\n                if layer.active:\n                    layer.type = 'ESRI:ArcGIS:MapServer'\n                    links = [[layer.type, service.url],\n                             ['OGC:WMTS', settings.SITE_URL.rstrip('/') + '/' + layer.get_url_endpoint()]]\n                    layer.title = esri_layer.name\n                    layer.abstract = esri_service.serviceDescription\n                    layer.url = service.url\n                    layer.page_url = layer.get_absolute_url\n                    links.append([\n                        'WWW:LINK',\n                        settings.SITE_URL.rstrip('/') + layer.page_url\n                    ])\n                    try:\n                        layer.bbox_x0 = esri_layer.extent.xmin\n                        layer.bbox_y0 = esri_layer.extent.ymin\n                        layer.bbox_x1 = esri_layer.extent.xmax\n                        layer.bbox_y1 = esri_layer.extent.ymax\n                    except KeyError:\n                        pass\n                    try:\n                        layer.bbox_x0 = esri_layer._json_struct['extent']['xmin']\n                        layer.bbox_y0 = esri_layer._json_struct['extent']['ymin']\n                        layer.bbox_x1 = esri_layer._json_struct['extent']['xmax']\n                        layer.bbox_y1 = esri_layer._json_struct['extent']['ymax']\n                    except Exception:\n                        pass\n                    layer.wkt_geometry = bbox2wktpolygon([layer.bbox_x0, layer.bbox_y0, layer.bbox_x1, layer.bbox_y1])\n                    layer.xml = create_metadata_record(\n                        identifier=str(layer.uuid),\n                        source=service.url,\n                        links=links,\n                        format='ESRI:ArcGIS:MapServer',\n                        type=layer.csw_type,\n                        relation=service.id_string,\n                        title=layer.title,\n                        alternative=layer.title,\n                        abstract=layer.abstract,\n                        wkt_geometry=layer.wkt_geometry\n                    )\n                    layer.anytext = gen_anytext(layer.title, layer.abstract)\n                    layer.save()\n                    # dates\n                    add_mined_dates(layer)\n                layer_n = layer_n + 1\n                # exits if DEBUG_SERVICES\n                LOGGER.debug(\"Updating layer n. %s/%s\" % (layer_n, total))\n                if DEBUG_SERVICES and layer_n == DEBUG_LAYER_NUMBER:\n                    return\n    except Exception as err:\n        message = \"update_layers_esri_mapserver: {0}\".format(\n            err\n        )\n        check = Check(\n            content_object=service,\n            success=False,\n            response_time=0,\n            message=message\n        )\n        check.save()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef update_layers_esri_imageserver(service):\n    try:\n        esri_service = ArcImageService(service.url)\n        # set srs\n        # both mapserver and imageserver exposes just one srs at the service level\n        # not sure if other ones are supported, for now we just store this one\n        obj = json.loads(esri_service._contents)\n        srs_code = obj['spatialReference']['wkid']\n        srs, created = SpatialReferenceSystem.objects.get_or_create(code=srs_code)\n        service.srs.add(srs)\n\n        service.update_validity()\n\n        layer, created = Layer.objects.get_or_create(name=obj['name'], service=service, catalog=service.catalog)\n        if layer.active:\n            layer.type = 'ESRI:ArcGIS:ImageServer'\n            links = [[layer.type, service.url],\n                     ['OGC:WMTS', settings.SITE_URL.rstrip('/') + '/' + layer.get_url_endpoint()]]\n            layer.title = obj['name']\n            layer.abstract = esri_service.serviceDescription\n            layer.url = service.url\n            layer.bbox_x0 = str(obj['extent']['xmin'])\n            layer.bbox_y0 = str(obj['extent']['ymin'])\n            layer.bbox_x1 = str(obj['extent']['xmax'])\n            layer.bbox_y1 = str(obj['extent']['ymax'])\n            layer.page_url = layer.get_absolute_url\n            links.append([\n                'WWW:LINK',\n                settings.SITE_URL.rstrip('/') + layer.page_url\n            ])\n            layer.wkt_geometry = bbox2wktpolygon([layer.bbox_x0, layer.bbox_y0, layer.bbox_x1, layer.bbox_y1])\n            layer.xml = create_metadata_record(\n                identifier=str(layer.uuid),\n                source=service.url,\n                links=links,\n                format='ESRI:ArcGIS:ImageServer',\n                type=layer.csw_type,\n                relation=service.id_string,\n                title=layer.title,\n                alternative=layer.title,\n                abstract=layer.abstract,\n                wkt_geometry=layer.wkt_geometry\n            )\n            layer.anytext = gen_anytext(layer.title, layer.abstract)\n            layer.save()\n            # dates\n            add_mined_dates(layer)\n    except Exception as err:\n        message = \"update_layers_esri_imageserver: {0}\".format(\n            err\n        )\n        check = Check(\n            content_object=service,\n            success=False,\n            response_time=0,\n            message=message\n        )\n        check.save()", "response": "Update layers for an ESRI REST ImageServer."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef endpointlist_post_save(instance, *args, **kwargs):\n    with open(instance.upload.file.name, mode='rb') as f:\n        lines = f.readlines()\n    for url in lines:\n        if len(url) > 255:\n            LOGGER.debug('Skipping this endpoint, as it is more than 255 characters: %s' % url)\n        else:\n            if Endpoint.objects.filter(url=url, catalog=instance.catalog).count() == 0:\n                endpoint = Endpoint(url=url, endpoint_list=instance)\n                endpoint.catalog = instance.catalog\n                endpoint.save()\n    if not settings.REGISTRY_SKIP_CELERY:\n        update_endpoints.delay(instance.id)\n    else:\n        update_endpoints(instance.id)", "response": "Called when the file is saved to the endpoint list."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef service_pre_save(instance, *args, **kwargs):\n\n    # check if service is unique\n    # we cannot use unique_together as it relies on a combination of fields\n    # from different models (service, resource)\n    exists = Service.objects.filter(url=instance.url,\n                                    type=instance.type,\n                                    catalog=instance.catalog).count() > 0\n\n    # TODO: When saving from the django admin, this should not be triggered.\n    # Reference: http://stackoverflow.com/questions/11561722/django-what-is-the-role-of-modelstate\n    if instance._state.adding and exists:\n        raise Exception(\"There is already such a service. url={0} catalog={1}\".format(\n            instance.url, instance.catalog\n        ))", "response": "Check if a service is unique and if not raise an exception"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef service_post_save(instance, *args, **kwargs):\n\n    # check service\n    if instance.is_monitored and settings.REGISTRY_SKIP_CELERY:\n        check_service(instance.id)\n    elif instance.is_monitored:\n        check_service.delay(instance.id)", "response": "Check if the service is full or not."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nchecks validity of a WM layer.", "response": "def layer_pre_save(instance, *args, **kwargs):\n    \"\"\"\n    Used to check layer validity.\n    \"\"\"\n\n    is_valid = True\n\n    # we do not need to check validity for WM layers\n    if not instance.service.type == 'Hypermap:WorldMap':\n\n        # 0. a layer is invalid if its service its invalid as well\n        if not instance.service.is_valid:\n            is_valid = False\n            LOGGER.debug('Layer with id %s is marked invalid because its service is invalid' % instance.id)\n\n        # 1. a layer is invalid with an extent within (-2, -2, +2, +2)\n        if instance.bbox_x0 > -2 and instance.bbox_x1 < 2 and instance.bbox_y0 > -2 and instance.bbox_y1 < 2:\n            is_valid = False\n            LOGGER.debug(\n                'Layer with id %s is marked invalid because its extent is within (-2, -2, +2, +2)' % instance.id\n            )\n\n    instance.is_valid = is_valid"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef layer_post_save(instance, *args, **kwargs):\n    if instance.is_monitored and instance.service.is_monitored:  # index and monitor\n        if not settings.REGISTRY_SKIP_CELERY:\n            check_layer.delay(instance.id)\n        else:\n            check_layer(instance.id)\n    else:  # just index\n        index_layer(instance.id)", "response": "Called when a layer is saved."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nuse to do reindex layers/services when a issue is removed form them.", "response": "def issue_post_delete(instance, *args, **kwargs):\n    \"\"\"\n    Used to do reindex layers/services when a issue is removed form them.\n    \"\"\"\n    LOGGER.debug('Re-adding layer/service to search engine index')\n    if isinstance(instance.content_object, Service):\n        if not settings.REGISTRY_SKIP_CELERY:\n            index_service.delay(instance.content_object.id)\n        else:\n            index_service(instance.content_object.id)\n    else:\n        if not settings.REGISTRY_SKIP_CELERY:\n            index_layer.delay(instance.content_object.id)\n        else:\n            index_layer(instance.content_object.id)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the admin url with the check list for this instance.", "response": "def get_checks_admin_reliability_warning_url(self):\n        \"\"\"\n        When service Realiability is going down users should go to the\n        the check history to find problem causes.\n        :return: admin url with check list for this instance\n        \"\"\"\n        # TODO: cache this.\n        path = self.get_checks_admin_url()\n        content_type = ContentType.objects.get_for_model(self)\n        params = \"?content_type__id__exact={0}&q={1}&success__exact=0\".format(\n            content_type.id,\n            self.id\n        )\n        url = path + params\n        return url"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nupdates layers for a service.", "response": "def update_layers(self):\n        \"\"\"\n        Update layers for a service.\n        \"\"\"\n\n        signals.post_save.disconnect(layer_post_save, sender=Layer)\n\n        try:\n            LOGGER.debug('Updating layers for service id %s' % self.id)\n            if self.type == 'OGC:WMS':\n                update_layers_wms(self)\n            elif self.type == 'OGC:WMTS':\n                update_layers_wmts(self)\n            elif self.type == 'ESRI:ArcGIS:MapServer':\n                update_layers_esri_mapserver(self)\n            elif self.type == 'ESRI:ArcGIS:ImageServer':\n                update_layers_esri_imageserver(self)\n            elif self.type == 'Hypermap:WorldMapLegacy':\n                update_layers_wm_legacy(self)\n            elif self.type == 'Hypermap:WorldMap':\n                update_layers_geonode_wm(self)\n            elif self.type == 'Hypermap:WARPER':\n                update_layers_warper(self)\n\n        except:\n            LOGGER.error('Error updating layers for service %s' % self.uuid)\n\n        signals.post_save.connect(layer_post_save, sender=Layer)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nchecking availability of a service and provide run metrics.", "response": "def check_available(self):\n        \"\"\"\n        Check for availability of a service and provide run metrics.\n        \"\"\"\n        success = True\n        start_time = datetime.datetime.utcnow()\n        message = ''\n\n        LOGGER.debug('Checking service id %s' % self.id)\n\n        try:\n            title = None\n            abstract = None\n            keywords = []\n            wkt_geometry = None\n            srs = '4326'\n            if self.type == 'OGC:CSW':\n                ows = CatalogueServiceWeb(self.url)\n                title = ows.identification.title\n                abstract = ows.identification.abstract\n                keywords = ows.identification.keywords\n            if self.type == 'OGC:WMS':\n                ows = get_wms_version_negotiate(self.url)\n                title = ows.identification.title\n                abstract = ows.identification.abstract\n                keywords = ows.identification.keywords\n                for c in ows.contents:\n                    if ows.contents[c].parent is None:\n                        wkt_geometry = bbox2wktpolygon(ows.contents[c].boundingBoxWGS84)\n                    break\n            if self.type == 'OGC:WMTS':\n                ows = WebMapTileService(self.url)\n                title = ows.identification.title\n                abstract = ows.identification.abstract\n                keywords = ows.identification.keywords\n            if self.type == 'OSGeo:TMS':\n                ows = TileMapService(self.url)\n                title = ows.identification.title\n                abstract = ows.identification.abstract\n                keywords = ows.identification.keywords\n            if self.type == 'ESRI:ArcGIS:MapServer':\n                esri = ArcMapService(self.url)\n                extent, srs = get_esri_extent(esri)\n                title = esri.mapName\n                if len(title) == 0:\n                    title = get_esri_service_name(self.url)\n                wkt_geometry = bbox2wktpolygon([\n                    extent['xmin'],\n                    extent['ymin'],\n                    extent['xmax'],\n                    extent['ymax']\n                ])\n            if self.type == 'ESRI:ArcGIS:ImageServer':\n                esri = ArcImageService(self.url)\n                extent, srs = get_esri_extent(esri)\n                title = esri._json_struct['name']\n                if len(title) == 0:\n                    title = get_esri_service_name(self.url)\n                wkt_geometry = bbox2wktpolygon([\n                    extent['xmin'],\n                    extent['ymin'],\n                    extent['xmax'],\n                    extent['ymax']\n                ])\n            if self.type == 'Hypermap:WorldMap':\n                urllib2.urlopen(self.url)\n            if self.type == 'Hypermap:WorldMapLegacy':\n                urllib2.urlopen(self.url)\n                title = 'Harvard WorldMap Legacy'\n            if self.type == 'Hypermap:WARPER':\n                urllib2.urlopen(self.url)\n            # update title without raising a signal and recursion\n            if title:\n                self.title = title\n                Service.objects.filter(id=self.id).update(title=title)\n            if abstract:\n                self.abstract = abstract\n                Service.objects.filter(id=self.id).update(abstract=abstract)\n            if keywords:\n                for kw in keywords:\n                    # FIXME: persist keywords to Django model\n                    self.keywords.add(kw)\n            if wkt_geometry:\n                self.wkt_geometry = wkt_geometry\n                Service.objects.filter(id=self.id).update(wkt_geometry=wkt_geometry)\n            xml = create_metadata_record(\n                identifier=self.id_string,\n                source=self.url,\n                links=[[self.type, self.url]],\n                format=self.type,\n                type='service',\n                title=title,\n                abstract=abstract,\n                keywords=keywords,\n                wkt_geometry=self.wkt_geometry,\n                srs=srs\n            )\n            anytexts = gen_anytext(title, abstract, keywords)\n            Service.objects.filter(id=self.id).update(anytext=anytexts, xml=xml, csw_type='service')\n        except Exception, e:\n            LOGGER.error(e, exc_info=True)\n            message = str(e)\n            success = False\n\n        end_time = datetime.datetime.utcnow()\n        delta = end_time - start_time\n        response_time = '%s.%s' % (delta.seconds, delta.microseconds)\n\n        check = Check(\n            content_object=self,\n            success=success,\n            response_time=response_time,\n            message=message\n        )\n        check.save()\n        LOGGER.debug('Service checked in %s seconds, status is %s' % (response_time, success))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef update_validity(self):\n\n        # WM is always valid\n        if self.type == 'Hypermap:WorldMap':\n            return\n\n        signals.post_save.disconnect(service_post_save, sender=Service)\n\n        try:\n\n            # some service now must be considered invalid:\n            # 0. any service not exposed in SUPPORTED_SRS\n            # 1. any WMTS service\n            # 2. all of the NOAA layers\n\n            is_valid = True\n\n            # 0. any service not exposed in SUPPORTED_SRS\n            if self.srs.filter(code__in=SUPPORTED_SRS).count() == 0:\n                LOGGER.debug('Service with id %s is marked invalid because in not exposed in SUPPORTED_SRS' % self.id)\n                is_valid = False\n\n            # 1. any WMTS service\n            if self.type == 'OGC:WMTS':\n                LOGGER.debug('Service with id %s is marked invalid because it is of type OGC:WMTS' % self.id)\n                is_valid = False\n\n            # 2. all of the NOAA layers\n            if 'noaa' in self.url.lower():\n                LOGGER.debug('Service with id %s is marked invalid because it is from NOAA' % self.id)\n                is_valid = False\n\n            # now we save the service\n            self.is_valid = is_valid\n            self.save()\n\n        except:\n            LOGGER.error('Error updating validity of the service!')\n\n        signals.post_save.connect(service_post_save, sender=Service)", "response": "Update validity of a service."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nresolves the search url no matter if local or remote", "response": "def get_search_url(self):\n        \"\"\"\n        resolve the search url no matter if local or remote.\n        :return: url or exception\n        \"\"\"\n\n        if self.is_remote:\n            return self.url\n\n        return reverse('search_api', args=[self.slug])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the Hypermap endpoint for a layer.", "response": "def get_url_endpoint(self):\n        \"\"\"\n        Returns the Hypermap endpoint for a layer.\n        This endpoint will be the WMTS MapProxy endpoint, only for WM we use the original endpoint.\n        \"\"\"\n        endpoint = self.url\n        if self.type not in ('Hypermap:WorldMap',):\n            endpoint = 'registry/%s/layer/%s/map/wmts/1.0.0/WMTSCapabilities.xml' % (\n                self.catalog.slug,\n                self.id\n            )\n        return endpoint"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef check_available(self):\n        success = True\n        start_time = datetime.datetime.utcnow()\n        message = ''\n        LOGGER.debug('Checking layer id %s' % self.id)\n\n        signals.post_save.disconnect(layer_post_save, sender=Layer)\n\n        try:\n            self.update_thumbnail()\n        except ValueError, err:\n            # caused by update_thumbnail()\n            # self.href is empty in arcserver.ExportMap\n            if str(err).startswith(\"unknown url type:\"):\n                LOGGER.debug('Thumbnail can not be updated: %s' % str(err))\n        except Exception, err:\n            message = str(err)\n            success = False\n\n        signals.post_save.connect(layer_post_save, sender=Layer)\n\n        end_time = datetime.datetime.utcnow()\n\n        delta = end_time - start_time\n        response_time = '%s.%s' % (delta.seconds, delta.microseconds)\n\n        check = Check(\n            content_object=self,\n            success=success,\n            response_time=response_time,\n            message=message\n        )\n        check.save()\n        LOGGER.debug('Layer checked in %s seconds, status is %s' % (response_time, success))\n        return success, message", "response": "Check availability of a layer and provide run metrics."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef registry_tags(self, query_string='{http://gis.harvard.edu/HHypermap/registry/0.1}property'):\n        from pycsw.core.etree import etree\n\n        parsed = etree.fromstring(self.xml, etree.XMLParser(resolve_entities=False))\n        registry_tags = parsed.findall(query_string)\n\n        registry_dict = {}\n        for tag in registry_tags:\n            try:\n                registry_dict[tag.attrib['name']] = tag.attrib['value']\n            except Exception, e:\n                LOGGER.error(e, exc_info=True)\n\n        return registry_dict", "response": "Get extra metadata tagged with a registry keyword."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _input_github_repo(url=None):\n    if url is None:\n        url = user_input('Input the URL of the GitHub repository '\n                         'to use as a `trytravis` repository: ')\n    url = url.strip()\n    http_match = _HTTPS_REGEX.match(url)\n    ssh_match = _SSH_REGEX.match(url)\n    if not http_match and not ssh_match:\n        raise RuntimeError('That URL doesn\\'t look like a valid '\n                           'GitHub URL. We expect something '\n                           'of the form: `https://github.com/[USERNAME]/'\n                           '[REPOSITORY]` or `ssh://git@github.com/'\n                           '[USERNAME]/[REPOSITORY]')\n\n    # Make sure that the user actually made a new repository on GitHub.\n    if http_match:\n        _, name = http_match.groups()\n    else:\n        _, name = ssh_match.groups()\n    if 'trytravis' not in name:\n        raise RuntimeError('You must have `trytravis` in the name of your '\n                           'repository. This is a security feature to reduce '\n                           'chances of running git push -f on a repository '\n                           'you don\\'t mean to.')\n\n    # Make sure that the user actually wants to use this repository.\n    accept = user_input('Remember that `trytravis` will make commits on your '\n                        'behalf to `%s`. Are you sure you wish to use this '\n                        'repository? Type `y` or `yes` to accept: ' % url)\n    if accept.lower() not in ['y', 'yes']:\n        raise RuntimeError('Operation aborted by user.')\n\n    if not os.path.isdir(config_dir):\n        os.makedirs(config_dir)\n    with open(os.path.join(config_dir, 'repo'), 'w+') as f:\n        f.truncate()\n        f.write(url)\n    print('Repository saved successfully.')", "response": "Grabs input from the user and saves it as their trytravis target repo."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _load_github_repo():\n    if 'TRAVIS' in os.environ:\n        raise RuntimeError('Detected that we are running in Travis. '\n                           'Stopping to prevent infinite loops.')\n    try:\n        with open(os.path.join(config_dir, 'repo'), 'r') as f:\n            return f.read()\n    except (OSError, IOError):\n        raise RuntimeError('Could not find your repository. '\n                           'Have you ran `trytravis --repo`?')", "response": "Load the GitHub repository from the user s config directory."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncommits local changes and submits them to the GitHub repository.", "response": "def _submit_changes_to_github_repo(path, url):\n    \"\"\" Temporarily commits local changes and submits them to\n    the GitHub repository that the user has specified. Then\n    reverts the changes to the git repository if a commit was\n    necessary. \"\"\"\n    try:\n        repo = git.Repo(path)\n    except Exception:\n        raise RuntimeError('Couldn\\'t locate a repository at `%s`.' % path)\n    commited = False\n    try:\n        try:\n            repo.delete_remote('trytravis')\n        except Exception:\n            pass\n        print('Adding a temporary remote to '\n              '`%s`...' % url)\n        remote = repo.create_remote('trytravis', url)\n\n        print('Adding all local changes...')\n        repo.git.add('--all')\n        try:\n            print('Committing local changes...')\n            timestamp = datetime.datetime.now().isoformat()\n            repo.git.commit(m='trytravis-' + timestamp)\n            commited = True\n        except git.exc.GitCommandError as e:\n            if 'nothing to commit' in str(e):\n                commited = False\n            else:\n                raise\n        commit = repo.head.commit.hexsha\n        committed_at = repo.head.commit.committed_datetime\n\n        print('Pushing to `trytravis` remote...')\n        remote.push(force=True)\n    finally:\n        if commited:\n            print('Reverting to old state...')\n            repo.git.reset('HEAD^')\n        try:\n            repo.delete_remote('trytravis')\n        except Exception:\n            pass\n    return commit, committed_at"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _wait_for_travis_build(url, commit, committed_at):\n    print('Waiting for a Travis build to appear '\n          'for `%s` after `%s`...' % (commit, committed_at))\n    import requests\n\n    slug = _slug_from_url(url)\n    start_time = time.time()\n    build_id = None\n\n    while time.time() - start_time < 60:\n        with requests.get('https://api.travis-ci.org/repos/%s/builds' % slug,\n                          headers=_travis_headers()) as r:\n            if not r.ok:\n                raise RuntimeError('Could not reach the Travis API '\n                                   'endpoint. Additional information: '\n                                   '%s' % str(r.content))\n\n            # Search through all commits and builds to find our build.\n            commit_to_sha = {}\n            json = r.json()\n            for travis_commit in sorted(json['commits'],\n                                        key=lambda x: x['committed_at']):\n                travis_committed_at = datetime.datetime.strptime(\n                    travis_commit['committed_at'], '%Y-%m-%dT%H:%M:%SZ'\n                ).replace(tzinfo=utc)\n                if travis_committed_at < committed_at:\n                    continue\n                commit_to_sha[travis_commit['id']] = travis_commit['sha']\n\n            for build in json['builds']:\n                if (build['commit_id'] in commit_to_sha and\n                        commit_to_sha[build['commit_id']] == commit):\n\n                    build_id = build['id']\n                    print('Travis build id: `%d`' % build_id)\n                    print('Travis build URL: `https://travis-ci.org/'\n                          '%s/builds/%d`' % (slug, build_id))\n\n            if build_id is not None:\n                break\n\n        time.sleep(3.0)\n    else:\n        raise RuntimeError('Timed out while waiting for a Travis build '\n                           'to start. Is Travis configured for `%s`?' % url)\n    return build_id", "response": "Waits for a Travis build to appear with the given commit SHA."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _watch_travis_build(build_id):\n    import requests\n    try:\n        build_size = None  # type: int\n        running = True\n        while running:\n            with requests.get('https://api.travis-ci.org/builds/%d' % build_id,\n                              headers=_travis_headers()) as r:\n                json = r.json()\n\n                if build_size is not None:\n                    if build_size > 1:\n                        sys.stdout.write('\\r\\x1b[%dA' % build_size)\n                    else:\n                        sys.stdout.write('\\r')\n\n                build_size = len(json['jobs'])\n                running = False\n                current_number = 1\n                for job in json['jobs']:  # pragma: no coverage\n                    color, state, is_running = _travis_job_state(job['state'])\n                    if is_running:\n                        running = True\n\n                    platform = job['config']['os']\n                    if platform == 'osx':\n                        platform = ' osx '\n\n                    env = job['config'].get('env', '')\n                    sudo = 's' if job['config'].get('sudo', True) else 'c'\n                    lang = job['config'].get('language', 'generic')\n\n                    padding = ' ' * (len(str(build_size)) -\n                                     len(str(current_number)))\n                    number = str(current_number) + padding\n                    current_number += 1\n                    job_display = '#' + ' '.join([number,\n                                                  state,\n                                                  platform,\n                                                  sudo,\n                                                  lang,\n                                                  env])\n\n                    print(color + job_display + colorama.Style.RESET_ALL)\n\n            time.sleep(3.0)\n    except KeyboardInterrupt:\n        pass", "response": "Watches and progressively outputs information about a Travis build"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _travis_job_state(state):\n    if state in [None, 'queued', 'created', 'received']:\n        return colorama.Fore.YELLOW, '*', True\n    elif state in ['started', 'running']:\n        return colorama.Fore.LIGHTYELLOW_EX, '*', True\n    elif state == 'passed':\n        return colorama.Fore.LIGHTGREEN_EX, 'P', False\n    elif state == 'failed':\n        return colorama.Fore.LIGHTRED_EX, 'X', False\n    elif state == 'errored':\n        return colorama.Fore.LIGHTRED_EX, '!', False\n    elif state == 'canceled':\n        return colorama.Fore.LIGHTBLACK_EX, 'X', False\n    else:\n        raise RuntimeError('unknown state: %s' % str(state))", "response": "Converts a Travis state into a state character color and boolean value."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _slug_from_url(url):\n    http_match = _HTTPS_REGEX.match(url)\n    ssh_match = _SSH_REGEX.match(url)\n    if not http_match and not ssh_match:\n        raise RuntimeError('Could not parse the URL (`%s`) '\n                           'for your repository.' % url)\n    if http_match:\n        return '/'.join(http_match.groups())\n    else:\n        return '/'.join(ssh_match.groups())", "response": "Parses a project slug out of either an HTTPS or SSH URL."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the output for trytravis - version.", "response": "def _version_string():\n    \"\"\" Gets the output for `trytravis --version`. \"\"\"\n    platform_system = platform.system()\n    if platform_system == 'Linux':\n        os_name, os_version, _ = platform.dist()\n    else:\n        os_name = platform_system\n        os_version = platform.version()\n    python_version = platform.python_version()\n    return 'trytravis %s (%s %s, python %s)' % (__version__,\n                                                os_name.lower(),\n                                                os_version,\n                                                python_version)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nfunctioning that acts just like main except does not catch exceptions.", "response": "def _main(argv):\n    \"\"\" Function that acts just like main() except\n    doesn't catch exceptions. \"\"\"\n    repo_input_argv = len(argv) == 2 and argv[0] in ['--repo', '-r', '-R']\n\n    # We only support a single argv parameter.\n    if len(argv) > 1 and not repo_input_argv:\n        _main(['--help'])\n\n    # Parse the command and do the right thing.\n    if len(argv) == 1 or repo_input_argv:\n        arg = argv[0]\n\n        # Help/usage\n        if arg in ['-h', '--help', '-H']:\n            print(_USAGE)\n\n        # Version\n        elif arg in ['-v', '--version', '-V']:\n            print(_version_string())\n\n        # Token\n        elif arg in ['-r', '--repo', '-R']:\n            if len(argv) == 2:\n                url = argv[1]\n            else:\n                url = None\n            _input_github_repo(url)\n\n        # No wait\n        elif arg in ['--no-wait', '-nw']:\n            url = _load_github_repo()\n            commit, committed = _submit_changes_to_github_repo(os.getcwd(),\n                                                               url)\n            build_id = _wait_for_travis_build(url, commit, committed)\n\n        # Help string\n        else:\n            _main(['--help'])\n\n    # No arguments means we're trying to submit to Travis.\n    elif len(argv) == 0:\n        url = _load_github_repo()\n        commit, committed = _submit_changes_to_github_repo(os.getcwd(), url)\n        build_id = _wait_for_travis_build(url, commit, committed)\n        _watch_travis_build(build_id)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef main(argv=None):  # pragma: no coverage\n    try:\n        colorama.init()\n        if argv is None:\n            argv = sys.argv[1:]\n        _main(argv)\n    except RuntimeError as e:\n        print(colorama.Fore.RED + 'ERROR: ' +\n              str(e) + colorama.Style.RESET_ALL)\n        sys.exit(1)\n    else:\n        sys.exit(0)", "response": "Entry point when the user runs the trytravis command."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ndispatching the request to the global CSW", "response": "def csw_global_dispatch(request, url=None, catalog_id=None):\n    \"\"\"pycsw wrapper\"\"\"\n\n    if request.user.is_authenticated():  # turn on CSW-T\n        settings.REGISTRY_PYCSW['manager']['transactions'] = 'true'\n\n    env = request.META.copy()\n\n    # TODO: remove this workaround\n    # HH should be able to pass env['wsgi.input'] without hanging\n    # details at https://github.com/cga-harvard/HHypermap/issues/94\n    if request.method == 'POST':\n        from StringIO import StringIO\n        env['wsgi.input'] = StringIO(request.body)\n\n    env.update({'local.app_root': os.path.dirname(__file__),\n                'REQUEST_URI': request.build_absolute_uri()})\n\n    # if this is a catalog based CSW, then update settings\n    if url is not None:\n        settings.REGISTRY_PYCSW['server']['url'] = url\n    if catalog_id is not None:\n        settings.REGISTRY_PYCSW['repository']['filter'] = 'catalog_id = %d' % catalog_id\n\n    csw = server.Csw(settings.REGISTRY_PYCSW, env)\n\n    content = csw.dispatch_wsgi()\n\n    # pycsw 2.0 has an API break:\n    # pycsw < 2.0: content = xml_response\n    # pycsw >= 2.0: content = [http_status_code, content]\n    # deal with the API break\n\n    if isinstance(content, list):  # pycsw 2.0+\n        content = content[1]\n\n    response = HttpResponse(content, content_type=csw.contenttype)\n\n    # TODO: Fix before 1.0 release. CORS should not be enabled blindly like this.\n    response['Access-Control-Allow-Origin'] = '*'\n    return response"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef csw_global_dispatch_by_catalog(request, catalog_slug):\n\n    catalog = get_object_or_404(Catalog, slug=catalog_slug)\n\n    if catalog:  # define catalog specific settings\n        url = settings.SITE_URL.rstrip('/') + request.path.rstrip('/')\n        return csw_global_dispatch(request, url=url, catalog_id=catalog.id)", "response": "pycsw wrapper for catalogs"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef opensearch_dispatch(request):\n\n    ctx = {\n        'shortname': settings.REGISTRY_PYCSW['metadata:main']['identification_title'],\n        'description': settings.REGISTRY_PYCSW['metadata:main']['identification_abstract'],\n        'developer': settings.REGISTRY_PYCSW['metadata:main']['contact_name'],\n        'contact': settings.REGISTRY_PYCSW['metadata:main']['contact_email'],\n        'attribution': settings.REGISTRY_PYCSW['metadata:main']['provider_name'],\n        'tags': settings.REGISTRY_PYCSW['metadata:main']['identification_keywords'].replace(',', ' '),\n        'url': settings.SITE_URL.rstrip('/')\n    }\n\n    return render_to_response('search/opensearch_description.xml', ctx,\n                              content_type='application/opensearchdescription+xml')", "response": "Dispatches the request to the OpenSearch description."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef good_coords(coords):\n        if (len(coords) != 4):\n            return False\n        for coord in coords[0:3]:\n            try:\n                num = float(coord)\n                if (math.isnan(num)):\n                    return False\n                if (math.isinf(num)):\n                    return False\n            except ValueError:\n                return False\n        return True", "response": "check if a list of coordinates is good"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nclears all indexes in the elasticsearch core", "response": "def clear_es():\n        \"\"\"Clear all indexes in the es core\"\"\"\n        # TODO: should receive a catalog slug.\n        ESHypermap.es.indices.delete(ESHypermap.index_name, ignore=[400, 404])\n        LOGGER.debug('Elasticsearch: Index cleared')"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef create_indices(catalog_slug):\n        # TODO: enable auto_create_index in the ES nodes to make this implicit.\n        # https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-index_.html#index-creation\n        # http://support.searchly.com/customer/en/portal/questions/\n        # 16312889-is-automatic-index-creation-disabled-?new=16312889\n        mapping = {\n            \"mappings\": {\n                \"layer\": {\n                    \"properties\": {\n                        \"layer_geoshape\": {\n                           \"type\": \"geo_shape\",\n                           \"tree\": \"quadtree\",\n                           \"precision\": REGISTRY_MAPPING_PRECISION\n                        }\n                    }\n                }\n            }\n        }\n        ESHypermap.es.indices.create(catalog_slug, ignore=[400, 404], body=mapping)", "response": "Create ES core indices"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nkills WSGI processes that may be running in development", "response": "def kill_process(procname, scriptname):\n    \"\"\"kill WSGI processes that may be running in development\"\"\"\n\n    # from http://stackoverflow.com/a/2940878\n    import signal\n    import subprocess\n\n    p = subprocess.Popen(['ps', 'aux'], stdout=subprocess.PIPE)\n    out, err = p.communicate()\n\n    for line in out.decode().splitlines():\n        if procname in line and scriptname in line:\n            pid = int(line.split()[1])\n            info('Stopping %s %s %d' % (procname, scriptname, pid))\n            os.kill(pid, signal.SIGKILL)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef populate_initial_services():\n    services_list = (\n        (\n            'Harvard WorldMap',\n            'Harvard WorldMap open source web geospatial platform',\n            'Hypermap:WorldMap',\n            'http://worldmap.harvard.edu'\n        ),\n        (\n            'NYPL MapWarper',\n            'The New York Public Library (NYPL) MapWarper web site',\n            'Hypermap:WARPER',\n            'http://maps.nypl.org/warper/maps'\n        ),\n        (\n            'Map Warper',\n            'The MapWarper web site developed, hosted and maintained by Tim Waters',\n            'Hypermap:WARPER',\n            'http://mapwarper.net/maps'\n        ),\n        (\n            'WorldMap Warp',\n            'The MapWarper instance part of the Harvard WorldMap project',\n            'Hypermap:WARPER',\n            'http://warp.worldmap.harvard.edu/maps'\n        ),\n        (\n            'WFP GeoNode',\n            'World Food Programme GeoNode',\n            'OGC:WMS',\n            'http://geonode.wfp.org/geoserver/ows?'\n        ),\n        (\n            'NASA EARTHDATA',\n            'NASA EARTHDATA, powered by EOSDIS',\n            'OGC:WMTS',\n            'http://map1.vis.earthdata.nasa.gov/wmts-geo/1.0.0/WMTSCapabilities.xml'\n        ),\n    )\n\n    esri_endpoint = 'https://gis.ngdc.noaa.gov/arcgis/rest/services'\n    LOGGER.debug('*** Importing esri endpoint: %s' % esri_endpoint)\n    create_services_from_endpoint(esri_endpoint)\n\n    for service in services_list:\n        LOGGER.debug('*** Importing %s' % service[0])\n        service = Service(\n            title=service[0],\n            abstract=service[1],\n            type=service[2],\n            url=service[3]\n        )\n        service.save()", "response": "Populate a fresh set of installed services with basic services."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef elasticsearch(serializer, catalog):\n\n    search_engine_endpoint = \"{0}/{1}/_search\".format(SEARCH_URL, catalog.slug)\n\n    q_text = serializer.validated_data.get(\"q_text\")\n    q_time = serializer.validated_data.get(\"q_time\")\n    q_geo = serializer.validated_data.get(\"q_geo\")\n    q_user = serializer.validated_data.get(\"q_user\")\n    d_docs_sort = serializer.validated_data.get(\"d_docs_sort\")\n    d_docs_limit = int(serializer.validated_data.get(\"d_docs_limit\"))\n    d_docs_page = int(serializer.validated_data.get(\"d_docs_page\"))\n    a_text_limit = serializer.validated_data.get(\"a_text_limit\")\n    a_user_limit = serializer.validated_data.get(\"a_user_limit\")\n    a_time_gap = serializer.validated_data.get(\"a_time_gap\")\n    a_time_limit = serializer.validated_data.get(\"a_time_limit\")\n    original_response = serializer.validated_data.get(\"original_response\")\n\n    # Dict for search on Elastic engine\n    must_array = []\n    filter_dic = {}\n    aggs_dic = {}\n\n    # get ES version to make the query builder to be backward compatible with\n    # diffs versions.\n    # TODO: move this to a proper place. maybe ES client?.\n    # TODO: cache it to avoid overwhelm ES with this call.\n    # TODO: ask for ES_VERSION when building queries with an elegant way.\n    ES_VERSION = 2\n    response = requests.get(SEARCH_URL)\n    if response.ok:\n        # looks ugly but will work on normal ES response for \"/\".\n        ES_VERSION = int(response.json()[\"version\"][\"number\"][0])\n\n    # String searching\n    if q_text:\n        # Wrapping query string into a query filter.\n\n        if ES_VERSION >= 2:\n            query_string = {\n                \"query_string\": {\n                    \"query\": q_text\n                }\n            }\n        else:\n            query_string = {\n                \"query\": {\n                    \"query_string\": {\n                        \"query\": q_text\n                    }\n                }\n            }\n\n        # add string searching\n        must_array.append(query_string)\n\n    if q_time:\n        # check if q_time exists\n        q_time = str(q_time)  # check string\n        shortener = q_time[1:-1]\n        shortener = shortener.split(\" TO \")\n        gte = shortener[0]  # greater than\n        lte = shortener[1]  # less than\n        layer_date = {}\n        if gte == '*' and lte != '*':\n            layer_date[\"lte\"] = lte\n            range_time = {\n                \"layer_date\": layer_date\n            }\n            range_time = {\"range\": range_time}\n            must_array.append(range_time)\n        if gte != '*' and lte == '*':\n            layer_date[\"gte\"] = gte\n            range_time = {\n                \"layer_date\": layer_date\n            }\n            range_time = {\"range\": range_time}\n            must_array.append(range_time)\n        if gte != '*' and lte != '*':\n            layer_date[\"gte\"] = gte\n            layer_date[\"lte\"] = lte\n            range_time = {\n                \"layer_date\": layer_date\n            }\n            range_time = {\"range\": range_time}\n            must_array.append(range_time)\n    # geo_shape searching\n    if q_geo:\n        q_geo = str(q_geo)\n        q_geo = q_geo[1:-1]\n        Ymin, Xmin = q_geo.split(\" TO \")[0].split(\",\")\n        Ymax, Xmax = q_geo.split(\" TO \")[1].split(\",\")\n        geoshape_query = {\n            \"layer_geoshape\": {\n                \"shape\": {\n                    \"type\": \"envelope\",\n                    \"coordinates\": [[Xmin, Ymax], [Xmax, Ymin]]\n                },\n                \"relation\": \"intersects\"\n            }\n        }\n        filter_dic[\"geo_shape\"] = geoshape_query\n\n    if q_user:\n        # Using q_user\n        user_searching = {\n            \"match\": {\n                \"layer_originator\": q_user\n            }\n        }\n        must_array.append(user_searching)\n\n    if ES_VERSION >= 2:\n        dic_query = {\n            \"query\": {\n                \"bool\": {\n                    \"must\": must_array,\n                    \"filter\": filter_dic\n                }\n            }\n        }\n    else:\n        dic_query = {\n            \"query\": {\n                \"filtered\": {\n                    \"filter\": {\n                        \"bool\": {\n                            \"must\": must_array,\n                            \"should\": filter_dic\n                        }\n                    }\n                }\n            }\n        }\n\n    # Page\n    if d_docs_limit:\n        dic_query[\"size\"] = d_docs_limit\n\n    if d_docs_page:\n        dic_query[\"from\"] = d_docs_limit * d_docs_page - d_docs_limit\n\n    if d_docs_sort == \"score\":\n        dic_query[\"sort\"] = {\"_score\": {\"order\": \"desc\"}}\n\n    if d_docs_sort == \"time\":\n        dic_query[\"sort\"] = {\"layer_date\": {\"order\": \"desc\"}}\n\n    if d_docs_sort == \"distance\":\n        if q_geo:\n            # distance_x = float(((float(Xmin) - float(Xmax)) ** 2.0) ** (0.5))\n            # distance_y = float(((float(Ymin) - float(Ymax)) ** 2.0) ** (0.5))\n            msg = (\"Sorting by distance is different on ElasticSearch than Solr, because this\"\n                   \"feature on elastic is unavailable to geo_shape type.ElasticSearch docs said:\"\n                   \"Due to the complex input structure and index representation of shapes,\"\n                   \"it is not currently possible to sort shapes or retrieve their fields directly.\"\n                   \"The geo_shape value is only retrievable through the _source field.\"\n                   \" Link: https://www.elastic.co/guide/en/elasticsearch/reference/current/geo-shape.html\")\n            return {\"error\": {\"msg\": msg}}\n\n        else:\n            msg = \"q_qeo MUST BE NO ZERO if you wanna sort by distance\"\n            return {\"error\": {\"msg\": msg}}\n\n    if a_text_limit:\n        # getting most frequently occurring users.\n        text_limit = {\n            \"terms\": {\n                \"field\": \"abstract\",\n                \"size\": a_text_limit\n            }\n        }\n        aggs_dic['popular_text'] = text_limit\n\n    if a_user_limit:\n        # getting most frequently occurring users.\n        users_limit = {\n\n            \"terms\": {\n                \"field\": \"layer_originator\",\n                \"size\": a_user_limit\n            }\n        }\n        aggs_dic['popular_users'] = users_limit\n\n    if a_time_limit:\n        # TODO: Work in progress, a_time_limit is incomplete.\n        # TODO: when times are * it does not work. also a a_time_gap is not required.\n        if q_time:\n            if not a_time_gap:\n                # getting time limit histogram.\n                time_limt = {\n                    \"date_range\": {\n                        \"field\": \"layer_date\",\n                        \"format\": \"yyyy-MM-dd'T'HH:mm:ssZ\",\n                        \"ranges\": [\n                            {\"from\": gte, \"to\": lte}\n                        ]\n                    }\n                }\n                aggs_dic['range'] = time_limt\n            else:\n                pass\n\n        else:\n            msg = \"If you want to use a_time_limit feature, q_time MUST BE initialized\"\n            return {\"error\": {\"msg\": msg}}\n\n    if a_time_gap:\n        interval = gap_to_elastic(a_time_gap)\n        time_gap = {\n            \"date_histogram\": {\n                \"field\": \"layer_date\",\n                \"format\": \"yyyy-MM-dd'T'HH:mm:ssZ\",\n                \"interval\": interval\n            }\n        }\n        aggs_dic['articles_over_time'] = time_gap\n\n    # adding aggreations on body query\n    if aggs_dic:\n        dic_query['aggs'] = aggs_dic\n    try:\n        res = requests.post(search_engine_endpoint, data=json.dumps(dic_query))\n    except Exception as e:\n        return 500, {\"error\": {\"msg\": str(e)}}\n\n    es_response = res.json()\n\n    if original_response:\n        return es_response\n\n    data = {}\n\n    if 'error' in es_response:\n        data[\"error\"] = es_response[\"error\"]\n        return 400, data\n\n    data[\"request_url\"] = res.url\n    data[\"request_body\"] = json.dumps(dic_query)\n    data[\"a.matchDocs\"] = es_response['hits']['total']\n    docs = []\n    # aggreations response: facets searching\n    if 'aggregations' in es_response:\n        aggs = es_response['aggregations']\n        # getting the most frequently occurring users.\n        if 'popular_users' in aggs:\n            a_users_list_array = []\n            users_resp = aggs[\"popular_users\"][\"buckets\"]\n            for item in users_resp:\n                temp = {}\n                temp['count'] = item['doc_count']\n                temp['value'] = item['key']\n                a_users_list_array.append(temp)\n            data[\"a.user\"] = a_users_list_array\n\n        # getting most frequently ocurring words\n        if 'popular_text' in aggs:\n            a_text_list_array = []\n            text_resp = es_response[\"aggregations\"][\"popular_text\"][\"buckets\"]\n            for item in text_resp:\n                temp = {}\n                temp['count'] = item['doc_count']\n                temp['value'] = item['key']\n                a_text_list_array.append(temp)\n            data[\"a.text\"] = a_text_list_array\n\n        if 'articles_over_time' in aggs:\n            gap_count = []\n            a_gap = {}\n            gap_resp = aggs[\"articles_over_time\"][\"buckets\"]\n\n            start = \"*\"\n            end = \"*\"\n\n            if len(gap_resp) > 0:\n                start = gap_resp[0]['key_as_string'].replace('+0000', 'z')\n                end = gap_resp[-1]['key_as_string'].replace('+0000', 'z')\n\n            a_gap['start'] = start\n            a_gap['end'] = end\n            a_gap['gap'] = a_time_gap\n\n            for item in gap_resp:\n                temp = {}\n                if item['doc_count'] != 0:\n                    temp['count'] = item['doc_count']\n                    temp['value'] = item['key_as_string'].replace('+0000', 'z')\n                    gap_count.append(temp)\n            a_gap['counts'] = gap_count\n            data['a.time'] = a_gap\n\n        if 'range' in aggs:\n            # Work in progress\n            # Pay attention in the following code lines: Make it better!!!!\n            time_count = []\n            time_resp = aggs[\"range\"][\"buckets\"]\n            a_time = {}\n            a_time['start'] = gte\n            a_time['end'] = lte\n            a_time['gap'] = None\n\n            for item in time_resp:\n                temp = {}\n                if item['doc_count'] != 0:\n                    temp['count'] = item['doc_count']\n                    temp['value'] = item['key'].replace('+0000', 'z')\n                    time_count.append(temp)\n            a_time['counts'] = time_count\n            data['a.time'] = a_time\n\n    if not int(d_docs_limit) == 0:\n        for item in es_response['hits']['hits']:\n            # data\n            temp = item['_source']['abstract']\n            temp = temp.replace(u'\\u201c', \"\\\"\")\n            temp = temp.replace(u'\\u201d', \"\\\"\")\n            temp = temp.replace('\"', \"\\\"\")\n            temp = temp.replace(\"'\", \"\\'\")\n            temp = temp.replace(u'\\u2019', \"\\'\")\n            item['_source']['abstract'] = temp\n            docs.append(item['_source'])\n\n    data[\"d.docs\"] = docs\n\n    return data", "response": "https://www.elastic.co/guide/en/elasticsearch/reference/current/_the_search_api.html\n    :param serializer:\n    :return:"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsearching on solr endpoint", "response": "def solr(serializer):\n    \"\"\"\n    Search on solr endpoint\n    :param serializer:\n    :return:\n    \"\"\"\n    search_engine_endpoint = serializer.validated_data.get(\"search_engine_endpoint\")\n    q_time = serializer.validated_data.get(\"q_time\")\n    q_geo = serializer.validated_data.get(\"q_geo\")\n    q_text = serializer.validated_data.get(\"q_text\")\n    q_user = serializer.validated_data.get(\"q_user\")\n    d_docs_limit = serializer.validated_data.get(\"d_docs_limit\")\n    d_docs_page = serializer.validated_data.get(\"d_docs_page\")\n    d_docs_sort = serializer.validated_data.get(\"d_docs_sort\")\n    a_time_limit = serializer.validated_data.get(\"a_time_limit\")\n    a_time_gap = serializer.validated_data.get(\"a_time_gap\")\n    a_time_filter = serializer.validated_data.get(\"a_time_filter\")\n    a_hm_limit = serializer.validated_data.get(\"a_hm_limit\")\n    a_hm_gridlevel = serializer.validated_data.get(\"a_hm_gridlevel\")\n    a_hm_filter = serializer.validated_data.get(\"a_hm_filter\")\n    a_text_limit = serializer.validated_data.get(\"a_text_limit\")\n    a_user_limit = serializer.validated_data.get(\"a_user_limit\")\n    original_response = serializer.validated_data.get(\"original_response\")\n\n    # query params to be sent via restful solr\n    params = {\n        \"q\": \"*:*\",\n        \"indent\": \"on\",\n        \"wt\": \"json\",\n        \"rows\": d_docs_limit,\n        \"facet\": \"off\",\n        \"facet.field\": [],\n        \"debug\": \"timing\"\n    }\n    if q_text:\n        params[\"q\"] = q_text\n\n    if d_docs_limit >= 0:\n        d_docs_page -= 1\n        d_docs_page = d_docs_limit * d_docs_page\n        params[\"start\"] = d_docs_page\n\n    # query params for filters\n    filters = []\n    if q_time:\n        # TODO: when user sends incomplete dates like 2000, its completed: 2000-(TODAY-MONTH)-(TODAY-DAY)T00:00:00Z\n        # TODO: \"Invalid Date in Date Math String:'[* TO 2000-12-05T00:00:00Z]'\"\n        # Kotlin like: \"{!field f=layer_date tag=layer_date}[* TO 2000-12-05T00:00:00Z]\"\n        # then do it simple:\n        filters.append(\"{0}:{1}\".format(TIME_FILTER_FIELD, q_time))\n    if q_geo:\n        filters.append(\"{0}:{1}\".format(GEO_FILTER_FIELD, q_geo))\n\n    if q_user:\n        filters.append(\"{{!field f={0} tag={0}}}{1}\".format(USER_FIELD, q_user))\n\n    if filters:\n        params[\"fq\"] = filters\n\n    # query params for ordering\n    if d_docs_sort == 'score' and q_text:\n        params[\"sort\"] = 'score desc'\n    elif d_docs_sort == 'time':\n        params[\"sort\"] = '{} desc'.format(TIME_SORT_FIELD)\n    elif d_docs_sort == 'distance':\n        rectangle = parse_geo_box(q_geo)\n        params[\"sort\"] = 'geodist() asc'\n        params[\"sfield\"] = GEO_SORT_FIELD\n        params[\"pt\"] = '{0},{1}'.format(rectangle.centroid.x, rectangle.centroid.y)\n\n    # query params for facets\n    if a_time_limit > 0:\n        params[\"facet\"] = 'on'\n        time_filter = a_time_filter or q_time or None\n\n        # traduce * to actual min/max dates.\n        time_filter = asterisk_to_min_max(TIME_FILTER_FIELD, time_filter, search_engine_endpoint)\n\n        # create the range faceting params.\n        facet_parms = request_time_facet(TIME_FILTER_FIELD, time_filter, a_time_gap, a_time_limit)\n        params.update(facet_parms)\n\n    if a_hm_limit > 0:\n        params[\"facet\"] = 'on'\n        hm_facet_params = request_heatmap_facet(GEO_HEATMAP_FIELD, a_hm_filter, a_hm_gridlevel, a_hm_limit)\n        params.update(hm_facet_params)\n\n    if a_text_limit > 0:\n        params[\"facet\"] = 'on'\n        params[\"facet.field\"].append(TEXT_FIELD)\n        params[\"f.{}.facet.limit\".format(TEXT_FIELD)] = a_text_limit\n\n    if a_user_limit > 0:\n        params[\"facet\"] = 'on'\n        params[\"facet.field\"].append(\"{{! ex={0}}}{0}\".format(USER_FIELD))\n        params[\"f.{}.facet.limit\".format(USER_FIELD)] = a_user_limit\n\n    try:\n        res = requests.get(\n            search_engine_endpoint, params=params\n        )\n    except Exception as e:\n        return 500, {\"error\": {\"msg\": str(e)}}\n\n    print '>', res.url\n\n    solr_response = res.json()\n    solr_response[\"solr_request\"] = res.url\n\n    if original_response > 0:\n        return solr_response\n\n    # create the response dict following the swagger model:\n    data = {}\n\n    if 'error' in solr_response:\n        data[\"error\"] = solr_response[\"error\"]\n        return 400, data\n\n    response = solr_response[\"response\"]\n    data[\"a.matchDocs\"] = response.get(\"numFound\")\n\n    if response.get(\"docs\"):\n        data[\"d.docs\"] = response.get(\"docs\")\n\n    if a_time_limit > 0:\n        date_facet = solr_response[\"facet_counts\"][\"facet_ranges\"][TIME_FILTER_FIELD]\n        counts = []\n        value_count = iter(date_facet.get(\"counts\"))\n        for value, count in zip(value_count, value_count):\n            counts.append({\n                \"value\": value,\n                \"count\": count\n            })\n        a_time = {\n            \"start\": date_facet.get(\"start\"),\n            \"end\": date_facet.get(\"end\"),\n            \"gap\": date_facet.get(\"gap\"),\n            \"counts\": counts\n        }\n        data[\"a.time\"] = a_time\n\n    if a_hm_limit > 0:\n        hm_facet_raw = solr_response[\"facet_counts\"][\"facet_heatmaps\"][GEO_HEATMAP_FIELD]\n        hm_facet = {\n            'gridLevel': hm_facet_raw[1],\n            'columns': hm_facet_raw[3],\n            'rows': hm_facet_raw[5],\n            'minX': hm_facet_raw[7],\n            'maxX': hm_facet_raw[9],\n            'minY': hm_facet_raw[11],\n            'maxY': hm_facet_raw[13],\n            'counts_ints2D': hm_facet_raw[15],\n            'projection': 'EPSG:4326'\n        }\n        data[\"a.hm\"] = hm_facet\n\n    if a_user_limit > 0:\n        user_facet = solr_response[\"facet_counts\"][\"facet_fields\"][USER_FIELD]\n\n        counts = []\n        value_count = iter(user_facet)\n        for value, count in zip(value_count, value_count):\n            counts.append({\n                \"value\": value,\n                \"count\": count\n            })\n        data[\"a.user\"] = counts\n\n    if a_text_limit > 0:\n        text_facet = solr_response[\"facet_counts\"][\"facet_fields\"][TEXT_FIELD]\n\n        counts = []\n        value_count = iter(text_facet)\n        for value, count in zip(value_count, value_count):\n            counts.append({\n                \"value\": value,\n                \"count\": count\n            })\n        data[\"a.text\"] = counts\n\n    subs = []\n    for label, values in solr_response[\"debug\"][\"timing\"].iteritems():\n        if type(values) is not dict:\n            continue\n        subs_data = {\"label\": label, \"subs\": []}\n        for label, values in values.iteritems():\n            if type(values) is not dict:\n                subs_data[\"millis\"] = values\n                continue\n            subs_data[\"subs\"].append({\n                \"label\": label,\n                \"millis\": values.get(\"time\")\n            })\n        subs.append(subs_data)\n\n    timing = {\n        \"label\": \"requests.get.elapsed\",\n        \"millis\": res.elapsed,\n        \"subs\": [{\n            \"label\": \"QTime\",\n            \"millis\": solr_response[\"responseHeader\"].get(\"QTime\"),\n            \"subs\": subs\n        }]\n    }\n\n    data[\"timing\"] = timing\n    data[\"request_url\"] = res.url\n\n    return data"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef parse_get_params(request):\n\n    get = request.GET.copy()\n    new_get = request.GET.copy()\n    for key in get.iterkeys():\n        if key.count(\".\") > 0:\n            new_key = key.replace(\".\", \"_\")\n            new_get[new_key] = get.get(key)\n            del new_get[key]\n\n    return new_get", "response": "parse all url get params that contains dots in a representation of\n    serializer field names for example d. docs. limit to d_docs_limit."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef main():\n    tcp_adapter = TcpAdapter(\"192.168.1.3\", name=\"HASS\", activate_source=False)\n    hdmi_network = HDMINetwork(tcp_adapter)\n    hdmi_network.start()\n    while True:\n        for d in hdmi_network.devices:\n            _LOGGER.info(\"Device: %s\", d)\n\n        time.sleep(7)", "response": "Main function for testing purpose."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncomputes difference in bits between digest1 and digest2 returns - 127 to 128 is the same", "response": "def compare_hexdigests( digest1, digest2 ):\n    \"\"\"Compute difference in bits between digest1 and digest2\n       returns -127 to 128; 128 is the same, -127 is different\"\"\"\n    # convert to 32-tuple of unsighed two-byte INTs\n    digest1 = tuple([int(digest1[i:i+2],16) for i in range(0,63,2)])\n    digest2 = tuple([int(digest2[i:i+2],16) for i in range(0,63,2)])\n    bits = 0\n    for i in range(32):\n        bits += POPC[255 & digest1[i] ^ digest2[i]]\n    return 128 - bits"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget a transition n between chars a b c.", "response": "def tran3(self, a, b, c, n):\n        \"\"\"Get accumulator for a transition n between chars a, b, c.\"\"\"\n        return (((TRAN[(a+n)&255]^TRAN[b]*(n+n+1))+TRAN[(c)^TRAN[n]])&255)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef update(self, data):\n        for character in data:\n            if PY3:\n                ch = character\n            else:\n                ch = ord(character)\n            self.count += 1\n\n            # incr accumulators for triplets\n            if self.lastch[1] > -1:\n                self.acc[self.tran3(ch, self.lastch[0], self.lastch[1], 0)] +=1\n            if self.lastch[2] > -1:\n                self.acc[self.tran3(ch, self.lastch[0], self.lastch[2], 1)] +=1\n                self.acc[self.tran3(ch, self.lastch[1], self.lastch[2], 2)] +=1\n            if self.lastch[3] > -1:\n                self.acc[self.tran3(ch, self.lastch[0], self.lastch[3], 3)] +=1\n                self.acc[self.tran3(ch, self.lastch[1], self.lastch[3], 4)] +=1\n                self.acc[self.tran3(ch, self.lastch[2], self.lastch[3], 5)] +=1\n                self.acc[self.tran3(self.lastch[3], self.lastch[0], ch, 6)] +=1\n                self.acc[self.tran3(self.lastch[3], self.lastch[2], ch, 7)] +=1\n\n            # adjust last seen chars\n            self.lastch = [ch] + self.lastch[:3]", "response": "Add data to running digest increasing the accumulators for 0 - 8 triplets formed by this char and the previous 0 - 3 chars."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef digest(self):\n        total = 0                           # number of triplets seen\n        if self.count == 3:                 # 3 chars = 1 triplet\n            total = 1\n        elif self.count == 4:               # 4 chars = 4 triplets\n            total = 4\n        elif self.count > 4:                # otherwise 8 triplets/char less\n            total = 8 * self.count - 28     # 28 'missed' during 'ramp-up'\n\n        threshold = total / 256             # threshold for accumulators, using the mean\n\n        code = [0]*32                       # start with all zero bits\n        for i in range(256):                # for all 256 accumulators\n            if self.acc[i] > threshold:     # if it meets the threshold\n                code[i >> 3] += 1 << (i&7)  # set corresponding digest bit, equivalent to i/8, 2 ** (i % 8)\n\n        return code[::-1]", "response": "Get the digest of the data seen thus far as a list of bytes."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nupdate running digest with content of named file.", "response": "def from_file(self, filename):\n        \"\"\"Update running digest with content of named file.\"\"\"\n        f = open(filename, 'rb')\n        while True:\n            data = f.read(10480)\n            if not data:\n                break\n            self.update(data)\n        f.close()"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncomputes difference in bits between own digest and another.", "response": "def compare(self, otherdigest, ishex=False):\n        \"\"\"Compute difference in bits between own digest and another.\n           returns -127 to 128; 128 is the same, -127 is different\"\"\"\n        bits = 0\n        myd = self.digest()\n        if ishex:\n            # convert to 32-tuple of unsighed two-byte INTs\n            otherdigest = tuple([int(otherdigest[i:i+2],16) for i in range(0,63,2)])\n        for i in range(32):\n            bits += POPC[255 & myd[i] ^ otherdigest[i]]\n        return 128 - bits"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a JD - formatted string of the CloudGenix Response body.", "response": "def jdout(api_response):\n    \"\"\"\n    JD Output function. Does quick pretty printing of a CloudGenix Response body. This function returns a string\n    instead of directly printing content.\n\n      **Parameters:**\n\n      - **api_response:** A CloudGenix-attribute extended `requests.Response` object\n\n    **Returns:** Pretty-formatted text of the Response body\n    \"\"\"\n    try:\n        # attempt to output the cgx_content. should always be a Dict if it exists.\n        output = json.dumps(api_response.cgx_content, indent=4)\n    except (TypeError, ValueError, AttributeError):\n        # cgx_content did not exist, or was not JSON serializable. Try pretty output the base obj.\n        try:\n            output = json.dumps(api_response, indent=4)\n        except (TypeError, ValueError, AttributeError):\n            # Same issue, just raw output the passed data. Let any exceptions happen here.\n            output = api_response\n    return output"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef notify_for_new_version(self):\n\n        # broad exception clause, if this fails for any reason just return.\n        try:\n            recommend_update = False\n            update_check_resp = requests.get(self.update_info_url, timeout=3)\n            web_version = update_check_resp.json()[\"info\"][\"version\"]\n            api_logger.debug(\"RETRIEVED_VERSION: %s\", web_version)\n\n            available_version = SDK_BUILD_REGEX.search(web_version).groupdict()\n            current_version = SDK_BUILD_REGEX.search(self.version).groupdict()\n\n            available_major = available_version.get('major')\n            available_minor = available_version.get('minor')\n            available_patch = available_version.get('patch')\n            available_build = available_version.get('build')\n            current_major = current_version.get('major')\n            current_minor = current_version.get('minor')\n            current_patch = current_version.get('patch')\n            current_build = current_version.get('build')\n\n            api_logger.debug(\"AVAILABLE_VERSION: %s\", available_version)\n            api_logger.debug(\"CURRENT_VERSION: %s\", current_version)\n\n            # check for major/minor version differences, do not alert for build differences.\n            if available_major > current_major:\n                recommend_update = True\n            elif available_major >= current_major and available_minor > current_minor:\n                recommend_update = True\n            elif available_major >= current_major and available_minor >= current_minor and \\\n                    available_patch > current_patch:\n                recommend_update = True\n\n            api_logger.debug(\"NEED_UPDATE: %s\", recommend_update)\n\n            # notify.\n            if recommend_update:\n                sys.stderr.write(\"WARNING: CloudGenix Python SDK upgrade available. SDKs are typically deprecated 6 \"\n                                 \"months after release of a new version.\\n\"\n                                 \"\\tLatest Version: {0}\\n\"\n                                 \"\\tCurrent Version: {1}\\n\"\n                                 \"\\tFor more info, see 'https://github.com/cloudgenix/sdk-python'. Additionally, this \"\n                                 \"message can be suppressed by instantiating the API with API(update_check=False).\\n\\n\"\n                                 \"\".format(web_version, self.version))\n\n            return\n\n        except Exception:\n            # just return and continue.\n            return", "response": "Check if a new version of the SDK on API constructor instantiation is found print a notification to STDERR."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nmodifies ssl verification settings.", "response": "def ssl_verify(self, ssl_verify):\n        \"\"\"\n        Modify ssl verification settings\n\n        **Parameters:**\n\n          - ssl_verify:\n             - True: Verify using builtin BYTE_CA_BUNDLE.\n             - False: No SSL Verification.\n             - Str: Full path to a x509 PEM CA File or bundle.\n\n        **Returns:** Mutates API object in place, no return.\n        \"\"\"\n        self.verify = ssl_verify\n        # if verify true/false, set ca_verify_file appropriately\n        if isinstance(self.verify, bool):\n            if self.verify:  # True\n                if os.name == 'nt':\n                    # Windows does not allow tmpfile access w/out close. Close file then delete it when done.\n                    self._ca_verify_file_handle = temp_ca_bundle(delete=False)\n                    self._ca_verify_file_handle.write(BYTE_CA_BUNDLE)\n                    self._ca_verify_file_handle.flush()\n                    self.ca_verify_filename = self._ca_verify_file_handle.name\n                    self._ca_verify_file_handle.close()\n\n                # Other (POSIX/Unix/Linux/OSX)\n                else:\n                    self._ca_verify_file_handle = temp_ca_bundle()\n                    self._ca_verify_file_handle.write(BYTE_CA_BUNDLE)\n                    self._ca_verify_file_handle.flush()\n                    self.ca_verify_filename = self._ca_verify_file_handle.name\n\n                # register cleanup function for temp file.\n                atexit.register(self._cleanup_ca_temp_file)\n\n            else:  # False\n                # disable warnings for SSL certs.\n                urllib3.disable_warnings()\n                self.ca_verify_filename = False\n        else:  # Not True/False, assume path to file/dir for Requests\n            self.ca_verify_filename = self.verify\n        return"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef modify_rest_retry(self, total=8, connect=None, read=None, redirect=None, status=None,\n                          method_whitelist=urllib3.util.retry.Retry.DEFAULT_METHOD_WHITELIST, status_forcelist=None,\n                          backoff_factor=0.705883, raise_on_redirect=True, raise_on_status=True,\n                          respect_retry_after_header=True, adapter_url=\"https://\"):\n        \"\"\"\n        Modify retry parameters for the SDK's rest call object.\n\n        Parameters are directly from and passed directly to `urllib3.util.retry.Retry`, and get applied directly to\n        the underlying `requests.Session` object.\n\n        Default retry with total=8 and backoff_factor=0.705883:\n         - Try 1, 0 delay (0 total seconds)\n         - Try 2, 0 delay (0 total seconds)\n         - Try 3, 0.705883 delay (0.705883 total seconds)\n         - Try 4, 1.411766 delay (2.117649 total seconds)\n         - Try 5, 2.823532 delay (4.941181 total seconds)\n         - Try 6, 5.647064 delay (10.588245 total seconds)\n         - Try 7, 11.294128 delay (21.882373 total seconds)\n         - Try 8, 22.588256 delay (44.470629 total seconds)\n         - Try 9, 45.176512 delay (89.647141 total seconds)\n         - Try 10, 90.353024 delay (180.000165 total seconds)\n\n        **Parameters:**\n\n          - **total:** int, Total number of retries to allow. Takes precedence over other counts.\n          - **connect:** int, How many connection-related errors to retry on.\n          - **read:** int, How many times to retry on read errors.\n          - **redirect:** int, How many redirects to perform. loops.\n          - **status:** int, How many times to retry on bad status codes.\n          - **method_whitelist:** iterable, Set of uppercased HTTP method verbs that we should retry on.\n          - **status_forcelist:** iterable, A set of integer HTTP status codes that we should force a retry on.\n          - **backoff_factor:** float, A backoff factor to apply between attempts after the second try.\n          - **raise_on_redirect:** bool, True = raise a MaxRetryError, False = return latest 3xx response.\n          - **raise_on_status:** bool, Similar logic to ``raise_on_redirect`` but for status responses.\n          - **respect_retry_after_header:** bool, Whether to respect Retry-After header on status codes.\n          - **adapter_url:** string, URL match for these retry values (default `https://`)\n\n        **Returns:** No return, mutates the session directly\n        \"\"\"\n        # Cloudgenix responses with 502/504 are usually recoverable. Use them if no list specified.\n        if status_forcelist is None:\n            status_forcelist = (413, 429, 502, 503, 504)\n\n        retry = urllib3.util.retry.Retry(total=total,\n                                         connect=connect,\n                                         read=read,\n                                         redirect=redirect,\n                                         status=status,\n                                         method_whitelist=method_whitelist,\n                                         status_forcelist=status_forcelist,\n                                         backoff_factor=backoff_factor,\n                                         raise_on_redirect=raise_on_redirect,\n                                         raise_on_status=raise_on_status,\n                                         respect_retry_after_header=respect_retry_after_header)\n        adapter = requests.adapters.HTTPAdapter(max_retries=retry)\n        self._session.mount(adapter_url, adapter)\n        return", "response": "Modify the retry parameters for the SDK s REST call object."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nviewing current rest retry settings in the requests. Session object", "response": "def view_rest_retry(self, url=None):\n        \"\"\"\n        View current rest retry settings in the `requests.Session()` object\n\n        **Parameters:**\n\n          - **url:** URL to use to determine retry methods for. Defaults to 'https://'\n\n        **Returns:** Dict, Key header, value is header value.\n        \"\"\"\n        if url is None:\n            url = \"https://\"\n        return vars(self._session.get_adapter(url).max_retries)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef view_cookies(self):\n        return_list = []\n        for cookie in self._session.cookies:\n            return_list.append(vars(cookie))\n\n        return return_list", "response": "View current cookies in the requests. Session object"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef set_debug(self, debuglevel):\n        if isinstance(debuglevel, int):\n            self._debuglevel = debuglevel\n\n        if self._debuglevel == 1:\n            logging.basicConfig(level=logging.INFO,\n                                format=\"%(levelname)s [%(name)s.%(funcName)s:%(lineno)d] %(message)s\")\n            api_logger.setLevel(logging.INFO)\n        elif self._debuglevel == 2:\n            logging.basicConfig(level=logging.DEBUG,\n                                format=\"%(levelname)s [%(name)s.%(funcName)s:%(lineno)d] %(message)s\")\n            requests.cookies.cookielib.debug = True\n            api_logger.setLevel(logging.DEBUG)\n        elif self._debuglevel >= 3:\n            logging.basicConfig(level=logging.DEBUG,\n                                format=\"%(levelname)s [%(name)s.%(funcName)s:%(lineno)d] %(message)s\")\n            requests.cookies.cookielib.debug = True\n            api_logger.setLevel(logging.DEBUG)\n            urllib3_logger = logging.getLogger(\"requests.packages.urllib3\")\n            urllib3_logger.setLevel(logging.DEBUG)\n            urllib3_logger.propagate = True\n        else:\n            # Remove all handlers\n            for handler in logging.root.handlers[:]:\n                logging.root.removeHandler(handler)\n            # set logging level to default\n            requests.cookies.cookielib.debug = False\n            api_logger.setLevel(logging.WARNING)\n\n        return", "response": "Sets the debug level of the API."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _subclass_container(self):\n        _parent_class = self\n\n        class GetWrapper(Get):\n\n            def __init__(self):\n                self._parent_class = _parent_class\n\n        class PostWrapper(Post):\n\n            def __init__(self):\n                self._parent_class = _parent_class\n\n        class PutWrapper(Put):\n\n            def __init__(self):\n                self._parent_class = _parent_class\n\n        class PatchWrapper(Patch):\n\n            def __init__(self):\n                self._parent_class = _parent_class\n\n        class DeleteWrapper(Delete):\n\n            def __init__(self):\n                self._parent_class = _parent_class\n\n        class InteractiveWrapper(Interactive):\n\n            def __init__(self):\n                self._parent_class = _parent_class\n\n        return {\"get\": GetWrapper,\n                \"post\": PostWrapper,\n                \"put\": PutWrapper,\n                \"patch\": PatchWrapper,\n                \"delete\": DeleteWrapper,\n                \"interactive\": InteractiveWrapper}", "response": "Return a dict with subclass references."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef rest_call(self, url, method, data=None, sensitive=False, timeout=None, content_json=True,\n                  retry=None, max_retry=None, retry_sleep=None):\n        \"\"\"\n        Generic REST call worker function\n\n        **Parameters:**\n\n          - **url:** URL for the REST call\n          - **method:** METHOD for the REST call\n          - **data:** Optional DATA for the call (for POST/PUT/etc.)\n          - **sensitive:** Flag if content request/response should be hidden from logging functions\n          - **timeout:** Requests Timeout\n          - **content_json:** Bool on whether the Content-Type header should be set to application/json\n          - **retry:** DEPRECATED - please use `cloudgenix.API.modify_rest_retry` instead.\n          - **max_retry:** DEPRECATED - please use `cloudgenix.API.modify_rest_retry` instead.\n          - **retry_sleep:** DEPRECATED - please use `cloudgenix.API.modify_rest_retry` instead.\n\n        **Returns:** Requests.Response object, extended with:\n\n          - **cgx_status**: Bool, True if a successful CloudGenix response, False if error.\n          - **cgx_content**: Content of the response, guaranteed to be in Dict format. Empty/invalid responses\n          will be converted to a Dict response.\n        \"\"\"\n        # pull retry related items from Constructor if not specified.\n        if timeout is None:\n            timeout = self.rest_call_timeout\n        if retry is not None:\n            # Someone using deprecated retry code. Notify.\n            sys.stderr.write(\"WARNING: 'retry' option of rest_call() has been deprecated. \"\n                             \"Please use 'API.modify_rest_retry()' instead.\")\n        if max_retry is not None:\n            # Someone using deprecated retry code. Notify.\n            sys.stderr.write(\"WARNING: 'max_retry' option of rest_call() has been deprecated. \"\n                             \"Please use 'API.modify_rest_retry()' instead.\")\n        if retry_sleep is not None:\n            # Someone using deprecated retry code. Notify.\n            sys.stderr.write(\"WARNING: 'max_retry' option of rest_call() has been deprecated. \"\n                             \"Please use 'API.modify_rest_retry()' instead.\")\n\n        # Get logging level, use this to bypass logging functions with possible large content if not set.\n        logger_level = api_logger.getEffectiveLevel()\n\n        # populate headers and cookies from session.\n        if content_json and method.lower() not in ['get', 'delete']:\n            headers = {\n                'Content-Type': 'application/json'\n            }\n        else:\n            headers = {}\n\n        # add session headers\n        headers.update(self._session.headers)\n        cookie = self._session.cookies.get_dict()\n\n        # make sure data is populated if present.\n        if isinstance(data, (list, dict)):\n            data = json.dumps(data)\n\n        api_logger.debug('REST_CALL URL = %s', url)\n\n        # make request\n        try:\n            if not sensitive:\n                api_logger.debug('\\n\\tREQUEST: %s %s\\n\\tHEADERS: %s\\n\\tCOOKIES: %s\\n\\tDATA: %s\\n',\n                                 method.upper(), url, headers, cookie, data)\n\n            # Actual request\n            response = self._session.request(method, url, data=data, verify=self.ca_verify_filename,\n                                             stream=True, timeout=timeout, headers=headers, allow_redirects=False)\n\n            # Request complete - lets parse.\n            # if it's a non-CGX-good response, return with cgx_status = False\n            if response.status_code not in [requests.codes.ok,\n                                            requests.codes.no_content,\n                                            requests.codes.found,\n                                            requests.codes.moved]:\n\n                # Simple JSON debug\n                if not sensitive:\n                    try:\n                        api_logger.debug('RESPONSE HEADERS: %s\\n', json.dumps(\n                            json.loads(text_type(response.headers)), indent=4))\n                    except ValueError:\n                        api_logger.debug('RESPONSE HEADERS: %s\\n', text_type(response.headers))\n                    try:\n                        api_logger.debug('RESPONSE: %s\\n', json.dumps(response.json(), indent=4))\n                    except ValueError:\n                        api_logger.debug('RESPONSE: %s\\n', text_type(response.text))\n                else:\n                    api_logger.debug('RESPONSE NOT LOGGED (sensitive content)')\n\n                api_logger.debug(\"Error, non-200 response received: %s\", response.status_code)\n\n                # CGX extend requests.Response for return\n                response.cgx_status = False\n                response.cgx_content = self._catch_nonjson_streamresponse(response.text)\n                return response\n\n            else:\n\n                # Simple JSON debug\n                if not sensitive and (logger_level <= logging.DEBUG and logger_level != logging.NOTSET):\n                    try:\n                        api_logger.debug('RESPONSE HEADERS: %s\\n', json.dumps(\n                            json.loads(text_type(response.headers)), indent=4))\n                        api_logger.debug('RESPONSE: %s\\n', json.dumps(response.json(), indent=4))\n                    except ValueError:\n                        api_logger.debug('RESPONSE HEADERS: %s\\n', text_type(response.headers))\n                        api_logger.debug('RESPONSE: %s\\n', text_type(response.text))\n                elif sensitive:\n                    api_logger.debug('RESPONSE NOT LOGGED (sensitive content)')\n\n                # CGX extend requests.Response for return\n                response.cgx_status = True\n                response.cgx_content = self._catch_nonjson_streamresponse(response.text)\n                return response\n\n        except (requests.exceptions.Timeout, requests.exceptions.ConnectionError, urllib3.exceptions.MaxRetryError)\\\n                as e:\n\n            api_logger.info(\"Error, %s.\", text_type(e))\n\n            # make a requests.Response object for return since we didn't get one.\n            response = requests.Response\n\n            # CGX extend requests.Response for return\n            response.cgx_status = False\n            response.cgx_content = {\n                '_error': [\n                    {\n                        'message': 'REST Request Exception: {}'.format(e),\n                        'data': {},\n                    }\n                ]\n            }\n            return response", "response": "Generic REST call worker function."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nfunction to clean up the ca temp file for requests.", "response": "def _cleanup_ca_temp_file(self):\n        \"\"\"\n        Function to clean up ca temp file for requests.\n\n        **Returns:** Removes TEMP ca file, no return\n        \"\"\"\n        if os.name == 'nt':\n            if isinstance(self.ca_verify_filename, (binary_type, text_type)):\n                # windows requires file to be closed for access. Have to manually remove\n                os.unlink(self.ca_verify_filename)\n        else:\n            # other OS's allow close and delete of file.\n            self._ca_verify_file_handle.close()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef parse_auth_token(self, auth_token):\n        # remove the random security key value from the front of the auth_token\n        auth_token_cleaned = auth_token.split('-', 1)[1]\n        # URL Decode the Auth Token\n        auth_token_decoded = self.url_decode(auth_token_cleaned)\n        # Create a new dict to hold the response.\n        auth_dict = {}\n\n        # Parse the token\n        for key_value in auth_token_decoded.split(\"&\"):\n            key_value_list = key_value.split(\"=\")\n            # check for valid token parts\n            if len(key_value_list) == 2 and type(key_value_list[0]) in [text_type, binary_type]:\n                auth_dict[key_value_list[0]] = key_value_list[1]\n\n        # Return the dict of key/values in the token.\n        return auth_dict", "response": "Parse the auth_token into a dict of key - value pairs."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef update_region_to_controller(self, region):\n        # default region position in a list\n        region_position = 1\n\n        # Check for a global \"ignore region\" flag\n        if self.ignore_region:\n            # bypass\n            api_logger.debug(\"IGNORE_REGION set, not updating controller region.\")\n            return\n\n        api_logger.debug(\"Updating Controller Region\")\n        api_logger.debug(\"CONTROLLER = %s\", self.controller)\n        api_logger.debug(\"CONTROLLER_ORIG = %s\", self.controller_orig)\n        api_logger.debug(\"CONTROLLER_REGION = %s\", self.controller_region)\n\n        # Check if this is an initial region use or an update region use\n        if self.controller_orig:\n            controller_base = self.controller_orig\n        else:\n            controller_base = self.controller\n            self.controller_orig = self.controller\n\n        # splice controller string\n        controller_full_part_list = controller_base.split('.')\n\n        for idx, part in enumerate(controller_full_part_list):\n            # is the region already in the controller string?\n            if region == part:\n                # yes, controller already has apropriate region\n                api_logger.debug(\"REGION %s ALREADY IN CONTROLLER AT INDEX = %s\", region, idx)\n                # update region if it is not already set.\n                if self.controller_region != region:\n                    self.controller_region = region\n                    api_logger.debug(\"UPDATED_CONTROLLER_REGION = %s\", self.controller_region)\n                return\n\n        controller_part_count = len(controller_full_part_list)\n\n        # handle short domain case\n        if controller_part_count > 1:\n            # insert region\n            controller_full_part_list[region_position] = region\n            self.controller = \".\".join(controller_full_part_list)\n        else:\n            # short domain, just add region\n            self.controller = \".\".join(controller_full_part_list) + '.' + region\n\n        # update SDK vars with region info\n        self.controller_orig = controller_base\n        self.controller_region = region\n\n        api_logger.debug(\"UPDATED_CONTROLLER = %s\", self.controller)\n        api_logger.debug(\"UPDATED_CONTROLLER_ORIG = %s\", self.controller_orig)\n        api_logger.debug(\"UPDATED_CONTROLLER_REGION = %s\", self.controller_region)\n        return", "response": "Update the controller string with the dynamic region info."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef parse_region(self, login_response):\n        auth_token = login_response.cgx_content['x_auth_token']\n        auth_token_dict = self.parse_auth_token(auth_token)\n        auth_region = auth_token_dict.get('region')\n        return auth_region", "response": "Parse the region from a successful login response."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef reparse_login_cookie_after_region_update(self, login_response):\n\n        login_url = login_response.request.url\n        api_logger.debug(\"ORIGINAL REQUEST URL = %s\", login_url)\n        # replace old controller with new controller.\n        login_url_new = login_url.replace(self.controller_orig, self.controller)\n        api_logger.debug(\"UPDATED REQUEST URL = %s\", login_url_new)\n        # reset login url with new region\n        login_response.request.url = login_url_new\n        # prep cookie jar parsing\n        req = requests.cookies.MockRequest(login_response.request)\n        res = requests.cookies.MockResponse(login_response.raw._original_response.msg)\n        # extract cookies to session cookie jar.\n        self._session.cookies.extract_cookies(res, req)\n        return", "response": "This function re - parses the login cookie after region update."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _catch_nonjson_streamresponse(rawresponse):\n        # attempt to load response for return.\n        try:\n            response = json.loads(rawresponse)\n        except (ValueError, TypeError):\n            if rawresponse:\n                response = {\n                    '_error': [\n                        {\n                            'message': 'Response not in JSON format.',\n                            'data': rawresponse,\n                        }\n                    ]\n                }\n            else:\n                # in case of null response, return empty dict.\n                response = {}\n\n        return response", "response": "Validate a streamed response is JSON. Return a Python dictionary either way."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget optimal file system buffer size for I/O calls.", "response": "def blksize(path):\n    \"\"\"\n    Get optimal file system buffer size (in bytes) for I/O calls.\n    \"\"\"\n    diskfreespace = win32file.GetDiskFreeSpace\n    dirname = os.path.dirname(fullpath(path))\n    try:\n        cluster_sectors, sector_size = diskfreespace(dirname)[:2]\n        size = cluster_sectors * sector_size\n\n    except win32file.error as e:\n        if e.winerror != winerror.ERROR_NOT_READY:\n            raise\n        sleep(3)\n        size = blksize(dirname)\n\n    return size"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the gravatar URL for the given email hash.", "response": "def gravatar(hash, size=100, rating='g', default='identicon', include_extension=False, force_default=False):\n        \"\"\"Pass email hash, return Gravatar URL. You can get email hash like this::\n\n            import hashlib\n            avatar_hash = hashlib.md5(email.lower().encode('utf-8')).hexdigest()\n\n        Visit https://en.gravatar.com/site/implement/images/ for more information.\n\n        :param hash: The email hash used to generate avatar URL.\n        :param size: The size of the avatar, default to 100 pixel.\n        :param rating: The rating of the avatar, default to ``g``\n        :param default: The type of default avatar, default to ``identicon``.\n        :param include_extension: Append a '.jpg' extension at the end of URL, default to ``False``.\n        :param force_default: Force to use default avatar, default to ``False``.\n        \"\"\"\n        if include_extension:\n            hash += '.jpg'\n\n        default = default or current_app.config['AVATARS_GRAVATAR_DEFAULT']\n        query_string = urlencode({'s': int(size), 'r': rating, 'd': default})\n\n        if force_default:\n            query_string += '&q=y'\n        return 'https://gravatar.com/avatar/' + hash + '?' + query_string"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning avatar URL at social media.", "response": "def social_media(username, platform='twitter', size='medium'):\n        \"\"\"Return avatar URL at social media.\n        Visit https://avatars.io for more information.\n\n        :param username: The username of the social media.\n        :param platform: One of facebook, instagram, twitter, gravatar.\n        :param size: The size of avatar, one of small, medium and large.\n        \"\"\"\n        return 'https://avatars.io/{platform}/{username}/{size}'.format(\n            platform=platform, username=username, size=size)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nload jcrop css file.", "response": "def jcrop_css(css_url=None):\n        \"\"\"Load jcrop css file.\n\n        :param css_url: The custom CSS URL.\n        \"\"\"\n        if css_url is None:\n            if current_app.config['AVATARS_SERVE_LOCAL']:\n                css_url = url_for('avatars.static', filename='jcrop/css/jquery.Jcrop.min.css')\n            else:\n                css_url = 'https://cdn.jsdelivr.net/npm/jcrop-0.9.12@0.9.12/css/jquery.Jcrop.min.css'\n        return Markup('<link rel=\"stylesheet\" href=\"%s\">' % css_url)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nload jcrop Javascript file.", "response": "def jcrop_js(js_url=None, with_jquery=True):\n        \"\"\"Load jcrop Javascript file.\n\n        :param js_url: The custom JavaScript URL.\n        :param with_jquery: Include jQuery or not, default to ``True``.\n        \"\"\"\n        serve_local = current_app.config['AVATARS_SERVE_LOCAL']\n\n        if js_url is None:\n            if serve_local:\n                js_url = url_for('avatars.static', filename='jcrop/js/jquery.Jcrop.min.js')\n            else:\n                js_url = 'https://cdn.jsdelivr.net/npm/jcrop-0.9.12@0.9.12/js/jquery.Jcrop.min.js'\n\n        if with_jquery:\n            if serve_local:\n                jquery = '<script src=\"%s\"></script>' % url_for('avatars.static', filename='jcrop/js/jquery.min.js')\n            else:\n                jquery = '<script src=\"https://cdn.jsdelivr.net/npm/jcrop-0.9.12@0.9.12/js/jquery.min.js\"></script>'\n        else:\n            jquery = ''\n        return Markup('''%s\\n<script src=\"%s\"></script>\n        ''' % (jquery, js_url))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef crop_box(endpoint=None, filename=None):\n        crop_size = current_app.config['AVATARS_CROP_BASE_WIDTH']\n\n        if endpoint is None or filename is None:\n            url = url_for('avatars.static', filename='default/default_l.jpg')\n        else:\n            url = url_for(endpoint, filename=filename)\n        return Markup('<img src=\"%s\" id=\"crop-box\" style=\"max-width: %dpx; display: block;\">' % (url, crop_size))", "response": "Create a crop box."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating a preview box.", "response": "def preview_box(endpoint=None, filename=None):\n        \"\"\"Create a preview box.\n\n        :param endpoint: The endpoint of view function that serve avatar image file.\n        :param filename: The filename of the image that need to be crop.\n        \"\"\"\n        preview_size = current_app.config['AVATARS_CROP_PREVIEW_SIZE'] or current_app.config['AVATARS_SIZE_TUPLE'][2]\n\n        if endpoint is None or filename is None:\n            url = url_for('avatars.static', filename='default/default_l.jpg')\n        else:\n            url = url_for(endpoint, filename=filename)\n        return Markup('''\n        <div id=\"preview-box\">\n        <div class=\"preview-box\" style=\"width: %dpx; height: %dpx; overflow: hidden;\">\n          <img src=\"%s\" class=\"jcrop-preview\" alt=\"Preview\"/>\n        </div>\n      </div>''' % (preview_size, preview_size, url))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ninitializing jcrop. :param min_size: The minimal size of crop area.", "response": "def init_jcrop(min_size=None):\n        \"\"\"Initialize jcrop.\n\n        :param min_size: The minimal size of crop area.\n        \"\"\"\n        init_x = current_app.config['AVATARS_CROP_INIT_POS'][0]\n        init_y = current_app.config['AVATARS_CROP_INIT_POS'][1]\n        init_size = current_app.config['AVATARS_CROP_INIT_SIZE'] or current_app.config['AVATARS_SIZE_TUPLE'][2]\n\n        if current_app.config['AVATARS_CROP_MIN_SIZE']:\n            min_size = min_size or current_app.config['AVATARS_SIZE_TUPLE'][2]\n            min_size_js = 'jcrop_api.setOptions({minSize: [%d, %d]});' % (min_size, min_size)\n        else:\n            min_size_js = ''\n        return Markup('''\n<script type=\"text/javascript\">\n    jQuery(function ($) {\n      // Create variables (in this scope) to hold the API and image size\n      var jcrop_api,\n          boundx,\n          boundy,\n\n          // Grab some information about the preview pane\n          $preview = $('#preview-box'),\n          $pcnt = $('#preview-box .preview-box'),\n          $pimg = $('#preview-box .preview-box img'),\n\n          xsize = $pcnt.width(),\n          ysize = $pcnt.height();\n\n      $('#crop-box').Jcrop({\n        onChange: updatePreview,\n        onSelect: updateCoords,\n        setSelect: [%s, %s, %s, %s],\n        aspectRatio: 1\n      }, function () {\n        // Use the API to get the real image size\n        var bounds = this.getBounds();\n        boundx = bounds[0];\n        boundy = bounds[1];\n        // Store the API in the jcrop_api variable\n        jcrop_api = this;\n        %s\n        jcrop_api.focus();\n        // Move the preview into the jcrop container for css positioning\n        $preview.appendTo(jcrop_api.ui.holder);\n      });\n\n      function updatePreview(c) {\n        if (parseInt(c.w) > 0) {\n          var rx = xsize / c.w;\n          var ry = ysize / c.h;\n          $pimg.css({\n            width: Math.round(rx * boundx) + 'px',\n            height: Math.round(ry * boundy) + 'px',\n            marginLeft: '-' + Math.round(rx * c.x) + 'px',\n            marginTop: '-' + Math.round(ry * c.y) + 'px'\n          });\n        }\n      }\n    });\n\n    function updateCoords(c) {\n      $('#x').val(c.x);\n      $('#y').val(c.y);\n      $('#w').val(c.w);\n      $('#h').val(c.h);\n    }\n  </script>\n            ''' % (init_x, init_y, init_size, init_size, min_size_js))"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsaves an avatar as raw image return new filename.", "response": "def save_avatar(self, image):\n        \"\"\"Save an avatar as raw image, return new filename.\n\n        :param image: The image that needs to be saved.\n        \"\"\"\n        path = current_app.config['AVATARS_SAVE_PATH']\n        filename = uuid4().hex + '_raw.png'\n        image.save(os.path.join(path, filename))\n        return filename"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef crop_avatar(self, filename, x, y, w, h):\n        x = int(x)\n        y = int(y)\n        w = int(w)\n        h = int(h)\n\n        sizes = current_app.config['AVATARS_SIZE_TUPLE']\n\n        if not filename:\n            path = os.path.join(self.root_path, 'static/default/default_l.jpg')\n        else:\n            path = os.path.join(current_app.config['AVATARS_SAVE_PATH'], filename)\n\n        print(path)\n\n        raw_img = Image.open(path)\n\n        base_width = current_app.config['AVATARS_CROP_BASE_WIDTH']\n\n        if raw_img.size[0] >= base_width:\n            raw_img = self.resize_avatar(raw_img, base_width=base_width)\n\n        cropped_img = raw_img.crop((x, y, x + w, y + h))\n\n        filename = uuid4().hex\n\n        avatar_s = self.resize_avatar(cropped_img, base_width=sizes[0])\n        avatar_m = self.resize_avatar(cropped_img, base_width=sizes[1])\n        avatar_l = self.resize_avatar(cropped_img, base_width=sizes[2])\n\n        filename_s = filename + '_s.png'\n        filename_m = filename + '_m.png'\n        filename_l = filename + '_l.png'\n\n        path_s = os.path.join(current_app.config['AVATARS_SAVE_PATH'], filename_s)\n        path_m = os.path.join(current_app.config['AVATARS_SAVE_PATH'], filename_m)\n        path_l = os.path.join(current_app.config['AVATARS_SAVE_PATH'], filename_l)\n\n        avatar_s.save(path_s, optimize=True, quality=85)\n        avatar_m.save(path_m, optimize=True, quality=85)\n        avatar_l.save(path_l, optimize=True, quality=85)\n\n        return [filename_s, filename_m, filename_l]", "response": "Crop the avatar with given size return a list of file name s m and l."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a PNG image from a string.", "response": "def get_image(self, string, width, height, pad=0):\n        \"\"\"\n          Byte representation of a PNG image\n        \"\"\"\n        hex_digest_byte_list = self._string_to_byte_list(string)\n        matrix = self._create_matrix(hex_digest_byte_list)\n        return self._create_image(matrix, width, height, pad)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates a pastel colour hex colour string", "response": "def _get_pastel_colour(self, lighten=127):\n        \"\"\"\n            Create a pastel colour hex colour string\n        \"\"\"\n        def r():\n            return random.randint(0, 128) + lighten\n        return r(), r(), r()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ndetermining the liminanace of an RGB colour", "response": "def _luminance(self, rgb):\n        \"\"\"\n        Determine the liminanace of an RGB colour\n        \"\"\"\n        a = []\n        for v in rgb:\n            v = v / float(255)\n            if v < 0.03928:\n                result = v / 12.92\n            else:\n                result = math.pow(((v + 0.055) / 1.055), 2.4)\n\n            a.append(result)\n        return a[0] * 0.2126 + a[1] * 0.7152 + a[2] * 0.0722"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _string_to_byte_list(self, data):\n        bytes_length = 16\n\n        m = self.digest()\n        m.update(str.encode(data))\n        hex_digest = m.hexdigest()\n\n        return list(int(hex_digest[num * 2:num * 2 + 2], bytes_length)\n                    for num in range(bytes_length))", "response": "Returns a list of rgb values of the image"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncheck if the bit n of hash_bytes is 1.", "response": "def _bit_is_one(self, n, hash_bytes):\n        \"\"\"\n        Check if the n (index) of hash_bytes is 1 or 0.\n        \"\"\"\n\n        scale = 16  # hexadecimal\n\n        if not hash_bytes[int(n / (scale / 2))] >> int(\n                (scale / 2) - ((n % (scale / 2)) + 1)) & 1 == 1:\n            return False\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate a PNG byte list of the image.", "response": "def _create_image(self, matrix, width, height, pad):\n        \"\"\"\n        Generates a PNG byte list\n        \"\"\"\n\n        image = Image.new(\"RGB\", (width + (pad * 2),\n                                  height + (pad * 2)), self.bg_colour)\n        image_draw = ImageDraw.Draw(image)\n\n        # Calculate the block width and height.\n        block_width = float(width) / self.cols\n        block_height = float(height) / self.rows\n\n        # Loop through blocks in matrix, draw rectangles.\n        for row, cols in enumerate(matrix):\n            for col, cell in enumerate(cols):\n                if cell:\n                    image_draw.rectangle((\n                        pad + col * block_width,  # x1\n                        pad + row * block_height,  # y1\n                        pad + (col + 1) * block_width - 1,  # x2\n                        pad + (row + 1) * block_height - 1  # y2\n                    ), fill=self.fg_colour)\n\n        stream = BytesIO()\n        image.save(stream, format=\"png\", optimize=True)\n        # return the image byte data\n        return stream.getvalue()"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _create_matrix(self, byte_list):\n\n        # Number of rows * cols halfed and rounded\n        # in order to fill opposite side\n        cells = int(self.rows * self.cols / 2 + self.cols % 2)\n\n        matrix = [[False] * self.cols for num in range(self.rows)]\n\n        for cell_number in range(cells):\n\n            # If the bit with index corresponding to this cell is 1\n            # mark that cell as fg_colour\n            # Skip byte 1, that's used in determining fg_colour\n            if self._bit_is_one(cell_number, byte_list[1:]):\n                # Find cell coordinates in matrix.\n                x_row = cell_number % self.rows\n                y_col = int(cell_number / self.cols)\n                # Set coord True and its opposite side\n                matrix[x_row][self.cols - y_col - 1] = True\n                matrix[x_row][y_col] = True\n        return matrix", "response": "Create the matrix that decides which blocks should be filled fg or bg colour\n            True for fg_colour\n            False for bg_colour\n           "}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngenerates and save avatars return a list of file name", "response": "def generate(self, text):\n        \"\"\"Generate and save avatars, return a list of file name: [filename_s, filename_m, filename_l].\n\n        :param text: The text used to generate image.\n        \"\"\"\n        sizes = current_app.config['AVATARS_SIZE_TUPLE']\n        path = current_app.config['AVATARS_SAVE_PATH']\n        suffix = {sizes[0]: 's', sizes[1]: 'm', sizes[2]: 'l'}\n\n        for size in sizes:\n            image_byte_array = self.get_image(\n                string=str(text),\n                width=int(size),\n                height=int(size),\n                pad=int(size * 0.1))\n            self.save(image_byte_array, save_location=os.path.join(path, '%s_%s.png' % (text, suffix[size])))\n        return [text + '_s.png', text + '_m.png', text + '_l.png']"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreading the values from the array and sets the attributes of the object.", "response": "def read(self, vals):\n        \"\"\"Read values.\n\n        Args:\n            vals (list): list of strings representing values\n\n        \"\"\"\n        i = 0\n        if len(vals[i]) == 0:\n            self.city = None\n        else:\n            self.city = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.state_province_region = None\n        else:\n            self.state_province_region = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.country = None\n        else:\n            self.country = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.source = None\n        else:\n            self.source = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.wmo = None\n        else:\n            self.wmo = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.latitude = None\n        else:\n            self.latitude = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.longitude = None\n        else:\n            self.longitude = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.timezone = None\n        else:\n            self.timezone = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.elevation = None\n        else:\n            self.elevation = vals[i]\n        i += 1"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncorresponding to IDD Field city", "response": "def city(self, value=None):\n        \"\"\"Corresponds to IDD Field `city`\n\n        Args:\n            value (str): value for IDD Field `city`\n                if `value` is None it will not be checked against the\n                specification and is assumed to be a missing value\n\n        Raises:\n            ValueError: if `value` is not a valid value\n\n        \"\"\"\n        if value is not None:\n            try:\n                value = str(value)\n            except ValueError:\n                raise ValueError('value {} need to be of type str '\n                                 'for field `city`'.format(value))\n            if ',' in value:\n                raise ValueError('value should not contain a comma '\n                                 'for field `city`')\n\n        self._city = value"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncorresponds to IDD Field state_province_region", "response": "def state_province_region(self, value=None):\n        \"\"\"Corresponds to IDD Field `state_province_region`\n\n        Args:\n            value (str): value for IDD Field `state_province_region`\n                if `value` is None it will not be checked against the\n                specification and is assumed to be a missing value\n\n        Raises:\n            ValueError: if `value` is not a valid value\n\n        \"\"\"\n        if value is not None:\n            try:\n                value = str(value)\n            except ValueError:\n                raise ValueError(\n                    'value {} need to be of type str '\n                    'for field `state_province_region`'.format(value))\n            if ',' in value:\n                raise ValueError('value should not contain a comma '\n                                 'for field `state_province_region`')\n\n        self._state_province_region = value"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef country(self, value=None):\n        if value is not None:\n            try:\n                value = str(value)\n            except ValueError:\n                raise ValueError('value {} need to be of type str '\n                                 'for field `country`'.format(value))\n            if ',' in value:\n                raise ValueError('value should not contain a comma '\n                                 'for field `country`')\n\n        self._country = value", "response": "Corresponds to IDD Field country"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef source(self, value=None):\n        if value is not None:\n            try:\n                value = str(value)\n            except ValueError:\n                raise ValueError('value {} need to be of type str '\n                                 'for field `source`'.format(value))\n            if ',' in value:\n                raise ValueError('value should not contain a comma '\n                                 'for field `source`')\n\n        self._source = value", "response": "Corresponds to IDD Field source"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncorresponds to IDD Field wmo", "response": "def wmo(self, value=None):\n        \"\"\"Corresponds to IDD Field `wmo` usually a 6 digit field. Used as\n        alpha in EnergyPlus.\n\n        Args:\n            value (str): value for IDD Field `wmo`\n                if `value` is None it will not be checked against the\n                specification and is assumed to be a missing value\n\n        Raises:\n            ValueError: if `value` is not a valid value\n\n        \"\"\"\n        if value is not None:\n            try:\n                value = str(value)\n            except ValueError:\n                raise ValueError('value {} need to be of type str '\n                                 'for field `wmo`'.format(value))\n            if ',' in value:\n                raise ValueError('value should not contain a comma '\n                                 'for field `wmo`')\n\n        self._wmo = value"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef latitude(self, value=0.0):\n        if value is not None:\n            try:\n                value = float(value)\n            except ValueError:\n                raise ValueError('value {} need to be of type float '\n                                 'for field `latitude`'.format(value))\n            if value < -90.0:\n                raise ValueError('value need to be greater or equal -90.0 '\n                                 'for field `latitude`')\n            if value > 90.0:\n                raise ValueError('value need to be smaller 90.0 '\n                                 'for field `latitude`')\n\n        self._latitude = value", "response": "Corresponds to IDD Field latitude"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef longitude(self, value=0.0):\n        if value is not None:\n            try:\n                value = float(value)\n            except ValueError:\n                raise ValueError('value {} need to be of type float '\n                                 'for field `longitude`'.format(value))\n            if value < -180.0:\n                raise ValueError('value need to be greater or equal -180.0 '\n                                 'for field `longitude`')\n            if value > 180.0:\n                raise ValueError('value need to be smaller 180.0 '\n                                 'for field `longitude`')\n\n        self._longitude = value", "response": "Corresponds to IDD Field longitude"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef timezone(self, value=0.0):\n        if value is not None:\n            try:\n                value = float(value)\n            except ValueError:\n                raise ValueError('value {} need to be of type float '\n                                 'for field `timezone`'.format(value))\n            if value < -12.0:\n                raise ValueError('value need to be greater or equal -12.0 '\n                                 'for field `timezone`')\n            if value > 12.0:\n                raise ValueError('value need to be smaller 12.0 '\n                                 'for field `timezone`')\n\n        self._timezone = value", "response": "Corresponds to IDD Field timezone Time relative to GMT"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncorrespond to IDD Field elevation", "response": "def elevation(self, value=0.0):\n        \"\"\"Corresponds to IDD Field `elevation`\n\n        Args:\n            value (float): value for IDD Field `elevation`\n                Unit: m\n                Default value: 0.0\n                value >= -1000.0\n                value < 9999.9\n                if `value` is None it will not be checked against the\n                specification and is assumed to be a missing value\n\n        Raises:\n            ValueError: if `value` is not a valid value\n\n        \"\"\"\n        if value is not None:\n            try:\n                value = float(value)\n            except ValueError:\n                raise ValueError('value {} need to be of type float '\n                                 'for field `elevation`'.format(value))\n            if value < -1000.0:\n                raise ValueError('value need to be greater or equal -1000.0 '\n                                 'for field `elevation`')\n            if value >= 9999.9:\n                raise ValueError('value need to be smaller 9999.9 '\n                                 'for field `elevation`')\n\n        self._elevation = value"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef export(self, top=True):\n        out = []\n        if top:\n            out.append(self._internal_name)\n        out.append(self._to_str(self.city))\n        out.append(self._to_str(self.state_province_region))\n        out.append(self._to_str(self.country))\n        out.append(self._to_str(self.source))\n        out.append(self._to_str(self.wmo))\n        out.append(self._to_str(self.latitude))\n        out.append(self._to_str(self.longitude))\n        out.append(self._to_str(self.timezone))\n        out.append(self._to_str(self.elevation))\n        return \",\".join(out)", "response": "Exports object to its string representation."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef read(self, vals):\n        i = 0\n        if len(vals[i]) == 0:\n            self.title_of_design_condition = None\n        else:\n            self.title_of_design_condition = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.unkown_field = None\n        else:\n            self.unkown_field = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.design_stat_heating = None\n        else:\n            self.design_stat_heating = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.coldestmonth = None\n        else:\n            self.coldestmonth = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.db996 = None\n        else:\n            self.db996 = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.db990 = None\n        else:\n            self.db990 = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.dp996 = None\n        else:\n            self.dp996 = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.hr_dp996 = None\n        else:\n            self.hr_dp996 = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.db_dp996 = None\n        else:\n            self.db_dp996 = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.dp990 = None\n        else:\n            self.dp990 = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.hr_dp990 = None\n        else:\n            self.hr_dp990 = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.db_dp990 = None\n        else:\n            self.db_dp990 = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.ws004c = None\n        else:\n            self.ws004c = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.db_ws004c = None\n        else:\n            self.db_ws004c = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.ws010c = None\n        else:\n            self.ws010c = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.db_ws010c = None\n        else:\n            self.db_ws010c = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.ws_db996 = None\n        else:\n            self.ws_db996 = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.wd_db996 = None\n        else:\n            self.wd_db996 = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.design_stat_cooling = None\n        else:\n            self.design_stat_cooling = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.hottestmonth = None\n        else:\n            self.hottestmonth = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.dbr = None\n        else:\n            self.dbr = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.db004 = None\n        else:\n            self.db004 = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.wb_db004 = None\n        else:\n            self.wb_db004 = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.db010 = None\n        else:\n            self.db010 = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.wb_db010 = None\n        else:\n            self.wb_db010 = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.db020 = None\n        else:\n            self.db020 = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.wb_db020 = None\n        else:\n            self.wb_db020 = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.wb004 = None\n        else:\n            self.wb004 = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.db_wb004 = None\n        else:\n            self.db_wb004 = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.wb010 = None\n        else:\n            self.wb010 = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.db_wb010 = None\n        else:\n            self.db_wb010 = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.wb020 = None\n        else:\n            self.wb020 = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.db_wb020 = None\n        else:\n            self.db_wb020 = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.ws_db004 = None\n        else:\n            self.ws_db004 = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.wd_db004 = None\n        else:\n            self.wd_db004 = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.dp004 = None\n        else:\n            self.dp004 = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.hr_dp004 = None\n        else:\n            self.hr_dp004 = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.db_dp004 = None\n        else:\n            self.db_dp004 = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.dp010 = None\n        else:\n            self.dp010 = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.hr_dp010 = None\n        else:\n            self.hr_dp010 = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.db_dp010 = None\n        else:\n            self.db_dp010 = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.dp020 = None\n        else:\n            self.dp020 = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.hr_dp020 = None\n        else:\n            self.hr_dp020 = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.db_dp020 = None\n        else:\n            self.db_dp020 = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.en004 = None\n        else:\n            self.en004 = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.db_en004 = None\n        else:\n            self.db_en004 = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.en010 = None\n        else:\n            self.en010 = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.db_en010 = None\n        else:\n            self.db_en010 = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.en020 = None\n        else:\n            self.en020 = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.db_en020 = None\n        else:\n            self.db_en020 = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.hrs_84_and_db12_8_or_20_6 = None\n        else:\n            self.hrs_84_and_db12_8_or_20_6 = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.design_stat_extremes = None\n        else:\n            self.design_stat_extremes = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.ws010 = None\n        else:\n            self.ws010 = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.ws025 = None\n        else:\n            self.ws025 = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.ws050 = None\n        else:\n            self.ws050 = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.wbmax = None\n        else:\n            self.wbmax = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.dbmin_mean = None\n        else:\n            self.dbmin_mean = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.dbmax_mean = None\n        else:\n            self.dbmax_mean = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.dbmin_stddev = None\n        else:\n            self.dbmin_stddev = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.dbmax_stddev = None\n        else:\n            self.dbmax_stddev = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.dbmin05years = None\n        else:\n            self.dbmin05years = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.dbmax05years = None\n        else:\n            self.dbmax05years = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.dbmin10years = None\n        else:\n            self.dbmin10years = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.dbmax10years = None\n        else:\n            self.dbmax10years = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.dbmin20years = None\n        else:\n            self.dbmin20years = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.dbmax20years = None\n        else:\n            self.dbmax20years = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.dbmin50years = None\n        else:\n            self.dbmin50years = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.dbmax50years = None\n        else:\n            self.dbmax50years = vals[i]\n        i += 1", "response": "Reads the values from the log file."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef title_of_design_condition(self, value=None):\n        if value is not None:\n            try:\n                value = str(value)\n            except ValueError:\n                raise ValueError(\n                    'value {} need to be of type str '\n                    'for field `title_of_design_condition`'.format(value))\n            if ',' in value:\n                raise ValueError('value should not contain a comma '\n                                 'for field `title_of_design_condition`')\n\n        self._title_of_design_condition = value", "response": "Corresponds to IDD Field title_of_design_condition"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncorrespond to IDD Field unkown_field Empty field in data.", "response": "def unkown_field(self, value=None):\n        \"\"\"Corresponds to IDD Field `unkown_field` Empty field in data.\n\n        Args:\n            value (str): value for IDD Field `unkown_field`\n                if `value` is None it will not be checked against the\n                specification and is assumed to be a missing value\n\n        Raises:\n            ValueError: if `value` is not a valid value\n\n        \"\"\"\n        if value is not None:\n            try:\n                value = str(value)\n            except ValueError:\n                raise ValueError('value {} need to be of type str '\n                                 'for field `unkown_field`'.format(value))\n            if ',' in value:\n                raise ValueError('value should not contain a comma '\n                                 'for field `unkown_field`')\n\n        self._unkown_field = value"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncorresponding to IDD Field design_stat_heating", "response": "def design_stat_heating(self, value=\"Heating\"):\n        \"\"\"Corresponds to IDD Field `design_stat_heating`\n\n        Args:\n            value (str): value for IDD Field `design_stat_heating`\n                Accepted values are:\n                      - Heating\n                Default value: Heating\n                if `value` is None it will not be checked against the\n                specification and is assumed to be a missing value\n\n        Raises:\n            ValueError: if `value` is not a valid value\n\n        \"\"\"\n        if value is not None:\n            try:\n                value = str(value)\n            except ValueError:\n                raise ValueError(\n                    'value {} need to be of type str '\n                    'for field `design_stat_heating`'.format(value))\n            if ',' in value:\n                raise ValueError('value should not contain a comma '\n                                 'for field `design_stat_heating`')\n            vals = set()\n            vals.add(\"Heating\")\n            if value not in vals:\n                raise ValueError('value {} is not an accepted value for '\n                                 'field `design_stat_heating`'.format(value))\n\n        self._design_stat_heating = value"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncorrespond to IDD Field coldestmonth", "response": "def coldestmonth(self, value=None):\n        \"\"\"Corresponds to IDD Field `coldestmonth`\n\n        Args:\n            value (int): value for IDD Field `coldestmonth`\n                value >= 1\n                value <= 12\n                if `value` is None it will not be checked against the\n                specification and is assumed to be a missing value\n\n        Raises:\n            ValueError: if `value` is not a valid value\n\n        \"\"\"\n        if value is not None:\n            try:\n                value = int(value)\n            except ValueError:\n                raise ValueError('value {} need to be of type int '\n                                 'for field `coldestmonth`'.format(value))\n            if value < 1:\n                raise ValueError('value need to be greater or equal 1 '\n                                 'for field `coldestmonth`')\n            if value > 12:\n                raise ValueError('value need to be smaller 12 '\n                                 'for field `coldestmonth`')\n\n        self._coldestmonth = value"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncorrespond to IDD Field db996 mean temperature corresponding to 99. 6% annual cumulative frequency of occurrence", "response": "def db996(self, value=None):\n        \"\"\"  Corresponds to IDD Field `db996`\n        Dry-bulb temperature corresponding to 99.6% annual cumulative\n        frequency of occurrence (cold conditions)\n\n        Args:\n            value (float): value for IDD Field `db996`\n                Unit: C\n                if `value` is None it will not be checked against the\n                specification and is assumed to be a missing value\n\n        Raises:\n            ValueError: if `value` is not a valid value\n        \"\"\"\n        if value is not None:\n            try:\n                value = float(value)\n            except ValueError:\n                raise ValueError('value {} need to be of type float '\n                                 'for field `db996`'.format(value))\n\n        self._db996 = value"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef db990(self, value=None):\n        if value is not None:\n            try:\n                value = float(value)\n            except ValueError:\n                raise ValueError('value {} need to be of type float '\n                                 'for field `db990`'.format(value))\n\n        self._db990 = value", "response": "Corresponds to IDD Field db990 mean temperature corresponding to 90. 0% annual cumulative\n        frequency of occurrence"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef dp996(self, value=None):\n        if value is not None:\n            try:\n                value = float(value)\n            except ValueError:\n                raise ValueError('value {} need to be of type float '\n                                 'for field `dp996`'.format(value))\n\n        self._dp996 = value", "response": "Corresponds to IDD Field dp996 Dew - point temperature corresponding to 99. 6% annual cumulative\n        frequency of occurrence"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncorresponding to IDD Field hr_dp996 humidity ratio calculated at standard atmospheric pressure pressure at elevation of station corresponding to 99. 6% annual cumulative frequency of occurrence corresponding to 99. 6% annual cumulative frequency of occurrence", "response": "def hr_dp996(self, value=None):\n        \"\"\"  Corresponds to IDD Field `hr_dp996`\n        humidity ratio, calculated at standard atmospheric pressure\n        at elevation of station, corresponding to\n        Dew-point temperature corresponding to 99.6% annual cumulative\n        frequency of occurrence (cold conditions)\n\n        Args:\n            value (float): value for IDD Field `hr_dp996`\n                if `value` is None it will not be checked against the\n                specification and is assumed to be a missing value\n\n        Raises:\n            ValueError: if `value` is not a valid value\n        \"\"\"\n        if value is not None:\n            try:\n                value = float(value)\n            except ValueError:\n                raise ValueError('value {} need to be of type float '\n                                 'for field `hr_dp996`'.format(value))\n\n        self._hr_dp996 = value"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef dp990(self, value=None):\n        if value is not None:\n            try:\n                value = float(value)\n            except ValueError:\n                raise ValueError('value {} need to be of type float '\n                                 'for field `dp990`'.format(value))\n\n        self._dp990 = value", "response": "Corresponds to IDD Field dp990 Dew - point temperature corresponding to 90. 0% annual cumulative\n        frequency of occurrence"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef hr_dp990(self, value=None):\n        if value is not None:\n            try:\n                value = float(value)\n            except ValueError:\n                raise ValueError('value {} need to be of type float '\n                                 'for field `hr_dp990`'.format(value))\n\n        self._hr_dp990 = value", "response": "Corresponds to IDD Field hr_dp990 humidity ratio corresponding to 7. 0% annual cumulative\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef ws004c(self, value=None):\n        if value is not None:\n            try:\n                value = float(value)\n            except ValueError:\n                raise ValueError('value {} need to be of type float '\n                                 'for field `ws004c`'.format(value))\n\n        self._ws004c = value", "response": "Corresponds to IDD Field ws004c Wind in Celsius"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncorrespond to IDD Field db_ws004c Mean coincident dry - bulb temperature corresponding to 0. 40% cumulative frequency for coldest month", "response": "def db_ws004c(self, value=None):\n        \"\"\"  Corresponds to IDD Field `db_ws004c`\n        Mean coincident dry-bulb temperature to wind speed corresponding to 0.40% cumulative frequency for coldest month\n\n        Args:\n            value (float): value for IDD Field `db_ws004c`\n                Unit: C\n                if `value` is None it will not be checked against the\n                specification and is assumed to be a missing value\n\n        Raises:\n            ValueError: if `value` is not a valid value\n        \"\"\"\n        if value is not None:\n            try:\n                value = float(value)\n            except ValueError:\n                raise ValueError('value {} need to be of type float '\n                                 'for field `db_ws004c`'.format(value))\n\n        self._db_ws004c = value"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef ws010c(self, value=None):\n        if value is not None:\n            try:\n                value = float(value)\n            except ValueError:\n                raise ValueError('value {} need to be of type float '\n                                 'for field `ws010c`'.format(value))\n\n        self._ws010c = value", "response": "Corresponds to IDD Field ws010c Wind speed corresponding to 1. 0% cumulative frequency\n        of occurrence for coldest month ; if not specified the value is used for the unit of occurrence for the IDD class."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef db_ws010c(self, value=None):\n        if value is not None:\n            try:\n                value = float(value)\n            except ValueError:\n                raise ValueError('value {} need to be of type float '\n                                 'for field `db_ws010c`'.format(value))\n\n        self._db_ws010c = value", "response": "Corresponds to IDD Field db_ws010c Mean coincident dry - bulb temperature corresponding to 1. 0% cumulative frequency for coldest month\n           "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef ws_db996(self, value=None):\n        if value is not None:\n            try:\n                value = float(value)\n            except ValueError:\n                raise ValueError('value {} need to be of type float '\n                                 'for field `ws_db996`'.format(value))\n\n        self._ws_db996 = value", "response": "Corresponds to IDD Field ws_db996 Mean wind speed coincident with 99. 6% dry - bulb temperature"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncorresponds to IDD Field wd_db996 Wind speed corresponding to mean wind speed coincident with 99. 6% dry - bulb temperature", "response": "def wd_db996(self, value=None):\n        \"\"\"  Corresponds to IDD Field `wd_db996`\n        most frequent wind direction corresponding to mean wind speed coincident with 99.6% dry-bulb temperature\n        degrees from north (east = 90 deg)\n\n        Args:\n            value (float): value for IDD Field `wd_db996`\n                Unit: deg\n                if `value` is None it will not be checked against the\n                specification and is assumed to be a missing value\n\n        Raises:\n            ValueError: if `value` is not a valid value\n        \"\"\"\n        if value is not None:\n            try:\n                value = float(value)\n            except ValueError:\n                raise ValueError('value {} need to be of type float '\n                                 'for field `wd_db996`'.format(value))\n\n        self._wd_db996 = value"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncorresponding to IDD Field design_stat_cooling", "response": "def design_stat_cooling(self, value=\"Cooling\"):\n        \"\"\"Corresponds to IDD Field `design_stat_cooling`\n\n        Args:\n            value (str): value for IDD Field `design_stat_cooling`\n                Accepted values are:\n                      - Cooling\n                Default value: Cooling\n                if `value` is None it will not be checked against the\n                specification and is assumed to be a missing value\n\n        Raises:\n            ValueError: if `value` is not a valid value\n\n        \"\"\"\n        if value is not None:\n            try:\n                value = str(value)\n            except ValueError:\n                raise ValueError(\n                    'value {} need to be of type str '\n                    'for field `design_stat_cooling`'.format(value))\n            if ',' in value:\n                raise ValueError('value should not contain a comma '\n                                 'for field `design_stat_cooling`')\n            vals = set()\n            vals.add(\"Cooling\")\n            if value not in vals:\n                raise ValueError('value {} is not an accepted value for '\n                                 'field `design_stat_cooling`'.format(value))\n\n        self._design_stat_cooling = value"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncorresponds to IDD Field dbr Daily temperature range for hottest and month.", "response": "def dbr(self, value=None):\n        \"\"\"Corresponds to IDD Field `dbr` Daily temperature range for hottest\n        month.\n\n        [defined as mean of the difference between daily maximum\n        and daily minimum dry-bulb temperatures for hottest month]\n\n        Args:\n            value (float): value for IDD Field `dbr`\n                Unit: C\n                if `value` is None it will not be checked against the\n                specification and is assumed to be a missing value\n\n        Raises:\n            ValueError: if `value` is not a valid value\n\n        \"\"\"\n        if value is not None:\n            try:\n                value = float(value)\n            except ValueError:\n                raise ValueError('value {} need to be of type float '\n                                 'for field `dbr`'.format(value))\n\n        self._dbr = value"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef db004(self, value=None):\n        if value is not None:\n            try:\n                value = float(value)\n            except ValueError:\n                raise ValueError('value {} need to be of type float '\n                                 'for field `db004`'.format(value))\n\n        self._db004 = value", "response": "Corresponds to IDD Field db004 mean coincident dry - bulb temperature corresponding to 0. 4% annual cumulative frequency of occurrence"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncorresponds to IDD Field wb_db004 mean coincident wet - bulb temperature to Dry - bulb temperature corresponding to 0. 4% annual cumulative frequency of occurrence", "response": "def wb_db004(self, value=None):\n        \"\"\"  Corresponds to IDD Field `wb_db004`\n        mean coincident wet-bulb temperature to\n        Dry-bulb temperature corresponding to 0.4% annual cumulative frequency of occurrence (warm conditions)\n\n        Args:\n            value (float): value for IDD Field `wb_db004`\n                Unit: C\n                if `value` is None it will not be checked against the\n                specification and is assumed to be a missing value\n\n        Raises:\n            ValueError: if `value` is not a valid value\n        \"\"\"\n        if value is not None:\n            try:\n                value = float(value)\n            except ValueError:\n                raise ValueError('value {} need to be of type float '\n                                 'for field `wb_db004`'.format(value))\n\n        self._wb_db004 = value"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef db010(self, value=None):\n        if value is not None:\n            try:\n                value = float(value)\n            except ValueError:\n                raise ValueError('value {} need to be of type float '\n                                 'for field `db010`'.format(value))\n\n        self._db010 = value", "response": "Corresponds to IDD Field db010 Dry - bulb temperature corresponding to 1. 0% annual cumulative frequency of occurrence"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef wb_db010(self, value=None):\n        if value is not None:\n            try:\n                value = float(value)\n            except ValueError:\n                raise ValueError('value {} need to be of type float '\n                                 'for field `wb_db010`'.format(value))\n\n        self._wb_db010 = value", "response": "Corresponds to IDD Field wb_db010 mean coincident wet - bulb temperature to\n        Dry - bulb temperature corresponding to 1. 0% annual cumulative frequency of occurrence"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncorresponding to IDD Field db020 mean coincident wet - bulb temperature to Dry - bulb temperature corresponding to 2. 0% annual cumulative frequency of occurrence", "response": "def db020(self, value=None):\n        \"\"\"  Corresponds to IDD Field `db020`\n        mean coincident wet-bulb temperature to\n        Dry-bulb temperature corresponding to 2.0% annual cumulative frequency of occurrence (warm conditions)\n\n        Args:\n            value (float): value for IDD Field `db020`\n                Unit: C\n                if `value` is None it will not be checked against the\n                specification and is assumed to be a missing value\n\n        Raises:\n            ValueError: if `value` is not a valid value\n        \"\"\"\n        if value is not None:\n            try:\n                value = float(value)\n            except ValueError:\n                raise ValueError('value {} need to be of type float '\n                                 'for field `db020`'.format(value))\n\n        self._db020 = value"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncorresponding to IDD Field wb_db020 mean coincident wet - bulb temperature to Dry - bulb temperature corresponding to 2. 0% annual cumulative frequency of occurrence", "response": "def wb_db020(self, value=None):\n        \"\"\"  Corresponds to IDD Field `wb_db020`\n        mean coincident wet-bulb temperature to\n        Dry-bulb temperature corresponding to 2.0% annual cumulative frequency of occurrence (warm conditions)\n\n        Args:\n            value (float): value for IDD Field `wb_db020`\n                Unit: C\n                if `value` is None it will not be checked against the\n                specification and is assumed to be a missing value\n\n        Raises:\n            ValueError: if `value` is not a valid value\n        \"\"\"\n        if value is not None:\n            try:\n                value = float(value)\n            except ValueError:\n                raise ValueError('value {} need to be of type float '\n                                 'for field `wb_db020`'.format(value))\n\n        self._wb_db020 = value"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef wb004(self, value=None):\n        if value is not None:\n            try:\n                value = float(value)\n            except ValueError:\n                raise ValueError('value {} need to be of type float '\n                                 'for field `wb004`'.format(value))\n\n        self._wb004 = value", "response": "Corresponds to IDD Field wb004 Wet - bulb temperature corresponding to 0. 4% annual cumulative frequency of occurrence\n       "}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef db_wb004(self, value=None):\n        if value is not None:\n            try:\n                value = float(value)\n            except ValueError:\n                raise ValueError('value {} need to be of type float '\n                                 'for field `db_wb004`'.format(value))\n\n        self._db_wb004 = value", "response": "Corresponds to IDD Field db_wb004 mean coincident dry - bulb temperature to\n        Wet - bulb temperature corresponding to 0. 4% annual cumulative frequency of occurrence\n       "}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef wb010(self, value=None):\n        if value is not None:\n            try:\n                value = float(value)\n            except ValueError:\n                raise ValueError('value {} need to be of type float '\n                                 'for field `wb010`'.format(value))\n\n        self._wb010 = value", "response": "Corresponds to IDD Field wb010 Wet - bulb temperature corresponding to 1. 0% annual cumulative frequency of occurrence\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef db_wb010(self, value=None):\n        if value is not None:\n            try:\n                value = float(value)\n            except ValueError:\n                raise ValueError('value {} need to be of type float '\n                                 'for field `db_wb010`'.format(value))\n\n        self._db_wb010 = value", "response": "Corresponds to IDD Field db_wb010 Wet - bulb temperature corresponding to 1. 0% annual cumulative frequency of occurrence\n       "}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncorresponding to IDD Field wb020 Wet - bulb temperature corresponding to 02. 0% annual cumulative frequency of occurrence", "response": "def wb020(self, value=None):\n        \"\"\"  Corresponds to IDD Field `wb020`\n        Wet-bulb temperature corresponding to 02.0% annual cumulative frequency of occurrence\n\n        Args:\n            value (float): value for IDD Field `wb020`\n                Unit: C\n                if `value` is None it will not be checked against the\n                specification and is assumed to be a missing value\n\n        Raises:\n            ValueError: if `value` is not a valid value\n        \"\"\"\n        if value is not None:\n            try:\n                value = float(value)\n            except ValueError:\n                raise ValueError('value {} need to be of type float '\n                                 'for field `wb020`'.format(value))\n\n        self._wb020 = value"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef db_wb020(self, value=None):\n        if value is not None:\n            try:\n                value = float(value)\n            except ValueError:\n                raise ValueError('value {} need to be of type float '\n                                 'for field `db_wb020`'.format(value))\n\n        self._db_wb020 = value", "response": "Corresponds to IDD Field db_wb020 Wet - bulb temperature to\n        Wet - bulb temperature corresponding to 2. 0% annual cumulative frequency of occurrence\n       "}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncorresponding to IDD Field ws_db004 mean wind speed coincident with 0. 4% dry - bulb temperature", "response": "def ws_db004(self, value=None):\n        \"\"\"  Corresponds to IDD Field `ws_db004`\n        Mean wind speed coincident with 0.4% dry-bulb temperature\n\n        Args:\n            value (float): value for IDD Field `ws_db004`\n                Unit: m/s\n                if `value` is None it will not be checked against the\n                specification and is assumed to be a missing value\n\n        Raises:\n            ValueError: if `value` is not a valid value\n        \"\"\"\n        if value is not None:\n            try:\n                value = float(value)\n            except ValueError:\n                raise ValueError('value {} need to be of type float '\n                                 'for field `ws_db004`'.format(value))\n\n        self._ws_db004 = value"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncorrespond to IDD Field wd_db004 mean wind speed coincident with 0. 4% dry - bulb temperature", "response": "def wd_db004(self, value=None):\n        \"\"\"  Corresponds to IDD Field `wd_db004`\n        corresponding most frequent wind direction\n        Mean wind speed coincident with 0.4% dry-bulb temperature\n        degrees true from north (east = 90 deg)\n\n        Args:\n            value (float): value for IDD Field `wd_db004`\n                Unit: deg\n                if `value` is None it will not be checked against the\n                specification and is assumed to be a missing value\n\n        Raises:\n            ValueError: if `value` is not a valid value\n        \"\"\"\n        if value is not None:\n            try:\n                value = float(value)\n            except ValueError:\n                raise ValueError('value {} need to be of type float '\n                                 'for field `wd_db004`'.format(value))\n\n        self._wd_db004 = value"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncorrespond to IDD Field dp004 Dew - point temperature corresponding to 0. 4% annual cumulative frequency of occurrence", "response": "def dp004(self, value=None):\n        \"\"\"  Corresponds to IDD Field `dp004`\n        Dew-point temperature corresponding to 0.4% annual cumulative frequency of occurrence\n\n        Args:\n            value (float): value for IDD Field `dp004`\n                Unit: C\n                if `value` is None it will not be checked against the\n                specification and is assumed to be a missing value\n\n        Raises:\n            ValueError: if `value` is not a valid value\n        \"\"\"\n        if value is not None:\n            try:\n                value = float(value)\n            except ValueError:\n                raise ValueError('value {} need to be of type float '\n                                 'for field `dp004`'.format(value))\n\n        self._dp004 = value"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncorrespond to IDD Field hr_dp004 humidity ratio corresponding to 0. 4% annual cumulative frequency of occurrence", "response": "def hr_dp004(self, value=None):\n        \"\"\"  Corresponds to IDD Field `hr_dp004`\n        humidity ratio corresponding to\n        Dew-point temperature corresponding to 0.4% annual cumulative frequency of occurrence\n\n        Args:\n            value (float): value for IDD Field `hr_dp004`\n                if `value` is None it will not be checked against the\n                specification and is assumed to be a missing value\n\n        Raises:\n            ValueError: if `value` is not a valid value\n        \"\"\"\n        if value is not None:\n            try:\n                value = float(value)\n            except ValueError:\n                raise ValueError('value {} need to be of type float '\n                                 'for field `hr_dp004`'.format(value))\n\n        self._hr_dp004 = value"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef db_dp004(self, value=None):\n        if value is not None:\n            try:\n                value = float(value)\n            except ValueError:\n                raise ValueError('value {} need to be of type float '\n                                 'for field `db_dp004`'.format(value))\n\n        self._db_dp004 = value", "response": "Corresponds to IDD Field db_dp004 mean coincident dry - bulb temperature to\n        Dew - point temperature corresponding to 0. 4% annual cumulative frequency of occurrence\n       "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncorresponding to IDD Field dp010 Dew - point temperature corresponding to 1. 0% annual cumulative frequency of occurrence", "response": "def dp010(self, value=None):\n        \"\"\"  Corresponds to IDD Field `dp010`\n        Dew-point temperature corresponding to 1.0% annual cumulative frequency of occurrence\n\n        Args:\n            value (float): value for IDD Field `dp010`\n                Unit: C\n                if `value` is None it will not be checked against the\n                specification and is assumed to be a missing value\n\n        Raises:\n            ValueError: if `value` is not a valid value\n        \"\"\"\n        if value is not None:\n            try:\n                value = float(value)\n            except ValueError:\n                raise ValueError('value {} need to be of type float '\n                                 'for field `dp010`'.format(value))\n\n        self._dp010 = value"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef db_dp010(self, value=None):\n        if value is not None:\n            try:\n                value = float(value)\n            except ValueError:\n                raise ValueError('value {} need to be of type float '\n                                 'for field `db_dp010`'.format(value))\n\n        self._db_dp010 = value", "response": "Corresponds to IDD Field db_dp010 mean coincident dry - bulb temperature to\n        Dew - point temperature corresponding to 1. 0% annual cumulative frequency of occurrence\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef dp020(self, value=None):\n        if value is not None:\n            try:\n                value = float(value)\n            except ValueError:\n                raise ValueError('value {} need to be of type float '\n                                 'for field `dp020`'.format(value))\n\n        self._dp020 = value", "response": "Corresponds to IDD Field dp020 Dew - point temperature corresponding to 2. 0% annual cumulative frequency of occurrence\n       "}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncorresponds to IDD Field hr_dp020 humidity ratio corresponding to 2. 0% annual cumulative frequency of occurrence Dew - point temperature corresponding to 2. 0% annual cumulative frequency of occurrence calculated at the standard atmospheric pressure at elevation of station", "response": "def hr_dp020(self, value=None):\n        \"\"\"  Corresponds to IDD Field `hr_dp020`\n        humidity ratio corresponding to\n        Dew-point temperature corresponding to 2.0% annual cumulative frequency of occurrence\n        calculated at the standard atmospheric pressure at elevation of station\n\n        Args:\n            value (float): value for IDD Field `hr_dp020`\n                if `value` is None it will not be checked against the\n                specification and is assumed to be a missing value\n\n        Raises:\n            ValueError: if `value` is not a valid value\n        \"\"\"\n        if value is not None:\n            try:\n                value = float(value)\n            except ValueError:\n                raise ValueError('value {} need to be of type float '\n                                 'for field `hr_dp020`'.format(value))\n\n        self._hr_dp020 = value"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncorresponding to IDD Field db_dp020 Mean coincident dry - bulb temperature to Dew - point temperature corresponding to 2. 0% annual cumulative frequency of occurrence", "response": "def db_dp020(self, value=None):\n        \"\"\"  Corresponds to IDD Field `db_dp020`\n        mean coincident dry-bulb temperature to\n        Dew-point temperature corresponding to 2.0% annual cumulative frequency of occurrence\n\n        Args:\n            value (float): value for IDD Field `db_dp020`\n                Unit: C\n                if `value` is None it will not be checked against the\n                specification and is assumed to be a missing value\n\n        Raises:\n            ValueError: if `value` is not a valid value\n        \"\"\"\n        if value is not None:\n            try:\n                value = float(value)\n            except ValueError:\n                raise ValueError('value {} need to be of type float '\n                                 'for field `db_dp020`'.format(value))\n\n        self._db_dp020 = value"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncorresponds to IDD Field en004 An annual cumulative frequency of occurrence to", "response": "def en004(self, value=None):\n        \"\"\"  Corresponds to IDD Field `en004`\n        mean coincident dry-bulb temperature to\n        Enthalpy corresponding to 0.4% annual cumulative frequency of occurrence\n\n        Args:\n            value (float): value for IDD Field `en004`\n                Unit: kJ/kg\n                if `value` is None it will not be checked against the\n                specification and is assumed to be a missing value\n\n        Raises:\n            ValueError: if `value` is not a valid value\n        \"\"\"\n        if value is not None:\n            try:\n                value = float(value)\n            except ValueError:\n                raise ValueError('value {} need to be of type float '\n                                 'for field `en004`'.format(value))\n\n        self._en004 = value"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncorrespond to IDD Field db_en004 mean coincident dry - bulb temperature to Enthalpy corresponding to 0. 4% annual cumulative frequency of occurrence", "response": "def db_en004(self, value=None):\n        \"\"\"  Corresponds to IDD Field `db_en004`\n        mean coincident dry-bulb temperature to\n        Enthalpy corresponding to 0.4% annual cumulative frequency of occurrence\n\n        Args:\n            value (float): value for IDD Field `db_en004`\n                Unit: C\n                if `value` is None it will not be checked against the\n                specification and is assumed to be a missing value\n\n        Raises:\n            ValueError: if `value` is not a valid value\n        \"\"\"\n        if value is not None:\n            try:\n                value = float(value)\n            except ValueError:\n                raise ValueError('value {} need to be of type float '\n                                 'for field `db_en004`'.format(value))\n\n        self._db_en004 = value"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef en010(self, value=None):\n        if value is not None:\n            try:\n                value = float(value)\n            except ValueError:\n                raise ValueError('value {} need to be of type float '\n                                 'for field `en010`'.format(value))\n\n        self._en010 = value", "response": "Corresponds to IDD Field en010 Enthalpy corresponding to 1. 0% annual cumulative frequency of occurrence of occurrence of the IDD resource."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncorresponds to IDD Field db_en010", "response": "def db_en010(self, value=None):\n        \"\"\"  Corresponds to IDD Field `db_en010`\n        mean coincident dry-bulb temperature to\n        Enthalpy corresponding to 1.0% annual cumulative frequency of occurrence\n\n        Args:\n            value (float): value for IDD Field `db_en010`\n                Unit: C\n                if `value` is None it will not be checked against the\n                specification and is assumed to be a missing value\n\n        Raises:\n            ValueError: if `value` is not a valid value\n        \"\"\"\n        if value is not None:\n            try:\n                value = float(value)\n            except ValueError:\n                raise ValueError('value {} need to be of type float '\n                                 'for field `db_en010`'.format(value))\n\n        self._db_en010 = value"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncorresponding to IDD Field en020 Enthalpy corresponding to 2. 0% annual cumulative frequency of occurrence of occurrence of the IDD resource.", "response": "def en020(self, value=None):\n        \"\"\"  Corresponds to IDD Field `en020`\n        mean coincident dry-bulb temperature to\n        Enthalpy corresponding to 2.0% annual cumulative frequency of occurrence\n\n        Args:\n            value (float): value for IDD Field `en020`\n                Unit: kJ/kg\n                if `value` is None it will not be checked against the\n                specification and is assumed to be a missing value\n\n        Raises:\n            ValueError: if `value` is not a valid value\n        \"\"\"\n        if value is not None:\n            try:\n                value = float(value)\n            except ValueError:\n                raise ValueError('value {} need to be of type float '\n                                 'for field `en020`'.format(value))\n\n        self._en020 = value"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef hrs_84_and_db12_8_or_20_6(self, value=None):\n        if value is not None:\n            try:\n                value = float(value)\n            except ValueError:\n                raise ValueError(\n                    'value {} need to be of type float '\n                    'for field `hrs_84_and_db12_8_or_20_6`'.format(value))\n\n        self._hrs_84_and_db12_8_or_20_6 = value", "response": "Corresponds to IDD Field hrs_84_and_db12_8_or_20_6"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncorresponding to IDD Field design_stat_extremes", "response": "def design_stat_extremes(self, value=\"Extremes\"):\n        \"\"\"Corresponds to IDD Field `design_stat_extremes`\n\n        Args:\n            value (str): value for IDD Field `design_stat_extremes`\n                Accepted values are:\n                      - Extremes\n                Default value: Extremes\n                if `value` is None it will not be checked against the\n                specification and is assumed to be a missing value\n\n        Raises:\n            ValueError: if `value` is not a valid value\n\n        \"\"\"\n        if value is not None:\n            try:\n                value = str(value)\n            except ValueError:\n                raise ValueError(\n                    'value {} need to be of type str '\n                    'for field `design_stat_extremes`'.format(value))\n            if ',' in value:\n                raise ValueError('value should not contain a comma '\n                                 'for field `design_stat_extremes`')\n            vals = set()\n            vals.add(\"Extremes\")\n            if value not in vals:\n                raise ValueError('value {} is not an accepted value for '\n                                 'field `design_stat_extremes`'.format(value))\n\n        self._design_stat_extremes = value"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef ws010(self, value=None):\n        if value is not None:\n            try:\n                value = float(value)\n            except ValueError:\n                raise ValueError('value {} need to be of type float '\n                                 'for field `ws010`'.format(value))\n\n        self._ws010 = value", "response": "Corresponds to IDD Field ws010 Wind speed corresponding to 1. 0% annual cumulative frequency of occurrence\n       "}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef ws025(self, value=None):\n        if value is not None:\n            try:\n                value = float(value)\n            except ValueError:\n                raise ValueError('value {} need to be of type float '\n                                 'for field `ws025`'.format(value))\n\n        self._ws025 = value", "response": "Corresponds to IDD Field ws025 Wind speed corresponding to 2. 5% annual cumulative frequency of occurrence\n       "}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncorresponds to IDD Field ws050 Wind speed corresponding 5. 0% annual cumulative frequency of occurrence", "response": "def ws050(self, value=None):\n        \"\"\"  Corresponds to IDD Field `ws050`\n        Wind speed corresponding 5.0% annual cumulative frequency of occurrence\n\n        Args:\n            value (float): value for IDD Field `ws050`\n                Unit: m/s\n                if `value` is None it will not be checked against the\n                specification and is assumed to be a missing value\n\n        Raises:\n            ValueError: if `value` is not a valid value\n        \"\"\"\n        if value is not None:\n            try:\n                value = float(value)\n            except ValueError:\n                raise ValueError('value {} need to be of type float '\n                                 'for field `ws050`'.format(value))\n\n        self._ws050 = value"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncorresponding to IDD Field wbmax Wet - bulb temperature", "response": "def wbmax(self, value=None):\n        \"\"\"  Corresponds to IDD Field `wbmax`\n        Extreme maximum wet-bulb temperature\n\n        Args:\n            value (float): value for IDD Field `wbmax`\n                Unit: C\n                if `value` is None it will not be checked against the\n                specification and is assumed to be a missing value\n\n        Raises:\n            ValueError: if `value` is not a valid value\n        \"\"\"\n        if value is not None:\n            try:\n                value = float(value)\n            except ValueError:\n                raise ValueError('value {} need to be of type float '\n                                 'for field `wbmax`'.format(value))\n\n        self._wbmax = value"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncorresponding to IDD Field dbmin_mean Mean of extreme annual minimum dry - bulb temperature", "response": "def dbmin_mean(self, value=None):\n        \"\"\"  Corresponds to IDD Field `dbmin_mean`\n        Mean of extreme annual minimum dry-bulb temperature\n\n        Args:\n            value (float): value for IDD Field `dbmin_mean`\n                Unit: C\n                if `value` is None it will not be checked against the\n                specification and is assumed to be a missing value\n\n        Raises:\n            ValueError: if `value` is not a valid value\n        \"\"\"\n        if value is not None:\n            try:\n                value = float(value)\n            except ValueError:\n                raise ValueError('value {} need to be of type float '\n                                 'for field `dbmin_mean`'.format(value))\n\n        self._dbmin_mean = value"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncorrespond to IDD Field dbmax_mean Mean of extreme annual maximum dry - bulb temperature of the resource.", "response": "def dbmax_mean(self, value=None):\n        \"\"\"  Corresponds to IDD Field `dbmax_mean`\n        Mean of extreme annual maximum dry-bulb temperature\n\n        Args:\n            value (float): value for IDD Field `dbmax_mean`\n                Unit: C\n                if `value` is None it will not be checked against the\n                specification and is assumed to be a missing value\n\n        Raises:\n            ValueError: if `value` is not a valid value\n        \"\"\"\n        if value is not None:\n            try:\n                value = float(value)\n            except ValueError:\n                raise ValueError('value {} need to be of type float '\n                                 'for field `dbmax_mean`'.format(value))\n\n        self._dbmax_mean = value"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef dbmin_stddev(self, value=None):\n        if value is not None:\n            try:\n                value = float(value)\n            except ValueError:\n                raise ValueError('value {} need to be of type float '\n                                 'for field `dbmin_stddev`'.format(value))\n\n        self._dbmin_stddev = value", "response": "Corresponds to IDD Field dbmin_stddev Standard deviation of extreme annual minimum dry - bulb temperature of the resource."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncorrespond to IDD Field dbmax_stddev Standard deviation of extreme annual maximum dry - bulb temperature of the resource.", "response": "def dbmax_stddev(self, value=None):\n        \"\"\"  Corresponds to IDD Field `dbmax_stddev`\n        Standard deviation of extreme annual maximum dry-bulb temperature\n\n        Args:\n            value (float): value for IDD Field `dbmax_stddev`\n                Unit: C\n                if `value` is None it will not be checked against the\n                specification and is assumed to be a missing value\n\n        Raises:\n            ValueError: if `value` is not a valid value\n        \"\"\"\n        if value is not None:\n            try:\n                value = float(value)\n            except ValueError:\n                raise ValueError('value {} need to be of type float '\n                                 'for field `dbmax_stddev`'.format(value))\n\n        self._dbmax_stddev = value"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncorresponds to IDD Field dbmin05years", "response": "def dbmin05years(self, value=None):\n        \"\"\"  Corresponds to IDD Field `dbmin05years`\n        5-year return period values for minimum extreme dry-bulb temperature\n\n        Args:\n            value (float): value for IDD Field `dbmin05years`\n                Unit: C\n                if `value` is None it will not be checked against the\n                specification and is assumed to be a missing value\n\n        Raises:\n            ValueError: if `value` is not a valid value\n        \"\"\"\n        if value is not None:\n            try:\n                value = float(value)\n            except ValueError:\n                raise ValueError('value {} need to be of type float '\n                                 'for field `dbmin05years`'.format(value))\n\n        self._dbmin05years = value"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef dbmax05years(self, value=None):\n        if value is not None:\n            try:\n                value = float(value)\n            except ValueError:\n                raise ValueError('value {} need to be of type float '\n                                 'for field `dbmax05years`'.format(value))\n\n        self._dbmax05years = value", "response": "Corresponds to IDD Field dbmax05years"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef dbmin10years(self, value=None):\n        if value is not None:\n            try:\n                value = float(value)\n            except ValueError:\n                raise ValueError('value {} need to be of type float '\n                                 'for field `dbmin10years`'.format(value))\n\n        self._dbmin10years = value", "response": "Corresponds to IDD Field dbmin10years 10 - year return period values for minimum extreme dry - bulb temperature\n       "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncorrespond to IDD Field dbmax10years 10 - year return period values for maximum extreme dry - bulb temperature", "response": "def dbmax10years(self, value=None):\n        \"\"\"  Corresponds to IDD Field `dbmax10years`\n        10-year return period values for maximum extreme dry-bulb temperature\n\n        Args:\n            value (float): value for IDD Field `dbmax10years`\n                Unit: C\n                if `value` is None it will not be checked against the\n                specification and is assumed to be a missing value\n\n        Raises:\n            ValueError: if `value` is not a valid value\n        \"\"\"\n        if value is not None:\n            try:\n                value = float(value)\n            except ValueError:\n                raise ValueError('value {} need to be of type float '\n                                 'for field `dbmax10years`'.format(value))\n\n        self._dbmax10years = value"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncorresponding to IDD Field dbmin20years 20 - year return period values for minimum extreme dry - bulb temperature", "response": "def dbmin20years(self, value=None):\n        \"\"\"  Corresponds to IDD Field `dbmin20years`\n        20-year return period values for minimum extreme dry-bulb temperature\n\n        Args:\n            value (float): value for IDD Field `dbmin20years`\n                Unit: C\n                if `value` is None it will not be checked against the\n                specification and is assumed to be a missing value\n\n        Raises:\n            ValueError: if `value` is not a valid value\n        \"\"\"\n        if value is not None:\n            try:\n                value = float(value)\n            except ValueError:\n                raise ValueError('value {} need to be of type float '\n                                 'for field `dbmin20years`'.format(value))\n\n        self._dbmin20years = value"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncorresponds to IDD Field dbmax20years 20 - year return period values for maximum extreme dry - bulb temperature", "response": "def dbmax20years(self, value=None):\n        \"\"\"  Corresponds to IDD Field `dbmax20years`\n        20-year return period values for maximum extreme dry-bulb temperature\n\n        Args:\n            value (float): value for IDD Field `dbmax20years`\n                Unit: C\n                if `value` is None it will not be checked against the\n                specification and is assumed to be a missing value\n\n        Raises:\n            ValueError: if `value` is not a valid value\n        \"\"\"\n        if value is not None:\n            try:\n                value = float(value)\n            except ValueError:\n                raise ValueError('value {} need to be of type float '\n                                 'for field `dbmax20years`'.format(value))\n\n        self._dbmax20years = value"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncorrespond to IDD Field dbmin50years", "response": "def dbmin50years(self, value=None):\n        \"\"\"  Corresponds to IDD Field `dbmin50years`\n        50-year return period values for minimum extreme dry-bulb temperature\n\n        Args:\n            value (float): value for IDD Field `dbmin50years`\n                Unit: C\n                if `value` is None it will not be checked against the\n                specification and is assumed to be a missing value\n\n        Raises:\n            ValueError: if `value` is not a valid value\n        \"\"\"\n        if value is not None:\n            try:\n                value = float(value)\n            except ValueError:\n                raise ValueError('value {} need to be of type float '\n                                 'for field `dbmin50years`'.format(value))\n\n        self._dbmin50years = value"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef dbmax50years(self, value=None):\n        if value is not None:\n            try:\n                value = float(value)\n            except ValueError:\n                raise ValueError('value {} need to be of type float '\n                                 'for field `dbmax50years`'.format(value))\n\n        self._dbmax50years = value", "response": "Corresponds to IDD Field dbmax50years"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nexport the current object to its string representation.", "response": "def export(self, top=True):\n        \"\"\"Exports object to its string representation.\n\n        Args:\n            top (bool):  if True appends `internal_name` before values.\n                All non list objects should be exported with value top=True,\n                all list objects, that are embedded in as fields inlist objects\n                should be exported with `top`=False\n\n        Returns:\n            str: The objects string representation\n\n        \"\"\"\n        out = []\n        if top:\n            out.append(self._internal_name)\n        out.append(self._to_str(self.title_of_design_condition))\n        out.append(self._to_str(self.unkown_field))\n        out.append(self._to_str(self.design_stat_heating))\n        out.append(self._to_str(self.coldestmonth))\n        out.append(self._to_str(self.db996))\n        out.append(self._to_str(self.db990))\n        out.append(self._to_str(self.dp996))\n        out.append(self._to_str(self.hr_dp996))\n        out.append(self._to_str(self.db_dp996))\n        out.append(self._to_str(self.dp990))\n        out.append(self._to_str(self.hr_dp990))\n        out.append(self._to_str(self.db_dp990))\n        out.append(self._to_str(self.ws004c))\n        out.append(self._to_str(self.db_ws004c))\n        out.append(self._to_str(self.ws010c))\n        out.append(self._to_str(self.db_ws010c))\n        out.append(self._to_str(self.ws_db996))\n        out.append(self._to_str(self.wd_db996))\n        out.append(self._to_str(self.design_stat_cooling))\n        out.append(self._to_str(self.hottestmonth))\n        out.append(self._to_str(self.dbr))\n        out.append(self._to_str(self.db004))\n        out.append(self._to_str(self.wb_db004))\n        out.append(self._to_str(self.db010))\n        out.append(self._to_str(self.wb_db010))\n        out.append(self._to_str(self.db020))\n        out.append(self._to_str(self.wb_db020))\n        out.append(self._to_str(self.wb004))\n        out.append(self._to_str(self.db_wb004))\n        out.append(self._to_str(self.wb010))\n        out.append(self._to_str(self.db_wb010))\n        out.append(self._to_str(self.wb020))\n        out.append(self._to_str(self.db_wb020))\n        out.append(self._to_str(self.ws_db004))\n        out.append(self._to_str(self.wd_db004))\n        out.append(self._to_str(self.dp004))\n        out.append(self._to_str(self.hr_dp004))\n        out.append(self._to_str(self.db_dp004))\n        out.append(self._to_str(self.dp010))\n        out.append(self._to_str(self.hr_dp010))\n        out.append(self._to_str(self.db_dp010))\n        out.append(self._to_str(self.dp020))\n        out.append(self._to_str(self.hr_dp020))\n        out.append(self._to_str(self.db_dp020))\n        out.append(self._to_str(self.en004))\n        out.append(self._to_str(self.db_en004))\n        out.append(self._to_str(self.en010))\n        out.append(self._to_str(self.db_en010))\n        out.append(self._to_str(self.en020))\n        out.append(self._to_str(self.db_en020))\n        out.append(self._to_str(self.hrs_84_and_db12_8_or_20_6))\n        out.append(self._to_str(self.design_stat_extremes))\n        out.append(self._to_str(self.ws010))\n        out.append(self._to_str(self.ws025))\n        out.append(self._to_str(self.ws050))\n        out.append(self._to_str(self.wbmax))\n        out.append(self._to_str(self.dbmin_mean))\n        out.append(self._to_str(self.dbmax_mean))\n        out.append(self._to_str(self.dbmin_stddev))\n        out.append(self._to_str(self.dbmax_stddev))\n        out.append(self._to_str(self.dbmin05years))\n        out.append(self._to_str(self.dbmax05years))\n        out.append(self._to_str(self.dbmin10years))\n        out.append(self._to_str(self.dbmax10years))\n        out.append(self._to_str(self.dbmin20years))\n        out.append(self._to_str(self.dbmax20years))\n        out.append(self._to_str(self.dbmin50years))\n        out.append(self._to_str(self.dbmax50years))\n        return \",\".join(out)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreads the values. and adds them to the object.", "response": "def read(self, vals):\n        \"\"\"Read values.\n\n        Args:\n            vals (list): list of strings representing values\n\n        \"\"\"\n        i = 0\n        count = int(vals[i])\n        i += 1\n        for _ in range(count):\n            obj = DesignCondition()\n            obj.read(vals[i:i + obj.field_count])\n            self.add_design_condition(obj)\n            i += obj.field_count"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreading values. Args: vals (list): list of strings representing values", "response": "def read(self, vals):\n        \"\"\"Read values.\n\n        Args:\n            vals (list): list of strings representing values\n\n        \"\"\"\n        i = 0\n        if len(vals[i]) == 0:\n            self.typical_or_extreme_period_name = None\n        else:\n            self.typical_or_extreme_period_name = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.typical_or_extreme_period_type = None\n        else:\n            self.typical_or_extreme_period_type = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.period_start_day = None\n        else:\n            self.period_start_day = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.period_end_day = None\n        else:\n            self.period_end_day = vals[i]\n        i += 1"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncorresponding to IDD Field typical_or_extreme_period_name", "response": "def typical_or_extreme_period_name(self, value=None):\n        \"\"\"Corresponds to IDD Field `typical_or_extreme_period_name`\n\n        Args:\n            value (str): value for IDD Field `typical_or_extreme_period_name`\n                if `value` is None it will not be checked against the\n                specification and is assumed to be a missing value\n\n        Raises:\n            ValueError: if `value` is not a valid value\n\n        \"\"\"\n        if value is not None:\n            try:\n                value = str(value)\n            except ValueError:\n                raise ValueError(\n                    'value {} need to be of type str '\n                    'for field `typical_or_extreme_period_name`'.format(value))\n            if ',' in value:\n                raise ValueError('value should not contain a comma '\n                                 'for field `typical_or_extreme_period_name`')\n\n        self._typical_or_extreme_period_name = value"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncorresponds to IDD Field typical_or_extreme_period_type", "response": "def typical_or_extreme_period_type(self, value=None):\n        \"\"\"Corresponds to IDD Field `typical_or_extreme_period_type`\n\n        Args:\n            value (str): value for IDD Field `typical_or_extreme_period_type`\n                if `value` is None it will not be checked against the\n                specification and is assumed to be a missing value\n\n        Raises:\n            ValueError: if `value` is not a valid value\n\n        \"\"\"\n        if value is not None:\n            try:\n                value = str(value)\n            except ValueError:\n                raise ValueError(\n                    'value {} need to be of type str '\n                    'for field `typical_or_extreme_period_type`'.format(value))\n            if ',' in value:\n                raise ValueError('value should not contain a comma '\n                                 'for field `typical_or_extreme_period_type`')\n\n        self._typical_or_extreme_period_type = value"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncorrespond to IDD Field period_start_day", "response": "def period_start_day(self, value=None):\n        \"\"\"Corresponds to IDD Field `period_start_day`\n\n        Args:\n            value (str): value for IDD Field `period_start_day`\n                if `value` is None it will not be checked against the\n                specification and is assumed to be a missing value\n\n        Raises:\n            ValueError: if `value` is not a valid value\n\n        \"\"\"\n        if value is not None:\n            try:\n                value = str(value)\n            except ValueError:\n                raise ValueError('value {} need to be of type str '\n                                 'for field `period_start_day`'.format(value))\n            if ',' in value:\n                raise ValueError('value should not contain a comma '\n                                 'for field `period_start_day`')\n\n        self._period_start_day = value"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef period_end_day(self, value=None):\n        if value is not None:\n            try:\n                value = str(value)\n            except ValueError:\n                raise ValueError('value {} need to be of type str '\n                                 'for field `period_end_day`'.format(value))\n            if ',' in value:\n                raise ValueError('value should not contain a comma '\n                                 'for field `period_end_day`')\n\n        self._period_end_day = value", "response": "Corresponds to IDD Field period_end_day"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nexport object to its string representation.", "response": "def export(self, top=True):\n        \"\"\"Exports object to its string representation.\n\n        Args:\n            top (bool):  if True appends `internal_name` before values.\n                All non list objects should be exported with value top=True,\n                all list objects, that are embedded in as fields inlist objects\n                should be exported with `top`=False\n\n        Returns:\n            str: The objects string representation\n\n        \"\"\"\n        out = []\n        if top:\n            out.append(self._internal_name)\n        out.append(self._to_str(self.typical_or_extreme_period_name))\n        out.append(self._to_str(self.typical_or_extreme_period_type))\n        out.append(self._to_str(self.period_start_day))\n        out.append(self._to_str(self.period_end_day))\n        return \",\".join(out)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nread the values. and adds them to the internal state.", "response": "def read(self, vals):\n        \"\"\"Read values.\n\n        Args:\n            vals (list): list of strings representing values\n\n        \"\"\"\n        i = 0\n        count = int(vals[i])\n        i += 1\n        for _ in range(count):\n            obj = TypicalOrExtremePeriod()\n            obj.read(vals[i:i + obj.field_count])\n            self.add_typical_or_extreme_period(obj)\n            i += obj.field_count"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nexport object to its string representation.", "response": "def export(self, top=True):\n        \"\"\"Exports object to its string representation.\n\n        Args:\n            top (bool):  if True appends `internal_name` before values.\n                All non list objects should be exported with value top=True,\n                all list objects, that are embedded in as fields inlist objects\n                should be exported with `top`=False\n\n        Returns:\n            str: The objects string representation\n\n        \"\"\"\n        out = []\n        if top:\n            out.append(self._internal_name)\n        out.append(str(len(self.typical_or_extreme_periods)))\n        for obj in self.typical_or_extreme_periods:\n            out.append(obj.export(top=False))\n        return \",\".join(out)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef read(self, vals):\n        i = 0\n        if len(vals[i]) == 0:\n            self.ground_temperature_depth = None\n        else:\n            self.ground_temperature_depth = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.depth_soil_conductivity = None\n        else:\n            self.depth_soil_conductivity = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.depth_soil_density = None\n        else:\n            self.depth_soil_density = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.depth_soil_specific_heat = None\n        else:\n            self.depth_soil_specific_heat = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.depth_january_average_ground_temperature = None\n        else:\n            self.depth_january_average_ground_temperature = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.depth_february_average_ground_temperature = None\n        else:\n            self.depth_february_average_ground_temperature = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.depth_march_average_ground_temperature = None\n        else:\n            self.depth_march_average_ground_temperature = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.depth_april_average_ground_temperature = None\n        else:\n            self.depth_april_average_ground_temperature = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.depth_may_average_ground_temperature = None\n        else:\n            self.depth_may_average_ground_temperature = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.depth_june_average_ground_temperature = None\n        else:\n            self.depth_june_average_ground_temperature = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.depth_july_average_ground_temperature = None\n        else:\n            self.depth_july_average_ground_temperature = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.depth_august_average_ground_temperature = None\n        else:\n            self.depth_august_average_ground_temperature = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.depth_september_average_ground_temperature = None\n        else:\n            self.depth_september_average_ground_temperature = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.depth_october_average_ground_temperature = None\n        else:\n            self.depth_october_average_ground_temperature = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.depth_november_average_ground_temperature = None\n        else:\n            self.depth_november_average_ground_temperature = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.depth_december_average_ground_temperature = None\n        else:\n            self.depth_december_average_ground_temperature = vals[i]\n        i += 1", "response": "Reads the values from the array and sets the attributes of the object."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef ground_temperature_depth(self, value=None):\n        if value is not None:\n            try:\n                value = float(value)\n            except ValueError:\n                raise ValueError(\n                    'value {} need to be of type float '\n                    'for field `ground_temperature_depth`'.format(value))\n\n        self._ground_temperature_depth = value", "response": "Corresponds to IDD Field ground_temperature_depth"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncorresponds to IDD Field depth_soil_conductivity", "response": "def depth_soil_conductivity(self, value=None):\n        \"\"\"Corresponds to IDD Field `depth_soil_conductivity`\n\n        Args:\n            value (float): value for IDD Field `depth_soil_conductivity`\n                Unit: W/m-K,\n                if `value` is None it will not be checked against the\n                specification and is assumed to be a missing value\n\n        Raises:\n            ValueError: if `value` is not a valid value\n\n        \"\"\"\n        if value is not None:\n            try:\n                value = float(value)\n            except ValueError:\n                raise ValueError(\n                    'value {} need to be of type float '\n                    'for field `depth_soil_conductivity`'.format(value))\n\n        self._depth_soil_conductivity = value"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef depth_soil_density(self, value=None):\n        if value is not None:\n            try:\n                value = float(value)\n            except ValueError:\n                raise ValueError(\n                    'value {} need to be of type float '\n                    'for field `depth_soil_density`'.format(value))\n\n        self._depth_soil_density = value", "response": "Corresponds to IDD Field depth_soil_density"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncorresponding to IDD Field depth_soil_specific_heat", "response": "def depth_soil_specific_heat(self, value=None):\n        \"\"\"Corresponds to IDD Field `depth_soil_specific_heat`\n\n        Args:\n            value (float): value for IDD Field `depth_soil_specific_heat`\n                Unit: J/kg-K,\n                if `value` is None it will not be checked against the\n                specification and is assumed to be a missing value\n\n        Raises:\n            ValueError: if `value` is not a valid value\n\n        \"\"\"\n        if value is not None:\n            try:\n                value = float(value)\n            except ValueError:\n                raise ValueError(\n                    'value {} need to be of type float '\n                    'for field `depth_soil_specific_heat`'.format(value))\n\n        self._depth_soil_specific_heat = value"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef depth_january_average_ground_temperature(self, value=None):\n        if value is not None:\n            try:\n                value = float(value)\n            except ValueError:\n                raise ValueError(\n                    'value {} need to be of type float '\n                    'for field `depth_january_average_ground_temperature`'.format(value))\n\n        self._depth_january_average_ground_temperature = value", "response": "Corresponds to IDD Field depth_january_average_ground_temperature"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef depth_february_average_ground_temperature(self, value=None):\n        if value is not None:\n            try:\n                value = float(value)\n            except ValueError:\n                raise ValueError(\n                    'value {} need to be of type float '\n                    'for field `depth_february_average_ground_temperature`'.format(value))\n\n        self._depth_february_average_ground_temperature = value", "response": "Corresponds to IDD Field depth_february_average_ground_temperature"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncorresponds to IDD Field depth_march_average_ground_temperature", "response": "def depth_march_average_ground_temperature(self, value=None):\n        \"\"\"Corresponds to IDD Field `depth_march_average_ground_temperature`\n\n        Args:\n            value (float): value for IDD Field `depth_march_average_ground_temperature`\n                Unit: C\n                if `value` is None it will not be checked against the\n                specification and is assumed to be a missing value\n\n        Raises:\n            ValueError: if `value` is not a valid value\n\n        \"\"\"\n        if value is not None:\n            try:\n                value = float(value)\n            except ValueError:\n                raise ValueError(\n                    'value {} need to be of type float '\n                    'for field `depth_march_average_ground_temperature`'.format(value))\n\n        self._depth_march_average_ground_temperature = value"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncorresponding to IDD Field depth_april_average_ground_temperature", "response": "def depth_april_average_ground_temperature(self, value=None):\n        \"\"\"Corresponds to IDD Field `depth_april_average_ground_temperature`\n\n        Args:\n            value (float): value for IDD Field `depth_april_average_ground_temperature`\n                Unit: C\n                if `value` is None it will not be checked against the\n                specification and is assumed to be a missing value\n\n        Raises:\n            ValueError: if `value` is not a valid value\n\n        \"\"\"\n        if value is not None:\n            try:\n                value = float(value)\n            except ValueError:\n                raise ValueError(\n                    'value {} need to be of type float '\n                    'for field `depth_april_average_ground_temperature`'.format(value))\n\n        self._depth_april_average_ground_temperature = value"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef depth_may_average_ground_temperature(self, value=None):\n        if value is not None:\n            try:\n                value = float(value)\n            except ValueError:\n                raise ValueError(\n                    'value {} need to be of type float '\n                    'for field `depth_may_average_ground_temperature`'.format(value))\n\n        self._depth_may_average_ground_temperature = value", "response": "Corresponds to IDD Field depth_may_average_ground_temperature"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncorresponds to IDD Field depth_june_average_ground_temperature", "response": "def depth_june_average_ground_temperature(self, value=None):\n        \"\"\"Corresponds to IDD Field `depth_june_average_ground_temperature`\n\n        Args:\n            value (float): value for IDD Field `depth_june_average_ground_temperature`\n                Unit: C\n                if `value` is None it will not be checked against the\n                specification and is assumed to be a missing value\n\n        Raises:\n            ValueError: if `value` is not a valid value\n\n        \"\"\"\n        if value is not None:\n            try:\n                value = float(value)\n            except ValueError:\n                raise ValueError(\n                    'value {} need to be of type float '\n                    'for field `depth_june_average_ground_temperature`'.format(value))\n\n        self._depth_june_average_ground_temperature = value"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef depth_july_average_ground_temperature(self, value=None):\n        if value is not None:\n            try:\n                value = float(value)\n            except ValueError:\n                raise ValueError(\n                    'value {} need to be of type float '\n                    'for field `depth_july_average_ground_temperature`'.format(value))\n\n        self._depth_july_average_ground_temperature = value", "response": "Corresponds to IDD Field depth_july_average_ground_temperature"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncorrespond to IDD Field depth_august_average_ground_temperature", "response": "def depth_august_average_ground_temperature(self, value=None):\n        \"\"\"Corresponds to IDD Field `depth_august_average_ground_temperature`\n\n        Args:\n            value (float): value for IDD Field `depth_august_average_ground_temperature`\n                Unit: C\n                if `value` is None it will not be checked against the\n                specification and is assumed to be a missing value\n\n        Raises:\n            ValueError: if `value` is not a valid value\n\n        \"\"\"\n        if value is not None:\n            try:\n                value = float(value)\n            except ValueError:\n                raise ValueError(\n                    'value {} need to be of type float '\n                    'for field `depth_august_average_ground_temperature`'.format(value))\n\n        self._depth_august_average_ground_temperature = value"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef depth_september_average_ground_temperature(self, value=None):\n        if value is not None:\n            try:\n                value = float(value)\n            except ValueError:\n                raise ValueError(\n                    'value {} need to be of type float '\n                    'for field `depth_september_average_ground_temperature`'.format(value))\n\n        self._depth_september_average_ground_temperature = value", "response": "Corresponds to IDD Field depth_september_average_ground_temperature"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef depth_october_average_ground_temperature(self, value=None):\n        if value is not None:\n            try:\n                value = float(value)\n            except ValueError:\n                raise ValueError(\n                    'value {} need to be of type float '\n                    'for field `depth_october_average_ground_temperature`'.format(value))\n\n        self._depth_october_average_ground_temperature = value", "response": "Corresponds to IDD Field depth_october_average_ground_temperature"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef depth_november_average_ground_temperature(self, value=None):\n        if value is not None:\n            try:\n                value = float(value)\n            except ValueError:\n                raise ValueError(\n                    'value {} need to be of type float '\n                    'for field `depth_november_average_ground_temperature`'.format(value))\n\n        self._depth_november_average_ground_temperature = value", "response": "Corresponds to IDD Field depth_november_average_ground_temperature"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef depth_december_average_ground_temperature(self, value=None):\n        if value is not None:\n            try:\n                value = float(value)\n            except ValueError:\n                raise ValueError(\n                    'value {} need to be of type float '\n                    'for field `depth_december_average_ground_temperature`'.format(value))\n\n        self._depth_december_average_ground_temperature = value", "response": "Corresponds to IDD Field depth_december_average_ground_temperature"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nexport the current object to its string representation.", "response": "def export(self, top=True):\n        \"\"\"Exports object to its string representation.\n\n        Args:\n            top (bool):  if True appends `internal_name` before values.\n                All non list objects should be exported with value top=True,\n                all list objects, that are embedded in as fields inlist objects\n                should be exported with `top`=False\n\n        Returns:\n            str: The objects string representation\n\n        \"\"\"\n        out = []\n        if top:\n            out.append(self._internal_name)\n        out.append(self._to_str(self.ground_temperature_depth))\n        out.append(self._to_str(self.depth_soil_conductivity))\n        out.append(self._to_str(self.depth_soil_density))\n        out.append(self._to_str(self.depth_soil_specific_heat))\n        out.append(self._to_str(self.depth_january_average_ground_temperature))\n        out.append(\n            self._to_str(\n                self.depth_february_average_ground_temperature))\n        out.append(self._to_str(self.depth_march_average_ground_temperature))\n        out.append(self._to_str(self.depth_april_average_ground_temperature))\n        out.append(self._to_str(self.depth_may_average_ground_temperature))\n        out.append(self._to_str(self.depth_june_average_ground_temperature))\n        out.append(self._to_str(self.depth_july_average_ground_temperature))\n        out.append(self._to_str(self.depth_august_average_ground_temperature))\n        out.append(\n            self._to_str(\n                self.depth_september_average_ground_temperature))\n        out.append(self._to_str(self.depth_october_average_ground_temperature))\n        out.append(\n            self._to_str(\n                self.depth_november_average_ground_temperature))\n        out.append(\n            self._to_str(\n                self.depth_december_average_ground_temperature))\n        return \",\".join(out)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreading the values. and adds them to the object.", "response": "def read(self, vals):\n        \"\"\"Read values.\n\n        Args:\n            vals (list): list of strings representing values\n\n        \"\"\"\n        i = 0\n        count = int(vals[i])\n        i += 1\n        for _ in range(count):\n            obj = GroundTemperature()\n            obj.read(vals[i:i + obj.field_count])\n            self.add_ground_temperature(obj)\n            i += obj.field_count"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef read(self, vals):\n        i = 0\n        if len(vals[i]) == 0:\n            self.holiday_name = None\n        else:\n            self.holiday_name = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.holiday_day = None\n        else:\n            self.holiday_day = vals[i]\n        i += 1", "response": "Reads the values.\n            self. holiday_name and self. holiday_day from the list of strings representing values\n\n       ."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef holiday_name(self, value=None):\n        if value is not None:\n            try:\n                value = str(value)\n            except ValueError:\n                raise ValueError('value {} need to be of type str '\n                                 'for field `holiday_name`'.format(value))\n            if ',' in value:\n                raise ValueError('value should not contain a comma '\n                                 'for field `holiday_name`')\n\n        self._holiday_name = value", "response": "Corresponds to IDD Field holiday_name"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef holiday_day(self, value=None):\n        if value is not None:\n            try:\n                value = str(value)\n            except ValueError:\n                raise ValueError('value {} need to be of type str '\n                                 'for field `holiday_day`'.format(value))\n            if ',' in value:\n                raise ValueError('value should not contain a comma '\n                                 'for field `holiday_day`')\n\n        self._holiday_day = value", "response": "Corresponds to IDD Field holiday_day"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nexports object to its string representation.", "response": "def export(self, top=True):\n        \"\"\"Exports object to its string representation.\n\n        Args:\n            top (bool):  if True appends `internal_name` before values.\n                All non list objects should be exported with value top=True,\n                all list objects, that are embedded in as fields inlist objects\n                should be exported with `top`=False\n\n        Returns:\n            str: The objects string representation\n\n        \"\"\"\n        out = []\n        if top:\n            out.append(self._internal_name)\n        out.append(self._to_str(self.holiday_name))\n        out.append(self._to_str(self.holiday_day))\n        return \",\".join(out)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef read(self, vals):\n        i = 0\n        if len(vals[i]) == 0:\n            self.leapyear_observed = None\n        else:\n            self.leapyear_observed = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.daylight_saving_start_day = None\n        else:\n            self.daylight_saving_start_day = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.daylight_saving_end_day = None\n        else:\n            self.daylight_saving_end_day = vals[i]\n        i += 1\n        count = int(vals[i])\n        i += 1\n        for _ in range(count):\n            obj = Holiday()\n            obj.read(vals[i:i + obj.field_count])\n            self.add_holiday(obj)\n            i += obj.field_count", "response": "Read values.\n\n        Args:\n            vals (list): list of strings representing values"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncorresponds to IDD Field leapyear_observed", "response": "def leapyear_observed(self, value=None):\n        \"\"\"Corresponds to IDD Field `leapyear_observed` Yes if Leap Year will\n        be observed for this file No if Leap Year days (29 Feb) should be\n        ignored in this file.\n\n        Args:\n            value (str): value for IDD Field `leapyear_observed`\n                Accepted values are:\n                      - Yes\n                      - No\n                if `value` is None it will not be checked against the\n                specification and is assumed to be a missing value\n\n        Raises:\n            ValueError: if `value` is not a valid value\n\n        \"\"\"\n        if value is not None:\n            try:\n                value = str(value)\n            except ValueError:\n                raise ValueError('value {} need to be of type str '\n                                 'for field `leapyear_observed`'.format(value))\n            if ',' in value:\n                raise ValueError('value should not contain a comma '\n                                 'for field `leapyear_observed`')\n            vals = set()\n            vals.add(\"Yes\")\n            vals.add(\"No\")\n            if value not in vals:\n                raise ValueError('value {} is not an accepted value for '\n                                 'field `leapyear_observed`'.format(value))\n\n        self._leapyear_observed = value"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef daylight_saving_start_day(self, value=None):\n        if value is not None:\n            try:\n                value = str(value)\n            except ValueError:\n                raise ValueError(\n                    'value {} need to be of type str '\n                    'for field `daylight_saving_start_day`'.format(value))\n            if ',' in value:\n                raise ValueError('value should not contain a comma '\n                                 'for field `daylight_saving_start_day`')\n\n        self._daylight_saving_start_day = value", "response": "Corresponds to IDD Field daylight_saving_start_day"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncorresponding to IDD Field daylight_saving_end_day", "response": "def daylight_saving_end_day(self, value=None):\n        \"\"\"Corresponds to IDD Field `daylight_saving_end_day`\n\n        Args:\n            value (str): value for IDD Field `daylight_saving_end_day`\n                if `value` is None it will not be checked against the\n                specification and is assumed to be a missing value\n\n        Raises:\n            ValueError: if `value` is not a valid value\n\n        \"\"\"\n        if value is not None:\n            try:\n                value = str(value)\n            except ValueError:\n                raise ValueError(\n                    'value {} need to be of type str '\n                    'for field `daylight_saving_end_day`'.format(value))\n            if ',' in value:\n                raise ValueError('value should not contain a comma '\n                                 'for field `daylight_saving_end_day`')\n\n        self._daylight_saving_end_day = value"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef export(self, top=True):\n        out = []\n        if top:\n            out.append(self._internal_name)\n        out.append(self._to_str(self.leapyear_observed))\n        out.append(self._to_str(self.daylight_saving_start_day))\n        out.append(self._to_str(self.daylight_saving_end_day))\n        out.append(str(len(self.holidays)))\n        for obj in self.holidays:\n            out.append(obj.export(top=False))\n        return \",\".join(out)", "response": "Exports object to its string representation."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nread the values. and sets the comments_1 attribute of the object.", "response": "def read(self, vals):\n        \"\"\"Read values.\n\n        Args:\n            vals (list): list of strings representing values\n\n        \"\"\"\n        i = 0\n        if len(vals[i]) == 0:\n            self.comments_1 = None\n        else:\n            self.comments_1 = vals[i]\n        i += 1"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncorrespond to IDD Field comments_1", "response": "def comments_1(self, value=None):\n        \"\"\"Corresponds to IDD Field `comments_1`\n\n        Args:\n            value (str): value for IDD Field `comments_1`\n                if `value` is None it will not be checked against the\n                specification and is assumed to be a missing value\n\n        Raises:\n            ValueError: if `value` is not a valid value\n\n        \"\"\"\n        if value is not None:\n            try:\n                value = str(value)\n            except ValueError:\n                raise ValueError('value {} need to be of type str '\n                                 'for field `comments_1`'.format(value))\n            if ',' in value:\n                raise ValueError('value should not contain a comma '\n                                 'for field `comments_1`')\n\n        self._comments_1 = value"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nread the values. and sets the comments_2 attribute of the object.", "response": "def read(self, vals):\n        \"\"\"Read values.\n\n        Args:\n            vals (list): list of strings representing values\n\n        \"\"\"\n        i = 0\n        if len(vals[i]) == 0:\n            self.comments_2 = None\n        else:\n            self.comments_2 = vals[i]\n        i += 1"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncorresponding to IDD Field comments_2", "response": "def comments_2(self, value=None):\n        \"\"\"Corresponds to IDD Field `comments_2`\n\n        Args:\n            value (str): value for IDD Field `comments_2`\n                if `value` is None it will not be checked against the\n                specification and is assumed to be a missing value\n\n        Raises:\n            ValueError: if `value` is not a valid value\n\n        \"\"\"\n        if value is not None:\n            try:\n                value = str(value)\n            except ValueError:\n                raise ValueError('value {} need to be of type str '\n                                 'for field `comments_2`'.format(value))\n            if ',' in value:\n                raise ValueError('value should not contain a comma '\n                                 'for field `comments_2`')\n\n        self._comments_2 = value"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nexports object to its string representation.", "response": "def export(self, top=True):\n        \"\"\"Exports object to its string representation.\n\n        Args:\n            top (bool):  if True appends `internal_name` before values.\n                All non list objects should be exported with value top=True,\n                all list objects, that are embedded in as fields inlist objects\n                should be exported with `top`=False\n\n        Returns:\n            str: The objects string representation\n\n        \"\"\"\n        out = []\n        if top:\n            out.append(self._internal_name)\n        out.append(self._to_str(self.comments_2))\n        return \",\".join(out)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nread the values from the list of strings representing values .", "response": "def read(self, vals):\n        \"\"\"Read values.\n\n        Args:\n            vals (list): list of strings representing values\n\n        \"\"\"\n        i = 0\n        if len(vals[i]) == 0:\n            self.number_of_records_per_hour = None\n        else:\n            self.number_of_records_per_hour = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.data_period_name_or_description = None\n        else:\n            self.data_period_name_or_description = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.data_period_start_day_of_week = None\n        else:\n            self.data_period_start_day_of_week = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.data_period_start_day = None\n        else:\n            self.data_period_start_day = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.data_period_end_day = None\n        else:\n            self.data_period_end_day = vals[i]\n        i += 1"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef number_of_records_per_hour(self, value=None):\n        if value is not None:\n            try:\n                value = int(value)\n            except ValueError:\n                raise ValueError(\n                    'value {} need to be of type int '\n                    'for field `number_of_records_per_hour`'.format(value))\n\n        self._number_of_records_per_hour = value", "response": "Corresponds to IDD Field number_of_records_per_hour"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncorresponds to IDD Field data_period_name_or_description", "response": "def data_period_name_or_description(self, value=None):\n        \"\"\"Corresponds to IDD Field `data_period_name_or_description`\n\n        Args:\n            value (str): value for IDD Field `data_period_name_or_description`\n                if `value` is None it will not be checked against the\n                specification and is assumed to be a missing value\n\n        Raises:\n            ValueError: if `value` is not a valid value\n\n        \"\"\"\n        if value is not None:\n            try:\n                value = str(value)\n            except ValueError:\n                raise ValueError(\n                    'value {} need to be of type str '\n                    'for field `data_period_name_or_description`'.format(value))\n            if ',' in value:\n                raise ValueError('value should not contain a comma '\n                                 'for field `data_period_name_or_description`')\n\n        self._data_period_name_or_description = value"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncorresponds to IDD Field data_period_start_day_of_week", "response": "def data_period_start_day_of_week(self, value=None):\n        \"\"\"Corresponds to IDD Field `data_period_start_day_of_week`\n\n        Args:\n            value (str): value for IDD Field `data_period_start_day_of_week`\n                Accepted values are:\n                      - Sunday\n                      - Monday\n                      - Tuesday\n                      - Wednesday\n                      - Thursday\n                      - Friday\n                      - Saturday\n                if `value` is None it will not be checked against the\n                specification and is assumed to be a missing value\n\n        Raises:\n            ValueError: if `value` is not a valid value\n\n        \"\"\"\n        if value is not None:\n            try:\n                value = str(value)\n            except ValueError:\n                raise ValueError(\n                    'value {} need to be of type str '\n                    'for field `data_period_start_day_of_week`'.format(value))\n            if ',' in value:\n                raise ValueError('value should not contain a comma '\n                                 'for field `data_period_start_day_of_week`')\n            vals = set()\n            vals.add(\"Sunday\")\n            vals.add(\"Monday\")\n            vals.add(\"Tuesday\")\n            vals.add(\"Wednesday\")\n            vals.add(\"Thursday\")\n            vals.add(\"Friday\")\n            vals.add(\"Saturday\")\n            if value not in vals:\n                raise ValueError(\n                    'value {} is not an accepted value for '\n                    'field `data_period_start_day_of_week`'.format(value))\n\n        self._data_period_start_day_of_week = value"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncorresponds to IDD Field data_period_start_day", "response": "def data_period_start_day(self, value=None):\n        \"\"\"Corresponds to IDD Field `data_period_start_day`\n\n        Args:\n            value (str): value for IDD Field `data_period_start_day`\n                if `value` is None it will not be checked against the\n                specification and is assumed to be a missing value\n\n        Raises:\n            ValueError: if `value` is not a valid value\n\n        \"\"\"\n        if value is not None:\n            try:\n                value = str(value)\n            except ValueError:\n                raise ValueError(\n                    'value {} need to be of type str '\n                    'for field `data_period_start_day`'.format(value))\n            if ',' in value:\n                raise ValueError('value should not contain a comma '\n                                 'for field `data_period_start_day`')\n\n        self._data_period_start_day = value"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncorresponds to IDD Field data_period_end_day", "response": "def data_period_end_day(self, value=None):\n        \"\"\"Corresponds to IDD Field `data_period_end_day`\n\n        Args:\n            value (str): value for IDD Field `data_period_end_day`\n                if `value` is None it will not be checked against the\n                specification and is assumed to be a missing value\n\n        Raises:\n            ValueError: if `value` is not a valid value\n\n        \"\"\"\n        if value is not None:\n            try:\n                value = str(value)\n            except ValueError:\n                raise ValueError(\n                    'value {} need to be of type str '\n                    'for field `data_period_end_day`'.format(value))\n            if ',' in value:\n                raise ValueError('value should not contain a comma '\n                                 'for field `data_period_end_day`')\n\n        self._data_period_end_day = value"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nexporting the object to its string representation.", "response": "def export(self, top=True):\n        \"\"\"Exports object to its string representation.\n\n        Args:\n            top (bool):  if True appends `internal_name` before values.\n                All non list objects should be exported with value top=True,\n                all list objects, that are embedded in as fields inlist objects\n                should be exported with `top`=False\n\n        Returns:\n            str: The objects string representation\n\n        \"\"\"\n        out = []\n        if top:\n            out.append(self._internal_name)\n        out.append(self._to_str(self.number_of_records_per_hour))\n        out.append(self._to_str(self.data_period_name_or_description))\n        out.append(self._to_str(self.data_period_start_day_of_week))\n        out.append(self._to_str(self.data_period_start_day))\n        out.append(self._to_str(self.data_period_end_day))\n        return \",\".join(out)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreads the values. and adds them to the internal object.", "response": "def read(self, vals):\n        \"\"\"Read values.\n\n        Args:\n            vals (list): list of strings representing values\n\n        \"\"\"\n        i = 0\n        count = int(vals[i])\n        i += 1\n        for _ in range(count):\n            obj = DataPeriod()\n            obj.read(vals[i:i + obj.field_count])\n            self.add_data_period(obj)\n            i += obj.field_count"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreads the values from the specified list of strings representing values in the current locale.", "response": "def read(self, vals):\n        \"\"\"Read values.\n\n        Args:\n            vals (list): list of strings representing values\n\n        \"\"\"\n        i = 0\n        if len(vals[i]) == 0:\n            self.year = None\n        else:\n            self.year = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.month = None\n        else:\n            self.month = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.day = None\n        else:\n            self.day = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.hour = None\n        else:\n            self.hour = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.minute = None\n        else:\n            self.minute = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.data_source_and_uncertainty_flags = None\n        else:\n            self.data_source_and_uncertainty_flags = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.dry_bulb_temperature = None\n        else:\n            self.dry_bulb_temperature = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.dew_point_temperature = None\n        else:\n            self.dew_point_temperature = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.relative_humidity = None\n        else:\n            self.relative_humidity = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.atmospheric_station_pressure = None\n        else:\n            self.atmospheric_station_pressure = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.extraterrestrial_horizontal_radiation = None\n        else:\n            self.extraterrestrial_horizontal_radiation = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.extraterrestrial_direct_normal_radiation = None\n        else:\n            self.extraterrestrial_direct_normal_radiation = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.horizontal_infrared_radiation_intensity = None\n        else:\n            self.horizontal_infrared_radiation_intensity = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.global_horizontal_radiation = None\n        else:\n            self.global_horizontal_radiation = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.direct_normal_radiation = None\n        else:\n            self.direct_normal_radiation = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.diffuse_horizontal_radiation = None\n        else:\n            self.diffuse_horizontal_radiation = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.global_horizontal_illuminance = None\n        else:\n            self.global_horizontal_illuminance = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.direct_normal_illuminance = None\n        else:\n            self.direct_normal_illuminance = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.diffuse_horizontal_illuminance = None\n        else:\n            self.diffuse_horizontal_illuminance = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.zenith_luminance = None\n        else:\n            self.zenith_luminance = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.wind_direction = None\n        else:\n            self.wind_direction = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.wind_speed = None\n        else:\n            self.wind_speed = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.total_sky_cover = None\n        else:\n            self.total_sky_cover = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.opaque_sky_cover = None\n        else:\n            self.opaque_sky_cover = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.visibility = None\n        else:\n            self.visibility = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.ceiling_height = None\n        else:\n            self.ceiling_height = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.present_weather_observation = None\n        else:\n            self.present_weather_observation = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.present_weather_codes = None\n        else:\n            self.present_weather_codes = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.precipitable_water = None\n        else:\n            self.precipitable_water = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.aerosol_optical_depth = None\n        else:\n            self.aerosol_optical_depth = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.snow_depth = None\n        else:\n            self.snow_depth = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.days_since_last_snowfall = None\n        else:\n            self.days_since_last_snowfall = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.albedo = None\n        else:\n            self.albedo = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.liquid_precipitation_depth = None\n        else:\n            self.liquid_precipitation_depth = vals[i]\n        i += 1\n        if len(vals[i]) == 0:\n            self.liquid_precipitation_quantity = None\n        else:\n            self.liquid_precipitation_quantity = vals[i]\n        i += 1"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncorresponds to IDD Field year", "response": "def year(self, value=None):\n        \"\"\"Corresponds to IDD Field `year`\n\n        Args:\n            value (int): value for IDD Field `year`\n                if `value` is None it will not be checked against the\n                specification and is assumed to be a missing value\n\n        Raises:\n            ValueError: if `value` is not a valid value\n\n        \"\"\"\n        if value is not None:\n            try:\n                value = int(value)\n            except ValueError:\n                raise ValueError('value {} need to be of type int '\n                                 'for field `year`'.format(value))\n\n        self._year = value"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef month(self, value=None):\n        if value is not None:\n            try:\n                value = int(value)\n            except ValueError:\n                raise ValueError('value {} need to be of type int '\n                                 'for field `month`'.format(value))\n            if value < 1:\n                raise ValueError('value need to be greater or equal 1 '\n                                 'for field `month`')\n            if value > 12:\n                raise ValueError('value need to be smaller 12 '\n                                 'for field `month`')\n\n        self._month = value", "response": "Corresponds to IDD Field month"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncorresponding to IDD Field day", "response": "def day(self, value=None):\n        \"\"\"Corresponds to IDD Field `day`\n\n        Args:\n            value (int): value for IDD Field `day`\n                value >= 1\n                value <= 31\n                if `value` is None it will not be checked against the\n                specification and is assumed to be a missing value\n\n        Raises:\n            ValueError: if `value` is not a valid value\n\n        \"\"\"\n        if value is not None:\n            try:\n                value = int(value)\n            except ValueError:\n                raise ValueError('value {} need to be of type int '\n                                 'for field `day`'.format(value))\n            if value < 1:\n                raise ValueError('value need to be greater or equal 1 '\n                                 'for field `day`')\n            if value > 31:\n                raise ValueError('value need to be smaller 31 '\n                                 'for field `day`')\n\n        self._day = value"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncorresponds to IDD Field hour", "response": "def hour(self, value=None):\n        \"\"\"Corresponds to IDD Field `hour`\n\n        Args:\n            value (int): value for IDD Field `hour`\n                value >= 1\n                value <= 24\n                if `value` is None it will not be checked against the\n                specification and is assumed to be a missing value\n\n        Raises:\n            ValueError: if `value` is not a valid value\n\n        \"\"\"\n        if value is not None:\n            try:\n                value = int(value)\n            except ValueError:\n                raise ValueError('value {} need to be of type int '\n                                 'for field `hour`'.format(value))\n            if value < 1:\n                raise ValueError('value need to be greater or equal 1 '\n                                 'for field `hour`')\n            if value > 24:\n                raise ValueError('value need to be smaller 24 '\n                                 'for field `hour`')\n\n        self._hour = value"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncorrespond to IDD Field minute", "response": "def minute(self, value=None):\n        \"\"\"Corresponds to IDD Field `minute`\n\n        Args:\n            value (int): value for IDD Field `minute`\n                value >= 0\n                value <= 60\n                if `value` is None it will not be checked against the\n                specification and is assumed to be a missing value\n\n        Raises:\n            ValueError: if `value` is not a valid value\n\n        \"\"\"\n        if value is not None:\n            try:\n                value = int(value)\n            except ValueError:\n                raise ValueError('value {} need to be of type int '\n                                 'for field `minute`'.format(value))\n            if value < 0:\n                raise ValueError('value need to be greater or equal 0 '\n                                 'for field `minute`')\n            if value > 60:\n                raise ValueError('value need to be smaller 60 '\n                                 'for field `minute`')\n\n        self._minute = value"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef data_source_and_uncertainty_flags(self, value=None):\n        if value is not None:\n            try:\n                value = str(value)\n            except ValueError:\n                raise ValueError(\n                    'value {} need to be of type str '\n                    'for field `data_source_and_uncertainty_flags`'.format(value))\n            if ',' in value:\n                raise ValueError(\n                    'value should not contain a comma '\n                    'for field `data_source_and_uncertainty_flags`')\n\n        self._data_source_and_uncertainty_flags = value", "response": "Corresponds to IDD Field data_source_and_uncertainty_flags"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncorrespond to IDD Field dry_bulb_temperature", "response": "def dry_bulb_temperature(self, value=99.9):\n        \"\"\"Corresponds to IDD Field `dry_bulb_temperature`\n\n        Args:\n            value (float): value for IDD Field `dry_bulb_temperature`\n                Unit: C\n                value > -70.0\n                value < 70.0\n                Missing value: 99.9\n                if `value` is None it will not be checked against the\n                specification and is assumed to be a missing value\n\n        Raises:\n            ValueError: if `value` is not a valid value\n\n        \"\"\"\n        if value is not None:\n            try:\n                value = float(value)\n            except ValueError:\n                raise ValueError(\n                    'value {} need to be of type float '\n                    'for field `dry_bulb_temperature`'.format(value))\n            if value <= -70.0:\n                raise ValueError('value need to be greater -70.0 '\n                                 'for field `dry_bulb_temperature`')\n            if value >= 70.0:\n                raise ValueError('value need to be smaller 70.0 '\n                                 'for field `dry_bulb_temperature`')\n\n        self._dry_bulb_temperature = value"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef dew_point_temperature(self, value=99.9):\n        if value is not None:\n            try:\n                value = float(value)\n            except ValueError:\n                raise ValueError(\n                    'value {} need to be of type float '\n                    'for field `dew_point_temperature`'.format(value))\n            if value <= -70.0:\n                raise ValueError('value need to be greater -70.0 '\n                                 'for field `dew_point_temperature`')\n            if value >= 70.0:\n                raise ValueError('value need to be smaller 70.0 '\n                                 'for field `dew_point_temperature`')\n\n        self._dew_point_temperature = value", "response": "Corresponds to IDD Field dew_point_temperature"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef relative_humidity(self, value=999):\n        if value is not None:\n            try:\n                value = int(value)\n            except ValueError:\n                raise ValueError('value {} need to be of type int '\n                                 'for field `relative_humidity`'.format(value))\n            if value < 0:\n                raise ValueError('value need to be greater or equal 0 '\n                                 'for field `relative_humidity`')\n            if value > 110:\n                raise ValueError('value need to be smaller 110 '\n                                 'for field `relative_humidity`')\n\n        self._relative_humidity = value", "response": "Corresponds to IDD Field relative_humidity"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncorresponding to IDD Field atmospheric_station_pressure", "response": "def atmospheric_station_pressure(self, value=999999):\n        \"\"\"Corresponds to IDD Field `atmospheric_station_pressure`\n\n        Args:\n            value (int): value for IDD Field `atmospheric_station_pressure`\n                Unit: Pa\n                value > 31000\n                value < 120000\n                Missing value: 999999\n                if `value` is None it will not be checked against the\n                specification and is assumed to be a missing value\n\n        Raises:\n            ValueError: if `value` is not a valid value\n\n        \"\"\"\n        if value is not None:\n            try:\n                value = int(value)\n            except ValueError:\n                raise ValueError(\n                    'value {} need to be of type int '\n                    'for field `atmospheric_station_pressure`'.format(value))\n            if value <= 31000:\n                raise ValueError('value need to be greater 31000 '\n                                 'for field `atmospheric_station_pressure`')\n            if value >= 120000:\n                raise ValueError('value need to be smaller 120000 '\n                                 'for field `atmospheric_station_pressure`')\n\n        self._atmospheric_station_pressure = value"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncorresponding to IDD Field extraterrestrial_horizontal_radiation", "response": "def extraterrestrial_horizontal_radiation(self, value=9999.0):\n        \"\"\"Corresponds to IDD Field `extraterrestrial_horizontal_radiation`\n\n        Args:\n            value (float): value for IDD Field `extraterrestrial_horizontal_radiation`\n                Unit: Wh/m2\n                value >= 0.0\n                Missing value: 9999.0\n                if `value` is None it will not be checked against the\n                specification and is assumed to be a missing value\n\n        Raises:\n            ValueError: if `value` is not a valid value\n\n        \"\"\"\n        if value is not None:\n            try:\n                value = float(value)\n            except ValueError:\n                raise ValueError(\n                    'value {} need to be of type float '\n                    'for field `extraterrestrial_horizontal_radiation`'.format(value))\n            if value < 0.0:\n                raise ValueError(\n                    'value need to be greater or equal 0.0 '\n                    'for field `extraterrestrial_horizontal_radiation`')\n\n        self._extraterrestrial_horizontal_radiation = value"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncorresponds to IDD Field extraterrestrial_direct_normal_radiation", "response": "def extraterrestrial_direct_normal_radiation(self, value=9999.0):\n        \"\"\"Corresponds to IDD Field `extraterrestrial_direct_normal_radiation`\n\n        Args:\n            value (float): value for IDD Field `extraterrestrial_direct_normal_radiation`\n                Unit: Wh/m2\n                value >= 0.0\n                Missing value: 9999.0\n                if `value` is None it will not be checked against the\n                specification and is assumed to be a missing value\n\n        Raises:\n            ValueError: if `value` is not a valid value\n\n        \"\"\"\n        if value is not None:\n            try:\n                value = float(value)\n            except ValueError:\n                raise ValueError(\n                    'value {} need to be of type float '\n                    'for field `extraterrestrial_direct_normal_radiation`'.format(value))\n            if value < 0.0:\n                raise ValueError(\n                    'value need to be greater or equal 0.0 '\n                    'for field `extraterrestrial_direct_normal_radiation`')\n\n        self._extraterrestrial_direct_normal_radiation = value"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncorrespond to IDD Field horizontal_infrared_radiation_intensity", "response": "def horizontal_infrared_radiation_intensity(self, value=9999.0):\n        \"\"\"Corresponds to IDD Field `horizontal_infrared_radiation_intensity`\n\n        Args:\n            value (float): value for IDD Field `horizontal_infrared_radiation_intensity`\n                Unit: Wh/m2\n                value >= 0.0\n                Missing value: 9999.0\n                if `value` is None it will not be checked against the\n                specification and is assumed to be a missing value\n\n        Raises:\n            ValueError: if `value` is not a valid value\n\n        \"\"\"\n        if value is not None:\n            try:\n                value = float(value)\n            except ValueError:\n                raise ValueError(\n                    'value {} need to be of type float '\n                    'for field `horizontal_infrared_radiation_intensity`'.format(value))\n            if value < 0.0:\n                raise ValueError(\n                    'value need to be greater or equal 0.0 '\n                    'for field `horizontal_infrared_radiation_intensity`')\n\n        self._horizontal_infrared_radiation_intensity = value"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncorrespond to IDD Field global_horizontal_radiation", "response": "def global_horizontal_radiation(self, value=9999.0):\n        \"\"\"Corresponds to IDD Field `global_horizontal_radiation`\n\n        Args:\n            value (float): value for IDD Field `global_horizontal_radiation`\n                Unit: Wh/m2\n                value >= 0.0\n                Missing value: 9999.0\n                if `value` is None it will not be checked against the\n                specification and is assumed to be a missing value\n\n        Raises:\n            ValueError: if `value` is not a valid value\n\n        \"\"\"\n        if value is not None:\n            try:\n                value = float(value)\n            except ValueError:\n                raise ValueError(\n                    'value {} need to be of type float '\n                    'for field `global_horizontal_radiation`'.format(value))\n            if value < 0.0:\n                raise ValueError('value need to be greater or equal 0.0 '\n                                 'for field `global_horizontal_radiation`')\n\n        self._global_horizontal_radiation = value"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncorresponds to IDD Field direct_normal_radiation", "response": "def direct_normal_radiation(self, value=9999.0):\n        \"\"\"Corresponds to IDD Field `direct_normal_radiation`\n\n        Args:\n            value (float): value for IDD Field `direct_normal_radiation`\n                Unit: Wh/m2\n                value >= 0.0\n                Missing value: 9999.0\n                if `value` is None it will not be checked against the\n                specification and is assumed to be a missing value\n\n        Raises:\n            ValueError: if `value` is not a valid value\n\n        \"\"\"\n        if value is not None:\n            try:\n                value = float(value)\n            except ValueError:\n                raise ValueError(\n                    'value {} need to be of type float '\n                    'for field `direct_normal_radiation`'.format(value))\n            if value < 0.0:\n                raise ValueError('value need to be greater or equal 0.0 '\n                                 'for field `direct_normal_radiation`')\n\n        self._direct_normal_radiation = value"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef diffuse_horizontal_radiation(self, value=9999.0):\n        if value is not None:\n            try:\n                value = float(value)\n            except ValueError:\n                raise ValueError(\n                    'value {} need to be of type float '\n                    'for field `diffuse_horizontal_radiation`'.format(value))\n            if value < 0.0:\n                raise ValueError('value need to be greater or equal 0.0 '\n                                 'for field `diffuse_horizontal_radiation`')\n\n        self._diffuse_horizontal_radiation = value", "response": "Corresponds to IDD Field diffuse_horizontal_radiation"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef global_horizontal_illuminance(self, value=999999.0):\n        if value is not None:\n            try:\n                value = float(value)\n            except ValueError:\n                raise ValueError(\n                    'value {} need to be of type float '\n                    'for field `global_horizontal_illuminance`'.format(value))\n            if value < 0.0:\n                raise ValueError('value need to be greater or equal 0.0 '\n                                 'for field `global_horizontal_illuminance`')\n\n        self._global_horizontal_illuminance = value", "response": "Corresponds to IDD Field global_horizontal_illuminance"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef direct_normal_illuminance(self, value=999999.0):\n        if value is not None:\n            try:\n                value = float(value)\n            except ValueError:\n                raise ValueError(\n                    'value {} need to be of type float '\n                    'for field `direct_normal_illuminance`'.format(value))\n            if value < 0.0:\n                raise ValueError('value need to be greater or equal 0.0 '\n                                 'for field `direct_normal_illuminance`')\n\n        self._direct_normal_illuminance = value", "response": "Corresponds to IDD Field direct_normal_illuminance"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef diffuse_horizontal_illuminance(self, value=999999.0):\n        if value is not None:\n            try:\n                value = float(value)\n            except ValueError:\n                raise ValueError(\n                    'value {} need to be of type float '\n                    'for field `diffuse_horizontal_illuminance`'.format(value))\n            if value < 0.0:\n                raise ValueError('value need to be greater or equal 0.0 '\n                                 'for field `diffuse_horizontal_illuminance`')\n\n        self._diffuse_horizontal_illuminance = value", "response": "Corresponds to IDD Field diffuse_horizontal_illuminance"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncorresponds to IDD Field zenith_luminance", "response": "def zenith_luminance(self, value=9999.0):\n        \"\"\"  Corresponds to IDD Field `zenith_luminance`\n        will be missing if >= 9999\n\n        Args:\n            value (float): value for IDD Field `zenith_luminance`\n                Unit: Cd/m2\n                value >= 0.0\n                Missing value: 9999.0\n                if `value` is None it will not be checked against the\n                specification and is assumed to be a missing value\n\n        Raises:\n            ValueError: if `value` is not a valid value\n        \"\"\"\n        if value is not None:\n            try:\n                value = float(value)\n            except ValueError:\n                raise ValueError('value {} need to be of type float '\n                                 'for field `zenith_luminance`'.format(value))\n            if value < 0.0:\n                raise ValueError('value need to be greater or equal 0.0 '\n                                 'for field `zenith_luminance`')\n\n        self._zenith_luminance = value"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef wind_direction(self, value=999.0):\n        if value is not None:\n            try:\n                value = float(value)\n            except ValueError:\n                raise ValueError('value {} need to be of type float '\n                                 'for field `wind_direction`'.format(value))\n            if value < 0.0:\n                raise ValueError('value need to be greater or equal 0.0 '\n                                 'for field `wind_direction`')\n            if value > 360.0:\n                raise ValueError('value need to be smaller 360.0 '\n                                 'for field `wind_direction`')\n\n        self._wind_direction = value", "response": "Corresponds to IDD Field wind_direction"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef wind_speed(self, value=999.0):\n        if value is not None:\n            try:\n                value = float(value)\n            except ValueError:\n                raise ValueError('value {} need to be of type float '\n                                 'for field `wind_speed`'.format(value))\n            if value < 0.0:\n                raise ValueError('value need to be greater or equal 0.0 '\n                                 'for field `wind_speed`')\n            if value > 40.0:\n                raise ValueError('value need to be smaller 40.0 '\n                                 'for field `wind_speed`')\n\n        self._wind_speed = value", "response": "Corresponds to IDD Field wind_speed"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncorresponds to IDD Field total_sky_cover", "response": "def total_sky_cover(self, value=99.0):\n        \"\"\"Corresponds to IDD Field `total_sky_cover` This is the value for\n        total sky cover (tenths of coverage). (i.e. 1 is 1/10 covered. 10 is\n        total coverage). (Amount of sky dome in tenths covered by clouds or\n        obscuring phenomena at the  hour indicated at the time indicated.)\n\n        Args:\n            value (float): value for IDD Field `total_sky_cover`\n                value >= 0.0\n                value <= 10.0\n                Missing value: 99.0\n                if `value` is None it will not be checked against the\n                specification and is assumed to be a missing value\n\n        Raises:\n            ValueError: if `value` is not a valid value\n\n        \"\"\"\n        if value is not None:\n            try:\n                value = float(value)\n            except ValueError:\n                raise ValueError('value {} need to be of type float '\n                                 'for field `total_sky_cover`'.format(value))\n            if value < 0.0:\n                raise ValueError('value need to be greater or equal 0.0 '\n                                 'for field `total_sky_cover`')\n            if value > 10.0:\n                raise ValueError('value need to be smaller 10.0 '\n                                 'for field `total_sky_cover`')\n\n        self._total_sky_cover = value"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef opaque_sky_cover(self, value=99.0):\n        if value is not None:\n            try:\n                value = float(value)\n            except ValueError:\n                raise ValueError('value {} need to be of type float '\n                                 'for field `opaque_sky_cover`'.format(value))\n            if value < 0.0:\n                raise ValueError('value need to be greater or equal 0.0 '\n                                 'for field `opaque_sky_cover`')\n            if value > 10.0:\n                raise ValueError('value need to be smaller 10.0 '\n                                 'for field `opaque_sky_cover`')\n\n        self._opaque_sky_cover = value", "response": "Corresponds to IDD Field opaque_sky_cover"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncorresponding to IDD Field visibility", "response": "def visibility(self, value=9999.0):\n        \"\"\"Corresponds to IDD Field `visibility` This is the value for\n        visibility in km. (Horizontal visibility at the time indicated.)\n\n        Args:\n            value (float): value for IDD Field `visibility`\n                Unit: km\n                Missing value: 9999.0\n                if `value` is None it will not be checked against the\n                specification and is assumed to be a missing value\n\n        Raises:\n            ValueError: if `value` is not a valid value\n\n        \"\"\"\n        if value is not None:\n            try:\n                value = float(value)\n            except ValueError:\n                raise ValueError('value {} need to be of type float '\n                                 'for field `visibility`'.format(value))\n\n        self._visibility = value"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncorresponding to IDD Field ceiling_height", "response": "def ceiling_height(self, value=99999.0):\n        \"\"\"Corresponds to IDD Field `ceiling_height` This is the value for\n        ceiling height in m. (77777 is unlimited ceiling height. 88888 is\n        cirroform ceiling.) It is not currently used in EnergyPlus\n        calculations.\n\n        Args:\n            value (float): value for IDD Field `ceiling_height`\n                Unit: m\n                Missing value: 99999.0\n                if `value` is None it will not be checked against the\n                specification and is assumed to be a missing value\n\n        Raises:\n            ValueError: if `value` is not a valid value\n\n        \"\"\"\n        if value is not None:\n            try:\n                value = float(value)\n            except ValueError:\n                raise ValueError('value {} need to be of type float '\n                                 'for field `ceiling_height`'.format(value))\n\n        self._ceiling_height = value"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef present_weather_observation(self, value=None):\n        if value is not None:\n            try:\n                value = int(value)\n            except ValueError:\n                raise ValueError(\n                    'value {} need to be of type int '\n                    'for field `present_weather_observation`'.format(value))\n\n        self._present_weather_observation = value", "response": "Corresponds to IDD Field present_weather_observation"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef present_weather_codes(self, value=None):\n        if value is not None:\n            try:\n                value = int(value)\n            except ValueError:\n                raise ValueError(\n                    'value {} need to be of type int '\n                    'for field `present_weather_codes`'.format(value))\n\n        self._present_weather_codes = value", "response": "Corresponds to IDD Field present_weather_codes"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef precipitable_water(self, value=999.0):\n        if value is not None:\n            try:\n                value = float(value)\n            except ValueError:\n                raise ValueError(\n                    'value {} need to be of type float '\n                    'for field `precipitable_water`'.format(value))\n\n        self._precipitable_water = value", "response": "Corresponds to IDD Field precipitable_water"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncorrespond to IDD Field aerosol_optical_depth", "response": "def aerosol_optical_depth(self, value=0.999):\n        \"\"\"Corresponds to IDD Field `aerosol_optical_depth`\n\n        Args:\n            value (float): value for IDD Field `aerosol_optical_depth`\n                Unit: thousandths\n                Missing value: 0.999\n                if `value` is None it will not be checked against the\n                specification and is assumed to be a missing value\n\n        Raises:\n            ValueError: if `value` is not a valid value\n\n        \"\"\"\n        if value is not None:\n            try:\n                value = float(value)\n            except ValueError:\n                raise ValueError(\n                    'value {} need to be of type float '\n                    'for field `aerosol_optical_depth`'.format(value))\n\n        self._aerosol_optical_depth = value"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef snow_depth(self, value=999.0):\n        if value is not None:\n            try:\n                value = float(value)\n            except ValueError:\n                raise ValueError('value {} need to be of type float '\n                                 'for field `snow_depth`'.format(value))\n\n        self._snow_depth = value", "response": "Corresponds to IDD Field snow_depth"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef days_since_last_snowfall(self, value=99):\n        if value is not None:\n            try:\n                value = int(value)\n            except ValueError:\n                raise ValueError(\n                    'value {} need to be of type int '\n                    'for field `days_since_last_snowfall`'.format(value))\n\n        self._days_since_last_snowfall = value", "response": "Corresponds to IDD Field days_since_last_snowfall"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncorrespond to IDD Field albedo", "response": "def albedo(self, value=999.0):\n        \"\"\"Corresponds to IDD Field `albedo`\n\n        Args:\n            value (float): value for IDD Field `albedo`\n                Missing value: 999.0\n                if `value` is None it will not be checked against the\n                specification and is assumed to be a missing value\n\n        Raises:\n            ValueError: if `value` is not a valid value\n\n        \"\"\"\n        if value is not None:\n            try:\n                value = float(value)\n            except ValueError:\n                raise ValueError('value {} need to be of type float '\n                                 'for field `albedo`'.format(value))\n\n        self._albedo = value"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncorresponding to IDD Field liquid_precipitation_depth", "response": "def liquid_precipitation_depth(self, value=999.0):\n        \"\"\"Corresponds to IDD Field `liquid_precipitation_depth`\n\n        Args:\n            value (float): value for IDD Field `liquid_precipitation_depth`\n                Unit: mm\n                Missing value: 999.0\n                if `value` is None it will not be checked against the\n                specification and is assumed to be a missing value\n\n        Raises:\n            ValueError: if `value` is not a valid value\n\n        \"\"\"\n        if value is not None:\n            try:\n                value = float(value)\n            except ValueError:\n                raise ValueError(\n                    'value {} need to be of type float '\n                    'for field `liquid_precipitation_depth`'.format(value))\n\n        self._liquid_precipitation_depth = value"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef liquid_precipitation_quantity(self, value=99.0):\n        if value is not None:\n            try:\n                value = float(value)\n            except ValueError:\n                raise ValueError(\n                    'value {} need to be of type float '\n                    'for field `liquid_precipitation_quantity`'.format(value))\n\n        self._liquid_precipitation_quantity = value", "response": "Corresponds to IDD Field liquid_precipitation_quantity"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef export(self, top=True):\n        out = []\n        if top:\n            out.append(self._internal_name)\n        out.append(self._to_str(self.year))\n        out.append(self._to_str(self.month))\n        out.append(self._to_str(self.day))\n        out.append(self._to_str(self.hour))\n        out.append(self._to_str(self.minute))\n        out.append(self._to_str(self.data_source_and_uncertainty_flags))\n        out.append(self._to_str(self.dry_bulb_temperature))\n        out.append(self._to_str(self.dew_point_temperature))\n        out.append(self._to_str(self.relative_humidity))\n        out.append(self._to_str(self.atmospheric_station_pressure))\n        out.append(self._to_str(self.extraterrestrial_horizontal_radiation))\n        out.append(self._to_str(self.extraterrestrial_direct_normal_radiation))\n        out.append(self._to_str(self.horizontal_infrared_radiation_intensity))\n        out.append(self._to_str(self.global_horizontal_radiation))\n        out.append(self._to_str(self.direct_normal_radiation))\n        out.append(self._to_str(self.diffuse_horizontal_radiation))\n        out.append(self._to_str(self.global_horizontal_illuminance))\n        out.append(self._to_str(self.direct_normal_illuminance))\n        out.append(self._to_str(self.diffuse_horizontal_illuminance))\n        out.append(self._to_str(self.zenith_luminance))\n        out.append(self._to_str(self.wind_direction))\n        out.append(self._to_str(self.wind_speed))\n        out.append(self._to_str(self.total_sky_cover))\n        out.append(self._to_str(self.opaque_sky_cover))\n        out.append(self._to_str(self.visibility))\n        out.append(self._to_str(self.ceiling_height))\n        out.append(self._to_str(self.present_weather_observation))\n        out.append(self._to_str(self.present_weather_codes))\n        out.append(self._to_str(self.precipitable_water))\n        out.append(self._to_str(self.aerosol_optical_depth))\n        out.append(self._to_str(self.snow_depth))\n        out.append(self._to_str(self.days_since_last_snowfall))\n        out.append(self._to_str(self.albedo))\n        out.append(self._to_str(self.liquid_precipitation_depth))\n        out.append(self._to_str(self.liquid_precipitation_quantity))\n        return \",\".join(out)", "response": "Exports the current object to its string representation."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nappend weather data. Args: data (WeatherData): weather data object", "response": "def add_weatherdata(self, data):\n        \"\"\"Appends weather data.\n\n        Args:\n            data (WeatherData): weather data object\n\n        \"\"\"\n        if not isinstance(data, WeatherData):\n            raise ValueError('Weather data need to be of type WeatherData')\n        self._data[\"WEATHER DATA\"].append(data)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef save(self, path, check=True):\n        with open(path, 'w') as f:\n            if check:\n                if (\"LOCATION\" not in self._data or\n                        self._data[\"LOCATION\"] is None):\n                    raise ValueError('location is not valid.')\n                if (\"DESIGN CONDITIONS\" not in self._data or\n                        self._data[\"DESIGN CONDITIONS\"] is None):\n                    raise ValueError('design_conditions is not valid.')\n                if (\"TYPICAL/EXTREME PERIODS\" not in self._data or\n                        self._data[\"TYPICAL/EXTREME PERIODS\"] is None):\n                    raise ValueError(\n                        'typical_or_extreme_periods is not valid.')\n                if (\"GROUND TEMPERATURES\" not in self._data or\n                        self._data[\"GROUND TEMPERATURES\"] is None):\n                    raise ValueError('ground_temperatures is not valid.')\n                if (\"HOLIDAYS/DAYLIGHT SAVINGS\" not in self._data or\n                        self._data[\"HOLIDAYS/DAYLIGHT SAVINGS\"] is None):\n                    raise ValueError(\n                        'holidays_or_daylight_savings is not valid.')\n                if (\"COMMENTS 1\" not in self._data or\n                        self._data[\"COMMENTS 1\"] is None):\n                    raise ValueError('comments_1 is not valid.')\n                if (\"COMMENTS 2\" not in self._data or\n                        self._data[\"COMMENTS 2\"] is None):\n                    raise ValueError('comments_2 is not valid.')\n                if (\"DATA PERIODS\" not in self._data or\n                        self._data[\"DATA PERIODS\"] is None):\n                    raise ValueError('data_periods is not valid.')\n            if (\"LOCATION\" in self._data and\n                    self._data[\"LOCATION\"] is not None):\n                f.write(self._data[\"LOCATION\"].export() + \"\\n\")\n            if (\"DESIGN CONDITIONS\" in self._data and\n                    self._data[\"DESIGN CONDITIONS\"] is not None):\n                f.write(self._data[\"DESIGN CONDITIONS\"].export() + \"\\n\")\n            if (\"TYPICAL/EXTREME PERIODS\" in self._data and\n                    self._data[\"TYPICAL/EXTREME PERIODS\"] is not None):\n                f.write(self._data[\"TYPICAL/EXTREME PERIODS\"].export() + \"\\n\")\n            if (\"GROUND TEMPERATURES\" in self._data and\n                    self._data[\"GROUND TEMPERATURES\"] is not None):\n                f.write(self._data[\"GROUND TEMPERATURES\"].export() + \"\\n\")\n            if (\"HOLIDAYS/DAYLIGHT SAVINGS\" in self._data and\n                    self._data[\"HOLIDAYS/DAYLIGHT SAVINGS\"] is not None):\n                f.write(\n                    self._data[\"HOLIDAYS/DAYLIGHT SAVINGS\"].export() +\n                    \"\\n\")\n            if (\"COMMENTS 1\" in self._data and\n                    self._data[\"COMMENTS 1\"] is not None):\n                f.write(self._data[\"COMMENTS 1\"].export() + \"\\n\")\n            if (\"COMMENTS 2\" in self._data and\n                    self._data[\"COMMENTS 2\"] is not None):\n                f.write(self._data[\"COMMENTS 2\"].export() + \"\\n\")\n            if (\"DATA PERIODS\" in self._data and\n                    self._data[\"DATA PERIODS\"] is not None):\n                f.write(self._data[\"DATA PERIODS\"].export() + \"\\n\")\n            for item in self._data[\"WEATHER DATA\"]:\n                f.write(item.export(False) + \"\\n\")", "response": "Save weather data in EPW format to path."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate an object depending on internal_name", "response": "def _create_datadict(cls, internal_name):\n        \"\"\"Creates an object depending on `internal_name`\n\n        Args:\n            internal_name (str): IDD name\n\n        Raises:\n            ValueError: if `internal_name` cannot be matched to a data dictionary object\n\n        \"\"\"\n        if internal_name == \"LOCATION\":\n            return Location()\n        if internal_name == \"DESIGN CONDITIONS\":\n            return DesignConditions()\n        if internal_name == \"TYPICAL/EXTREME PERIODS\":\n            return TypicalOrExtremePeriods()\n        if internal_name == \"GROUND TEMPERATURES\":\n            return GroundTemperatures()\n        if internal_name == \"HOLIDAYS/DAYLIGHT SAVINGS\":\n            return HolidaysOrDaylightSavings()\n        if internal_name == \"COMMENTS 1\":\n            return Comments1()\n        if internal_name == \"COMMENTS 2\":\n            return Comments2()\n        if internal_name == \"DATA PERIODS\":\n            return DataPeriods()\n        raise ValueError(\n            \"No DataDictionary known for {}\".format(internal_name))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef read(self, path):\n        with open(path, \"r\") as f:\n            for line in f:\n                line = line.strip()\n                match_obj_name = re.search(r\"^([A-Z][A-Z/ \\d]+),\", line)\n                if match_obj_name is not None:\n                    internal_name = match_obj_name.group(1)\n                    if internal_name in self._data:\n                        self._data[internal_name] = self._create_datadict(\n                            internal_name)\n                        data_line = line[len(internal_name) + 1:]\n                        vals = data_line.strip().split(',')\n                        self._data[internal_name].read(vals)\n                else:\n                    wd = WeatherData()\n                    wd.read(line.strip().split(','))\n                    self.add_weatherdata(wd)", "response": "Reads EPW weather data from path."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef display_url(target):\n\n    prefix = u\"http://\" if not target.startswith(\"http\") else u\"\"\n    target = prefix + target\n    display(HTML(u'<a href=\"{t}\" target=_blank>{t}</a>'.format(t=target)))", "response": "Display the URL in an IPython notebook."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef iframe_url(target, width=500, height=400, scrolling=True, border=0, frameborder=0):\n    \n    prefix = u\"http://\" if not target.startswith(\"http\") else u\"\"\n    target = prefix + target\n    if scrolling:\n        scroll_val = 'yes'\n    else:\n        scroll_val = 'no'\n    return u'<iframe frameborder=\"{frameborder}\" scrolling=\"{scrolling}\" style=\"border:{border}px\" src=\"{url}\", width={width} height={height}></iframe>'.format(frameborder=frameborder, scrolling=scroll_val, border=border, url=target, width=width, height=height)", "response": "Return a HTML iframe for displaying an item in the browser."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef display_iframe_url(target, **kwargs):\n\n    txt = iframe_url(target, **kwargs)\n    display(HTML(txt))", "response": "Display the contents of a URL in an IPython notebook."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef display_google_book(id, page=None, width=700, height=500, **kwargs):\n    if isinstance(page, int):\n        url = 'http://books.google.co.uk/books?id={id}&pg=PA{page}&output=embed'.format(id=id, page=page)\n    else:\n        url = 'http://books.google.co.uk/books?id={id}&pg={page}&output=embed'.format(id=id, page=page)\n    display_iframe_url(url, width=width, height=height, **kwargs)", "response": "Display an embedded version of a Google book."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef code_toggle(start_show=False, message=None):\n\n    \n    html ='<script>\\n'\n    if message is None:\n        message = u'The raw code for this jupyter notebook can be hidden for easier reading.'\n    if start_show:\n        html += u'code_show=true;\\n'\n    else:\n        html += u'code_show=false;\\n'\n    html+='''function code_toggle() {\n if (code_show){\n $('div.input').show();\n } else {\n $('div.input').hide();\n }\n code_show = !code_show\n} \n$( document ).ready(code_toggle);\n</script>\n'''\n    html += message + ' To toggle on/off the raw code, click <a href=\"javascript:code_toggle()\">here</a>.' \n    display(HTML(html))", "response": "Toggles on and off the raw code in a jupyter notebook."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef display_plots(filebase, directory=None, width=700, height=500, **kwargs):\n    def show_figure(filebase, directory, **kwargs):\n        \"\"\"Helper function to load in the relevant plot for display.\"\"\"\n        filename = filebase.format(**kwargs)\n        if directory is not None:\n            filename = directory + '/' + filename\n        display(HTML(\"<img src='{filename}'>\".format(filename=filename)))\n        \n    interact(show_figure, filebase=fixed(filebase), directory=fixed(directory), **kwargs)", "response": "Display a series of plots controlled by sliders."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the answers to the lab classes.", "response": "def answer(part, module='mlai2014.json'):\n    \"\"\"Returns the answers to the lab classes.\"\"\"\n    marks = json.load(open(os.path.join(data_directory, module), 'rb'))\n    return marks['Lab '  + str(part+1)]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef latex(self):\n        output = self.latex_preamble\n        output += self._repr_latex_()\n        output += self.latex_post\n        return output", "response": "Gives a latex representation of the assessment."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngives an html representation of the assessment.", "response": "def html(self):\n        \"\"\"Gives an html representation of the assessment.\"\"\"\n        output = self.html_preamble\n        output += self._repr_html_()\n        output += self.html_post\n        return output"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef marksheet(self):\n        columns=['Number', 'Question', 'Correct (a fraction)', 'Max Mark', 'Comments']\n        mark_sheet = pd.DataFrame() \n        for qu_number, question in enumerate(self.answers):\n            part_no = 0\n            for number, part in enumerate(question):\n                if number>0:\n                    if part[2] > 0:\n                        part_no += 1\n                        index = str(qu_number+1) +'_'+str(part_no)\n                        frame = pd.DataFrame(columns=columns, index=[index])\n                        frame.loc[index]['Number'] = index\n                        frame.loc[index]['Question'] = part[0]\n                        frame.loc[index]['Max Mark'] = part[2]\n                        mark_sheet =  mark_sheet.append(frame)\n\n        return mark_sheet.sort(columns='Number')", "response": "Returns an empty dataframe containing rows and columns for marking."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncompute the total mark for the assessment.", "response": "def total_marks(self):\n        \"\"\"Compute the total mark for the assessment.\"\"\"\n        total = 0\n        for answer in self.answers:\n            for number, part in enumerate(answer):\n                if number>0:\n                    if part[2]>0:\n                        total+=part[2]\n        return total"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef download(name, course, github='SheffieldML/notebook/master/lab_classes/'):\n\n    github_stub = 'https://raw.githubusercontent.com/'\n    if not name.endswith('.ipynb'):\n        name += '.ipynb'\n    from pods.util import download_url\n    download_url(os.path.join(github_stub, github, course, name), store_directory=course)", "response": "Download a lab class from the relevant course"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef read(self, vals):\n        i = 0\n        {%- for field in fields %}\n        {%- if field.is_list %}\n        count = int(vals[i])\n        i += 1\n        for _ in range(count):\n            obj = {{field.object_name}}()\n            obj.read(vals[i:i + obj.field_count])\n            self.add_{{field.field_name}}(obj)\n            i += obj.field_count\n        {%- else %}\n        if len(vals[i]) == 0:\n            self.{{field.field_name}} = None\n        else:\n            self.{{field.field_name}} = vals[i]\n        i += 1\n        {%- endif %}\n        {%- endfor %}", "response": "Reads the values in the current object from the list of strings representing values\n    \n       ."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef permute(num):\n    \"Permutation for randomizing data order.\"\n    if permute_data:\n        return np.random.permutation(num)\n    else:\n        logging.warning(\"Warning not permuting data\")\n        return np.arange(num)", "response": "Permutation for randomizing data order."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a class category that shows the encoding", "response": "def discrete(cats, name='discrete'):\n    \"\"\"Return a class category that shows the encoding\"\"\"\n    import json\n    ks = list(cats)\n    for key in ks:\n        if isinstance(key, bytes):\n            cats[key.decode('utf-8')] = cats.pop(key)\n    return 'discrete(' + json.dumps([cats, name]) + ')'"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef prompt_stdin(prompt):\n    # raw_input returns the empty string for \"enter\"\n    yes = set(['yes', 'y'])\n    no = set(['no','n'])\n\n    try:\n        print(prompt)\n        if sys.version_info>=(3,0):\n            choice = input().lower()\n        else:\n            choice = raw_input().lower()\n        # would like to test for which exceptions here\n    except:\n        print('Stdin is not implemented.')\n        print('You need to set')\n        print('overide_manual_authorize=True')\n        print('to proceed with the download. Please set that variable and continue.')\n        raise\n\n\n    if choice in yes:\n        return True\n    elif choice in no:\n        return False\n    else:\n        print(\"Your response was a \" + choice)\n        print(\"Please respond with 'yes', 'y' or 'no', 'n'\")", "response": "Ask user for agreeing to data set licenses."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nremove a data set from the cache", "response": "def clear_cache(dataset_name=None):\n    \"\"\"Remove a data set from the cache\"\"\"\n    dr = data_resources[dataset_name]\n    if 'dirs' in dr:\n        for dirs, files in zip(dr['dirs'], dr['files']):\n            for dir, file in zip(dirs, files):\n                path = os.path.join(data_path, dataset_name, dir, file)\n                if os.path.exists(path):\n                    logging.info(\"clear_cache: removing \" + path)\n                    os.unlink(path)\n            for dir in dirs:\n                path = os.path.join(data_path, dataset_name, dir)\n                if os.path.exists(path):\n                    logging.info(\"clear_cache: remove directory \" + path)\n                    os.rmdir(path)\n        \n    else:\n        for file_list in dr['files']:\n            for file in file_list:\n                path = os.path.join(data_path, dataset_name, file)\n                if os.path.exists(path):\n                    logging.info(\"clear_cache: remove \" + path)\n                    os.unlink(path)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef data_available(dataset_name=None):\n    dr = data_resources[dataset_name]\n    if 'dirs' in dr:\n        for dirs, files in zip(dr['dirs'], dr['files']):\n            for dir, file in zip(dirs, files):\n                if not os.path.exists(os.path.join(data_path, dataset_name, dir, file)):\n                    return False\n    else:\n        for file_list in dr['files']:\n            for file in file_list:\n                if not os.path.exists(os.path.join(data_path, dataset_name, file)):\n                    return False\n    return True", "response": "Check if the data set is available on the local machine already."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ndownloads the data set.", "response": "def download_data(dataset_name=None, prompt=prompt_stdin):\n    \"\"\"Check with the user that the are happy with terms and conditions for the data set, then download it.\"\"\"\n        \n    dr = data_resources[dataset_name]\n    if not authorize_download(dataset_name, prompt=prompt):\n        raise Exception(\"Permission to download data set denied.\")\n    \n    if 'suffices' in dr:\n        for url, files, suffices in zip(dr['urls'], dr['files'], dr['suffices']):\n            for file, suffix in zip(files, suffices):\n                download_url(url=os.path.join(url,file),\n                             dir_name = data_path,\n                             store_directory=dataset_name,\n                             suffix=suffix)\n    elif 'dirs' in dr:\n        for url, dirs, files in zip(dr['urls'], dr['dirs'], dr['files']):\n            for file, dir in zip(files, dirs):\n                print(file, dir)\n                download_url(\n                    url=os.path.join(url,dir,file),\n                    dir_name = data_path,\n                    store_directory=os.path.join(dataset_name,dir)\n                    )\n    else:\n        for url, files in zip(dr['urls'], dr['files']):\n            for file in files:\n                download_url(\n                    url=os.path.join(url,file),\n                    dir_name = data_path,\n                    store_directory=dataset_name\n                    )\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef df2arff(df, dataset_name, pods_data):\n    def java_simple_date(date_format):\n        date_format = date_format.replace('%Y', 'yyyy').replace('%m', 'MM').replace('%d', 'dd').replace('%H', 'HH')\n        return date_format.replace('%h', 'hh').replace('%M', 'mm').replace('%S', 'ss').replace('%f', 'SSSSSS')\n    \n    def tidy_field(atr):\n        return str(atr).replace(' / ', '/').replace(' ', '_')\n    types = {'STRING': [str], 'INTEGER': [int, np.int64, np.uint8], 'REAL': [np.float64]}\n    d = {}\n    d['attributes'] = []\n    for atr in df.columns:\n        if isinstance(atr, str):\n            if len(atr)>8 and atr[:9] == 'discrete(':\n                import json\n                elements = json.loads(atr[9:-1])\n                d['attributes'].append((tidy_field(elements[1]),\n                                         list(elements[0].keys())))\n                mask = {}\n                c = pd.Series(index=df.index)\n                for key, val in elements[0].items():\n                    mask = df[atr]==val\n                    c[mask] = key\n                df[atr] = c\n                continue\n            if len(atr)>7 and atr[:8] == 'integer(':\n                name = atr[8:-1]\n                d['attributes'].append((tidy_field(name), 'INTEGER'))\n                df[atr] = df[atr].astype(int)\n                continue\n            if len(atr)>7 and atr[:8]=='datenum(':\n                from matplotlib.dates import num2date\n                elements = atr[8:-1].split(',')\n                d['attributes'].append((elements[0] + '_datenum_' + java_simple_date(elements[1]), 'STRING'))\n                df[atr] = num2date(df[atr].values) #\n                df[atr] = df[atr].dt.strftime(elements[1])\n                continue\n            if len(atr)>9 and atr[:10]=='timestamp(':\n                def timestamp2date(values):\n                    import datetime\n                    \"\"\"Convert timestamp into a date object\"\"\"\n                    new = []\n                    for value in values:\n                        new.append(np.datetime64(datetime.datetime.fromtimestamp(value)))\n                    return np.asarray(new)\n                elements = atr[10:-1].split(',')\n                d['attributes'].append((elements[0] + '_datenum_' + java_simple_date(elements[1]), 'STRING'))\n                df[atr] = timestamp2date(df[atr].values) #\n                df[atr] = df[atr].dt.strftime(elements[1])\n                continue\n            if len(atr)>10 and atr[:11]=='datetime64(':\n                elements = atr[11:-1].split(',')\n                d['attributes'].append((elements[0] + '_datenum_' + java_simple_date(elements[1]), 'STRING'))\n                df[atr] = df[atr].dt.strftime(elements[1])\n                continue\n            if len(atr)>11 and atr[:12]=='decimalyear(':\n                def decyear2date(values):\n                    \"\"\"Convert decimal year into a date object\"\"\"\n                    new = []\n                    for i, decyear in enumerate(values):\n                        year = int(np.floor(decyear))\n                        dec = decyear-year\n                        end = np.datetime64(str(year+1)+'-01-01')\n                        start = np.datetime64(str(year)+'-01-01')\n                        diff=end-start\n                        days = dec*(diff/np.timedelta64(1, 'D'))\n                        # round to nearest day\n                        add = np.timedelta64(int(np.round(days)), 'D')\n                        new.append(start+add)\n                    return np.asarray(new)\n                elements = atr[12:-1].split(',')\n                d['attributes'].append((elements[0] + '_datenum_' + java_simple_date(elements[1]), 'STRING'))\n                df[atr] = decyear2date(df[atr].values) #\n                df[atr] = df[atr].dt.strftime(elements[1])\n                continue\n\n        field = tidy_field(atr)\n        el = df[atr][0]\n        type_assigned=False\n        for t in types:\n            if isinstance(el, tuple(types[t])):\n                d['attributes'].append((field, t))\n                type_assigned=True\n                break\n        if not type_assigned:\n            import json\n            d['attributes'].append((field+'_json', 'STRING'))\n            df[atr] = df[atr].apply(json.dumps)\n\n    d['data'] = []\n    for ind, row in df.iterrows():\n        d['data'].append(list(row))\n\n    import textwrap as tw\n    width = 78\n    d['description'] = dataset_name + \"\\n\\n\"\n    if 'info' in pods_data and pods_data['info']:\n        d['description'] += \"\\n\".join(tw.wrap(pods_data['info'], width)) + \"\\n\\n\"\n    if 'details' in pods_data and pods_data['details']:\n        d['description'] += \"\\n\".join(tw.wrap(pods_data['details'], width))\n    if 'citation' in pods_data and pods_data['citation']:\n        d['description'] += \"\\n\\n\" + \"Citation\" \"\\n\\n\" + \"\\n\".join(tw.wrap(pods_data['citation'], width))\n\n    d['relation'] = dataset_name\n    import arff\n    string = arff.dumps(d)\n    import re\n    string = re.sub(r'\\@ATTRIBUTE \"?(.*)_datenum_(.*)\"? STRING',\n                    r'@ATTRIBUTE \"\\1\" DATE [\\2]',\n                    string)\n    f = open(dataset_name + '.arff', 'w')\n    f.write(string)\n    f.close()", "response": "Write an arff file from a pandas dataframe"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ntake a pods data set and write it as an ARFF file", "response": "def to_arff(dataset, **kwargs):\n    \"\"\"Take a pods data set and write it as an ARFF file\"\"\"\n    pods_data = dataset(**kwargs)\n    vals = list(kwargs.values())\n    for i, v in enumerate(vals):\n        if isinstance(v, list):\n            vals[i] = '|'.join(v)\n        else:\n            vals[i] = str(v)\n    args = '_'.join(vals)\n    n = dataset.__name__\n    if len(args)>0:\n        n += '_' + args\n        n = n.replace(' ', '-')\n    ks = pods_data.keys()\n    d = None\n    if 'Y' in ks and 'X' in ks: \n        d = pd.DataFrame(pods_data['X'])\n        if 'Xtest' in ks:\n            d = d.append(pd.DataFrame(pods_data['Xtest']), ignore_index=True)\n        if 'covariates' in ks:\n            d.columns = pods_data['covariates']\n        dy = pd.DataFrame(pods_data['Y'])\n        if 'Ytest' in ks:\n            dy = dy.append(pd.DataFrame(pods_data['Ytest']), ignore_index=True)\n        if 'response' in ks:\n            dy.columns = pods_data['response']\n        for c in dy.columns:\n            if c not in d.columns:\n                d[c] = dy[c]\n            else:\n                d['y'+str(c)] = dy[c]\n    elif 'Y' in ks:\n        d = pd.DataFrame(pods_data['Y'])\n        if 'Ytest' in ks:\n            d = d.append(pd.DataFrame(pods_data['Ytest']), ignore_index=True)\n\n    elif 'data' in ks:\n        d = pd.DataFrame(pods_data['data'])\n    if d is not None:\n        df2arff(d, n, pods_data)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef epomeo_gpx(data_set='epomeo_gpx', sample_every=4):\n    import gpxpy\n    import gpxpy.gpx\n    if not data_available(data_set):\n        download_data(data_set)\n    files = ['endomondo_1', 'endomondo_2', 'garmin_watch_via_endomondo','viewranger_phone', 'viewranger_tablet']\n\n    X = []\n    for file in files:\n        gpx_file = open(os.path.join(data_path, 'epomeo_gpx', file + '.gpx'), 'r')\n\n        gpx = gpxpy.parse(gpx_file)\n        segment = gpx.tracks[0].segments[0]\n        points = [point for track in gpx.tracks for segment in track.segments for point in segment.points]\n        data = [[(point.time-datetime.datetime(2013,8,21)).total_seconds(), point.latitude, point.longitude, point.elevation] for point in points]\n        X.append(np.asarray(data)[::sample_every, :])\n        gpx_file.close()\n    if pandas_available:\n        X = pd.DataFrame(X[0], columns=['seconds', 'latitude', 'longitude', 'elevation'])\n        X.set_index(keys='seconds', inplace=True)\n    return data_details_return({'X' : X, 'info' : 'Data is an array containing time in seconds, latitude, longitude and elevation in that order.'}, data_set)", "response": "Data set of three GPS traces of the same movement on Mt Epomeo in Ischia. Requires gpxpy to run. Requires gpxpy to run. Requires gpxpy to run. Requires gpxpy to run. Requires gpxpy to run. Requires gpxpy to run. Requires gpxpy to run. Requires gpxpy to run. Requires gpxpy to run. Requires gpxpy to run. Requires gpxpy to run."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef pmlr(volumes='all', data_set='pmlr'):\n    if not data_available(data_set):\n        download_data(data_set)\n        \n    proceedings_file = open(os.path.join(data_path, data_set, 'proceedings.yaml'), 'r')\n    import yaml\n    proceedings = yaml.load(proceedings_file)\n    \n    # Create a new resources entry for downloading contents of proceedings.\n    data_name_full = 'pmlr_volumes'\n    data_resources[data_name_full] = data_resources[data_set].copy()\n    data_resources[data_name_full]['files'] = []\n    data_resources[data_name_full]['dirs'] = []\n    data_resources[data_name_full]['urls'] = []\n    for entry in proceedings:\n        if volumes=='all' or entry['volume'] in volumes:\n            file = entry['yaml'].split('/')[-1]\n            dir = 'v' + str(entry['volume'])\n            data_resources[data_name_full]['files'].append([file])\n            data_resources[data_name_full]['dirs'].append([dir])\n            data_resources[data_name_full]['urls'].append(data_resources[data_set]['urls'][0])\n    Y = []\n    # Download the volume data\n    if not data_available(data_name_full):\n        download_data(data_name_full)\n    for entry in reversed(proceedings):\n        volume =  entry['volume']\n        if volumes == 'all' or volume in volumes:\n            file = entry['yaml'].split('/')[-1]\n            volume_file = open(os.path.join(\n                data_path, data_name_full,\n                'v'+str(volume), file\n                ), 'r')\n            Y+=yaml.load(volume_file)\n    if pandas_available:\n        Y = pd.DataFrame(Y)\n        Y['published'] = pd.to_datetime(Y['published'])\n        #Y.columns.values[4] = json_object('authors')\n        #Y.columns.values[7] = json_object('editors')\n        Y['issued'] = Y['issued'].apply(lambda x: np.datetime64(datetime.datetime(*x['date-parts'])))\n        Y['author'] = Y['author'].apply(lambda x: [str(author['given']) + ' ' + str(author['family']) for author in x])\n        Y['editor'] = Y['editor'].apply(lambda x: [str(editor['given']) + ' ' + str(editor['family']) for editor in x])\n        columns = list(Y.columns)\n        columns[14] = datetime64_('published')\n        columns[11] = datetime64_('issued')\n        Y.columns = columns\n        \n    return data_details_return({'Y' : Y, 'info' : 'Data is a pandas data frame containing each paper, its abstract, authors, volumes and venue.'}, data_set)", "response": "Download the Proceedings of Machine Learning Research and create a new resource table for each of the volumes."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ndownloads football data from English games since 1993.", "response": "def football_data(season='1617', data_set='football_data'):\n    \"\"\"Football data from English games since 1993. This downloads data from football-data.co.uk for the given season. \"\"\"\n    league_dict = {'E0':0, 'E1':1, 'E2': 2, 'E3': 3, 'EC':4}\n    def league2num(string):\n        if isinstance(string, bytes):\n            string = string.decode('utf-8')\n        return league_dict[string]\n\n    def football2num(string):\n        if isinstance(string, bytes):\n            string = string.decode('utf-8')\n        if string in football_dict:\n            return football_dict[string]\n        else:\n            football_dict[string] = len(football_dict)+1\n            return len(football_dict)+1\n\n    def datestr2num(s):\n        import datetime\n        from matplotlib.dates import date2num\n        return date2num(datetime.datetime.strptime(s.decode('utf-8'),'%d/%m/%y'))\n    data_set_season = data_set + '_' + season\n    data_resources[data_set_season] = copy.deepcopy(data_resources[data_set])\n    data_resources[data_set_season]['urls'][0]+=season + '/'\n    start_year = int(season[0:2])\n    end_year = int(season[2:4])\n    files = ['E0.csv', 'E1.csv', 'E2.csv', 'E3.csv']\n    if start_year>4 and start_year < 93:\n        files += ['EC.csv']\n    data_resources[data_set_season]['files'] = [files]\n    if not data_available(data_set_season):\n        download_data(data_set_season)\n    start = True\n    for file in reversed(files):\n        filename = os.path.join(data_path, data_set_season, file)\n        # rewrite files removing blank rows.\n        writename = os.path.join(data_path, data_set_season, 'temp.csv')\n        input = open(filename, encoding='ISO-8859-1')\n        output = open(writename, 'w')\n        writer = csv.writer(output)\n        for row in csv.reader(input):\n            if any(field.strip() for field in row):\n                writer.writerow(row)\n        input.close()\n        output.close()\n        table = np.loadtxt(writename,skiprows=1, usecols=(0, 1, 2, 3, 4, 5), converters = {0: league2num, 1: datestr2num, 2:football2num, 3:football2num}, delimiter=',')\n        if start:\n            X = table[:, :4]\n            Y = table[:, 4:]\n            start=False\n        else:\n            X = np.append(X, table[:, :4], axis=0)\n            Y = np.append(Y, table[:, 4:], axis=0)\n    return data_details_return({'X': X, 'Y': Y, 'covariates': [discrete(league_dict, 'league'), datenum('match_day'), discrete(football_dict, 'home team'), discrete(football_dict, 'away team')], 'response': [integer('home score'), integer('away score')]}, data_set)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef lee_yeast_ChIP(data_set='lee_yeast_ChIP'):\n    if not data_available(data_set):\n        download_data(data_set)\n    from pandas import read_csv\n    dir_path = os.path.join(data_path, data_set)\n    filename = os.path.join(dir_path, 'binding_by_gene.tsv')\n    S = read_csv(filename, header=1, index_col=0, sep='\\t')\n    transcription_factors = [col for col in S.columns if col[:7] != 'Unnamed']\n    annotations = S[['Unnamed: 1', 'Unnamed: 2', 'Unnamed: 3']]\n    S = S[transcription_factors]\n    return data_details_return({'annotations' : annotations, 'Y' : S, 'transcription_factors': transcription_factors}, data_set)", "response": "Yeast ChIP data from Lee et al."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef google_trends(query_terms=['big data', 'machine learning', 'data science'], data_set='google_trends', refresh_data=False):\n\n    query_terms.sort()\n    import pandas as pd\n\n    # Create directory name for data\n    dir_path = os.path.join(data_path,'google_trends')\n    if not os.path.isdir(dir_path):\n        os.makedirs(dir_path)\n    dir_name = '-'.join(query_terms)\n    dir_name = dir_name.replace(' ', '_')\n    dir_path = os.path.join(dir_path,dir_name)\n    file = 'data.csv'\n    file_name = os.path.join(dir_path,file)\n    if not os.path.exists(file_name) or refresh_data:\n        print(\"Accessing Google trends to acquire the data. Note that repeated accesses will result in a block due to a google terms of service violation. Failure at this point may be due to such blocks.\")\n        # quote the query terms.\n        quoted_terms = []\n        for term in query_terms:\n            quoted_terms.append(quote(term))\n        print(\"Query terms: \", ', '.join(query_terms))\n\n        print(\"Fetching query:\")\n        query = 'http://www.google.com/trends/fetchComponent?q=%s&cid=TIMESERIES_GRAPH_0&export=3' % \",\".join(quoted_terms)\n\n        data = urlopen(query).read().decode('utf8')\n        print(\"Done.\")\n        # In the notebook they did some data cleaning: remove Javascript header+footer, and translate new Date(....,..,..) into YYYY-MM-DD.\n        header = \"\"\"// Data table response\\ngoogle.visualization.Query.setResponse(\"\"\"\n        data = data[len(header):-2]\n        data = re.sub('new Date\\((\\d+),(\\d+),(\\d+)\\)', (lambda m: '\"%s-%02d-%02d\"' % (m.group(1).strip(), 1+int(m.group(2)), int(m.group(3)))), data)\n        timeseries = json.loads(data)\n        columns = [k['label'] for k in timeseries['table']['cols']]\n        rows = list(map(lambda x: [k['v'] for k in x['c']], timeseries['table']['rows']))\n        df = pd.DataFrame(rows, columns=columns)\n        if not os.path.isdir(dir_path):\n            os.makedirs(dir_path)\n\n        df.to_csv(file_name)\n    else:\n        print(\"Reading cached data for google trends. To refresh the cache set 'refresh_data=True' when calling this function.\")\n        print(\"Query terms: \", ', '.join(query_terms))\n\n        df = pd.read_csv(file_name, parse_dates=[0])\n\n    columns = df.columns\n    terms = len(query_terms)\n    import datetime\n    from matplotlib.dates import date2num\n    X = np.asarray([(date2num(datetime.datetime.strptime(df.ix[row]['Date'], '%Y-%m-%d')), i) for i in range(terms) for row in df.index])\n    Y = np.asarray([[df.ix[row][query_terms[i]]] for i in range(terms) for row in df.index ])\n    output_info = columns[1:]\n    cats = {}\n    for i in range(terms):\n        cats[query_terms[i]] = i\n    return data_details_return({'data frame' : df, 'X': X, 'Y': Y, 'query_terms': query_terms, 'info': \"Data downloaded from google trends with query terms: \" + ', '.join(query_terms) + '.', 'covariates' : [datenum('date'), discrete(cats, 'query_terms')], 'response' : ['normalized interest']}, data_set)", "response": "Download the data from Google trends."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef toy_linear_1d_classification(seed=default_seed):\n    def sample_class(f):\n        p = 1. / (1. + np.exp(-f))\n        c = np.random.binomial(1, p)\n        c = np.where(c, 1, -1)\n        return c\n\n    np.random.seed(seed=seed)\n    x1 = np.random.normal(-3, 5, 20)\n    x2 = np.random.normal(3, 5, 20)\n    X = (np.r_[x1, x2])[:, None]\n    return {'X': X, 'Y':  sample_class(2.*X), 'F': 2.*X, 'covariates' : ['X'], 'response': [discrete({'positive': 1, 'negative': -1})],'seed' : seed}", "response": "Simple classification data in one dimension for illustrating models."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the movie body count for the given movie set.", "response": "def movie_body_count(data_set='movie_body_count'):\n    \"\"\"Data set of movies and body count for movies scraped from www.MovieBodyCounts.com created by Simon Garnier and Randy Olson for exploring differences between Python and R.\"\"\"\n    if not data_available(data_set):\n        download_data(data_set)\n\n    from pandas import read_csv\n    dir_path = os.path.join(data_path, data_set)\n    filename = os.path.join(dir_path, 'film-death-counts-Python.csv')\n    Y = read_csv(filename)\n    Y['Actors'] = Y['Actors'].apply(lambda x: x.split('|'))\n    Y['Genre'] = Y['Genre'].apply(lambda x: x.split('|'))\n    Y['Director'] = Y['Director'].apply(lambda x: x.split('|'))\n    return data_details_return({'Y': Y, 'info' : \"Data set of movies and body count for movies scraped from www.MovieBodyCounts.com created by Simon Garnier and Randy Olson for exploring differences between Python and R.\",\n                                }, data_set)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the data set of movies and body count for movie rated R.", "response": "def movie_body_count_r_classify(data_set='movie_body_count'):\n    \"\"\"Data set of movies and body count for movies scraped from www.MovieBodyCounts.com created by Simon Garnier and Randy Olson for exploring differences between Python and R.\"\"\"\n    data = movie_body_count()['Y']\n    import pandas as pd\n    import numpy as np\n    X = data[['Year', 'Body_Count']]\n    Y = data['MPAA_Rating']=='R' # set label to be positive for R rated films.\n\n    # Create series of movie genres with the relevant index\n    s = data['Genre'].str.split('|').apply(pd.Series, 1).stack()\n    s.index = s.index.droplevel(-1) # to line up with df's index\n\n    # Extract from the series the unique list of genres.\n    genres = s.unique()\n\n    # For each genre extract the indices where it is present and add a column to X\n    for genre in genres:\n        index = s[s==genre].index.tolist()\n        values = pd.Series(np.zeros(X.shape[0]), index=X.index)\n        values[index] = 1\n        X[genre] = values\n    return data_details_return({'X': X, 'Y': Y, 'info' : \"Data set of movies and body count for movies scraped from www.MovieBodyCounts.com created by Simon Garnier and Randy Olson for exploring differences between Python and R. In this variant we aim to classify whether the film is rated R or not depending on the genre, the years and the body count.\",\n                                }, data_set)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef movielens100k(data_set='movielens100k'):\n    if not data_available(data_set):\n        import zipfile\n        download_data(data_set)\n        dir_path = os.path.join(data_path, data_set)\n        zip = zipfile.ZipFile(os.path.join(dir_path, 'ml-100k.zip'), 'r')\n        for name in zip.namelist():\n            zip.extract(name, dir_path)\n    import pandas as pd\n    encoding = 'latin-1'\n    movie_path = os.path.join(data_path, 'movielens100k', 'ml-100k')\n    items = pd.read_csv(os.path.join(movie_path, 'u.item'), index_col = 'index', header=None, sep='|',names=['index', 'title', 'date', 'empty', 'imdb_url', 'unknown', 'Action', 'Adventure', 'Animation', 'Children''s', 'Comedy', 'Crime', 'Documentary', 'Drama', 'Fantasy', 'Film-Noir', 'Horror', 'Musical', 'Mystery', 'Romance', 'Sci-Fi', 'Thriller', 'War', 'Western'], encoding=encoding)\n    users = pd.read_csv(os.path.join(movie_path, 'u.user'), index_col = 'index', header=None, sep='|', names=['index', 'age', 'sex', 'job', 'id'], encoding=encoding)\n    parts = ['u1.base', 'u1.test', 'u2.base', 'u2.test','u3.base', 'u3.test','u4.base', 'u4.test','u5.base', 'u5.test','ua.base', 'ua.test','ub.base', 'ub.test']\n    ratings = []\n    for part in parts:\n        rate_part = pd.read_csv(os.path.join(movie_path, part), index_col = 'index', header=None, sep='\\t', names=['user', 'item', 'rating', 'index'], encoding=encoding)\n        rate_part['split'] = part\n        ratings.append(rate_part)\n    Y = pd.concat(ratings)\n    return data_details_return({'Y':Y, 'film_info':items, 'user_info':users, 'info': 'The Movielens 100k data'}, data_set)", "response": "Data set of movie ratings collected by the University of Minnesota and cleaned up for use."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef calc_horizontal_infrared_radiation_intensity(weatherdata):\n    temp_drybulb_K = C2K(weatherdata._dry_bulb_temperature)\n    temp_dew_K = C2K(weatherdata.dew_point_temperature)\n    N = weatherdata.opaque_sky_cover\n    sky_emissivity = (0.787 + 0.764 * math.log(temp_dew_K / C2K(0.0)) *\n                      (1.0 + 0.0224 * N - 0.0035 * N ** 2 + 0.00028 * N ** 3))\n    hor_id = sky_emissivity * sigma * temp_drybulb_K ** 4\n    weatherdata.horizontal_infrared_radiation_intensity = hor_id", "response": "Calculates the global horizontal infrared radiation intensity based on drybulb dewpoint and opaque sky cover."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef download_url(url, dir_name='.', save_name=None, store_directory=None, messages=True, suffix=''):\n    if sys.version_info>=(3,0):\n        from urllib.parse import quote\n        from urllib.request import urlopen \n        from urllib.error import HTTPError, URLError\n    else:\n        from urllib2 import quote\n        from urllib2 import urlopen\n        from urllib2 import URLError as HTTPError\n    i = url.rfind('/')\n    file = url[i+1:]\n    if store_directory is not None:\n        dir_name = os.path.join(dir_name, store_directory)\n    if save_name is None:\n        save_name = file\n    save_name = os.path.join(dir_name, save_name)\n    print(\"Downloading \", url, \"->\", save_name)\n    if not os.path.exists(dir_name):\n        os.makedirs(dir_name)\n    try:\n        response = urlopen(url+suffix)\n    except HTTPError as e:\n        if not hasattr(e, \"code\"):\n            raise\n        if e.code > 399 and e.code<500:\n            raise ValueError('Tried url ' + url + suffix + ' and received client error ' + str(e.code))\n        elif e.code > 499:\n            raise ValueError('Tried url ' + url + suffix + ' and received server error ' + str(e.code))\n    except URLError as e:\n        raise ValueError('Tried url ' + url + suffix + ' and failed with error ' + str(e.reason))\n    with open(save_name, 'wb') as f:\n        meta = response.info()\n        content_length_str = meta.get(\"Content-Length\")\n        if content_length_str:\n            #if sys.version_info>=(3,0):\n            try:\n                file_size = int(content_length_str)\n            except:\n                try: \n                    file_size = int(content_length_str[0])\n                except:\n                    file_size = None\n            if file_size == 1:\n                file_size = None\n            #else:\n            #    file_size = int(content_length_str)\n        else:\n            file_size = None\n        \n        status = \"\"\n        file_size_dl = 0\n        block_sz = 8192\n        line_length = 30\n        percentage = 1./line_length\n        \n        if file_size:\n            print(\"|\"+\"{:^{ll}}\".format(\"Downloading {:7.3f}MB\".format(file_size/(1048576.)), ll=line_length)+\"|\")\n            from itertools import cycle\n            cycle_str = cycle('>')\n            sys.stdout.write(\"|\")\n                    \n        while True:\n            buff = response.read(block_sz)\n            if not buff:\n                break\n            file_size_dl += len(buff)\n            f.write(buff)\n            \n            # If content_length_str was incorrect, we can end up with many too many equals signs, catches this edge case\n            #correct_meta = float(file_size_dl)/file_size <= 1.0\n            \n            if file_size:\n                if (float(file_size_dl)/file_size) >= percentage:\n                    sys.stdout.write(next(cycle_str))\n                    sys.stdout.flush()\n                    percentage += 1./line_length\n                #percentage = \"=\"*int(line_length*float(file_size_dl)/file_size)\n                #status = r\"[{perc: <{ll}}] {dl:7.3f}/{full:.3f}MB\".format(dl=file_size_dl/(1048576.), full=file_size/(1048576.), ll=line_length, perc=percentage)\n            else:\n                sys.stdout.write(\" \"*(len(status)) + \"\\r\")\n                status = r\"{dl:7.3f}MB\".format(dl=file_size_dl/(1048576.),\n                                                                       ll=line_length,\n                                                                       perc=\".\"*int(line_length*float(file_size_dl/(10*1048576.))))\n                sys.stdout.write(status)\n                sys.stdout.flush()\n\n            #sys.stdout.write(status)\n        \n        if file_size:\n            sys.stdout.write(\"|\")\n            sys.stdout.flush()\n\n        print(status)", "response": "Download a file from a url and save it to disk."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef access_elementusers(self, elementuser_id, access_id=None, tenant_id=None, api_version=\"v2.0\"):\n\n        if tenant_id is None and self._parent_class.tenant_id:\n            # Pull tenant_id from parent namespace cache.\n            tenant_id = self._parent_class.tenant_id\n        elif not tenant_id:\n            # No value for tenant_id.\n            raise TypeError(\"tenant_id is required but not set or cached.\")\n        cur_ctlr = self._parent_class.controller\n\n        if not access_id:\n            url = str(cur_ctlr) + \"/{}/api/tenants/{}/elementusers/{}/access\".format(api_version,\n                                                                                     tenant_id,\n                                                                                     elementuser_id)\n        else:\n            url = str(cur_ctlr) + \"/{}/api/tenants/{}/elementusers/{}/access/{}\".format(api_version,\n                                                                                        tenant_id,\n                                                                                        elementuser_id,\n                                                                                        access_id)\n\n        api_logger.debug(\"URL = %s\", url)\n        return self._parent_class.rest_call(url, \"get\")", "response": "Get all accesses for a particular element user."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef login(self, email=None, password=None):\n        # if email not given in function, or if first login fails, prompt.\n\n        if email is None:\n            # If user is not set, pull from cache. If not in cache, prompt.\n            if self._parent_class.email:\n                email = self._parent_class.email\n            else:\n                email = compat_input(\"login: \")\n\n        if password is None:\n            # if pass not given on function, or if first login fails, prompt.\n            if self._parent_class._password:\n                password = self._parent_class._password\n            else:\n                password = getpass.getpass()\n\n        # Try and login\n        # For SAML 2.0 support, set the Referer URL prior to logging in.\n        # add referer header to the session.\n        self._parent_class.add_headers({'Referer': \"{}/v2.0/api/login\".format(self._parent_class.controller)})\n\n        # call the login API.\n        response = self._parent_class.post.login({\"email\": email, \"password\": password})\n\n        if response.cgx_status:\n\n            # Check for SAML 2.0 login\n            if not response.cgx_content.get('x_auth_token'):\n                urlpath = response.cgx_content.get(\"urlpath\", \"\")\n                request_id = response.cgx_content.get(\"requestId\", \"\")\n                if urlpath and request_id:\n                    # SAML 2.0\n                    print('SAML 2.0: To finish login open the following link in a browser\\n\\n{0}\\n\\n'.format(urlpath))\n                    found_auth_token = False\n                    for i in range(20):\n                        print('Waiting for {0} seconds for authentication...'.format((20 - i) * 5))\n                        saml_response = self.check_sso_login(email, request_id)\n                        if saml_response.cgx_status and saml_response.cgx_content.get('x_auth_token'):\n                            found_auth_token = True\n                            break\n                        # wait before retry.\n                        time.sleep(5)\n                    if not found_auth_token:\n                        print(\"Login time expired! Please re-login.\\n\")\n                        # log response when debug\n                        try:\n                            api_logger.debug(\"LOGIN_FAIL_RESPONSE = %s\", json.dumps(response, indent=4))\n                        except (TypeError, ValueError):\n                            # not JSON response, don't pretty print log.\n                            api_logger.debug(\"LOGIN_FAIL_RESPONSE = %s\", str(response))\n                        # print login error\n                        print('Login failed, please try again', response)\n                        # Flush command-line entered login info if failure.\n                        self._parent_class.email = None\n                        self._parent_class.password = None\n                        return False\n\n            api_logger.info('Login successful:')\n            # if we got here, we either got an x_auth_token in the original login, or\n            # we got an auth_token cookie set via SAML. Figure out which.\n            auth_token = response.cgx_content.get('x_auth_token')\n            if auth_token:\n                # token in the original login (not saml) means region parsing has not been done.\n                # do now, and recheck if cookie needs set.\n                auth_region = self._parent_class.parse_region(response)\n                self._parent_class.update_region_to_controller(auth_region)\n                self._parent_class.reparse_login_cookie_after_region_update(response)\n            # debug info if needed\n            api_logger.debug(\"AUTH_TOKEN=%s\", response.cgx_content.get('x_auth_token'))\n\n            # Step 2: Get operator profile for tenant ID and other info.\n            if self.interactive_update_profile_vars():\n\n                # pull tenant detail\n                if self._parent_class.tenant_id:\n\n                    # add tenant values to API() object\n                    if self.interactive_tenant_update_vars():\n\n                        # Step 3: Check for ESP/MSP. If so, ask which tenant this session should be for.\n                        if self._parent_class.is_esp:\n                            # ESP/MSP!\n                            choose_status, chosen_client_id = self.interactive_client_choice()\n\n                            if choose_status:\n                                # attempt to login as client\n                                clogin_resp = self._parent_class.post.login_clients(chosen_client_id, {})\n\n                                if clogin_resp.cgx_status:\n                                    # login successful, update profile and tenant info\n                                    c_profile = self.interactive_update_profile_vars()\n                                    t_profile = self.interactive_tenant_update_vars()\n\n                                    if c_profile and t_profile:\n                                        # successful full client login.\n                                        self._parent_class._password = None\n                                        # remove referer header prior to continuing.\n                                        self._parent_class.remove_header('Referer')\n                                        return True\n\n                                    else:\n                                        if t_profile:\n                                            print(\"ESP Client Tenant detail retrieval failed.\")\n                                        # clear password out of memory\n                                        self._parent_class.email = None\n                                        self._parent_class._password = None\n                                        # remove referer header prior to continuing.\n                                        self._parent_class.remove_header('Referer')\n                                        return False\n\n                                else:\n                                    print(\"ESP Client Login failed.\")\n                                    # clear password out of memory\n                                    self._parent_class.email = None\n                                    self._parent_class._password = None\n                                    # remove referer header prior to continuing.\n                                    self._parent_class.remove_header('Referer')\n                                    return False\n\n                            else:\n                                print(\"ESP Client Choice failed.\")\n                                # clear password out of memory\n                                self._parent_class.email = None\n                                self._parent_class._password = None\n                                # remove referer header prior to continuing.\n                                self._parent_class.remove_header('Referer')\n                                return False\n\n                        # successful!\n                        # clear password out of memory\n                        self._parent_class._password = None\n                        # remove referer header prior to continuing.\n                        self._parent_class.remove_header('Referer')\n                        return True\n\n                    else:\n                        print(\"Tenant detail retrieval failed.\")\n                        # clear password out of memory\n                        self._parent_class.email = None\n                        self._parent_class._password = None\n                        # remove referer header prior to continuing.\n                        self._parent_class.remove_header('Referer')\n                        return False\n\n            else:\n                # Profile detail retrieval failed\n                self._parent_class.email = None\n                self._parent_class._password = None\n                return False\n\n            api_logger.info(\"EMAIL = %s\", self._parent_class.email)\n            api_logger.info(\"USER_ID = %s\", self._parent_class._user_id)\n            api_logger.info(\"USER ROLES = %s\", json.dumps(self._parent_class.roles))\n            api_logger.info(\"TENANT_ID = %s\", self._parent_class.tenant_id)\n            api_logger.info(\"TENANT_NAME = %s\", self._parent_class.tenant_name)\n            api_logger.info(\"TOKEN_SESSION = %s\", self._parent_class.token_session)\n\n            # remove referer header prior to continuing.\n            self._parent_class.remove_header('Referer')\n        else:\n            # log response when debug\n            api_logger.debug(\"LOGIN_FAIL_RESPONSE = %s\", json.dumps(response.cgx_content, indent=4))\n            # print login error\n            print('Login failed, please try again:', response.cgx_content)\n            # Flush command-line entered login info if failure.\n            self._parent_class.email = None\n            self._parent_class.password = None\n\n            # remove referer header prior to continuing.\n            self._parent_class.remove_header('Referer')\n        return False", "response": "Interactively logs in using the CloudGenix API."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nfunctioning to use a token as auth for the API.", "response": "def use_token(self, token=None):\n        \"\"\"\n        Function to use static AUTH_TOKEN as auth for the constructor instead of full login process.\n\n        **Parameters:**:\n\n          - **token**: Static AUTH_TOKEN\n\n        **Returns:** Bool on success or failure. In addition the function will mutate the `cloudgenix.API`\n                     constructor items as needed.\n        \"\"\"\n        api_logger.info('use_token function:')\n\n        # check token is a string.\n        if not isinstance(token, (text_type, binary_type)):\n            api_logger.debug('\"token\" was not a text-style string: {}'.format(text_type(token)))\n            return False\n\n        # Start setup of constructor.\n        session = self._parent_class.expose_session()\n\n        # clear cookies\n        session.cookies.clear()\n\n        # Static Token uses X-Auth-Token header instead of cookies.\n        self._parent_class.add_headers({\n            'X-Auth-Token': token\n        })\n\n        # Step 2: Get operator profile for tenant ID and other info.\n        if self.interactive_update_profile_vars():\n\n            # pull tenant detail\n            if self._parent_class.tenant_id:\n\n                # add tenant values to API() object\n                if self.interactive_tenant_update_vars():\n\n                    # Step 3: Check for ESP/MSP. If so, ask which tenant this session should be for.\n                    if self._parent_class.is_esp:\n                        # ESP/MSP!\n                        choose_status, chosen_client_id = self.interactive_client_choice()\n\n                        if choose_status:\n                            # attempt to login as client\n                            clogin_resp = self._parent_class.post.login_clients(chosen_client_id, {})\n\n                            if clogin_resp.cgx_status:\n                                # login successful, update profile and tenant info\n                                c_profile = self.interactive_update_profile_vars()\n                                t_profile = self.interactive_tenant_update_vars()\n\n                                if c_profile and t_profile:\n                                    # successful full client login.\n                                    self._parent_class._password = None\n                                    return True\n\n                                else:\n                                    if t_profile:\n                                        print(\"ESP Client Tenant detail retrieval failed.\")\n                                    # clear password out of memory\n                                    self._parent_class.email = None\n                                    self._parent_class._password = None\n                                    return False\n\n                            else:\n                                print(\"ESP Client Login failed.\")\n                                # clear password out of memory\n                                self._parent_class.email = None\n                                self._parent_class._password = None\n                                return False\n\n                        else:\n                            print(\"ESP Client Choice failed.\")\n                            # clear password out of memory\n                            self._parent_class.email = None\n                            self._parent_class._password = None\n                            return False\n\n                    # successful!\n                    # clear password out of memory\n                    self._parent_class._password = None\n                    return True\n\n                else:\n                    print(\"Tenant detail retrieval failed.\")\n                    # clear password out of memory\n                    self._parent_class.email = None\n                    self._parent_class._password = None\n                    return False\n\n        else:\n            # Profile detail retrieval failed\n            self._parent_class.email = None\n            self._parent_class._password = None\n            return False\n\n        api_logger.info(\"EMAIL = %s\", self._parent_class.email)\n        api_logger.info(\"USER_ID = %s\", self._parent_class._user_id)\n        api_logger.info(\"USER ROLES = %s\", json.dumps(self._parent_class.roles))\n        api_logger.info(\"TENANT_ID = %s\", self._parent_class.tenant_id)\n        api_logger.info(\"TENANT_NAME = %s\", self._parent_class.tenant_name)\n        api_logger.info(\"TOKEN_SESSION = %s\", self._parent_class.token_session)\n\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nfunctioning to update the cloudgenix. API object with tenant login info. Run after login or client login.", "response": "def interactive_tenant_update_vars(self):\n        \"\"\"\n        Function to update the `cloudgenix.API` object with tenant login info. Run after login or client login.\n\n        **Returns:** Boolean on success/failure,\n        \"\"\"\n        api_logger.info('interactive_tenant_update_vars function:')\n        tenant_resp = self._parent_class.get.tenants(self._parent_class.tenant_id)\n        status = tenant_resp.cgx_status\n        tenant_dict = tenant_resp.cgx_content\n\n        if status:\n\n            api_logger.debug(\"new tenant_dict: %s\", tenant_dict)\n\n            # Get Tenant info.\n            self._parent_class.tenant_name = tenant_dict.get('name', self._parent_class.tenant_id)\n            # is ESP/MSP?\n            self._parent_class.is_esp = tenant_dict.get('is_esp')\n            # grab tenant address for location.\n            address_lookup = tenant_dict.get('address', None)\n            if address_lookup:\n                tenant_address = address_lookup.get('street', \"\") + \", \"\n                tenant_address += (str(address_lookup.get('street2', \"\")) + \", \")\n                tenant_address += (str(address_lookup.get('city', \"\")) + \", \")\n                tenant_address += (str(address_lookup.get('state', \"\")) + \", \")\n                tenant_address += (str(address_lookup.get('post_code', \"\")) + \", \")\n                tenant_address += (str(address_lookup.get('country', \"\")) + \", \")\n            else:\n                tenant_address = \"Unknown\"\n            self._parent_class.address = tenant_address\n            return True\n        else:\n            # update failed\n            return False"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nfunction to update the cloudgenix. API object with profile info. Run after login or client login.", "response": "def interactive_update_profile_vars(self):\n        \"\"\"\n        Function to update the `cloudgenix.API` object with profile info. Run after login or client login.\n\n        **Returns:** Boolean on success/failure,\n        \"\"\"\n\n        profile = self._parent_class.get.profile()\n\n        if profile.cgx_status:\n\n            # if successful, save tenant id and email info to cli state.\n            self._parent_class.tenant_id = profile.cgx_content.get('tenant_id')\n            self._parent_class.email = profile.cgx_content.get('email')\n            self._parent_class._user_id = profile.cgx_content.get('id')\n            self._parent_class.roles = profile.cgx_content.get('roles', [])\n            self._parent_class.token_session = profile.cgx_content.get('token_session')\n\n            return True\n\n        else:\n            print(\"Profile retrieval failed.\")\n            # clear password out of memory\n            self._parent_class._password = None\n            return False"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef interactive_client_choice(self):\n\n        clients = self._parent_class.get.clients_t()\n        clients_perms = self._parent_class.get.permissions_clients_d(self._parent_class._user_id)\n\n        client_status = clients.cgx_status\n        clients_dict = clients.cgx_content\n        c_perms_status = clients_perms.cgx_status\n        c_perms_dict = clients_perms.cgx_content\n\n        # Build MSP/ESP id-name dict, get list of allowed tenants.\n        if client_status and c_perms_status:\n            client_id_name = {}\n            for client in clients_dict.get('items', []):\n                if type(client) is dict:\n                    # create client ID to name map table.\n                    client_id_name[client.get('id', \"err\")] = client.get('canonical_name')\n\n            # Valid clients w/permissions - create list of tuples for menu\n            menu_list = []\n            for client in c_perms_dict.get('items', []):\n                if type(client) is dict:\n                    # add entry\n                    client_id = client.get('client_id')\n                    # create tuple of ( client name, client id ) to append to list\n                    menu_list.append(\n                        (client_id_name.get(client_id, client_id), client_id)\n                    )\n            # empty menu?\n            if not menu_list:\n                # no clients\n                print(\"No ESP/MSP clients allowed for user.\")\n                return False, {}\n\n            # ask user to select client\n            _, chosen_client_id = self.quick_menu(\"ESP/MSP Detected. Select a client to use:\", \"{0}) {1}\", menu_list)\n\n            return True, chosen_client_id\n\n        else:\n            print(\"ESP/MSP detail retrieval failed.\")\n            return False, {}", "response": "Interactively ask user to select a client from ESP managed clients."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef quick_menu(self, banner, list_line_format, choice_list):\n        # Setup menu\n        invalid = True\n        menu_int = -1\n\n        # loop until valid\n        while invalid:\n            print(banner)\n\n            for item_index, item_value in enumerate(choice_list):\n                print(list_line_format.format(item_index + 1, *item_value))\n\n            menu_choice = compat_input(\"\\nChoose a Number or (Q)uit: \")\n\n            if str(menu_choice).lower() in ['q']:\n                # exit\n                print(\"Exiting..\")\n                # best effort logout\n                self._parent_class.get.logout()\n                sys.exit(0)\n\n            # verify number entered\n            try:\n                menu_int = int(menu_choice)\n                sanity = True\n            except ValueError:\n                # not a number\n                print(\"ERROR: \", menu_choice)\n                sanity = False\n\n            # validate number chosen\n            if sanity and 1 <= menu_int <= len(choice_list):\n                invalid = False\n            else:\n                print(\"Invalid input, needs to be between 1 and {0}.\\n\".format(len(choice_list)))\n\n        # return the choice_list tuple that matches the entry.\n        return choice_list[int(menu_int) - 1]", "response": "Function to display a quick menu for user input"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nlogging-in to the CloudGenix API, and see if SAML SSO has occurred. This function is used to check and see if SAML SSO has succeeded while waiting. **Parameters:** - **operator_email:** String with the username to log in with - **request_id:** String containing the SAML 2.0 Request ID from previous login attempt. **Returns:** Tuple (Boolean success, Token on success, JSON response on error.)", "response": "def check_sso_login(self, operator_email, request_id):\n        \"\"\"\n        Login to the CloudGenix API, and see if SAML SSO has occurred.\n        This function is used to check and see if SAML SSO has succeeded while waiting.\n\n        **Parameters:**\n\n          - **operator_email:** String with the username to log in with\n          - **request_id:** String containing the SAML 2.0 Request ID from previous login attempt.\n\n        **Returns:** Tuple (Boolean success, Token on success, JSON response on error.)\n        \"\"\"\n\n        data = {\n            \"email\": operator_email,\n            \"requestId\": request_id\n        }\n\n        # If debug is set..\n        api_logger.info('check_sso_login function:')\n\n        response = self._parent_class.post.login(data=data)\n\n        # If valid response, but no token.\n        if not response.cgx_content.get('x_auth_token'):\n            # no valid login yet.\n            return response\n\n        # update with token and region\n        auth_region = self._parent_class.parse_region(response)\n        self._parent_class.update_region_to_controller(auth_region)\n        self._parent_class.reparse_login_cookie_after_region_update(response)\n\n        return response"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef logout(self, force=False):\n        # Extract requests session for manipulation.\n        session = self._parent_class.expose_session()\n\n        # if force = True, or token_session = None/False, call logout API.\n        if force or not self._parent_class.token_session:\n            # Call Logout\n            result = self._parent_class.get.logout()\n            if result.cgx_status:\n                # clear info from session.\n                self._parent_class.tenant_id = None\n                self._parent_class.tenant_name = None\n                self._parent_class.is_esp = None\n                self._parent_class.client_id = None\n                self._parent_class.address_string = None\n                self._parent_class.email = None\n                self._parent_class._user_id = None\n                self._parent_class._password = None\n                self._parent_class.roles = None\n                self._parent_class.token_session = None\n                # Cookies are removed via LOGOUT API call. if X-Auth-Token set, clear.\n                if session.headers.get('X-Auth-Token'):\n                    self._parent_class.remove_header('X-Auth-Token')\n\n            return result.cgx_status\n\n        else:\n            # Token Session and not forced.\n            api_logger.debug('TOKEN SESSION, LOGOUT API NOT CALLED.')\n            # clear info from session.\n            self._parent_class.tenant_id = None\n            self._parent_class.tenant_name = None\n            self._parent_class.is_esp = None\n            self._parent_class.client_id = None\n            self._parent_class.address_string = None\n            self._parent_class.email = None\n            self._parent_class._user_id = None\n            self._parent_class._password = None\n            self._parent_class.roles = None\n            self._parent_class.token_session = None\n            # if X-Auth-Token set, clear.\n            if session.headers.get('X-Auth-Token'):\n                self._parent_class.remove_header('X-Auth-Token')\n\n            return True", "response": "Logout of the current user."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nfunction to display a quick confirmation for user input AttributeNames", "response": "def quick_confirm(prompt, default_value):\n        \"\"\"\n        Function to display a quick confirmation for user input\n\n        **Parameters:**\n\n          - **prompt:** Text to display before confirm\n          - **default_value:** Default value for no entry\n\n        **Returns:** 'y', 'n', or Default value.\n        \"\"\"\n        valid = False\n        value = default_value.lower()\n        while not valid:\n            input_val = compat_input(prompt + \"[{0}]: \".format(default_value))\n\n            if input_val == \"\":\n                value = default_value.lower()\n                valid = True\n            else:\n                try:\n                    if input_val.lower() in ['y', 'n']:\n                        value = input_val.lower()\n                        valid = True\n                    else:\n                        print(\"ERROR: enter 'Y' or 'N'.\")\n                        valid = False\n\n                except ValueError:\n                    print(\"ERROR: enter 'Y' or 'N'.\")\n                    valid = False\n\n        return value"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nfunctioning to display a quick question for integer user input", "response": "def quick_int_input(prompt, default_value, min_val=1, max_val=30):\n        \"\"\"\n        Function to display a quick question for integer user input\n\n        **Parameters:**\n\n          - **prompt:** Text / question to display\n          - **default_value:** Default value for no entry\n          - **min_val:** Lowest allowed integer\n          - **max_val:** Highest allowed integer\n\n        **Returns:** integer or default_value.\n        \"\"\"\n        valid = False\n        num_val = default_value\n        while not valid:\n            input_val = compat_input(prompt + \"[{0}]: \".format(default_value))\n\n            if input_val == \"\":\n                num_val = default_value\n                valid = True\n            else:\n                try:\n                    num_val = int(input_val)\n                    if min_val <= num_val <= max_val:\n                        valid = True\n                    else:\n                        print(\"ERROR: must be between {0} and {1}.\".format(min, max))\n                        valid = False\n\n                except ValueError:\n                    print(\"ERROR: must be a number.\")\n                    valid = False\n\n        return num_val"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef quick_str_input(prompt, default_value):\n        valid = False\n        str_val = default_value\n        while not valid:\n            input_val = raw_input(prompt + \"[{0}]: \".format(default_value))\n\n            if input_val == \"\":\n                str_val = default_value\n                valid = True\n            else:\n                try:\n                    str_val = text_type(input_val)\n                    valid = True\n\n                except ValueError:\n                    print(\"ERROR: must be text.\")\n                    valid = False\n\n        return str_val", "response": "Function to display a quick question for text input."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef compare_digests(digest_1, digest_2, is_hex_1=True, is_hex_2=True, threshold=None):\n    # if we have both hexes use optimized method\n    if threshold is not None:\n        threshold -= 128\n        threshold *= -1\n    if is_hex_1 and is_hex_2:\n        bits =  0\n        for i in range_(0, 63, 2):\n            bits += POPC[255 & int(digest_1[i:i+2], 16) ^ int(digest_2[i:i+2], 16)]\n            if threshold is not None and bits > threshold: break\n        return 128 - bits\n    else:\n        # at least one of the inputs is a list of unsigned ints\n        if is_hex_1:  digest_1 = convert_hex_to_ints(digest_1)\n        if is_hex_2:  digest_2 = convert_hex_to_ints(digest_2)\n        bit_diff = 0\n        for i in range(len(digest_1)):\n            bit_diff += POPC[255 & digest_1[i] ^ digest_2[i]]\n            if threshold is not None and bit_diff > threshold: break\n        return 128 - bit_diff", "response": "Compare two digests and returns the bit difference between them."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef process(self, chunk):\n        self._digest = None\n\n        if isinstance(chunk, text_type):\n            chunk = chunk.encode('utf-8')\n\n        # chunk is a byte string\n        for char in chunk:\n            self.num_char += 1\n            if PY3:\n                # In Python 3, iterating over bytes yields integers\n                c = char\n            else:\n                c = ord(char)\n            if len(self.window) > 1:            # seen at least three characters\n                self.acc[self.tran_hash(c, self.window[0], self.window[1], 0)] += 1\n            if len(self.window) > 2:            # seen at least four characters\n                self.acc[self.tran_hash(c, self.window[0], self.window[2], 1)] += 1\n                self.acc[self.tran_hash(c, self.window[1], self.window[2], 2)] += 1\n            if len(self.window) > 3:            # have a full window\n                self.acc[self.tran_hash(c, self.window[0], self.window[3], 3)] += 1\n                self.acc[self.tran_hash(c, self.window[1], self.window[3], 4)] += 1\n                self.acc[self.tran_hash(c, self.window[2], self.window[3], 5)] += 1\n                # duplicate hashes, used to maintain 8 trigrams per character\n                self.acc[self.tran_hash(self.window[3], self.window[0], c, 6)] += 1\n                self.acc[self.tran_hash(self.window[3], self.window[2], c, 7)] += 1\n\n            # add current character to the window, remove the previous character\n            if len(self.window) < 4:\n                self.window = [c] + self.window\n            else:\n                self.window = [c] + self.window[:3]", "response": "Processes a chunk of data and returns the hash of all of the trigrams in the chunk."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncomputes the digest of the nilsimsa entry for the current locale.", "response": "def compute_digest(self):\n        \"\"\"\n        using a threshold (mean of the accumulator), computes the nilsimsa digest\n        \"\"\"\n        num_trigrams = 0\n        if self.num_char == 3:          # 3 chars -> 1 trigram\n            num_trigrams = 1\n        elif self.num_char == 4:        # 4 chars -> 4 trigrams\n            num_trigrams = 4\n        elif self.num_char > 4:         # > 4 chars -> 8 for each char\n            num_trigrams = 8 * self.num_char - 28\n\n        # threshhold is the mean of the acc buckets\n        threshold = num_trigrams / 256.0\n\n        digest = [0] * 32\n        for i in range(256):\n            if self.acc[i] > threshold:\n                digest[i >> 3] += 1 << (i & 7)      # equivalent to i/8, 2**(i mod 7)\n\n        self._digest = digest[::-1]"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef from_file(self, fname):\n        f = open(fname, \"rb\")\n        data = f.read()\n        self.update(data)\n        f.close()", "response": "read in a file and compute digest"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the difference between the nilsimsa digests between the current object and a given digest", "response": "def compare(self, digest_2, is_hex = False):\n        \"\"\"\n        returns difference between the nilsimsa digests between the current\n        object and a given digest\n        \"\"\"\n        # convert hex string to list of ints\n        if is_hex:\n            digest_2 = convert_hex_to_ints(digest_2)\n\n        bit_diff = 0\n        for i in range(len(self.digest)):\n            bit_diff += POPC[self.digest[i] ^ digest_2[i]]           #computes the bit diff between the i'th position of the digests\n\n        return 128 - bit_diff"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nlogging-in api **Parameters:**: - **data**: Dictionary containing data to POST as JSON - **api_version**: API version to use (default v2.0) **Returns:** requests.Response object extended with cgx_status and cgx_content properties.", "response": "def login(self, data, api_version=\"v2.0\"):\n        \"\"\"\n        Login api\n\n          **Parameters:**:\n\n          - **data**: Dictionary containing data to POST as JSON\n          - **api_version**: API version to use (default v2.0)\n\n        **Returns:** requests.Response object extended with cgx_status and cgx_content properties.\n        \"\"\"\n\n        cur_ctlr = self._parent_class.controller\n\n        url = str(cur_ctlr) + \"/{}/api/login\".format(api_version)\n\n        api_logger.debug(\"URL = %s\", url)\n        return self._parent_class.rest_call(url, \"post\", data=data, sensitive=True)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nforget password API **Parameters:**: - **data**: Dictionary containing data to POST as JSON - **tenant_id**: Tenant ID - **api_version**: API version to use (default v2.0) **Returns:** requests.Response object extended with cgx_status and cgx_content properties.", "response": "def tenant_forgot_password_login(self, data, tenant_id=None, api_version=\"v2.0\"):\n        \"\"\"\n        Forgot password API\n\n          **Parameters:**:\n\n          - **data**: Dictionary containing data to POST as JSON\n          - **tenant_id**: Tenant ID\n          - **api_version**: API version to use (default v2.0)\n\n        **Returns:** requests.Response object extended with cgx_status and cgx_content properties.\n        \"\"\"\n\n        if tenant_id is None and self._parent_class.tenant_id:\n            # Pull tenant_id from parent namespace cache.\n            tenant_id = self._parent_class.tenant_id\n        elif not tenant_id:\n            # No value for tenant_id.\n            raise TypeError(\"tenant_id is required but not set or cached.\")\n        cur_ctlr = self._parent_class.controller\n\n        url = str(cur_ctlr) + \"/{}/api/tenants/{}/login/password/forgot\".format(api_version,\n                                                                                tenant_id)\n\n        api_logger.debug(\"URL = %s\", url)\n        return self._parent_class.rest_call(url, \"post\", data=data, sensitive=True)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef is_valid_file(parser,arg):\n\tif not os.path.exists(arg):\n       \t\tparser.error(\"File %s not found\"%arg)\n\telse:\n\t       \treturn arg", "response": "verify the validity of the given file. Never trust the End - User"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting the language ID of the input file language", "response": "def getID(code_file):\n\t\"\"\"Get the language ID of the input file language\"\"\"\n\tjson_path = ghostfolder+'/'+json_file\n\tif os.path.exists(json_path):\n\t\tpass\n\telse:\n\t\tdownload_file('https://ghostbin.com/languages.json')\n\n\tlang = detect_lang(code_file)\n\n\tjson_data = json.load(file(json_path))#don't think i need this though\n\tID = ''\n\tfor  i in range(len(json_data)):\n\t\ttemp = len(json_data[i]['languages'])\n\t\tfor j in range(temp):\t\n\t\t\tif json_data[i]['languages'][j]['name'].lower() == lang.lower():\n\t\t\t\tID = json_data[i]['languages'][j]['id']\n\t\t\t\tprint('Gotten language ID from \\'languages.json\\': {0}'.format(ID))\n\t\t\t\treturn ID"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef detect_lang(path):\n\tblob = FileBlob(path, os.getcwd())\n\tif blob.is_text:\n\t\tprint('Programming language of the file detected: {0}'.format(blob.language.name))\n\t\treturn blob.language.name\n\telse:#images, binary and what-have-you won't be pasted\n\t\tprint('File not a text file. Exiting...')\n\t\tsys.exit()", "response": "Detect the language used in the given file."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef set_serial(self, android_serial):\n        self.adb = ADB(android_serial)\n        self.device = Device(android_serial)\n        self.test_helper = TestHelper(self.adb)", "response": "Set the serial number of the device."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nclicks at x y coordinates.", "response": "def click_at_coordinates(self, x, y):\n        \"\"\"\n        Click at (x,y) coordinates.\n        \"\"\"\n        self.device.click(int(x), int(y))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef swipe_by_coordinates(self, sx, sy, ex, ey, steps=10):\n        self.device.swipe(sx, sy, ex, ey, steps)", "response": "Swipe from sx sy ex ey with default steps 10"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nswipes the UI object left with steps = 10", "response": "def swipe_left(self, steps=10, *args, **selectors):\n        \"\"\"\n        Swipe the UI object with *selectors* from center to left.\n\n        Example:\n\n        | Swipe Left | description=Home screen 3 |                           | # swipe the UI object left              |\n        | Swipe Left | 5                         | description=Home screen 3 | # swipe the UI object left with steps=5 |\n\n        See `introduction` for details about Identified UI object.\n        \"\"\"\n        self.device(**selectors).swipe.left(steps=steps)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef swipe_right(self, steps=10, *args, **selectors):\n        self.device(**selectors).swipe.right(steps=steps)", "response": "Swipe the UI object with selectors * from center to right"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef swipe_top(self, steps=10, *args, **selectors):\n        self.device(**selectors).swipe.up(steps=steps)", "response": "Swipe the UI object with selectors * from center to top\n       "}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef swipe_bottom(self, steps=10, *args, **selectors):\n        self.device(**selectors).swipe.down(steps=steps)", "response": "Swipe the UI object with selectors from center to bottom"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ndragging from sx sy to ex ey with steps steps", "response": "def drag_by_coordinates(self,sx, sy, ex, ey, steps=10):\n        \"\"\"\n        Drag from (sx, sy) to (ex, ey) with steps\n\n        See `Swipe By Coordinates` also.\n        \"\"\"\n        self.device.drag(sx, sy, ex, ey, steps)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nwait for the object which has the given selectors within the given timeout.", "response": "def wait_for_exists(self, timeout=0, *args, **selectors):\n        \"\"\"\n        Wait for the object which has *selectors* within the given timeout.\n\n        Return true if the object *appear* in the given timeout. Else return false.\n        \"\"\"\n        return self.device(**selectors).wait.exists(timeout=timeout)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef wait_until_gone(self, timeout=0, *args, **selectors):\n        return self.device(**selectors).wait.gone(timeout=timeout)", "response": "Wait until the object which has selectors in the given timeout."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nperform fling forward horizontally action on the object which has *selectors* attributes. Returns whether the object can be flinged forward horizontally.", "response": "def fling_forward_horizontally(self, *args, **selectors):\n        \"\"\"\n        Perform fling forward (horizontally)action on the object which has *selectors* attributes.\n\n        Return whether the object can be fling or not.\n        \"\"\"\n        return self.device(**selectors).fling.horiz.forward()"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef fling_backward_horizontally(self, *args, **selectors):\n        return self.device(**selectors).fling.horiz.backward()", "response": "This is a horizontally flinging backward action on the object which has *selectors* attributes."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef fling_forward_vertically(self, *args, **selectors):\n        return self.device(**selectors).fling.vert.forward()", "response": "Perform fling forward ( vertically action on the object which has *selectors* attributes. Returns whether the object can be fling forward."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nperform fling backward vertically action on the object which has *selectors* attributes. Returns whether the object can be fling backward.", "response": "def fling_backward_vertically(self, *args, **selectors):\n        \"\"\"\n        Perform fling backward (vertically)action on the object which has *selectors* attributes.\n\n        Return whether the object can be fling or not.\n        \"\"\"\n        return self.device(**selectors).fling.vert.backward()"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nscroll the object which has *selectors* attributes to beginning horizontally.", "response": "def scroll_to_beginning_horizontally(self, steps=10, *args,**selectors):\n        \"\"\"\n        Scroll the object which has *selectors* attributes to *beginning* horizontally.\n\n        See `Scroll Forward Vertically` for more details.\n        \"\"\"\n        return self.device(**selectors).scroll.horiz.toBeginning(steps=steps)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nscroll the object which has *selectors* attributes to end horizontally.", "response": "def scroll_to_end_horizontally(self, steps=10, *args, **selectors):\n        \"\"\"\n        Scroll the object which has *selectors* attributes to *end* horizontally.\n\n        See `Scroll Forward Vertically` for more details.\n        \"\"\"\n        return self.device(**selectors).scroll.horiz.toEnd(steps=steps)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef scroll_forward_horizontally(self, steps=10, *args, **selectors):\n        return self.device(**selectors).scroll.horiz.forward(steps=steps)", "response": "Perform scroll forward horizontally action on the object which has *selectors* attributes."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nperforms scroll backward horizontally action on the object which has *selectors* attributes.", "response": "def scroll_backward_horizontally(self, steps=10, *args, **selectors):\n        \"\"\"\n        Perform scroll backward (horizontally)action on the object which has *selectors* attributes.\n\n        Return whether the object can be Scroll or not.\n\n        See `Scroll Forward Vertically` for more details.\n        \"\"\"\n        return self.device(**selectors).scroll.horiz.backward(steps=steps)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef scroll_to_beginning_vertically(self, steps=10, *args,**selectors):\n        return self.device(**selectors).scroll.vert.toBeginning(steps=steps)", "response": "Scroll the object which has *selectors* attributes to beginning * vertically."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nscrolling the object which has *selectors* attributes to end * vertically.", "response": "def scroll_to_end_vertically(self, steps=10, *args, **selectors):\n        \"\"\"\n        Scroll the object which has *selectors* attributes to *end* vertically.\n\n        See `Scroll Forward Vertically` for more details.\n        \"\"\"\n        return self.device(**selectors).scroll.vert.toEnd(steps=steps)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nperforms scroll forward vertically action on the object which has selectors attributes.", "response": "def scroll_forward_vertically(self, steps=10, *args, **selectors):\n        \"\"\"\n        Perform scroll forward (vertically)action on the object which has *selectors* attributes.\n\n        Return whether the object can be Scroll or not.\n\n        Example:\n        | ${can_be_scroll} | Scroll Forward Vertically | className=android.widget.ListView       |                                   | # Scroll forward the UI object with class name |\n        | ${can_be_scroll} | Scroll Forward Vertically | 100                                     | className=android.widget.ListView | # Scroll with steps |\n        \"\"\"\n        return self.device(**selectors).scroll.vert.forward(steps=steps)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nperform scroll backward vertically action on the object which has *selectors* attributes.", "response": "def scroll_backward_vertically(self, steps=10, *args, **selectors):\n        \"\"\"\n        Perform scroll backward (vertically)action on the object which has *selectors* attributes.\n\n        Return whether the object can be Scroll or not.\n\n        See `Scroll Forward Vertically` for more details.\n        \"\"\"\n        return self.device(**selectors).scroll.vert.backward(steps=steps)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nscrolls the object to the specified selector attributes in the vertically visible UI object.", "response": "def scroll_to_vertically(self, obj, *args,**selectors):\n        \"\"\"\n        Scroll(vertically) on the object: obj to specific UI object which has *selectors* attributes appears.\n\n        Return true if the UI object, else return false.\n\n        Example:\n\n        | ${list}        | Get Object           | className=android.widget.ListView |              | # Get the list object     |\n        | ${is_web_view} | Scroll To Vertically | ${list}                           | text=WebView | # Scroll to text:WebView. |\n        \"\"\"\n        return obj.scroll.vert.to(**selectors)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ntake a screenshot of device and log in the report with timestamp scale and quality for screenshot size quality default scale and quality for screenshot size quality", "response": "def screenshot(self, scale=None, quality=None):\n        \"\"\"\n        Take a screenshot of device and log in the report with timestamp, scale for screenshot size and quality for screenshot quality\n        default scale=1.0 quality=100\n        \"\"\"\n        output_dir = BuiltIn().get_variable_value('${OUTPUTDIR}')\n        ts = time.time()\n        st = datetime.datetime.fromtimestamp(ts).strftime('%Y%m%d%H%M%S')\n        screenshot_path = '%s%s%s.png' % (output_dir, os.sep, st)\n        self.device.screenshot(screenshot_path, scale, quality)\n        logger.info('\\n<a href=\"%s\">%s</a><br><img src=\"%s\">' % (screenshot_path, st, screenshot_path), html=True)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef register_click_watcher(self, watcher_name, selectors, *condition_list):\n        watcher = self.device.watcher(watcher_name)\n        for condition in condition_list:\n            watcher.when(**self.__unicode_to_dict(condition))\n        watcher.click(**self.__unicode_to_dict(selectors))\n        self.device.watchers.run()", "response": "Register a click watcher on the object which has the selectors * when conditions match."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef register_press_watcher(self, watcher_name, press_keys, *condition_list):\n        def unicode_to_list(a_unicode):\n            a_list = list()\n            comma_count = a_unicode.count(',')\n            for count in range(comma_count + 1):\n                comma_position = a_unicode.find(',')\n                if comma_position == -1:\n                    a_list.append(str(a_unicode))\n                else:\n                    a_list.append(a_unicode[0:comma_position])\n                    a_unicode = a_unicode[comma_position + 1:]\n            return a_list\n\n        watcher = self.device.watcher(watcher_name)\n        for condition in condition_list:\n            watcher.when(**self.__unicode_to_dict(condition))\n        watcher.press(*unicode_to_list(press_keys))\n        self.device.watchers.run()", "response": "Register a new watcher with the given name and perform press_keys action sequentially when conditions match."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nremove watcher with name watcher_name.", "response": "def remove_watchers(self, watcher_name = None):\n        \"\"\"\n        Remove watcher with *watcher_name* or remove all watchers.\n        \"\"\"\n        if watcher_name == None:\n            self.device.watchers.remove()\n        else:\n            self.device.watchers.remove(watcher_name)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_count(self, *args, **selectors):\n        obj = self.get_object(**selectors)\n        return self.get_count_of_object(obj)", "response": "Get the count of UI objects with selectors *"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_info_of_object(self, obj, selector=None):\n        if selector:\n            return obj.info.get(selector)\n        else:\n            return obj.info", "response": "Returns the info dictionary of the object."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef call(self, obj, method, *args, **selectors):\n        func = getattr(obj, method)\n        return func(**selectors)", "response": "This keyword can use object method from original python uiautomator"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef set_text(self, input_text, *args, **selectors):\n        self.device(**selectors).set_text(input_text)", "response": "Set the text of the input_text to the UI object with the given selectors."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef clear_text(self, *args, **selectors):\n        while True:\n            target = self.device(**selectors)\n            text = target.info['text']\n            target.clear_text()\n            remain_text = target.info['text']\n            if text == ''  or remain_text == text:\n                break", "response": "Clear the text of the UI object with the specified selectors."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef open_notification(self):\n        sdk_version = self.device.info['sdkInt']\n        if sdk_version < 18:\n            height = self.device.info['displayHeight']\n            self.device.swipe(1, 1, 1, height - 1, 1)\n        else:\n            self.device.open.notification()", "response": "Open notification\n\n        Built in support for Android 4.3 (API level 18)\n\n        Using swipe action as a workaround for API level lower than 18"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nsleep for a given amount of time.", "response": "def sleep(self, time):\n        \"\"\"\n        Sleep(no action) for *time* (in millisecond)\n        \"\"\"\n        target = 'wait for %s' % str(time)\n        self.device(text=target).wait.exists(timeout=time)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nconnect to Wi - Fi", "response": "def connect_to_wifi(self, ssid, password=None):\n        \"\"\"\n        [Test Agent]\n\n        Connect to *ssid* with *password*\n        \"\"\"\n        cmd = 'am broadcast -a testagent -e action CONNECT_TO_WIFI -e ssid %s -e password %s' % (ssid, password)\n        self.adb.shell_cmd(cmd)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nmerges two precomputed similarity lists truncating the result to clip most similar items.", "response": "def merge_sims(oldsims, newsims, clip=None):\n    \"\"\"Merge two precomputed similarity lists, truncating the result to `clip` most similar items.\"\"\"\n    if oldsims is None:\n        result = newsims or []\n    elif newsims is None:\n        result = oldsims\n    else:\n        result = sorted(oldsims + newsims, key=lambda item: -item[1])\n    if clip is not None:\n        result = result[:clip]\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ndeleting all files created by this index invalidating self. Use with care.", "response": "def terminate(self):\n        \"\"\"Delete all files created by this index, invalidating `self`. Use with care.\"\"\"\n        try:\n            self.id2sims.terminate()\n        except:\n            pass\n        import glob\n        for fname in glob.glob(self.fname + '*'):\n            try:\n                os.remove(fname)\n                logger.info(\"deleted %s\" % fname)\n            except Exception, e:\n                logger.warning(\"failed to delete %s: %s\" % (fname, e))\n        for val in self.__dict__.keys():\n            try:\n                delattr(self, val)\n            except:\n                pass"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef index_documents(self, fresh_docs, model):\n        docids = fresh_docs.keys()\n        vectors = (model.docs2vecs(fresh_docs[docid] for docid in docids))\n        logger.info(\"adding %i documents to %s\" % (len(docids), self))\n        self.qindex.add_documents(vectors)\n        self.qindex.save()\n        self.update_ids(docids)", "response": "Update fresh index with new documents."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef update_ids(self, docids):\n        logger.info(\"updating %i id mappings\" % len(docids))\n        for docid in docids:\n            if docid is not None:\n                pos = self.id2pos.get(docid, None)\n                if pos is not None:\n                    logger.info(\"replacing existing document %r in %s\" % (docid, self))\n                    del self.pos2id[pos]\n                self.id2pos[docid] = self.length\n                try:\n                    del self.id2sims[docid]\n                except:\n                    pass\n            self.length += 1\n        self.id2sims.sync()\n        self.update_mappings()", "response": "Update id - > pos mapping with new document ids."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsynchronizing id < > position mappings.", "response": "def update_mappings(self):\n        \"\"\"Synchronize id<->position mappings.\"\"\"\n        self.pos2id = dict((v, k) for k, v in self.id2pos.iteritems())\n        assert len(self.pos2id) == len(self.id2pos), \"duplicate ids or positions detected\""}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ndeleting documents from the index.", "response": "def delete(self, docids):\n        \"\"\"Delete documents (specified by their ids) from the index.\"\"\"\n        logger.debug(\"deleting %i documents from %s\" % (len(docids), self))\n        deleted = 0\n        for docid in docids:\n            try:\n                del self.id2pos[docid]\n                deleted += 1\n                del self.id2sims[docid]\n            except:\n                pass\n        self.id2sims.sync()\n        if deleted:\n            logger.info(\"deleted %i documents from %s\" % (deleted, self))\n        self.update_mappings()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef sims2scores(self, sims, eps=1e-7):\n        result = []\n        if isinstance(sims, numpy.ndarray):\n            sims = abs(sims) # TODO or maybe clip? are opposite vectors \"similar\" or \"dissimilar\"?!\n            for pos in numpy.argsort(sims)[::-1]:\n                if pos in self.pos2id and sims[pos] > eps: # ignore deleted/rewritten documents\n                    # convert positions of resulting docs back to ids\n                    result.append((self.pos2id[pos], sims[pos]))\n                    if len(result) == self.topsims:\n                        break\n        else:\n            for pos, score in sims:\n                if pos in self.pos2id and abs(score) > eps: # ignore deleted/rewritten documents\n                    # convert positions of resulting docs back to ids\n                    result.append((self.pos2id[pos], abs(score)))\n                    if len(result) == self.topsims:\n                        break\n        return result", "response": "Convert raw similarity vector to a list of ( docid similarity ) results."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns indexed vector corresponding to document docid.", "response": "def vec_by_id(self, docid):\n        \"\"\"Return indexed vector corresponding to document `docid`.\"\"\"\n        pos = self.id2pos[docid]\n        return self.qindex.vector_by_id(pos)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef sims_by_id(self, docid):\n        result = self.id2sims.get(docid, None)\n        if result is None:\n            self.qindex.num_best = self.topsims\n            sims = self.qindex.similarity_by_id(self.id2pos[docid])\n            result = self.sims2scores(sims)\n        return result", "response": "Find the most similar documents to the document with docid."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef sims_by_vec(self, vec, normalize=None):\n        if normalize is None:\n            normalize = self.qindex.normalize\n        norm, self.qindex.normalize = self.qindex.normalize, normalize # store old value\n        self.qindex.num_best = self.topsims\n        sims = self.qindex[vec]\n        self.qindex.normalize = norm # restore old value of qindex.normalize\n        return self.sims2scores(sims)", "response": "Return the most similar documents to a given vector."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef merge(self, other):\n        other.qindex.normalize, other.qindex.num_best = False, self.topsims\n        # update precomputed \"most similar\" for old documents (in case some of\n        # the new docs make it to the top-N for some of the old documents)\n        logger.info(\"updating old precomputed values\")\n        pos, lenself = 0, len(self.qindex)\n        for chunk in self.qindex.iter_chunks():\n            for sims in other.qindex[chunk]:\n                if pos in self.pos2id:\n                    # ignore masked entries (deleted, overwritten documents)\n                    docid = self.pos2id[pos]\n                    sims = self.sims2scores(sims)\n                    self.id2sims[docid] = merge_sims(self.id2sims[docid], sims, self.topsims)\n                pos += 1\n                if pos % 10000 == 0:\n                    logger.info(\"PROGRESS: updated doc #%i/%i\" % (pos, lenself))\n        self.id2sims.sync()\n\n        logger.info(\"merging fresh index into optimized one\")\n        pos, docids = 0, []\n        for chunk in other.qindex.iter_chunks():\n            for vec in chunk:\n                if pos in other.pos2id: # don't copy deleted documents\n                    self.qindex.add_documents([vec])\n                    docids.append(other.pos2id[pos])\n                pos += 1\n        self.qindex.save()\n        self.update_ids(docids)\n\n        logger.info(\"precomputing most similar for the fresh index\")\n        pos, lenother = 0, len(other.qindex)\n        norm, self.qindex.normalize = self.qindex.normalize, False\n        topsims, self.qindex.num_best = self.qindex.num_best, self.topsims\n        for chunk in other.qindex.iter_chunks():\n            for sims in self.qindex[chunk]:\n                if pos in other.pos2id:\n                    # ignore masked entries (deleted, overwritten documents)\n                    docid = other.pos2id[pos]\n                    self.id2sims[docid] = self.sims2scores(sims)\n                pos += 1\n                if pos % 10000 == 0:\n                    logger.info(\"PROGRESS: precomputed doc #%i/%i\" % (pos, lenother))\n        self.qindex.normalize, self.qindex.num_best = norm, topsims\n        self.id2sims.sync()", "response": "Merge documents from the other index into this one."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef doc2vec(self, doc):\n        bow = self.dictionary.doc2bow(doc['tokens'])\n        if self.method == 'lsi':\n            return self.lsi[self.tfidf[bow]]\n        elif self.method == 'lda':\n            return self.lda[bow]\n        elif self.method == 'lda_tfidf':\n            return self.lda[self.tfidf[bow]]\n        elif self.method == 'logentropy':\n            return self.logent[bow]", "response": "Convert a single SimilarityDocument to vector."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nconverting multiple SimilarityDocuments to vectors.", "response": "def docs2vecs(self, docs):\n        \"\"\"Convert multiple SimilarityDocuments to vectors (batch version of doc2vec).\"\"\"\n        bows = (self.dictionary.doc2bow(doc['tokens']) for doc in docs)\n        if self.method == 'lsi':\n            return self.lsi[self.tfidf[bows]]\n        elif self.method == 'lda':\n            return self.lda[bows]\n        elif self.method == 'lda_tfidf':\n            return self.lda[self.tfidf[bows]]\n        elif self.method == 'logentropy':\n            return self.logent[bows]"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef flush(self, save_index=False, save_model=False, clear_buffer=False):\n        if save_index:\n            if self.fresh_index is not None:\n                self.fresh_index.save(self.location('index_fresh'))\n            if self.opt_index is not None:\n                self.opt_index.save(self.location('index_opt'))\n        if save_model:\n            if self.model is not None:\n                self.model.save(self.location('model'))\n        self.payload.commit()\n        if clear_buffer:\n            if hasattr(self, 'fresh_docs'):\n                try:\n                    self.fresh_docs.terminate() # erase all buffered documents + file on disk\n                except:\n                    pass\n            self.fresh_docs = SqliteDict(journal_mode=JOURNAL_MODE) # buffer defaults to a random location in temp\n        self.fresh_docs.sync()", "response": "Commit all changes clear all caches."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef close(self):\n        try:\n            self.payload.close()\n        except:\n            pass\n        try:\n            self.model.close()\n        except:\n            pass\n        try:\n            self.fresh_index.close()\n        except:\n            pass\n        try:\n            self.opt_index.close()\n        except:\n            pass\n        try:\n            self.fresh_docs.terminate()\n        except:\n            pass", "response": "Explicitly close open file handles databases etc."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef buffer(self, documents):\n        logger.info(\"adding documents to temporary buffer of %s\" % (self))\n        for doc in documents:\n            docid = doc['id']\n#            logger.debug(\"buffering document %r\" % docid)\n            if docid in self.fresh_docs:\n                logger.warning(\"asked to re-add id %r; rewriting old value\" % docid)\n            self.fresh_docs[docid] = doc\n        self.fresh_docs.sync()", "response": "Add a sequence of documents to the temporary buffer."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate an indexing model.", "response": "def train(self, corpus=None, method='auto', clear_buffer=True, params=None):\n        \"\"\"\n        Create an indexing model. Will overwrite the model if it already exists.\n        All indexes become invalid, because documents in them use a now-obsolete\n        representation.\n\n        The model is trained on documents previously entered via `buffer`,\n        or directly on `corpus`, if specified.\n        \"\"\"\n        if corpus is not None:\n            # use the supplied corpus only (erase existing buffer, if any)\n            self.flush(clear_buffer=True)\n            self.buffer(corpus)\n        if not self.fresh_docs:\n            msg = \"train called but no training corpus specified for %s\" % self\n            logger.error(msg)\n            raise ValueError(msg)\n        if method == 'auto':\n            numdocs = len(self.fresh_docs)\n            if numdocs < 1000:\n                logging.warning(\"too few training documents; using simple log-entropy model instead of latent semantic indexing\")\n                method = 'logentropy'\n            else:\n                method = 'lsi'\n        if params is None:\n            params = {}\n        self.model = SimModel(self.fresh_docs, method=method, params=params)\n        self.flush(save_model=True, clear_buffer=clear_buffer)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nindex all documents in corpus if specified.", "response": "def index(self, corpus=None, clear_buffer=True):\n        \"\"\"\n        Permanently index all documents previously added via `buffer`, or\n        directly index documents from `corpus`, if specified.\n\n        The indexing model must already exist (see `train`) before this function\n        is called.\n        \"\"\"\n        if not self.model:\n            msg = 'must initialize model for %s before indexing documents' % self.basename\n            logger.error(msg)\n            raise AttributeError(msg)\n\n        if corpus is not None:\n            # use the supplied corpus only (erase existing buffer, if any)\n            self.flush(clear_buffer=True)\n            self.buffer(corpus)\n\n        if not self.fresh_docs:\n            msg = \"index called but no indexing corpus specified for %s\" % self\n            logger.error(msg)\n            raise ValueError(msg)\n\n        if not self.fresh_index:\n            logger.info(\"starting a new fresh index for %s\" % self)\n            self.fresh_index = SimIndex(self.location('index_fresh'), self.model.num_features)\n        self.fresh_index.index_documents(self.fresh_docs, self.model)\n        if self.opt_index is not None:\n            self.opt_index.delete(self.fresh_docs.keys())\n        logger.info(\"storing document payloads\")\n        for docid in self.fresh_docs:\n            payload = self.fresh_docs[docid].get('payload', None)\n            if payload is None:\n                # HACK: exit on first doc without a payload (=assume all docs have payload, or none does)\n                break\n            self.payload[docid] = payload\n        self.flush(save_index=True, clear_buffer=clear_buffer)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef drop_index(self, keep_model=True):\n        modelstr = \"\" if keep_model else \"and model \"\n        logger.info(\"deleting similarity index \" + modelstr + \"from %s\" % self.basename)\n\n        # delete indexes\n        for index in [self.fresh_index, self.opt_index]:\n            if index is not None:\n                index.terminate()\n        self.fresh_index, self.opt_index = None, None\n\n        # delete payload\n        if self.payload is not None:\n            self.payload.close()\n\n            fname = self.location('payload')\n            try:\n                if os.path.exists(fname):\n                    os.remove(fname)\n                    logger.info(\"deleted %s\" % fname)\n            except Exception, e:\n                logger.warning(\"failed to delete %s\" % fname)\n        self.payload = SqliteDict(self.location('payload'), autocommit=True, journal_mode=JOURNAL_MODE)\n\n        # optionally, delete the model as well\n        if not keep_model and self.model is not None:\n            self.model.close()\n            fname = self.location('model')\n            try:\n                if os.path.exists(fname):\n                    os.remove(fname)\n                    logger.info(\"deleted %s\" % fname)\n            except Exception, e:\n                logger.warning(\"failed to delete %s\" % fname)\n            self.model = None\n        self.flush(save_index=True, save_model=True, clear_buffer=True)", "response": "Drop all indexed documents. If keep_model is False also dropped the model."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ndeleting specified documents from the index.", "response": "def delete(self, docids):\n        \"\"\"Delete specified documents from the index.\"\"\"\n        logger.info(\"asked to drop %i documents\" % len(docids))\n        for index in [self.opt_index, self.fresh_index]:\n            if index is not None:\n                index.delete(docids)\n        self.flush(save_index=True)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef find_similar(self, doc, min_score=0.0, max_results=100):\n        logger.debug(\"received query call with %r\" % doc)\n        if self.is_locked():\n            msg = \"cannot query while the server is being updated\"\n            logger.error(msg)\n            raise RuntimeError(msg)\n        sims_opt, sims_fresh = None, None\n        for index in [self.fresh_index, self.opt_index]:\n            if index is not None:\n                index.topsims = max_results\n        if isinstance(doc, basestring):\n            # query by direct document id\n            docid = doc\n            if self.opt_index is not None and docid in self.opt_index:\n                sims_opt = self.opt_index.sims_by_id(docid)\n                if self.fresh_index is not None:\n                    vec = self.opt_index.vec_by_id(docid)\n                    sims_fresh = self.fresh_index.sims_by_vec(vec, normalize=False)\n            elif self.fresh_index is not None and docid in self.fresh_index:\n                sims_fresh = self.fresh_index.sims_by_id(docid)\n                if self.opt_index is not None:\n                    vec = self.fresh_index.vec_by_id(docid)\n                    sims_opt = self.opt_index.sims_by_vec(vec, normalize=False)\n            else:\n                raise ValueError(\"document %r not in index\" % docid)\n        else:\n            if 'topics' in doc:\n                # user supplied vector directly => use that\n                vec = gensim.matutils.any2sparse(doc['topics'])\n            else:\n                # query by an arbitrary text (=tokens) inside doc['tokens']\n                vec = self.model.doc2vec(doc) # convert document (text) to vector\n            if self.opt_index is not None:\n                sims_opt = self.opt_index.sims_by_vec(vec)\n            if self.fresh_index is not None:\n                sims_fresh = self.fresh_index.sims_by_vec(vec)\n\n        merged = merge_sims(sims_opt, sims_fresh)\n        logger.debug(\"got %s raw similars, pruning with max_results=%s, min_score=%s\" %\n            (len(merged), max_results, min_score))\n        result = []\n        for docid, score in merged:\n            if score < min_score or 0 < max_results <= len(result):\n                break\n            result.append((docid, float(score), self.payload.get(docid, None)))\n        return result", "response": "Find most similar articles in the index."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning ids of all indexed documents.", "response": "def keys(self):\n        \"\"\"Return ids of all indexed documents.\"\"\"\n        result = []\n        if self.fresh_index is not None:\n            result += self.fresh_index.keys()\n        if self.opt_index is not None:\n            result += self.opt_index.keys()\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef check_session(self):\n        if self.session is None:\n            if self.autosession:\n                self.open_session()\n            else:\n                msg = \"must open a session before modifying %s\" % self\n                raise RuntimeError(msg)", "response": "Check if a session is open."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef open_session(self):\n        if self.session is not None:\n            msg = \"session already open; commit it or rollback before opening another one in %s\" % self\n            logger.error(msg)\n            raise RuntimeError(msg)\n\n        logger.info(\"opening a new session\")\n        logger.info(\"removing %s\" % self.loc_session)\n        try:\n            shutil.rmtree(self.loc_session)\n        except:\n            logger.info(\"failed to delete %s\" % self.loc_session)\n        logger.info(\"cloning server from %s to %s\" %\n                    (self.loc_stable, self.loc_session))\n        shutil.copytree(self.loc_stable, self.loc_session)\n        self.session = SimServer(self.loc_session, use_locks=self.use_locks)\n        self.lock_update.acquire()", "response": "Open a new session to modify this server."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef buffer(self, *args, **kwargs):\n        self.check_session()\n        result = self.session.buffer(*args, **kwargs)\n        return result", "response": "Buffer documents in the current session"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef index(self, *args, **kwargs):\n        self.check_session()\n        result = self.session.index(*args, **kwargs)\n        if self.autosession:\n            self.commit()\n        return result", "response": "Index documents in the current session"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ndrops all indexed documents from the session. Optionally drop model.", "response": "def drop_index(self, keep_model=True):\n        \"\"\"Drop all indexed documents from the session. Optionally, drop model too.\"\"\"\n        self.check_session()\n        result = self.session.drop_index(keep_model)\n        if self.autosession:\n            self.commit()\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef delete(self, docids):\n        self.check_session()\n        result = self.session.delete(docids)\n        if self.autosession:\n            self.commit()\n        return result", "response": "Delete documents from the current session."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef optimize(self):\n        self.check_session()\n        result = self.session.optimize()\n        if self.autosession:\n            self.commit()\n        return result", "response": "Optimize index for faster by - document - id queries."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef commit(self):\n        if self.session is not None:\n            logger.info(\"committing transaction in %s\" % self)\n            tmp = self.stable\n            self.stable, self.session = self.session, None\n            self.istable = 1 - self.istable\n            self.write_istable()\n            tmp.close() # don't wait for gc, release resources manually\n            self.lock_update.release()\n        else:\n            logger.warning(\"commit called but there's no open session in %s\" % self)", "response": "Commit changes made by the latest session."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncloses the session and release the lock update.", "response": "def rollback(self):\n        \"\"\"Ignore all changes made in the latest session (terminate the session).\"\"\"\n        if self.session is not None:\n            logger.info(\"rolling back transaction in %s\" % self)\n            self.session.close()\n            self.session = None\n            self.lock_update.release()\n        else:\n            logger.warning(\"rollback called but there's no open session in %s\" % self)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset the autosession of the current user.", "response": "def set_autosession(self, value=None):\n        \"\"\"\n        Turn autosession (automatic committing after each modification call) on/off.\n        If value is None, only query the current value (don't change anything).\n        \"\"\"\n        if value is not None:\n            self.rollback()\n            self.autosession = value\n        return self.autosession"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef terminate(self):\n        logger.info(\"deleting entire server %s\" % self)\n        self.close()\n        try:\n            shutil.rmtree(self.basedir)\n            logger.info(\"deleted server under %s\" % self.basedir)\n            # delete everything from self, so that using this object fails results\n            # in an error as quickly as possible\n            for val in self.__dict__.keys():\n                try:\n                    delattr(self, val)\n                except:\n                    pass\n        except Exception, e:\n            logger.warning(\"failed to delete SessionServer: %s\" % (e))", "response": "Delete all files created by this server invalidating self. Use with care."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef find_similar(self, *args, **kwargs):\n        if self.session is not None and self.autosession:\n            # with autosession on, commit the pending transaction first\n            self.commit()\n        return self.stable.find_similar(*args, **kwargs)", "response": "Find similar articles.\n\n        With autosession off, use the index state *before* current session started,\n        so that changes made in the session will not be visible here. With autosession\n        on, close the current session first (so that session changes *are* committed\n        and visible)."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef start(io_loop=None, check_time=2):\n\n    \"\"\"Begins watching source files for changes.\n\n    .. versionchanged:: 4.1\n       The ``io_loop`` argument is deprecated.\n    \"\"\"\n    io_loop = io_loop or asyncio.get_event_loop()\n    if io_loop in _io_loops:\n        return\n    _io_loops[io_loop] = True\n    if len(_io_loops) > 1:\n        logger.warning(\"aiohttp_autoreload started more than once in the same process\")\n    # if _has_execv:\n    #     add_reload_hook(functools.partial(io_loop.close, all_fds=True))\n    modify_times = {}\n    callback = functools.partial(_reload_on_update, modify_times)\n    logger.debug(\"Starting periodic checks for code changes\")\n    call_periodic(check_time, callback, loop=io_loop)", "response": "Starts watching source files for changes."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nyield chunk_size items from data at a time.", "response": "def generate_chunks(data, chunk_size=DEFAULT_CHUNK_SIZE):\n    \"\"\"Yield 'chunk_size' items from 'data' at a time.\"\"\"\n    iterator = iter(repeated.getvalues(data))\n\n    while True:\n        chunk = list(itertools.islice(iterator, chunk_size))\n        if not chunk:\n            return\n\n        yield chunk"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef reduce(reducer, data, chunk_size=DEFAULT_CHUNK_SIZE):\n    if not chunk_size:\n        return finalize(reducer, fold(reducer, data))\n\n    # Splitting the work up into chunks allows us to, e.g. reduce a large file\n    # without loading everything into memory, while still being significantly\n    # faster than repeatedly calling the fold function for every element.\n    chunks = generate_chunks(data, chunk_size)\n    intermediate = fold(reducer, next(chunks))\n    for chunk in chunks:\n        intermediate = merge(reducer, intermediate, fold(reducer, chunk))\n\n    return finalize(reducer, intermediate)", "response": "Repeatedly call fold and merge on data and then finalize."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef conditions(self):\n        for idx in six.moves.range(1, len(self.children), 2):\n            yield (self.children[idx - 1], self.children[idx])", "response": "The if - else pairs."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nresolving placeholders in a staging path with actual paths to the corresponding tasks.", "response": "def resolve_placeholders(path, placeholder_dict):\n    \"\"\"\n    **Purpose**: Substitute placeholders in staging attributes of a Task with actual paths to the corresponding tasks.\n\n    :arguments:\n        :path: string describing the staging paths, possibly containing a placeholder\n        :placeholder_dict: dictionary holding the values for placeholders\n\n    \"\"\"\n\n    try:\n\n        if isinstance(path, unicode):\n            path = str(path)\n\n        if not isinstance(path, str):\n            raise TypeError(expected_type=str, actual_type=type(path))\n\n        if '$' not in path:\n            return path\n\n        # Extract placeholder from path\n        if len(path.split('>')) == 1:\n            placeholder = path.split('/')[0]\n        else:\n            if path.split('>')[0].strip().startswith('$'):\n                placeholder = path.split('>')[0].strip().split('/')[0]\n            else:\n                placeholder = path.split('>')[1].strip().split('/')[0]\n\n        # SHARED\n        if placeholder == \"$SHARED\":\n            return path.replace(placeholder, 'pilot://')\n\n        # Expected placeholder format:\n        # $Pipeline_{pipeline.uid}_Stage_{stage.uid}_Task_{task.uid}\n\n        broken_placeholder = placeholder.split('/')[0].split('_')\n\n        if not len(broken_placeholder) == 6:\n            raise ValueError(\n                obj='placeholder',\n                attribute='task',\n                expected_value='$Pipeline_(pipeline_name)_Stage_(stage_name)_Task_(task_name) or $SHARED',\n                actual_value=broken_placeholder)\n\n        pipeline_name = broken_placeholder[1]\n        stage_name = broken_placeholder[3]\n        task_name = broken_placeholder[5]\n        resolved_placeholder = None\n\n        if pipeline_name in placeholder_dict.keys():\n            if stage_name in placeholder_dict[pipeline_name].keys():\n                if task_name in placeholder_dict[pipeline_name][stage_name].keys():\n                    resolved_placeholder = path.replace(placeholder, placeholder_dict[\n                                                        pipeline_name][stage_name][task_name]['path'])\n                else:\n                    logger.warning('%s not assigned to any task in Stage %s Pipeline %s' %\n                                   (task_name, stage_name, pipeline_name))\n            else:\n                logger.warning('%s not assigned to any Stage in Pipeline %s' % (\n                    stage_name, pipeline_name))\n        else:\n            logger.warning('%s not assigned to any Pipeline' % (pipeline_name))\n\n        if not resolved_placeholder:\n            logger.warning('No placeholder could be found for task name %s \\\n                        stage name %s and pipeline name %s. Please be sure to \\\n                        use object names and not uids in your references,i.e, \\\n                        $Pipeline_(pipeline_name)_Stage_(stage_name)_Task_(task_name)')\n            raise ValueError(\n                obj='placeholder',\n                attribute='task',\n                expected_value='$Pipeline_(pipeline_name)_Stage_(stage_name)_Task_(task_name) or $SHARED',\n                actual_value=broken_placeholder)\n\n        return resolved_placeholder\n\n    except Exception, ex:\n\n        logger.exception('Failed to resolve placeholder %s, error: %s' %(path, ex))\n        raise"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_input_list_from_task(task, placeholder_dict):\n\n    try:\n\n        if not isinstance(task, Task):\n            raise TypeError(expected_type=Task, actual_type=type(task))\n\n        input_data = []\n\n        if task.link_input_data:\n\n            for path in task.link_input_data:\n\n                path = resolve_placeholders(path, placeholder_dict)\n\n                if len(path.split('>')) > 1:\n\n                    temp = {\n                        'source': path.split('>')[0].strip(),\n                        'target': path.split('>')[1].strip(),\n                        'action': rp.LINK\n                    }\n                else:\n                    temp = {\n                        'source': path.split('>')[0].strip(),\n                        'target': os.path.basename(path.split('>')[0].strip()),\n                        'action': rp.LINK\n                    }\n                input_data.append(temp)\n\n        if task.upload_input_data:\n\n            for path in task.upload_input_data:\n\n                path = resolve_placeholders(path, placeholder_dict)\n\n                if len(path.split('>')) > 1:\n\n                    temp = {\n                        'source': path.split('>')[0].strip(),\n                        'target': path.split('>')[1].strip()\n                    }\n                else:\n                    temp = {\n                        'source': path.split('>')[0].strip(),\n                        'target': os.path.basename(path.split('>')[0].strip())\n                    }\n                input_data.append(temp)\n\n        if task.copy_input_data:\n\n            for path in task.copy_input_data:\n\n                path = resolve_placeholders(path, placeholder_dict)\n\n                if len(path.split('>')) > 1:\n\n                    temp = {\n                        'source': path.split('>')[0].strip(),\n                        'target': path.split('>')[1].strip(),\n                        'action': rp.COPY\n                    }\n                else:\n                    temp = {\n                        'source': path.split('>')[0].strip(),\n                        'target': os.path.basename(path.split('>')[0].strip()),\n                        'action': rp.COPY\n                    }\n                input_data.append(temp)\n\n        if task.move_input_data:\n\n            for path in task.move_input_data:\n\n                path = resolve_placeholders(path, placeholder_dict)\n\n                if len(path.split('>')) > 1:\n\n                    temp = {\n                        'source': path.split('>')[0].strip(),\n                        'target': path.split('>')[1].strip(),\n                        'action': rp.MOVE\n                    }\n                else:\n                    temp = {\n                        'source': path.split('>')[0].strip(),\n                        'target': os.path.basename(path.split('>')[0].strip()),\n                        'action': rp.MOVE\n                    }\n\n                input_data.append(temp)\n\n        return input_data\n\n    except Exception, ex:\n\n        logger.exception('Failed to get input list of files from task, error: %s' % ex)\n        raise", "response": "This function parses a Task object to extract the files that need to be staged as the output."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef create_cud_from_task(task, placeholder_dict, prof=None):\n\n    try:\n\n        logger.debug('Creating CU from Task %s' % (task.uid))\n\n        if prof:\n            prof.prof('cud from task - create', uid=task.uid)\n\n        cud = rp.ComputeUnitDescription()\n        cud.name = '%s,%s,%s,%s,%s,%s' % (task.uid, task.name,\n                                          task.parent_stage['uid'], task.parent_stage['name'],\n                                          task.parent_pipeline['uid'], task.parent_pipeline['name'])\n        cud.pre_exec = task.pre_exec\n        cud.executable = task.executable\n        cud.arguments = resolve_arguments(task.arguments, placeholder_dict)\n        cud.post_exec = task.post_exec\n        if task.tag:\n            if task.parent_pipeline['name']:\n                cud.tag = resolve_tags( tag=task.tag,\n                                        parent_pipeline_name=task.parent_pipeline['name'],\n                                        placeholder_dict=placeholder_dict)\n\n        cud.cpu_processes = task.cpu_reqs['processes']\n        cud.cpu_threads = task.cpu_reqs['threads_per_process']\n        cud.cpu_process_type = task.cpu_reqs['process_type']\n        cud.cpu_thread_type = task.cpu_reqs['thread_type']\n        cud.gpu_processes = task.gpu_reqs['processes']\n        cud.gpu_threads = task.gpu_reqs['threads_per_process']\n        cud.gpu_process_type = task.gpu_reqs['process_type']\n        cud.gpu_thread_type = task.gpu_reqs['thread_type']\n        if task.lfs_per_process:\n            cud.lfs_per_process = task.lfs_per_process\n\n        if task.stdout:\n            cud.stdout = task.stdout\n        if task.stderr:\n            cud.stderr = task.stderr\n\n        cud.input_staging = get_input_list_from_task(task, placeholder_dict)\n        cud.output_staging = get_output_list_from_task(task, placeholder_dict)\n\n        if prof:\n            prof.prof('cud from task - done', uid=task.uid)\n\n        logger.debug('CU %s created from Task %s' % (cud.name, task.uid))\n\n        return cud\n\n    except Exception, ex:\n        logger.exception('CU creation failed, error: %s' % ex)\n        raise", "response": "Create a ComputeUnitDescription object based on the given task."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef create_task_from_cu(cu, prof=None):\n\n    try:\n\n        logger.debug('Create Task from CU %s' % cu.name)\n\n        if prof:\n            prof.prof('task from cu - create',\n                      uid=cu.name.split(',')[0].strip())\n\n        task = Task()\n        task.uid = cu.name.split(',')[0].strip()\n        task.name = cu.name.split(',')[1].strip()\n        task.parent_stage['uid'] = cu.name.split(',')[2].strip()\n        task.parent_stage['name'] = cu.name.split(',')[3].strip()\n        task.parent_pipeline['uid'] = cu.name.split(',')[4].strip()\n        task.parent_pipeline['name'] = cu.name.split(',')[5].strip()\n        task.rts_uid = cu.uid\n\n        if cu.state == rp.DONE:\n            task.exit_code = 0\n        else:\n            task.exit_code = 1\n\n        task.path = ru.Url(cu.sandbox).path\n\n        if prof:\n            prof.prof('task from cu - done', uid=cu.name.split(',')[0].strip())\n\n        logger.debug('Task %s created from CU %s' % (task.uid, cu.name))\n\n        return task\n\n    except Exception, ex:\n        logger.exception('Task creation from CU failed, error: %s' % ex)\n        raise", "response": "This function creates a Task based on the given Compute Unit."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nsend Report E - mails.", "response": "def handle_noargs(self, **options):\n        \"\"\"Send Report E-mails.\"\"\"\n\n        r = get_r()\n        since = datetime.utcnow() - timedelta(days=1)\n        metrics = {}\n        categories = r.metric_slugs_by_category()\n        for category_name, slug_list in categories.items():\n            metrics[category_name] = []\n            for slug in slug_list:\n                metric_values = r.get_metric_history(slug, since=since)\n                metrics[category_name].append(\n                    (slug, metric_values)\n                )\n\n        # metrics is now:\n        # --------------\n        # { Category : [\n        #     ('foo', [('m:foo:2012-07-18', 1), ('m:foo:2012-07-19, 2), ...])\n        #   ],\n        #   ...\n        # }\n\n        template = \"redis_metrics/email/report.{fmt}\"\n        data = {\n            'today': since,\n            'metrics': metrics,\n        }\n\n        message = render_to_string(template.format(fmt='txt'), data)\n        message_html = render_to_string(template.format(fmt='html'), data)\n        msg = EmailMultiAlternatives(\n            subject=\"Redis Metrics Report\",\n            body=message,\n            from_email=settings.DEFAULT_FROM_EMAIL,\n            to=[email for name, email in settings.ADMINS]\n        )\n        msg.attach_alternative(message_html, \"text/html\")\n        msg.send()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef luid(self):\n        p_elem = self.parent_pipeline.get('name')\n        if not p_elem:\n            p_elem = self.parent_pipeline['uid']\n\n        s_elem = self.name\n        if not s_elem:\n            s_elem = self.uid\n\n        return '%s.%s' % (p_elem, s_elem)", "response": "Return the fully qualified unique ID of the current stage."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding tasks to the existing set of tasks of the Stage", "response": "def add_tasks(self, value):\n        \"\"\"\n        Adds tasks to the existing set of tasks of the Stage\n\n        :argument: set of tasks\n        \"\"\"\n        tasks = self._validate_entities(value)\n        self._tasks.update(tasks)\n        self._task_count = len(self._tasks)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nconvert the current Stage into a dictionary.", "response": "def to_dict(self):\n        \"\"\"\n        Convert current Stage into a dictionary\n\n        :return: python dictionary\n        \"\"\"\n\n        stage_desc_as_dict = {\n\n            'uid': self._uid,\n            'name': self._name,\n            'state': self._state,\n            'state_history': self._state_history,\n            'parent_pipeline': self._p_pipeline\n        }\n\n        return stage_desc_as_dict"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef from_dict(self, d):\n\n        if 'uid' in d:\n            if d['uid']:\n                self._uid = d['uid']\n\n        if 'name' in d:\n            if d['name']:\n                self._name = d['name']\n\n        if 'state' in d:\n            if isinstance(d['state'], str) or isinstance(d['state'], unicode):\n                if d['state'] in states._stage_state_values.keys():\n                    self._state = d['state']\n                else:\n                    raise ValueError(obj=self._uid,\n                                     attribute='state',\n                                     expected_value=states._stage_state_values.keys(),\n                                     actual_value=value)\n            else:\n                raise TypeError(entity='state', expected_type=str, actual_type=type(d['state']))\n\n        else:\n            self._state = states.INITIAL\n\n        if 'state_history' in d:\n            if isinstance(d['state_history'], list):\n                self._state_history = d['state_history']\n            else:\n                raise TypeError(entity='state_history', expected_type=list, actual_type=type(d['state_history']))\n\n        if 'parent_pipeline' in d:\n            if isinstance(d['parent_pipeline'], dict):\n                self._p_pipeline = d['parent_pipeline']\n            else:\n                raise TypeError(entity='parent_pipeline', expected_type=dict, actual_type=type(d['parent_pipeline']))", "response": "Create a new object from a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _set_tasks_state(self, value):\n        if value not in states.state_numbers.keys():\n            raise ValueError(obj=self._uid,\n                             attribute='set_tasks_state',\n                             expected_value=states.state_numbers.keys(),\n                             actual_value=value)\n\n        for task in self._tasks:\n            task.state = value", "response": "Sets the state of all tasks in the current stage."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nchecking if all tasks of the current stage have completed.", "response": "def _check_stage_complete(self):\n        \"\"\"\n        Purpose: Check if all tasks of the current stage have completed, i.e., are in either DONE or FAILED state.\n        \"\"\"\n\n        try:\n\n            for task in self._tasks:\n                if task.state not in [states.DONE, states.FAILED]:\n                    return False\n\n            return True\n\n        except Exception, ex:\n            raise EnTKError(ex)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncheck whether the tasks list is of type set.", "response": "def _validate_entities(self, tasks):\n        \"\"\"\n        Purpose: Validate whether the 'tasks' is of type set. Validate the description of each Task.\n        \"\"\"\n\n        if not tasks:\n            raise TypeError(expected_type=Task, actual_type=type(tasks))\n\n        if not isinstance(tasks, set):\n\n            if not isinstance(tasks, list):\n                tasks = set([tasks])\n            else:\n                tasks = set(tasks)\n\n        for t in tasks:\n\n            if not isinstance(t, Task):\n                raise TypeError(expected_type=Task, actual_type=type(t))\n\n        return tasks"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _assign_uid(self, sid):\n        self._uid = ru.generate_id('stage.%(item_counter)04d', ru.ID_CUSTOM, namespace=sid)\n        for task in self._tasks:\n            task._assign_uid(sid)\n\n        self._pass_uid()", "response": "Assign a uid to the current object based on the sid passed. Pass the current uid to children of\n        current object"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nassign the parent Stage and parent Pipeline to all the tasks of the current stage.", "response": "def _pass_uid(self):\n        \"\"\"\n        Purpose: Assign the parent Stage and the parent Pipeline to all the tasks of the current stage. \n\n        :arguments: set of Tasks (optional)\n        :return: list of updated Tasks\n        \"\"\"\n\n        for task in self._tasks:\n            task.parent_stage['uid'] = self._uid\n            task.parent_stage['name'] = self._name\n            task.parent_pipeline['uid'] = self._p_pipeline['uid']\n            task.parent_pipeline['name'] = self._p_pipeline['name']"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef application(tokens):\n    tokens = iter(tokens)\n    func = next(tokens)\n    paren = next(tokens)\n\n    if func and func.name == \"symbol\" and paren.name == \"lparen\":\n        # We would be able to unambiguously parse function application with\n        # whitespace between the function name and the lparen, but let's not\n        # do that because it's unexpected in most languages.\n        if func.end != paren.start:\n            raise errors.EfilterParseError(\n                start=func.start, end=paren.end,\n                message=\"No whitespace allowed between function and paren.\")\n\n        return common.TokenMatch(None, func.value, (func, paren))", "response": "Matches function call application."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngenerates the text of an RPM spec file.", "response": "def _make_spec_file(self):\n        \"\"\"Generates the text of an RPM spec file.\n\n        Returns:\n          A list of strings containing the lines of text.\n        \"\"\"\n        # Note that bdist_rpm can be an old style class.\n        if issubclass(BdistRPMCommand, object):\n            spec_file = super(BdistRPMCommand, self)._make_spec_file()\n        else:\n            spec_file = bdist_rpm._make_spec_file(self)\n\n        if sys.version_info[0] < 3:\n            python_package = \"python\"\n        else:\n            python_package = \"python3\"\n\n        description = []\n        summary = \"\"\n        in_description = False\n\n        python_spec_file = []\n        for line in spec_file:\n            if line.startswith(\"Summary: \"):\n                summary = line\n\n            elif line.startswith(\"BuildRequires: \"):\n                line = \"BuildRequires: {0:s}-setuptools\".format(python_package)\n\n            elif line.startswith(\"Requires: \"):\n                if python_package == \"python3\":\n                    line = line.replace(\"python\", \"python3\")\n\n            elif line.startswith(\"%description\"):\n                in_description = True\n\n            elif line.startswith(\"%files\"):\n                line = \"%files -f INSTALLED_FILES -n {0:s}-%{{name}}\".format(\n                    python_package)\n\n            elif line.startswith(\"%prep\"):\n                in_description = False\n\n                python_spec_file.append(\n                    \"%package -n {0:s}-%{{name}}\".format(python_package))\n                python_spec_file.append(\"{0:s}\".format(summary))\n                python_spec_file.append(\"\")\n                python_spec_file.append(\n                    \"%description -n {0:s}-%{{name}}\".format(python_package))\n                python_spec_file.extend(description)\n\n            elif in_description:\n                # Ignore leading white lines in the description.\n                if not description and not line:\n                    continue\n\n                description.append(line)\n\n            python_spec_file.append(line)\n\n        return python_spec_file"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef resolve(self, name):\n        for scope in reversed(self.scopes):\n            try:\n                return structured.resolve(scope, name)\n            except (KeyError, AttributeError):\n                continue\n\n        raise AttributeError(name)", "response": "Call IStructured. resolve across all scopes and return first hit."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef getmembers(self):\n        names = set()\n        for scope in self.scopes:\n            if isinstance(scope, type):\n                names.update(structured.getmembers_static(scope))\n            else:\n                names.update(structured.getmembers_runtime(scope))\n\n        return names", "response": "Gets members from all scopes using both runtime and static."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef getmembers_runtime(self):\n        names = set()\n        for scope in self.scopes:\n            names.update(structured.getmembers_runtime(scope))\n\n        return names", "response": "Gets members from all scopes using ONLY runtime information."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef getmembers_static(cls):\n        names = set()\n        for scope in cls.scopes:\n            names.update(structured.getmembers_static(scope))\n\n        return names", "response": "Gets members from all scopes using ONLY static information."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef reflect(self, name):\n        # Return whatever the most local scope defines this as, or bubble all\n        # the way to the top.\n        result = None\n        for scope in reversed(self.scopes):\n            try:\n                if isinstance(scope, type):\n                    result = structured.reflect_static_member(scope, name)\n                else:\n                    result = structured.reflect_runtime_member(scope, name)\n\n                if result is not None:\n                    return result\n\n            except (NotImplementedError, KeyError, AttributeError):\n                continue\n\n        return protocol.AnyType", "response": "Reflect name starting with local scope all the way up to global."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreflect name using ONLY runtime reflection.", "response": "def reflect_runtime_member(self, name):\n        \"\"\"Reflect 'name' using ONLY runtime reflection.\n\n        You most likely want to use ScopeStack.reflect instead.\n\n        Returns:\n            Type of 'name', or protocol.AnyType.\n        \"\"\"\n        for scope in reversed(self.scopes):\n            try:\n                return structured.reflect_runtime_member(scope, name)\n            except (NotImplementedError, KeyError, AttributeError):\n                continue\n\n        return protocol.AnyType"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreflect name using ONLY static reflection.", "response": "def reflect_static_member(cls, name):\n        \"\"\"Reflect 'name' using ONLY static reflection.\n\n        You most likely want to use ScopeStack.reflect instead.\n\n        Returns:\n            Type of 'name', or protocol.AnyType.\n        \"\"\"\n        for scope in reversed(cls.scopes):\n            try:\n                return structured.reflect_static_member(scope, name)\n            except (NotImplementedError, KeyError, AttributeError):\n                continue\n\n        return protocol.AnyType"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_hostmap(profile):\n    '''\n    We abuse the profile combination to also derive a pilot-host map, which\n    will tell us on what exact host each pilot has been running.  To do so, we\n    check for the PMGR_ACTIVE advance event in agent_0.prof, and use the NTP\n    sync info to associate a hostname.\n    '''\n    # FIXME: This should be replaced by proper hostname logging\n    #        in `pilot.resource_details`.\n\n    hostmap = dict()  # map pilot IDs to host names\n    for entry in profile:\n        if entry[ru.EVENT] == 'hostname':\n            hostmap[entry[ru.UID]] = entry[ru.MSG]\n\n    return hostmap", "response": "This function returns a dict that associates pilot IDs to host names."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef run(self):\n\n        try:\n\n            # Set None objects local to each run\n            self._wfp = None\n            self._sync_thread = None\n            self._terminate_sync = Event()\n            self._resubmit_failed = False\n            self._cur_attempt = 1\n\n            if not self._workflow:\n                self._logger.error('No workflow assigned currently, please check your script')\n                raise MissingError(obj=self._uid, missing_attribute='workflow')\n\n            if not self._resource_manager:\n                self._logger.error('No resource manager assigned currently, please create and add a valid resource manager')\n                raise MissingError(obj=self._uid, missing_attribute='resource_manager')\n\n            self._prof.prof('amgr run started', uid=self._uid)\n\n            # Setup rabbitmq stuff\n            if not self._mqs_setup:\n\n                self._report.info('Setting up RabbitMQ system')\n                setup = self._setup_mqs()\n\n                if not setup:\n                    self._logger.error('RabbitMQ system not available')\n                    raise EnTKError(\"RabbitMQ setup failed\")\n\n                self._mqs_setup = True\n\n                self._report.ok('>>ok\\n')\n\n            # Create WFProcessor object\n            self._prof.prof('creating wfp obj', uid=self._uid)\n            self._wfp = WFprocessor(sid=self._sid,\n                                    workflow=self._workflow,\n                                    pending_queue=self._pending_queue,\n                                    completed_queue=self._completed_queue,\n                                    mq_hostname=self._mq_hostname,\n                                    port=self._port,\n                                    resubmit_failed=self._resubmit_failed)\n            self._wfp._initialize_workflow()\n            self._workflow = self._wfp.workflow\n\n\n            # Submit resource request if not resource allocation done till now or\n            # resubmit a new one if the old one has completed\n            if self._resource_manager:\n                res_alloc_state = self._resource_manager.get_resource_allocation_state()\n                if (not res_alloc_state) or (res_alloc_state in self._resource_manager.get_completed_states()):\n\n                    self._logger.info('Starting resource request submission')\n                    self._prof.prof('init rreq submission', uid=self._uid)\n                    self._resource_manager._submit_resource_request()\n                    res_alloc_state = self._resource_manager.get_resource_allocation_state()\n                    if res_alloc_state in self._resource_manager.get_completed_states():\n                        raise EnTKError(msg=\"Cannot proceed. Resource allocation ended up in %s\"%res_alloc_state)\n\n            else:\n\n                self._logger.exception('Cannot run without resource manager, please create and assign a resource manager')\n                raise EnTKError(text='Missing resource manager')\n\n            # Start synchronizer thread\n            if not self._sync_thread:\n                self._logger.info('Starting synchronizer thread')\n                self._sync_thread = Thread(target=self._synchronizer, name='synchronizer-thread')\n                self._prof.prof('starting synchronizer thread', uid=self._uid)\n                self._sync_thread.start()\n\n            # Start WFprocessor\n            self._logger.info('Starting WFProcessor process from AppManager')\n            self._wfp.start_processor()\n\n            self._report.ok('All components created\\n')\n\n            # Create tmgr object only if it does not already exist\n            if self._rts == 'radical.pilot':\n                from radical.entk.execman.rp import TaskManager\n            elif self._rts == 'mock':\n                from radical.entk.execman.mock import TaskManager\n\n            if not self._task_manager:\n                self._prof.prof('creating tmgr obj', uid=self._uid)\n                self._task_manager = TaskManager(sid=self._sid,\n                                                 pending_queue=self._pending_queue,\n                                                 completed_queue=self._completed_queue,\n                                                 mq_hostname=self._mq_hostname,\n                                                 rmgr=self._resource_manager,\n                                                 port=self._port\n                                                 )\n                self._logger.info('Starting task manager process from AppManager')\n                self._task_manager.start_manager()\n                self._task_manager.start_heartbeat()\n\n            active_pipe_count = len(self._workflow)\n            finished_pipe_uids = []\n\n            # We wait till all pipelines of the workflow are marked\n            # complete\n            while ((active_pipe_count > 0) and\n                    (self._wfp.workflow_incomplete()) and\n                    (self._resource_manager.get_resource_allocation_state() not\n                     in self._resource_manager.get_completed_states())):\n\n                if active_pipe_count > 0:\n\n                    for pipe in self._workflow:\n\n                        with pipe.lock:\n\n                            if (pipe.completed) and (pipe.uid not in finished_pipe_uids):\n\n                                self._logger.info('Pipe %s completed' % pipe.uid)\n                                finished_pipe_uids.append(pipe.uid)\n                                active_pipe_count -= 1\n                                self._logger.info('Active pipes: %s' % active_pipe_count)\n\n                if (not self._sync_thread.is_alive()) and (self._cur_attempt <= self._reattempts):\n\n                    self._sync_thread = Thread(target=self._synchronizer,\n                                               name='synchronizer-thread')\n                    self._logger.info('Restarting synchronizer thread')\n                    self._prof.prof('restarting synchronizer', uid=self._uid)\n                    self._sync_thread.start()\n\n                    self._cur_attempt += 1\n\n                if (not self._wfp.check_processor()) and (self._cur_attempt <= self._reattempts):\n\n                    \"\"\"\n                    If WFP dies, both child threads are also cleaned out.\n                    We simply recreate the wfp object with a copy of the workflow\n                    in the appmanager and start the processor.\n                    \"\"\"\n\n                    self._prof.prof('recreating wfp obj', uid=self._uid)\n                    self._wfp = WFProcessor(\n                        sid=self._sid,\n                        workflow=self._workflow,\n                        pending_queue=self._pending_queue,\n                        completed_queue=self._completed_queue,\n                        mq_hostname=self._mq_hostname,\n                        port=self._port,\n                        resubmit_failed=self._resubmit_failed)\n\n                    self._logger.info('Restarting WFProcessor process from AppManager')\n                    self._wfp.start_processor()\n\n                    self._cur_attempt += 1\n\n                if (not self._task_manager.check_heartbeat()) and (self._cur_attempt <= self._reattempts):\n\n                    \"\"\"\n                    If the tmgr process or heartbeat dies, we simply start a\n                    new process using the start_manager method. We do not\n                    need to create a new instance of the TaskManager object\n                    itself. We stop and start a new instance of the\n                    heartbeat thread as well.\n                    \"\"\"\n                    self._prof.prof('restarting tmgr process and heartbeat', uid=self._uid)\n\n                    self._logger.info('Terminating heartbeat thread')\n                    self._task_manager.terminate_heartbeat()\n                    self._logger.info('Terminating tmgr process')\n                    self._task_manager.terminate_manager()\n                    self._logger.info('Restarting task manager process')\n                    self._task_manager.start_manager()\n                    self._logger.info('Restarting heartbeat thread')\n                    self._task_manager.start_heartbeat()\n\n                    self._cur_attempt += 1\n\n            self._prof.prof('start termination', uid=self._uid)\n\n            # Terminate threads in following order: wfp, helper, synchronizer\n            self._logger.info('Terminating WFprocessor')\n            self._wfp.terminate_processor()\n\n            self._logger.info('Terminating synchronizer thread')\n            self._terminate_sync.set()\n            self._sync_thread.join()\n            self._logger.info('Synchronizer thread terminated')\n\n            if self._autoterminate:\n                self.resource_terminate()\n\n            if self._write_workflow:\n                write_workflow(self._workflow, self._sid)\n\n            self._prof.prof('termination done', uid=self._uid)\n\n        except KeyboardInterrupt:\n\n            self._prof.prof('start termination', uid=self._uid)\n\n            self._logger.exception('Execution interrupted by user (you probably hit Ctrl+C), ' +\n                               'trying to cancel enqueuer thread gracefully...')\n\n            # Terminate threads in following order: wfp, helper, synchronizer\n            if self._wfp:\n                self._logger.info('Terminating WFprocessor')\n                self._wfp.terminate_processor()\n\n            if self._task_manager:\n                self._logger.info('Terminating task manager process')\n                self._task_manager.terminate_manager()\n                self._task_manager.terminate_heartbeat()\n\n            if self._sync_thread:\n                self._logger.info('Terminating synchronizer thread')\n                self._terminate_sync.set()\n                self._sync_thread.join()\n                self._logger.info('Synchronizer thread terminated')\n\n            if self._resource_manager:\n                self._resource_manager._terminate_resource_request()\n\n            self._prof.prof('termination done', uid=self._uid)\n\n            raise KeyboardInterrupt\n\n        except Exception, ex:\n\n            self._prof.prof('start termination', uid=self._uid)\n\n            self._logger.exception('Error in AppManager: %s' % ex)\n\n            # Terminate threads in following order: wfp, helper, synchronizer\n            if self._wfp:\n                self._logger.info('Terminating WFprocessor')\n                self._wfp.terminate_processor()\n\n            if self._task_manager:\n                self._logger.info('Terminating task manager process')\n                self._task_manager.terminate_manager()\n                self._task_manager.terminate_heartbeat()\n\n            if self._sync_thread:\n                self._logger.info('Terminating synchronizer thread')\n                self._terminate_sync.set()\n                self._sync_thread.join()\n                self._logger.info('Synchronizer thread terminated')\n\n            if self._resource_manager:\n                self._resource_manager._terminate_resource_request()\n\n            self._prof.prof('termination done', uid=self._uid)\n            raise", "response": "This method is executed by the application manager."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _synchronizer(self):\n\n        try:\n\n            self._prof.prof('synchronizer started', uid=self._uid)\n\n            self._logger.info('synchronizer thread started')\n\n            def task_update(msg, reply_to, corr_id, mq_channel):\n\n                completed_task = Task()\n                completed_task.from_dict(msg['object'])\n                self._logger.info('Received %s with state %s' % (completed_task.uid, completed_task.state))\n\n                found_task = False\n\n                # Traverse the entire workflow to find the correct task\n                for pipe in self._workflow:\n\n                    if not pipe.completed:\n                        if completed_task.parent_pipeline['uid'] == pipe.uid:\n\n                            for stage in pipe.stages:\n\n                                if completed_task.parent_stage['uid'] == stage.uid:\n\n                                    for task in stage.tasks:\n\n                                        if (completed_task.uid == task.uid)and(completed_task.state != task.state):\n\n                                            task.state = str(completed_task.state)\n                                            self._logger.debug('Found task %s with state %s' %\n                                                               (task.uid, task.state))\n\n                                            if completed_task.path:\n                                                task.path = str(completed_task.path)\n\n                                            mq_channel.basic_publish(exchange='',\n                                                                     routing_key=reply_to,\n                                                                     properties=pika.BasicProperties(\n                                                                         correlation_id=corr_id),\n                                                                     body='%s-ack' % task.uid)\n\n                                            self._prof.prof('publishing sync ack for obj with state %s' %\n                                                            msg['object']['state'],\n                                                            uid=msg['object']['uid']\n                                                            )\n\n                                            mq_channel.basic_ack(delivery_tag=method_frame.delivery_tag)\n                                            self._report.ok('Update: ')\n                                            self._report.info('%s state: %s\\n' % (task.luid, task.state))\n\n                                            found_task = True\n\n                                    if not found_task:\n\n                                        # If there was a Stage update, but the Stage was not found in any of the Pipelines. This\n                                        # means that this was a Stage that was added during runtime and the AppManager does not\n                                        # know about it. The current solution is going to be: add it to the workflow object in the\n                                        # AppManager via the synchronizer.\n\n                                        self._prof.prof('Adap: adding new task')\n\n                                        self._logger.info('Adding new task %s to parent stage: %s' % (completed_task.uid,\n                                                                                                      stage.uid))\n\n                                        stage.add_tasks(completed_task)\n                                        mq_channel.basic_publish(exchange='',\n                                                                 routing_key=reply_to,\n                                                                 properties=pika.BasicProperties(\n                                                                     correlation_id=corr_id),\n                                                                 body='%s-ack' % completed_task.uid)\n\n                                        self._prof.prof('Adap: added new task')\n\n                                        self._prof.prof('publishing sync ack for obj with state %s' %\n                                                        msg['object']['state'],\n                                                        uid=msg['object']['uid']\n                                                        )\n\n                                        mq_channel.basic_ack(delivery_tag=method_frame.delivery_tag)\n                                        self._report.ok('Update: ')\n                                        self._report.info('%s state: %s\\n' %\n                                                          (completed_task.luid, completed_task.state))\n\n            def stage_update(msg, reply_to, corr_id, mq_channel):\n\n                completed_stage = Stage()\n                completed_stage.from_dict(msg['object'])\n                self._logger.info('Received %s with state %s' % (completed_stage.uid, completed_stage.state))\n\n                found_stage = False\n\n                # Traverse the entire workflow to find the correct stage\n                for pipe in self._workflow:\n\n                    if not pipe.completed:\n\n                        if completed_stage.parent_pipeline['uid'] == pipe.uid:\n                            self._logger.info('Found parent pipeline: %s' % pipe.uid)\n\n                            for stage in pipe.stages:\n\n                                if (completed_stage.uid == stage.uid)and(completed_stage.state != stage.state):\n\n                                    self._logger.debug('Found stage %s' % stage.uid)\n\n                                    stage.state = str(completed_stage.state)\n\n                                    mq_channel.basic_publish(exchange='',\n                                                             routing_key=reply_to,\n                                                             properties=pika.BasicProperties(\n                                                                 correlation_id=corr_id),\n                                                             body='%s-ack' % stage.uid)\n\n                                    self._prof.prof('publishing sync ack for obj with state %s' %\n                                                    msg['object']['state'],\n                                                    uid=msg['object']['uid']\n                                                    )\n\n                                    mq_channel.basic_ack(delivery_tag=method_frame.delivery_tag)\n                                    self._report.ok('Update: ')\n                                    self._report.info('%s state: %s\\n' % (stage.luid, stage.state))\n\n                                    found_stage = True\n\n                            if not found_stage:\n\n                                # If there was a Stage update, but the Stage was not found in any of the Pipelines. This\n                                # means that this was a Stage that was added during runtime and the AppManager does not\n                                # know about it. The current solution is going to be: add it to the workflow object in the\n                                # AppManager via the synchronizer.\n\n                                self._prof.prof('Adap: adding new stage', uid=self._uid)\n\n                                self._logger.info('Adding new stage %s to parent pipeline: %s' % (completed_stage.uid,\n                                                                                                  pipe.uid))\n\n                                pipe.add_stages(completed_stage)\n                                mq_channel.basic_publish(exchange='',\n                                                         routing_key=reply_to,\n                                                         properties=pika.BasicProperties(\n                                                             correlation_id=corr_id),\n                                                         body='%s-ack' % completed_stage.uid)\n\n                                self._prof.prof('Adap: adding new stage', uid=self._uid)\n\n                                self._prof.prof('publishing sync ack for obj with state %s' %\n                                                msg['object']['state'],\n                                                uid=msg['object']['uid']\n                                                )\n\n                                mq_channel.basic_ack(delivery_tag=method_frame.delivery_tag)\n\n            def pipeline_update(msg, reply_to, corr_id, mq_channel):\n\n                completed_pipeline = Pipeline()\n                completed_pipeline.from_dict(msg['object'])\n\n                self._logger.info('Received %s with state %s' % (completed_pipeline.uid, completed_pipeline.state))\n\n                # Traverse the entire workflow to find the correct pipeline\n                for pipe in self._workflow:\n\n                    if not pipe.completed:\n\n                        if (completed_pipeline.uid == pipe.uid)and(completed_pipeline.state != pipe.state):\n\n                            pipe.state = str(completed_pipeline.state)\n\n                            self._logger.info('Found pipeline %s, state %s, completed %s' % (pipe.uid,\n                                                                                             pipe.state,\n                                                                                             pipe.completed)\n                                              )\n\n                            # Reply with ack msg to the sender\n                            mq_channel.basic_publish(exchange='',\n                                                     routing_key=reply_to,\n                                                     properties=pika.BasicProperties(\n                                                         correlation_id=corr_id),\n                                                     body='%s-ack' % pipe.uid)\n\n                            self._prof.prof('publishing sync ack for obj with state %s' %\n                                            msg['object']['state'],\n                                            uid=msg['object']['uid']\n                                            )\n\n                            mq_channel.basic_ack(delivery_tag=method_frame.delivery_tag)\n\n                            # Keep the assignment of the completed flag after sending the acknowledgment\n                            # back. Otherwise the MainThread takes lock over the pipeline because of logging\n                            # and profiling\n                            if completed_pipeline.completed:\n                                pipe._completed_flag.set()\n                            self._report.ok('Update: ')\n                            self._report.info('%s state: %s\\n' % (pipe.luid, pipe.state))\n\n            mq_connection = pika.BlockingConnection(pika.ConnectionParameters(host=self._mq_hostname, port=self._port))\n            mq_channel = mq_connection.channel()\n\n            last = time.time()\n\n            while not self._terminate_sync.is_set():\n\n                #-------------------------------------------------------------------------------------------------------\n                # Messages between tmgr Main thread and synchronizer -- only Task objects\n\n                method_frame, props, body = mq_channel.basic_get(queue='%s-tmgr-to-sync' % self._sid)\n\n                \"\"\"\n                The message received is a JSON object with the following structure:\n\n                msg = {\n                        'type': 'Pipeline'/'Stage'/'Task',\n                        'object': json/dict\n                        }\n                \"\"\"\n\n                if body:\n\n                    msg = json.loads(body)\n\n                    self._prof.prof('received obj with state %s for sync' %\n                                    msg['object']['state'], uid=msg['object']['uid'])\n\n                    self._logger.debug('received %s with state %s for sync' %\n                                       (msg['object']['uid'], msg['object']['state']))\n\n                    if msg['type'] == 'Task':\n                        task_update(msg, '%s-sync-to-tmgr' % self._sid, props.correlation_id, mq_channel)\n\n                #-------------------------------------------------------------------------------------------------------\n\n                #-------------------------------------------------------------------------------------------------------\n                # Messages between callback thread and synchronizer -- only Task objects\n\n                method_frame, props, body = mq_channel.basic_get(queue='%s-cb-to-sync' % self._sid)\n\n                \"\"\"\n                The message received is a JSON object with the following structure:\n\n                msg = {\n                        'type': 'Pipeline'/'Stage'/'Task',\n                        'object': json/dict\n                        }\n                \"\"\"\n\n                if body:\n\n                    msg = json.loads(body)\n\n                    self._prof.prof('received obj with state %s for sync' %\n                                    msg['object']['state'], uid=msg['object']['uid'])\n\n                    self._logger.debug('received %s with state %s for sync' %\n                                       (msg['object']['uid'], msg['object']['state']))\n\n                    if msg['type'] == 'Task':\n                        task_update(msg, '%s-sync-to-cb' % self._sid, props.correlation_id, mq_channel)\n\n                #-------------------------------------------------------------------------------------------------------\n\n                #-------------------------------------------------------------------------------------------------------\n                # Messages between enqueue thread and synchronizer -- Task, Stage or Pipeline\n                method_frame, props, body = mq_channel.basic_get(queue='%s-enq-to-sync' % self._sid)\n\n                if body:\n\n                    msg = json.loads(body)\n\n                    self._prof.prof('received obj with state %s for sync' %\n                                    msg['object']['state'], uid=msg['object']['uid'])\n\n                    self._logger.debug('received %s with state %s for sync' %\n                                       (msg['object']['uid'], msg['object']['state']))\n\n                    if msg['type'] == 'Task':\n                        task_update(msg, '%s-sync-to-enq' % self._sid, props.correlation_id, mq_channel)\n\n                    elif msg['type'] == 'Stage':\n                        stage_update(msg, '%s-sync-to-enq' % self._sid, props.correlation_id, mq_channel)\n\n                    elif msg['type'] == 'Pipeline':\n                        pipeline_update(msg, '%s-sync-to-enq' % self._sid, props.correlation_id, mq_channel)\n                #-------------------------------------------------------------------------------------------------------\n\n                #-------------------------------------------------------------------------------------------------------\n                # Messages between dequeue thread and synchronizer -- Task, Stage or Pipeline\n                method_frame, props, body = mq_channel.basic_get(queue='%s-deq-to-sync' % self._sid)\n\n                if body:\n\n                    msg = json.loads(body)\n\n                    self._prof.prof('received obj with state %s for sync' %\n                                    msg['object']['state'], uid=msg['object']['uid'])\n\n                    self._logger.debug('received %s with state %s for sync' %\n                                       (msg['object']['uid'], msg['object']['state']))\n\n                    if msg['type'] == 'Task':\n                        task_update(msg, '%s-sync-to-deq' % self._sid, props.correlation_id, mq_channel)\n\n                    elif msg['type'] == 'Stage':\n                        stage_update(msg, '%s-sync-to-deq' % self._sid, props.correlation_id, mq_channel)\n\n                    elif msg['type'] == 'Pipeline':\n                        pipeline_update(msg, '%s-sync-to-deq' % self._sid, props.correlation_id, mq_channel)\n                #-------------------------------------------------------------------------------------------------------\n\n                # Appease pika cos it thinks the connection is dead\n                now = time.time()\n                if now - last >= self._rmq_ping_interval:\n                    mq_connection.process_data_events()\n                    last = now\n\n            self._prof.prof('terminating synchronizer', uid=self._uid)\n\n        except KeyboardInterrupt:\n\n            self._logger.exception('Execution interrupted by user (you probably hit Ctrl+C), ' +\n                               'trying to terminate synchronizer thread gracefully...')\n\n            raise KeyboardInterrupt\n\n        except Exception, ex:\n\n            self._logger.exception('Unknown error in synchronizer: %s. \\n Terminating thread' % ex)\n            raise", "response": "Synchronize the master process with the master process."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncall only on a valid form this method will place the chosen metrics in the given catgory.", "response": "def categorize_metrics(self):\n        \"\"\"Called only on a valid form, this method will place the chosen\n        metrics in the given catgory.\"\"\"\n        category = self.cleaned_data['category_name']\n        metrics = self.cleaned_data['metrics']\n        self.r.reset_category(category, metrics)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _submit_resource_request(self):\n\n        try:\n\n            self._prof.prof('creating rreq', uid=self._uid)\n\n            def _pilot_state_cb(pilot, state):\n                self._logger.info('Pilot %s state: %s' % (pilot.uid, state))\n\n                if state == rp.FAILED:\n                    self._logger.error('Pilot has failed')\n\n                elif state == rp.DONE:\n                    self._logger.error('Pilot has completed')\n\n            self._session = rp.Session(dburl=self._mlab_url, uid=self._sid)\n            self._pmgr = rp.PilotManager(session=self._session)\n            self._pmgr.register_callback(_pilot_state_cb)\n\n            pd_init = {\n                'resource': self._resource,\n                'runtime': self._walltime,\n                'cores': self._cpus,\n                'project': self._project,\n            }\n\n            if self._gpus:\n                pd_init['gpus'] = self._gpus\n\n            if self._access_schema:\n                pd_init['access_schema'] = self._access_schema\n\n            if self._queue:\n                pd_init['queue'] = self._queue\n\n            if self._rts_config.get('sandbox_cleanup', None):\n                pd_init['cleanup'] = True\n\n            # Create Compute Pilot with validated resource description\n            pdesc = rp.ComputePilotDescription(pd_init)\n\n            self._prof.prof('rreq created', uid=self._uid)\n\n            # Launch the pilot\n            self._pilot = self._pmgr.submit_pilots(pdesc)\n\n            self._prof.prof('rreq submitted', uid=self._uid)\n\n            shared_staging_directives = list()\n            for data in self._shared_data:\n                temp = {\n                    'source': data,\n                    'target': 'pilot:///' + os.path.basename(data)\n                }\n                shared_staging_directives.append(temp)\n\n            self._pilot.stage_in(shared_staging_directives)\n\n            self._prof.prof('shared data staging initiated', uid=self._uid)\n            self._logger.info('Resource request submission successful.. waiting for pilot to go Active')\n\n            # Wait for pilot to go active\n            self._pilot.wait([rp.PMGR_ACTIVE, rp.FAILED, rp.CANCELED])\n\n            self._prof.prof('resource active', uid=self._uid)\n            self._logger.info('Pilot is now active')\n\n        except KeyboardInterrupt:\n\n            if self._session:\n                self._session.close()\n\n            self._logger.exception('Execution interrupted by user (you probably hit Ctrl+C), ' +\n                               'trying to exit callback thread gracefully...')\n            raise KeyboardInterrupt\n\n        except Exception, ex:\n            self._logger.exception('Resource request submission failed')\n            raise", "response": "Submits a resource request to the RADICAL Pilot."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _terminate_resource_request(self):\n\n        try:\n\n            if self._pilot:\n\n                self._prof.prof('canceling resource allocation', uid=self._uid)\n                self._pilot.cancel()\n                download_rp_profile = os.environ.get('RADICAL_PILOT_PROFILE', False)\n                self._session.close(cleanup=self._rts_config.get('db_cleanup', False),\n                                    download=download_rp_profile)\n                self._prof.prof('resource allocation canceled', uid=self._uid)\n\n        except KeyboardInterrupt:\n\n            self._logger.exception('Execution interrupted by user (you probably hit Ctrl+C), ' +\n                               'trying to exit callback thread gracefully...')\n            raise KeyboardInterrupt\n\n        except Exception, ex:\n            self._logger.exception('Could not cancel resource request, error: %s' % ex)\n            raise", "response": "Cancel the resource allocation."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nrequesting service locations .", "response": "def get_list(self, size=100, startIndex=0, searchText=\"\", sortProperty=\"\", sortOrder='ASC', status='Active,Pending'):\n        \"\"\"\n        Request service locations\n\n        Returns\n        -------\n        dict\n        \"\"\"\n\n        url = urljoin(BASEURL, \"sites\", \"list\")\n\n        params = {\n            'api_key': self.token,\n            'size': size,\n            'startIndex': startIndex,\n            'sortOrder': sortOrder,\n            'status': status\n        }\n\n        if searchText:\n            params['searchText'] = searchText\n\n        if sortProperty:\n            params['sortProperty'] = sortProperty\n\n        r = requests.get(url, params)\n        r.raise_for_status()\n        return r.json()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef match(self, f, *args):\n        try:\n            match = f(self.tokenizer, *args)\n        except StopIteration:\n            # The grammar function might have tried to access more tokens than\n            # are available. That's not really an error, it just means it didn't\n            # match.\n            return\n\n        if match is None:\n            return\n\n        if not isinstance(match, grammar.TokenMatch):\n            raise TypeError(\"Invalid grammar function %r returned %r.\"\n                            % (f, match))\n\n        self.matched = match\n        return match", "response": "Match grammar function f against next token and set self. matched."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef accept(self, f, *args):\n        match = self.match(f, *args)\n        if match is None:\n            return\n\n        self.tokenizer.skip(len(match.tokens))\n        return match", "response": "Like match but consume the token."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef reject(self, f, *args):\n        match = self.match(f, *args)\n        if match:\n            token = self.peek(0)\n            raise errors.EfilterParseError(\n                query=self.tokenizer.source, token=token,\n                message=\"Was not expecting a %s here.\" % token.name)", "response": "Like match but throw a parse error if f matches."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef expect(self, f, *args):\n        match = self.accept(f, *args)\n        if match:\n            return match\n\n        try:\n            func_name = f.func_name\n        except AttributeError:\n            func_name = \"<unnamed grammar function>\"\n\n        start, end = self.current_position()\n        raise errors.EfilterParseError(\n            query=self.tokenizer.source, start=start, end=end,\n            message=\"Was expecting %s here.\" % (func_name))", "response": "Like accept but throws a parse error if f doesn t match."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a tuple of start end of the current token.", "response": "def current_position(self):\n        \"\"\"Return a tuple of (start, end).\"\"\"\n        token = self.tokenizer.peek(0)\n        if token:\n            return token.start, token.end\n\n        return self.tokenizer.position, self.tokenizer.position + 1"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef ComplementEquivalence(*args, **kwargs):\n    return ast.Complement(\n        ast.Equivalence(*args, **kwargs), **kwargs)", "response": "Change x!= y to not ( x == y."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nchanges x not in y to not in y.", "response": "def ComplementMembership(*args, **kwargs):\n    \"\"\"Change (x not in y) to not(x in y).\"\"\"\n    return ast.Complement(\n        ast.Membership(*args, **kwargs), **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nchange x doesn t contain y to not x.", "response": "def ReverseComplementMembership(x, y, **kwargs):\n    \"\"\"Change (x doesn't contain y) to not(y in x).\"\"\"\n    return ast.Complement(\n        ast.Membership(y, x, **kwargs), **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef __solve_for_repeated(expr, vars):\n    var = solve(expr, vars).value\n    if (var and isinstance(var, (tuple, list))\n            and protocol.implements(var[0], structured.IStructured)):\n        return repeated.meld(*var), False\n\n    return var, repeated.isrepeating(var)", "response": "Solve expr returning a value of a repeated value."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nsolve expr returning a scalar value.", "response": "def __solve_for_scalar(expr, vars):\n    \"\"\"Helper: solve 'expr' always returning a scalar (not IRepeated).\n\n    If the output of 'expr' is a single value or a single RowTuple with a single\n    column then return the value in that column. Otherwise raise.\n\n    Arguments:\n        expr: Expression to solve.\n        vars: The scope.\n\n    Returns:\n        A scalar value (not an IRepeated).\n\n    Raises:\n        EfilterTypeError if it cannot get a scalar.\n    \"\"\"\n    var = solve(expr, vars).value\n    try:\n        scalar = repeated.getvalue(var)\n    except TypeError:\n        raise errors.EfilterTypeError(\n            root=expr, query=expr.source,\n            message=\"Wasn't expecting more than one value here. Got %r.\"\n            % (var,))\n\n    if isinstance(scalar, row_tuple.RowTuple):\n        try:\n            return scalar.get_singleton()\n        except ValueError:\n            raise errors.EfilterTypeError(\n                root=expr, query=expr.source,\n                message=\"Was expecting a scalar value here. Got %r.\"\n                % (scalar,))\n    else:\n        return scalar"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the value of the var named in the expression.", "response": "def solve_var(expr, vars):\n    \"\"\"Returns the value of the var named in the expression.\"\"\"\n    try:\n        return Result(structured.resolve(vars, expr.value), ())\n    except (KeyError, AttributeError) as e:\n        # Raise a better exception for accessing a non-existent member.\n        raise errors.EfilterKeyError(root=expr, key=expr.value, message=e,\n                                     query=expr.source)\n    except (TypeError, ValueError) as e:\n        # Raise a better exception for what is probably a null pointer error.\n        if vars.locals is None:\n            raise errors.EfilterNoneError(\n                root=expr, query=expr.source,\n                message=\"Trying to access member %r of a null.\" % expr.value)\n        else:\n            raise errors.EfilterTypeError(\n                root=expr, query=expr.source,\n                message=\"%r (vars: %r)\" % (e, vars))\n    except NotImplementedError as e:\n        raise errors.EfilterError(\n            root=expr, query=expr.source,\n            message=\"Trying to access member %r of an instance of %r.\" %\n            (expr.value, type(vars)))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef solve_select(expr, vars):\n    data, _ = __solve_for_repeated(expr.lhs, vars)\n    key = solve(expr.rhs, vars).value\n\n    try:\n        results = [associative.select(d, key) for d in repeated.getvalues(data)]\n    except (KeyError, AttributeError):\n        # Raise a better exception for accessing a non-existent key.\n        raise errors.EfilterKeyError(root=expr, key=key, query=expr.source)\n    except (TypeError, ValueError):\n        # Raise a better exception for what is probably a null pointer error.\n        if vars.locals is None:\n            raise errors.EfilterNoneError(\n                root=expr, query=expr.source,\n                message=\"Cannot select key %r from a null.\" % key)\n        else:\n            raise\n    except NotImplementedError:\n        raise errors.EfilterError(\n            root=expr, query=expr.source,\n            message=\"Cannot select keys from a non-associative value.\")\n\n    return Result(repeated.meld(*results), ())", "response": "Use IAssociative. select to get key from the data ( lhs )."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nusing IStructured. resolve to get member from the object ( rhs ) from the object ( lhs ).", "response": "def solve_resolve(expr, vars):\n    \"\"\"Use IStructured.resolve to get member (rhs) from the object (lhs).\n\n    This operation supports both scalars and repeated values on the LHS -\n    resolving from a repeated value implies a map-like operation and returns a\n    new repeated values.\n    \"\"\"\n    objs, _ = __solve_for_repeated(expr.lhs, vars)\n    member = solve(expr.rhs, vars).value\n\n    try:\n        results = [structured.resolve(o, member)\n                   for o in repeated.getvalues(objs)]\n    except (KeyError, AttributeError):\n        # Raise a better exception for the non-existent member.\n        raise errors.EfilterKeyError(root=expr.rhs, key=member,\n                                     query=expr.source)\n    except (TypeError, ValueError):\n        # Is this a null object error?\n        if vars.locals is None:\n            raise errors.EfilterNoneError(\n                root=expr, query=expr.source,\n                message=\"Cannot resolve member %r from a null.\" % member)\n        else:\n            raise\n    except NotImplementedError:\n        raise errors.EfilterError(\n            root=expr, query=expr.source,\n            message=\"Cannot resolve members from a non-structured value.\")\n\n    return Result(repeated.meld(*results), ())"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef solve_apply(expr, vars):\n    func = __solve_for_scalar(expr.func, vars)\n    args = []\n    kwargs = {}\n    for arg in expr.args:\n        if isinstance(arg, ast.Pair):\n            if not isinstance(arg.lhs, ast.Var):\n                raise errors.EfilterError(\n                    root=arg.lhs,\n                    message=\"Invalid argument name.\")\n\n            kwargs[arg.key.value] = solve(arg.value, vars).value\n        else:\n            args.append(solve(arg, vars).value)\n\n    result = applicative.apply(func, args, kwargs)\n\n    return Result(result, ())", "response": "Returns the result of applying a function to its arguments."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nsolve the bind expression and return a RowTuple that is the result of evaluating the bind subtree.", "response": "def solve_bind(expr, vars):\n    \"\"\"Build a RowTuple from key/value pairs under the bind.\n\n    The Bind subtree is arranged as follows:\n\n    Bind\n    | First KV Pair\n    | | First Key Expression\n    | | First Value Expression\n    | Second KV Pair\n    | | Second Key Expression\n    | | Second Value Expression\n    Etc...\n\n    As we evaluate the subtree, each subsequent KV pair is evaluated with\n    the all previous bingings already in scope. For example:\n\n    bind(x: 5, y: x + 5)  # Will bind y = 10 because x is already available.\n    \"\"\"\n    value_expressions = []\n    keys = []\n    for pair in expr.children:\n        keys.append(solve(pair.key, vars).value)\n        value_expressions.append(pair.value)\n\n    result = row_tuple.RowTuple(ordered_columns=keys)\n    intermediate_scope = scope.ScopeStack(vars, result)\n\n    for idx, value_expression in enumerate(value_expressions):\n        value = solve(value_expression, intermediate_scope).value\n        # Update the intermediate bindings so as to make earlier bindings\n        # already available to the next child-expression.\n        result[keys[idx]] = value\n\n    return Result(result, ())"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef solve_repeat(expr, vars):\n    try:\n        result = repeated.meld(*[solve(x, vars).value for x in expr.children])\n        return Result(result, ())\n    except TypeError:\n        raise errors.EfilterTypeError(\n            root=expr, query=expr.source,\n            message=\"All values in a repeated value must be of the same type.\")", "response": "Build a repeated value from subexpressions."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nbuilding a tuple from subexpressions.", "response": "def solve_tuple(expr, vars):\n    \"\"\"Build a tuple from subexpressions.\"\"\"\n    result = tuple(solve(x, vars).value for x in expr.children)\n    return Result(result, ())"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nevaluating conditions and return the one that matches the given expression.", "response": "def solve_ifelse(expr, vars):\n    \"\"\"Evaluate conditions and return the one that matches.\"\"\"\n    for condition, result in expr.conditions():\n        if boolean.asbool(solve(condition, vars).value):\n            return solve(result, vars)\n\n    return solve(expr.default(), vars)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef solve_map(expr, vars):\n    lhs_values, _ = __solve_for_repeated(expr.lhs, vars)\n\n    def lazy_map():\n        try:\n            for lhs_value in repeated.getvalues(lhs_values):\n                yield solve(expr.rhs,\n                            __nest_scope(expr.lhs, vars, lhs_value)).value\n        except errors.EfilterNoneError as error:\n            error.root = expr\n            raise\n\n    return Result(repeated.lazy(lazy_map), ())", "response": "Solves the map - form by recursively calling its RHS with new vars."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nsolve a let - form by calling RHS with nested scope.", "response": "def solve_let(expr, vars):\n    \"\"\"Solves a let-form by calling RHS with nested scope.\"\"\"\n    lhs_value = solve(expr.lhs, vars).value\n    if not isinstance(lhs_value, structured.IStructured):\n        raise errors.EfilterTypeError(\n            root=expr.lhs, query=expr.original,\n            message=\"The LHS of 'let' must evaluate to an IStructured. Got %r.\"\n            % (lhs_value,))\n\n    return solve(expr.rhs, __nest_scope(expr.lhs, vars, lhs_value))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nfiltering values on the LHS by evaluating each value.", "response": "def solve_filter(expr, vars):\n    \"\"\"Filter values on the LHS by evaluating RHS with each value.\n\n    Returns any LHS values for which RHS evaluates to a true value.\n    \"\"\"\n    lhs_values, _ = __solve_for_repeated(expr.lhs, vars)\n\n    def lazy_filter():\n        for lhs_value in repeated.getvalues(lhs_values):\n            if solve(expr.rhs, __nest_scope(expr.lhs, vars, lhs_value)).value:\n                yield lhs_value\n\n    return Result(repeated.lazy(lazy_filter), ())"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef solve_sort(expr, vars):\n    lhs_values = repeated.getvalues(__solve_for_repeated(expr.lhs, vars)[0])\n\n    sort_expression = expr.rhs\n\n    def _key_func(x):\n        return solve(sort_expression, __nest_scope(expr.lhs, vars, x)).value\n\n    results = ordered.ordered(lhs_values, key_func=_key_func)\n\n    return Result(repeated.meld(*results), ())", "response": "Sort values on the LHS by the value they yield when passed to RHS."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn True if RHS evaluates to a true value with each state of LHS.", "response": "def solve_each(expr, vars):\n    \"\"\"Return True if RHS evaluates to a true value with each state of LHS.\n\n    If LHS evaluates to a normal IAssociative object then this is the same as\n    a regular let-form, except the return value is always a boolean. If LHS\n    evaluates to a repeared var (see efilter.protocols.repeated) of\n    IAssociative objects then RHS will be evaluated with each state and True\n    will be returned only if each result is true.\n    \"\"\"\n    lhs_values, _ = __solve_for_repeated(expr.lhs, vars)\n\n    for lhs_value in repeated.getvalues(lhs_values):\n        result = solve(expr.rhs, __nest_scope(expr.lhs, vars, lhs_value))\n        if not result.value:\n            # Each is required to return an actual boolean.\n            return result._replace(value=False)\n\n    return Result(True, ())"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget cast LHS to RHS.", "response": "def solve_cast(expr, vars):\n    \"\"\"Get cast LHS to RHS.\"\"\"\n    lhs = solve(expr.lhs, vars).value\n    t = solve(expr.rhs, vars).value\n\n    if t is None:\n        raise errors.EfilterTypeError(\n            root=expr, query=expr.source,\n            message=\"Cannot find type named %r.\" % expr.rhs.value)\n\n    if not isinstance(t, type):\n        raise errors.EfilterTypeError(\n            root=expr.rhs, query=expr.source,\n            message=\"%r is not a type and cannot be used with 'cast'.\" % (t,))\n\n    try:\n        cast_value = t(lhs)\n    except TypeError:\n        raise errors.EfilterTypeError(\n            root=expr, query=expr.source,\n            message=\"Invalid cast %s -> %s.\" % (type(lhs), t))\n\n    return Result(cast_value, ())"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef solve_isinstance(expr, vars):\n    lhs = solve(expr.lhs, vars)\n\n    try:\n        t = solve(expr.rhs, vars).value\n    except errors.EfilterKeyError:\n        t = None\n\n    if t is None:\n        raise errors.EfilterTypeError(\n            root=expr.rhs, query=expr.source,\n            message=\"Cannot find type named %r.\" % expr.rhs.value)\n\n    if not isinstance(t, type):\n        raise errors.EfilterTypeError(\n            root=expr.rhs, query=expr.source,\n            message=\"%r is not a type and cannot be used with 'isa'.\" % (t,))\n\n    return Result(protocol.implements(lhs.value, t), ())", "response": "Typecheck whether LHS is type on the RHS."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set_version(mod_root):\n\n    try:\n\n        version_base   = None\n        version_detail = None\n\n        # get version from './VERSION'\n        src_root = os.path.dirname(__file__)\n        if  not src_root:\n            src_root = '.'\n\n        with open(src_root + '/VERSION', 'r') as f:\n            version_base = f.readline().strip()\n\n        # attempt to get version detail information from git\n        # We only do that though if we are in a repo root dir,\n        # ie. if 'git rev-parse --show-prefix' returns an empty string --\n        # otherwise we get confused if the ve lives beneath another repository,\n        # and the pip version used uses an install tmp dir in the ve space\n        # instead of /tmp (which seems to happen with some pip/setuptools\n        # versions).\n        p = sp.Popen('cd %s ; '\n                     'test -z `git rev-parse --show-prefix` || exit -1; '\n                     'tag=`git describe --tags --always` 2>/dev/null ; '\n                     'branch=`git branch | grep -e \"^*\" | cut -f 2- -d \" \"` 2>/dev/null ; '\n                     'echo $tag@$branch' % src_root,\n                     stdout=sp.PIPE, stderr=sp.STDOUT, shell=True)\n        version_detail = str(p.communicate()[0].strip())\n        version_detail = version_detail.replace('detached from ', 'detached-')\n\n        # remove all non-alphanumeric (and then some) chars\n        version_detail = re.sub('[/ ]+', '-', version_detail)\n        version_detail = re.sub('[^a-zA-Z0-9_+@.-]+', '', version_detail)\n\n        if  p.returncode   !=  0  or \\\n            version_detail == '@' or \\\n            'git-error' in version_detail or \\\n            'not-a-git-repo' in version_detail or \\\n            'not-found'      in version_detail or \\\n            'fatal'          in version_detail :\n            version = version_base\n        elif '@' not in version_base:\n            version = '%s-%s' % (version_base, version_detail)\n        else:\n            version = version_base\n\n        # make sure the version files exist for the runtime version inspection\n        path = '%s/%s' % (src_root, mod_root)\n        with open(path + \"/VERSION\", \"w\") as f:\n            f.write(version + \"\\n\")\n\n        sdist_name = \"%s-%s.tar.gz\" % (name, version)\n        sdist_name = sdist_name.replace('/', '-')\n        sdist_name = sdist_name.replace('@', '-')\n        sdist_name = sdist_name.replace('#', '-')\n        sdist_name = sdist_name.replace('_', '-')\n\n        if '--record'    in sys.argv or \\\n           'bdist_egg'   in sys.argv or \\\n           'bdist_wheel' in sys.argv    :\n          # pip install stage 2 or easy_install stage 1\n          #\n          # pip install will untar the sdist in a tmp tree.  In that tmp\n          # tree, we won't be able to derive git version tags -- so we pack the\n          # formerly derived version as ./VERSION\n            shutil.move(\"VERSION\", \"VERSION.bak\")            # backup version\n            shutil.copy(\"%s/VERSION\" % path, \"VERSION\")      # use full version instead\n            os.system  (\"python setup.py sdist\")             # build sdist\n            shutil.copy('dist/%s' % sdist_name,\n                        '%s/%s'   % (mod_root, sdist_name))  # copy into tree\n            shutil.move(\"VERSION.bak\", \"VERSION\")            # restore version\n\n        with open(path + \"/SDIST\", \"w\") as f:\n            f.write(sdist_name + \"\\n\")\n\n        return version_base, version_detail, sdist_name\n\n    except Exception as e :\n        raise RuntimeError('Could not extract/set version: %s' % e)", "response": "This function will set the version of the mod_root and the version of the mod_root."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating distutil data_files structure from dir", "response": "def makeDataFiles(prefix, dir):\n    \"\"\" Create distutils data_files structure from dir\n    distutil will copy all file rooted under dir into prefix, excluding\n    dir itself, just like 'ditto src dst' works, and unlike 'cp -r src\n    dst, which copy src into dst'.\n    Typical usage:\n        # install the contents of 'wiki' under sys.prefix+'share/moin'\n        data_files = makeDataFiles('share/moin', 'wiki')\n    For this directory structure:\n        root\n            file1\n            file2\n            dir\n                file\n                subdir\n                    file\n    makeDataFiles('prefix', 'root')  will create this distutil data_files structure:\n        [('prefix', ['file1', 'file2']),\n         ('prefix/dir', ['file']),\n         ('prefix/dir/subdir', ['file'])]\n    \"\"\"\n    # Strip 'dir/' from of path before joining with prefix\n    dir = dir.rstrip('/')\n    strip = len(dir) + 1\n    found = []\n    os.path.walk(dir, visit, (prefix, strip, found))\n    #print found[0]\n    return found[0]"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef visit((prefix, strip, found), dirname, names):\n    files = []\n    # Iterate over a copy of names, modify names\n    for name in names[:]:\n        path = os.path.join(dirname, name)\n        # Ignore directories -  we will visit later\n        if os.path.isdir(path):\n            # Remove directories we don't want to visit later\n            if isbad(name):\n                names.remove(name)\n            continue\n        elif isgood(name):\n            files.append(path)\n    destination = os.path.join(prefix, dirname[strip:])\n    found.append((destination, files))", "response": "Visit directory and add distutil tuple for each file in names"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _initialize_workflow(self):\n\n        try:\n\n            self._prof.prof('initializing workflow', uid=self._uid)\n\n            for p in self._workflow:\n                p._assign_uid(self._sid)\n\n            self._prof.prof('workflow initialized', uid=self._uid)\n\n        except Exception, ex:\n            self._logger.exception(\n                'Fatal error while initializing workflow: %s' % ex)\n            raise", "response": "Initialize the PST of the workflow with a uid and type checks."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _enqueue(self, local_prof):\n\n        try:\n\n            local_prof.prof('enqueue-thread started', uid=self._uid)\n            self._logger.info('enqueue-thread started')\n\n            # Acquire a connection+channel to the rmq server\n            mq_connection = pika.BlockingConnection(\n                pika.ConnectionParameters(host=self._mq_hostname, port=self._port))\n            mq_channel = mq_connection.channel()\n\n            last = time.time()\n            while not self._enqueue_thread_terminate.is_set():\n\n                '''\n                We iterate through all pipelines to collect tasks from\n                stages that are pending scheduling. Once collected, these tasks\n                will be communicated to the tmgr in bulk.\n                '''\n\n                workload = []\n                scheduled_stages = []\n\n                for pipe in self._workflow:\n\n                    with pipe.lock:\n\n                        if ((not pipe.completed) and (not pipe.state == states.SUSPENDED)):\n\n                            # Test if the pipeline is already in the final state\n                            if pipe.state in states.FINAL:\n                                continue\n\n                            elif pipe.state == states.INITIAL:\n\n                                # Set state of pipeline to SCHEDULING if it is in INITIAL\n                                transition(obj=pipe,\n                                           obj_type='Pipeline',\n                                           new_state=states.SCHEDULING,\n                                           channel=mq_channel,\n                                           queue='%s-enq-to-sync' % self._sid,\n                                           profiler=local_prof,\n                                           logger=self._logger)\n\n                            executable_stage = pipe.stages[pipe.current_stage - 1]\n\n                            if not executable_stage.uid:\n                                executable_stage.parent_pipeline['uid'] = pipe.uid\n                                executable_stage.parent_pipeline['name'] = pipe.name\n                                executable_stage._assign_uid(self._sid)\n\n                            if executable_stage.state in [states.INITIAL, states.SCHEDULED]:\n\n                                if executable_stage.state == states.INITIAL:\n\n                                    transition(obj=executable_stage,\n                                               obj_type='Stage',\n                                               new_state=states.SCHEDULING,\n                                               channel=mq_channel,\n                                               queue='%s-enq-to-sync' % self._sid,\n                                               profiler=local_prof,\n                                               logger=self._logger)\n\n                                executable_tasks = executable_stage.tasks\n\n                                for executable_task in executable_tasks:\n\n                                    if (executable_task.state == states.INITIAL)or \\\n                                            ((executable_task.state == states.FAILED)and(self._resubmit_failed)):\n\n                                        # Set state of Tasks in current Stage to SCHEDULING\n                                        transition(obj=executable_task,\n                                                   obj_type='Task',\n                                                   new_state=states.SCHEDULING,\n                                                   channel=mq_channel,\n                                                   queue='%s-enq-to-sync' % self._sid,\n                                                   profiler=local_prof,\n                                                   logger=self._logger)\n\n                                        # task_as_dict = json.dumps(executable_task.to_dict())\n                                        workload.append(executable_task)\n\n                                        if executable_stage not in scheduled_stages:\n                                            scheduled_stages.append(\n                                                executable_stage)\n\n                if workload:\n\n                    # Put the task on one of the pending_queues\n                    workload_as_dict = list()\n                    for task in workload:\n                        workload_as_dict.append(task.to_dict())\n                    workload_as_dict = json.dumps(workload_as_dict)\n\n                    mq_channel.basic_publish(exchange='',\n                                             routing_key=self._pending_queue[0],\n                                             body=workload_as_dict\n                                             # properties=pika.BasicProperties(\n                                             # make message persistent\n                                             # delivery_mode = 2)\n                                             )\n\n                    for task in workload:\n\n                        # Set state of Tasks in current Stage to SCHEDULED\n                        transition(obj=task,\n                                   obj_type='Task',\n                                   new_state=states.SCHEDULED,\n                                   channel=mq_channel,\n                                   queue='%s-enq-to-sync' % self._sid,\n                                   profiler=local_prof,\n                                   logger=self._logger)\n\n                        self._logger.debug(\n                            'Task %s published to pending queue' % task.uid)\n\n                if scheduled_stages:\n                    for executable_stage in scheduled_stages:\n\n                        transition(obj=executable_stage,\n                                   obj_type='Stage',\n                                   new_state=states.SCHEDULED,\n                                   channel=mq_channel,\n                                   queue='%s-enq-to-sync' % self._sid,\n                                   profiler=local_prof,\n                                   logger=self._logger)\n\n                # Appease pika cos it thinks the connection is dead\n                now = time.time()\n                if now - last >= self._rmq_ping_interval:\n                    mq_connection.process_data_events()\n                    last = now\n\n            self._logger.info('Enqueue thread terminated')\n            mq_connection.close()\n\n            local_prof.prof('terminating enqueue-thread', uid=self._uid)\n\n        except KeyboardInterrupt:\n\n            self._logger.exception('Execution interrupted by user (you probably hit Ctrl+C), ' +\n                               'trying to cancel enqueuer thread gracefully...')\n\n            mq_connection.close()\n\n            raise KeyboardInterrupt\n\n        except Exception, ex:\n\n            self._logger.exception('Error in enqueue-thread: %s' % ex)\n            try:\n                mq_connection.close()\n            except Exception as ex:\n                self._logger.warning('mq_connection not created, %s' % ex)\n\n            raise", "response": "This function is run in the enqueue thread. It will iterate through all pipelines and put them into the pending_q list."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _wfp(self):\n\n        try:\n\n            local_prof = ru.Profiler(\n                name='radical.entk.%s' % self._uid + '-proc', path=self._path)\n\n            local_prof.prof('wfp process started', uid=self._uid)\n\n            self._logger.info('WFprocessor started')\n\n            # Process should run till terminate condtion is encountered\n            while (not self._wfp_terminate.is_set()):\n\n                try:\n\n                    # Start dequeue thread\n                    if (not self._dequeue_thread) or (not self._dequeue_thread.is_alive()):\n\n                        local_prof.prof(\n                            'creating dequeue-thread', uid=self._uid)\n                        self._dequeue_thread = threading.Thread(\n                            target=self._dequeue, args=(local_prof,), name='dequeue-thread')\n\n                        self._logger.info('Starting dequeue-thread')\n                        local_prof.prof(\n                            'starting dequeue-thread', uid=self._uid)\n                        self._dequeue_thread.start()\n\n                    # Start enqueue thread\n                    if (not self._enqueue_thread) or (not self._enqueue_thread.is_alive()):\n\n                        local_prof.prof(\n                            'creating enqueue-thread', uid=self._uid)\n                        self._enqueue_thread = threading.Thread(\n                            target=self._enqueue, args=(local_prof,), name='enqueue-thread')\n\n                        self._logger.info('Starting enqueue-thread')\n                        local_prof.prof(\n                            'starting enqueue-thread', uid=self._uid)\n                        self._enqueue_thread.start()\n\n                except Exception, ex:\n                    self._logger.exception('WFProcessor interrupted')\n                    raise\n\n            local_prof.prof('start termination', uid=self._uid)\n\n            self._logger.info('Terminating enqueue-thread')\n            self._enqueue_thread_terminate.set()\n            self._enqueue_thread.join()\n            self._logger.info('Terminating dequeue-thread')\n            self._dequeue_thread_terminate.set()\n            self._dequeue_thread.join()\n\n            local_prof.prof('termination done', uid=self._uid)\n\n            local_prof.prof('terminating wfp process', uid=self._uid)\n\n            local_prof.close()\n\n        except KeyboardInterrupt:\n\n            self._logger.exception('Execution interrupted by user (you probably hit Ctrl+C), ' +\n                               'trying to cancel wfprocessor process gracefully...')\n\n            if self._enqueue_thread:\n\n                if not self._enqueue_thread_terminate.is_set():\n                    self._logger.info('Terminating enqueue-thread')\n                    self._enqueue_thread_terminate.set()\n                    self._enqueue_thread.join()\n\n            if self._dequeue_thread:\n\n                if not self._dequeue_thread_terminate.is_set():\n                    self._logger.info('Terminating dequeue-thread')\n                    self._dequeue_thread_terminate.set()\n                    self._dequeue_thread.join()\n\n            self._logger.info('WFprocessor process terminated')\n\n            raise KeyboardInterrupt\n\n        except Exception, ex:\n            self._logger.exception(\n                'Error in wfp process: %s. \\n Closing enqueue, dequeue threads' % ex)\n\n            if self._enqueue_thread:\n\n                if not self._enqueue_thread_terminate.is_set():\n                    self._logger.info('Terminating enqueue-thread')\n                    self._enqueue_thread_terminate.set()\n                    self._enqueue_thread.join()\n\n            if self._dequeue_thread:\n\n                if not self._dequeue_thread_terminate.is_set():\n                    self._logger.info('Terminating dequeue-thread')\n                    self._dequeue_thread_terminate.set()\n                    self._dequeue_thread.join()\n\n            self._logger.info('WFprocessor process terminated')\n\n            self._logger.exception('%s failed with %s'%(self._uid, ex))\n            raise EnTKError(ex)", "response": "This function is used to create and spawn two threads for the slow version of the WF processor."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef start_processor(self):\n\n        if not self._wfp_process:\n\n            try:\n\n                self._prof.prof('creating wfp process', uid=self._uid)\n                self._wfp_process = Process(\n                    target=self._wfp, name='wfprocessor')\n\n                self._enqueue_thread = None\n                self._dequeue_thread = None\n                self._enqueue_thread_terminate = threading.Event()\n                self._dequeue_thread_terminate = threading.Event()\n\n                self._wfp_terminate = Event()\n                self._logger.info('Starting WFprocessor process')\n                self._prof.prof('starting wfp process', uid=self._uid)\n                self._wfp_process.start()\n\n                return True\n\n            except Exception, ex:\n\n                self._logger.exception('WFprocessor not started')\n                self.terminate_processor()\n                raise\n\n        else:\n            self._logger.warn(\n                'Wfp process already running, attempted to restart!')", "response": "Start the WFprocessor process."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef terminate_processor(self):\n\n        try:\n\n            if self.check_processor():\n                self._logger.debug(\n                    'Attempting to end WFprocessor... event: %s' % self._wfp_terminate.is_set())\n                self._wfp_terminate.set()\n                self._wfp_process.join()\n                self._wfp_process = None\n                self._logger.debug('WFprocessor process terminated')\n            else:\n                self._logger.debug('WFprocessor process already terminated')\n\n            self._prof.prof('wfp process terminated', uid=self._uid)\n\n            self._prof.close()\n\n        except Exception, ex:\n            self._logger.exception('Could not terminate wfprocessor process')\n            raise", "response": "This method terminate the WFprocessor process."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef workflow_incomplete(self):\n\n        try:\n            for pipe in self._workflow:\n                with pipe.lock:\n                    if pipe.completed:\n                        pass\n                    else:\n                        return True\n            return False\n\n        except Exception, ex:\n            self._logger.exception(\n                'Could not check if workflow is incomplete, error:%s' % ex)\n            raise", "response": "Checks if the workflow is incomplete."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the repeated value or first value if there s only one.", "response": "def meld(*values):\n    \"\"\"Return the repeated value, or the first value if there's only one.\n\n    This is a convenience function, equivalent to calling\n    getvalue(repeated(x)) to get x.\n\n    This function skips over instances of None in values (None is not allowed\n    in repeated variables).\n\n    Examples:\n        meld(\"foo\", \"bar\") # => ListRepetition(\"foo\", \"bar\")\n        meld(\"foo\", \"foo\") # => ListRepetition(\"foo\", \"foo\")\n        meld(\"foo\", None) # => \"foo\"\n        meld(None) # => None\n    \"\"\"\n    values = [x for x in values if x is not None]\n    if not values:\n        return None\n\n    result = repeated(*values)\n    if isrepeating(result):\n        return result\n\n    return getvalue(result)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef getvalue(x):\n    if isrepeating(x):\n        raise TypeError(\n            \"Ambiguous call to getvalue for %r which has more than one value.\"\n            % x)\n\n    for value in getvalues(x):\n        return value", "response": "Return the single value of x."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the fully qualified unique ID of the current task.", "response": "def luid(self):\n        \"\"\"\n        Unique ID of the current task (fully qualified).\n\n        example:\n            >>> task.luid\n            pipe.0001.stage.0004.task.0234\n\n        :getter: Returns the fully qualified uid of the current task\n        :type: String\n        \"\"\"\n        p_elem = self.parent_pipeline.get('name')\n        if not p_elem:\n            p_elem = self.parent_pipeline['uid']\n\n        s_elem = self.parent_stage.get('name')\n        if not s_elem:\n            s_elem = self.parent_stage['uid']\n\n        t_elem = self.name\n        if not t_elem:\n            t_elem = self.uid\n\n        return '%s.%s.%s' % (p_elem, s_elem, t_elem)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef to_dict(self):\n\n        task_desc_as_dict = {\n            'uid': self._uid,\n            'name': self._name,\n            'state': self._state,\n            'state_history': self._state_history,\n\n            'pre_exec': self._pre_exec,\n            'executable': self._executable,\n            'arguments': self._arguments,\n            'post_exec': self._post_exec,\n            'cpu_reqs': self._cpu_reqs,\n            'gpu_reqs': self._gpu_reqs,\n            'lfs_per_process': self._lfs_per_process,\n\n            'upload_input_data': self._upload_input_data,\n            'copy_input_data': self._copy_input_data,\n            'link_input_data': self._link_input_data,\n            'move_input_data': self._move_input_data,\n            'copy_output_data': self._copy_output_data,\n            'move_output_data': self._move_output_data,\n            'download_output_data': self._download_output_data,\n\n            'stdout': self._stdout,\n            'stderr': self._stderr,\n\n            'exit_code': self._exit_code,\n            'path': self._path,\n            'tag': self._tag,\n\n            'parent_stage': self._p_stage,\n            'parent_pipeline': self._p_pipeline,\n        }\n\n        return task_desc_as_dict", "response": "Convert the current Task into a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef from_dict(self, d):\n\n        if 'uid' in d:\n            if d['uid']:\n                self._uid = d['uid']\n\n        if 'name' in d:\n            if d['name']:\n                self._name = d['name']\n\n        if 'state' in d:\n            if isinstance(d['state'], str) or isinstance(d['state'], unicode):\n                self._state = d['state']\n            else:\n                raise TypeError(entity='state', expected_type=str,\n                                actual_type=type(d['state']))\n        else:\n            self._state = states.INITIAL\n\n        if 'state_history' in d:\n            if isinstance(d['state_history'], list):\n                self._state_history = d['state_history']\n            else:\n                raise TypeError(entity='state_history', expected_type=list, actual_type=type(\n                    d['state_history']))\n\n        if 'pre_exec' in d:\n            if isinstance(d['pre_exec'], list):\n                self._pre_exec = d['pre_exec']\n            else:\n                raise TypeError(expected_type=list,\n                                actual_type=type(d['pre_exec']))\n\n        if 'executable' in d:\n            if isinstance(d['executable'], str) or isinstance(d['executable'], unicode):\n                self._executable = d['executable']\n            else:\n                raise TypeError(expected_type=str,\n                                actual_type=type(d['executable']))\n\n        if 'arguments' in d:\n            if isinstance(d['arguments'], list):\n                self._arguments = d['arguments']\n            else:\n                raise TypeError(expected_type=list,\n                                actual_type=type(d['arguments']))\n\n        if 'post_exec' in d:\n            if isinstance(d['post_exec'], list):\n                self._post_exec = d['post_exec']\n            else:\n                raise TypeError(expected_type=list,\n                                actual_type=type(d['post_exec']))\n\n        if 'cpu_reqs' in d:\n            if isinstance(d['cpu_reqs'], dict):\n                self._cpu_reqs = d['cpu_reqs']\n            else:\n                raise TypeError(expected_type=dict,\n                                actual_type=type(d['cpu_reqs']))\n\n        if 'gpu_reqs' in d:\n            if isinstance(d['gpu_reqs'], dict):\n                self._gpu_reqs = d['gpu_reqs']\n            else:\n                raise TypeError(expected_type=dict,\n                                actual_type=type(d['gpu_reqs']))\n\n        if 'lfs_per_process' in d:\n            if d['lfs_per_process']:\n                if isinstance(d['lfs_per_process'], int):\n                    self._lfs_per_process = d['lfs_per_process']\n                else:\n                    raise TypeError(expected_type=int,\n                                    actual_type=type(d['lfs_per_process']))\n\n        if 'upload_input_data' in d:\n            if isinstance(d['upload_input_data'], list):\n                self._upload_input_data = d['upload_input_data']\n            else:\n                raise TypeError(expected_type=list,\n                                actual_type=type(d['upload_input_data']))\n\n        if 'copy_input_data' in d:\n            if isinstance(d['copy_input_data'], list):\n                self._copy_input_data = d['copy_input_data']\n            else:\n                raise TypeError(expected_type=list,\n                                actual_type=type(d['copy_input_data']))\n\n        if 'link_input_data' in d:\n            if isinstance(d['link_input_data'], list):\n                self._link_input_data = d['link_input_data']\n            else:\n                raise TypeError(expected_type=list,\n                                actual_type=type(d['link_input_data']))\n\n        if 'move_input_data' in d:\n            if isinstance(d['move_input_data'], list):\n                self._move_input_data = d['move_input_data']\n            else:\n                raise TypeError(expected_type=list,\n                                actual_type=type(d['move_input_data']))\n\n\n        if 'copy_output_data' in d:\n            if isinstance(d['copy_output_data'], list):\n                self._copy_output_data = d['copy_output_data']\n            else:\n                raise TypeError(expected_type=list,\n                                actual_type=type(d['copy_output_data']))\n\n        if 'move_output_data' in d:\n            if isinstance(d['move_output_data'], list):\n                self._move_output_data = d['move_output_data']\n            else:\n                raise TypeError(expected_type=list,\n                                actual_type=type(d['move_output_data']))\n\n        if 'download_output_data' in d:\n            if isinstance(d['download_output_data'], list):\n                self._download_output_data = d['download_output_data']\n            else:\n                raise TypeError(expected_type=list, actual_type=type(\n                    d['download_output_data']))\n\n        if 'stdout' in d:\n            if d['stdout']:\n                if isinstance(d['stdout'], str) or isinstance(d['stdout'], unicode):\n                    self._stdout = d['stdout']\n                else:\n                    raise TypeError(expected_type=str, actual_type=type(d['stdout']))\n\n        if 'stderr' in d:\n            if d['stderr']:\n                if isinstance(d['stderr'], str) or isinstance(d['stderr'], unicode):\n                    self._stderr = d['stderr']\n                else:\n                    raise TypeError(expected_type=str, actual_type=type(d['stderr']))\n\n        if 'exit_code' in d:\n            if d['exit_code']:\n                if isinstance(d['exit_code'], int):\n                    self._exit_code = d['exit_code']\n                else:\n                    raise TypeError(\n                        entity='exit_code', expected_type=int, actual_type=type(d['exit_code']))\n\n        if 'path' in d:\n            if d['path']:\n                if isinstance(d['path'], str) or isinstance(d['path'], unicode):\n                    self._path = d['path']\n                else:\n                    raise TypeError(entity='path', expected_type=str,\n                                    actual_type=type(d['path']))\n\n        if 'tag' in d:\n            if d['tag']:\n                if isinstance(d['tag'], str) or isinstance(d['tag'], unicode):\n                    self._tag = str(d['tag'])\n                else:\n                    raise TypeError(expected_type=str,\n                                    actual_type=type(d['tag']))\n\n        if 'parent_stage' in d:\n            if isinstance(d['parent_stage'], dict):\n                self._p_stage = d['parent_stage']\n            else:\n                raise TypeError(\n                    entity='parent_stage', expected_type=dict, actual_type=type(d['parent_stage']))\n\n        if 'parent_pipeline' in d:\n            if isinstance(d['parent_pipeline'], dict):\n                self._p_pipeline = d['parent_pipeline']\n            else:\n                raise TypeError(entity='parent_pipeline', expected_type=dict, actual_type=type(\n                    d['parent_pipeline']))", "response": "Create a Task from a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nassigns a uid to the current object based on the sid passed in.", "response": "def _assign_uid(self, sid):\n        \"\"\"\n        Purpose: Assign a uid to the current object based on the sid passed\n        \"\"\"\n        self._uid = ru.generate_id(\n            'task.%(item_counter)04d', ru.ID_CUSTOM, namespace=sid)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _validate(self):\n\n        if self._state is not states.INITIAL:\n            raise ValueError(obj=self._uid,\n                             attribute='state',\n                             expected_value=states.INITIAL,\n                             actual_value=self._state)\n\n        if not self._executable:\n            raise MissingError(obj=self._uid,\n                               missing_attribute='executable')", "response": "Validate that the state of the current object is DESCRIBED and that the executable is specified for the current object."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _process_tasks(self, task_queue, rmgr, logger, mq_hostname, port, local_prof, sid):\n\n\n        '''\n        **Purpose**: The new thread that gets spawned by the main tmgr process invokes this function. This\n        function receives tasks from 'task_queue' and submits them to the RADICAL Pilot RTS.\n        '''\n\n        placeholder_dict = dict()\n\n        def load_placeholder(task, rts_uid):\n\n            parent_pipeline = str(task.parent_pipeline['name'])\n            parent_stage = str(task.parent_stage['name'])\n\n            if parent_pipeline not in placeholder_dict:\n                placeholder_dict[parent_pipeline] = dict()\n\n            if parent_stage not in placeholder_dict[parent_pipeline]:\n                placeholder_dict[parent_pipeline][parent_stage] = dict()\n\n            if None not in [parent_pipeline, parent_stage, task.name]:\n                placeholder_dict[parent_pipeline][parent_stage][str(task.name)] = {'path': str(task.path),\n                                                                                   'rts_uid': rts_uid}\n\n        def unit_state_cb(unit, state):\n\n            try:\n\n                logger.debug('Unit %s in state %s' % (unit.uid, unit.state))\n\n                if unit.state in rp.FINAL:\n\n                    # Acquire a connection+channel to the rmq server\n                    mq_connection = pika.BlockingConnection(\n                        pika.ConnectionParameters(host=mq_hostname, port=port))\n                    mq_channel = mq_connection.channel()\n\n                    task = None\n                    task = create_task_from_cu(unit, local_prof)\n\n                    transition(obj=task,\n                               obj_type='Task',\n                               new_state=states.COMPLETED,\n                               channel=mq_channel,\n                               queue='%s-cb-to-sync' % sid,\n                               profiler=local_prof,\n                               logger=logger)\n\n                    load_placeholder(task, unit.uid)\n\n                    task_as_dict = json.dumps(task.to_dict())\n\n                    mq_channel.basic_publish(exchange='',\n                                             routing_key='%s-completedq-1' % sid,\n                                             body=task_as_dict\n                                             # properties=pika.BasicProperties(\n                                             # make message persistent\n                                             #    delivery_mode = 2,\n                                             # )\n                                             )\n\n                    logger.info('Pushed task %s with state %s to completed queue %s-completedq-1' % (task.uid, task.state,\n                                                                                                     sid))\n\n                    mq_connection.close()\n\n            except KeyboardInterrupt:\n                logger.exception('Execution interrupted by user (you probably hit Ctrl+C), ' +\n                                 'trying to exit callback thread gracefully...')\n\n                raise KeyboardInterrupt\n\n            except Exception, ex:\n                logger.exception('Error in RP callback thread: %s' % ex)\n\n        umgr = rp.UnitManager(session=rmgr._session)\n        umgr.add_pilots(rmgr.pilot)\n        umgr.register_callback(unit_state_cb)\n\n        try:\n\n            while not self._tmgr_terminate.is_set():\n\n                body = None\n\n                try:\n                    body = task_queue.get(block=True, timeout=10)\n                except Queue.Empty:\n                    # Ignore empty exception, we don't always have new tasks to run\n                    pass\n\n                if body:\n\n                    task_queue.task_done()\n\n                    bulk_tasks = list()\n                    bulk_cuds = list()\n\n                    for task in body:\n                        t = Task()\n                        t.from_dict(task)\n                        bulk_tasks.append(t)\n                        bulk_cuds.append(create_cud_from_task(\n                            t, placeholder_dict, local_prof))\n\n                        mq_connection = pika.BlockingConnection(pika.ConnectionParameters(host=mq_hostname, port=port))\n                        mq_channel = mq_connection.channel()\n\n                        transition(obj=t,\n                                   obj_type='Task',\n                                   new_state=states.SUBMITTING,\n                                   channel=mq_channel,\n                                   queue='%s-tmgr-to-sync' % sid,\n                                   profiler=local_prof,\n                                   logger=logger)\n\n                        mq_connection.close()\n\n\n                    umgr.submit_units(bulk_cuds)\n\n                    for task in bulk_tasks:\n\n                        mq_connection = pika.BlockingConnection(pika.ConnectionParameters(host=mq_hostname, port=port))\n                        mq_channel = mq_connection.channel()\n\n                        transition(obj=task,\n                                   obj_type='Task',\n                                   new_state=states.SUBMITTED,\n                                   channel=mq_channel,\n                                   queue='%s-tmgr-to-sync' % sid,\n                                   profiler=local_prof,\n                                   logger=logger)\n\n                        mq_connection.close()\n\n        except KeyboardInterrupt as ex:\n            logger.exception('Execution interrupted by user (you probably hit Ctrl+C), ' +\n                            'trying to cancel task processor gracefully...')\n\n        except Exception as ex:\n            logger.exception('%s failed with %s'%(self._uid, ex))\n            raise EnTKError(ex)", "response": "This function processes all tasks from the task_queue and creates a new thread and submits them to the RADICAL Pilot RTS."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef infer_type(expr, scope):\n    # Do we know what the key even is?\n    if isinstance(expr.key, ast.Literal):\n        key = expr.key.value\n    else:\n        return protocol.AnyType\n\n    container_type = infer_type(expr.value, scope)\n\n    try:\n        # Associative types are not subject to scoping rules so we can just\n        # reflect using IAssociative.\n        return associative.reflect(container_type, key) or protocol.AnyType\n    except NotImplementedError:\n        return protocol.AnyType", "response": "Try to infer the type of x y."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef infer_type(expr, scope):\n    # Do we know what the member is?\n    if isinstance(expr.member, ast.Literal):\n        member = expr.member.value\n    else:\n        return protocol.AnyType\n\n    container_type = infer_type(expr.obj, scope)\n\n    try:\n        # We are not using lexical scope here on purpose - we want to see what\n        # the type of the member is only on the container_type.\n        return structured.reflect(container_type, member) or protocol.AnyType\n    except NotImplementedError:\n        return protocol.AnyType", "response": "Try to infer the type of x. y if x is a known value."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _tmgr(self, uid, rmgr, logger, mq_hostname, port, pending_queue, completed_queue):\n\n        try:\n\n            def heartbeat_response(mq_channel):\n\n                try:\n\n                    # Get request from heartbeat-req for heartbeat response\n                    hb_method_frame, hb_props, hb_body = mq_channel.basic_get(\n                        queue=self._hb_request_q)\n\n                    if hb_body:\n\n                        logger.info('Received heartbeat request')\n\n                        mq_channel.basic_publish(exchange='',\n                                                 routing_key=self._hb_response_q,\n                                                 properties=pika.BasicProperties(\n                                                     correlation_id=hb_props.correlation_id),\n                                                 body='response')\n\n                        logger.info('Sent heartbeat response')\n                        mq_channel.basic_ack(\n                            delivery_tag=hb_method_frame.delivery_tag)\n\n                except Exception, ex:\n                    logger.exception(\n                        'Failed to respond to heartbeat request, error: %s' % ex)\n                    raise\n\n            local_prof = ru.Profiler(\n                name='radical.entk.%s' % self._uid + '-proc', path=self._path)\n\n            local_prof.prof('tmgr process started', uid=self._uid)\n            logger.info('Task Manager process started')\n\n            # Thread should run till terminate condtion is encountered\n            mq_connection = pika.BlockingConnection(\n                pika.ConnectionParameters(host=mq_hostname, port=port))\n            mq_channel = mq_connection.channel()\n\n            # Queue for communication between threads of this process\n            task_queue = Queue.Queue()\n\n            # Start second thread to receive tasks and push to RTS\n            self._rts_runner = threading.Thread(target=self._process_tasks,\n                                                args=(task_queue,\n                                                      rmgr,\n                                                      logger,\n                                                      mq_hostname,\n                                                      port,\n                                                      local_prof,\n                                                      self._sid))\n            self._rts_runner.start()\n\n            local_prof.prof('tmgr infrastructure setup done', uid=uid)\n\n            last = time.time()\n            while not self._tmgr_terminate.is_set():\n\n                try:\n\n                    method_frame, header_frame, body = mq_channel.basic_get(\n                        queue=pending_queue[0])\n\n                    if body:\n\n                        body = json.loads(body)\n                        task_queue.put(body)\n\n                        mq_channel.basic_ack(\n                            delivery_tag=method_frame.delivery_tag)\n\n                    heartbeat_response(mq_channel)\n\n                except Exception, ex:\n                    logger.exception('Error in task execution: %s' % ex)\n                    raise\n\n        except KeyboardInterrupt:\n\n            logger.exception('Execution interrupted by user (you probably hit Ctrl+C), ' +\n                               'trying to cancel tmgr process gracefully...')\n\n        except Exception, ex:\n\n            logger.exception('%s failed with %s'%(self._uid, ex))\n            raise EnTKError(ex)\n\n        finally:\n\n            local_prof.prof('terminating tmgr process', uid=uid)\n\n            if self._rts_runner:\n                self._rts_runner.join()\n\n            mq_connection.close()\n            local_prof.close()", "response": "This method is used to run the App Manager process. It is called by the App Manager process. It is called by the App Manager process to process the Task from the pending_queue and the Task from the completed_queue."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nstarts the task manager process.", "response": "def start_manager(self):\n        \"\"\"\n        **Purpose**: Method to start the tmgr process. The tmgr function\n        is not to be accessed directly. The function is started in a separate\n        thread using this method.\n        \"\"\"\n\n        if not self._tmgr_process:\n\n            try:\n\n                self._prof.prof('creating tmgr process', uid=self._uid)\n                self._tmgr_terminate = Event()\n\n                self._tmgr_process = Process(target=self._tmgr,\n                                             name='task-manager',\n                                             args=(\n                                                 self._uid,\n                                                 self._rmgr,\n                                                 self._logger,\n                                                 self._mq_hostname,\n                                                 self._port,\n                                                 self._pending_queue,\n                                                 self._completed_queue)\n                                             )\n\n                self._logger.info('Starting task manager process')\n                self._prof.prof('starting tmgr process', uid=self._uid)\n                self._tmgr_process.start()\n\n                return True\n\n            except Exception, ex:\n\n                self._logger.exception('Task manager not started, error: %s' % ex)\n                self.terminate_manager()\n                raise\n\n        else:\n            self._logger.warn(\n                'tmgr process already running, but attempted to restart!')"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncasing - insensitive keyword match.", "response": "def keyword(tokens, expected):\n    \"\"\"Case-insensitive keyword match.\"\"\"\n    try:\n        token = next(iter(tokens))\n    except StopIteration:\n        return\n\n    if token and token.name == \"symbol\" and token.value.lower() == expected:\n        return TokenMatch(None, token.value, (token,))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef multi_keyword(tokens, keyword_parts):\n    tokens = iter(tokens)\n    matched_tokens = []\n    limit = len(keyword_parts)\n\n    for idx in six.moves.range(limit):\n        try:\n            token = next(tokens)\n        except StopIteration:\n            return\n\n        if (not token or token.name != \"symbol\" or\n                token.value.lower() != keyword_parts[idx]):\n            return\n\n        matched_tokens.append(token)\n\n    return TokenMatch(None, token.value, matched_tokens)", "response": "Match a case - insensitive keyword consisting of multiple tokens."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nmatch a prefix of an operator.", "response": "def prefix(tokens, operator_table):\n    \"\"\"Match a prefix of an operator.\"\"\"\n    operator, matched_tokens = operator_table.prefix.match(tokens)\n    if operator:\n        return TokenMatch(operator, None, matched_tokens)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef infix(tokens, operator_table):\n    operator, matched_tokens = operator_table.infix.match(tokens)\n    if operator:\n        return TokenMatch(operator, None, matched_tokens)", "response": "Match an infix of an operator."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nmatches a suffix of an operator.", "response": "def suffix(tokens, operator_table):\n    \"\"\"Match a suffix of an operator.\"\"\"\n    operator, matched_tokens = operator_table.suffix.match(tokens)\n    if operator:\n        return TokenMatch(operator, None, matched_tokens)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nmatching a token name ( type.", "response": "def token_name(tokens, expected):\n    \"\"\"Match a token name (type).\"\"\"\n    try:\n        token = next(iter(tokens))\n    except StopIteration:\n        return\n\n    if token and token.name == expected:\n        return TokenMatch(None, token.value, (token,))"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ngenerate a grammar function that will match expected_tokens only.", "response": "def match_tokens(expected_tokens):\n    \"\"\"Generate a grammar function that will match 'expected_tokens' only.\"\"\"\n    if isinstance(expected_tokens, Token):\n        # Match a single token.\n        def _grammar_func(tokens):\n            try:\n                next_token = next(iter(tokens))\n            except StopIteration:\n                return\n\n            if next_token == expected_tokens:\n                return TokenMatch(None, next_token.value, (next_token,))\n\n    elif isinstance(expected_tokens, tuple):\n        # Match multiple tokens.\n        match_len = len(expected_tokens)\n        def _grammar_func(tokens):\n            upcoming = tuple(itertools.islice(tokens, match_len))\n            if upcoming == expected_tokens:\n                return TokenMatch(None, None, upcoming)\n    else:\n        raise TypeError(\n            \"'expected_tokens' must be an instance of Token or a tuple \"\n            \"thereof. Got %r.\" % expected_tokens)\n\n    return _grammar_func"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef expression(self, previous_precedence=0):\n        lhs = self.atom()\n\n        return self.operator(lhs, previous_precedence)", "response": "An expression is an atom or an infix expression."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef atom(self):\n        # Parameter replacement with literals.\n        if self.tokens.accept(grammar.param):\n            return self.param()\n\n        # Let expressions (let(x = 5, y = 10) x + y)\n        if self.tokens.accept(grammar.let):\n            return self.let()\n\n        # At the top level, we try to see if we are recursing into an SQL query.\n        if self.tokens.accept(grammar.select):\n            return self.select()\n\n        # A SELECT query can also start with 'ANY'.\n        if self.tokens.accept(grammar.select_any):\n            return self.select_any()\n\n        # Explicitly reject any keywords from SQL other than SELECT and ANY.\n        # If we don't do this they will match as valid symbols (variables)\n        # and that might be confusing to the user.\n        self.tokens.reject(grammar.sql_keyword)\n\n        # Match if-else before other things that consume symbols.\n        if self.tokens.accept(grammar.if_if):\n            return self.if_if()\n\n        # Operators must be matched first because the same symbols could also\n        # be vars or applications.\n        if self.tokens.accept(grammar.prefix):\n            operator = self.tokens.matched.operator\n            start = self.tokens.matched.start\n            expr = self.expression(operator.precedence)\n            return operator.handler(expr, start=start, end=expr.end,\n                                    source=self.original)\n\n        if self.tokens.accept(grammar.literal):\n            return ast.Literal(self.tokens.matched.value, source=self.original,\n                               start=self.tokens.matched.start,\n                               end=self.tokens.matched.end)\n\n        # Match builtin pseudo-functions before functions and vars to prevent\n        # overrides.\n        if self.tokens.accept(grammar.builtin):\n            return self.builtin(self.tokens.matched.value)\n\n        # Match applications before vars, because obviously.\n        if self.tokens.accept(grammar.application):\n            return self.application(\n                ast.Var(self.tokens.matched.value, source=self.original,\n                        start=self.tokens.matched.start,\n                        end=self.tokens.matched.first.end))\n\n        if self.tokens.accept(common_grammar.symbol):\n            return ast.Var(self.tokens.matched.value, source=self.original,\n                           start=self.tokens.matched.start,\n                           end=self.tokens.matched.end)\n\n        if self.tokens.accept(common_grammar.lparen):\n            # Parens will contain one or more expressions. If there are several\n            # expressions, separated by commas, then they are a repeated value.\n            #\n            # Unlike lists, repeated values must all be of the same type,\n            # otherwise evaluation of the query will fail at runtime (or\n            # type-check time, for simple cases.)\n            start = self.tokens.matched.start\n            expressions = [self.expression()]\n\n            while self.tokens.accept(common_grammar.comma):\n                expressions.append(self.expression())\n\n            self.tokens.expect(common_grammar.rparen)\n\n            if len(expressions) == 1:\n                return expressions[0]\n            else:\n                return ast.Repeat(*expressions, source=self.original,\n                                  start=start, end=self.tokens.matched.end)\n\n        if self.tokens.accept(common_grammar.lbracket):\n            return self.list()\n\n        # We've run out of things we know the next atom could be. If there is\n        # still input left then it's illegal syntax. If there is nothing then\n        # the input cuts off when we still need an atom. Either is an error.\n        if self.tokens.peek(0):\n            return self.error(\n                \"Was not expecting %r here.\" % self.tokens.peek(0).name,\n                start_token=self.tokens.peek(0))\n        else:\n            return self.error(\"Unexpected end of input.\")", "response": "Parse an atom and return a new ast. Atom node."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef accept_operator(self, precedence):\n        match = grammar.infix(self.tokens)\n        if not match:\n            return\n\n        if match.operator.precedence < precedence:\n            return\n\n        # The next thing is an operator that we want. Now match it for real.\n        return self.tokens.accept(grammar.infix)", "response": "Accept the next binary operator only if it s of higher precedence."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nclimbs operator precedence as long as there are operators. This function implements a basic precedence climbing parser to deal with binary operators in a sane fashion. The outer loop will keep spinning as long as the next token is an operator with a precedence of at least 'min_precedence', parsing operands as atoms (which, in turn, recurse into 'expression' which recurses back into 'operator'). This supports both left- and right-associativity. The only part of the code that's not a regular precedence-climber deals with mixfix operators. A mixfix operator in DottySQL consists of an infix part and a suffix (they are still binary, they just have a terminator).", "response": "def operator(self, lhs, min_precedence):\n        \"\"\"Climb operator precedence as long as there are operators.\n\n        This function implements a basic precedence climbing parser to deal\n        with binary operators in a sane fashion. The outer loop will keep\n        spinning as long as the next token is an operator with a precedence\n        of at least 'min_precedence', parsing operands as atoms (which,\n        in turn, recurse into 'expression' which recurses back into 'operator').\n\n        This supports both left- and right-associativity. The only part of the\n        code that's not a regular precedence-climber deals with mixfix\n        operators. A mixfix operator in DottySQL consists of an infix part\n        and a suffix (they are still binary, they just have a terminator).\n        \"\"\"\n\n        # Spin as long as the next token is an operator of higher\n        # precedence. (This may not do anything, which is fine.)\n        while self.accept_operator(precedence=min_precedence):\n            operator = self.tokens.matched.operator\n\n            # If we're parsing a mixfix operator we can keep going until\n            # the suffix.\n            if operator.suffix:\n                rhs = self.expression()\n                self.tokens.expect(common_grammar.match_tokens(operator.suffix))\n                rhs.end = self.tokens.matched.end\n            elif operator.name == \".\":\n                # The dot operator changes the meaning of RHS.\n                rhs = self.dot_rhs()\n            else:\n                # The right hand side is an atom, which might turn out to be\n                # an expression. Isn't recursion exciting?\n                rhs = self.atom()\n\n            # Keep going as long as the next token is an infix operator of\n            # higher precedence.\n            next_min_precedence = operator.precedence\n            if operator.assoc == \"left\":\n                next_min_precedence += 1\n\n            while self.tokens.match(grammar.infix):\n                if (self.tokens.matched.operator.precedence\n                        < next_min_precedence):\n                    break\n                rhs = self.operator(rhs,\n                                    self.tokens.matched.operator.precedence)\n\n            lhs = operator.handler(lhs, rhs, start=lhs.start, end=rhs.end,\n                                   source=self.original)\n\n        return lhs"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nmatch the right - hand side of a dot (. ) operator. The RHS must be a symbol token but it is interpreted as a literal string.", "response": "def dot_rhs(self):\n        \"\"\"Match the right-hand side of a dot (.) operator.\n\n        The RHS must be a symbol token, but it is interpreted as a literal\n        string (because that's what goes in the AST of Resolve.)\n        \"\"\"\n        self.tokens.expect(common_grammar.symbol)\n        return ast.Literal(self.tokens.matched.value,\n                           start=self.tokens.matched.start,\n                           end=self.tokens.matched.end, source=self.original)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef select(self):\n        # Try to match the asterisk, any or list of vars.\n        if self.tokens.accept(grammar.select_any):\n            return self.select_any()\n\n        if self.tokens.accept(grammar.select_all):\n            # The FROM after SELECT * is required.\n            self.tokens.expect(grammar.select_from)\n            return self.select_from()\n\n        return self.select_what()", "response": "First part of an SQL query."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _guess_name_of(self, expr):\n        if isinstance(expr, ast.Var):\n            return expr.value\n\n        if isinstance(expr, ast.Resolve):\n            # We know the RHS of resolve is a Literal because that's what\n            # Parser.dot_rhs does.\n            return expr.rhs.value\n\n        if isinstance(expr, ast.Select) and isinstance(expr.rhs, ast.Literal):\n            name = self._guess_name_of(expr.lhs)\n            if name is not None:\n                return \"%s_%s\" % (name, expr.rhs.value)\n\n        if isinstance(expr, ast.Apply) and isinstance(expr.func, ast.Var):\n            return expr.func.value", "response": "Tries to guess what variable name expr ends in.\n           "}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef select_limit(self, source_expression):\n        start = self.tokens.matched.start\n\n        # The expression right after LIMIT is the count to take.\n        limit_count_expression = self.expression()\n\n        # Optional OFFSET follows.\n        if self.tokens.accept(grammar.select_offset):\n            offset_start = self.tokens.matched.start\n            offset_end = self.tokens.matched.end\n\n            # Next thing is the count to drop.\n            offset_count_expression = self.expression()\n\n            # We have a new source expression, which is drop(count, original).\n            offset_source_expression = ast.Apply(\n                ast.Var(\"drop\", start=offset_start, end=offset_end,\n                        source=self.original),\n                offset_count_expression,\n                source_expression,\n                start=offset_start, end=offset_count_expression.end,\n                source=self.original)\n\n            # Drop before taking, because obviously.\n            source_expression = offset_source_expression\n\n        limit_expression = ast.Apply(\n            ast.Var(\"take\", start=start, end=limit_count_expression.end,\n                    source=self.original),\n            limit_count_expression,\n            source_expression,\n            start=start, end=self.tokens.matched.end, source=self.original)\n\n        return limit_expression", "response": "Match LIMIT take and drop."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef builtin(self, keyword):\n        # The match includes the lparen token, so the keyword is just the first\n        # token in the match, not the whole thing.\n        keyword_start = self.tokens.matched.first.start\n        keyword_end = self.tokens.matched.first.end\n        self.tokens.expect(common_grammar.lparen)\n\n        if self.tokens.matched.start != keyword_end:\n            return self.error(\n                \"No whitespace allowed between function and lparen.\",\n                start_token=self.tokens.matched.first)\n\n        expr_type = grammar.BUILTINS[keyword.lower()]\n        arguments = [self.expression()]\n        while self.tokens.accept(common_grammar.comma):\n            arguments.append(self.expression())\n\n        self.tokens.expect(common_grammar.rparen)\n\n        if expr_type.arity and expr_type.arity != len(arguments):\n            return self.error(\n                \"%s expects %d arguments, but was passed %d.\" % (\n                    keyword, expr_type.arity, len(arguments)),\n                start_token=self.tokens.matched.first)\n\n        return expr_type(*arguments, start=keyword_start,\n                         end=self.tokens.matched.end, source=self.original)", "response": "Parse the pseudo - function application subgrammar."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef application(self, func):\n        start = self.tokens.matched.start\n        if self.tokens.accept(common_grammar.rparen):\n            # That was easy.\n            return ast.Apply(func, start=start, end=self.tokens.matched.end,\n                             source=self.original)\n\n        arguments = [self.expression()]\n        while self.tokens.accept(common_grammar.comma):\n            arguments.append(self.expression())\n\n        self.tokens.expect(common_grammar.rparen)\n        return ast.Apply(func, *arguments, start=start,\n                         end=self.tokens.matched.end, source=self.original)", "response": "Parse the function application subgrammar."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef list(self):\n        start = self.tokens.matched.start\n\n        if self.tokens.accept(common_grammar.rbracket):\n            return ast.Tuple(start=start, end=self.tokens.matched.end,\n                             source=self.original)\n\n        elements = [self.expression()]\n\n        while self.tokens.accept(common_grammar.comma):\n            elements.append(self.expression())\n\n        self.tokens.expect(common_grammar.rbracket)\n        return ast.Tuple(*elements, start=start, end=self.tokens.matched.end,\n                         source=self.original)", "response": "Parse a list ( tuple which can contain any combination of types."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_singleton(self):\n        only_value = None\n        for value in six.itervalues(self.ordered_dict):\n            # This loop will raise if it runs more than once.\n            if only_value is not None:\n                raise ValueError(\"%r is not a singleton.\" % self)\n\n            only_value = value\n\n        if only_value is self.__UnsetSentinel or only_value is None:\n            raise ValueError(\"%r is empty.\" % self)\n\n        return only_value", "response": "Returns the singleton value of the entry in the row."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn True if the object obj implements the specified protocol.", "response": "def implements(obj, protocol):\n    \"\"\"Does the object 'obj' implement the 'prococol'?\"\"\"\n    if isinstance(obj, type):\n        raise TypeError(\"First argument to implements must be an instance. \"\n                        \"Got %r.\" % obj)\n    return isinstance(obj, protocol) or issubclass(AnyType, protocol)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef isa(cls, protocol):\n    if not isinstance(cls, type):\n        raise TypeError(\"First argument to isa must be a type. Got %s.\" %\n                        repr(cls))\n\n    if not isinstance(protocol, type):\n        raise TypeError((\"Second argument to isa must be a type or a Protocol. \"\n                         \"Got an instance of %r.\") % type(protocol))\n    return issubclass(cls, protocol) or issubclass(AnyType, protocol)", "response": "Checks if the given class participates in the given protocol."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef implemented(cls, for_type):\n\n        for function in cls.required():\n            if not function.implemented_for_type(for_type):\n                raise TypeError(\n                    \"%r doesn't implement %r so it cannot participate in \"\n                    \"the protocol %r.\" %\n                    (for_type, function.func.__name__, cls))\n\n        cls.register(for_type)", "response": "Assert that protocol cls is implemented for type for_type."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef __get_type_args(for_type=None, for_types=None):\n        if for_type:\n            if for_types:\n                raise ValueError(\"Cannot pass both for_type and for_types.\")\n            for_types = (for_type,)\n        elif for_types:\n            if not isinstance(for_types, tuple):\n                raise TypeError(\"for_types must be passed as a tuple of \"\n                                \"types (classes).\")\n        else:\n            raise ValueError(\"Must pass either for_type or for_types.\")\n\n        return for_types", "response": "Parse the arguments and return a tuple of types to implement for."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nbuild a function that calls the method func_name on objects and returns the result of calling the method with the same name as the contents of the obj parameter and the arguments from the args.", "response": "def _build_late_dispatcher(func_name):\n        \"\"\"Return a function that calls method 'func_name' on objects.\n\n        This is useful for building late-bound dynamic dispatch.\n\n        Arguments:\n            func_name: The name of the instance method that should be called.\n\n        Returns:\n            A function that takes an 'obj' parameter, followed by *args and\n            returns the result of calling the instance method with the same\n            name as the contents of 'func_name' on the 'obj' object with the\n            arguments from *args.\n        \"\"\"\n        def _late_dynamic_dispatcher(obj, *args):\n            method = getattr(obj, func_name, None)\n            if not callable(method):\n                raise NotImplementedError(\n                    \"Instance method %r is not implemented by %r.\" % (\n                        func_name, obj))\n\n            return method(*args)\n\n        return _late_dynamic_dispatcher"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nprovide protocol implementation for a type.", "response": "def implement(cls, implementations, for_type=None, for_types=None):\n        \"\"\"Provide protocol implementation for a type.\n\n        Register all implementations of multimethod functions in this\n        protocol and add the type into the abstract base class of the\n        protocol.\n\n        Arguments:\n            implementations: A dict of (function, implementation), where each\n                function is multimethod and each implementation is a callable.\n            for_type: The concrete type implementations apply to.\n            for_types: Same as for_type, but takes a tuple of types.\n\n            You may not supply both for_type and for_types for obvious reasons.\n\n        Raises:\n            ValueError for arguments.\n            TypeError if not all implementations are provided or if there\n                are issues related to polymorphism (e.g. attempting to\n                implement a non-multimethod function.\n        \"\"\"\n        for type_ in cls.__get_type_args(for_type, for_types):\n            cls._implement_for_type(for_type=type_,\n                                    implementations=implementations)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nparses one of the rules as either objectfilter or dottysql.", "response": "def _parse_query(self, source):\n        \"\"\"Parse one of the rules as either objectfilter or dottysql.\n\n        Example:\n            _parse_query(\"5 + 5\")\n            # Returns Sum(Literal(5), Literal(5))\n\n        Arguments:\n            source: A rule in either objectfilter or dottysql syntax.\n\n        Returns:\n            The AST to represent the rule.\n        \"\"\"\n        if self.OBJECTFILTER_WORDS.search(source):\n            syntax_ = \"objectfilter\"\n        else:\n            syntax_ = None  # Default it is.\n\n        return query.Query(source, syntax=syntax_)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _parse_tagfile(self):\n        rules = None\n        tag = None\n        for line in self.original:\n            match = self.TAG_DECL_LINE.match(line)\n            if match:\n                if tag and rules:\n                    yield tag, rules\n                rules = []\n                tag = match.group(1)\n                continue\n\n            match = self.TAG_RULE_LINE.match(line)\n            if match:\n                source = match.group(1)\n                rules.append(self._parse_query(source))", "response": "Parse the tagfile and yield tuples of tag_name list of rule ASTs."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nnormalize both sides but don t eliminate the expression.", "response": "def normalize(expr):\n    \"\"\"Normalize both sides, but don't eliminate the expression.\"\"\"\n    lhs = normalize(expr.lhs)\n    rhs = normalize(expr.rhs)\n    return type(expr)(lhs, rhs, start=lhs.start, end=rhs.end)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef normalize(expr):\n    args = [normalize(arg) for arg in expr.args]\n\n    return type(expr)(expr.func, *args, start=expr.start, end=expr.end)", "response": "No elimination but normalize arguments."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nnormalizing n - ary expressions and eliminate empty branches.", "response": "def normalize(expr):\n    \"\"\"Pass through n-ary expressions, and eliminate empty branches.\n\n    Variadic and binary expressions recursively visit all their children.\n\n    If all children are eliminated then the parent expression is also\n    eliminated:\n\n    (& [removed] [removed]) => [removed]\n\n    If only one child is left, it is promoted to replace the parent node:\n\n    (& True) => True\n    \"\"\"\n    children = []\n    for child in expr.children:\n        branch = normalize(child)\n        if branch is None:\n            continue\n\n        if type(branch) is type(expr):\n            children.extend(branch.children)\n        else:\n            children.append(branch)\n\n    if len(children) == 0:\n        return None\n\n    if len(children) == 1:\n        return children[0]\n\n    return type(expr)(*children, start=children[0].start,\n                      end=children[-1].end)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef dedupe(items):\n    seen = set()\n    for item in items:\n        if item not in seen:\n            yield item\n            seen.add(item)", "response": "Remove duplicates from a sequence of hashable items while maintaining\n    order."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a generator that yields datetime. datetime objects from the given date range.", "response": "def _date_range(self, granularity, since, to=None):\n        \"\"\"Returns a generator that yields ``datetime.datetime`` objects from\n        the ``since`` date until ``to`` (default: *now*).\n\n        * ``granularity`` -- The granularity at which the generated datetime\n          objects should be created: seconds, minutes, hourly, daily, weekly,\n          monthly, or yearly\n        * ``since`` -- a ``datetime.datetime`` object, from which we start\n          generating periods of time. This can also be ``None``, and will\n          default to the past 7 days if that's the case.\n        * ``to`` -- a ``datetime.datetime`` object, from which we start\n          generating periods of time. This can also be ``None``, and will\n          default to now if that's the case.\n\n        If ``granularity`` is one of daily, weekly, monthly, or yearly, this\n        function gives objects at the daily level.\n\n        If ``granularity`` is one of the following, the number of datetime\n        objects returned is capped, otherwise this code is really slow and\n        probably generates more data than we want:\n\n            * hourly: returns at most 720 values (~30 days)\n            * minutes: returns at most 480 values (8 hours)\n            * second: returns at most 300 values (5 minutes)\n\n        For example, if granularity is \"seconds\", we'll receive datetime\n        objects that differ by 1 second each.\n\n        \"\"\"\n        if since is None:\n            since = datetime.utcnow() - timedelta(days=7)  # Default to 7 days\n\n        if to is None:\n            to = datetime.utcnow()\n        elapsed = (to - since)\n\n        # Figure out how many units to generate for the elapsed time.\n        # I'm going to use `granularity` as a keyword parameter to timedelta,\n        # so I need to change the wording for hours and anything > days.\n        if granularity == \"seconds\":\n            units = elapsed.total_seconds()\n            units = 300 if units > 300 else units\n        elif granularity == \"minutes\":\n            units = elapsed.total_seconds() / 60\n            units = 480 if units > 480 else units\n        elif granularity == \"hourly\":\n            granularity = \"hours\"\n            units = elapsed.total_seconds() / 3600\n            units = 720 if units > 720 else units\n        else:\n            granularity = \"days\"\n            units = elapsed.days + 1\n\n        return (to - timedelta(**{granularity: u}) for u in range(int(units)))"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a set of the metric slugs for the given category", "response": "def _category_slugs(self, category):\n        \"\"\"Returns a set of the metric slugs for the given category\"\"\"\n        key = self._category_key(category)\n        slugs = self.r.smembers(key)\n        return slugs"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _categorize(self, slug, category):\n        key = self._category_key(category)\n        self.r.sadd(key, slug)\n\n        # Store all category names in a Redis set, for easy retrieval\n        self.r.sadd(self._categories_key, category)", "response": "Add the slug to the category."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a generator of all possible granularities based on the MIN_GRANULARITY and MAX_GRANULARITY settings.", "response": "def _granularities(self):\n        \"\"\"Returns a generator of all possible granularities based on the\n        MIN_GRANULARITY and MAX_GRANULARITY settings.\n        \"\"\"\n        keep = False\n        for g in GRANULARITIES:\n            if g == app_settings.MIN_GRANULARITY and not keep:\n                keep = True\n            elif g == app_settings.MAX_GRANULARITY and keep:\n                keep = False\n                yield g\n            if keep:\n                yield g"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nbuilds an OrderedDict of metric keys and patterns for the given slug and date.", "response": "def _build_key_patterns(self, slug, date):\n        \"\"\"Builds an OrderedDict of metric keys and patterns for the given slug\n        and date.\"\"\"\n        # we want to keep the order, from smallest to largest granularity\n        patts = OrderedDict()\n        metric_key_patterns = self._metric_key_patterns()\n        for g in self._granularities():\n            date_string = date.strftime(metric_key_patterns[g][\"date_format\"])\n            patts[g] = metric_key_patterns[g][\"key\"].format(slug, date_string)\n        return patts"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nbuilds the redis keys used to store metrics.", "response": "def _build_keys(self, slug, date=None, granularity='all'):\n        \"\"\"Builds redis keys used to store metrics.\n\n        * ``slug`` -- a slug used for a metric, e.g. \"user-signups\"\n        * ``date`` -- (optional) A ``datetime.datetime`` object used to\n          generate the time period for the metric. If omitted, the current date\n          and time (in UTC) will be used.\n        * ``granularity`` -- Must be one of: \"all\" (default), \"yearly\",\n        \"monthly\", \"weekly\", \"daily\", \"hourly\", \"minutes\", or \"seconds\".\n\n        Returns a list of strings.\n\n        \"\"\"\n        slug = slugify(slug)  # Ensure slugs have a consistent format\n        if date is None:\n            date = datetime.utcnow()\n        patts = self._build_key_patterns(slug, date)\n        if granularity == \"all\":\n            return list(patts.values())\n        return [patts[granularity]]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a dictionary of metrics data indexed by category.", "response": "def metric_slugs_by_category(self):\n        \"\"\"Return a dictionary of metrics data indexed by category:\n\n            {<category_name>: set(<slug1>, <slug2>, ...)}\n\n        \"\"\"\n        result = OrderedDict()\n        categories = sorted(self.r.smembers(self._categories_key))\n        for category in categories:\n            result[category] = self._category_slugs(category)\n\n        # We also need to see the uncategorized metric slugs, so need some way\n        # to check which slugs are not already stored.\n        categorized_metrics = set([  # Flatten the list of metrics\n            slug for sublist in result.values() for slug in sublist\n        ])\n        f = lambda slug: slug not in categorized_metrics\n        uncategorized = list(set(filter(f, self.metric_slugs())))\n        if len(uncategorized) > 0:\n            result['Uncategorized'] = uncategorized\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nremoves all keys for the given slug from the set of available metrics.", "response": "def delete_metric(self, slug):\n        \"\"\"Removes all keys for the given ``slug``.\"\"\"\n\n        # To remove all keys for a slug, I need to retrieve them all from\n        # the set of metric keys, This uses the redis \"keys\" command, which is\n        # inefficient, but this shouldn't be used all that often.\n        prefix = \"m:{0}:*\".format(slug)\n        keys = self.r.keys(prefix)\n        self.r.delete(*keys)  # Remove the metric data\n\n        # Finally, remove the slug from the set\n        self.r.srem(self._metric_slugs_key, slug)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef set_metric(self, slug, value, category=None, expire=None, date=None):\n        keys = self._build_keys(slug, date=date)\n\n        # Add the slug to the set of metric slugs\n        self.r.sadd(self._metric_slugs_key, slug)\n\n        # Construct a dictionary of key/values for use with mset\n        data = {}\n        for k in keys:\n            data[k] = value\n        self.r.mset(data)\n\n        # Add the category if applicable.\n        if category:\n            self._categorize(slug, category)\n\n        # Expire the Metric in ``expire`` seconds if applicable.\n        if expire:\n            for k in keys:\n                self.r.expire(k, expire)", "response": "Assigns a specific value to the current metric."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef metric(self, slug, num=1, category=None, expire=None, date=None):\n        # Add the slug to the set of metric slugs\n        self.r.sadd(self._metric_slugs_key, slug)\n\n        if category:\n            self._categorize(slug, category)\n\n        # Increment keys. NOTE: current redis-py (2.7.2) doesn't include an\n        # incrby method; .incr accepts a second ``amount`` parameter.\n        keys = self._build_keys(slug, date=date)\n\n        # Use a pipeline to speed up incrementing multiple keys\n        pipe = self.r.pipeline()\n        for key in keys:\n            pipe.incr(key, num)\n            if expire:\n                pipe.expire(key, expire)\n        pipe.execute()", "response": "Records a metric in Redis."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget the current values for a metric.", "response": "def get_metric(self, slug):\n        \"\"\"Get the current values for a metric.\n\n        Returns a dictionary with metric values accumulated for the seconds,\n        minutes, hours, day, week, month, and year.\n\n        \"\"\"\n        results = OrderedDict()\n        granularities = self._granularities()\n        keys = self._build_keys(slug)\n        for granularity, key in zip(granularities, keys):\n            results[granularity] = self.r.get(key)\n        return results"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_metrics(self, slug_list):\n        # meh. I should have been consistent here, but I'm lazy, so support these\n        # value names instead of granularity names, but respect the min/max\n        # granularity settings.\n        keys = ['seconds', 'minutes', 'hours', 'day', 'week', 'month', 'year']\n        key_mapping = {gran: key for gran, key in zip(GRANULARITIES, keys)}\n        keys = [key_mapping[gran] for gran in self._granularities()]\n\n        results = []\n        for slug in slug_list:\n            metrics = self.r.mget(*self._build_keys(slug))\n            if any(metrics):  # Only if we have data.\n                results.append((slug, dict(zip(keys, metrics))))\n        return results", "response": "Get the metrics for multiple slugs."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_category_metrics(self, category):\n        slug_list = self._category_slugs(category)\n        return self.get_metrics(slug_list)", "response": "Get the metrics belonging to the given category"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nremoving the category from Redis. This doesn t touch the metrics ; they simply become uncategorized.", "response": "def delete_category(self, category):\n        \"\"\"Removes the category from Redis. This doesn't touch the metrics;\n        they simply become uncategorized.\"\"\"\n        # Remove mapping of metrics-to-category\n        category_key = self._category_key(category)\n        self.r.delete(category_key)\n\n        # Remove category from Set\n        self.r.srem(self._categories_key, category)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef reset_category(self, category, metric_slugs):\n        key = self._category_key(category)\n        if len(metric_slugs) == 0:\n            # If there are no metrics, just remove the category\n            self.delete_category(category)\n        else:\n            # Save all the slugs in the category, and save the category name\n            self.r.sadd(key, *metric_slugs)\n            self.r.sadd(self._categories_key, category)", "response": "Resets or creates a category containing a list of metrics."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget the history for one or more metrics.", "response": "def get_metric_history(self, slugs, since=None, to=None, granularity='daily'):\n        \"\"\"Get history for one or more metrics.\n\n        * ``slugs`` -- a slug OR a list of slugs\n        * ``since`` -- the date from which we start pulling metrics\n        * ``to`` -- the date until which we start pulling metrics\n        * ``granularity`` -- seconds, minutes, hourly,\n                             daily, weekly, monthly, yearly\n\n        Returns a list of tuples containing the Redis key and the associated\n        metric::\n\n            r = R()\n            r.get_metric_history('test', granularity='weekly')\n            [\n                ('m:test:w:2012-52', '15'),\n            ]\n\n        To get history for multiple metrics, just provide a list of slugs::\n\n            metrics = ['test', 'other']\n            r.get_metric_history(metrics, granularity='weekly')\n            [\n                ('m:test:w:2012-52', '15'),\n                ('m:other:w:2012-52', '42'),\n            ]\n\n        \"\"\"\n        if not type(slugs) == list:\n            slugs = [slugs]\n\n        # Build the set of Redis keys that we need to get.\n        keys = []\n        for slug in slugs:\n            for date in self._date_range(granularity, since, to):\n                keys += self._build_keys(slug, date, granularity)\n        keys = list(dedupe(keys))\n\n        # Fetch our data, replacing any None-values with zeros\n        results = [0 if v is None else v for v in self.r.mget(keys)]\n        results = zip(keys, results)\n        return sorted(results, key=lambda t: t[0])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a list of lists of all the keys in the system that are in the same format as the ones in the system.", "response": "def get_metric_history_as_columns(self, slugs, since=None,\n                                      granularity='daily'):\n        \"\"\"Provides the same data as ``get_metric_history``, but in a columnar\n        format. If you had the following yearly history, for example::\n\n            [\n                ('m:bar:y:2012', '1'),\n                ('m:bar:y:2013', '2'),\n                ('m:foo:y:2012', '3'),\n                ('m:foo:y:2013', '4')\n            ]\n\n        this method would provide you with the following data structure::\n\n            [\n                ['Period',  'bar',  'foo']\n                ['y:2012',  '1',    '3'],\n                ['y:2013',  '2',    '4'],\n            ]\n\n        Note that this also includes a header column. Data in this format may\n        be useful for certain graphing libraries (I'm looking at you Google\n        Charts LineChart).\n\n        \"\"\"\n        history = self.get_metric_history(slugs, since, granularity=granularity)\n        _history = []  # new, columnar history\n        periods = ['Period']  # A separate, single column for the time period\n        for s in slugs:\n            column = [s]  # story all the data for a single slug\n            for key, value in history:\n                # ``metric_slug`` extracts the slug from the Redis Key\n                if template_tags.metric_slug(key) == s:\n                    column.append(value)\n\n                # Get time period value as first column; This value is\n                # duplicated in the Redis key for each value, so this is a bit\n                # inefficient, but... oh well.\n                period = template_tags.strip_metric_prefix(key)\n                if period not in periods:\n                    periods.append(period)\n\n            _history.append(column)  # Remember that slug's column of data\n\n        # Finally, stick the time periods in the first column.\n        _history.insert(0, periods)\n        return list(zip(*_history))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a dict that can be used to plot the metrics for a specific set of slugs.", "response": "def get_metric_history_chart_data(self, slugs, since=None, granularity='daily'):\n        \"\"\"Provides the same data as ``get_metric_history``, but with metrics\n        data arranged in a format that's easy to plot with Chart.js. If you had\n        the following yearly history, for example::\n\n            [\n                ('m:bar:y:2012', '1'),\n                ('m:bar:y:2013', '2'),\n                ('m:bar:y:2014', '3'),\n                ('m:foo:y:2012', '4'),\n                ('m:foo:y:2013', '5')\n                ('m:foo:y:2014', '6')\n            ]\n\n        this method would provide you with the following data structure::\n\n            'periods': ['y:2012', 'y:2013', 'y:2014']\n            'data': [\n              {\n                'slug': 'bar',\n                'values': [1, 2, 3]\n              },\n              {\n                'slug': 'foo',\n                'values': [4, 5, 6]\n              },\n            ]\n\n        \"\"\"\n        slugs = sorted(slugs)\n        history = self.get_metric_history(slugs, since, granularity=granularity)\n\n        # Convert the history into an intermediate data structure organized\n        # by periods. Since the history is sorted by key (which includes both\n        # the slug and the date, the values should be ordered correctly.\n        periods = []\n        data = OrderedDict()\n        for k, v in history:\n            period = template_tags.strip_metric_prefix(k)\n            if period not in periods:\n                periods.append(period)\n\n            slug = template_tags.metric_slug(k)\n            if slug not in data:\n                data[slug] = []\n            data[slug].append(v)\n\n        # Now, reorganize data for our end result.\n        metrics = {'periods': periods, 'data': []}\n        for slug, values in data.items():\n            metrics['data'].append({\n                'slug': slug,\n                'values': values\n            })\n\n        return metrics"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef gauge(self, slug, current_value):\n        k = self._gauge_key(slug)\n        self.r.sadd(self._gauge_slugs_key, slug)  # keep track of all Gauges\n        self.r.set(k, current_value)", "response": "Set the value for a Gauge."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nremoving all gauges with the given slug.", "response": "def delete_gauge(self, slug):\n        \"\"\"Removes all gauges with the given ``slug``.\"\"\"\n        key = self._gauge_key(slug)\n        self.r.delete(key)  # Remove the Gauge\n        self.r.srem(self._gauge_slugs_key, slug)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nrendering a template with a menu to view a metric or metrics for a given number of years.", "response": "def metrics_since(slugs, years, link_type=\"detail\", granularity=None):\n    \"\"\"Renders a template with a menu to view a metric (or metrics) for a\n    given number of years.\n\n    * ``slugs`` -- A Slug or a set/list of slugs\n    * ``years`` -- Number of years to show past metrics\n    * ``link_type`` -- What type of chart do we want (\"history\" or \"aggregate\")\n        * history  -- use when displaying a single metric's history\n        * aggregate -- use when displaying aggregate metric history\n    * ``granularity`` -- For \"history\" only; show the metric's granularity;\n      default is \"daily\"\n\n    \"\"\"\n    now = datetime.utcnow()\n\n    # Determine if we're looking at one slug or multiple slugs\n    if type(slugs) in [list, set]:\n        slugs = \"+\".join(s.lower().strip() for s in slugs)\n\n    # Set the default granularity if it's omitted\n    granularity = granularity.lower().strip() if granularity else \"daily\"\n\n    # Each item is: (slug, since, text, granularity)\n    # Always include values for Today, 1 week, 30 days, 60 days, 90 days...\n    slug_values = [\n        (slugs, now - timedelta(days=1), \"Today\", granularity),\n        (slugs, now - timedelta(days=7), \"1 Week\", granularity),\n        (slugs, now - timedelta(days=30), \"30 Days\", granularity),\n        (slugs, now - timedelta(days=60), \"60 Days\", granularity),\n        (slugs, now - timedelta(days=90), \"90 Days\", granularity),\n    ]\n\n    # Then an additional number of years\n    for y in range(1, years + 1):\n        t = now - timedelta(days=365 * y)\n        text = \"{0} Years\".format(y)\n        slug_values.append((slugs, t, text, granularity))\n    return {'slug_values': slug_values, 'link_type': link_type.lower().strip()}"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ninclude a Donut Chart for the specified Gauge.", "response": "def gauge(slug, maximum=9000, size=200, coerce='float'):\n    \"\"\"Include a Donut Chart for the specified Gauge.\n\n    * ``slug`` -- the unique slug for the Gauge.\n    * ``maximum`` -- The maximum value for the gauge (default is 9000)\n    * ``size`` -- The size (in pixels) of the gauge (default is 200)\n    * ``coerce`` -- type to which gauge values should be coerced. The default\n      is float. Use ``{% gauge some_slug coerce='int' %}`` to coerce to integer\n\n    \"\"\"\n    coerce_options = {'float': float, 'int': int, 'str': str}\n    coerce = coerce_options.get(coerce, float)\n\n    redis = get_r()\n    value = coerce(redis.get_gauge(slug))\n    if value < maximum and coerce == float:\n        diff = round(maximum - value, 2)\n    elif value < maximum:\n        diff = maximum - value\n    else:\n        diff = 0\n\n    return {\n        'slug': slug,\n        'current_value': value,\n        'max_value': maximum,\n        'size': size,\n        'diff': diff,\n    }"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ntemplate Tag to display a metric s current detail.", "response": "def metric_detail(slug, with_data_table=False):\n    \"\"\"Template Tag to display a metric's *current* detail.\n\n    * ``slug`` -- the metric's unique slug\n    * ``with_data_table`` -- if True, prints the raw data in a table.\n\n    \"\"\"\n    r = get_r()\n    granularities = list(r._granularities())\n    metrics = r.get_metric(slug)\n    metrics_data = []\n    for g in granularities:\n        metrics_data.append((g, metrics[g]))\n\n    return {\n        'granularities': [g.title() for g in granularities],\n        'slug': slug,\n        'metrics': metrics_data,\n        'with_data_table': with_data_table,\n    }"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef metric_history(slug, granularity=\"daily\", since=None, to=None,\n                   with_data_table=False):\n    \"\"\"Template Tag to display a metric's history.\n\n    * ``slug`` -- the metric's unique slug\n    * ``granularity`` -- the granularity: daily, hourly, weekly, monthly, yearly\n    * ``since`` -- a datetime object or a string string matching one of the\n      following patterns: \"YYYY-mm-dd\" for a date or \"YYYY-mm-dd HH:MM:SS\" for\n      a date & time.\n    * ``to`` -- the date until which we start pulling metrics\n    * ``with_data_table`` -- if True, prints the raw data in a table.\n\n    \"\"\"\n    r = get_r()\n    try:\n        if since and len(since) == 10:  # yyyy-mm-dd\n            since = datetime.strptime(since, \"%Y-%m-%d\")\n        elif since and len(since) == 19:  # yyyy-mm-dd HH:MM:ss\n            since = datetime.strptime(since, \"%Y-%m-%d %H:%M:%S\")\n\n        if to and len(to) == 10:  # yyyy-mm-dd\n            to = datetime.strptime(since, \"%Y-%m-%d\")\n        elif to and len(to) == 19:  # yyyy-mm-dd HH:MM:ss\n            to = datetime.strptime(to, \"%Y-%m-%d %H:%M:%S\")\n\n    except (TypeError, ValueError):\n        # assume we got a datetime object or leave since = None\n        pass\n\n    metric_history = r.get_metric_history(\n        slugs=slug,\n        since=since,\n        to=to,\n        granularity=granularity\n    )\n\n    return {\n        'since': since,\n        'to': to,\n        'slug': slug,\n        'granularity': granularity,\n        'metric_history': metric_history,\n        'with_data_table': with_data_table,\n    }", "response": "Return a template tag that displays a metric s history."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a dict that can be used to display multiple metrics in a single page.", "response": "def aggregate_detail(slug_list, with_data_table=False):\n    \"\"\"Template Tag to display multiple metrics.\n\n    * ``slug_list`` -- A list of slugs to display\n    * ``with_data_table`` -- if True, prints the raw data in a table.\n\n    \"\"\"\n    r = get_r()\n    metrics_data = []\n    granularities = r._granularities()\n\n    # XXX converting granularties into their key-name for metrics.\n    keys = ['seconds', 'minutes', 'hours', 'day', 'week', 'month', 'year']\n    key_mapping = {gran: key for gran, key in zip(GRANULARITIES, keys)}\n    keys = [key_mapping[gran] for gran in granularities]\n\n    # Our metrics data is of the form:\n    #\n    #   (slug, {time_period: value, ... }).\n    #\n    # Let's convert this to (slug, list_of_values) so that the list of\n    # values is in the same order as the granularties\n    for slug, data in r.get_metrics(slug_list):\n        values = [data[t] for t in keys]\n        metrics_data.append((slug, values))\n\n    return {\n        'chart_id': \"metric-aggregate-{0}\".format(\"-\".join(slug_list)),\n        'slugs': slug_list,\n        'metrics': metrics_data,\n        'with_data_table': with_data_table,\n        'granularities': [g.title() for g in keys],\n    }"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a dictionary of data for the given list of metric slugs.", "response": "def aggregate_history(slugs, granularity=\"daily\", since=None, with_data_table=False):\n    \"\"\"Template Tag to display history for multiple metrics.\n\n    * ``slug_list`` -- A list of slugs to display\n    * ``granularity`` -- the granularity: seconds, minutes, hourly,\n                         daily, weekly, monthly, yearly\n    * ``since`` -- a datetime object or a string string matching one of the\n      following patterns: \"YYYY-mm-dd\" for a date or \"YYYY-mm-dd HH:MM:SS\" for\n      a date & time.\n    * ``with_data_table`` -- if True, prints the raw data in a table.\n\n    \"\"\"\n    r = get_r()\n    slugs = list(slugs)\n\n    try:\n        if since and len(since) == 10:  # yyyy-mm-dd\n            since = datetime.strptime(since, \"%Y-%m-%d\")\n        elif since and len(since) == 19:  # yyyy-mm-dd HH:MM:ss\n            since = datetime.strptime(since, \"%Y-%m-%d %H:%M:%S\")\n    except (TypeError, ValueError):\n        # assume we got a datetime object or leave since = None\n        pass\n\n    history = r.get_metric_history_chart_data(\n        slugs=slugs,\n        since=since,\n        granularity=granularity\n    )\n\n    return {\n        'chart_id': \"metric-aggregate-history-{0}\".format(\"-\".join(slugs)),\n        'slugs': slugs,\n        'since': since,\n        'granularity': granularity,\n        'metric_history': history,\n        'with_data_table': with_data_table,\n    }"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef user_func(func, arg_types=None, return_type=None):\n    class UserFunction(std_core.TypedFunction):\n        name = func.__name__\n\n        def __call__(self, *args, **kwargs):\n            return func(*args, **kwargs)\n\n        @classmethod\n        def reflect_static_args(cls):\n            return arg_types\n\n        @classmethod\n        def reflect_static_return(cls):\n            return return_type\n\n    return UserFunction()", "response": "Create an EFILTER - callable version of function func."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef infer(query, replacements=None, root_type=None,\n          libs=(\"stdcore\", \"stdmath\")):\n    \"\"\"Determine the type of the query's output without actually running it.\n\n    Arguments:\n        query: A query object or string with the query.\n        replacements: Built-time parameters to the query, either as dict or as\n            an array (for positional interpolation).\n        root_type: The types of variables to be supplied to the query inference.\n        libs: What standard libraries should be taken into account for the\n            inference.\n\n    Returns:\n        The type of the query's output, if it can be determined. If undecidable,\n        returns efilter.protocol.AnyType.\n\n        NOTE: The inference returns the type of a row in the results, not of the\n        actual Python object returned by 'apply'. For example, if a query\n        returns multiple rows, each one of which is an integer, the type of the\n        output is considered to be int, not a collection of rows.\n\n    Examples:\n        infer(\"5 + 5\") # -> INumber\n\n        infer(\"SELECT * FROM people WHERE age > 10\") # -> AnyType\n\n        # If root_type implements the IStructured reflection API:\n        infer(\"SELECT * FROM people WHERE age > 10\", root_type=...) # -> dict\n    \"\"\"\n    # Always make the scope stack start with stdcore.\n    if root_type:\n        type_scope = scope.ScopeStack(std_core.MODULE, root_type)\n    else:\n        type_scope = scope.ScopeStack(std_core.MODULE)\n\n    stdcore_included = False\n    for lib in libs:\n        if lib == \"stdcore\":\n            stdcore_included = True\n            continue\n\n        module = std_core.LibraryModule.ALL_MODULES.get(lib)\n        if not module:\n            raise TypeError(\"No standard library module %r.\" % lib)\n\n        type_scope = scope.ScopeStack(module, type_scope)\n\n    if not stdcore_included:\n        raise TypeError(\"'stdcore' must always be included.\")\n\n    query = q.Query(query, params=replacements)\n    return infer_type.infer_type(query, type_scope)", "response": "Infer the type of the query s output without actually running it."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nyielding objects from data that match the query.", "response": "def search(query, data, replacements=None):\n    \"\"\"Yield objects from 'data' that match the 'query'.\"\"\"\n    query = q.Query(query, params=replacements)\n    for entry in data:\n        if solve.solve(query, entry).value:\n            yield entry"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef peek(self, steps=1):\n        try:\n            tokens = iter(self)\n            for _ in six.moves.range(steps):\n                next(tokens)\n\n            return next(tokens)\n        except StopIteration:\n            return None", "response": "Look ahead and return the next token."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nskipping ahead by steps tokens.", "response": "def skip(self, steps=1):\n        \"\"\"Skip ahead by 'steps' tokens.\"\"\"\n        for _ in six.moves.range(steps):\n            self.next_token()"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef next_token(self):\n        if self.lookahead:\n            self.current_token = self.lookahead.popleft()\n            return self.current_token\n\n        self.current_token = self._parse_next_token()\n        return self.current_token", "response": "Returns the next logical token advancing the tokenizer."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _next_pattern(self):\n        current_state = self.state_stack[-1]\n        position = self._position\n        for pattern in self.patterns:\n            if current_state not in pattern.states:\n                continue\n\n            m = pattern.regex.match(self.source, position)\n            if not m:\n                continue\n\n            position = m.end()\n            token = None\n\n            if pattern.next_state:\n                self.state_stack.append(pattern.next_state)\n\n            if pattern.action:\n                callback = getattr(self, pattern.action, None)\n                if callback is None:\n                    raise RuntimeError(\n                        \"No method defined for pattern action %s!\" %\n                        pattern.action)\n\n                if \"token\" in m.groups():\n                    value = m.group(\"token\")\n                else:\n                    value = m.group(0)\n                token = callback(string=value, match=m,\n                                 pattern=pattern)\n\n            self._position = position\n\n            return token\n\n        self._error(\"Don't know how to match next. Did you forget quotes?\",\n                    start=self._position, end=self._position + 1)", "response": "Parses the next pattern by matching each in turn."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _error(self, message, start, end=None):\n        raise errors.EfilterParseError(\n            source=self.source, start=start, end=end, message=message)", "response": "Raise a nice error with the token highlighted."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef emit(self, string, match, pattern, **_):\n        return grammar.Token(name=pattern.name, value=string,\n                             start=match.start(), end=match.end())", "response": "Emits a token using the current pattern match and pattern label."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting version string by parsing PKG - INFO file.", "response": "def get_pkg_version():\n    \"\"\"Get version string by parsing PKG-INFO.\"\"\"\n    try:\n        with open(\"PKG-INFO\", \"r\") as fp:\n            rgx = re.compile(r\"Version: (\\d+)\")\n            for line in fp.readlines():\n                match = rgx.match(line)\n                if match:\n                    return match.group(1)\n    except IOError:\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngenerating a version string from git commits.", "response": "def get_version(dev_version=False):\n    \"\"\"Generates a version string.\n\n    Arguments:\n        dev_version: Generate a verbose development version from git commits.\n\n    Examples:\n        1.1\n        1.1.dev43 # If 'dev_version' was passed.\n    \"\"\"\n    if dev_version:\n        version = git_dev_version()\n        if not version:\n            raise RuntimeError(\"Could not generate dev version from git.\")\n\n        return version\n\n    return \"1!%d.%d\" % (MAJOR, MINOR)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _heartbeat(self):\n\n        try:\n\n            self._prof.prof('heartbeat thread started', uid=self._uid)\n\n            mq_connection = pika.BlockingConnection(pika.ConnectionParameters(host=self._mq_hostname, port=self._port))\n            mq_channel = mq_connection.channel()\n\n            response = True\n            while (response and (not self._hb_terminate.is_set())):\n                response = False\n                corr_id = str(uuid.uuid4())\n\n                # Heartbeat request signal sent to task manager via rpc-queue\n                mq_channel.basic_publish(exchange='',\n                                         routing_key=self._hb_request_q,\n                                         properties=pika.BasicProperties(\n                                             reply_to=self._hb_response_q,\n                                             correlation_id=corr_id),\n                                         body='request')\n                self._logger.info('Sent heartbeat request')\n\n                # mq_connection.close()\n\n                # Sleep for hb_interval and then check if tmgr responded\n                mq_connection.sleep(self._hb_interval)\n\n                # mq_connection = pika.BlockingConnection(\n                #     pika.ConnectionParameters(host=self._mq_hostname, port=self._port))\n                # mq_channel = mq_connection.channel()\n\n                method_frame, props, body = mq_channel.basic_get(queue=self._hb_response_q)\n\n                if body:\n                    if corr_id == props.correlation_id:\n                        self._logger.info('Received heartbeat response')\n                        response = True\n\n                        mq_channel.basic_ack(delivery_tag=method_frame.delivery_tag)\n\n                # Appease pika cos it thinks the connection is dead\n                # mq_connection.close()\n\n        except KeyboardInterrupt:\n            self._logger.exception('Execution interrupted by user (you probably hit Ctrl+C), ' +\n                               'trying to cancel tmgr process gracefully...')\n            raise KeyboardInterrupt\n\n        except Exception as ex:\n            self._logger.exception('Heartbeat failed with error: %s' % ex)\n            raise\n\n        finally:\n\n            try:\n                mq_connection.close()\n            except:\n                self._logger.warning('mq_connection not created')\n\n            self._prof.prof('terminating heartbeat thread', uid=self._uid)", "response": "This method is executed in the heartbeat thread. It sends a request to the heartbeat - req queue and receives a response from the heartbeat - res queue."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef start_heartbeat(self):\n\n        if not self._hb_thread:\n\n            try:\n\n                self._logger.info('Starting heartbeat thread')\n                self._prof.prof('creating heartbeat thread', uid=self._uid)\n                self._hb_terminate = threading.Event()\n                self._hb_thread = threading.Thread(target=self._heartbeat, name='heartbeat')\n\n                self._prof.prof('starting heartbeat thread', uid=self._uid)\n                self._hb_thread.start()\n\n                return True\n\n            except Exception, ex:\n\n                self._logger.exception('Heartbeat not started, error: %s' % ex)\n                self.terminate_heartbeat()\n                raise\n\n        else:\n            self._logger.warn('Heartbeat thread already running, but attempted to restart!')", "response": "Start the heartbeat thread."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef terminate_heartbeat(self):\n\n        try:\n\n            if self._hb_thread:\n\n                self._hb_terminate.set()\n\n                if self.check_heartbeat():\n                    self._hb_thread.join()\n\n                self._hb_thread = None\n\n                self._logger.info('Hearbeat thread terminated')\n\n                self._prof.prof('heartbeat thread terminated', uid=self._uid)\n\n                # We close in the heartbeat because it ends after the tmgr process\n                self._prof.close()\n\n        except Exception, ex:\n            self._logger.exception('Could not terminate heartbeat thread')\n            raise\n\n        finally:\n\n            if not (self.check_heartbeat() or self.check_manager()):\n\n                mq_connection = pika.BlockingConnection(pika.ConnectionParameters(host=self._mq_hostname, port=self._port))\n                mq_channel = mq_connection.channel()\n\n                # To respond to heartbeat - get request from rpc_queue\n                mq_channel.queue_delete(queue=self._hb_response_q)\n                mq_channel.queue_delete(queue=self._hb_request_q)\n\n                mq_connection.close()", "response": "This method terminate the heartbeat thread."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef terminate_manager(self):\n\n        try:\n\n            if self._tmgr_process:\n\n                if not self._tmgr_terminate.is_set():\n                    self._tmgr_terminate.set()\n\n                if self.check_manager():\n                    self._tmgr_process.join()\n\n                self._tmgr_process = None\n                self._logger.info('Task manager process closed')\n\n                self._prof.prof('tmgr process terminated', uid=self._uid)\n\n        except Exception, ex:\n            self._logger.exception('Could not terminate task manager process')\n            raise", "response": "Terminate the tmgr process."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef getvalues(self):\n        idx = 0\n        generator = self._generator_func()\n        first_value = next(generator)\n        self._value_type = type(first_value)\n        yield first_value\n\n        for idx, value in enumerate(generator):\n            if not isinstance(value, self._value_type):\n                raise TypeError(\n                    \"All values of a repeated var must be of the same type.\"\n                    \" First argument was of type %r, but argument %r is of\"\n                    \" type %r.\" %\n                    (self._value_type, value, repeated.value_type(value)))\n\n            self._watermark = max(self._watermark, idx + 1)\n            yield value\n\n        # Iteration stopped - check if we're at the previous watermark and raise\n        # if not.\n        if idx + 1 < self._watermark:\n            raise ValueError(\n                \"LazyRepetition %r was previously able to iterate its\"\n                \" generator up to idx %d, but this time iteration stopped after\"\n                \" idx %d! Generator function %r is not stable.\" %\n                (self, self._watermark, idx + 1, self._generator_func))\n\n        # Watermark is higher than previous count! Generator function returned\n        # more values this time than last time.\n        if self._count is not None and self._watermark >= self._count:\n            raise ValueError(\n                \"LazyRepetition %r previously iterated only up to idx %d but\"\n                \" was now able to reach idx %d! Generator function %r is not\"\n                \" stable.\" %\n                (self, self._count - 1, idx + 1, self._generator_func))\n\n        # We've finished iteration - cache count. After this the count will be\n        # watermark + 1 forever.\n        self._count = self._watermark + 1", "response": "Yields all the values from the generator_func and type - checks."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef value_eq(self, other):\n        self_sorted = ordered.ordered(self.getvalues())\n        other_sorted = ordered.ordered(repeated.getvalues(other))\n        return self_sorted == other_sorted", "response": "Sorted comparison of values."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nprints a detailed audit of all calls to this function.", "response": "def call_audit(func):\n    \"\"\"Print a detailed audit of all calls to this function.\"\"\"\n    def audited_func(*args, **kwargs):\n        import traceback\n        stack = traceback.extract_stack()\n        r = func(*args, **kwargs)\n        func_name = func.__name__\n\n        print(\"@depth %d, trace %s -> %s(*%r, **%r) => %r\" % (\n            len(stack),\n            \" -> \".join(\"%s:%d:%s\" % x[0:3] for x in stack[-5:-2]),\n            func_name,\n            args,\n            kwargs,\n            r))\n        return r\n\n    return audited_func"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef prefer_type(self, prefer, over):\n        self._write_lock.acquire()\n        try:\n            if self._preferred(preferred=over, over=prefer):\n                raise ValueError(\n                    \"Type %r is already preferred over %r.\" % (over, prefer))\n            prefs = self._prefer_table.setdefault(prefer, set())\n            prefs.add(over)\n        finally:\n            self._write_lock.release()", "response": "Prefer one type over another type."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nfind the best implementation of this function given a type.", "response": "def _find_and_cache_best_function(self, dispatch_type):\n        \"\"\"Finds the best implementation of this function given a type.\n\n        This function caches the result, and uses locking for thread safety.\n\n        Returns:\n            Implementing function, in below order of preference:\n            1. Explicitly registered implementations (through\n               multimethod.implement) for types that 'dispatch_type' either is\n               or inherits from directly.\n            2. Explicitly registered implementations accepting an abstract type\n               (interface) in which dispatch_type participates (through\n               abstract_type.register() or the convenience methods).\n            3. Default behavior of the multimethod function. This will usually\n               raise a NotImplementedError, by convention.\n\n        Raises:\n            TypeError: If two implementing functions are registered for\n                different abstract types, and 'dispatch_type' participates in\n                both, and no order of preference was specified using\n                prefer_type.\n        \"\"\"\n        result = self._dispatch_table.get(dispatch_type)\n        if result:\n            return result\n\n        # The outer try ensures the lock is always released.\n        with self._write_lock:\n            try:\n                dispatch_mro = dispatch_type.mro()\n            except TypeError:\n                # Not every type has an MRO.\n                dispatch_mro = ()\n\n            best_match = None\n            result_type = None\n\n            for candidate_type, candidate_func in self.implementations:\n                if not issubclass(dispatch_type, candidate_type):\n                    # Skip implementations that are obviously unrelated.\n                    continue\n\n                try:\n                    # The candidate implementation may be for a type that's\n                    # actually in the MRO, or it may be for an abstract type.\n                    match = dispatch_mro.index(candidate_type)\n                except ValueError:\n                    # This means we have an implementation for an abstract\n                    # type, which ranks below all concrete types.\n                    match = None\n\n                if best_match is None:\n                    if result and match is None:\n                        # Already have a result, and no order of preference.\n                        # This is probably because the type is a member of two\n                        # abstract types and we have separate implementations\n                        # for those two abstract types.\n\n                        if self._preferred(candidate_type, over=result_type):\n                            result = candidate_func\n                            result_type = candidate_type\n                        elif self._preferred(result_type, over=candidate_type):\n                            # No need to update anything.\n                            pass\n                        else:\n                            raise TypeError(\n                                \"Two candidate implementations found for \"\n                                \"multimethod function %s (dispatch type %s) \"\n                                \"and neither is preferred.\" %\n                                (self.func_name, dispatch_type))\n                    else:\n                        result = candidate_func\n                        result_type = candidate_type\n                        best_match = match\n\n                if (match or 0) < (best_match or 0):\n                    result = candidate_func\n                    result_type = candidate_type\n                    best_match = match\n\n            self._dispatch_table[dispatch_type] = result\n            return result"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nparsing the arguments and return a tuple of types to implement for.", "response": "def __get_types(for_type=None, for_types=None):\n        \"\"\"Parse the arguments and return a tuple of types to implement for.\n\n        Raises:\n            ValueError or TypeError as appropriate.\n        \"\"\"\n        if for_type:\n            if for_types:\n                raise ValueError(\"Cannot pass both for_type and for_types.\")\n            for_types = (for_type,)\n        elif for_types:\n            if not isinstance(for_types, tuple):\n                raise TypeError(\"for_types must be passed as a tuple of \"\n                                \"types (classes).\")\n        else:\n            raise ValueError(\"Must pass either for_type or for_types.\")\n\n        return for_types"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef implementation(self, for_type=None, for_types=None):\n        for_types = self.__get_types(for_type, for_types)\n\n        def _decorator(implementation):\n            self.implement(implementation, for_types=for_types)\n            return self\n\n        return _decorator", "response": "Returns a decorator that will register the implementation."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nregisters an implementation function for for_type.", "response": "def implement(self, implementation, for_type=None, for_types=None):\n        \"\"\"Registers an implementing function for for_type.\n\n        Arguments:\n            implementation: Callable implementation for this type.\n            for_type: The type this implementation applies to.\n            for_types: Same as for_type, but takes a tuple of types.\n\n            for_type and for_types cannot both be passed (for obvious reasons.)\n\n        Raises:\n            ValueError\n        \"\"\"\n        unbound_implementation = self.__get_unbound_function(implementation)\n        for_types = self.__get_types(for_type, for_types)\n\n        for t in for_types:\n            self._write_lock.acquire()\n            try:\n                self.implementations.append((t, unbound_implementation))\n            finally:\n                self._write_lock.release()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef to_int_list(values):\n    results = []\n    for v in values:\n        try:\n            results.append(int(v))\n        except (TypeError, ValueError):\n            results.append(0)\n    return results", "response": "Converts the given list of vlues into a list of integers."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nvalidate the resource description.", "response": "def _validate_resource_desc(self):\n        \"\"\"\n        **Purpose**: Validate the resource description provided to the ResourceManager\n        \"\"\"\n\n        self._prof.prof('validating rdesc', uid=self._uid)\n        self._logger.debug('Validating resource description')\n\n        expected_keys = ['resource',\n                         'walltime',\n                         'cpus']\n\n        for key in expected_keys:\n            if key not in self._resource_desc:\n                raise MissingError(obj='resource description', missing_attribute=key)\n\n        if not isinstance(self._resource_desc['resource'], str):\n            raise TypeError(expected_type=str, actual_type=type(self._resource_desc['resource']))\n\n        if not isinstance(self._resource_desc['walltime'], int):\n            raise TypeError(expected_type=int, actual_type=type(self._resource_desc['walltime']))\n\n        if not isinstance(self._resource_desc['cpus'], int):\n            raise TypeError(expected_type=int, actual_type=type(self._resource_desc['cpus']))\n\n        if 'gpus' in self._resource_desc:\n            if (not isinstance(self._resource_desc['gpus'], int)):\n                raise TypeError(expected_type=int, actual_type=type(self._resource_desc['project']))\n\n        if 'project' in self._resource_desc:\n            if (not isinstance(self._resource_desc['project'], str)) and (not self._resource_desc['project']):\n                raise TypeError(expected_type=str, actual_type=type(self._resource_desc['project']))\n\n        if 'access_schema' in self._resource_desc:\n            if not isinstance(self._resource_desc['access_schema'], str):\n                raise TypeError(expected_type=str, actual_type=type(self._resource_desc['access_schema']))\n\n        if 'queue' in self._resource_desc:\n            if not isinstance(self._resource_desc['queue'], str):\n                raise TypeError(expected_type=str, actual_type=type(self._resource_desc['queue']))\n\n        if not isinstance(self._rts_config, dict):\n            raise TypeError(expected_type=dict, actual_type=type(self._rts_config))\n\n        self._validated = True\n\n        self._logger.info('Resource description validated')\n        self._prof.prof('rdesc validated', uid=self._uid)\n\n        return self._validated"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\npopulate the object with the validated resource description.", "response": "def _populate(self):\n        \"\"\"\n        **Purpose**:    Populate the ResourceManager class with the validated\n                        resource description\n        \"\"\"\n\n        if self._validated:\n\n            self._prof.prof('populating rmgr', uid=self._uid)\n            self._logger.debug('Populating resource manager object')\n\n            self._resource = self._resource_desc['resource']\n            self._walltime = self._resource_desc['walltime']\n            self._cpus = self._resource_desc['cpus']\n            self._gpus = self._resource_desc.get('gpus', 0)\n            self._project = self._resource_desc.get('project', None)\n            self._access_schema = self._resource_desc.get('access_schema', None)\n            self._queue = self._resource_desc.get('queue', None)\n\n            self._logger.debug('Resource manager population successful')\n            self._prof.prof('rmgr populated', uid=self._uid)\n\n        else:\n            raise EnTKError('Resource description not validated')"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nincluding the Gauge slugs and data in the context.", "response": "def get_context_data(self, **kwargs):\n        \"\"\"Includes the Gauge slugs and data in the context.\"\"\"\n        data = super(GaugesView, self).get_context_data(**kwargs)\n        data.update({'gauges': get_r().gauge_slugs()})\n        return data"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_context_data(self, **kwargs):\n        data = super(MetricsListView, self).get_context_data(**kwargs)\n\n        # Metrics organized by category, like so:\n        # { <category_name>: [ <slug1>, <slug2>, ... ]}\n        data.update({'metrics': get_r().metric_slugs_by_category()})\n        return data", "response": "Includes the metrics slugs in the context."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_context_data(self, **kwargs):\n        data = super(MetricDetailView, self).get_context_data(**kwargs)\n        data['slug'] = kwargs['slug']\n        data['granularities'] = list(get_r()._granularities())\n        return data", "response": "Includes the metrics slugs in the context."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ninclude the metrics slugs in the context.", "response": "def get_context_data(self, **kwargs):\n        \"\"\"Includes the metrics slugs in the context.\"\"\"\n        data = super(MetricHistoryView, self).get_context_data(**kwargs)\n\n        # Accept GET query params for ``since``\n        since = self.request.GET.get('since', None)\n        if since and len(since) == 10:  # yyyy-mm-dd\n            since = datetime.strptime(since, \"%Y-%m-%d\")\n        elif since and len(since) == 19:  # yyyy-mm-dd HH:MM:ss\n            since = datetime.strptime(since, \"%Y-%m-%d %H:%M:%S\")\n\n        data.update({\n            'since': since,\n            'slug': kwargs['slug'],\n            'granularity': kwargs['granularity'],\n            'granularities': list(get_r()._granularities()),\n        })\n        return data"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreverses the redis_metric_aggregate_detail URL using self. metric_slugs as an argument.", "response": "def get_success_url(self):\n        \"\"\"Reverses the ``redis_metric_aggregate_detail`` URL using\n        ``self.metric_slugs`` as an argument.\"\"\"\n        slugs = '+'.join(self.metric_slugs)\n        url = reverse('redis_metric_aggregate_detail', args=[slugs])\n        # Django 1.6 quotes reversed URLs, which changes + into %2B. We want\n        # want to keep the + in the url (it's ok according to RFC 1738)\n        # https://docs.djangoproject.com/en/1.6/releases/1.6/#quoting-in-reverse\n        return url.replace(\"%2B\", \"+\")"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef form_valid(self, form):\n        self.metric_slugs = [k.strip() for k in form.cleaned_data['metrics']]\n        return super(AggregateFormView, self).form_valid(form)", "response": "Pull the metrics from the submitted form and store them as a\n        list."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ninclude the metrics slugs in the context.", "response": "def get_context_data(self, **kwargs):\n        \"\"\"Includes the metrics slugs in the context.\"\"\"\n        r = get_r()\n        category = kwargs.pop('category', None)\n        data = super(AggregateDetailView, self).get_context_data(**kwargs)\n\n        if category:\n            slug_set =   r._category_slugs(category)\n        else:\n            slug_set = set(kwargs['slugs'].split('+'))\n\n        data['granularities'] = list(r._granularities())\n        data['slugs'] = slug_set\n        data['category'] = category\n        return data"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nincludes the metrics slugs in the context.", "response": "def get_context_data(self, **kwargs):\n        \"\"\"Includes the metrics slugs in the context.\"\"\"\n        r = get_r()\n        data = super(AggregateHistoryView, self).get_context_data(**kwargs)\n        slug_set = set(kwargs['slugs'].split('+'))\n        granularity = kwargs.get('granularity', 'daily')\n\n        # Accept GET query params for ``since``\n        since = self.request.GET.get('since', None)\n        if since and len(since) == 10:  # yyyy-mm-dd\n            since = datetime.strptime(since, \"%Y-%m-%d\")\n        elif since and len(since) == 19:  # yyyy-mm-dd HH:MM:ss\n            since = datetime.strptime(since, \"%Y-%m-%d %H:%M:%S\")\n\n        data.update({\n            'slugs': slug_set,\n            'granularity': granularity,\n            'since': since,\n            'granularities': list(r._granularities())\n        })\n        return data"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nseeing if this view was called with a specified category.", "response": "def get(self, *args, **kwargs):\n        \"\"\"See if this view was called with a specified category.\"\"\"\n        self.initial = {\"category_name\":  kwargs.get('category_name', None)}\n        return super(CategoryFormView, self).get(*args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef form_valid(self, form):\n        form.categorize_metrics()\n        return super(CategoryFormView, self).form_valid(form)", "response": "Update the the\n        category so contains the given metrics."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef rerun(self):\n\n        \"\"\"\n        Rerun sets the state of the Pipeline to scheduling so that the Pipeline\n        can be checked for new stages\n        \"\"\"\n\n        self._state = states.SCHEDULING\n        self._completed_flag = threading.Event()\n        print 'Pipeline %s in %s state'%(self._uid, self._state)", "response": "Rerun sets the state of the Pipeline to scheduling so that the Pipeline\n        can be checked for new stages"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef to_dict(self):\n\n        pipeline_desc_as_dict = {\n\n            'uid': self._uid,\n            'name': self._name,\n            'state': self._state,\n            'state_history': self._state_history,\n            'completed': self._completed_flag.is_set()\n        }\n\n        return pipeline_desc_as_dict", "response": "Convert the current Pipeline into a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef from_dict(self, d):\n\n        if 'uid' in d:\n            if d['uid']:\n                self._uid = d['uid']\n\n        if 'name' in d:\n            if d['name']:\n                self._name = d['name']\n\n        if 'state' in d:\n            if isinstance(d['state'], str) or isinstance(d['state'], unicode):\n                if d['state'] in states._pipeline_state_values.keys():\n                    self._state = d['state']\n                else:\n                    raise ValueError(obj=self._uid,\n                                     attribute='state',\n                                     expected_value=states._pipeline_state_values.keys(),\n                                     actual_value=d['state'])\n            else:\n                raise TypeError(entity='state', expected_type=str,\n                                actual_type=type(d['state']))\n\n        else:\n            self._state = states.INITIAL\n\n        if 'state_history' in d:\n            if isinstance(d['state_history'], list):\n                self._state_history = d['state_history']\n            else:\n                raise TypeError(entity='state_history', expected_type=list, actual_type=type(\n                    d['state_history']))\n\n        if 'completed' in d:\n            if isinstance(d['completed'], bool):\n                if d['completed']:\n                    self._completed_flag.set()\n            else:\n                raise TypeError(entity='completed', expected_type=bool,\n                                actual_type=type(d['completed']))", "response": "Create a new object from a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _increment_stage(self):\n\n        try:\n\n            if self._cur_stage < self._stage_count:\n                self._cur_stage += 1\n            else:\n                self._completed_flag.set()\n\n        except Exception, ex:\n            raise EnTKError(text=ex)", "response": "Increment the stage pointer."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _decrement_stage(self):\n\n        try:\n\n            if self._cur_stage > 0:\n                self._cur_stage -= 1\n                self._completed_flag = threading.Event()  # reset\n\n        except Exception, ex:\n            raise EnTKError(text=ex)", "response": "Decrement the stage pointer."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncheck whether the argument stages is of list of Stage objects.", "response": "def _validate_entities(self, stages):\n        \"\"\"\n        Purpose: Validate whether the argument 'stages' is of list of Stage objects\n\n        :argument: list of Stage objects\n        \"\"\"\n        if not stages:\n            raise TypeError(expected_type=Stage, actual_type=type(stages))\n\n        if not isinstance(stages, list):\n            stages = [stages]\n\n        for value in stages:\n            if not isinstance(value, Stage):\n                raise TypeError(expected_type=Stage, actual_type=type(value))\n\n        return stages"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _assign_uid(self, sid):\n        self._uid = ru.generate_id(\n            'pipeline.%(item_counter)04d', ru.ID_CUSTOM, namespace=sid)\n        for stage in self._stages:\n            stage._assign_uid(sid)\n\n        self._pass_uid()", "response": "Assign a uid to the current object based on the sid passed. Pass the current uid to children of\n            current object"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _pass_uid(self):\n\n        for stage in self._stages:\n            stage.parent_pipeline['uid'] = self._uid\n            stage.parent_pipeline['name'] = self._name\n            stage._pass_uid()", "response": "Passes the current Pipeline s uid to all Stages."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nextracts YANG model from an IETF RFC or draft text file. This is the main (external) API entry for the module. :param add_line_refs: :param source_id: identifier (file name or URL) of a draft or RFC file containing one or more YANG models :param srcdir: If source_id points to a file, the optional parameter identifies the directory where the file is located :param dstdir: Directory where to put the extracted YANG models :param strict: Strict syntax enforcement :param strict_examples: Only output valid examples when in strict mode :param debug_level: Determines how much debug output is printed to the console :param force_revision_regexp: Whether it should create a <filename>@<revision>.yang even on error using regexp :param force_revision_pyang: Whether it should create a <filename>@<revision>.yang even on error using pyang :return: None", "response": "def xym(source_id, srcdir, dstdir, strict=False, strict_examples=False, debug_level=0, add_line_refs=False,\n        force_revision_pyang=False, force_revision_regexp=False):\n    \"\"\"\n    Extracts YANG model from an IETF RFC or draft text file.\n    This is the main (external) API entry for the module.\n\n    :param add_line_refs:\n    :param source_id: identifier (file name or URL) of a draft or RFC file containing\n           one or more YANG models\n    :param srcdir: If source_id points to a file, the optional parameter identifies\n           the directory where the file is located\n    :param dstdir: Directory where to put the extracted YANG models\n    :param strict: Strict syntax enforcement\n    :param strict_examples: Only output valid examples when in strict mode\n    :param debug_level: Determines how much debug output is printed to the console\n    :param force_revision_regexp: Whether it should create a <filename>@<revision>.yang even on error using regexp\n    :param force_revision_pyang: Whether it should create a <filename>@<revision>.yang even on error using pyang\n    :return: None\n    \"\"\"\n\n    if force_revision_regexp and force_revision_pyang:\n        print('Can not use both methods for parsing name and revision - using regular expression method only')\n        force_revision_pyang = False\n\n    url = re.compile(r'^(?:http|ftp)s?://'  # http:// or https://\n                     r'(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\\.)+(?:[A-Z]{2,6}\\.?|[A-Z0-9-]{2,}\\.?)|'  # domain\n                     r'localhost|'  # localhost...\n                     r'\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})'  # ...or ip\n                     r'(?::\\d+)?'  # optional port\n                     r'(?:/?|[/?]\\S+)$', re.IGNORECASE)\n    rqst_hdrs = {'Accept': 'text/plain', 'Accept-Charset': 'utf-8'}\n\n    ye = YangModuleExtractor(source_id, dstdir, strict, strict_examples, add_line_refs, debug_level)\n    is_url = url.match(source_id)\n    if is_url:\n        r = requests.get(source_id, headers=rqst_hdrs)\n        if r.status_code == 200:\n            content = r.text.encode('utf8').splitlines(True)\n            ye.extract_yang_model(content)\n        else:\n            print(\"Failed to fetch file from URL '%s', error '%d'\" % (source_id, r.status_code), file=sys.stderr)\n    else:\n        try:\n            with open(os.path.join(srcdir, source_id)) as sf:\n                ye.extract_yang_model(sf.readlines())\n        except IOError as ioe:\n            print(ioe)\n    return ye.get_extracted_models(force_revision_pyang, force_revision_regexp)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef warning(self, s):\n        print(\"   WARNING: '%s', %s\" % (self.src_id, s), file=sys.stderr)", "response": "Print a warning message to stderr."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef error(self, s):\n        print(\"   ERROR: '%s', %s\" % (self.src_id, s), file=sys.stderr)", "response": "Prints out an error message to stderr."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef remove_leading_spaces(self, input_model):\n        leading_spaces = 1024\n        output_model = []\n        for mline in input_model:\n            line = mline[0]\n            if line.rstrip(' \\r\\n') != '':\n                leading_spaces = min(leading_spaces, len(line) - len(line.lstrip(' ')))\n                output_model.append([line[leading_spaces:], mline[1]])\n\n                line_len = len(line[leading_spaces:])\n                if line_len > self.max_line_len:\n                    self.max_line_len = line_len\n            else:\n                output_model.append(['\\n', mline[1]])\n        return output_model", "response": "This function removes leading spaces from YANG model lines."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef add_line_references(self, input_model):\n        output_model = []\n        for ln in input_model:\n            line_len = len(ln[0])\n            line_ref = ('// %4d' % ln[1]).rjust((self.max_line_len - line_len + 7), ' ')\n            new_line = '%s %s\\n' % (ln[0].rstrip(' \\r\\n\\t\\f'), line_ref)\n            output_model.append([new_line, ln[1]])\n        return output_model", "response": "This function adds line numbers to the line number in\n                 in the YANG model."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nremoves extra empty lines from a YANG model that was extracted by extract_new_line_from_draft or extract_new_line_from_RFC text.", "response": "def remove_extra_empty_lines(self, input_model):\n        \"\"\"\n        Removes superfluous newlines from a YANG model that was extracted\n        from a draft or RFC text. Newlines are removed whenever 2 or more\n        consecutive empty lines are found in the model. This function is a\n        part of the model post-processing pipeline.\n        :param input_model: The YANG model to be processed\n        :return: YANG model with superfluous newlines removed\n        \"\"\"\n        ncnt = 0\n        output_model = []\n        for ln in input_model:\n            if ln[0].strip(' \\n\\r') is '':\n                if ncnt is 0:\n                    output_model.append(ln)\n                elif self.debug_level > 1:\n                        self.debug_print_strip_msg(ln[1] - 1, ln[0])\n                ncnt += 1\n            else:\n                output_model.append(ln)\n                ncnt = 0\n        if self.debug_level > 0:\n            print('   Removed %d empty lines' % (len(input_model) - len(output_model)))\n        return output_model"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef post_process_model(self, input_model, add_line_refs):\n        intermediate_model = self.remove_leading_spaces(input_model)\n        intermediate_model = self.remove_extra_empty_lines(intermediate_model)\n        if add_line_refs:\n            intermediate_model = self.add_line_references(intermediate_model)\n        return finalize_model(intermediate_model)", "response": "This function is called by the YANG model post - processing pipeline. It is called after the YANG model is processed and the YANG model is written to the module file."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nwrites YANG model that was extracted from a source identifier to a. YANG destination file.", "response": "def write_model_to_file(self, mdl, fn):\n        \"\"\"\n        Write a YANG model that was extracted from a source identifier\n        (URL or source .txt file) to a .yang destination file\n        :param mdl: YANG model, as a list of lines\n        :param fn: Name of the YANG model file\n        :return:\n        \"\"\"\n        # Write the model to file\n        output = ''.join(self.post_process_model(mdl, self.add_line_refs))\n        if fn:\n            fqfn = self.dst_dir + '/' + fn\n            if os.path.isfile(fqfn):\n                self.error(\"File '%s' exists\" % fqfn)\n                return\n            with open(fqfn, 'w') as of:\n                of.write(output)\n                of.close()\n                self.extracted_models.append(fn)\n        else:\n            self.error(\"Output file name can not be determined; YANG file not created\")"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ndebug print of the currently parsed line", "response": "def debug_print_line(self, i, level, line):\n        \"\"\"\n        Debug print of the currently parsed line\n        :param i: The line number of the line that is being currently parsed\n        :param level: Parser level\n        :param line: the line that is currently being parsed\n        :return: None\n        \"\"\"\n        if self.debug_level == 2:\n            print(\"Line %d (%d): '%s'\" % (i + 1, level, line.rstrip(' \\r\\n\\t\\f')))\n        if self.debug_level > 2:\n            print(\"Line %d (%d):\" % (i + 1, level))\n            hexdump(line)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ndebugs print indicating that an empty line is being skipped", "response": "def debug_print_strip_msg(self, i, line):\n        \"\"\"\n        Debug print indicating that an empty line is being skipped\n        :param i: The line number of the line that is being currently parsed\n        :param line: the parsed line\n        :return: None\n        \"\"\"\n        if self.debug_level == 2:\n            print(\"     Stripping Line %d: '%s'\" % (i + 1, line.rstrip(' \\r\\n\\t\\f')))\n        elif self.debug_level > 2:\n            print(\"     Stripping Line %d:\" % (i + 1))\n            hexdump(line)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nskip over empty lines in the parsed text i until the next empty line.", "response": "def strip_empty_lines_forward(self, content, i):\n        \"\"\"\n        Skip over empty lines\n        :param content: parsed text\n        :param i: current parsed line\n        :return: number of skipped lined\n        \"\"\"\n        while i < len(content):\n            line = content[i].strip(' \\r\\n\\t\\f')\n            if line != '':\n                break\n            self.debug_print_strip_msg(i, content[i])\n            i += 1  # Strip an empty line\n        return i"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nstrip empty lines preceding the line that is currently being parsed.", "response": "def strip_empty_lines_backward(self, model, max_lines_to_strip):\n        \"\"\"\n        Strips empty lines preceding the line that is currently being parsed. This\n        fucntion is called when the parser encounters a Footer.\n        :param model: lines that were added to the model up to this point\n        :param line_num: the number of teh line being parsed\n        :param max_lines_to_strip: max number of lines to strip from the model\n        :return: None\n        \"\"\"\n        for l in range(0, max_lines_to_strip):\n            if model[-1][0].strip(' \\r\\n\\t\\f') != '':\n                return\n            self.debug_print_strip_msg(model[-1][1] - 1, model[-1][0])\n            model.pop()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nextracting one or more YANG models from a string of text.", "response": "def extract_yang_model(self, content):\n        \"\"\"\n        Extracts one or more YANG models from an RFC or draft text string in\n        which the models are specified. The function skips over page\n        formatting (Page Headers and Footers) and performs basic YANG module\n        syntax checking. In strict mode, the function also enforces the\n        <CODE BEGINS> / <CODE ENDS> tags - a model is not extracted unless\n        the tags are present.\n        :return: None\n        \"\"\"\n        model = []\n        output_file = None\n        in_model = False\n        example_match = False\n        i = 0\n        level = 0\n        quotes = 0\n        while i < len(content):\n            line = content[i]\n\n            # Try to match '<CODE ENDS>'\n            if self.CODE_ENDS_TAG.match(line):\n                if in_model is False:\n                    self.warning(\"Line %d: misplaced <CODE ENDS>\" % i)\n                in_model = False\n\n            if \"\\\"\" in line:\n                if line.count(\"\\\"\") % 2 == 0:\n                    quotes = 0\n                else:\n                    if quotes == 1:\n                        quotes = 0\n                    else:\n                        quotes = 1\n\n            # Try to match '(sub)module <module_name> {'\n            match = self.MODULE_STATEMENT.match(line)\n            if match:\n                # We're already parsing a module\n                if quotes == 0:\n                    if level > 0:\n                        self.error(\"Line %d - 'module' statement within another module\" % i)\n                        return\n\n                # Check if we should enforce <CODE BEGINS> / <CODE ENDS>\n                # if we do enforce, we ignore models  not enclosed in <CODE BEGINS> / <CODE ENDS>\n                if match.groups()[1] or match.groups()[4]:\n                    self.warning('Line %d - Module name should not be enclosed in quotes' % i)\n\n                # do the module name checking, etc.\n                example_match = self.EXAMPLE_TAG.match(match.groups()[2])\n                if in_model is True:\n                    if example_match:\n                        self.error(\"Line %d - YANG module '%s' with <CODE BEGINS> and starting with 'example-'\" %\n                                   (i, match.groups()[2]))\n                else:\n                    if not example_match:\n                        self.error(\"Line %d - YANG module '%s' with no <CODE BEGINS> and not starting with 'example-'\" %\n                                   (i, match.groups()[2]))\n\n                # now decide if we're allowed to set the level\n                # (i.e. signal that we're in a module) to 1 and if\n                # we're allowed to output the module at all with the\n                # strict examples flag\n                # if self.strict is True:\n                #     if in_model is True:\n                #         level = 1\n                # else:\n                #     level = 1\n\n                # always set the level to 1; we decide whether or not\n                # to output at the end\n                if quotes == 0:\n                    level = 1\n                if not output_file and level == 1 and quotes == 0:\n                    print(\"\\nExtracting '%s'\" % match.groups()[2])\n                    output_file = '%s.yang' % match.groups()[2].strip('\"\\'')\n                    if self.debug_level > 0:\n                        print('   Getting YANG file name from module name: %s' % output_file)\n\n            if level > 0:\n                self.debug_print_line(i, level, content[i])\n                # Try to match the Footer ('[Page <page_num>]')\n                # If match found, skip over page headers and footers\n                if self.PAGE_TAG.match(line):\n                    self.strip_empty_lines_backward(model, 3)\n                    self.debug_print_strip_msg(i, content[i])\n                    i += 1        # Strip the\n                    # Strip empty lines between the Footer and the next page Header\n                    i = self.strip_empty_lines_forward(content, i)\n                    if i < len(content):\n                        self.debug_print_strip_msg(i, content[i])\n                        i += 1      # Strip the next page Header\n                    else:\n                        self.error(\"<End of File> - EOF encountered while parsing the model\")\n                        return\n                    # Strip empty lines between the page Header and real content on the page\n                    i = self.strip_empty_lines_forward(content, i) - 1\n                    if i >= len(content):\n                        self.error(\"<End of File> - EOF encountered while parsing the model\")\n                        return\n                else:\n                    model.append([line, i + 1])\n                    counter = Counter(line)\n                    if quotes == 0:\n                        if \"\\\"\" in line and \"}\" in line:\n                            if line.index(\"}\") > line.rindex(\"\\\"\") or line.index(\"}\") < line.index(\"\\\"\"):\n                                level += (counter['{'] - counter['}'])\n                        else:\n                            level += (counter['{'] - counter['}'])\n                    if level == 1:\n                        if self.strict:\n                            if self.strict_examples:\n                                if example_match and not in_model:\n                                    self.write_model_to_file(model, output_file)\n                            elif in_model:\n                                self.write_model_to_file(model, output_file)\n                        else:\n                            self.write_model_to_file(model, output_file)\n                        self.max_line_len = 0\n                        model = []\n                        output_file = None\n                        level = 0\n\n            # Try to match '<CODE BEGINS>'\n            match = self.CODE_BEGINS_TAG.match(line)\n            if match:\n                # Found the beginning of the YANG module code section; make sure we're not parsing a model already\n                if level > 0:\n                    self.error(\"Line %d - <CODE BEGINS> within a model\" % i)\n                    return\n                if in_model is True:\n                    self.error(\"Line %d - Misplaced <CODE BEGINS> or missing <CODE ENDS>\" % i)\n                in_model = True\n                mg = match.groups()\n                # Get the YANG module's file name\n                if mg[2]:\n                    print(\"\\nExtracting '%s'\" % match.groups()[2])\n                    output_file = mg[2].strip()\n                else:\n                    if mg[0] and mg[1] is None:\n                        self.error('Line %d - Missing file name in <CODE BEGINS>' % i)\n                    else:\n                        self.error(\"Line %d - YANG file not specified in <CODE BEGINS>\" % i)\n            i += 1\n        if level > 0:\n            self.error(\"<End of File> - EOF encountered while parsing the model\")\n            return\n        if in_model is True:\n            self.error(\"Line %d - Missing <CODE ENDS>\" % i)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef auto_retry(fun):\n\n    @functools.wraps(fun)\n    def decorated(instance, *args, **kwargs):\n        \"\"\"Wrapper around a decorated function.\"\"\"\n        cfg = instance._retry_config\n        remaining_tries = cfg.retry_attempts\n        current_wait = cfg.retry_wait\n        retry_backoff = cfg.retry_backoff\n        last_error = None\n\n        while remaining_tries >= 0:\n            try:\n                return fun(instance, *args, **kwargs)\n            except socket.error as e:\n                last_error = e\n                instance._retry_logger.warning('Connection failed: %s', e)\n\n            remaining_tries -= 1\n            if remaining_tries == 0:\n                # Last attempt\n                break\n\n            # Wait a bit\n            time.sleep(current_wait)\n            current_wait *= retry_backoff\n\n        # All attempts failed, let's raise the last error.\n        raise last_error\n\n    return decorated", "response": "Decorator for retrying method calls based on instance parameters."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nextracting used strings from a %(foo )s pattern.", "response": "def extract_pattern(fmt):\n    \"\"\"Extracts used strings from a %(foo)s pattern.\"\"\"\n    class FakeDict(object):\n        def __init__(self):\n            self.seen_keys = set()\n\n        def __getitem__(self, key):\n            self.seen_keys.add(key)\n            return ''\n\n        def keys(self):\n            return self.seen_keys\n\n    fake = FakeDict()\n    try:\n        fmt % fake\n    except TypeError:\n        # Formatting error\n        pass\n    return set(fake.keys())"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef iso_mesh_line(vertices, tris, vertex_data, levels):\n\n    lines = None\n    connects = None\n    vertex_level = None\n    level_index = None\n    if not all([isinstance(x, np.ndarray) for x in (vertices, tris,\n                vertex_data, levels)]):\n        raise ValueError('all inputs must be numpy arrays')\n    if vertices.shape[1] <= 3:\n        verts = vertices\n    elif vertices.shape[1] == 4:\n        verts = vertices[:, :-1]\n    else:\n        verts = None\n    if (verts is not None and tris.shape[1] == 3 and\n            vertex_data.shape[0] == verts.shape[0]):\n        edges = np.vstack((tris.reshape((-1)),\n                           np.roll(tris, -1, axis=1).reshape((-1)))).T\n        edge_datas = vertex_data[edges]\n        edge_coors = verts[edges].reshape(tris.shape[0]*3, 2, 3)\n        for lev in levels:\n            # index for select edges with vertices have only False - True\n            # or True - False at extremity\n            index = (edge_datas >= lev)\n            index = index[:, 0] ^ index[:, 1]  # xor calculation\n            # Selectect edge\n            edge_datas_Ok = edge_datas[index, :]\n            xyz = edge_coors[index]\n            # Linear interpolation\n            ratio = np.array([(lev - edge_datas_Ok[:, 0]) /\n                              (edge_datas_Ok[:, 1] - edge_datas_Ok[:, 0])])\n            point = xyz[:, 0, :] + ratio.T * (xyz[:, 1, :] - xyz[:, 0, :])\n            nbr = point.shape[0]//2\n            if connects is not None:\n                connect = np.arange(0, nbr*2).reshape((nbr, 2)) + \\\n                    len(lines)\n                connects = np.append(connects, connect, axis=0)\n                lines = np.append(lines, point, axis=0)\n                vertex_level = np.append(vertex_level,\n                                         np.zeros(len(point)) +\n                                         lev)\n                level_index = np.append(level_index, np.array(len(point)))\n            else:\n                lines = point\n                connects = np.arange(0, nbr*2).reshape((nbr, 2))\n                vertex_level = np.zeros(len(point)) + lev\n                level_index = np.array(len(point))\n\n            vertex_level = vertex_level.reshape((vertex_level.size, 1))\n\n    return lines, connects, vertex_level, level_index", "response": "Generate an isocurve from vertex data in a surface mesh."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef set_data(self, vertices=None, tris=None, data=None):\n        # modifier pour tenier compte des None self._recompute = True\n        if data is not None:\n            self._data = data\n            self._need_recompute = True\n        if vertices is not None:\n            self._vertices = vertices\n            self._need_recompute = True\n        if tris is not None:\n            self._tris = tris\n            self._need_recompute = True\n        self.update()", "response": "Set the data of the object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nset the color of the log entry.", "response": "def set_color(self, color):\n        \"\"\"Set the color\n\n        Parameters\n        ----------\n        color : instance of Color\n            The color to use.\n        \"\"\"\n        if color is not None:\n            self._color_lev = color\n            self._need_color_update = True\n            self.update()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _compute_iso_color(self):\n        level_color = []\n        colors = self._lc\n        for i, index in enumerate(self._li):\n            level_color.append(np.zeros((index, 4)) + colors[i])\n        self._cl = np.vstack(level_color)", "response": "compute LineVisual color from level index and corresponding level\n        color\n       "}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef remove(self):\n        self._multivol.deallocate(self.id)\n        ARRAY_CACHE.pop(self.id, None)\n        PIXEL_CACHE.pop(self.id, None)", "response": "Remove the layer artist for good\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ninjects functions and constants from PyOpenGL but leave out the names that are deprecated or that we provide in our API.", "response": "def _inject():\n    \"\"\" Inject functions and constants from PyOpenGL but leave out the\n    names that are deprecated or that we provide in our API.\n    \"\"\"\n    \n    # Get namespaces\n    NS = globals()\n    GLNS = _GL.__dict__\n    \n    # Get names that we use in our API\n    used_names = []\n    used_names.extend([names[0] for names in _pyopengl2._functions_to_import])\n    used_names.extend([name for name in _pyopengl2._used_functions])\n    NS['_used_names'] = used_names\n    #\n    used_constants = set(_constants.__dict__)\n    # Count\n    injected_constants = 0\n    injected_functions = 0\n    \n    for name in dir(_GL):\n        \n        if name.startswith('GL_'):\n            # todo: find list of deprecated constants\n            if name not in used_constants:\n                NS[name] = GLNS[name]\n                injected_constants += 1\n        \n        elif name.startswith('gl'):\n            # Functions\n            if (name + ',') in _deprecated_functions:\n                pass  # Function is deprecated\n            elif name in used_names:\n                pass  # Function is in our GL ES 2.0 API\n            else:\n                NS[name] = GLNS[name]\n                injected_functions += 1"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nfinds a module by name.", "response": "def _find_module(name, path=None):\n    \"\"\"\n    Alternative to `imp.find_module` that can also search in subpackages.\n    \"\"\"\n\n    parts = name.split('.')\n\n    for part in parts:\n        if path is not None:\n            path = [path]\n\n        fh, path, descr = imp.find_module(part, path)\n        if fh is not None and part != parts[-1]:\n            fh.close()\n\n    return fh, path, descr"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nforces edge (i, j) to be present in mesh. This works by removing intersected triangles and filling holes up to the cutting edge.", "response": "def _edge_event(self, i, j):\n        \"\"\"\n        Force edge (i, j) to be present in mesh. \n        This works by removing intersected triangles and filling holes up to\n        the cutting edge.\n        \"\"\"\n        front_index = self._front.index(i)\n        \n        #debug(\"  == edge event ==\")\n        front = self._front\n\n        # First just see whether this edge is already present\n        # (this is not in the published algorithm)\n        if (i, j) in self._edges_lookup or (j, i) in self._edges_lookup:\n            #debug(\"    already added.\")\n            return\n        #debug(\"    Edge (%d,%d) not added yet. Do edge event. (%s - %s)\" % \n        #      (i, j, pts[i], pts[j]))\n        \n        # traverse in two different modes:\n        #  1. If cutting edge is below front, traverse through triangles. These\n        #     must be removed and the resulting hole re-filled. (fig. 12)\n        #  2. If cutting edge is above the front, then follow the front until \n        #     crossing under again. (fig. 13)\n        # We must be able to switch back and forth between these \n        # modes (fig. 14)\n\n        # Collect points that draw the open polygons on either side of the \n        # cutting edge. Note that our use of 'upper' and 'lower' is not strict;\n        # in some cases the two may be swapped.\n        upper_polygon = [i]\n        lower_polygon = [i]\n        \n        # Keep track of which section of the front must be replaced\n        # and with what it should be replaced\n        front_holes = []  # contains indexes for sections of front to remove\n        \n        next_tri = None   # next triangle to cut (already set if in mode 1)\n        last_edge = None  # or last triangle edge crossed (if in mode 1)\n        \n        # Which direction to traverse front\n        front_dir = 1 if self.pts[j][0] > self.pts[i][0] else -1\n                \n        # Initialize search state\n        if self._edge_below_front((i, j), front_index):\n            mode = 1  # follow triangles\n            tri = self._find_cut_triangle((i, j))\n            last_edge = self._edge_opposite_point(tri, i)\n            next_tri = self._adjacent_tri(last_edge, i)\n            assert next_tri is not None\n            self._remove_tri(*tri)\n            # todo: does this work? can we count on last_edge to be clockwise\n            # around point i?\n            lower_polygon.append(last_edge[1])\n            upper_polygon.append(last_edge[0])\n        else:\n            mode = 2  # follow front\n\n        # Loop until we reach point j\n        while True:\n            #debug(\"  == edge_event loop: mode %d ==\" % mode)\n            #debug(\"      front_holes:\", front_holes, front)\n            #debug(\"      front_index:\", front_index)\n            #debug(\"      next_tri:\", next_tri)\n            #debug(\"      last_edge:\", last_edge)\n            #debug(\"      upper_polygon:\", upper_polygon)\n            #debug(\"      lower_polygon:\", lower_polygon)\n            #debug(\"      =====\")\n            if mode == 1:\n                # crossing from one triangle into another\n                if j in next_tri:\n                    #debug(\"    -> hit endpoint!\")\n                    # reached endpoint! \n                    # update front / polygons\n                    upper_polygon.append(j)\n                    lower_polygon.append(j)\n                    #debug(\"    Appended to upper_polygon:\", upper_polygon)\n                    #debug(\"    Appended to lower_polygon:\", lower_polygon)\n                    self._remove_tri(*next_tri)\n                    break\n                else:\n                    # next triangle does not contain the end point; we will\n                    # cut one of the two far edges.\n                    tri_edges = self._edges_in_tri_except(next_tri, last_edge)\n                    \n                    # select the edge that is cut\n                    last_edge = self._intersected_edge(tri_edges, (i, j))\n                    #debug(\"    set last_edge to intersected edge:\", last_edge)\n                    last_tri = next_tri\n                    next_tri = self._adjacent_tri(last_edge, last_tri)\n                    #debug(\"    set next_tri:\", next_tri)\n                    self._remove_tri(*last_tri)\n\n                    # Crossing an edge adds one point to one of the polygons\n                    if lower_polygon[-1] == last_edge[0]:\n                        upper_polygon.append(last_edge[1])\n                        #debug(\"    Appended to upper_polygon:\", upper_polygon)\n                    elif lower_polygon[-1] == last_edge[1]:\n                        upper_polygon.append(last_edge[0])\n                        #debug(\"    Appended to upper_polygon:\", upper_polygon)\n                    elif upper_polygon[-1] == last_edge[0]:\n                        lower_polygon.append(last_edge[1])\n                        #debug(\"    Appended to lower_polygon:\", lower_polygon)\n                    elif upper_polygon[-1] == last_edge[1]:\n                        lower_polygon.append(last_edge[0])\n                        #debug(\"    Appended to lower_polygon:\", lower_polygon)\n                    else:\n                        raise RuntimeError(\"Something went wrong..\")\n                    \n                    # If we crossed the front, go to mode 2\n                    x = self._edge_in_front(last_edge)\n                    if x >= 0:  # crossing over front\n                        #debug(\"    -> crossed over front, prepare for mode 2\")\n                        mode = 2\n                        next_tri = None\n                        #debug(\"    set next_tri: None\")\n                        \n                        # where did we cross the front?\n                        # nearest to new point\n                        front_index = x + (1 if front_dir == -1 else 0)\n                        #debug(\"    set front_index:\", front_index)\n                        \n                        # Select the correct polygon to be lower_polygon\n                        # (because mode 2 requires this). \n                        # We know that last_edge is in the front, and \n                        # front[front_index] is the point _above_ the front. \n                        # So if this point is currently the last element in\n                        # lower_polygon, then the polys must be swapped.\n                        if lower_polygon[-1] == front[front_index]:\n                            tmp = lower_polygon, upper_polygon\n                            upper_polygon, lower_polygon = tmp\n                            #debug('    Swap upper/lower polygons')\n                        else:\n                            assert upper_polygon[-1] == front[front_index]\n                        \n                    else:\n                        assert next_tri is not None\n                \n            else:  # mode == 2\n                # At each iteration, we require:\n                #   * front_index is the starting index of the edge _preceding_\n                #     the edge that will be handled in this iteration\n                #   * lower_polygon is the polygon to which points should be\n                #     added while traversing the front\n                \n                front_index += front_dir\n                #debug(\"    Increment front_index: %d\" % front_index)\n                next_edge = (front[front_index], front[front_index+front_dir])\n                #debug(\"    Set next_edge: %s\" % repr(next_edge))\n                \n                assert front_index >= 0\n                if front[front_index] == j:\n                    # found endpoint!\n                    #debug(\"    -> hit endpoint!\")\n                    lower_polygon.append(j)\n                    upper_polygon.append(j)\n                    #debug(\"    Appended to upper_polygon:\", upper_polygon)\n                    #debug(\"    Appended to lower_polygon:\", lower_polygon)\n                    break\n\n                # Add point to lower_polygon. \n                # The conditional is because there are cases where the \n                # point was already added if we just crossed from mode 1.\n                if lower_polygon[-1] != front[front_index]:\n                    lower_polygon.append(front[front_index])\n                    #debug(\"    Appended to lower_polygon:\", lower_polygon)\n\n                front_holes.append(front_index)\n                #debug(\"    Append to front_holes:\", front_holes)\n\n                if self._edges_intersect((i, j), next_edge):\n                    # crossing over front into triangle\n                    #debug(\"    -> crossed over front, prepare for mode 1\")\n                    mode = 1\n                    \n                    last_edge = next_edge\n                    #debug(\"    Set last_edge:\", last_edge)\n                    \n                    # we are crossing the front, so this edge only has one\n                    # triangle. \n                    next_tri = self._tri_from_edge(last_edge)\n                    #debug(\"    Set next_tri:\", next_tri)\n                    \n                    upper_polygon.append(front[front_index+front_dir])\n                    #debug(\"    Appended to upper_polygon:\", upper_polygon)\n                #else:\n                    #debug(\"    -> did not cross front..\")\n        \n        #debug(\"Finished edge_event:\")\n        #debug(\"  front_holes:\", front_holes)\n        #debug(\"  upper_polygon:\", upper_polygon)\n        #debug(\"  lower_polygon:\", lower_polygon)\n\n        # (iii) triangluate empty areas\n        \n        #debug(\"Filling edge_event polygons...\")\n        for polygon in [lower_polygon, upper_polygon]:\n            dist = self._distances_from_line((i, j), polygon)\n            #debug(\"Distances:\", dist)\n            while len(polygon) > 2:\n                ind = np.argmax(dist)\n                #debug(\"Next index: %d\" % ind)\n                self._add_tri(polygon[ind], polygon[ind-1],\n                              polygon[ind+1], legal=False, \n                              source='edge_event')\n                polygon.pop(ind)\n                dist.pop(ind)\n\n        #debug(\"Finished filling edge_event polygons.\")\n        \n        # update front by removing points in the holes (places where front \n        # passes below the cut edge)\n        front_holes.sort(reverse=True)\n        for i in front_holes:\n            front.pop(i)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nfinds the triangle that has edge [ 0 ] as one of its vertices and is bisected by edge.", "response": "def _find_cut_triangle(self, edge):\n        \"\"\"\n        Return the triangle that has edge[0] as one of its vertices and is \n        bisected by edge.\n        \n        Return None if no triangle is found.\n        \"\"\"\n        edges = []  # opposite edge for each triangle attached to edge[0]\n        for tri in self.tris:\n            if edge[0] in tri:\n                edges.append(self._edge_opposite_point(tri, edge[0]))\n                \n        for oedge in edges:\n            o1 = self._orientation(edge, oedge[0])\n            o2 = self._orientation(edge, oedge[1]) \n            #debug(edge, oedge, o1, o2)\n            #debug(self.pts[np.array(edge)])\n            #debug(self.pts[np.array(oedge)])\n            if o1 != o2:\n                return (edge[0], oedge[0], oedge[1])\n        \n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _edge_in_front(self, edge):\n        e = (list(edge), list(edge)[::-1])\n        for i in range(len(self._front)-1):\n            if self._front[i:i+2] in e:\n                return i\n        return -1", "response": "Return the index where the edge appears in the front."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _edge_opposite_point(self, tri, i):\n        ind = tri.index(i)\n        return (tri[(ind+1) % 3], tri[(ind+2) % 3])", "response": "Given a triangle return the edge that is opposite point i."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _adjacent_tri(self, edge, i):\n        if not np.isscalar(i):\n            i = [x for x in i if x not in edge][0]\n\n        try:\n            pt1 = self._edges_lookup[edge]\n            pt2 = self._edges_lookup[(edge[1], edge[0])]\n        except KeyError:\n            return None\n            \n        if pt1 == i:\n            return (edge[1], edge[0], pt2)\n        elif pt2 == i:\n            return (edge[1], edge[0], pt1)\n        else:\n            raise RuntimeError(\"Edge %s and point %d do not form a triangle \"\n                               \"in this mesh.\" % (edge, i))", "response": "Given a triangle formed by edge and i return the triangle that shares the edge and i."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _tri_from_edge(self, edge):\n        edge = tuple(edge)\n        p1 = self._edges_lookup.get(edge, None)\n        p2 = self._edges_lookup.get(edge[::-1], None)\n        if p1 is None:\n            if p2 is None:\n                raise RuntimeError(\"No tris connected to edge %r\" % (edge,))\n            return edge + (p2,)\n        elif p2 is None:\n            return edge + (p1,)\n        else:\n            raise RuntimeError(\"Two triangles connected to edge %r\" % (edge,))", "response": "Return the only tri that contains edge. If two tris share this\n        edge raise an exception."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the edges in tri excluding edge.", "response": "def _edges_in_tri_except(self, tri, edge):\n        \"\"\"Return the edges in *tri*, excluding *edge*.\n        \"\"\"\n        edges = [(tri[i], tri[(i+1) % 3]) for i in range(3)]\n        try:\n            edges.remove(tuple(edge))\n        except ValueError:\n            edges.remove(tuple(edge[::-1]))\n        return edges"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn True if edge is below the front.", "response": "def _edge_below_front(self, edge, front_index):\n        \"\"\"Return True if *edge* is below the current front. \n        \n        One of the points in *edge* must be _on_ the front, at *front_index*.\n        \"\"\"\n        f0 = self._front[front_index-1]\n        f1 = self._front[front_index+1]\n        return (self._orientation(edge, f0) > 0 and \n                self._orientation(edge, f1) < 0)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngives a list of edges return the first that is intersected by cut_edge.", "response": "def _intersected_edge(self, edges, cut_edge):\n        \"\"\" Given a list of *edges*, return the first that is intersected by\n        *cut_edge*.\n        \"\"\"\n        for edge in edges:\n            if self._edges_intersect(edge, cut_edge):\n                return edge"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _find_edge_intersections(self):\n        edges = self.pts[self.edges]\n        cuts = {}  # { edge: [(intercept, point), ...], ... }\n        for i in range(edges.shape[0]-1):\n            # intersection of edge i onto all others\n            int1 = self._intersect_edge_arrays(edges[i:i+1], edges[i+1:])\n            # intersection of all edges onto edge i\n            int2 = self._intersect_edge_arrays(edges[i+1:], edges[i:i+1])\n        \n            # select for pairs that intersect\n            err = np.geterr()\n            np.seterr(divide='ignore', invalid='ignore')\n            try:\n                mask1 = (int1 >= 0) & (int1 <= 1)\n                mask2 = (int2 >= 0) & (int2 <= 1)\n                mask3 = mask1 & mask2  # all intersections\n            finally:\n                np.seterr(**err)\n            \n            # compute points of intersection\n            inds = np.argwhere(mask3)[:, 0]\n            if len(inds) == 0:\n                continue\n            h = int2[inds][:, np.newaxis]\n            pts = (edges[i, 0][np.newaxis, :] * (1.0 - h) + \n                   edges[i, 1][np.newaxis, :] * h)\n            \n            # record for all edges the location of cut points\n            edge_cuts = cuts.setdefault(i, [])\n            for j, ind in enumerate(inds):\n                if 0 < int2[ind] < 1:\n                    edge_cuts.append((int2[ind], pts[j]))\n                if 0 < int1[ind] < 1:\n                    other_cuts = cuts.setdefault(ind+i+1, [])\n                    other_cuts.append((int1[ind], pts[j]))\n        \n        # sort all cut lists by intercept, remove duplicates\n        for k, v in cuts.items():\n            v.sort(key=lambda x: x[0])\n            for i in range(len(v)-2, -1, -1):\n                if v[i][0] == v[i+1][0]:\n                    v.pop(i+1)\n        return cuts", "response": "Find the intersection of all edges onto all others and return a dictionary containing the edge and the list of the positions at which the edge should be split."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the projection of a and b onto a and c", "response": "def _projection(self, a, b, c):\n        \"\"\"Return projection of (a,b) onto (a,c)\n        Arguments are point locations, not indexes.\n        \"\"\"\n        ab = b - a\n        ac = c - a\n        return a + ((ab*ac).sum() / (ac*ac).sum()) * ac"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn 1 if edges intersect completely ( endpoints excluded )", "response": "def _edges_intersect(self, edge1, edge2):\n        \"\"\"\n        Return 1 if edges intersect completely (endpoints excluded)\n        \"\"\"\n        h12 = self._intersect_edge_arrays(self.pts[np.array(edge1)], \n                                          self.pts[np.array(edge2)])\n        h21 = self._intersect_edge_arrays(self.pts[np.array(edge2)], \n                                          self.pts[np.array(edge1)])\n        err = np.geterr()\n        np.seterr(divide='ignore', invalid='ignore')\n        try:\n            out = (0 < h12 < 1) and (0 < h21 < 1)\n        finally:\n            np.seterr(**err)\n        return out"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _intersection_matrix(self, lines):\n        return self._intersect_edge_arrays(lines[:, np.newaxis, ...], \n                                           lines[np.newaxis, ...])", "response": "Return a 2D array of intercepts that are the intersection of the lines with the lines."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _intersect_edge_arrays(self, lines1, lines2):\n        # vector for each line in lines1\n        l1 = lines1[..., 1, :] - lines1[..., 0, :]\n        # vector for each line in lines2\n        l2 = lines2[..., 1, :] - lines2[..., 0, :]\n        # vector between first point of each line\n        diff = lines1[..., 0, :] - lines2[..., 0, :]\n        \n        p = l1.copy()[..., ::-1]  # vectors perpendicular to l1\n        p[..., 0] *= -1\n        \n        f = (l2 * p).sum(axis=-1)  # l2 dot p\n        # tempting, but bad idea! \n        #f = np.where(f==0, 1, f)\n        err = np.geterr()\n        np.seterr(divide='ignore', invalid='ignore')\n        try:\n            h = (diff * p).sum(axis=-1) / f  # diff dot p / f\n        finally:\n            np.seterr(**err)\n        \n        return h", "response": "Return the intercepts of all lines defined in lines1 and lines in lines2 as they \n        intersect all lines in lines2."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning 1 if edge [ 0 ] -> point is clockwise from edge [ 1 ] - 1 if counterclockwise from edge [ 0 ] - point", "response": "def _orientation(self, edge, point):\n        \"\"\" Returns +1 if edge[0]->point is clockwise from edge[0]->edge[1], \n        -1 if counterclockwise, and 0 if parallel.\n        \"\"\"\n        v1 = self.pts[point] - self.pts[edge[0]]\n        v2 = self.pts[edge[1]] - self.pts[edge[0]]\n        c = np.cross(v1, v2)  # positive if v1 is CW from v2\n        return 1 if c > 0 else (-1 if c < 0 else 0)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef load_ipython_extension(ipython):\n    import IPython\n\n    # don't continue if IPython version is < 3.0\n    ipy_version = LooseVersion(IPython.__version__)\n    if ipy_version < LooseVersion(\"3.0.0\"):\n        ipython.write_err(\"Your IPython version is older than \"\n                          \"version 3.0.0, the minimum for Vispy's\"\n                          \"IPython backend. Please upgrade your IPython\"\n                          \"version.\")\n        return\n\n    _load_webgl_backend(ipython)", "response": "Loads the IPython extension and returns the base object that can be used to create the extension."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _load_webgl_backend(ipython):\n\n    from .. import app\n    app_instance = app.use_app(\"ipynb_webgl\")\n\n    if app_instance.backend_name == \"ipynb_webgl\":\n        ipython.write(\"Vispy IPython module has loaded successfully\")\n    else:\n        # TODO: Improve this error message\n        ipython.write_err(\"Unable to load webgl backend of Vispy\")", "response": "Load the webgl backend for the IPython notebook"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndraw the current state of the sequence.", "response": "def draw(self, mode=None):\n        \"\"\" Draw collection \"\"\"\n\n        if self._need_update:\n            self._update()\n\n        program = self._programs[0]\n\n        mode = mode or self._mode\n        if self._indices_list is not None:\n            program.draw(mode, self._indices_buffer)\n        else:\n            program.draw(mode)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ngenerate a 1D gaussian filter for the given data.", "response": "def gaussian_filter(data, sigma):\n    \"\"\"\n    Drop-in replacement for scipy.ndimage.gaussian_filter.\n\n    (note: results are only approximately equal to the output of\n     gaussian_filter)\n    \"\"\"\n    if np.isscalar(sigma):\n        sigma = (sigma,) * data.ndim\n\n    baseline = data.mean()\n    filtered = data - baseline\n    for ax in range(data.ndim):\n        s = float(sigma[ax])\n        if s == 0:\n            continue\n\n        # generate 1D gaussian kernel\n        ksize = int(s * 6)\n        x = np.arange(-ksize, ksize)\n        kernel = np.exp(-x**2 / (2*s**2))\n        kshape = [1, ] * data.ndim\n        kshape[ax] = len(kernel)\n        kernel = kernel.reshape(kshape)\n\n        # convolve as product of FFTs\n        shape = data.shape[ax] + ksize\n        scale = 1.0 / (abs(s) * (2*np.pi)**0.5)\n        filtered = scale * np.fft.irfft(np.fft.rfft(filtered, shape, axis=ax) *\n                                        np.fft.rfft(kernel, shape, axis=ax),\n                                        axis=ax)\n\n        # clip off extra data\n        sl = [slice(None)] * data.ndim\n        sl[ax] = slice(filtered.shape[ax]-data.shape[ax], None, None)\n        filtered = filtered[sl]\n    return filtered + baseline"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ntranslates a single segment of a node into a 3D matrix.", "response": "def translate(offset, dtype=None):\n    \"\"\"Translate by an offset (x, y, z) .\n\n    Parameters\n    ----------\n    offset : array-like, shape (3,)\n        Translation in x, y, z.\n    dtype : dtype | None\n        Output type (if None, don't cast).\n\n    Returns\n    -------\n    M : ndarray\n        Transformation matrix describing the translation.\n    \"\"\"\n    assert len(offset) == 3\n    x, y, z = offset\n    M = np.array([[1., 0., 0., 0.],\n                 [0., 1., 0., 0.],\n                 [0., 0., 1., 0.],\n                 [x, y, z, 1.0]], dtype)\n    return M"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the 3x3 rotation matrix for rotation about a vector.", "response": "def rotate(angle, axis, dtype=None):\n    \"\"\"The 3x3 rotation matrix for rotation about a vector.\n\n    Parameters\n    ----------\n    angle : float\n        The angle of rotation, in degrees.\n    axis : ndarray\n        The x, y, z coordinates of the axis direction vector.\n    \"\"\"\n    angle = np.radians(angle)\n    assert len(axis) == 3\n    x, y, z = axis / np.linalg.norm(axis)\n    c, s = math.cos(angle), math.sin(angle)\n    cx, cy, cz = (1 - c) * x, (1 - c) * y, (1 - c) * z\n    M = np.array([[cx * x + c, cy * x - z * s, cz * x + y * s, .0],\n                  [cx * y + z * s, cy * y + c, cz * y - x * s, 0.],\n                  [cx * z - y * s, cy * z + x * s, cz * z + c, 0.],\n                  [0., 0., 0., 1.]], dtype).T\n    return M"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncreates a perspective projection matrix for a single resource set.", "response": "def perspective(fovy, aspect, znear, zfar):\n    \"\"\"Create perspective projection matrix\n\n    Parameters\n    ----------\n    fovy : float\n        The field of view along the y axis.\n    aspect : float\n        Aspect ratio of the view.\n    znear : float\n        Near coordinate of the field of view.\n    zfar : float\n        Far coordinate of the field of view.\n\n    Returns\n    -------\n    M : ndarray\n        Perspective projection matrix (4x4).\n    \"\"\"\n    assert(znear != zfar)\n    h = math.tan(fovy / 360.0 * math.pi) * znear\n    w = h * aspect\n    return frustum(-w, w, -h, h, znear, zfar)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nfinds a 3D transformation matrix that maps points1 onto points2.", "response": "def affine_map(points1, points2):\n    \"\"\" Find a 3D transformation matrix that maps points1 onto points2.\n\n    Arguments are specified as arrays of four 3D coordinates, shape (4, 3).\n    \"\"\"\n    A = np.ones((4, 4))\n    A[:, :3] = points1\n    B = np.ones((4, 4))\n    B[:, :3] = points2\n\n    # solve 3 sets of linear equations to determine\n    # transformation matrix elements\n    matrix = np.eye(4)\n    for i in range(3):\n        # solve Ax = B; x is one row of the desired transformation matrix\n        matrix[i] = np.linalg.solve(A, B[:, i])\n\n    return matrix"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nadds a final message to the message list if no parent profiler.", "response": "def finish(self, msg=None):\n        \"\"\"Add a final message; flush the message list if no parent profiler.\n        \"\"\"\n        if self._finished or self.disable:\n            return        \n        self._finished = True\n        if msg is not None:\n            self(msg)\n        self._new_msg(\"< Exiting %s, total time: %0.4f ms\", \n                      self._name, (ptime.time() - self._firstTime) * 1000)\n        type(self)._depth -= 1\n        if self._depth < 1:\n            self.flush()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _init():\n    global config, _data_path, _allowed_config_keys\n\n    app_dir = _get_vispy_app_dir()\n    if app_dir is not None:\n        _data_path = op.join(app_dir, 'data')\n        _test_data_path = op.join(app_dir, 'test_data')\n    else:\n        _data_path = _test_data_path = None\n\n    # All allowed config keys and the types they may have\n    _allowed_config_keys = {\n        'data_path': string_types,\n        'default_backend': string_types,\n        'gl_backend': string_types,\n        'gl_debug': (bool,),\n        'glir_file': string_types+file_types,\n        'include_path': list,\n        'logging_level': string_types,\n        'qt_lib': string_types,\n        'dpi': (int, type(None)),\n        'profile': string_types + (type(None),),\n        'audit_tests': (bool,),\n        'test_data_path': string_types + (type(None),),\n    }\n\n    # Default values for all config options\n    default_config_options = {\n        'data_path': _data_path,\n        'default_backend': '',\n        'gl_backend': 'gl2',\n        'gl_debug': False,\n        'glir_file': '',\n        'include_path': [],\n        'logging_level': 'info',\n        'qt_lib': 'any',\n        'dpi': None,\n        'profile': None,\n        'audit_tests': False,\n        'test_data_path': _test_data_path,\n    }\n\n    config = Config(**default_config_options)\n\n    try:\n        config.update(**_load_config())\n    except Exception as err:\n        raise Exception('Error while reading vispy config file \"%s\":\\n  %s' %\n                        (_get_config_fname(), err.message))\n    set_log_level(config['logging_level'])\n\n    _parse_command_line_arguments()", "response": "Initialize the hierarchy of modules"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _parse_command_line_arguments():\n    global config\n    # Get command line args for vispy\n    argnames = ['vispy-backend=', 'vispy-gl-debug', 'vispy-glir-file=',\n                'vispy-log=', 'vispy-help', 'vispy-profile=', 'vispy-cprofile',\n                'vispy-dpi=', 'vispy-audit-tests']\n    try:\n        opts, args = getopt.getopt(sys.argv[1:], '', argnames)\n    except getopt.GetoptError:\n        opts = []\n    # Use them to set the config values\n    for o, a in opts:\n        if o.startswith('--vispy'):\n            if o == '--vispy-backend':\n                config['default_backend'] = a\n                logger.info('vispy backend: %s', a)\n            elif o == '--vispy-gl-debug':\n                config['gl_debug'] = True\n            elif o == '--vispy-glir-file':\n                config['glir_file'] = a\n            elif o == '--vispy-log':\n                if ',' in a:\n                    verbose, match = a.split(',')\n                else:\n                    verbose = a\n                    match = None\n                config['logging_level'] = a\n                set_log_level(verbose, match)\n            elif o == '--vispy-profile':\n                config['profile'] = a\n            elif o == '--vispy-cprofile':\n                _enable_profiling()\n            elif o == '--vispy-help':\n                print(VISPY_HELP)\n            elif o == '--vispy-dpi':\n                config['dpi'] = int(a)\n            elif o == '--vispy-audit-tests':\n                config['audit_tests'] = True\n            else:\n                logger.warning(\"Unsupported vispy flag: %s\" % o)", "response": "Parse command line arguments and set them into the vispy config."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsaves the current configuration to vispy config file.", "response": "def save_config(**kwargs):\n    \"\"\"Save configuration keys to vispy config file\n\n    Parameters\n    ----------\n    **kwargs : keyword arguments\n        Key/value pairs to save to the config file.\n    \"\"\"\n    if kwargs == {}:\n        kwargs = config._config\n    current_config = _load_config()\n    current_config.update(**kwargs)\n    # write to disk\n    fname = _get_config_fname()\n    if fname is None:\n        raise RuntimeError('config filename could not be determined')\n    if not op.isdir(op.dirname(fname)):\n        os.mkdir(op.dirname(fname))\n    with open(fname, 'w') as fid:\n        json.dump(current_config, fid, sort_keys=True, indent=0)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset the vispy data download directory.", "response": "def set_data_dir(directory=None, create=False, save=False):\n    \"\"\"Set vispy data download directory\n\n    Parameters\n    ----------\n    directory : str | None\n        The directory to use.\n    create : bool\n        If True, create directory if it doesn't exist.\n    save : bool\n        If True, save the configuration to the vispy config.\n    \"\"\"\n    if directory is None:\n        directory = _data_path\n        if _data_path is None:\n            raise IOError('default path cannot be determined, please '\n                          'set it manually (directory != None)')\n    if not op.isdir(directory):\n        if not create:\n            raise IOError('directory \"%s\" does not exist, perhaps try '\n                          'create=True to create it?' % directory)\n        os.mkdir(directory)\n    config.update(data_path=directory)\n    if save:\n        save_config(data_path=directory)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nstarting profiling and register callback to print stats when the program exits.", "response": "def _enable_profiling():\n    \"\"\" Start profiling and register callback to print stats when the program\n    exits.\n    \"\"\"\n    import cProfile\n    import atexit\n    global _profiler\n    _profiler = cProfile.Profile()\n    _profiler.enable()\n    atexit.register(_profile_atexit)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef sys_info(fname=None, overwrite=False):\n    if fname is not None and op.isfile(fname) and not overwrite:\n        raise IOError('file exists, use overwrite=True to overwrite')\n\n    out = ''\n    try:\n        # Nest all imports here to avoid any circular imports\n        from ..app import use_app, Canvas\n        from ..app.backends import BACKEND_NAMES\n        from ..gloo import gl\n        from ..testing import has_backend\n        # get default app\n        with use_log_level('warning'):\n            app = use_app(call_reuse=False)  # suppress messages\n        out += 'Platform: %s\\n' % platform.platform()\n        out += 'Python:   %s\\n' % str(sys.version).replace('\\n', ' ')\n        out += 'Backend:  %s\\n' % app.backend_name\n        for backend in BACKEND_NAMES:\n            if backend.startswith('ipynb_'):\n                continue\n            with use_log_level('warning', print_msg=False):\n                which = has_backend(backend, out=['which'])[1]\n            out += '{0:<9} {1}\\n'.format(backend + ':', which)\n        out += '\\n'\n        # We need an OpenGL context to get GL info\n        canvas = Canvas('Test', (10, 10), show=False, app=app)\n        canvas._backend._vispy_set_current()\n        out += 'GL version:  %r\\n' % (gl.glGetParameter(gl.GL_VERSION),)\n        x_ = gl.GL_MAX_TEXTURE_SIZE\n        out += 'MAX_TEXTURE_SIZE: %r\\n' % (gl.glGetParameter(x_),)\n        out += 'Extensions: %r\\n' % (gl.glGetParameter(gl.GL_EXTENSIONS),)\n        canvas.close()\n    except Exception:  # don't stop printing info\n        out += '\\nInfo-gathering error:\\n%s' % traceback.format_exc()\n        pass\n    if fname is not None:\n        with open(fname, 'w') as fid:\n            fid.write(out)\n    return out", "response": "Get relevant system and debugging information."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef compact(vertices, indices, tolerance=1e-3):\n\n    # Transform vertices into a structured array for np.unique to work\n    n = len(vertices)\n    V = np.zeros(n, dtype=[(\"pos\", np.float32, 3)])\n    V[\"pos\"][:, 0] = vertices[:, 0]\n    V[\"pos\"][:, 1] = vertices[:, 1]\n    V[\"pos\"][:, 2] = vertices[:, 2]\n\n    epsilon = 1e-3\n    decimals = int(np.log(epsilon)/np.log(1/10.))\n\n    # Round all vertices within given decimals\n    V_ = np.zeros_like(V)\n    X = V[\"pos\"][:, 0].round(decimals=decimals)\n    X[np.where(abs(X) < epsilon)] = 0\n\n    V_[\"pos\"][:, 0] = X\n    Y = V[\"pos\"][:, 1].round(decimals=decimals)\n    Y[np.where(abs(Y) < epsilon)] = 0\n    V_[\"pos\"][:, 1] = Y\n\n    Z = V[\"pos\"][:, 2].round(decimals=decimals)\n    Z[np.where(abs(Z) < epsilon)] = 0\n    V_[\"pos\"][:, 2] = Z\n\n    # Find the unique vertices AND the mapping\n    U, RI = np.unique(V_, return_inverse=True)\n\n    # Translate indices from original vertices into the reduced set (U)\n    indices = indices.ravel()\n    I_ = indices.copy().ravel()\n    for i in range(len(indices)):\n        I_[i] = RI[indices[i]]\n    I_ = I_.reshape(len(indices)/3, 3)\n\n    # Return reduced vertices set, transalted indices and mapping that allows\n    # to go from U to V\n    return U.view(np.float32).reshape(len(U), 3), I_, RI", "response": "Compact vertices and indices within given tolerance"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef normals(vertices, indices):\n\n    # Compact similar vertices\n    vertices, indices, mapping = compact(vertices, indices)\n\n    T = vertices[indices]\n    N = np.cross(T[:, 1] - T[:, 0], T[:, 2]-T[:, 0])\n    L = np.sqrt(np.sum(N * N, axis=1))\n    L[L == 0] = 1.0  # prevent divide-by-zero\n    N /= L[:, np.newaxis]\n    normals = np.zeros_like(vertices)\n    normals[indices[:, 0]] += N\n    normals[indices[:, 1]] += N\n    normals[indices[:, 2]] += N\n    L = np.sqrt(np.sum(normals*normals, axis=1))\n    L[L == 0] = 1.0\n    normals /= L[:, np.newaxis]\n\n    return normals[mapping]", "response": "Compute the normals over a triangulated surface."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef create_native(self):\n        if self._backend is not None:\n            return\n        # Make sure that the app is active\n        assert self._app.native\n        # Instantiate the backend with the right class\n        self._app.backend_module.CanvasBackend(self, **self._backend_kwargs)\n        # self._backend = set by BaseCanvasBackend\n        self._backend_kwargs = None  # Clean up\n\n        # Connect to draw event (append to the end)\n        # Process GLIR commands at each paint event\n        self.events.draw.connect(self.context.flush_commands, position='last')\n        if self._autoswap:\n            self.events.draw.connect((self, 'swap_buffers'),\n                                     ref=True, position='last')", "response": "Create the native widget if not already done so."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nconnects a function to an event in the event store.", "response": "def connect(self, fun):\n        \"\"\" Connect a function to an event\n\n        The name of the function\n        should be on_X, with X the name of the event (e.g. 'on_draw').\n\n        This method is typically used as a decorator on a function\n        definition for an event handler.\n\n        Parameters\n        ----------\n        fun : callable\n            The function.\n        \"\"\"\n        # Get and check name\n        name = fun.__name__\n        if not name.startswith('on_'):\n            raise ValueError('When connecting a function based on its name, '\n                             'the name should start with \"on_\"')\n        eventname = name[3:]\n        # Get emitter\n        try:\n            emitter = self.events[eventname]\n        except KeyError:\n            raise ValueError(\n                'Event \"%s\" not available on this canvas.' %\n                eventname)\n        # Connect\n        emitter.connect(fun)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the size of the canvas window", "response": "def size(self):\n        \"\"\" The size of canvas/window \"\"\"\n        size = self._backend._vispy_get_size()\n        return (size[0] // self._px_scale, size[1] // self._px_scale)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef show(self, visible=True, run=False):\n        self._backend._vispy_set_visible(visible)\n        if run:\n            self.app.run()", "response": "Show or hide the canvas."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nclosing the canvas and the backend.", "response": "def close(self):\n        \"\"\"Close the canvas\n\n        Notes\n        -----\n        This will usually destroy the GL context. For Qt, the context\n        (and widget) will be destroyed only if the widget is top-level.\n        To avoid having the widget destroyed (more like standard Qt\n        behavior), consider making the widget a sub-widget.\n        \"\"\"\n        if self._backend is not None and not self._closed:\n            self._closed = True\n            self.events.close()\n            self._backend._vispy_close()\n        forget_canvas(self)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _update_fps(self, event):\n        self._frame_count += 1\n        diff = time() - self._basetime\n        if (diff > self._fps_window):\n            self._fps = self._frame_count / diff\n            self._basetime = time()\n            self._frame_count = 0\n            self._fps_callback(self.fps)", "response": "Update the fps after every window"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nmeasuring the current FPS of the current entry.", "response": "def measure_fps(self, window=1, callback='%1.1f FPS'):\n        \"\"\"Measure the current FPS\n\n        Sets the update window, connects the draw event to update_fps\n        and sets the callback function.\n\n        Parameters\n        ----------\n        window : float\n            The time-window (in seconds) to calculate FPS. Default 1.0.\n        callback : function | str\n            The function to call with the float FPS value, or the string\n            to be formatted with the fps value and then printed. The\n            default is ``'%1.1f FPS'``. If callback evaluates to False, the\n            FPS measurement is stopped.\n        \"\"\"\n        # Connect update_fps function to draw\n        self.events.draw.disconnect(self._update_fps)\n        if callback:\n            if isinstance(callback, string_types):\n                callback_str = callback  # because callback gets overwritten\n\n                def callback(x):\n                    print(callback_str % x)\n\n            self._fps_window = window\n            self.events.draw.connect(self._update_fps)\n            self._fps_callback = callback\n        else:\n            self._fps_callback = None"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nrenders the canvas to an offscreen buffer and return the image.", "response": "def render(self):\n        \"\"\" Render the canvas to an offscreen buffer and return the image\n        array.\n\n        Returns\n        -------\n        image : array\n            Numpy array of type ubyte and shape (h, w, 4). Index [0, 0] is the \n            upper-left corner of the rendered region.\n        \n        \"\"\"\n        self.set_current()\n        size = self.physical_size\n        fbo = FrameBuffer(color=RenderBuffer(size[::-1]),\n                          depth=RenderBuffer(size[::-1]))\n\n        try:\n            fbo.activate()\n            self.events.draw()\n            return fbo.read()\n        finally:\n            fbo.deactivate()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef drag_events(self):\n        if not self.is_dragging:\n            return None\n\n        event = self\n        events = []\n        while True:\n            # mouse_press events can only be the start of a trail\n            if event is None or event.type == 'mouse_press':\n                break\n            events.append(event)\n            event = event.last_event\n\n        return events[::-1]", "response": "Return a list of all mouse events in the current drag operation."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns an array of mouse coordinates for every event in the current mouse drag operation.", "response": "def trail(self):\n        \"\"\" Return an (N, 2) array of mouse coordinates for every event in the\n        current mouse drag operation.\n\n        Returns None if there is no current drag operation.\n        \"\"\"\n        events = self.drag_events()\n        if events is None:\n            return None\n\n        trail = np.empty((len(events), 2), dtype=int)\n        for i, ev in enumerate(events):\n            trail[i] = ev.pos\n\n        return trail"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef width_min(self, width_min):\n\n        if width_min is None:\n            self._width_limits[0] = 0\n            return\n\n        width_min = float(width_min)\n        assert(0 <= width_min)\n\n        self._width_limits[0] = width_min\n        self._update_layout()", "response": "Sets the minimum height of the widget\n           "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsetting the maximum width of the widget.", "response": "def width_max(self, width_max):\n        \"\"\"Set the maximum width of the widget.\n\n        Parameters\n        ----------\n        width_max: None | float\n            the maximum width of the widget. if None, maximum width\n            is unbounded\n        \"\"\"\n        if width_max is None:\n            self._width_limits[1] = None\n            return\n\n        width_max = float(width_max)\n        assert(self.width_min <= width_max)\n\n        self._width_limits[1] = width_max\n        self._update_layout()"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsets the minimum height of the widget", "response": "def height_min(self, height_min):\n        \"\"\"Set the minimum height of the widget\n\n        Parameters\n        ----------\n\n        height_min: float\n            the minimum height of the widget\n        \"\"\"\n        if height_min is None:\n            self._height_limits[0] = 0\n            return\n\n        height_min = float(height_min)\n        assert(height_min >= 0)\n\n        self._height_limits[0] = height_min\n        self._update_layout()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef height_max(self, height_max):\n        if height_max is None:\n            self._height_limits[1] = None\n            return\n\n        height_max = float(height_max)\n        assert(0 <= self.height_min <= height_max)\n        self._height_limits[1] = height_max\n        self._update_layout()", "response": "Sets the maximum height of the widget."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef inner_rect(self):\n        m = self.margin + self._border_width + self.padding\n        if not self.border_color.is_blank:\n            m += 1\n        return Rect((m, m), (self.size[0]-2*m, self.size[1]-2*m))", "response": "The rectangular area inside the margin border and padding."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncall whenever the clipper for this widget needs to be updated.", "response": "def _update_clipper(self):\n        \"\"\"Called whenever the clipper for this widget may need to be updated.\n        \"\"\"\n        if self.clip_children and self._clipper is None:\n            self._clipper = Clipper()\n        elif not self.clip_children:\n            self._clipper = None\n\n        if self._clipper is None:\n            return\n        self._clipper.rect = self.inner_rect\n        self._clipper.transform = self.get_transform('framebuffer', 'visual')"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nupdating the border line to match new shape", "response": "def _update_line(self):\n        \"\"\" Update border line to match new shape \"\"\"\n        w = self._border_width\n        m = self.margin\n        # border is drawn within the boundaries of the widget:\n        #\n        #  size = (8, 7)  margin=2\n        #  internal rect = (3, 3, 2, 1)\n        #  ........\n        #  ........\n        #  ..BBBB..\n        #  ..B  B..\n        #  ..BBBB..\n        #  ........\n        #  ........\n        #\n        l = b = m\n        r = self.size[0] - m\n        t = self.size[1] - m\n        pos = np.array([\n            [l, b], [l+w, b+w],\n            [r, b], [r-w, b+w],\n            [r, t], [r-w, t-w],\n            [l, t], [l+w, t-w],\n        ], dtype=np.float32)\n        faces = np.array([\n            [0, 2, 1],\n            [1, 2, 3],\n            [2, 4, 3],\n            [3, 5, 4],\n            [4, 5, 6],\n            [5, 7, 6],\n            [6, 0, 7],\n            [7, 0, 1],\n            [5, 3, 1],\n            [1, 5, 7],\n        ], dtype=np.int32)\n        start = 8 if self._border_color.is_blank else 0\n        stop = 8 if self._bgcolor.is_blank else 10\n        face_colors = None\n        if self._face_colors is not None:\n            face_colors = self._face_colors[start:stop]\n        self._mesh.set_data(vertices=pos, faces=faces[start:stop],\n                            face_colors=face_colors)\n\n        # picking mesh covers the entire area\n        self._picking_mesh.set_data(vertices=pos[::2])"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef add_widget(self, widget):\n        self._widgets.append(widget)\n        widget.parent = self\n        self._update_child_widgets()\n        return widget", "response": "Adds a Widget as a managed child of this Widget."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating a new Grid and add it as a child widget.", "response": "def add_grid(self, *args, **kwargs):\n        \"\"\"\n        Create a new Grid and add it as a child widget.\n\n        All arguments are given to Grid().\n        \"\"\"\n        from .grid import Grid\n        grid = Grid(*args, **kwargs)\n        return self.add_widget(grid)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating a new ViewBox and add it as a child widget.", "response": "def add_view(self, *args, **kwargs):\n        \"\"\"\n        Create a new ViewBox and add it as a child widget.\n\n        All arguments are given to ViewBox().\n        \"\"\"\n        from .viewbox import ViewBox\n        view = ViewBox(*args, **kwargs)\n        return self.add_widget(view)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef remove_widget(self, widget):\n        self._widgets.remove(widget)\n        widget.parent = None\n        self._update_child_widgets()", "response": "Removes a Widget as a managed child of this Widget."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef pack_unit(value):\n    pack = np.zeros(value.shape + (4,), dtype=np.ubyte)\n    for i in range(4):\n        value, pack[..., i] = np.modf(value * 256.)\n    return pack", "response": "Packs float values between 0 1 into 4 unsigned int8\n    Returns ------- array\n    packed interpolation kernel\n   "}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef pack_ieee(value):\n    return np.fromstring(value.tostring(),\n                         np.ubyte).reshape((value.shape + (4,)))", "response": "Packs float ieee binary representation into 4 unsigned int8\n    Returns ndarray of packed ieee binary representation"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef load_spatial_filters(packed=True):\n    names = (\"Bilinear\", \"Hanning\", \"Hamming\", \"Hermite\",\n             \"Kaiser\", \"Quadric\", \"Bicubic\", \"CatRom\",\n             \"Mitchell\", \"Spline16\", \"Spline36\", \"Gaussian\",\n             \"Bessel\", \"Sinc\", \"Lanczos\", \"Blackman\", \"Nearest\")\n\n    kernel = np.load(op.join(DATA_DIR, 'spatial-filters.npy'))\n    if packed:\n        # convert the kernel to a packed representation\n        kernel = pack_unit(kernel)\n\n    return kernel, names", "response": "Load spatial - filters kernel and names"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef list_fonts():\n    vals = _list_fonts()\n    for font in _vispy_fonts:\n        vals += [font] if font not in vals else []\n    vals = sorted(vals, key=lambda s: s.lower())\n    return vals", "response": "List system fonts returning a list of all available system fonts."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _process_backend_kwargs(self, kwargs):\n        # Verify given argument with capability of the backend\n        app = self._vispy_canvas.app\n        capability = app.backend_module.capability\n        if kwargs['context'].shared.name:  # name already assigned: shared\n            if not capability['context']:\n                raise RuntimeError('Cannot share context with this backend')\n        for key in [key for (key, val) in capability.items() if not val]:\n            if key in ['context', 'multi_window', 'scroll']:\n                continue\n            invert = key in ['resizable', 'decorate']\n            if bool(kwargs[key]) - invert:\n                raise RuntimeError('Config %s is not supported by backend %s'\n                                   % (key, app.backend_name))\n\n        # Return items in sequence\n        out = SimpleBunch()\n        keys = ['title', 'size', 'position', 'show', 'vsync', 'resizable',\n                'decorate', 'fullscreen', 'parent', 'context', 'always_on_top',\n                ]\n        for key in keys:\n            out[key] = kwargs[key]\n        return out", "response": "Internal method to retrieve the kwargs from the backend module."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsetting the view range.", "response": "def _set_range(self, init):\n        \"\"\" Reset the view.\n        \"\"\"\n\n        #PerspectiveCamera._set_range(self, init)\n\n        # Stop moving\n        self._speed *= 0.0\n\n        # Get window size (and store factor now to sync with resizing)\n        w, h = self._viewbox.size\n        w, h = float(w), float(h)\n\n        # Get range and translation for x and y\n        x1, y1, z1 = self._xlim[0], self._ylim[0], self._zlim[0]\n        x2, y2, z2 = self._xlim[1], self._ylim[1], self._zlim[1]\n        rx, ry, rz = (x2 - x1), (y2 - y1), (z2 - z1)\n\n        # Correct ranges for window size. Note that the window width\n        # influences the x and y data range, while the height influences\n        # the z data range.\n        if w / h > 1:\n            rx /= w / h\n            ry /= w / h\n        else:\n            rz /= h / w\n\n        # Do not convert to screen coordinates. This camera does not need\n        # to fit everything on screen, but we need to estimate the scale\n        # of the data in the scene.\n\n        # Set scale, depending on data range. Initial speed is such that\n        # the scene can be traversed in about three seconds.\n        self._scale_factor = max(rx, ry, rz) / 3.0\n\n        # Set initial position to a corner of the scene\n        margin = np.mean([rx, ry, rz]) * 0.1\n        self._center = x1 - margin, y1 - margin, z1 + margin\n\n        # Determine initial view direction based on flip axis\n        yaw = 45 * self._flip_factors[0]\n        pitch = -90 - 20 * self._flip_factors[2]\n        if self._flip_factors[1] < 0:\n            yaw += 90 * np.sign(self._flip_factors[0])\n\n        # Set orientation\n        q1 = Quaternion.create_from_axis_angle(pitch*math.pi/180, 1, 0, 0)\n        q2 = Quaternion.create_from_axis_angle(0*math.pi/180, 0, 1, 0)\n        q3 = Quaternion.create_from_axis_angle(yaw*math.pi/180, 0, 0, 1)\n        #\n        self._rotation1 = (q1 * q2 * q3).normalize()\n        self._rotation2 = Quaternion()\n\n        # Update\n        self.view_changed()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef on_timer(self, event):\n\n        # Set relative speed and acceleration\n        rel_speed = event.dt\n        rel_acc = 0.1\n\n        # Get what's forward\n        pf, pr, pl, pu = self._get_directions()\n\n        # Increase speed through acceleration\n        # Note that self._speed is relative. We can balance rel_acc and\n        # rel_speed to get a nice smooth or direct control\n        self._speed += self._acc * rel_acc\n\n        # Reduce speed. Simulate resistance. Using brakes slows down faster.\n        # Note that the way that we reduce speed, allows for higher\n        # speeds if keys ar bound to higher acc values (i.e. turbo)\n        reduce = np.array([0.05, 0.05, 0.05, 0.1, 0.1, 0.1])\n        reduce[self._brake > 0] = 0.2\n        self._speed -= self._speed * reduce\n        if np.abs(self._speed).max() < 0.05:\n            self._speed *= 0.0\n\n        # --- Determine new position from translation speed\n\n        if self._speed[:3].any():\n\n            # Create speed vectors, use scale_factor as a reference\n            dv = np.array([1.0/d for d in self._flip_factors])\n            #\n            vf = pf * dv * rel_speed * self._scale_factor\n            vr = pr * dv * rel_speed * self._scale_factor\n            vu = pu * dv * rel_speed * self._scale_factor\n            direction = vf, vr, vu\n\n            # Set position\n            center_loc = np.array(self._center, dtype='float32')\n            center_loc += (self._speed[0] * direction[0] +\n                           self._speed[1] * direction[1] +\n                           self._speed[2] * direction[2])\n            self._center = tuple(center_loc)\n\n        # --- Determine new orientation from rotation speed\n\n        roll_angle = 0\n\n        # Calculate manual roll (from speed)\n        if self._speed[3:].any():\n            angleGain = np.array([1.0, 1.5, 1.0]) * 3 * math.pi / 180\n            angles = self._speed[3:] * angleGain\n\n            q1 = Quaternion.create_from_axis_angle(angles[0], -1, 0, 0)\n            q2 = Quaternion.create_from_axis_angle(angles[1], 0, 1, 0)\n            q3 = Quaternion.create_from_axis_angle(angles[2], 0, 0, -1)\n            q = q1 * q2 * q3\n            self._rotation1 = (q * self._rotation1).normalize()\n\n        # Calculate auto-roll\n        if self.auto_roll:\n            up = {'x': (1, 0, 0), 'y': (0, 1, 0), 'z': (0, 0, 1)}[self.up[1]]\n            up = np.array(up) * {'+': +1, '-': -1}[self.up[0]]\n\n            def angle(p1, p2):\n                return np.arccos(p1.dot(p2))\n            #au = angle(pu, (0, 0, 1))\n            ar = angle(pr, up)\n            al = angle(pl, up)\n            af = angle(pf, up)\n            # Roll angle that's off from being leveled (in unit strength)\n            roll_angle = math.sin(0.5*(al - ar))\n            # Correct for pitch\n            roll_angle *= abs(math.sin(af))  # abs(math.sin(au))\n            if abs(roll_angle) < 0.05:\n                roll_angle = 0\n            if roll_angle:\n                # Correct to soften the force at 90 degree angle\n                roll_angle = np.sign(roll_angle) * np.abs(roll_angle)**0.5\n                # Get correction for this iteration and apply\n                angle_correction = 1.0 * roll_angle * math.pi / 180\n                q = Quaternion.create_from_axis_angle(angle_correction,\n                                                      0, 0, 1)\n                self._rotation1 = (q * self._rotation1).normalize()\n\n        # Update\n        if self._speed.any() or roll_angle or self._update_from_mouse:\n            self._update_from_mouse = False\n            self.view_changed()", "response": "This method is called when the event is generated by the event loop."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef viewbox_mouse_event(self, event):\n        PerspectiveCamera.viewbox_mouse_event(self, event)\n\n        if event.handled or not self.interactive:\n            return\n\n        if event.type == 'mouse_wheel':\n            if not event.mouse_event.modifiers:\n                # Move forward / backward\n                self._speed[0] += 0.5 * event.delta[1]\n            elif keys.SHIFT in event.mouse_event.modifiers:\n                # Speed\n                s = 1.1 ** - event.delta[1]\n                self.scale_factor /= s  # divide instead of multiply\n                print('scale factor: %1.1f units/s' % self.scale_factor)\n            return\n\n        if event.type == 'mouse_press':\n            event.handled = True\n\n        if event.type == 'mouse_release':\n            # Reset\n            self._event_value = None\n            # Apply rotation\n            self._rotation1 = (self._rotation2 * self._rotation1).normalize()\n            self._rotation2 = Quaternion()\n        elif not self._timer.running:\n            # Ensure the timer runs\n            self._timer.start()\n\n        if event.type == 'mouse_move':\n\n            if event.press_event is None:\n                return\n            if not event.buttons:\n                return\n\n            # Prepare\n            modifiers = event.mouse_event.modifiers\n            pos1 = event.mouse_event.press_event.pos\n            pos2 = event.mouse_event.pos\n            w, h = self._viewbox.size\n\n            if 1 in event.buttons and not modifiers:\n                # rotate\n\n                # get normalized delta values\n                d_az = -float(pos2[0] - pos1[0]) / w\n                d_el = +float(pos2[1] - pos1[1]) / h\n                # Apply gain\n                d_az *= - 0.5 * math.pi  # * self._speed_rot\n                d_el *= + 0.5 * math.pi  # * self._speed_rot\n                # Create temporary quaternions\n                q_az = Quaternion.create_from_axis_angle(d_az, 0, 1, 0)\n                q_el = Quaternion.create_from_axis_angle(d_el, 1, 0, 0)\n\n                # Apply to global quaternion\n                self._rotation2 = (q_el.normalize() * q_az).normalize()\n\n            elif 2 in event.buttons and keys.CONTROL in modifiers:\n                # zoom --> fov\n                if self._event_value is None:\n                    self._event_value = self._fov\n                p1 = np.array(event.press_event.pos)[:2]\n                p2 = np.array(event.pos)[:2]\n                p1c = event.map_to_canvas(p1)[:2]\n                p2c = event.map_to_canvas(p2)[:2]\n                d = p2c - p1c\n                fov = self._event_value * math.exp(-0.01*d[1])\n                self._fov = min(90.0, max(10, fov))\n\n        # Make transform be updated on the next timer tick.\n        # By doing it at timer tick, we avoid shaky behavior\n        self._update_from_mouse = True", "response": "Handles the viewbox mouse event."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns True if there s something to read on stdin ( posix version.", "response": "def _stdin_ready_posix():\n    \"\"\"Return True if there's something to read on stdin (posix version).\"\"\"\n    infds, outfds, erfds = select.select([sys.stdin],[],[],0)\n    return bool(infds)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsets PyOS_InputHook to callback and return the previous one.", "response": "def set_inputhook(self, callback):\n        \"\"\"Set PyOS_InputHook to callback and return the previous one.\"\"\"\n        # On platforms with 'readline' support, it's all too likely to\n        # have a KeyboardInterrupt signal delivered *even before* an\n        # initial ``try:`` clause in the callback can be executed, so\n        # we need to disable CTRL+C in this situation.\n        ignore_CTRL_C()\n        self._callback = callback\n        self._callback_pyfunctype = self.PYFUNC(callback)\n        pyos_inputhook_ptr = self.get_pyos_inputhook()\n        original = self.get_pyos_inputhook_as_func()\n        pyos_inputhook_ptr.value = \\\n            ctypes.cast(self._callback_pyfunctype, ctypes.c_void_p).value\n        self._installed = True\n        return original"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nclears the PyOS_InputHook and return the previous one.", "response": "def clear_inputhook(self, app=None):\n        \"\"\"Set PyOS_InputHook to NULL and return the previous one.\n\n        Parameters\n        ----------\n        app : optional, ignored\n          This parameter is allowed only so that clear_inputhook() can be\n          called with a similar interface as all the ``enable_*`` methods.  But\n          the actual value of the parameter is ignored.  This uniform interface\n          makes it easier to have user-level entry points in the main IPython\n          app like :meth:`enable_gui`.\"\"\"\n        pyos_inputhook_ptr = self.get_pyos_inputhook()\n        original = self.get_pyos_inputhook_as_func()\n        pyos_inputhook_ptr.value = ctypes.c_void_p(None).value\n        allow_CTRL_C()\n        self._reset()\n        return original"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nclear IPython s internal reference to an application instance.", "response": "def clear_app_refs(self, gui=None):\n        \"\"\"Clear IPython's internal reference to an application instance.\n\n        Whenever we create an app for a user on qt4 or wx, we hold a\n        reference to the app.  This is needed because in some cases bad things\n        can happen if a user doesn't hold a reference themselves.  This\n        method is provided to clear the references we are holding.\n\n        Parameters\n        ----------\n        gui : None or str\n            If None, clear all app references.  If ('wx', 'qt4') clear\n            the app for that toolkit.  References are not held for gtk or tk\n            as those toolkits don't have the notion of an app.\n        \"\"\"\n        if gui is None:\n            self.apps = {}\n        elif gui in self.apps:\n            del self.apps[gui]"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef register(self, toolkitname, *aliases):\n        def decorator(cls):\n            inst = cls(self)\n            self.guihooks[toolkitname] = inst\n            for a in aliases:\n                self.aliases[a] = toolkitname\n            return cls\n        return decorator", "response": "Register a class to provide the event loop for a given GUI."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef enable_gui(self, gui=None, app=None):\n        if gui in (None, GUI_NONE):\n            return self.disable_gui()\n        \n        if gui in self.aliases:\n            return self.enable_gui(self.aliases[gui], app)\n        \n        try:\n            gui_hook = self.guihooks[gui]\n        except KeyError:\n            e = \"Invalid GUI request {!r}, valid ones are: {}\"\n            raise ValueError(e.format(gui, ', '.join(self.guihooks)))\n        self._current_gui = gui\n\n        app = gui_hook.enable(app)\n        if app is not None:\n            app._in_event_loop = True\n            self.apps[gui] = app        \n        return app", "response": "Switch amongst GUI input hooks by name."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ndisable GUI event loop integration.", "response": "def disable_gui(self):\n        \"\"\"Disable GUI event loop integration.\n        \n        If an application was registered, this sets its ``_in_event_loop``\n        attribute to False. It then calls :meth:`clear_inputhook`.\n        \"\"\"\n        gui = self._current_gui\n        if gui in self.apps:\n            self.apps[gui]._in_event_loop = False\n        return self.clear_inputhook()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef set_current_canvas(canvas):\n    # Notify glir \n    canvas.context._do_CURRENT_command = True\n    # Try to be quick\n    if canvasses and canvasses[-1]() is canvas:\n        return\n    # Make this the current\n    cc = [c() for c in canvasses if c() is not None]\n    while canvas in cc:\n        cc.remove(canvas)\n    cc.append(canvas)\n    canvasses[:] = [weakref.ref(c) for c in cc]", "response": "Make a canvas active. Used primarily by the canvas itself."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nforgetting about the given canvas. Used by the canvas when closed.", "response": "def forget_canvas(canvas):\n    \"\"\" Forget about the given canvas. Used by the canvas when closed.\n    \"\"\"\n    cc = [c() for c in canvasses if c() is not None]\n    while canvas in cc:\n        cc.remove(canvas)\n    canvasses[:] = [weakref.ref(c) for c in cc]"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef create_shared(self, name, ref):\n        if self._shared is not None:\n            raise RuntimeError('Can only set_shared once.')\n        self._shared = GLShared(name, ref)", "response": "Create the shared object."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nflushes the current command list.", "response": "def flush_commands(self, event=None):\n        \"\"\" Flush\n\n        Parameters\n        ----------\n        event : instance of Event\n            The event.\n        \"\"\"\n        if self._do_CURRENT_command:\n            self._do_CURRENT_command = False\n            canvas = get_current_canvas()\n            if canvas and hasattr(canvas, '_backend'):\n                fbo = canvas._backend._vispy_get_fb_bind_location()\n            else:\n                fbo = 0\n            self.shared.parser.parse([('CURRENT', 0, fbo)])\n        self.glir.flush(self.shared.parser)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef add_ref(self, name, ref):\n        if self._name is None:\n            self._name = name\n        elif name != self._name:\n            raise RuntimeError('Contexts can only share between backends of '\n                               'the same type')\n        self._refs.append(weakref.ref(ref))", "response": "Add a weakref to the backend object that gives access\n       "}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef ref(self):\n        # Clean\n        self._refs = [r for r in self._refs if (r() is not None)]\n        # Get ref\n        ref = self._refs[0]() if self._refs else None\n        if ref is not None:\n            return ref\n        else:\n            raise RuntimeError('No reference for available for GLShared')", "response": "A weakref to an object holding the low - level object store and a low - level object store."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget the DPI from the OS .", "response": "def get_dpi(raise_error=True):\n    \"\"\"Get screen DPI from the OS\n\n    Parameters\n    ----------\n    raise_error : bool\n        If True, raise an error if DPI could not be determined.\n\n    Returns\n    -------\n    dpi : float\n        Dots per inch of the primary screen.\n    \"\"\"\n    display = quartz.CGMainDisplayID()\n    mm = quartz.CGDisplayScreenSize(display)\n    px = quartz.CGDisplayBounds(display).size\n    return (px.width/mm.width + px.height/mm.height) * 0.5 * 25.4"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nlinks this Varying to another object from which it will derive its dtype.", "response": "def link(self, var):\n        \"\"\" Link this Varying to another object from which it will derive its\n        dtype. This method is used internally when assigning an attribute to\n        a varying using syntax ``Function[varying] = attr``.\n        \"\"\"\n        assert self._dtype is not None or hasattr(var, 'dtype')\n        self._link = var\n        self.changed()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef obj(x):\n    \n    j = np.arange(1, 6)\n    tmp1 = np.dot(j, np.cos((j+1)*x[0] + j))\n    tmp2 = np.dot(j, np.cos((j+1)*x[1] + j))\n    return tmp1 * tmp2", "response": "Two Dimensional Shubert Function"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef besj(self, x, n):\n        '''\n        Function BESJ calculates Bessel function of first kind of order n\n        Arguments:\n            n - an integer (>=0), the order\n            x - value at which the Bessel function is required\n        --------------------\n        C++ Mathematical Library\n        Converted from equivalent FORTRAN library\n        Converted by Gareth Walker for use by course 392 computational project\n        All functions tested and yield the same results as the corresponding\n        FORTRAN versions.\n\n        If you have any problems using these functions please report them to\n        M.Muldoon@UMIST.ac.uk\n\n        Documentation available on the web\n        http://www.ma.umist.ac.uk/mrm/Teaching/392/libs/392.html\n        Version 1.0   8/98\n        29 October, 1999\n        --------------------\n        Adapted for use in AGG library by\n                    Andy Wilk (castor.vulgaris@gmail.com)\n        Adapted for use in vispy library by\n                    Nicolas P. Rougier (Nicolas.Rougier@inria.fr)\n        -----------------------------------------------------------------------\n        '''\n        if n < 0:\n            return 0.0\n\n        d = 1e-6\n        b = 0\n        if math.fabs(x) <= d:\n            if n != 0:\n                return 0\n            return 1\n\n        b1 = 0  # b1 is the value from the previous iteration\n        # Set up a starting order for recurrence\n        m1 = int(math.fabs(x)) + 6\n        if math.fabs(x) > 5:\n            m1 = int(math.fabs(1.4 * x + 60 / x))\n\n        m2 = int(n + 2 + math.fabs(x) / 4)\n        if m1 > m2:\n            m2 = m1\n\n        # Apply recurrence down from curent max order\n        while True:\n            c3 = 0\n            c2 = 1e-30\n            c4 = 0\n            m8 = 1\n            if m2 / 2 * 2 == m2:\n                m8 = -1\n\n            imax = m2 - 2\n            for i in range(1, imax+1):\n                c6 = 2 * (m2 - i) * c2 / x - c3\n                c3 = c2\n                c2 = c6\n                if m2 - i - 1 == n:\n                    b = c6\n                m8 = -1 * m8\n                if m8 > 0:\n                    c4 = c4 + 2 * c6\n\n            c6 = 2 * c2 / x - c3\n            if n == 0:\n                b = c6\n            c4 += c6\n            b /= c4\n            if math.fabs(b - b1) < d:\n                return b\n            b1 = b\n            m2 += 3", "response": "Function BESJ calculates the Bessel function of the first kind of order n from the curent value x."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating an exact copy of this quaternion.", "response": "def copy(self):\n        \"\"\" Create an exact copy of this quaternion. \n        \"\"\"\n        return Quaternion(self.w, self.x, self.y, self.z, False)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the norm of the quaternion", "response": "def norm(self):\n        \"\"\" Returns the norm of the quaternion\n        \n        norm = w**2 + x**2 + y**2 + z**2\n        \"\"\"\n        tmp = self.w**2 + self.x**2 + self.y**2 + self.z**2\n        return tmp**0.5"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nnormalizing the quaternion length.", "response": "def _normalize(self):\n        \"\"\" Make the quaternion unit length.\n        \"\"\"\n        # Get length\n        L = self.norm()\n        if not L:\n            raise ValueError('Quaternion cannot have 0-length.')\n        # Correct\n        self.w /= L\n        self.x /= L\n        self.y /= L\n        self.z /= L"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef conjugate(self):\n        new = self.copy()\n        new.x *= -1\n        new.y *= -1\n        new.z *= -1\n        return new", "response": "Return the conjugate of the quaternion."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the inverse of the current object", "response": "def inverse(self):\n        \"\"\" returns q.conjugate()/q.norm()**2\n        \n        So if the quaternion is unit length, it is the same\n        as the conjugate.\n        \"\"\"\n        new = self.conjugate()\n        tmp = self.norm()**2\n        new.w /= tmp\n        new.x /= tmp\n        new.y /= tmp\n        new.z /= tmp\n        return new"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef exp(self):\n        \n        # Init\n        vecNorm = self.x**2 + self.y**2 + self.z**2\n        wPart = np.exp(self.w)        \n        q = Quaternion()\n        \n        # Calculate\n        q.w = wPart * np.cos(vecNorm)\n        q.x = wPart * self.x * np.sin(vecNorm) / vecNorm\n        q.y = wPart * self.y * np.sin(vecNorm) / vecNorm\n        q.z = wPart * self.z * np.sin(vecNorm) / vecNorm\n        \n        return q", "response": "Returns the exponent of the quaternion. \n        ( not tested )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef log(self):\n        \n        # Init\n        norm = self.norm()\n        vecNorm = self.x**2 + self.y**2 + self.z**2\n        tmp = self.w / norm\n        q = Quaternion()\n        \n        # Calculate\n        q.w = np.log(norm)\n        q.x = np.log(norm) * self.x * np.arccos(tmp) / vecNorm\n        q.y = np.log(norm) * self.y * np.arccos(tmp) / vecNorm\n        q.z = np.log(norm) * self.z * np.arccos(tmp) / vecNorm\n        \n        return q", "response": "Returns the natural logarithm of the quaternion. \n        ( not tested )"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef rotate_point(self, p):\n        # Prepare \n        p = Quaternion(0, p[0], p[1], p[2], False)  # Do not normalize!\n        q1 = self.normalize()\n        q2 = self.inverse()\n        # Apply rotation\n        r = (q1*p)*q2\n        # Make point and return        \n        return r.x, r.y, r.z", "response": "Rotate a Point instance using this quaternion."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate a 4x4 homography matrix that represents the rotation of the quaternion.", "response": "def get_matrix(self):\n        \"\"\" Create a 4x4 homography matrix that represents the rotation\n        of the quaternion.\n        \"\"\"\n        # Init matrix (remember, a matrix, not an array)\n        a = np.zeros((4, 4), dtype=np.float32)\n        w, x, y, z = self.w, self.x, self.y, self.z\n        # First row\n        a[0, 0] = - 2.0 * (y * y + z * z) + 1.0\n        a[1, 0] = + 2.0 * (x * y + z * w)\n        a[2, 0] = + 2.0 * (x * z - y * w)\n        a[3, 0] = 0.0\n        # Second row\n        a[0, 1] = + 2.0 * (x * y - z * w)\n        a[1, 1] = - 2.0 * (x * x + z * z) + 1.0\n        a[2, 1] = + 2.0 * (z * y + x * w)\n        a[3, 1] = 0.0\n        # Third row\n        a[0, 2] = + 2.0 * (x * z + y * w)\n        a[1, 2] = + 2.0 * (y * z - x * w)\n        a[2, 2] = - 2.0 * (x * x + y * y) + 1.0\n        a[3, 2] = 0.0\n        # Fourth row\n        a[0, 3] = 0.0\n        a[1, 3] = 0.0\n        a[2, 3] = 0.0\n        a[3, 3] = 1.0\n        return a"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_axis_angle(self):\n        # Init\n        angle = 2 * np.arccos(max(min(self.w, 1.), -1.))\n        scale = (self.x**2 + self.y**2 + self.z**2)**0.5    \n        \n        # Calc axis\n        if scale:\n            ax = self.x / scale\n            ay = self.y / scale\n            az = self.z / scale\n        else:\n            # No rotation, so arbitrary axis\n            ax, ay, az = 1, 0, 0\n        # Return\n        return angle, ax, ay, az", "response": "Get the axis - angle representation of the quaternion."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating a quaternion from an axis - angle representation.", "response": "def create_from_axis_angle(cls, angle, ax, ay, az, degrees=False):\n        \"\"\" Classmethod to create a quaternion from an axis-angle representation. \n        (angle should be in radians).\n        \"\"\"\n        if degrees:\n            angle = np.radians(angle)\n        while angle < 0:\n            angle += np.pi*2\n        angle2 = angle/2.0\n        sinang2 = np.sin(angle2)\n        return Quaternion(np.cos(angle2), ax*sinang2, ay*sinang2, az*sinang2)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating a quaternion given the euler angles.", "response": "def create_from_euler_angles(cls, rx, ry, rz, degrees=False):\n        \"\"\" Classmethod to create a quaternion given the euler angles.\n        \"\"\"\n        if degrees:\n            rx, ry, rz = np.radians([rx, ry, rz])\n        # Obtain quaternions\n        qx = Quaternion(np.cos(rx/2), 0, 0, np.sin(rx/2))\n        qy = Quaternion(np.cos(ry/2), 0, np.sin(ry/2), 0)\n        qz = Quaternion(np.cos(rz/2), np.sin(rz/2), 0, 0)\n        # Almost done\n        return qx*qy*qz"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nturns a possibly string enum into an integer enum.", "response": "def as_enum(enum):\n    \"\"\" Turn a possibly string enum into an integer enum.\n    \"\"\"\n    if isinstance(enum, string_types):\n        try:\n            enum = getattr(gl, 'GL_' + enum.upper())\n        except AttributeError:\n            try:\n                enum = _internalformats['GL_' + enum.upper()]\n            except KeyError:\n                raise ValueError('Could not find int value for enum %r' % enum)\n    return enum"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nconvert the shaders in the order they appear in the order they appear.", "response": "def convert_shaders(convert, shaders):\n    \"\"\" Modify shading code so that we can write code once\n    and make it run \"everywhere\".\n    \"\"\"\n\n    # New version of the shaders\n    out = []\n\n    if convert == 'es2':\n\n        for isfragment, shader in enumerate(shaders):\n            has_version = False\n            has_prec_float = False\n            has_prec_int = False\n            lines = []\n            # Iterate over lines\n            for line in shader.lstrip().splitlines():\n                if line.startswith('#version'):\n                    has_version = True\n                    continue\n                if line.startswith('precision '):\n                    has_prec_float = has_prec_float or 'float' in line\n                    has_prec_int = has_prec_int or 'int' in line\n                lines.append(line.rstrip())\n            # Write\n            # BUG: fails on WebGL (Chrome)\n            # if True:\n            #     lines.insert(has_version, '#line 0')\n            if not has_prec_float:\n                lines.insert(has_version, 'precision highp float;')\n            if not has_prec_int:\n                lines.insert(has_version, 'precision highp int;')\n            # BUG: fails on WebGL (Chrome)\n            # if not has_version:\n            #     lines.insert(has_version, '#version 100')\n            out.append('\\n'.join(lines))\n\n    elif convert == 'desktop':\n\n        for isfragment, shader in enumerate(shaders):\n            has_version = False\n            lines = []\n            # Iterate over lines\n            for line in shader.lstrip().splitlines():\n                has_version = has_version or line.startswith('#version')\n                if line.startswith('precision '):\n                    line = ''\n                for prec in (' highp ', ' mediump ', ' lowp '):\n                    line = line.replace(prec, ' ')\n                lines.append(line.rstrip())\n            # Write\n            if not has_version:\n                lines.insert(0, '#version 120\\n')\n            out.append('\\n'.join(lines))\n\n    else:\n        raise ValueError('Cannot convert shaders to %r.' % convert)\n\n    return tuple(out)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nconvert a desktop command so it works on es2.", "response": "def as_es2_command(command):\n    \"\"\" Modify a desktop command so it works on es2.\n    \"\"\"\n\n    if command[0] == 'FUNC':\n        return (command[0], re.sub(r'^gl([A-Z])',\n                lambda m: m.group(1).lower(), command[1])) + command[2:]\n    if command[0] == 'SHADERS':\n        return command[:2] + convert_shaders('es2', command[2:])\n    if command[0] == 'UNIFORM':\n        return command[:-1] + (command[-1].tolist(),)\n    return command"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _check_pyopengl_3D():\n    global USE_TEX_3D\n    USE_TEX_3D = True\n    try:\n        import OpenGL.GL as _gl\n    except ImportError:\n        raise ImportError('PyOpenGL is required for 3D texture support')\n    return _gl", "response": "Helper to ensure users have OpenGL for 3D texture support"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nprint the list of currently in the queue.", "response": "def show(self, filter=None):\n        \"\"\" Print the list of commands currently in the queue. If filter is\n        given, print only commands that match the filter.\n        \"\"\"\n        for command in self._commands:\n            if command[0] is None:  # or command[1] in self._invalid_objects:\n                continue  # Skip nill commands\n            if filter and command[0] != filter:\n                continue\n            t = []\n            for e in command:\n                if isinstance(e, np.ndarray):\n                    t.append('array %s' % str(e.shape))\n                elif isinstance(e, str):\n                    s = e.strip()\n                    if len(s) > 20:\n                        s = s[:18] + '... %i lines' % (e.count('\\n')+1)\n                    t.append(s)\n                else:\n                    t.append(e)\n            print(tuple(t))"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nflushes all current commands to the GLIR interpreter.", "response": "def flush(self, parser):\n        \"\"\" Flush all current commands to the GLIR interpreter.\n        \"\"\"\n        if self._verbose:\n            show = self._verbose if isinstance(self._verbose, str) else None\n            self.show(show)\n        parser.parse(self._filter(self.clear(), parser))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _filter(self, commands, parser):\n        resized = set()\n        commands2 = []\n        for command in reversed(commands):\n            if command[0] == 'SHADERS':\n                convert = parser.convert_shaders()\n                if convert:\n                    shaders = self._convert_shaders(convert, command[2:])\n                    command = command[:2] + shaders\n            elif command[1] in resized:\n                if command[0] in ('SIZE', 'DATA'):\n                    continue  # remove this command\n            elif command[0] == 'SIZE':\n                resized.add(command[1])\n            commands2.append(command)\n        return list(reversed(commands2))", "response": "Filter DATA or SIZE commands that are overridden by a\n        SIZE command."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nassociating this queue with another.", "response": "def associate(self, queue):\n        \"\"\"Merge this queue with another.\n\n        Both queues will use a shared command list and either one can be used\n        to fill or flush the shared queue.\n        \"\"\"\n        assert isinstance(queue, GlirQueue)\n        if queue._shared is self._shared:\n            return\n\n        # merge commands\n        self._shared._commands.extend(queue.clear())\n        self._shared._verbose |= queue._shared._verbose\n        self._shared._associations[queue] = None\n        # update queue and all related queues to use the same _shared object\n        for ch in queue._shared._associations:\n            ch._shared = self._shared\n            self._shared._associations[ch] = None\n        queue._shared = self._shared"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _parse(self, command):\n        cmd, id_, args = command[0], command[1], command[2:]\n\n        if cmd == 'CURRENT':\n            # This context is made current\n            self.env.clear()\n            self._gl_initialize()\n            self.env['fbo'] = args[0]\n            gl.glBindFramebuffer(gl.GL_FRAMEBUFFER, args[0])\n        elif cmd == 'FUNC':\n            # GL function call\n            args = [as_enum(a) for a in args]\n            try:\n                getattr(gl, id_)(*args)\n            except AttributeError:\n                logger.warning('Invalid gl command: %r' % id_)\n        elif cmd == 'CREATE':\n            # Creating an object\n            if args[0] is not None:\n                klass = self._classmap[args[0]]\n                self._objects[id_] = klass(self, id_)\n            else:\n                self._invalid_objects.add(id_)\n        elif cmd == 'DELETE':\n            # Deleting an object\n            ob = self._objects.get(id_, None)\n            if ob is not None:\n                self._objects[id_] = JUST_DELETED\n                ob.delete()\n        else:\n            # Doing somthing to an object\n            ob = self._objects.get(id_, None)\n            if ob == JUST_DELETED:\n                return\n            if ob is None:\n                if id_ not in self._invalid_objects:\n                    raise RuntimeError('Cannot %s object %i because it '\n                                       'does not exist' % (cmd, id_))\n                return\n            # Triage over command. Order of commands is set so most\n            # common ones occur first.\n            if cmd == 'DRAW':  # Program\n                ob.draw(*args)\n            elif cmd == 'TEXTURE':  # Program\n                ob.set_texture(*args)\n            elif cmd == 'UNIFORM':  # Program\n                ob.set_uniform(*args)\n            elif cmd == 'ATTRIBUTE':  # Program\n                ob.set_attribute(*args)\n            elif cmd == 'DATA':  # VertexBuffer, IndexBuffer, Texture\n                ob.set_data(*args)\n            elif cmd == 'SIZE':  # VertexBuffer, IndexBuffer,\n                ob.set_size(*args)  # Texture[1D, 2D, 3D], RenderBuffer\n            elif cmd == 'ATTACH':  # FrameBuffer\n                ob.attach(*args)\n            elif cmd == 'FRAMEBUFFER':  # FrameBuffer\n                ob.set_framebuffer(*args)\n            elif cmd == 'SHADERS':  # Program\n                ob.set_shaders(*args)\n            elif cmd == 'WRAPPING':  # Texture1D, Texture2D, Texture3D\n                ob.set_wrapping(*args)\n            elif cmd == 'INTERPOLATION':  # Texture1D, Texture2D, Texture3D\n                ob.set_interpolation(*args)\n            else:\n                logger.warning('Invalid GLIR command %r' % cmd)", "response": "Parses a single command."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef parse(self, commands):\n\n        # Get rid of dummy objects that represented deleted objects in\n        # the last parsing round.\n        to_delete = []\n        for id_, val in self._objects.items():\n            if val == JUST_DELETED:\n                to_delete.append(id_)\n        for id_ in to_delete:\n            self._objects.pop(id_)\n\n        for command in commands:\n            self._parse(command)", "response": "Parse a list of commands."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _gl_initialize(self):\n        if '.es' in gl.current_backend.__name__:\n            pass  # ES2: no action required\n        else:\n            # Desktop, enable sprites\n            GL_VERTEX_PROGRAM_POINT_SIZE = 34370\n            GL_POINT_SPRITE = 34913\n            gl.glEnable(GL_VERTEX_PROGRAM_POINT_SIZE)\n            gl.glEnable(GL_POINT_SPRITE)\n        if self.capabilities['max_texture_size'] is None:  # only do once\n            self.capabilities['gl_version'] = gl.glGetParameter(gl.GL_VERSION)\n            self.capabilities['max_texture_size'] = \\\n                gl.glGetParameter(gl.GL_MAX_TEXTURE_SIZE)\n            this_version = self.capabilities['gl_version'].split(' ')[0]\n            this_version = LooseVersion(this_version)", "response": "Deal with compatibility ; desktop does not have sprites\n            enabled by default. ES2 does not have sprites\n            enabled by default."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef activate(self):\n        if self._handle != self._parser.env.get('current_program', False):\n            self._parser.env['current_program'] = self._handle\n            gl.glUseProgram(self._handle)", "response": "Activate the current program."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef deactivate(self):\n        if self._parser.env.get('current_program', 0) != 0:\n            self._parser.env['current_program'] = 0\n            gl.glUseProgram(0)", "response": "Deactivate the current program."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _get_active_attributes_and_uniforms(self):\n        # This match a name of the form \"name[size]\" (= array)\n        regex = re.compile(\"\"\"(?P<name>\\w+)\\s*(\\[(?P<size>\\d+)\\])\\s*\"\"\")\n        # Get how many active attributes and uniforms there are\n        cu = gl.glGetProgramParameter(self._handle, gl.GL_ACTIVE_UNIFORMS)\n        ca = gl.glGetProgramParameter(self.handle, gl.GL_ACTIVE_ATTRIBUTES)\n        # Get info on each one\n        attributes = []\n        uniforms = []\n        for container, count, func in [(attributes, ca, gl.glGetActiveAttrib),\n                                       (uniforms, cu, gl.glGetActiveUniform)]:\n            for i in range(count):\n                name, size, gtype = func(self._handle, i)\n                m = regex.match(name)  # Check if xxx[0] instead of xx\n                if m:\n                    name = m.group('name')\n                    for i in range(size):\n                        container.append(('%s[%d]' % (name, i), gtype))\n                else:\n                    container.append((name, gtype))\n        #return attributes, uniforms\n        return set([v[0] for v in attributes] + [v[0] for v in uniforms])", "response": "Retrieve the active attributes and uniforms for this GLIR program."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _parse_error(self, error):\n        error = str(error)\n        # Nvidia\n        # 0(7): error C1008: undefined variable \"MV\"\n        m = re.match(r'(\\d+)\\((\\d+)\\)\\s*:\\s(.*)', error)\n        if m:\n            return int(m.group(2)), m.group(3)\n        # ATI / Intel\n        # ERROR: 0:131: '{' : syntax error parse error\n        m = re.match(r'ERROR:\\s(\\d+):(\\d+):\\s(.*)', error)\n        if m:\n            return int(m.group(2)), m.group(3)\n        # Nouveau\n        # 0:28(16): error: syntax error, unexpected ')', expecting '('\n        m = re.match(r'(\\d+):(\\d+)\\((\\d+)\\):\\s(.*)', error)\n        if m:\n            return int(m.group(2)), m.group(4)\n        # Other ...\n        return None, error", "response": "Parses a single GLSL error and extracts the linenr and description of the object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _get_error(self, code, errors, indentation=0):\n        # Init\n        results = []\n        lines = None\n        if code is not None:\n            lines = [line.strip() for line in code.split('\\n')]\n\n        for error in errors.split('\\n'):\n            # Strip; skip empy lines\n            error = error.strip()\n            if not error:\n                continue\n            # Separate line number from description (if we can)\n            linenr, error = self._parse_error(error)\n            if None in (linenr, lines):\n                results.append('%s' % error)\n            else:\n                results.append('on line %i: %s' % (linenr, error))\n                if linenr > 0 and linenr < len(lines):\n                    results.append('  %s' % lines[linenr - 1])\n\n        # Add indentation and return\n        results = [' ' * indentation + r for r in results]\n        return '\\n'.join(results)", "response": "Get error and show the faulty line + some context\n        Other GLIR implementations may omit this."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef set_texture(self, name, value):\n        if not self._linked:\n            raise RuntimeError('Cannot set uniform when program has no code')\n        # Get handle for the uniform, first try cache\n        handle = self._handles.get(name, -1)\n        if handle < 0:\n            if name in self._known_invalid:\n                return\n            handle = gl.glGetUniformLocation(self._handle, name)\n            self._unset_variables.discard(name)  # Mark as set\n            self._handles[name] = handle  # Store in cache\n            if handle < 0:\n                self._known_invalid.add(name)\n                logger.info('Variable %s is not an active uniform' % name)\n                return\n        # Program needs to be active in order to set uniforms\n        self.activate()\n        if True:\n            # Sampler: the value is the id of the texture\n            tex = self._parser.get_object(value)\n            if tex == JUST_DELETED:\n                return\n            if tex is None:\n                raise RuntimeError('Could not find texture with id %i' % value)\n            unit = len(self._samplers)\n            if name in self._samplers:\n                unit = self._samplers[name][-1]  # Use existing unit\n            self._samplers[name] = tex._target, tex.handle, unit\n            gl.glUniform1i(handle, unit)", "response": "Set a texture sampler. Value is the id of the texture to link."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsets a uniform value.", "response": "def set_uniform(self, name, type_, value):\n        \"\"\" Set a uniform value. Value is assumed to have been checked.\n        \"\"\"\n        if not self._linked:\n            raise RuntimeError('Cannot set uniform when program has no code')\n        # Get handle for the uniform, first try cache\n        handle = self._handles.get(name, -1)\n        count = 1\n        if handle < 0:\n            if name in self._known_invalid:\n                return\n            handle = gl.glGetUniformLocation(self._handle, name)\n            self._unset_variables.discard(name)  # Mark as set\n            # if we set a uniform_array, mark all as set\n            if not type_.startswith('mat'):\n                count = value.nbytes // (4 * self.ATYPEINFO[type_][0])\n            if count > 1:\n                for ii in range(count):\n                    if '%s[%s]' % (name, ii) in self._unset_variables:\n                        self._unset_variables.discard('%s[%s]' % (name, ii))\n\n            self._handles[name] = handle  # Store in cache\n            if handle < 0:\n                self._known_invalid.add(name)\n                logger.info('Variable %s is not an active uniform' % name)\n                return\n        # Look up function to call\n        funcname = self.UTYPEMAP[type_]\n        func = getattr(gl, funcname)\n        # Program needs to be active in order to set uniforms\n        self.activate()\n        # Triage depending on type\n        if type_.startswith('mat'):\n            # Value is matrix, these gl funcs have alternative signature\n            transpose = False  # OpenGL ES 2.0 does not support transpose\n            func(handle, 1, transpose, value)\n        else:\n            # Regular uniform\n            func(handle, count, value)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef set_attribute(self, name, type_, value):\n        if not self._linked:\n            raise RuntimeError('Cannot set attribute when program has no code')\n        # Get handle for the attribute, first try cache\n        handle = self._handles.get(name, -1)\n        if handle < 0:\n            if name in self._known_invalid:\n                return\n            handle = gl.glGetAttribLocation(self._handle, name)\n            self._unset_variables.discard(name)  # Mark as set\n            self._handles[name] = handle  # Store in cache\n            if handle < 0:\n                self._known_invalid.add(name)\n                if value[0] != 0 and value[2] > 0:  # VBO with offset\n                    return  # Probably an unused element in a structured VBO\n                logger.info('Variable %s is not an active attribute' % name)\n                return\n        # Program needs to be active in order to set uniforms\n        self.activate()\n        # Triage depending on VBO or tuple data\n        if value[0] == 0:\n            # Look up function call\n            funcname = self.ATYPEMAP[type_]\n            func = getattr(gl, funcname)\n            # Set data\n            self._attributes[name] = 0, handle, func, value[1:]\n        else:\n            # Get meta data\n            vbo_id, stride, offset = value\n            size, gtype, dtype = self.ATYPEINFO[type_]\n            # Get associated VBO\n            vbo = self._parser.get_object(vbo_id)\n            if vbo == JUST_DELETED:\n                return\n            if vbo is None:\n                raise RuntimeError('Could not find VBO with id %i' % vbo_id)\n            # Set data\n            func = gl.glVertexAttribPointer\n            args = size, gtype, gl.GL_FALSE, stride, offset\n            self._attributes[name] = vbo.handle, handle, func, args", "response": "Set an attribute value."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef draw(self, mode, selection):\n        if not self._linked:\n            raise RuntimeError('Cannot draw program if code has not been set')\n        # Init\n        gl.check_error('Check before draw')\n        mode = as_enum(mode)\n        # Draw\n        if len(selection) == 3:\n            # Selection based on indices\n            id_, gtype, count = selection\n            if count:\n                self._pre_draw()\n                ibuf = self._parser.get_object(id_)\n                ibuf.activate()\n                gl.glDrawElements(mode, count, as_enum(gtype), None)\n                ibuf.deactivate()\n        else:\n            # Selection based on start and count\n            first, count = selection\n            if count:\n                self._pre_draw()\n                gl.glDrawArrays(mode, first, count)\n        # Wrap up\n        gl.check_error('Check after draw')\n        self._post_draw()", "response": "Draw program in given mode with given selection."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef as_matrix_transform(transform):\n    if isinstance(transform, ChainTransform):\n        matrix = np.identity(4)\n        for tr in transform.transforms:\n            # We need to do the matrix multiplication manually because VisPy\n            # somehow doesn't mutliply matrices if there is a perspective\n            # component. The equation below looks like it's the wrong way\n            # around, but the VisPy matrices are transposed.\n            matrix = np.matmul(as_matrix_transform(tr).matrix, matrix)\n        return MatrixTransform(matrix)\n    elif isinstance(transform, InverseTransform):\n        matrix = as_matrix_transform(transform._inverse)\n        return MatrixTransform(matrix.inv_matrix)\n    elif isinstance(transform, NullTransform):\n        return MatrixTransform()\n    elif isinstance(transform, STTransform):\n        return transform.as_matrix()\n    elif isinstance(transform, MatrixTransform):\n        return transform\n    else:\n        raise TypeError(\"Could not simplify transform of type {0}\".format(type(transform)))", "response": "Simplify a transform to a single matrix transform which makes it a lot\n    faster to compute transformations."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ngenerate a list of nodes and line vertices for a single circle.", "response": "def circular(adjacency_mat, directed=False):\n    \"\"\"Places all nodes on a single circle.\n\n    Parameters\n    ----------\n    adjacency_mat : matrix or sparse\n        The graph adjacency matrix\n    directed : bool\n        Whether the graph is directed. If this is True, is will also\n        generate the vertices for arrows, which can be passed to an\n        ArrowVisual.\n\n    Yields\n    ------\n    (node_vertices, line_vertices, arrow_vertices) : tuple\n        Yields the node and line vertices in a tuple. This layout only yields a\n        single time, and has no builtin animation\n    \"\"\"\n\n    if issparse(adjacency_mat):\n        adjacency_mat = adjacency_mat.tocoo()\n\n    num_nodes = adjacency_mat.shape[0]\n\n    t = np.linspace(0, 2 * np.pi, num_nodes, endpoint=False, dtype=np.float32)\n\n    # Visual coordinate system is between 0 and 1, so generate a circle with\n    # radius 0.5 and center it at the point (0.5, 0.5).\n    node_coords = (0.5 * np.array([np.cos(t), np.sin(t)]) + 0.5).T\n\n    line_vertices, arrows = _straight_line_vertices(adjacency_mat,\n                                                    node_coords, directed)\n\n    yield node_coords, line_vertices, arrows"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nappending a new set of vertices to the current set of vertices.", "response": "def append(self, P, closed=False, itemsize=None, **kwargs):\n        \"\"\"\n        Append a new set of vertices to the collection.\n\n        For kwargs argument, n is the number of vertices (local) or the number\n        of item (shared)\n\n        Parameters\n        ----------\n\n        P : np.array\n            Vertices positions of the path(s) to be added\n\n        closed: bool\n            Whether path(s) is/are closed\n\n        itemsize: int or None\n            Size of an individual path\n\n        caps : list, array or 2-tuple\n           Path start /end cap\n\n        join : list, array or float\n           path segment join\n\n        color : list, array or 4-tuple\n           Path color\n\n        miter_limit : list, array or float\n           Miter limit for join\n\n        linewidth : list, array or float\n           Path linewidth\n\n        antialias : list, array or float\n           Path antialias area\n        \"\"\"\n\n        itemsize = itemsize or len(P)\n        itemcount = len(P) / itemsize\n\n        # Computes the adjacency information\n        n, p = len(P), P.shape[-1]\n        Z = np.tile(P, 2).reshape(2 * len(P), p)\n        V = np.empty(n, dtype=self.vtype)\n\n        V['p0'][1:-1] = Z[0::2][:-2]\n        V['p1'][:-1] = Z[1::2][:-1]\n        V['p2'][:-1] = Z[1::2][+1:]\n        V['p3'][:-2] = Z[0::2][+2:]\n\n        # Apply default values on vertices\n        for name in self.vtype.names:\n            if name not in ['collection_index', 'p0', 'p1', 'p2', 'p3']:\n                V[name] = kwargs.get(name, self._defaults[name])\n\n        # Extract relevant segments only\n        V = (V.reshape(n / itemsize, itemsize)[:, :-1])\n        if closed:\n            V['p0'][:, 0] = V['p2'][:, -1]\n            V['p3'][:, -1] = V['p1'][:, 0]\n        else:\n            V['p0'][:, 0] = V['p1'][:, 0]\n            V['p3'][:, -1] = V['p2'][:, -1]\n        V = V.ravel()\n\n        # Quadruple each point (we're using 2 triangles / segment)\n        # No shared vertices between segment because of joins\n        V = np.repeat(V, 4, axis=0).reshape((len(V), 4))\n        V['uv'] = (-1, -1), (-1, +1), (+1, -1), (+1, +1)\n        V = V.ravel()\n\n        n = itemsize\n        if closed:\n            # uint16 for WebGL\n            I = np.resize(\n                np.array([0, 1, 2, 1, 2, 3], dtype=np.uint32), n * 2 * 3)\n            I += np.repeat(4 * np.arange(n, dtype=np.uint32), 6)\n            I[-6:] = 4 * n - 6, 4 * n - 5, 0, 4 * n - 5, 0, 1\n        else:\n            I = np.resize(\n                np.array([0, 1, 2, 1, 2, 3], dtype=np.uint32), (n - 1) * 2 * 3)\n            I += np.repeat(4 * np.arange(n - 1, dtype=np.uint32), 6)\n        I = I.ravel()\n\n        # Uniforms\n        if self.utype:\n            U = np.zeros(itemcount, dtype=self.utype)\n            for name in self.utype.names:\n                if name not in [\"__unused__\"]:\n                    U[name] = kwargs.get(name, self._defaults[name])\n        else:\n            U = None\n\n        Collection.append(self, vertices=V, uniforms=U,\n                          indices=I, itemsize=itemsize * 4 - 4)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef draw(self, mode=\"triangles\"):\n\n        gl.glDepthMask(0)\n        Collection.draw(self, mode)\n        gl.glDepthMask(1)", "response": "Draw the current context."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef set_data(self, pos=None, symbol='o', size=10., edge_width=1.,\n                 edge_width_rel=None, edge_color='black', face_color='white',\n                 scaling=False):\n        \"\"\" Set the data used to display this visual.\n\n        Parameters\n        ----------\n        pos : array\n            The array of locations to display each symbol.\n        symbol : str\n            The style of symbol to draw (see Notes).\n        size : float or array\n            The symbol size in px.\n        edge_width : float | None\n            The width of the symbol outline in pixels.\n        edge_width_rel : float | None\n            The width as a fraction of marker size. Exactly one of\n            `edge_width` and `edge_width_rel` must be supplied.\n        edge_color : Color | ColorArray\n            The color used to draw each symbol outline.\n        face_color : Color | ColorArray\n            The color used to draw each symbol interior.\n        scaling : bool\n            If set to True, marker scales when rezooming.\n\n        Notes\n        -----\n        Allowed style strings are: disc, arrow, ring, clobber, square, diamond,\n        vbar, hbar, cross, tailed_arrow, x, triangle_up, triangle_down,\n        and star.\n        \"\"\"\n        assert (isinstance(pos, np.ndarray) and\n                pos.ndim == 2 and pos.shape[1] in (2, 3))\n        if (edge_width is not None) + (edge_width_rel is not None) != 1:\n            raise ValueError('exactly one of edge_width and edge_width_rel '\n                             'must be non-None')\n        if edge_width is not None:\n            if edge_width < 0:\n                raise ValueError('edge_width cannot be negative')\n        else:\n            if edge_width_rel < 0:\n                raise ValueError('edge_width_rel cannot be negative')\n        self.symbol = symbol\n        self.scaling = scaling\n\n        edge_color = ColorArray(edge_color).rgba\n        if len(edge_color) == 1:\n            edge_color = edge_color[0]\n\n        face_color = ColorArray(face_color).rgba\n        if len(face_color) == 1:\n            face_color = face_color[0]\n\n        n = len(pos)\n        data = np.zeros(n, dtype=[('a_position', np.float32, 3),\n                                  ('a_fg_color', np.float32, 4),\n                                  ('a_bg_color', np.float32, 4),\n                                  ('a_size', np.float32, 1),\n                                  ('a_edgewidth', np.float32, 1)])\n        data['a_fg_color'] = edge_color\n        data['a_bg_color'] = face_color\n        if edge_width is not None:\n            data['a_edgewidth'] = edge_width\n        else:\n            data['a_edgewidth'] = size*edge_width_rel\n        data['a_position'][:, :pos.shape[1]] = pos\n        data['a_size'] = size\n        self.shared_program['u_antialias'] = self.antialias  # XXX make prop\n        self._data = data\n        self._vbo.set_data(data)\n        self.shared_program.bind(self._vbo)\n        self.update()", "response": "Set the data used to display the symbol in the current page."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef hook_changed(self, hook_name, widget, new_data):\n        if hook_name == 'song':\n            self.song_changed(widget, new_data)\n        elif hook_name == 'state':\n            self.state_changed(widget, new_data)\n        elif hook_name == 'elapsed_and_total':\n            elapsed, total = new_data\n            self.time_changed(widget, elapsed, total)", "response": "Handle a hook upate."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nupdates the signature of func with the data in self", "response": "def update(self, func, **kw):\n        \"Update the signature of func with the data in self\"\n        func.__name__ = self.name\n        func.__doc__ = getattr(self, 'doc', None)\n        func.__dict__ = getattr(self, 'dict', {})\n        func.__defaults__ = getattr(self, 'defaults', ())\n        func.__kwdefaults__ = getattr(self, 'kwonlydefaults', None)\n        func.__annotations__ = getattr(self, 'annotations', None)\n        callermodule = sys._getframe(3).f_globals.get('__name__', '?')\n        func.__module__ = getattr(self, 'module', callermodule)\n        func.__dict__.update(kw)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nmake a new function from a given template and update the signature", "response": "def make(self, src_templ, evaldict=None, addsource=False, **attrs):\n        \"Make a new function from a given template and update the signature\"\n        src = src_templ % vars(self) # expand name and signature\n        evaldict = evaldict or {}\n        mo = DEF.match(src)\n        if mo is None:\n            raise SyntaxError('not a valid function template\\n%s' % src)\n        name = mo.group(1) # extract the function name\n        names = set([name] + [arg.strip(' *') for arg in\n                             self.shortsignature.split(',')])\n        for n in names:\n            if n in ('_func_', '_call_'):\n                raise NameError('%s is overridden in\\n%s' % (n, src))\n        if not src.endswith('\\n'): # add a newline just for safety\n            src += '\\n' # this is needed in old versions of Python\n        try:\n            code = compile(src, '<string>', 'single')\n            # print >> sys.stderr, 'Compiling %s' % src\n            exec(code, evaldict)\n        except:\n            print('Error in generated code:', file=sys.stderr)\n            print(src, file=sys.stderr)\n            raise\n        func = evaldict[name]\n        if addsource:\n            attrs['__source__'] = src\n        self.update(func, **attrs)\n        return func"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate a function from the strings name signature and body.", "response": "def create(cls, obj, body, evaldict, defaults=None,\n               doc=None, module=None, addsource=True, **attrs):\n        \"\"\"\n        Create a function from the strings name, signature and body.\n        evaldict is the evaluation dictionary. If addsource is true an attribute\n        __source__ is added to the result. The attributes attrs are added,\n        if any.\n        \"\"\"\n        if isinstance(obj, str): # \"name(signature)\"\n            name, rest = obj.strip().split('(', 1)\n            signature = rest[:-1] #strip a right parens\n            func = None\n        else: # a function\n            name = None\n            signature = None\n            func = obj\n        self = cls(func, name, signature, defaults, doc, module)\n        ibody = '\\n'.join('    ' + line for line in body.splitlines())\n        return self.make('def %(name)s(%(signature)s):\\n' + ibody,\n                        evaldict, addsource, **attrs)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting the scalar array data", "response": "def set_data(self, data=None, vertex_colors=None, face_colors=None,\n                 color=None):\n        \"\"\" Set the scalar array data\n\n        Parameters\n        ----------\n        data : ndarray\n            A 3D array of scalar values. The isosurface is constructed to show\n            all locations in the scalar field equal to ``self.level``.\n        vertex_colors : array-like | None\n            Colors to use for each vertex.\n        face_colors : array-like | None\n            Colors to use for each face.\n        color : instance of Color\n            The color to use.\n        \"\"\"\n        # We only change the internal variables if they are provided\n        if data is not None:\n            self._data = data\n            self._recompute = True\n        if vertex_colors is not None:\n            self._vertex_colors = vertex_colors\n            self._update_meshvisual = True\n        if face_colors is not None:\n            self._face_colors = face_colors\n            self._update_meshvisual = True\n        if color is not None:\n            self._color = Color(color)\n            self._update_meshvisual = True\n        self.update()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_scene_bounds(self, dim=None):\n        # todo: handle sub-children\n        # todo: handle transformations\n        # Init\n        bounds = [(np.inf, -np.inf), (np.inf, -np.inf), (np.inf, -np.inf)]\n        # Get bounds of all children\n        for ob in self.scene.children:\n            if hasattr(ob, 'bounds'):\n                for axis in (0, 1, 2):\n                    if (dim is not None) and dim != axis:\n                        continue\n                    b = ob.bounds(axis)\n                    if b is not None:\n                        b = min(b), max(b)  # Ensure correct order\n                        bounds[axis] = (min(bounds[axis][0], b[0]), \n                                        max(bounds[axis][1], b[1]))\n        # Set defaults\n        for axis in (0, 1, 2):\n            if any(np.isinf(bounds[axis])):\n                bounds[axis] = -1, 1\n        \n        if dim is not None:\n            return bounds[dim]\n        else:\n            return bounds", "response": "Get the total bounds based on the visuals present in the scene."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nconvert user string or hex color to rgb array", "response": "def _string_to_rgb(color):\n    \"\"\"Convert user string or hex color to color array (length 3 or 4)\"\"\"\n    if not color.startswith('#'):\n        if color.lower() not in _color_dict:\n            raise ValueError('Color \"%s\" unknown' % color)\n        color = _color_dict[color]\n        assert color[0] == '#'\n    # hex color\n    color = color[1:]\n    lc = len(color)\n    if lc in (3, 4):\n        color = ''.join(c + c for c in color)\n        lc = len(color)\n    if lc not in (6, 8):\n        raise ValueError('Hex color must have exactly six or eight '\n                         'elements following the # sign')\n    color = np.array([int(color[i:i+2], 16) / 255. for i in range(0, lc, 2)])\n    return color"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nconverts color from any set of fmts str hex or arr to RGB array", "response": "def _user_to_rgba(color, expand=True, clip=False):\n    \"\"\"Convert color(s) from any set of fmts (str/hex/arr) to RGB(A) array\"\"\"\n    if color is None:\n        color = np.zeros(4, np.float32)\n    if isinstance(color, string_types):\n        color = _string_to_rgb(color)\n    elif isinstance(color, ColorArray):\n        color = color.rgba\n    # We have to treat this specially\n    elif isinstance(color, (list, tuple)):\n        if any(isinstance(c, string_types) for c in color):\n            color = [_user_to_rgba(c, expand=expand, clip=clip) for c in color]\n            if any(len(c) > 1 for c in color):\n                raise RuntimeError('could not parse colors, are they nested?')\n            color = [c[0] for c in color]\n    color = np.atleast_2d(color).astype(np.float32)\n    if color.shape[1] not in (3, 4):\n        raise ValueError('color must have three or four elements')\n    if expand and color.shape[1] == 3:  # only expand if requested\n        color = np.concatenate((color, np.ones((color.shape[0], 1))),\n                               axis=1)\n    if color.min() < 0 or color.max() > 1:\n        if clip:\n            color = np.clip(color, 0, 1)\n        else:\n            raise ValueError(\"Color values must be between 0 and 1 (or use \"\n                             \"clip=True to automatically clip the values).\")\n    return color"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _array_clip_val(val):\n    val = np.array(val)\n    if val.max() > 1 or val.min() < 0:\n        logger.warning('value will be clipped between 0 and 1')\n    val[...] = np.clip(val, 0, 1)\n    return val", "response": "Helper to turn val into array and clip between 0 and 1"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nextending a ColorArray with new colors.", "response": "def extend(self, colors):\n        \"\"\"Extend a ColorArray with new colors\n\n        Parameters\n        ----------\n        colors : instance of ColorArray\n            The new colors.\n        \"\"\"\n        colors = ColorArray(colors)\n        self._rgba = np.vstack((self._rgba, colors._rgba))\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset the color using an Nx4 array of RGBA floats", "response": "def rgba(self, val):\n        \"\"\"Set the color using an Nx4 array of RGBA floats\"\"\"\n        # Note: all other attribute sets get routed here!\n        # This method is meant to do the heavy lifting of setting data\n        rgba = _user_to_rgba(val, expand=False)\n        if self._rgba is None:\n            self._rgba = rgba  # only on init\n        else:\n            self._rgba[:, :rgba.shape[1]] = rgba"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsetting the color using an Nx4 array of RGBA uint8 values", "response": "def RGBA(self, val):\n        \"\"\"Set the color using an Nx4 array of RGBA uint8 values\"\"\"\n        # need to convert to normalized float\n        val = np.atleast_1d(val).astype(np.float32) / 255\n        self.rgba = val"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset the color using an Nx3 array of RGB uint8 values", "response": "def RGB(self, val):\n        \"\"\"Set the color using an Nx3 array of RGB uint8 values\"\"\"\n        # need to convert to normalized float\n        val = np.atleast_1d(val).astype(np.float32) / 255.\n        self.rgba = val"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef value(self, val):\n        hsv = self._hsv\n        hsv[:, 2] = _array_clip_val(val)\n        self.rgba = _hsv_to_rgb(hsv)", "response": "Set the color using length - N array of values."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef lighter(self, dv=0.1, copy=True):\n        color = self.copy() if copy else self\n        color.value += dv\n        return color", "response": "Produce a lighter color."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nproduces a darker color.", "response": "def darker(self, dv=0.1, copy=True):\n        \"\"\"Produce a darker color (if possible)\n\n        Parameters\n        ----------\n        dv : float\n            Amount to decrease the color value by.\n        copy : bool\n            If False, operation will be carried out in-place.\n\n        Returns\n        -------\n        color : instance of ColorArray\n            The darkened Color.\n        \"\"\"\n        color = self.copy() if copy else self\n        color.value -= dv\n        return color"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _set_range(self, init):\n\n        if init and (self._scale_factor is not None):\n            return  # We don't have to set our scale factor\n\n        # Get window size (and store factor now to sync with resizing)\n        w, h = self._viewbox.size\n        w, h = float(w), float(h)\n\n        # Get range and translation for x and y\n        x1, y1, z1 = self._xlim[0], self._ylim[0], self._zlim[0]\n        x2, y2, z2 = self._xlim[1], self._ylim[1], self._zlim[1]\n        rx, ry, rz = (x2 - x1), (y2 - y1), (z2 - z1)\n\n        # Correct ranges for window size. Note that the window width\n        # influences the x and y data range, while the height influences\n        # the z data range.\n        if w / h > 1:\n            rx /= w / h\n            ry /= w / h\n        else:\n            rz /= h / w\n\n        # Convert to screen coordinates. In screen x, only x and y have effect.\n        # In screen y, all three dimensions have effect. The idea of the lines\n        # below is to calculate the range on screen when that will fit the\n        # data under any rotation.\n        rxs = (rx**2 + ry**2)**0.5\n        rys = (rx**2 + ry**2 + rz**2)**0.5\n\n        self.scale_factor = max(rxs, rys) * 1.04", "response": "Reset the camera view using the known limits."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nhandling a mouse event and updates the internal state of the object.", "response": "def viewbox_mouse_event(self, event):\n        \"\"\"\n        The viewbox received a mouse event; update transform\n        accordingly.\n\n        Parameters\n        ----------\n        event : instance of Event\n            The event.\n        \"\"\"\n        if event.handled or not self.interactive:\n            return\n\n        PerspectiveCamera.viewbox_mouse_event(self, event)\n\n        if event.type == 'mouse_release':\n            self._event_value = None  # Reset\n        elif event.type == 'mouse_press':\n            event.handled = True\n        elif event.type == 'mouse_move':\n            if event.press_event is None:\n                return\n\n            modifiers = event.mouse_event.modifiers\n            p1 = event.mouse_event.press_event.pos\n            p2 = event.mouse_event.pos\n            d = p2 - p1\n\n            if 1 in event.buttons and not modifiers:\n                # Rotate\n                self._update_rotation(event)\n\n            elif 2 in event.buttons and not modifiers:\n                # Zoom\n                if self._event_value is None:\n                    self._event_value = (self._scale_factor, self._distance)\n                zoomy = (1 + self.zoom_factor) ** d[1]\n                \n                self.scale_factor = self._event_value[0] * zoomy\n                # Modify distance if its given\n                if self._distance is not None:\n                    self._distance = self._event_value[1] * zoomy\n                self.view_changed()\n\n            elif 1 in event.buttons and keys.SHIFT in modifiers:\n                # Translate\n                norm = np.mean(self._viewbox.size)\n                if self._event_value is None or len(self._event_value) == 2:\n                    self._event_value = self.center\n                dist = (p1 - p2) / norm * self._scale_factor\n                dist[1] *= -1\n                # Black magic part 1: turn 2D into 3D translations\n                dx, dy, dz = self._dist_to_trans(dist)\n                # Black magic part 2: take up-vector and flipping into account\n                ff = self._flip_factors\n                up, forward, right = self._get_dim_vectors()\n                dx, dy, dz = right * dx + forward * dy + up * dz\n                dx, dy, dz = ff[0] * dx, ff[1] * dy, dz * ff[2]\n                c = self._event_value\n                self.center = c[0] + dx, c[1] + dy, c[2] + dz\n\n            elif 2 in event.buttons and keys.SHIFT in modifiers:\n                # Change fov\n                if self._event_value is None:\n                    self._event_value = self._fov\n                fov = self._event_value - d[1] / 5.0\n                self.fov = min(180.0, max(0.0, fov))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _update_camera_pos(self):\n\n        # transform will be updated several times; do not update camera\n        # transform until we are done.\n        ch_em = self.events.transform_change\n        with ch_em.blocker(self._update_transform):\n            tr = self.transform\n            tr.reset()\n\n            up, forward, right = self._get_dim_vectors()\n\n            # Create mapping so correct dim is up\n            pp1 = np.array([(0, 0, 0), (0, 0, -1), (1, 0, 0), (0, 1, 0)])\n            pp2 = np.array([(0, 0, 0), forward, right, up])\n            tr.set_mapping(pp1, pp2)\n\n            tr.translate(-self._actual_distance * forward)\n            self._rotate_tr()\n            tr.scale([1.0/a for a in self._flip_factors])\n            tr.translate(np.array(self.center))", "response": "Update the camera position and orientation"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ndetermining if the user requested interactive mode.", "response": "def is_interactive(self):\n        \"\"\" Determine if the user requested interactive mode.\n        \"\"\"\n        # The Python interpreter sets sys.flags correctly, so use them!\n        if sys.flags.interactive:\n            return True\n\n        # IPython does not set sys.flags when -i is specified, so first\n        # check it if it is already imported.\n        if '__IPYTHON__' not in dir(six.moves.builtins):\n            return False\n\n        # Then we check the application singleton and determine based on\n        # a variable it sets.\n        try:\n            from IPython.config.application import Application as App\n            return App.initialized() and App.instance().interact\n        except (ImportError, AttributeError):\n            return False"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef run(self, allow_interactive=True):\n\n        if allow_interactive and self.is_interactive():\n            inputhook.set_interactive(enabled=True, app=self)\n        else:\n            return self._backend._vispy_run()", "response": "Enter the native GUI event loop."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nselect a backend by name. See class docstring for details.", "response": "def _use(self, backend_name=None):\n        \"\"\"Select a backend by name. See class docstring for details.\n        \"\"\"\n        # See if we're in a specific testing mode, if so DONT check to see\n        # if it's a valid backend. If it isn't, it's a good thing we\n        # get an error later because we should have decorated our test\n        # with requires_application()\n        test_name = os.getenv('_VISPY_TESTING_APP', None)\n\n        # Check whether the given name is valid\n        if backend_name is not None:\n            if backend_name.lower() == 'default':\n                backend_name = None  # Explicitly use default, avoid using test\n            elif backend_name.lower() not in BACKENDMAP:\n                raise ValueError('backend_name must be one of %s or None, not '\n                                 '%r' % (BACKEND_NAMES, backend_name))\n        elif test_name is not None:\n            backend_name = test_name.lower()\n            assert backend_name in BACKENDMAP\n\n        # Should we try and load any backend, or just this specific one?\n        try_others = backend_name is None\n\n        # Get backends to try ...\n        imported_toolkits = []  # Backends for which the native lib is imported\n        backends_to_try = []\n        if not try_others:\n            # We should never hit this, since we check above\n            assert backend_name.lower() in BACKENDMAP.keys()\n            # Add it\n            backends_to_try.append(backend_name.lower())\n        else:\n            # See if a backend is loaded\n            for name, module_name, native_module_name in CORE_BACKENDS:\n                if native_module_name and native_module_name in sys.modules:\n                    imported_toolkits.append(name.lower())\n                    backends_to_try.append(name.lower())\n            # See if a default is given\n            default_backend = config['default_backend'].lower()\n            if default_backend.lower() in BACKENDMAP.keys():\n                if default_backend not in backends_to_try:\n                    backends_to_try.append(default_backend)\n            # After this, try each one\n            for name, module_name, native_module_name in CORE_BACKENDS:\n                name = name.lower()\n                if name not in backends_to_try:\n                    backends_to_try.append(name)\n\n        # Now try each one\n        for key in backends_to_try:\n            name, module_name, native_module_name = BACKENDMAP[key]\n            TRIED_BACKENDS.append(name)\n            mod_name = 'backends.' + module_name\n            __import__(mod_name, globals(), level=1)\n            mod = getattr(backends, module_name)\n            if not mod.available:\n                msg = ('Could not import backend \"%s\":\\n%s'\n                       % (name, str(mod.why_not)))\n                if not try_others:\n                    # Fail if user wanted to use a specific backend\n                    raise RuntimeError(msg)\n                elif key in imported_toolkits:\n                    # Warn if were unable to use an already imported toolkit\n                    msg = ('Although %s is already imported, the %s backend '\n                           'could not\\nbe used (\"%s\"). \\nNote that running '\n                           'multiple GUI toolkits simultaneously can cause '\n                           'side effects.' %\n                           (native_module_name, name, str(mod.why_not)))\n                    logger.warning(msg)\n                else:\n                    # Inform otherwise\n                    logger.info(msg)\n            else:\n                # Success!\n                self._backend_module = mod\n                logger.debug('Selected backend %s' % module_name)\n                break\n        else:\n            raise RuntimeError('Could not import any of the backends. '\n                               'You need to install any of %s. We recommend '\n                               'PyQt' % [b[0] for b in CORE_BACKENDS])\n\n        # Store classes for app backend and canvas backend\n        self._backend = self.backend_module.ApplicationBackend()"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _process_key(evt):\n    key = evt.GetKeyCode()\n    if key in KEYMAP:\n        return KEYMAP[key], ''\n    if 97 <= key <= 122:\n        key -= 32\n    if key >= 32 and key <= 127:\n        return keys.Key(chr(key)), chr(key)\n    else:\n        return None, None", "response": "Helper function to convert wx keycode to vispy keycode"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncheck if a node is a child of the current node.", "response": "def is_child(self, node):\n        \"\"\"Check if a node is a child of the current node\n\n        Parameters\n        ----------\n        node : instance of Node\n            The potential child.\n\n        Returns\n        -------\n        child : bool\n            Whether or not the node is a child.\n        \"\"\"\n        if node in self.children:\n            return True\n        for c in self.children:\n            if c.is_child(node):\n                return True\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef scene_node(self):\n        if self._scene_node is None:\n            from .subscene import SubScene\n            p = self.parent\n            while True:\n                if isinstance(p, SubScene) or p is None:\n                    self._scene_node = p\n                    break\n                p = p.parent\n            if self._scene_node is None:\n                self._scene_node = self\n        return self._scene_node", "response": "The first ancestor of this node that is a SubScene instance or self\n       ."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nupdate the node s properties.", "response": "def update(self):\n        \"\"\"\n        Emit an event to inform listeners that properties of this Node have\n        changed. Also request a canvas update.\n        \"\"\"\n        self.events.update()\n        c = getattr(self, 'canvas', None)\n        if c is not None:\n            c.update(node=self)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef set_transform(self, type_, *args, **kwargs):\n        self.transform = create_transform(type_, *args, **kwargs)", "response": "Create a new transform of type_ and assign it to this node."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _update_trsys(self, event):\n        for ch in self.children:\n            ch._update_trsys(event)\n        self.events.transform_change()\n        self.update()", "response": "Called when the transform system has changed."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the list of parents starting from this node.", "response": "def parent_chain(self):\n        \"\"\"\n        Return the list of parents starting from this node. The chain ends\n        at the first node with no parents.\n        \"\"\"\n        chain = [self]\n        while True:\n            try:\n                parent = chain[-1].parent\n            except Exception:\n                break\n            if parent is None:\n                break\n            chain.append(parent)\n        return chain"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _describe_tree(self, prefix, with_transform):\n        extra = ': \"%s\"' % self.name if self.name is not None else ''\n        if with_transform:\n            extra += (' [%s]' % self.transform.__class__.__name__)\n        output = ''\n        if len(prefix) > 0:\n            output += prefix[:-3]\n            output += '  +--'\n        output += '%s%s\\n' % (self.__class__.__name__, extra)\n\n        n_children = len(self.children)\n        for ii, child in enumerate(self.children):\n            sub_prefix = prefix + ('   ' if ii+1 == n_children else '  |')\n            output += child._describe_tree(sub_prefix, with_transform)\n        return output", "response": "Helper function to actuall construct the tree"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the common parent of two entities.", "response": "def common_parent(self, node):\n        \"\"\"\n        Return the common parent of two entities\n\n        If the entities have no common parent, return None.\n\n        Parameters\n        ----------\n        node : instance of Node\n            The other node.\n\n        Returns\n        -------\n        parent : instance of Node | None\n            The parent.\n        \"\"\"\n        p1 = self.parent_chain()\n        p2 = node.parent_chain()\n        for p in p1:\n            if p in p2:\n                return p\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef node_path_to_child(self, node):\n        if node is self:\n            return []\n\n        # Go up from the child node as far as we can\n        path1 = [node]\n        child = node\n        while child.parent is not None:\n            child = child.parent\n            path1.append(child)\n            # Early exit\n            if child is self:\n                return list(reversed(path1))\n        \n        # Verify that we're not cut off\n        if path1[-1].parent is None:\n            raise RuntimeError('%r is not a child of %r' % (node, self))\n        \n        def _is_child(path, parent, child):\n            path.append(parent)\n            if child in parent.children:\n                return path\n            else:\n                for c in parent.children:\n                    possible_path = _is_child(path[:], c, child)\n                    if possible_path:\n                        return possible_path\n            return None\n\n        # Search from the parent towards the child\n        path2 = _is_child([], self, path1[-1])\n        if not path2:\n            raise RuntimeError('%r is not a child of %r' % (node, self))\n\n        # Return\n        return path2 + list(reversed(path1))", "response": "Return a list describing the path from this node to a child node."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn two lists describing the path from this node to another node.", "response": "def node_path(self, node):\n        \"\"\"Return two lists describing the path from this node to another\n\n        Parameters\n        ----------\n        node : instance of Node\n            The other node.\n\n        Returns\n        -------\n        p1 : list\n            First path (see below).\n        p2 : list\n            Second path (see below).\n\n        Notes\n        -----\n        The first list starts with this node and ends with the common parent\n        between the endpoint nodes. The second list contains the remainder of\n        the path from the common parent to the specified ending node.\n        \n        For example, consider the following scenegraph::\n        \n            A --- B --- C --- D\n                   \\\n                    --- E --- F\n        \n        Calling `D.node_path(F)` will return::\n        \n            ([D, C, B], [E, F])\n        \n        \"\"\"\n        p1 = self.parent_chain()\n        p2 = node.parent_chain()\n        cp = None\n        for p in p1:\n            if p in p2:\n                cp = p\n                break\n        if cp is None:\n            raise RuntimeError(\"No single-path common parent between nodes %s \"\n                               \"and %s.\" % (self, node))\n        \n        p1 = p1[:p1.index(cp)+1]\n        p2 = p2[:p2.index(cp)][::-1]\n        return p1, p2"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef node_path_transforms(self, node):\n        a, b = self.node_path(node)\n        return ([n.transform for n in a[:-1]] + \n                [n.transform.inverse for n in b])[::-1]", "response": "Returns the list of transforms along the path to another node."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef read(cls, fname):\n        # Open file\n        fmt = op.splitext(fname)[1].lower()\n        assert fmt in ('.obj', '.gz')\n        opener = open if fmt == '.obj' else gzip_open\n        with opener(fname, 'rb') as f:\n            try:\n                reader = WavefrontReader(f)\n                while True:\n                    reader.readLine()\n            except EOFError:\n                pass\n\n        # Done\n        t0 = time.time()\n        mesh = reader.finish()\n        logger.debug('reading mesh took ' +\n                     str(time.time() - t0) +\n                     ' seconds')\n        return mesh", "response": "This classmethod is used to read the OBJ file. It is the entry point for reading the OBJ files."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef readLine(self):\n\n        # Read line\n        line = self._f.readline().decode('ascii', 'ignore')\n        if not line:\n            raise EOFError()\n        line = line.strip()\n\n        if line.startswith('v '):\n            # self._vertices.append( *self.readTuple(line) )\n            self._v.append(self.readTuple(line))\n        elif line.startswith('vt '):\n            self._vt.append(self.readTuple(line, 3))\n        elif line.startswith('vn '):\n            self._vn.append(self.readTuple(line))\n        elif line.startswith('f '):\n            self._faces.append(self.readFace(line))\n        elif line.startswith('#'):\n            pass  # Comment\n        elif line.startswith('mtllib '):\n            logger.warning('Notice reading .OBJ: material properties are '\n                           'ignored.')\n        elif any(line.startswith(x) for x in ('g ', 's ', 'o ', 'usemtl ')):\n            pass  # Ignore groups and smoothing groups, obj names, material\n        elif not line.strip():\n            pass\n        else:\n            logger.warning('Notice reading .OBJ: ignoring %s command.'\n                           % line.strip())", "response": "Reads a single line and processes it."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef readTuple(self, line, n=3):\n        numbers = [num for num in line.split(' ') if num]\n        return [float(num) for num in numbers[1:n + 1]]", "response": "Reads a tuple of numbers. e. g. vertices normals or teture coords."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef readFace(self, line):\n\n        # Get parts (skip first)\n        indexSets = [num for num in line.split(' ') if num][1:]\n\n        final_face = []\n        for indexSet in indexSets:\n\n            # Did we see this exact index earlier? If so, it's easy\n            final_index = self._facemap.get(indexSet)\n            if final_index is not None:\n                final_face.append(final_index)\n                continue\n\n            # If not, we need to sync the vertices/normals/texcords ...\n\n            # Get and store final index\n            final_index = len(self._vertices)\n            final_face.append(final_index)\n            self._facemap[indexSet] = final_index\n\n            # What indices were given?\n            indices = [i for i in indexSet.split('/')]\n\n            # Store new set of vertex/normal/texcords.\n            # If there is a single face that does not specify the texcord\n            # index, the texcords are ignored. Likewise for the normals.\n            if True:\n                vertex_index = self._absint(indices[0], len(self._v))\n                self._vertices.append(self._v[vertex_index])\n            if self._texcords is not None:\n                if len(indices) > 1 and indices[1]:\n                    texcord_index = self._absint(indices[1], len(self._vt))\n                    self._texcords.append(self._vt[texcord_index])\n                else:\n                    if self._texcords:\n                        logger.warning('Ignoring texture coordinates because '\n                                       'it is not specified for all faces.')\n                    self._texcords = None\n            if self._normals is not None:\n                if len(indices) > 2 and indices[2]:\n                    normal_index = self._absint(indices[2], len(self._vn))\n                    self._normals.append(self._vn[normal_index])\n                else:\n                    if self._normals:\n                        logger.warning('Ignoring normals because it is not '\n                                       'specified for all faces.')\n                    self._normals = None\n\n        # Check face\n        if self._faces and len(self._faces[0]) != len(final_face):\n            raise RuntimeError(\n                'Vispy requires that all faces are either triangles or quads.')\n\n        # Done\n        return final_face", "response": "Reads a single face from a string."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef finish(self):\n        self._vertices = np.array(self._vertices, 'float32')\n        if self._faces:\n            self._faces = np.array(self._faces, 'uint32')\n        else:\n            # Use vertices only\n            self._vertices = np.array(self._v, 'float32')\n            self._faces = None\n        if self._normals:\n            self._normals = np.array(self._normals, 'float32')\n        else:\n            self._normals = self._calculate_normals()\n        if self._texcords:\n            self._texcords = np.array(self._texcords, 'float32')\n        else:\n            self._texcords = None\n\n        return self._vertices, self._faces, self._normals, self._texcords", "response": "Converts gathere lists to numpy arrays and creates\n            BaseMesh instance."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef write(cls, fname, vertices, faces, normals,\n              texcoords, name='', reshape_faces=True):\n        \"\"\" This classmethod is the entry point for writing mesh data to OBJ.\n\n        Parameters\n        ----------\n        fname : string\n            The filename to write to. Must end with \".obj\" or \".gz\".\n        vertices : numpy array\n            The vertex data\n        faces : numpy array\n            The face data\n        texcoords : numpy array\n            The texture coordinate per vertex\n        name : str\n            The name of the object (e.g. 'teapot')\n        reshape_faces : bool\n            Reshape the `faces` array to (Nf, 3). Set to `False`\n            if you need to write a mesh with non triangular faces.\n        \"\"\"\n        # Open file\n        fmt = op.splitext(fname)[1].lower()\n        if fmt not in ('.obj', '.gz'):\n            raise ValueError('Filename must end with .obj or .gz, not \"%s\"'\n                             % (fmt,))\n        opener = open if fmt == '.obj' else gzip_open\n        f = opener(fname, 'wb')\n        try:\n            writer = WavefrontWriter(f)\n            writer.writeMesh(vertices, faces, normals,\n                             texcoords, name, reshape_faces=reshape_faces)\n        except EOFError:\n            pass\n        finally:\n            f.close()", "response": "This classmethod writes a mesh to an object file."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nwriting a tuple of numbers on one line.", "response": "def writeTuple(self, val, what):\n        \"\"\" Writes a tuple of numbers (on one line).\n        \"\"\"\n        # Limit to three values. so RGBA data drops the alpha channel\n        # Format can handle up to 3 texcords\n        val = val[:3]\n        # Make string\n        val = ' '.join([str(v) for v in val])\n        # Write line\n        self.writeLine('%s %s' % (what, val))"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nwrite the face info to the net line.", "response": "def writeFace(self, val, what='f'):\n        \"\"\" Write the face info to the net line.\n        \"\"\"\n        # OBJ counts from 1\n        val = [v + 1 for v in val]\n        # Make string\n        if self._hasValues and self._hasNormals:\n            val = ' '.join(['%i/%i/%i' % (v, v, v) for v in val])\n        elif self._hasNormals:\n            val = ' '.join(['%i//%i' % (v, v) for v in val])\n        elif self._hasValues:\n            val = ' '.join(['%i/%i' % (v, v) for v in val])\n        else:\n            val = ' '.join(['%i' % v for v in val])\n        # Write line\n        self.writeLine('%s %s' % (what, val))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef writeMesh(self, vertices, faces, normals, values,\n                  name='', reshape_faces=True):\n        \"\"\" Write the given mesh instance.\n        \"\"\"\n\n        # Store properties\n        self._hasNormals = normals is not None\n        self._hasValues = values is not None\n        self._hasFaces = faces is not None\n\n        # Get faces and number of vertices\n        if faces is None:\n            faces = np.arange(len(vertices))\n            reshape_faces = True\n\n        if reshape_faces:\n            Nfaces = faces.size // 3\n            faces = faces.reshape((Nfaces, 3))\n        else:\n            is_triangular = np.array([len(f) == 3\n                                      for f in faces])\n            if not(np.all(is_triangular)):\n                logger.warning('''Faces doesn't appear to be triangular,\n                be advised the file cannot be read back in vispy''')\n        # Number of vertices\n        N = vertices.shape[0]\n\n        # Get string with stats\n        stats = []\n        stats.append('%i vertices' % N)\n        if self._hasValues:\n            stats.append('%i texcords' % N)\n        else:\n            stats.append('no texcords')\n        if self._hasNormals:\n            stats.append('%i normals' % N)\n        else:\n            stats.append('no normals')\n        stats.append('%i faces' % faces.shape[0])\n\n        # Write header\n        self.writeLine('# Wavefront OBJ file')\n        self.writeLine('# Created by vispy.')\n        self.writeLine('#')\n        if name:\n            self.writeLine('# object %s' % name)\n        else:\n            self.writeLine('# unnamed object')\n        self.writeLine('# %s' % ', '.join(stats))\n        self.writeLine('')\n\n        # Write data\n        if True:\n            for i in range(N):\n                self.writeTuple(vertices[i], 'v')\n        if self._hasNormals:\n            for i in range(N):\n                self.writeTuple(normals[i], 'vn')\n        if self._hasValues:\n            for i in range(N):\n                self.writeTuple(values[i], 'vt')\n        if True:\n            for i in range(faces.shape[0]):\n                self.writeFace(faces[i])", "response": "Writes a mesh to the file."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncompute cross product between 2D arrays x and y.", "response": "def _fast_cross_3d(x, y):\n    \"\"\"Compute cross product between list of 3D vectors\n\n    Much faster than np.cross() when the number of cross products\n    becomes large (>500). This is because np.cross() methods become\n    less memory efficient at this stage.\n\n    Parameters\n    ----------\n    x : array\n        Input array 1.\n    y : array\n        Input array 2.\n\n    Returns\n    -------\n    z : array\n        Cross product of x and y.\n\n    Notes\n    -----\n    x and y must both be 2D row vectors. One must have length 1, or both\n    lengths must match.\n    \"\"\"\n    assert x.ndim == 2\n    assert y.ndim == 2\n    assert x.shape[1] == 3\n    assert y.shape[1] == 3\n    assert (x.shape[0] == 1 or y.shape[0] == 1) or x.shape[0] == y.shape[0]\n    if max([x.shape[0], y.shape[0]]) >= 500:\n        return np.c_[x[:, 1] * y[:, 2] - x[:, 2] * y[:, 1],\n                     x[:, 2] * y[:, 0] - x[:, 0] * y[:, 2],\n                     x[:, 0] * y[:, 1] - x[:, 1] * y[:, 0]]\n    else:\n        return np.cross(x, y)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef resize(image, shape, kind='linear'):\n    image = np.array(image, float)\n    shape = np.array(shape, int)\n    if shape.ndim != 1 or shape.size != 2:\n        raise ValueError('shape must have two elements')\n    if image.ndim < 2:\n        raise ValueError('image must have two dimensions')\n    if not isinstance(kind, string_types) or kind not in ('nearest', 'linear'):\n        raise ValueError('mode must be \"nearest\" or \"linear\"')\n\n    r = np.linspace(0, image.shape[0] - 1, shape[0])\n    c = np.linspace(0, image.shape[1] - 1, shape[1])\n    if kind == 'linear':\n        r_0 = np.floor(r).astype(int)\n        c_0 = np.floor(c).astype(int)\n        r_1 = r_0 + 1\n        c_1 = c_0 + 1\n\n        top = (r_1 - r)[:, np.newaxis]\n        bot = (r - r_0)[:, np.newaxis]\n        lef = (c - c_0)[np.newaxis, :]\n        rig = (c_1 - c)[np.newaxis, :]\n\n        c_1 = np.minimum(c_1, image.shape[1] - 1)\n        r_1 = np.minimum(r_1, image.shape[0] - 1)\n        for arr in (top, bot, lef, rig):\n            arr.shape = arr.shape + (1,) * (image.ndim - 2)\n        out = top * rig * image[r_0][:, c_0, ...]\n        out += bot * rig * image[r_1][:, c_0, ...]\n        out += top * lef * image[r_0][:, c_1, ...]\n        out += bot * lef * image[r_1][:, c_1, ...]\n    else:  # kind == 'nearest'\n        r = np.round(r).astype(int)\n        c = np.round(c).astype(int)\n        out = image[r][:, c, ...]\n    return out", "response": "Resizes an image into a new image with the specified shape."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nappending a new set of segments to the collection.", "response": "def append(self, P0, P1, itemsize=None, **kwargs):\n        \"\"\"\n        Append a new set of segments to the collection.\n\n        For kwargs argument, n is the number of vertices (local) or the number\n        of item (shared)\n\n        Parameters\n        ----------\n\n        P : np.array\n            Vertices positions of the path(s) to be added\n\n        closed: bool\n            Whether path(s) is/are closed\n\n        itemsize: int or None\n            Size of an individual path\n\n        color : list, array or 4-tuple\n           Path color\n        \"\"\"\n\n        itemsize = itemsize or 1\n        itemcount = len(P0) / itemsize\n\n        V = np.empty(itemcount, dtype=self.vtype)\n\n        # Apply default values on vertices\n        for name in self.vtype.names:\n            if name not in ['collection_index', 'P']:\n                V[name] = kwargs.get(name, self._defaults[name])\n\n        V = np.repeat(V, 2, axis=0)\n        V['P'][0::2] = P0\n        V['P'][1::2] = P1\n\n        # Uniforms\n        if self.utype:\n            U = np.zeros(itemcount, dtype=self.utype)\n            for name in self.utype.names:\n                if name not in [\"__unused__\"]:\n                    U[name] = kwargs.get(name, self._defaults[name])\n        else:\n            U = None\n\n        Collection.append(self, vertices=V, uniforms=U, itemsize=itemsize)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef parse(self):\n        for line in self.lines:\n            # Parse the line\n            field_defs = self.parse_line(line)\n            fields = []\n\n            # Convert field parameters into Field objects\n            for (kind, options) in field_defs:\n                logger.debug(\"Creating field %s(%r)\", kind, options)\n                fields.append(self.field_registry.create(kind, **options))\n\n            # Add the list of Field objects to the 'fields per line'.\n            self.line_fields.append(fields)\n\n            # Pre-fill the list of widgets\n            for field in fields:\n                self.widgets[field] = None", "response": "Parse the lines and fill self. line_fields accordingly."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncomputes the relative position of the fields on a given line.", "response": "def compute_positions(cls, screen_width, line):\n        \"\"\"Compute the relative position of the fields on a given line.\n\n        Args:\n            screen_width (int): the width of the screen\n            line (mpdlcd.display_fields.Field list): the list of fields on the\n                line\n\n        Returns:\n            ((int, mpdlcd.display_fields.Field) list): the positions of fields,\n                as (position, field) tuples.\n\n        Raises:\n            FormatError: if the line contains more than one flexible field, or\n                is too long for the screen size.\n        \"\"\"\n        # First index\n        left = 1\n        # Last index\n        right = screen_width + 1\n        # Current 'flexible' field\n        flexible = None\n\n        # Compute the space to the left and to the right of the (optional)\n        # flexible field.\n        for field in line:\n            if field.is_flexible():\n                if flexible:\n                    raise FormatError(\n                        'There can be only one flexible field per line.')\n                flexible = field\n\n            elif not flexible:\n                left += field.width\n\n            else:\n                # Met a 'flexible', computing from the right\n                right -= field.width\n\n        # Available space for the 'flexible' field\n        available = right - left\n        if available <= 0:\n            raise FormatError(\"Too much data for screen width\")\n\n        if flexible:\n            if available < 1:\n                raise FormatError(\n                    \"Not enough space to display flexible field %s\" %\n                    flexible.name)\n\n            flexible.width = available\n\n        positions = []\n        left = 1\n        for field in line:\n            positions.append((left, field))\n            left += field.width\n\n        logger.debug('Positions are %r', positions)\n        return positions"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nadding the pattern to a screen.", "response": "def add_to_screen(self, screen_width, screen):\n        \"\"\"Add the pattern to a screen.\n\n        Also fills self.widgets.\n\n        Args:\n            screen_width (int): the width of the screen\n            screen (lcdprod.Screen): the screen to fill.\n        \"\"\"\n        for lineno, fields in enumerate(self.line_fields):\n            for left, field in self.compute_positions(screen_width, fields):\n                logger.debug(\n                    \"Adding field %s to screen %s at x=%d->%d, y=%d\",\n                    field, screen.ref, left, left + field.width - 1, 1 + lineno,\n                )\n\n                self.widgets[field] = field.add_to_screen(screen, left, 1 + lineno)\n                self.register_hooks(field)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nregisters a field on its target hooks.", "response": "def register_hooks(self, field):\n        \"\"\"Register a field on its target hooks.\"\"\"\n        for hook, subhooks in field.register_hooks():\n            self.hooks[hook].append(field)\n            self.subhooks[hook] |= set(subhooks)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef hook_changed(self, hook, new_data):\n        for field in self.hooks[hook]:\n            widget = self.widgets[field]\n            field.hook_changed(hook, widget, new_data)", "response": "Called whenever the data for a specific hook has changed."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef parse_line(self, line):\n        logger.debug('Parsing line %s', line)\n\n        OUT_FIELD = 0\n        IN_FIELD_KIND = 1\n        IN_FIELD_OPTION_NAME = 2\n        IN_FIELD_OPTION_VALUE = 3\n\n        class ParserState(object):\n            \"\"\"Holds the current state of the parser.\n\n            Attributes:\n                quote (str): the current quote character, or None\n                escaping (bool): whether the next character should be escaped\n                block (char list): the content of the current 'block'\n                kind (str): the kind of the current field, or ''\n                option_name (str): the name of the current option, or ''\n                options (dict(str => str)): maps option name to option value for\n                    the current field\n                state (int): state of the parser,one of OUT_FIELD/IN_FIELD_*\n                fields ((str, dict(str => str)) list): list of fields, as\n                    (kind, options) tuples.\n            \"\"\"\n\n            def __init__(self, logger=None):\n                self.quote = None\n                self.escaping = False\n                self.block = []\n                self.kind = ''\n                self.option_name = ''\n                self.options = {}\n                self.state = OUT_FIELD\n                self.fields = []\n                if not logger:\n                    logger = logging.getLogger('%s.parser' % __name__)\n                self.logger = logger\n\n            def _reset(self):\n                \"\"\"Reset buffered state (quote/escape/block).\"\"\"\n                self.quote = None\n                self.escaping = False\n                self.block = []\n\n            def _register_field(self, kind, options):\n                \"\"\"Register a completed field.\"\"\"\n                self.fields.append((kind, dict(options)))\n\n            def debug(self, msg, *args, **kwargs):\n                \"\"\"Print a debug message.\"\"\"\n                self.logger.debug(msg, *args, **kwargs)\n\n            def save_fixed_text(self):\n                \"\"\"Register a completed, fixed text, field.\"\"\"\n                assert self.state == OUT_FIELD\n                self._register_field(FIXED_TEXT_FIELD, {'text': ''.join(self.block)})\n\n            def enter_field(self):\n                \"\"\"Enter a new field.\"\"\"\n                self.debug('Entering new field')\n                self.state = IN_FIELD_KIND\n                self.kind = ''\n                self.options = {}\n                self.option_name = ''\n                self._reset()\n\n            def leave_kind(self):\n                \"\"\"Leave the field kind.\"\"\"\n                self.state = IN_FIELD_OPTION_NAME\n                self.kind = ''.join(self.block)\n                self.debug(\"Got widget kind '%s'\", self.kind)\n                self._reset()\n\n            def leave_option_name(self):\n                \"\"\"Leave an option name.\"\"\"\n                self.state = IN_FIELD_OPTION_VALUE\n                self.option_name = ''.join(self.block)\n                self.debug(\"Got option name '%s' for '%s'\", self.option_name, self.kind)\n                self._reset()\n\n            def leave_option_value(self):\n                \"\"\"Leave an option value.\"\"\"\n                self.state = IN_FIELD_OPTION_NAME\n                option_value = ''.join(self.block)\n                self.options[self.option_name] = option_value\n                self.debug(\"Got option '%s=%s' for '%s'\", self.option_name, option_value, self.kind)\n                self._reset()\n\n            def leave_field(self):\n                \"\"\"Leave a field definition.\"\"\"\n                self.state = OUT_FIELD\n                self._register_field(self.kind, self.options)\n                self.debug(\n                    \"Got widget '%s(%s)'\", self.kind,\n                    ', '.join('%s=%r' % it for it in self.options.items()),\n                )\n                self._reset()\n\n        st = ParserState()\n\n        for pos, char in enumerate(line):\n\n            # Escaping\n            if st.escaping:\n                st.escaping = False\n                st.block.append(char)\n\n            elif char == '\\\\':\n                st.escaping = True\n\n            # Quoting\n            elif char in ['\"', \"'\"]:\n                if st.state == IN_FIELD_OPTION_VALUE:\n                    if st.quote:  # Already in a quoted block\n                        if char == st.quote:\n                            st.leave_option_value()\n                        else:\n                            st.block.append(char)\n\n                    elif not st.block:  # First char of the block\n                        st.quote = char\n                        continue\n\n                    else:\n                        raise FormatError(\"Unexpected '%s' at %d in %s\" % (char, pos, line))\n\n                elif st.state == OUT_FIELD:\n                    st.block.append(char)\n\n                else:\n                    raise FormatError(\"Unexpected '%s' at %d in %s\" % (char, pos, line))\n\n            # Entering a field\n            elif char == '{':\n                if st.state == OUT_FIELD:\n                    if st.block:\n                        st.save_fixed_text()\n                    st.enter_field()\n\n                elif st.state == IN_FIELD_OPTION_VALUE and st.quote:\n                    st.block.append(char)\n\n                else:\n                    raise FormatError(\"Unexpected '{' at %d in %s\" % (pos, line))\n\n            # Leaving a field\n            elif char == '}':\n                if st.state == IN_FIELD_KIND:\n                    st.leave_kind()\n                    st.leave_field()\n\n                elif st.state == IN_FIELD_OPTION_NAME:\n                    raise FormatError(\"Missing option value for %s at %d in %s\" % (''.join(st.block), pos, line))\n\n                elif st.state == IN_FIELD_OPTION_VALUE:\n                    if st.quote:\n                        st.block.append(char)\n                    else:\n                        st.leave_option_value()\n                        st.leave_field()\n\n                elif st.state == OUT_FIELD:\n                    raise FormatError(\"Unexpected '}' at %d in %s\" % (pos, line))\n\n            # Between kind and option name\n            elif char == ' ':\n                if st.state == IN_FIELD_KIND:\n                    if not st.block:\n                        raise FormatError(\"Missing field kind at %s in %s\" % (pos, line))\n\n                    st.leave_kind()\n\n                elif st.state == IN_FIELD_OPTION_VALUE and st.quote:\n                    st.block.append(char)\n\n                elif st.state == OUT_FIELD:\n                    st.block.append(char)\n\n                else:\n                    raise FormatError(\"Unexpected ' ' at %d in %s\" % (pos, line))\n\n            # Between options\n            elif char == ',':\n                if st.state == IN_FIELD_OPTION_NAME:\n                    if st.block:\n                        raise FormatError(\"Missing option value for %s at %d in %s\" % (''.join(st.block), pos, line))\n                    else:\n                        # At the beginning of a new option\n                        continue\n\n                elif st.state == IN_FIELD_KIND:\n                    raise FormatError(\"Unexpected ',' in field definition %s at %d in %s\" % (st.kind, pos, line))\n\n                elif st.state == IN_FIELD_OPTION_VALUE:\n                    if st.quote:\n                        st.block.append(char)\n                    elif st.block:\n                        st.leave_option_value()\n                    else:\n                        raise FormatError(\"Missing option value for %s at %d in %s\" % (st.option_name, pos, line))\n\n                else:  # OUT_FIELD\n                    st.block.append(char)\n\n            # Between option name and option value\n            elif char == '=':\n                if st.state == IN_FIELD_OPTION_NAME:\n                    if st.block:\n                        st.leave_option_name()\n\n                    else:\n                        raise FormatError(\"Missing option name at %d in %s\" % (pos, line))\n\n                elif st.state == OUT_FIELD:\n                    st.block.append(char)\n\n                elif st.state == IN_FIELD_OPTION_VALUE:\n                    if st.quote:\n                        st.block.append(char)\n\n                    elif not st.block:\n                        # At the beginning of an option\n                        continue\n\n                    else:\n                        raise FormatError(\n                            \"Unexpected '=' in option value for %s at %d in %s\"\n                            % (st.option_name, pos, line))\n\n                else:\n                    raise FormatError(\"Unexpected '=' at %d in %s\" % (pos, line))\n\n            # Everything else\n            else:\n                st.block.append(char)\n\n        # All input parsed\n        if st.state != OUT_FIELD:\n            raise FormatError(\"Unclosed field at %d in '%s'; block: '%s'\" % (pos, line, ''.join(st.block)))\n\n        if st.block:\n            st.save_fixed_text()\n\n        return st.fields", "response": "Parse a line of text into a patternLine object."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef add(self, pattern_txt):\n        self.patterns[len(pattern_txt)] = pattern_txt\n\n        low = 0\n        high = len(pattern_txt) - 1\n\n        while not pattern_txt[low]:\n            low += 1\n\n        while not pattern_txt[high]:\n            high -= 1\n\n        min_pattern = pattern_txt[low:high + 1]\n        self.min_patterns[len(min_pattern)] = min_pattern", "response": "Adds a pattern to the list."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nconvert x y coordinates to w x y z Quaternion parameters", "response": "def _arcball(xy, wh):\n    \"\"\"Convert x,y coordinates to w,x,y,z Quaternion parameters\n\n    Adapted from:\n\n    linalg library\n\n    Copyright (c) 2010-2015, Renaud Blanch <rndblnch at gmail dot com>\n    Licence at your convenience:\n    GPLv3 or higher <http://www.gnu.org/licenses/gpl.html>\n    BSD new <http://opensource.org/licenses/BSD-3-Clause>\n    \"\"\"\n    x, y = xy\n    w, h = wh\n    r = (w + h) / 2.\n    x, y = -(2. * x - w) / r, (2. * y - h) / r\n    h = np.sqrt(x*x + y*y)\n    return (0., x/h, y/h, 0.) if h > 1. else (0., x, y, np.sqrt(1. - h*h))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _update_rotation(self, event):\n        p2 = event.mouse_event.pos\n        if self._event_value is None:\n            self._event_value = p2\n        wh = self._viewbox.size\n        self._quaternion = (Quaternion(*_arcball(p2, wh)) *\n                            Quaternion(*_arcball(self._event_value, wh)) *\n                            self._quaternion)\n        self._event_value = p2\n        self.view_changed()", "response": "Update rotation parmeters based on mouse movement"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nrotate the transformation matrix based on camera parameters", "response": "def _rotate_tr(self):\n        \"\"\"Rotate the transformation matrix based on camera parameters\"\"\"\n        rot, x, y, z = self._quaternion.get_axis_angle()\n        up, forward, right = self._get_dim_vectors()\n        self.transform.rotate(180 * rot / np.pi, (x, z, y))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nconvert mouse x y movement into x y z translations", "response": "def _dist_to_trans(self, dist):\n        \"\"\"Convert mouse x, y movement into x, y, z translations\"\"\"\n        rot, x, y, z = self._quaternion.get_axis_angle()\n        tr = MatrixTransform()\n        tr.rotate(180 * rot / np.pi, (x, y, z))\n        dx, dz, dy = np.dot(tr.matrix[:3, :3], (dist[0], dist[1], 0.))\n        return dx, dy, dz"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef as_vec4(obj, default=(0, 0, 0, 1)):\n    obj = np.atleast_2d(obj)\n    # For multiple vectors, reshape to (..., 4)\n    if obj.shape[-1] < 4:\n        new = np.empty(obj.shape[:-1] + (4,), dtype=obj.dtype)\n        new[:] = default\n        new[..., :obj.shape[-1]] = obj\n        obj = new\n    elif obj.shape[-1] > 4:\n        raise TypeError(\"Array shape %s cannot be converted to vec4\"\n                        % obj.shape)\n    return obj", "response": "Convert obj to 4 - element vector."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef arg_to_vec4(func, self_, arg, *args, **kwargs):\n    if isinstance(arg, (tuple, list, np.ndarray)):\n        arg = np.array(arg)\n        flatten = arg.ndim == 1\n        arg = as_vec4(arg)\n\n        ret = func(self_, arg, *args, **kwargs)\n        if flatten and ret is not None:\n            return ret.flatten()\n        return ret\n    elif hasattr(arg, '_transform_in'):\n        arr = arg._transform_in()\n        ret = func(self_, arr, *args, **kwargs)\n        return arg._transform_out(ret)\n    else:\n        raise TypeError(\"Cannot convert argument to 4D vector: %s\" % arg)", "response": "Decorator for converting an argument to vec4 format suitable for 4x4 matrix multiplication."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get(self, path):\n        key = tuple(map(id, path))\n        item = self._cache.get(key, None)\n        if item is None:\n            logger.debug(\"Transform cache miss: %s\", key)\n            item = [0, self._create(path)]\n            self._cache[key] = item\n        item[0] = 0  # reset age for this item\n\n        # make sure the chain is up to date\n        #tr = item[1]\n        #for i, node in enumerate(path[1:]):\n        #    if tr.transforms[i] is not node.transform:\n        #        tr[i] = node.transform\n\n        return item[1]", "response": "Get a transform from the cache that maps along path which must\n        be a list of Transforms to apply in reverse order."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nrolls the cache by 1. Items whose age is greater than self. max_age will be removed from the cache.", "response": "def roll(self):\n        \"\"\" Increase the age of all items in the cache by 1. Items whose age\n        is greater than self.max_age will be removed from the cache.\n        \"\"\"\n        rem = []\n        for key, item in self._cache.items():\n            if item[0] > self.max_age:\n                rem.append(key)\n            item[0] += 1\n\n        for key in rem:\n            logger.debug(\"TransformCache remove: %s\", key)\n            del self._cache[key]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncalculate and show a histogram of data.", "response": "def histogram(self, data, bins=10, color='w', orientation='h'):\n        \"\"\"Calculate and show a histogram of data\n\n        Parameters\n        ----------\n        data : array-like\n            Data to histogram. Currently only 1D data is supported.\n        bins : int | array-like\n            Number of bins, or bin edges.\n        color : instance of Color\n            Color of the histogram.\n        orientation : {'h', 'v'}\n            Orientation of the histogram.\n\n        Returns\n        -------\n        hist : instance of Polygon\n            The histogram polygon.\n        \"\"\"\n        self._configure_2d()\n        hist = scene.Histogram(data, bins, color, orientation)\n        self.view.add(hist)\n        self.view.camera.set_range()\n        return hist"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef image(self, data, cmap='cubehelix', clim='auto', fg_color=None):\n        self._configure_2d(fg_color)\n        image = scene.Image(data, cmap=cmap, clim=clim)\n        self.view.add(image)\n        self.view.camera.aspect = 1\n        self.view.camera.set_range()\n\n        return image", "response": "Show an image in the view."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef mesh(self, vertices=None, faces=None, vertex_colors=None,\n             face_colors=None, color=(0.5, 0.5, 1.), fname=None,\n             meshdata=None):\n        \"\"\"Show a 3D mesh\n\n        Parameters\n        ----------\n        vertices : array\n            Vertices.\n        faces : array | None\n            Face definitions.\n        vertex_colors : array | None\n            Vertex colors.\n        face_colors : array | None\n            Face colors.\n        color : instance of Color\n            Color to use.\n        fname : str | None\n            Filename to load. If not None, then vertices, faces, and meshdata\n            must be None.\n        meshdata : MeshData | None\n            Meshdata to use. If not None, then vertices, faces, and fname\n            must be None.\n\n        Returns\n        -------\n        mesh : instance of Mesh\n            The mesh.\n        \"\"\"\n        self._configure_3d()\n        if fname is not None:\n            if not all(x is None for x in (vertices, faces, meshdata)):\n                raise ValueError('vertices, faces, and meshdata must be None '\n                                 'if fname is not None')\n            vertices, faces = read_mesh(fname)[:2]\n        if meshdata is not None:\n            if not all(x is None for x in (vertices, faces, fname)):\n                raise ValueError('vertices, faces, and fname must be None if '\n                                 'fname is not None')\n        else:\n            meshdata = MeshData(vertices, faces)\n        mesh = scene.Mesh(meshdata=meshdata, vertex_colors=vertex_colors,\n                          face_colors=face_colors, color=color,\n                          shading='smooth')\n        self.view.add(mesh)\n        self.view.camera.set_range()\n        return mesh", "response": "Show a 3D mesh."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nplotting a series of data using lines and markers.", "response": "def plot(self, data, color='k', symbol=None, line_kind='-', width=1.,\n             marker_size=10., edge_color='k', face_color='b', edge_width=1.,\n             title=None, xlabel=None, ylabel=None):\n        \"\"\"Plot a series of data using lines and markers\n\n        Parameters\n        ----------\n        data : array | two arrays\n            Arguments can be passed as ``(Y,)``, ``(X, Y)`` or\n            ``np.array((X, Y))``.\n        color : instance of Color\n            Color of the line.\n        symbol : str\n            Marker symbol to use.\n        line_kind : str\n            Kind of line to draw. For now, only solid lines (``'-'``)\n            are supported.\n        width : float\n            Line width.\n        marker_size : float\n            Marker size. If `size == 0` markers will not be shown.\n        edge_color : instance of Color\n            Color of the marker edge.\n        face_color : instance of Color\n            Color of the marker face.\n        edge_width : float\n            Edge width of the marker.\n        title : str | None\n            The title string to be displayed above the plot\n        xlabel : str | None\n            The label to display along the bottom axis\n        ylabel : str | None\n            The label to display along the left axis.\n\n        Returns\n        -------\n        line : instance of LinePlot\n            The line plot.\n\n        See also\n        --------\n        marker_types, LinePlot\n        \"\"\"\n        self._configure_2d()\n        line = scene.LinePlot(data, connect='strip', color=color,\n                              symbol=symbol, line_kind=line_kind,\n                              width=width, marker_size=marker_size,\n                              edge_color=edge_color,\n                              face_color=face_color,\n                              edge_width=edge_width)\n        self.view.add(line)\n        self.view.camera.set_range()\n        self.visuals.append(line)\n\n        if title is not None:\n            self.title.text = title\n        if xlabel is not None:\n            self.xlabel.text = xlabel\n        if ylabel is not None:\n            self.ylabel.text = ylabel\n\n        return line"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncalculating and show a spectrogram of the specified data.", "response": "def spectrogram(self, x, n_fft=256, step=None, fs=1., window='hann',\n                    color_scale='log', cmap='cubehelix', clim='auto'):\n        \"\"\"Calculate and show a spectrogram\n\n        Parameters\n        ----------\n        x : array-like\n            1D signal to operate on. ``If len(x) < n_fft``, x will be\n            zero-padded to length ``n_fft``.\n        n_fft : int\n            Number of FFT points. Much faster for powers of two.\n        step : int | None\n            Step size between calculations. If None, ``n_fft // 2``\n            will be used.\n        fs : float\n            The sample rate of the data.\n        window : str | None\n            Window function to use. Can be ``'hann'`` for Hann window, or None\n            for no windowing.\n        color_scale : {'linear', 'log'}\n            Scale to apply to the result of the STFT.\n            ``'log'`` will use ``10 * log10(power)``.\n        cmap : str\n            Colormap name.\n        clim : str | tuple\n            Colormap limits. Should be ``'auto'`` or a two-element tuple of\n            min and max values.\n\n        Returns\n        -------\n        spec : instance of Spectrogram\n            The spectrogram.\n\n        See also\n        --------\n        Image\n        \"\"\"\n        self._configure_2d()\n        # XXX once we have axes, we should use \"fft_freqs\", too\n        spec = scene.Spectrogram(x, n_fft, step, fs, window,\n                                 color_scale, cmap, clim)\n        self.view.add(spec)\n        self.view.camera.set_range()\n        return spec"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nshow a 3D volume", "response": "def volume(self, vol, clim=None, method='mip', threshold=None,\n               cmap='grays'):\n        \"\"\"Show a 3D volume\n\n        Parameters\n        ----------\n        vol : ndarray\n            Volume to render.\n        clim : tuple of two floats | None\n            The contrast limits. The values in the volume are mapped to\n            black and white corresponding to these values. Default maps\n            between min and max.\n        method : {'mip', 'iso', 'translucent', 'additive'}\n            The render style to use. See corresponding docs for details.\n            Default 'mip'.\n        threshold : float\n            The threshold to use for the isosurafce render style. By default\n            the mean of the given volume is used.\n        cmap : str\n            The colormap to use.\n\n        Returns\n        -------\n        volume : instance of Volume\n            The volume visualization.\n\n        See also\n        --------\n        Volume\n        \"\"\"\n        self._configure_3d()\n        volume = scene.Volume(vol, clim, method, threshold, cmap=cmap)\n        self.view.add(volume)\n        self.view.camera.set_range()\n        return volume"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef surface(self, zdata, **kwargs):\n        self._configure_3d()\n        surf = scene.SurfacePlot(z=zdata, **kwargs)\n        self.view.add(surf)\n        self.view.camera.set_range()\n        return surf", "response": "Show a 3D surface plot."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef colorbar(self, cmap, position=\"right\",\n                 label=\"\", clim=(\"\", \"\"),\n                 border_width=0.0, border_color=\"black\",\n                 **kwargs):\n        \"\"\"Show a ColorBar\n\n        Parameters\n        ----------\n        cmap : str | vispy.color.ColorMap\n            Either the name of the ColorMap to be used from the standard\n            set of names (refer to `vispy.color.get_colormap`),\n            or a custom ColorMap object.\n            The ColorMap is used to apply a gradient on the colorbar.\n        position : {'left', 'right', 'top', 'bottom'}\n            The position of the colorbar with respect to the plot.\n            'top' and 'bottom' are placed horizontally, while\n            'left' and 'right' are placed vertically\n        label : str\n            The label that is to be drawn with the colorbar\n            that provides information about the colorbar.\n        clim : tuple (min, max)\n            the minimum and maximum values of the data that\n            is given to the colorbar. This is used to draw the scale\n            on the side of the colorbar.\n        border_width : float (in px)\n            The width of the border the colormap should have. This measurement\n            is given in pixels\n        border_color : str | vispy.color.Color\n            The color of the border of the colormap. This can either be a\n            str as the color's name or an actual instace of a vipy.color.Color\n\n        Returns\n        -------\n        colorbar : instance of ColorBarWidget\n\n        See also\n        --------\n        ColorBarWidget\n        \"\"\"\n\n        self._configure_2d()\n\n        cbar = scene.ColorBarWidget(orientation=position,\n                                    label_str=label,\n                                    cmap=cmap,\n                                    clim=clim,\n                                    border_width=border_width,\n                                    border_color=border_color,\n                                    **kwargs)\n\n        CBAR_LONG_DIM = 50\n\n        if cbar.orientation == \"bottom\":\n            self.grid.remove_widget(self.cbar_bottom)\n            self.cbar_bottom = self.grid.add_widget(cbar, row=5, col=4)\n            self.cbar_bottom.height_max = \\\n                self.cbar_bottom.height_max = CBAR_LONG_DIM\n\n        elif cbar.orientation == \"top\":\n            self.grid.remove_widget(self.cbar_top)\n            self.cbar_top = self.grid.add_widget(cbar, row=1, col=4)\n            self.cbar_top.height_max = self.cbar_top.height_max = CBAR_LONG_DIM\n\n        elif cbar.orientation == \"left\":\n            self.grid.remove_widget(self.cbar_left)\n            self.cbar_left = self.grid.add_widget(cbar, row=2, col=1)\n            self.cbar_left.width_max = self.cbar_left.width_min = CBAR_LONG_DIM\n\n        else:  # cbar.orientation == \"right\"\n            self.grid.remove_widget(self.cbar_right)\n            self.cbar_right = self.grid.add_widget(cbar, row=2, col=5)\n            self.cbar_right.width_max = \\\n                self.cbar_right.width_min = CBAR_LONG_DIM\n\n        return cbar", "response": "Show a ColorBarWidget for the specified ColorMap and position."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nredraws the Vispy canvas", "response": "def redraw(self):\n        \"\"\"\n        Redraw the Vispy canvas\n        \"\"\"\n        if self._multiscat is not None:\n            self._multiscat._update()\n        self.vispy_widget.canvas.update()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nremoving the layer artist from the visualization", "response": "def remove(self):\n        \"\"\"\n        Remove the layer artist from the visualization\n        \"\"\"\n\n        if self._multiscat is None:\n            return\n\n        self._multiscat.deallocate(self.id)\n        self._multiscat = None\n\n        self._viewer_state.remove_global_callback(self._update_scatter)\n        self.state.remove_global_callback(self._update_scatter)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _check_valid(key, val, valid):\n    if val not in valid:\n        raise ValueError('%s must be one of %s, not \"%s\"'\n                         % (key, valid, val))", "response": "Helper to check if a key value is in the valid options"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nconverts to args representation", "response": "def _to_args(x):\n    \"\"\"Convert to args representation\"\"\"\n    if not isinstance(x, (list, tuple, np.ndarray)):\n        x = [x]\n    return x"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _check_conversion(key, valid_dict):\n    if key not in valid_dict and key not in valid_dict.values():\n        # Only show users the nice string values\n        keys = [v for v in valid_dict.keys() if isinstance(v, string_types)]\n        raise ValueError('value must be one of %s, not %s' % (keys, key))\n    return valid_dict[key] if key in valid_dict else key", "response": "Check for existence of key in dict return value or raise error"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreads pixels from the currently selected buffer.", "response": "def read_pixels(viewport=None, alpha=True, out_type='unsigned_byte'):\n    \"\"\"Read pixels from the currently selected buffer. \n    \n    Under most circumstances, this function reads from the front buffer.\n    Unlike all other functions in vispy.gloo, this function directly executes\n    an OpenGL command.\n\n    Parameters\n    ----------\n    viewport : array-like | None\n        4-element list of x, y, w, h parameters. If None (default),\n        the current GL viewport will be queried and used.\n    alpha : bool\n        If True (default), the returned array has 4 elements (RGBA).\n        If False, it has 3 (RGB).\n    out_type : str | dtype\n        Can be 'unsigned_byte' or 'float'. Note that this does not\n        use casting, but instead determines how values are read from\n        the current buffer. Can also be numpy dtypes ``np.uint8``,\n        ``np.ubyte``, or ``np.float32``.\n\n    Returns\n    -------\n    pixels : array\n        3D array of pixels in np.uint8 or np.float32 format. \n        The array shape is (h, w, 3) or (h, w, 4), with the top-left corner \n        of the framebuffer at index [0, 0] in the returned array.\n    \"\"\"\n    # Check whether the GL context is direct or remote\n    context = get_current_canvas().context\n    if context.shared.parser.is_remote():\n        raise RuntimeError('Cannot use read_pixels() with remote GLIR parser')\n    \n    finish()  # noqa - finish first, also flushes GLIR commands\n    type_dict = {'unsigned_byte': gl.GL_UNSIGNED_BYTE,\n                 np.uint8: gl.GL_UNSIGNED_BYTE,\n                 'float': gl.GL_FLOAT,\n                 np.float32: gl.GL_FLOAT}\n    type_ = _check_conversion(out_type, type_dict)\n    if viewport is None:\n        viewport = gl.glGetParameter(gl.GL_VIEWPORT)\n    viewport = np.array(viewport, int)\n    if viewport.ndim != 1 or viewport.size != 4:\n        raise ValueError('viewport should be 1D 4-element array-like, not %s'\n                         % (viewport,))\n    x, y, w, h = viewport\n    gl.glPixelStorei(gl.GL_PACK_ALIGNMENT, 1)  # PACK, not UNPACK\n    fmt = gl.GL_RGBA if alpha else gl.GL_RGB\n    im = gl.glReadPixels(x, y, w, h, fmt, type_)\n    gl.glPixelStorei(gl.GL_PACK_ALIGNMENT, 4)\n    # reshape, flip, and return\n    if not isinstance(im, np.ndarray):\n        np_dtype = np.uint8 if type_ == gl.GL_UNSIGNED_BYTE else np.float32\n        im = np.frombuffer(im, np_dtype)\n\n    im.shape = h, w, (4 if alpha else 3)  # RGBA vs RGB\n    im = im[::-1, :, :]  # flip the image\n    return im"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_gl_configuration():\n    # XXX eventually maybe we can ask `gl` whether or not we can access these\n    gl.check_error('pre-config check')\n    config = dict()\n    gl.glBindFramebuffer(gl.GL_FRAMEBUFFER, 0)\n    fb_param = gl.glGetFramebufferAttachmentParameter\n    # copied since they aren't in ES:\n    GL_FRONT_LEFT = 1024\n    GL_DEPTH = 6145\n    GL_STENCIL = 6146\n    GL_SRGB = 35904\n    GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING = 33296\n    GL_STEREO = 3123\n    GL_DOUBLEBUFFER = 3122\n    sizes = dict(red=(GL_FRONT_LEFT, 33298),\n                 green=(GL_FRONT_LEFT, 33299),\n                 blue=(GL_FRONT_LEFT, 33300),\n                 alpha=(GL_FRONT_LEFT, 33301),\n                 depth=(GL_DEPTH, 33302),\n                 stencil=(GL_STENCIL, 33303))\n    for key, val in sizes.items():\n        config[key + '_size'] = fb_param(gl.GL_FRAMEBUFFER, val[0], val[1])\n    val = fb_param(gl.GL_FRAMEBUFFER, GL_FRONT_LEFT,\n                   GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING)\n    if val not in (gl.GL_LINEAR, GL_SRGB):\n        raise RuntimeError('unknown value for SRGB: %s' % val)\n    config['srgb'] = True if val == GL_SRGB else False  # GL_LINEAR\n    config['stereo'] = True if gl.glGetParameter(GL_STEREO) else False\n    config['double_buffer'] = (True if gl.glGetParameter(GL_DOUBLEBUFFER)\n                               else False)\n    config['samples'] = gl.glGetParameter(gl.GL_SAMPLES)\n    gl.check_error('post-config check')\n    return config", "response": "Read the current GL configuration."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set_viewport(self, *args):\n        x, y, w, h = args[0] if len(args) == 1 else args\n        self.glir.command('FUNC', 'glViewport', int(x), int(y), int(w), int(h))", "response": "Set the OpenGL viewport of the specified category."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset the depth range of the current object.", "response": "def set_depth_range(self, near=0., far=1.):\n        \"\"\"Set depth values\n    \n        Parameters\n        ----------\n        near : float\n            Near clipping plane.\n        far : float\n            Far clipping plane.\n        \"\"\"\n        self.glir.command('FUNC', 'glDepthRange', float(near), float(far))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset the line width of the current locale.", "response": "def set_line_width(self, width=1.):\n        \"\"\"Set line width\n    \n        Parameters\n        ----------\n        width : float\n            The line width.\n        \"\"\"\n        width = float(width)\n        if width < 0:\n            raise RuntimeError('Cannot have width < 0')\n        self.glir.command('FUNC', 'glLineWidth', width)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef set_polygon_offset(self, factor=0., units=0.):\n        self.glir.command('FUNC', 'glPolygonOffset', float(factor),\n                          float(units))", "response": "Sets the scale and units used to calculate the depth values for the polygon."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nclears the color and depth buffers of the current object.", "response": "def clear(self, color=True, depth=True, stencil=True):\n        \"\"\"Clear the screen buffers\n    \n        This is a wrapper for gl.glClear.\n    \n        Parameters\n        ----------\n        color : bool | str | tuple | instance of Color\n            Clear the color buffer bit. If not bool, ``set_clear_color`` will\n            be used to set the color clear value.\n        depth : bool | float\n            Clear the depth buffer bit. If float, ``set_clear_depth`` will\n            be used to set the depth clear value.\n        stencil : bool | int\n            Clear the stencil buffer bit. If int, ``set_clear_stencil`` will\n            be used to set the stencil clear index.\n        \"\"\"\n        bits = 0\n        if isinstance(color, np.ndarray) or bool(color):\n            if not isinstance(color, bool):\n                self.set_clear_color(color)\n            bits |= gl.GL_COLOR_BUFFER_BIT\n        if depth:\n            if not isinstance(depth, bool):\n                self.set_clear_depth(depth)\n            bits |= gl.GL_DEPTH_BUFFER_BIT\n        if stencil:\n            if not isinstance(stencil, bool):\n                self.set_clear_stencil(stencil)\n            bits |= gl.GL_STENCIL_BUFFER_BIT\n        self.glir.command('FUNC', 'glClear', bits)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset the screen clear color", "response": "def set_clear_color(self, color='black', alpha=None):\n        \"\"\"Set the screen clear color\n\n        This is a wrapper for gl.glClearColor.\n\n        Parameters\n        ----------\n        color : str | tuple | instance of Color\n            Color to use. See vispy.color.Color for options.\n        alpha : float | None\n            Alpha to use.\n        \"\"\"\n        self.glir.command('FUNC', 'glClearColor', *Color(color, alpha).rgba)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set_blend_func(self, srgb='one', drgb='zero',\n                       salpha=None, dalpha=None):\n        \"\"\"Specify pixel arithmetic for RGB and alpha\n    \n        Parameters\n        ----------\n        srgb : str\n            Source RGB factor.\n        drgb : str\n            Destination RGB factor.\n        salpha : str | None\n            Source alpha factor. If None, ``srgb`` is used.\n        dalpha : str\n            Destination alpha factor. If None, ``drgb`` is used.\n        \"\"\"\n        salpha = srgb if salpha is None else salpha\n        dalpha = drgb if dalpha is None else dalpha\n        self.glir.command('FUNC', 'glBlendFuncSeparate', \n                          srgb, drgb, salpha, dalpha)", "response": "Specify pixel arithmetic for RGB and alpha\n    \n       "}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set_blend_equation(self, mode_rgb, mode_alpha=None):\n        mode_alpha = mode_rgb if mode_alpha is None else mode_alpha\n        self.glir.command('FUNC', 'glBlendEquationSeparate', \n                          mode_rgb, mode_alpha)", "response": "Specify the equation for RGB and Alpha blending\n    \n       ."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef set_scissor(self, x, y, w, h):\n        self.glir.command('FUNC', 'glScissor', int(x), int(y), int(w), int(h))", "response": "Define the scissor box."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nset the stencil test function and reference value for the current stencil test.", "response": "def set_stencil_func(self, func='always', ref=0, mask=8, \n                         face='front_and_back'):\n        \"\"\"Set front or back function and reference value\n    \n        Parameters\n        ----------\n        func : str\n            See set_stencil_func.\n        ref : int\n            Reference value for the stencil test.\n        mask : int\n            Mask that is ANDed with ref and stored stencil value.\n        face : str\n            Can be 'front', 'back', or 'front_and_back'.\n        \"\"\"\n        self.glir.command('FUNC', 'glStencilFuncSeparate', \n                          face, func, int(ref), int(mask))"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncontrol the front or back writing of individual bits in the stencil.", "response": "def set_stencil_mask(self, mask=8, face='front_and_back'):\n        \"\"\"Control the front or back writing of individual bits in the stencil\n    \n        Parameters\n        ----------\n        mask : int\n            Mask that is ANDed with ref and stored stencil value.\n        face : str\n            Can be 'front', 'back', or 'front_and_back'.\n        \"\"\"\n        self.glir.command('FUNC', 'glStencilMaskSeparate', face, int(mask))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef set_stencil_op(self, sfail='keep', dpfail='keep', dppass='keep',\n                       face='front_and_back'):\n        \"\"\"Set front or back stencil test actions\n    \n        Parameters\n        ----------\n        sfail : str\n            Action to take when the stencil fails. Must be one of\n            'keep', 'zero', 'replace', 'incr', 'incr_wrap',\n            'decr', 'decr_wrap', or 'invert'.\n        dpfail : str\n            Action to take when the stencil passes.\n        dppass : str\n            Action to take when both the stencil and depth tests pass,\n            or when the stencil test passes and either there is no depth\n            buffer or depth testing is not enabled.\n        face : str\n            Can be 'front', 'back', or 'front_and_back'.\n        \"\"\"\n        self.glir.command('FUNC', 'glStencilOpSeparate', \n                          face, sfail, dpfail, dppass)", "response": "Set the stencil test actions for a specific buffer."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set_color_mask(self, red, green, blue, alpha):\n        self.glir.command('FUNC', 'glColorMask', bool(red), bool(green), \n                          bool(blue), bool(alpha))", "response": "Toggle writing of frame buffer color components\n    \n       "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsetting the coverage of the sample in the current context.", "response": "def set_sample_coverage(self, value=1.0, invert=False):\n        \"\"\"Specify multisample coverage parameters\n    \n        Parameters\n        ----------\n        value : float\n            Sample coverage value (will be clamped between 0. and 1.).\n        invert : bool\n            Specify if the coverage masks should be inverted.\n        \"\"\"\n        self.glir.command('FUNC', 'glSampleCoverage', float(value), \n                          bool(invert))"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsets the state of the OpenGL rendering system for the specified object.", "response": "def set_state(self, preset=None, **kwargs):\n        \"\"\"Set OpenGL rendering state, optionally using a preset\n    \n        Parameters\n        ----------\n        preset : str | None\n            Can be one of ('opaque', 'translucent', 'additive') to use\n            use reasonable defaults for these typical use cases.\n        **kwargs : keyword arguments\n            Other supplied keyword arguments will override any preset defaults.\n            Options to be enabled or disabled should be supplied as booleans\n            (e.g., ``'depth_test=True'``, ``cull_face=False``), non-boolean\n            entries will be passed as arguments to ``set_*`` functions (e.g.,\n            ``blend_func=('src_alpha', 'one')`` will call ``set_blend_func``).\n    \n        Notes\n        -----\n        This serves three purposes:\n    \n        1. Set GL state using reasonable presets.\n        2. Wrapping glEnable/glDisable functionality.\n        3. Convienence wrapping of other ``gloo.set_*`` functions.\n    \n        For example, one could do the following:\n    \n            >>> from vispy import gloo\n            >>> gloo.set_state('translucent', depth_test=False, clear_color=(1, 1, 1, 1))  # noqa, doctest:+SKIP\n    \n        This would take the preset defaults for 'translucent', turn\n        depth testing off (which would normally be on for that preset),\n        and additionally set the glClearColor parameter to be white.\n    \n        Another example to showcase glEnable/glDisable wrapping:\n    \n            >>> gloo.set_state(blend=True, depth_test=True, polygon_offset_fill=False)  # noqa, doctest:+SKIP\n    \n        This would be equivalent to calling\n    \n            >>> from vispy.gloo import gl\n            >>> gl.glDisable(gl.GL_BLEND)\n            >>> gl.glEnable(gl.GL_DEPTH_TEST)\n            >>> gl.glEnable(gl.GL_POLYGON_OFFSET_FILL)\n    \n        Or here's another example:\n    \n            >>> gloo.set_state(clear_color=(0, 0, 0, 1), blend=True, blend_func=('src_alpha', 'one'))  # noqa, doctest:+SKIP\n    \n        Thus arbitrary GL state components can be set directly using\n        ``set_state``. Note that individual functions are exposed e.g.,\n        as ``set_clear_color``, with some more informative docstrings\n        about those particular functions.\n        \"\"\"\n        kwargs = deepcopy(kwargs)\n        \n        # Load preset, if supplied\n        if preset is not None:\n            _check_valid('preset', preset, tuple(list(_gl_presets.keys())))\n            for key, val in _gl_presets[preset].items():\n                # only overwrite user input with preset if user's input is None\n                if key not in kwargs:\n                    kwargs[key] = val\n    \n        # cull_face is an exception because GL_CULL_FACE, glCullFace both exist\n        if 'cull_face' in kwargs:\n            cull_face = kwargs.pop('cull_face')\n            if isinstance(cull_face, bool):\n                funcname = 'glEnable' if cull_face else 'glDisable'\n                self.glir.command('FUNC', funcname, 'cull_face')\n            else:\n                self.glir.command('FUNC', 'glEnable', 'cull_face')\n                self.set_cull_face(*_to_args(cull_face))\n        \n        # Iterate over kwargs\n        for key, val in kwargs.items():\n            if key in _setters:\n                # Setter\n                args = _to_args(val)\n                # these actually need tuples\n                if key in ('blend_color', 'clear_color') and \\\n                        not isinstance(args[0], string_types):\n                    args = [args]\n                getattr(self, 'set_' + key)(*args)\n            else:\n                # Enable / disable\n                funcname = 'glEnable' if val else 'glDisable'\n                self.glir.command('FUNC', funcname, key)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nwait for GL commands to finish processing the", "response": "def finish(self):\n        \"\"\"Wait for GL commands to to finish\n        \n        This creates a GLIR command for glFinish and then processes the\n        GLIR commands. If the GLIR interpreter is remote (e.g. WebGL), this\n        function will return before GL has finished processing the commands.\n        \"\"\"\n        if hasattr(self, 'flush_commands'):\n            context = self\n        else:\n            context = get_current_canvas().context\n        context.glir.command('FUNC', 'glFinish')\n        context.flush_commands()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef flush(self):\n        if hasattr(self, 'flush_commands'):\n            context = self\n        else:\n            context = get_current_canvas().context\n        context.glir.command('FUNC', 'glFlush')\n        context.flush_commands()", "response": "Flush GL commands that are currently in use."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef set_hint(self, target, mode):\n        if not all(isinstance(tm, string_types) for tm in (target, mode)):\n            raise TypeError('target and mode must both be strings')\n        self.glir.command('FUNC', 'glHint', target, mode)", "response": "Set OpenGL drawing hint for the specified target and mode."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the GLIR queue corresponding to the current canvas s GLIR queue.", "response": "def glir(self):\n        \"\"\" The GLIR queue corresponding to the current canvas\n        \"\"\"\n        canvas = get_current_canvas()\n        if canvas is None:\n            msg = (\"If you want to use gloo without vispy.app, \" + \n                   \"use a gloo.context.FakeCanvas.\")\n            raise RuntimeError('Gloo requires a Canvas to run.\\n' + msg)\n        return canvas.context.glir"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nlet Vispy use the target OpenGL GL backend.", "response": "def use_gl(target='gl2'):\n    \"\"\" Let Vispy use the target OpenGL ES 2.0 implementation\n    \n    Also see ``vispy.use()``.\n    \n    Parameters\n    ----------\n    target : str\n        The target GL backend to use.\n\n    Available backends:\n    * gl2 - Use ES 2.0 subset of desktop (i.e. normal) OpenGL\n    * gl+ - Use the desktop ES 2.0 subset plus all non-deprecated GL\n      functions on your system (requires PyOpenGL)\n    * es2 - Use the ES2 library (Angle/DirectX on Windows)\n    * pyopengl2 - Use ES 2.0 subset of pyopengl (for fallback and testing)\n    * dummy - Prevent usage of gloo.gl (for when rendering occurs elsewhere)\n    \n    You can use vispy's config option \"gl_debug\" to check for errors\n    on each API call. Or, one can specify it as the target, e.g. \"gl2\n    debug\". (Debug does not apply to 'gl+', since PyOpenGL has its own\n    debug mechanism)\n    \"\"\"\n    target = target or 'gl2'\n    target = target.replace('+', 'plus')\n    \n    # Get options\n    target, _, options = target.partition(' ')\n    debug = config['gl_debug'] or 'debug' in options\n    \n    # Select modules to import names from\n    try:\n        mod = __import__(target, globals(), level=1)\n    except ImportError as err:\n        msg = 'Could not import gl target \"%s\":\\n%s' % (target, str(err))\n        raise RuntimeError(msg)\n\n    # Apply\n    global current_backend\n    current_backend = mod\n    _clear_namespace()\n    if 'plus' in target:\n        # Copy PyOpenGL funcs, extra funcs, constants, no debug\n        _copy_gl_functions(mod._pyopengl2, globals())\n        _copy_gl_functions(mod, globals(), True)\n    elif debug:\n        _copy_gl_functions(_debug_proxy, globals())\n    else:\n        _copy_gl_functions(mod, globals())"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nclearing the names that are not part of the strict ES API", "response": "def _clear_namespace():\n    \"\"\" Clear names that are not part of the strict ES API\n    \"\"\"\n    ok_names = set(default_backend.__dict__)\n    ok_names.update(['gl2', 'glplus'])  # don't remove the module\n    NS = globals()\n    for name in list(NS.keys()):\n        if name.lower().startswith('gl'):\n            if name not in ok_names:\n                del NS[name]"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nchecks this from time to time to detect GL errors.", "response": "def check_error(when='periodic check'):\n    \"\"\" Check this from time to time to detect GL errors.\n\n    Parameters\n    ----------\n    when : str\n        Shown in the exception to help the developer determine when\n        this check was done.\n    \"\"\"\n\n    errors = []\n    while True:\n        err = glGetError()\n        if err == GL_NO_ERROR or (errors and err == errors[-1]):\n            break\n        errors.append(err)\n    if errors:\n        msg = ', '.join([repr(ENUM_MAP.get(e, e)) for e in errors])\n        err = RuntimeError('OpenGL got errors (%s): %s' % (when, msg))\n        err.errors = errors\n        err.err = errors[-1]  # pyopengl compat\n        raise err"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets a useful represetation of an argument.", "response": "def _arg_repr(self, arg):\n        \"\"\" Get a useful (and not too large) represetation of an argument.\n        \"\"\"\n        r = repr(arg)\n        max = 40\n        if len(r) > max:\n            if hasattr(arg, 'shape'):\n                r = 'array:' + 'x'.join([repr(s) for s in arg.shape])\n            else:\n                r = r[:max-3] + '...'\n        return r"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset the scalar array data.", "response": "def set_data(self, data):\n        \"\"\" Set the scalar array data\n\n        Parameters\n        ----------\n        data : ndarray\n            A 2D array of scalar values. The isocurve is constructed to show\n            all locations in the scalar field equal to ``self.levels``.\n        \"\"\"\n        self._data = data\n\n        # if using matplotlib isoline algorithm we have to check for meshgrid\n        # and we can setup the tracer object here\n        if _HAS_MPL:\n            if self._X is None or self._X.T.shape != data.shape:\n                self._X, self._Y = np.meshgrid(np.arange(data.shape[0]),\n                                               np.arange(data.shape[1]))\n            self._iso = cntr.Cntr(self._X, self._Y, self._data.astype(float))\n\n        if self._clim is None:\n            self._clim = (data.min(), data.max())\n\n        # sanity check,\n        # should we raise an error here, since no isolines can be drawn?\n        # for now, _prepare_draw returns False if no isoline can be drawn\n        if self._data.min() != self._data.max():\n            self._data_is_uniform = False\n        else:\n            self._data_is_uniform = True\n\n        self._need_recompute = True\n        self.update()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _get_verts_and_connect(self, paths):\n        verts = np.vstack(paths)\n        gaps = np.add.accumulate(np.array([len(x) for x in paths])) - 1\n        connect = np.ones(gaps[-1], dtype=bool)\n        connect[gaps[:-1]] = False\n        return verts, connect", "response": "retrieve vertices and connects from given paths - list\n       "}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _compute_iso_line(self):\n        level_index = []\n        connects = []\n        verts = []\n\n        # calculate which level are within data range\n        # this works for now and the existing examples, but should be tested\n        # thoroughly also with the data-sanity check in set_data-function\n        choice = np.nonzero((self.levels > self._data.min()) &\n                            (self._levels < self._data.max()))\n        levels_to_calc = np.array(self.levels)[choice]\n\n        # save minimum level index\n        self._level_min = choice[0][0]\n\n        for level in levels_to_calc:\n            # if we use matplotlib isoline algorithm we need to add half a\n            # pixel in both (x,y) dimensions because isolines are aligned to\n            # pixel centers\n            if _HAS_MPL:\n                nlist = self._iso.trace(level, level, 0)\n                paths = nlist[:len(nlist)//2]\n                v, c = self._get_verts_and_connect(paths)\n                v += np.array([0.5, 0.5])\n            else:\n                paths = isocurve(self._data.astype(float).T, level,\n                                 extend_to_edge=True, connected=True)\n                v, c = self._get_verts_and_connect(paths)\n\n            level_index.append(v.shape[0])\n            connects.append(np.hstack((c, [False])))\n            verts.append(v)\n\n        self._li = np.hstack(level_index)\n        self._connect = np.hstack(connects)\n        self._verts = np.vstack(verts)", "response": "compute LineVisual vertices connects and color - index"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef connect(self, callback, ref=False, position='first',\n                before=None, after=None):\n        \"\"\"Connect this emitter to a new callback.\n\n        Parameters\n        ----------\n        callback : function | tuple\n            *callback* may be either a callable object or a tuple\n            (object, attr_name) where object.attr_name will point to a\n            callable object. Note that only a weak reference to ``object``\n            will be kept.\n        ref : bool | str\n            Reference used to identify the callback in ``before``/``after``.\n            If True, the callback ref will automatically determined (see\n            Notes). If False, the callback cannot be referred to by a string.\n            If str, the given string will be used. Note that if ``ref``\n            is not unique in ``callback_refs``, an error will be thrown.\n        position : str\n            If ``'first'``, the first eligible position is used (that\n            meets the before and after criteria), ``'last'`` will use\n            the last position.\n        before : str | callback | list of str or callback | None\n            List of callbacks that the current callback should precede.\n            Can be None if no before-criteria should be used.\n        after : str | callback | list of str or callback | None\n            List of callbacks that the current callback should follow.\n            Can be None if no after-criteria should be used.\n\n        Notes\n        -----\n        If ``ref=True``, the callback reference will be determined from:\n\n            1. If ``callback`` is ``tuple``, the secend element in the tuple.\n            2. The ``__name__`` attribute.\n            3. The ``__class__.__name__`` attribute.\n\n        The current list of callback refs can be obtained using\n        ``event.callback_refs``. Callbacks can be referred to by either\n        their string reference (if given), or by the actual callback that\n        was attached (e.g., ``(canvas, 'swap_buffers')``).\n\n        If the specified callback is already connected, then the request is\n        ignored.\n\n        If before is None and after is None (default), the new callback will\n        be added to the beginning of the callback list. Thus the\n        callback that is connected _last_ will be the _first_ to receive\n        events from the emitter.\n        \"\"\"\n        callbacks = self.callbacks\n        callback_refs = self.callback_refs\n        \n        callback = self._normalize_cb(callback)\n        \n        if callback in callbacks:\n            return\n        \n        # deal with the ref\n        if isinstance(ref, bool):\n            if ref:\n                if isinstance(callback, tuple):\n                    ref = callback[1]\n                elif hasattr(callback, '__name__'):  # function\n                    ref = callback.__name__\n                else:  # Method, or other\n                    ref = callback.__class__.__name__\n            else:\n                ref = None\n        elif not isinstance(ref, string_types):\n            raise TypeError('ref must be a bool or string')\n        if ref is not None and ref in self._callback_refs:\n            raise ValueError('ref \"%s\" is not unique' % ref)\n\n        # positions\n        if position not in ('first', 'last'):\n            raise ValueError('position must be \"first\" or \"last\", not %s'\n                             % position)\n\n        # bounds\n        bounds = list()  # upper & lower bnds (inclusive) of possible cb locs\n        for ri, criteria in enumerate((before, after)):\n            if criteria is None or criteria == []:\n                bounds.append(len(callback_refs) if ri == 0 else 0)\n            else:\n                if not isinstance(criteria, list):\n                    criteria = [criteria]\n                for c in criteria:\n                    count = sum([(c == cn or c == cc) for cn, cc\n                                 in zip(callback_refs, callbacks)])\n                    if count != 1:\n                        raise ValueError('criteria \"%s\" is in the current '\n                                         'callback list %s times:\\n%s\\n%s'\n                                         % (criteria, count,\n                                            callback_refs, callbacks))\n                matches = [ci for ci, (cn, cc) in enumerate(zip(callback_refs,\n                                                                callbacks))\n                           if (cc in criteria or cn in criteria)]\n                bounds.append(matches[0] if ri == 0 else (matches[-1] + 1))\n        if bounds[0] < bounds[1]:  # i.e., \"place before\" < \"place after\"\n            raise RuntimeError('cannot place callback before \"%s\" '\n                               'and after \"%s\" for callbacks: %s'\n                               % (before, after, callback_refs))\n        idx = bounds[1] if position == 'first' else bounds[0]  # 'last'\n\n        # actually add the callback\n        self._callbacks.insert(idx, callback)\n        self._callback_refs.insert(idx, ref)\n        return callback", "response": "Connect this emitter to a new callback."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef disconnect(self, callback=None):\n        if callback is None:\n            self._callbacks = []\n            self._callback_refs = []\n        else:\n            callback = self._normalize_cb(callback)\n            if callback in self._callbacks:\n                idx = self._callbacks.index(callback)\n                self._callbacks.pop(idx)\n                self._callback_refs.pop(idx)", "response": "Disconnect a callback from this emitter."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef block(self, callback=None):\n        self._blocked[callback] = self._blocked.get(callback, 0) + 1", "response": "Block this emitter. Any attempts to emit an event while blocked\n        will be silently ignored. If *callback* is given, then the emitter\n        is only blocked for that specific callback.\n\n        Calls to block are cumulative; the emitter must be unblocked the same\n        number of times as it is blocked."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef unblock(self, callback=None):\n        if callback not in self._blocked or self._blocked[callback] == 0:\n            raise RuntimeError(\"Cannot unblock %s for callback %s; emitter \"\n                               \"was not previously blocked.\" % \n                               (self, callback))\n        b = self._blocked[callback] - 1\n        if b == 0 and callback is not None:\n            del self._blocked[callback]\n        else:\n            self._blocked[callback] = b", "response": "Unblock this emitter. See :func:`event.EventEmitter.block`.\n        \n        Note: Use of ``unblock(None)`` only reverses the effect of \n        ``block(None)``; it does not unblock callbacks that were explicitly \n        blocked using ``block(callback)``."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef add(self, auto_connect=None, **kwargs):\n        if auto_connect is None:\n            auto_connect = self.auto_connect\n\n        # check all names before adding anything\n        for name in kwargs:\n            if name in self._emitters:\n                raise ValueError(\n                    \"EmitterGroup already has an emitter named '%s'\" %\n                    name)\n            elif hasattr(self, name):\n                raise ValueError(\"The name '%s' cannot be used as an emitter; \"\n                                 \"it is already an attribute of EmitterGroup\"\n                                 % name)\n\n        # add each emitter specified in the keyword arguments\n        for name, emitter in kwargs.items():\n            if emitter is None:\n                emitter = Event\n\n            if inspect.isclass(emitter) and issubclass(emitter, Event):\n                emitter = EventEmitter(\n                    source=self.source,\n                    type=name,\n                    event_class=emitter)\n            elif not isinstance(emitter, EventEmitter):\n                raise Exception('Emitter must be specified as either an '\n                                'EventEmitter instance or Event subclass. '\n                                '(got %s=%s)' % (name, emitter))\n\n            # give this emitter the same source as the group.\n            emitter.source = self.source\n\n            setattr(self, name, emitter)\n            self._emitters[name] = emitter\n\n            if auto_connect and self.source is not None:\n                emitter.connect((self.source, self.auto_connect_format % name))\n\n            # If emitters are connected to the group already, then this one\n            # should be connected as well.\n            if self._emitters_connected:\n                emitter.connect(self)", "response": "Adds one or more Emitters to this emitter group."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nblock all emitters in this group.", "response": "def block_all(self):\n        \"\"\" Block all emitters in this group.\n        \"\"\"\n        self.block()\n        for em in self._emitters.values():\n            em.block()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nunblocking all emitters in this group.", "response": "def unblock_all(self):\n        \"\"\" Unblock all emitters in this group.\n        \"\"\"\n        self.unblock()\n        for em in self._emitters.values():\n            em.unblock()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef connect(self, callback, ref=False, position='first',\n                before=None, after=None):\n        \"\"\" Connect the callback to the event group. The callback will receive\n        events from *all* of the emitters in the group.\n\n        See :func:`EventEmitter.connect() <vispy.event.EventEmitter.connect>`\n        for arguments.\n        \"\"\"\n        self._connect_emitters(True)\n        return EventEmitter.connect(self, callback, ref, position,\n                                    before, after)", "response": "Connect the callback to the event group."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef disconnect(self, callback=None):\n        ret = EventEmitter.disconnect(self, callback)\n        if len(self._callbacks) == 0:\n            self._connect_emitters(False)\n        return ret", "response": "Disconnect the callback from this group."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef validate_input_format(utterance, intent):\n    slots = {slot[\"name\"] for slot in intent[\"slots\"]}\n    split_utt = re.split(\"{(.*)}\", utterance)\n    banned = set(\"-/\\\\()^%$#@~`-_=+><;:\") # Banned characters\n\n    for token in split_utt:\n        if (banned & set(token)):\n            print (\" - Banned character found in substring\", token)\n            print (\" - Banned character list\", banned)\n            return False\n\n        if \"|\" in token:\n            split_token = token.split(\"|\")\n            if len(split_token)!=2:\n                print (\" - Error, token is incorrect in\", token, split_token)\n                return False\n\n            word, slot = split_token\n            if slot.strip() not in slots:\n                print (\" -\", slot, \"is not a valid slot for this Intent, valid slots are\", slots)\n                return False\n    return True", "response": "Validate input format for the Alerting App."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngenerating an isosurface from volumetric data using marching cubes algorithm.", "response": "def isosurface(data, level):\n    \"\"\"\n    Generate isosurface from volumetric data using marching cubes algorithm.\n    See Paul Bourke, \"Polygonising a Scalar Field\"  \n    (http://paulbourke.net/geometry/polygonise/)\n    \n    *data*   3D numpy array of scalar values\n    *level*  The level at which to generate an isosurface\n    \n    Returns an array of vertex coordinates (Nv, 3) and an array of \n    per-face vertex indexes (Nf, 3)    \n    \"\"\"\n    # For improvement, see:\n    # \n    # Efficient implementation of Marching Cubes' cases with topological \n    # guarantees.\n    # Thomas Lewiner, Helio Lopes, Antonio Wilson Vieira and Geovan Tavares.\n    # Journal of Graphics Tools 8(2): pp. 1-15 (december 2003)\n\n    (face_shift_tables, edge_shifts, \n     edge_table, n_table_faces) = _get_data_cache()\n    \n    ## mark everything below the isosurface level\n    mask = data < level\n\n    # Because we make use of the strides data attribute below, we have to make \n    # sure that the data is contiguous (which it won't be if the user did \n    # data.transpose() for example). Note that this doesn't copy the data if it \n    # is already contiguous.\n    data = np.ascontiguousarray(data)\n\n    ### make eight sub-fields and compute indexes for grid cells\n    index = np.zeros([x-1 for x in data.shape], dtype=np.ubyte)\n    fields = np.empty((2, 2, 2), dtype=object)\n    slices = [slice(0, -1), slice(1, None)]\n    for i in [0, 1]:\n        for j in [0, 1]:\n            for k in [0, 1]:\n                fields[i, j, k] = mask[slices[i], slices[j], slices[k]]\n                # this is just to match Bourk's vertex numbering scheme:\n                vertIndex = i - 2*j*i + 3*j + 4*k\n                index += (fields[i, j, k] * 2**vertIndex).astype(np.ubyte)\n    \n    ### Generate table of edges that have been cut\n    cut_edges = np.zeros([x+1 for x in index.shape]+[3], dtype=np.uint32)\n    edges = edge_table[index]\n    for i, shift in enumerate(edge_shifts[:12]):        \n        slices = [slice(shift[j], cut_edges.shape[j]+(shift[j]-1)) \n                  for j in range(3)]\n        cut_edges[slices[0], slices[1], slices[2], shift[3]] += edges & 2**i\n    \n    # for each cut edge, interpolate to see where exactly the edge is cut and \n    # generate vertex positions\n    m = cut_edges > 0\n    vertex_inds = np.argwhere(m)  # argwhere is slow!\n    vertexes = vertex_inds[:, :3].astype(np.float32).copy()\n    dataFlat = data.reshape(data.shape[0]*data.shape[1]*data.shape[2])\n    \n    ## re-use the cut_edges array as a lookup table for vertex IDs\n    cut_edges[vertex_inds[:, 0], \n              vertex_inds[:, 1], \n              vertex_inds[:, 2], \n              vertex_inds[:, 3]] = np.arange(vertex_inds.shape[0])\n    \n    for i in [0, 1, 2]:\n        vim = vertex_inds[:, 3] == i\n        vi = vertex_inds[vim, :3]\n        vi_flat = (vi * (np.array(data.strides[:3]) // \n                         data.itemsize)[np.newaxis, :]).sum(axis=1)\n        v1 = dataFlat[vi_flat]\n        v2 = dataFlat[vi_flat + data.strides[i]//data.itemsize]\n        vertexes[vim, i] += (level-v1) / (v2-v1)\n    \n    ### compute the set of vertex indexes for each face. \n    \n    ## This works, but runs a bit slower.\n    ## all cells with at least one face:\n    #cells = np.argwhere((index != 0) & (index != 255))  \n    #cellInds = index[cells[:, 0], cells[:, 1], cells[:, 2]]\n    #verts = faceTable[cellInds]\n    #mask = verts[..., 0, 0] != 9\n    ## we now have indexes into cut_edges:\n    #verts[...,:3] += cells[:, np.newaxis, np.newaxis,:]\n    #verts = verts[mask]\n    ## and these are the vertex indexes we want:\n    #faces = cut_edges[verts[..., 0], verts[..., 1], verts[..., 2], \n    #                  verts[..., 3]]  \n    \n    # To allow this to be vectorized efficiently, we count the number of faces \n    # in each grid cell and handle each group of cells with the same number \n    # together.\n    \n    # determine how many faces to assign to each grid cell\n    n_faces = n_table_faces[index]\n    tot_faces = n_faces.sum()\n    faces = np.empty((tot_faces, 3), dtype=np.uint32)\n    ptr = 0\n    \n    ## this helps speed up an indexing operation later on\n    cs = np.array(cut_edges.strides)//cut_edges.itemsize\n    cut_edges = cut_edges.flatten()\n\n    ## this, strangely, does not seem to help.\n    #ins = np.array(index.strides)/index.itemsize\n    #index = index.flatten()\n\n    for i in range(1, 6):\n        # expensive:\n        # all cells which require i faces  (argwhere is expensive)\n        cells = np.argwhere(n_faces == i)  \n        if cells.shape[0] == 0:\n            continue\n        # index values of cells to process for this round:\n        cellInds = index[cells[:, 0], cells[:, 1], cells[:, 2]]\n        \n        # expensive:\n        verts = face_shift_tables[i][cellInds]\n        # we now have indexes into cut_edges:\n        verts[..., :3] += (cells[:, np.newaxis,\n                                 np.newaxis, :]).astype(np.uint16)\n        verts = verts.reshape((verts.shape[0]*i,)+verts.shape[2:])\n        \n        # expensive:\n        verts = (verts * cs[np.newaxis, np.newaxis, :]).sum(axis=2)\n        vert_inds = cut_edges[verts]\n        nv = vert_inds.shape[0]\n        faces[ptr:ptr+nv] = vert_inds  # .reshape((nv, 3))\n        ptr += nv\n        \n    return vertexes, faces"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nextract all data buffers from the list of GLIR commands and replace them by buffer pointers. Return the modified list and the list of buffers as well.", "response": "def _extract_buffers(commands):\n    \"\"\"Extract all data buffers from the list of GLIR commands, and replace\n    them by buffer pointers {buffer: <buffer_index>}. Return the modified list\n    # of GILR commands and the list of buffers as well.\"\"\"\n    # First, filter all DATA commands.\n    data_commands = [command for command in commands if command[0] == 'DATA']\n    # Extract the arrays.\n    buffers = [data_command[3] for data_command in data_commands]\n    # Modify the commands by replacing the array buffers with pointers.\n    commands_modified = list(commands)\n    buffer_index = 0\n    for i, command in enumerate(commands_modified):\n        if command[0] == 'DATA':\n            commands_modified[i] = command[:3] + \\\n                ({'buffer_index': buffer_index},)\n            buffer_index += 1\n    return commands_modified, buffers"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate a JSON - serializable message of GLIR commands.", "response": "def create_glir_message(commands, array_serialization=None):\n    \"\"\"Create a JSON-serializable message of GLIR commands. NumPy arrays\n    are serialized according to the specified method.\n\n    Arguments\n    ---------\n\n    commands : list\n        List of GLIR commands.\n    array_serialization : string or None\n        Serialization method for NumPy arrays. Possible values are:\n            'binary' (default) : use a binary string\n            'base64' : base64 encoded string of the array\n\n    \"\"\"\n    # Default serialization method for NumPy arrays.\n    if array_serialization is None:\n        array_serialization = 'binary'\n    # Extract the buffers.\n    commands_modified, buffers = _extract_buffers(commands)\n    # Serialize the modified commands (with buffer pointers) and the buffers.\n    commands_serialized = [_serialize_command(command_modified)\n                           for command_modified in commands_modified]\n    buffers_serialized = [_serialize_buffer(buffer, array_serialization)\n                          for buffer in buffers]\n    # Create the final message.\n    msg = {\n        'msg_type': 'glir_commands',\n        'commands': commands_serialized,\n        'buffers': buffers_serialized,\n    }\n    return msg"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef request(self, command_string):\n\n        self.send(command_string)\n        if self.debug:\n            print(\"Telnet Request:  %s\" % (command_string))\n        while True:\n            response = urllib.parse.unquote(self.tn.read_until(b\"\\n\").decode())\n            if \"success\" in response:   # Normal successful reply\n                break\n            if \"huh\" in response:       # Something went wrong\n                break\n            if \"connect\" in response:   # Special reply to \"hello\"\n                break\n            # TODO Keep track of which screen is displayed\n            # Try again if response was key, menu or visibility notification.\n        if \"huh\" in response or self.debug:\n            print(\"Telnet Response: %s\" % (response[:-1]))\n        return response", "response": "Send a command to the Telnet server and return the response."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef add_screen(self, ref):\n\n        \"\"\" Add Screen \"\"\"\n\n        if ref not in self.screens:\n            screen = Screen(self, ref)\n            screen.clear()              # TODO Check this is needed, new screens should be clear.\n            self.screens[ref] = screen\n            return self.screens[ref]", "response": "Add a screen to the list of screens."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef add_key(self, ref, mode=\"shared\"):\n        if ref not in self.keys:\n            response = self.request(\"client_add_key %s -%s\" % (ref, mode))\n            if \"success\" not in response:\n                return None\n            self.keys.append(ref)\n            return ref", "response": "Add a key to the cache."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef del_key(self, ref):\n        if ref not in self.keys:\n            response = self.request(\"client_del_key %s\" % (ref))\n            self.keys.remove(ref)\n            if \"success\" in response:\n                return None\n            else:\n                return response", "response": "Delete a key.\n\n        (ref)\n        Return None or LCDd response on error"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nlaunches browser and virtual display first of all to be launched", "response": "def launch(self):\n        \"\"\"launch browser and virtual display, first of all to be launched\"\"\"\n        try:\n            # init virtual Display\n            self.vbro = Display()\n            self.vbro.start()\n            logger.debug(\"virtual display launched\")\n        except Exception:\n            raise exceptions.VBroException()\n        try:\n            self.browser = Browser(self.brow_name)\n            logger.debug(f\"browser {self.brow_name} launched\")\n        except Exception:\n            raise exceptions.BrowserException(\n                self.brow_name, \"failed to launch\")\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef css(self, css_path, dom=None):\n        if dom is None:\n            dom = self.browser\n        return expect(dom.find_by_css, args=[css_path])", "response": "css find function abbreviation"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef css1(self, css_path, dom=None):\n        if dom is None:\n            dom = self.browser\n\n        def _css1(path, domm):\n            \"\"\"virtual local func\"\"\"\n            return self.css(path, domm)[0]\n\n        return expect(_css1, args=[css_path, dom])", "response": "return the first value of self. css"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef search_name(self, name, dom=None):\n        if dom is None:\n            dom = self.browser\n        return expect(dom.find_by_name, args=[name])", "response": "name find function abbreviation"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef xpath(self, xpath, dom=None):\n        if dom is None:\n            dom = self.browser\n        return expect(dom.find_by_xpath, args=[xpath])", "response": "xpath find function abbreviation"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef elCss(self, css_path, dom=None):\n        if dom is None:\n            dom = self.browser\n        return expect(dom.is_element_present_by_css, args=[css_path])", "response": "check if element is present by css"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nchecks if element is present by xpath", "response": "def elXpath(self, xpath, dom=None):\n        \"\"\"check if element is present by css\"\"\"\n        if dom is None:\n            dom = self.browser\n        return expect(dom.is_element_present_by_xpath, args=[xpath])"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef new_pos(self, html_div):\n        pos = self.Position(self, html_div)\n        pos.bind_mov()\n        self.positions.append(pos)\n        return pos", "response": "create a new position"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nconverts a host : port string to a Connection tuple.", "response": "def _make_hostport(conn, default_host, default_port, default_user='', default_password=None):\n    \"\"\"Convert a '[user[:pass]@]host:port' string to a Connection tuple.\n\n    If the given connection is empty, use defaults.\n    If no port is given, use the default.\n\n    Args:\n        conn (str): the string describing the target hsot/port\n        default_host (str): the host to use if ``conn`` is empty\n        default_port (int): the port to use if not given in ``conn``.\n\n    Returns:\n        (str, int): a (host, port) tuple.\n    \"\"\"\n    parsed = urllib.parse.urlparse('//%s' % conn)\n    return Connection(\n        parsed.hostname or default_host,\n        parsed.port or default_port,\n        parsed.username if parsed.username is not None else default_user,\n        parsed.password if parsed.password is not None else default_password,\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate and connect to the LCDd server.", "response": "def _make_lcdproc(\n        lcd_host, lcd_port, retry_config,\n        charset=DEFAULT_LCDPROC_CHARSET, lcdd_debug=False):\n    \"\"\"Create and connect to the LCDd server.\n\n    Args:\n        lcd_host (str): the hostname to connect to\n        lcd_prot (int): the port to connect to\n        charset (str): the charset to use when sending messages to lcdproc\n        lcdd_debug (bool): whether to enable full LCDd debug\n        retry_attempts (int): the number of connection attempts\n        retry_wait (int): the time to wait between connection attempts\n        retry_backoff (int): the backoff for increasing inter-attempt delay\n\n    Returns:\n        lcdproc.server.Server\n    \"\"\"\n\n    class ServerSpawner(utils.AutoRetryCandidate):\n        \"\"\"Spawn the server, using auto-retry.\"\"\"\n\n        @utils.auto_retry\n        def connect(self):\n            return lcdrunner.LcdProcServer(\n                lcd_host, lcd_port, charset=charset, debug=lcdd_debug)\n\n    spawner = ServerSpawner(retry_config=retry_config, logger=logger)\n\n    try:\n        return spawner.connect()\n    except socket.error as e:\n        logger.error('Unable to connect to lcdproc %s:%s : %r', lcd_host, lcd_port, e)\n        raise SystemExit(1)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _make_patterns(patterns):\n    field_registry = display_fields.FieldRegistry()\n\n    pattern_list = display_pattern.ScreenPatternList(\n        field_registry=field_registry,\n    )\n    for pattern in patterns:\n        pattern_list.add(pattern.split('\\n'))\n    return pattern_list", "response": "Create a ScreenPatternList from a given pattern text."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef run_forever(\n        lcdproc='', mpd='', lcdproc_screen=DEFAULT_LCD_SCREEN_NAME,\n        lcdproc_charset=DEFAULT_LCDPROC_CHARSET,\n        lcdd_debug=False,\n        pattern='', patterns=[],\n        refresh=DEFAULT_REFRESH,\n        backlight_on=DEFAULT_BACKLIGHT_ON,\n        priority_playing=DEFAULT_PRIORITY,\n        priority_not_playing=DEFAULT_PRIORITY,\n        retry_attempts=DEFAULT_RETRY_ATTEMPTS,\n        retry_wait=DEFAULT_RETRY_WAIT,\n        retry_backoff=DEFAULT_RETRY_BACKOFF):\n    \"\"\"Run the server.\n\n    Args:\n        lcdproc (str): the target connection (host:port) for lcdproc\n        mpd (str): the target connection ([pwd@]host:port) for mpd\n        lcdproc_screen (str): the name of the screen to use for lcdproc\n        lcdproc_charset (str): the charset to use with lcdproc\n        lcdd_debug (bool): whether to enable full LCDd debug\n        pattern (str): the pattern to use\n        patterns (str list): the patterns to use\n        refresh (float): how often to refresh the display\n        backlight_on (str): the rules for activating backlight\n        retry_attempts (int): number of connection attempts\n        retry_wait (int): time between connection attempts\n        retry_backoff (int): increase to between-attempts delay\n    \"\"\"\n    # Compute host/ports\n    lcd_conn = _make_hostport(lcdproc, 'localhost', 13666)\n    mpd_conn = _make_hostport(mpd, 'localhost', 6600)\n\n    # Prepare auto-retry\n    retry_config = utils.AutoRetryConfig(\n        retry_attempts=retry_attempts,\n        retry_backoff=retry_backoff,\n        retry_wait=retry_wait)\n\n    # Setup MPD client\n    mpd_client = mpdwrapper.MPDClient(\n        host=mpd_conn.hostname,\n        port=mpd_conn.port,\n        password=mpd_conn.username,\n        retry_config=retry_config,\n    )\n\n    # Setup LCDd client\n    lcd = _make_lcdproc(\n        lcd_conn.hostname, lcd_conn.port,\n        lcdd_debug=lcdd_debug,\n        charset=lcdproc_charset,\n        retry_config=retry_config,\n    )\n\n    # Setup connector\n    runner = lcdrunner.MpdRunner(\n        mpd_client, lcd,\n        lcdproc_screen=lcdproc_screen,\n        refresh_rate=refresh,\n        retry_config=retry_config,\n        backlight_on=backlight_on,\n        priority_playing=priority_playing,\n        priority_not_playing=priority_not_playing,\n    )\n\n    # Fill pattern\n    if pattern:\n        # If a specific pattern was given, use it\n        patterns = [pattern]\n    elif not patterns:\n        # If no patterns were given, use the defaults\n        patterns = DEFAULT_PATTERNS\n    pattern_list = _make_patterns(patterns)\n\n    mpd_hook_registry = mpdhooks.HookRegistry()\n    runner.setup_pattern(pattern_list, hook_registry=mpd_hook_registry)\n\n    # Launch\n    mpd_client.connect()\n    runner.run()\n\n    # Exit\n    logging.shutdown()", "response": "Run the server forever."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _read_config(filename):\n    parser = configparser.RawConfigParser()\n    if filename and not parser.read(filename):\n        sys.stderr.write(\"Unable to open configuration file %s. Use --config='' to disable this warning.\\n\" % filename)\n\n    config = {}\n\n    for section, defaults in BASE_CONFIG.items():\n        # Patterns are handled separately\n        if section == 'patterns':\n            continue\n\n        for name, descr in defaults.items():\n            kind, default = descr\n            if section in parser.sections() and name in parser.options(section):\n                if kind == 'int':\n                    value = parser.getint(section, name)\n                elif kind == 'float':\n                    value = parser.getfloat(section, name)\n                elif kind == 'bool':\n                    value = parser.getboolean(section, name)\n                else:\n                    value = parser.get(section, name)\n            else:\n                value = default\n            config[name] = value\n\n    if 'patterns' in parser.sections():\n        patterns = [parser.get('patterns', opt) for opt in parser.options('patterns')]\n    else:\n        patterns = DEFAULT_PATTERNS\n    config['patterns'] = patterns\n\n    return config", "response": "Read the configuration from the given file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _extract_options(config, options, *args):\n    extract = {}\n    for key in args:\n        if key not in args:\n            continue\n        extract[key] = config[key]\n        option = getattr(options, key, None)\n        if option is not None:\n            extract[key] = option\n    return extract", "response": "Extract options values from a configparser optparse pair."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsets the render - buffer size and format for the specified texture class.", "response": "def resize(self, shape, format=None):\n        \"\"\" Set the render-buffer size and format\n\n        Parameters\n        ----------\n        shape : tuple of integers\n            New shape in yx order. A render buffer is always 2D. For\n            symmetry with the texture class, a 3-element tuple can also\n            be given, in which case the last dimension is ignored.\n        format : {None, 'color', 'depth', 'stencil'}\n            The buffer format. If None, the current format is maintained. \n            If that is also None, the format will be set upon attaching\n            it to a framebuffer. One can also specify the explicit enum:\n            GL_RGB565, GL_RGBA4, GL_RGB5_A1, GL_DEPTH_COMPONENT16, or\n            GL_STENCIL_INDEX8\n        \"\"\"\n        \n        if not self._resizeable:\n            raise RuntimeError(\"RenderBuffer is not resizeable\")\n        # Check shape\n        if not (isinstance(shape, tuple) and len(shape) in (2, 3)):\n            raise ValueError('RenderBuffer shape must be a 2/3 element tuple')\n        # Check format\n        if format is None:\n            format = self._format  # Use current format (may be None)\n        elif isinstance(format, int):\n            pass  # Do not check, maybe user needs desktop GL formats\n        elif isinstance(format, string_types):\n            if format not in ('color', 'depth', 'stencil'):\n                raise ValueError('RenderBuffer format must be \"color\", \"depth\"'\n                                 ' or \"stencil\", not %r' % format)\n        else:\n            raise ValueError('Invalid RenderBuffer format: %r' % format)\n        \n        # Store and send GLIR command\n        self._shape = tuple(shape[:2])\n        self._format = format\n        if self._format is not None:\n            self._glir.command('SIZE', self._id, self._shape, self._format)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef activate(self):\n        # Send command\n        self._glir.command('FRAMEBUFFER', self._id, True)\n        # Associate canvas now\n        canvas = get_current_canvas()\n        if canvas is not None:\n            canvas.context.glir.associate(self.glir)", "response": "Activate this frame buffer."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef shape(self):\n        if self.color_buffer is not None:\n            return self.color_buffer.shape[:2]  # in case its a texture\n        if self.depth_buffer is not None:\n            return self.depth_buffer.shape[:2]\n        if self.stencil_buffer is not None:\n            return self.stencil_buffer.shape[:2]\n        raise RuntimeError('FrameBuffer without buffers has undefined shape')", "response": "The shape of the Texture or RenderBuffer attached to this FrameBuffer\n           "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef resize(self, shape):\n        # Check\n        if not (isinstance(shape, tuple) and len(shape) == 2):\n            raise ValueError('RenderBuffer shape must be a 2-element tuple')\n        # Resize our buffers\n        for buf in (self.color_buffer, self.depth_buffer, self.stencil_buffer):\n            if buf is None:\n                continue\n            shape_ = shape\n            if isinstance(buf, Texture2D):\n                shape_ = shape + (self.color_buffer.shape[-1], )\n            buf.resize(shape_, buf.format)", "response": "Resize all currently - attached buffers with the given shape."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreads the contents of the specified buffer.", "response": "def read(self, mode='color', alpha=True):\n        \"\"\" Return array of pixel values in an attached buffer\n        \n        Parameters\n        ----------\n        mode : str\n            The buffer type to read. May be 'color', 'depth', or 'stencil'.\n        alpha : bool\n            If True, returns RGBA array. Otherwise, returns RGB.\n        \n        Returns\n        -------\n        buffer : array\n            3D array of pixels in np.uint8 format. \n            The array shape is (h, w, 3) or (h, w, 4), with the top-left \n            corner of the framebuffer at index [0, 0] in the returned array.\n        \n        \"\"\"\n        _check_valid('mode', mode, ['color', 'depth', 'stencil'])\n        buffer = getattr(self, mode+'_buffer')\n        h, w = buffer.shape[:2]\n        \n        # todo: this is ostensibly required, but not available in gloo.gl\n        #gl.glReadBuffer(buffer._target)\n        \n        return read_pixels((0, 0, w, h), alpha=alpha)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef set_data(self, pos=None, color=None, width=None, connect=None):\n        if pos is not None:\n            self._bounds = None\n            self._pos = pos\n            self._changed['pos'] = True\n\n        if color is not None:\n            self._color = color\n            self._changed['color'] = True\n\n        if width is not None:\n            self._width = width\n            self._changed['width'] = True\n\n        if connect is not None:\n            self._connect = connect\n            self._changed['connect'] = True\n\n        self.update()", "response": "Set the data used to draw this visual."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _compute_bounds(self, axis, view):\n        # Can and should we calculate bounds?\n        if (self._bounds is None) and self._pos is not None:\n            pos = self._pos\n            self._bounds = [(pos[:, d].min(), pos[:, d].max())\n                            for d in range(pos.shape[1])]\n        # Return what we can\n        if self._bounds is None:\n            return\n        else:\n            if axis < len(self._bounds):\n                return self._bounds[axis]\n            else:\n                return (0, 0)", "response": "Compute the bounds of the in - memory area of the in - memory area."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _agg_bake(cls, vertices, color, closed=False):\n\n        n = len(vertices)\n        P = np.array(vertices).reshape(n, 2).astype(float)\n        idx = np.arange(n)  # used to eventually tile the color array\n\n        dx, dy = P[0] - P[-1]\n        d = np.sqrt(dx*dx+dy*dy)\n\n        # If closed, make sure first vertex = last vertex (+/- epsilon=1e-10)\n        if closed and d > 1e-10:\n            P = np.append(P, P[0]).reshape(n+1, 2)\n            idx = np.append(idx, idx[-1])\n            n += 1\n\n        V = np.zeros(len(P), dtype=cls._agg_vtype)\n        V['a_position'] = P\n\n        # Tangents & norms\n        T = P[1:] - P[:-1]\n\n        N = np.sqrt(T[:, 0]**2 + T[:, 1]**2)\n        # T /= N.reshape(len(T),1)\n        V['a_tangents'][+1:, :2] = T\n        V['a_tangents'][0, :2] = T[-1] if closed else T[0]\n        V['a_tangents'][:-1, 2:] = T\n        V['a_tangents'][-1, 2:] = T[0] if closed else T[-1]\n\n        # Angles\n        T1 = V['a_tangents'][:, :2]\n        T2 = V['a_tangents'][:, 2:]\n        A = np.arctan2(T1[:, 0]*T2[:, 1]-T1[:, 1]*T2[:, 0],\n                       T1[:, 0]*T2[:, 0]+T1[:, 1]*T2[:, 1])\n        V['a_angles'][:-1, 0] = A[:-1]\n        V['a_angles'][:-1, 1] = A[+1:]\n\n        # Segment\n        L = np.cumsum(N)\n        V['a_segment'][+1:, 0] = L\n        V['a_segment'][:-1, 1] = L\n        # V['a_lengths'][:,2] = L[-1]\n\n        # Step 1: A -- B -- C  =>  A -- B, B' -- C\n        V = np.repeat(V, 2, axis=0)[1:-1]\n        V['a_segment'][1:] = V['a_segment'][:-1]\n        V['a_angles'][1:] = V['a_angles'][:-1]\n        V['a_texcoord'][0::2] = -1\n        V['a_texcoord'][1::2] = +1\n        idx = np.repeat(idx, 2)[1:-1]\n\n        # Step 2: A -- B, B' -- C  -> A0/A1 -- B0/B1, B'0/B'1 -- C0/C1\n        V = np.repeat(V, 2, axis=0)\n        V['a_texcoord'][0::2, 1] = -1\n        V['a_texcoord'][1::2, 1] = +1\n        idx = np.repeat(idx, 2)\n\n        I = np.resize(np.array([0, 1, 2, 1, 2, 3], dtype=np.uint32),\n                      (n-1)*(2*3))\n        I += np.repeat(4*np.arange(n-1, dtype=np.uint32), 6)\n\n        # Length\n        V['alength'] = L[-1] * np.ones(len(V))\n\n        # Color\n        if color.ndim == 1:\n            color = np.tile(color, (len(V), 1))\n        elif color.ndim == 2 and len(color) == n:\n            color = color[idx]\n        else:\n            raise ValueError('Color length %s does not match number of '\n                             'vertices %s' % (len(color), n))\n        V['color'] = color\n\n        return V, I", "response": "Bake a list of 2D vertices for rendering a thick line."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _get_k_p_a(font, left, right):\n    # http://lists.apple.com/archives/coretext-dev/2010/Dec/msg00020.html\n    # 1) set up a CTTypesetter\n    chars = left + right\n    args = [None, 1, cf.kCFTypeDictionaryKeyCallBacks,\n            cf.kCFTypeDictionaryValueCallBacks]\n    attributes = cf.CFDictionaryCreateMutable(*args)\n    cf.CFDictionaryAddValue(attributes, kCTFontAttributeName, font)\n    string = cf.CFAttributedStringCreate(None, CFSTR(chars), attributes)\n    typesetter = ct.CTTypesetterCreateWithAttributedString(string)\n    cf.CFRelease(string)\n    cf.CFRelease(attributes)\n    # 2) extract a CTLine from it\n    range = CFRange(0, 1)\n    line = ct.CTTypesetterCreateLine(typesetter, range)\n    # 3) use CTLineGetOffsetForStringIndex to get the character positions\n    offset = ct.CTLineGetOffsetForStringIndex(line, 1, None)\n    cf.CFRelease(line)\n    cf.CFRelease(typesetter)\n    return offset", "response": "This actually calculates the kerning + advance"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nupdating the data of the current object.", "response": "def set_data(self, xs=None, ys=None, zs=None, colors=None):\n        '''Update the mesh data.\n\n        Parameters\n        ----------\n        xs : ndarray | None\n            A 2d array of x coordinates for the vertices of the mesh.\n        ys : ndarray | None\n            A 2d array of y coordinates for the vertices of the mesh.\n        zs : ndarray | None\n            A 2d array of z coordinates for the vertices of the mesh.\n        colors : ndarray | None\n            The color at each point of the mesh. Must have shape\n            (width, height, 4) or (width, height, 3) for rgba or rgb\n            color definitions respectively.\n        '''\n\n        if xs is None:\n            xs = self._xs\n            self.__vertices = None\n\n        if ys is None:\n            ys = self._ys\n            self.__vertices = None\n\n        if zs is None:\n            zs = self._zs\n            self.__vertices = None\n\n        if self.__vertices is None:\n            vertices, indices = create_grid_mesh(xs, ys, zs)\n            self._xs = xs\n            self._ys = ys\n            self._zs = zs\n\n        if self.__vertices is None:\n            vertices, indices = create_grid_mesh(self._xs, self._ys, self._zs)\n            self.__meshdata.set_vertices(vertices)\n            self.__meshdata.set_faces(indices)\n\n        if colors is not None:\n            self.__meshdata.set_vertex_colors(colors.reshape(\n                colors.shape[0] * colors.shape[1], colors.shape[2]))\n\n        MeshVisual.set_data(self, meshdata=self.__meshdata)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nconvert numpy array to PNG byte array.", "response": "def _make_png(data, level=6):\n    \"\"\"Convert numpy array to PNG byte array.\n\n    Parameters\n    ----------\n    data : numpy.ndarray\n        Data must be (H, W, 3 | 4) with dtype = np.ubyte (np.uint8)\n    level : int\n        https://docs.python.org/2/library/zlib.html#zlib.compress\n        An integer from 0 to 9 controlling the level of compression:\n\n            * 1 is fastest and produces the least compression,\n            * 9 is slowest and produces the most.\n            * 0 is no compression.\n\n        The default value is 6.\n\n    Returns\n    -------\n    png : array\n        PNG formatted array\n    \"\"\"\n    # Eventually we might want to use ext/png.py for this, but this\n    # routine *should* be faster b/c it's speacialized for our use case\n\n    def mkchunk(data, name):\n        if isinstance(data, np.ndarray):\n            size = data.nbytes\n        else:\n            size = len(data)\n        chunk = np.empty(size + 12, dtype=np.ubyte)\n        chunk.data[0:4] = np.array(size, '>u4').tostring()\n        chunk.data[4:8] = name.encode('ASCII')\n        chunk.data[8:8 + size] = data\n        # and-ing may not be necessary, but is done for safety:\n        # https://docs.python.org/3/library/zlib.html#zlib.crc32\n        chunk.data[-4:] = np.array(zlib.crc32(chunk[4:-4]) & 0xffffffff,\n                                   '>u4').tostring()\n        return chunk\n\n    if data.dtype != np.ubyte:\n        raise TypeError('data.dtype must be np.ubyte (np.uint8)')\n\n    dim = data.shape[2]  # Dimension\n    if dim not in (3, 4):\n        raise TypeError('data.shape[2] must be in (3, 4)')\n\n    # www.libpng.org/pub/png/spec/1.2/PNG-Chunks.html#C.IHDR\n    if dim == 4:\n        ctyp = 0b0110  # RGBA\n    else:\n        ctyp = 0b0010  # RGB\n\n    # www.libpng.org/pub/png/spec/1.2/PNG-Structure.html\n    header = b'\\x89PNG\\x0d\\x0a\\x1a\\x0a'  # header\n\n    h, w = data.shape[:2]\n    depth = data.itemsize * 8\n    ihdr = struct.pack('!IIBBBBB', w, h, depth, ctyp, 0, 0, 0)\n    c1 = mkchunk(ihdr, 'IHDR')\n\n    # www.libpng.org/pub/png/spec/1.2/PNG-Chunks.html#C.IDAT\n    # insert filter byte at each scanline\n    idat = np.empty((h, w * dim + 1), dtype=np.ubyte)\n    idat[:, 1:] = data.reshape(h, w * dim)\n    idat[:, 0] = 0\n\n    comp_data = zlib.compress(idat, level)\n    c2 = mkchunk(comp_data, 'IDAT')\n    c3 = mkchunk(np.empty((0,), dtype=np.ubyte), 'IEND')\n\n    # concatenate\n    lh = len(header)\n    png = np.empty(lh + c1.nbytes + c2.nbytes + c3.nbytes, dtype=np.ubyte)\n    png.data[:lh] = header\n    p = lh\n\n    for chunk in (c1, c2, c3):\n        png[p:p + len(chunk)] = chunk\n        p += chunk.nbytes\n\n    return png"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef read_png(filename):\n    x = Reader(filename)\n    try:\n        alpha = x.asDirect()[3]['alpha']\n        if alpha:\n            y = x.asRGBA8()[2]\n            n = 4\n        else:\n            y = x.asRGB8()[2]\n            n = 3\n        y = np.array([yy for yy in y], np.uint8)\n    finally:\n        x.file.close()\n    y.shape = (y.shape[0], y.shape[1] // n, n)\n    return y", "response": "Read a PNG file to RGB8 or RGBA8."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef write_png(filename, data):\n    data = np.asarray(data)\n    if not data.ndim == 3 and data.shape[-1] in (3, 4):\n        raise ValueError('data must be a 3D array with last dimension 3 or 4')\n    with open(filename, 'wb') as f:\n        f.write(_make_png(data))", "response": "Write a PNG file containing the image data."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef imread(filename, format=None):\n    imageio, PIL = _check_img_lib()\n    if imageio is not None:\n        return imageio.imread(filename, format)\n    elif PIL is not None:\n        im = PIL.Image.open(filename)\n        if im.mode == 'P':\n            im = im.convert()\n        # Make numpy array\n        a = np.asarray(im)\n        if len(a.shape) == 0:\n            raise MemoryError(\"Too little memory to convert PIL image to \"\n                              \"array\")\n        return a\n    else:\n        raise RuntimeError(\"imread requires the imageio or PIL package.\")", "response": "Read image data from disk and return as array."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nsave image data to disk.", "response": "def imsave(filename, im, format=None):\n    \"\"\"Save image data to disk\n\n    Requires imageio or PIL.\n\n    Parameters\n    ----------\n    filename : str\n        Filename to write.\n    im : array\n        Image data.\n    format : str | None\n        Format of the file. If None, it will be inferred from the filename.\n\n    See also\n    --------\n    imread, read_png, write_png\n    \"\"\"\n    # Import imageio or PIL\n    imageio, PIL = _check_img_lib()\n    if imageio is not None:\n        return imageio.imsave(filename, im, format)\n    elif PIL is not None:\n        pim = PIL.Image.fromarray(im)\n        pim.save(filename, format)\n    else:\n        raise RuntimeError(\"imsave requires the imageio or PIL package.\")"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _check_img_lib():\n    # Import imageio or PIL\n    imageio = PIL = None\n    try:\n        import imageio\n    except ImportError:\n        try:\n            import PIL.Image\n        except ImportError:\n            pass\n    return imageio, PIL", "response": "Utility to search for imageio or PIL"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef read_from_user(input_type, *args, **kwargs):\n    '''\n    Helper function to prompt user for input of a specific type \n    e.g. float, str, int \n    Designed to work with both python 2 and 3 \n    Yes I know this is ugly.\n    '''\n\n    def _read_in(*args, **kwargs):\n        while True:\n            try: tmp =  raw_input(*args, **kwargs)\n            except NameError: tmp =  input(*args, **kwargs)\n            try: return input_type(tmp)\n            except: print ('Expected type', input_type)\n\n    return _read_in(*args, **kwargs)", "response": "Helper function to read from user for a specific type \n e. g. float str int64 int64"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nfunction decorator displaying the function execution time All kwargs are the arguments taken by the Timer class constructor.", "response": "def timer(logger=None, level=logging.INFO,\n          fmt=\"function %(function_name)s execution time: %(execution_time).3f\",\n          *func_or_func_args, **timer_kwargs):\n    \"\"\" Function decorator displaying the function execution time\n\n    All kwargs are the arguments taken by the Timer class constructor.\n\n    \"\"\"\n    # store Timer kwargs in local variable so the namespace isn't polluted\n    # by different level args and kwargs\n\n    def wrapped_f(f):\n        @functools.wraps(f)\n        def wrapped(*args, **kwargs):\n            with Timer(**timer_kwargs) as t:\n                out = f(*args, **kwargs)\n            context = {\n                'function_name': f.__name__,\n                'execution_time': t.elapsed,\n            }\n            if logger:\n                logger.log(\n                    level,\n                    fmt % context,\n                    extra=context)\n            else:\n                print(fmt % context)\n            return out\n        return wrapped\n    if (len(func_or_func_args) == 1\n            and isinstance(func_or_func_args[0], collections.Callable)):\n        return wrapped_f(func_or_func_args[0])\n    else:\n        return wrapped_f"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nappending a new set of vertices to the collection.", "response": "def append(self, points, indices, **kwargs):\n        \"\"\"\n        Append a new set of vertices to the collection.\n\n        For kwargs argument, n is the number of vertices (local) or the number\n        of item (shared)\n\n        Parameters\n        ----------\n\n        points : np.array\n            Vertices composing the triangles\n\n        indices : np.array\n            Indices describing triangles\n\n        color : list, array or 4-tuple\n           Path color\n        \"\"\"\n\n        itemsize = len(points)\n        itemcount = 1\n\n        V = np.empty(itemcount * itemsize, dtype=self.vtype)\n        for name in self.vtype.names:\n            if name not in ['collection_index', 'position']:\n                V[name] = kwargs.get(name, self._defaults[name])\n        V[\"position\"] = points\n\n        # Uniforms\n        if self.utype:\n            U = np.zeros(itemcount, dtype=self.utype)\n            for name in self.utype.names:\n                if name not in [\"__unused__\"]:\n                    U[name] = kwargs.get(name, self._defaults[name])\n        else:\n            U = None\n\n        I = np.array(indices).ravel()\n\n        Collection.append(self, vertices=V, uniforms=U, indices=I,\n                          itemsize=itemsize)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _mpl_to_vispy(fig):\n    renderer = VispyRenderer()\n    exporter = Exporter(renderer)\n    with warnings.catch_warnings(record=True):  # py3k mpl warning\n        exporter.run(fig)\n    renderer._vispy_done()\n    return renderer.canvas", "response": "Convert a matplotlib figure to vispy"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nshows the current figures using vispy", "response": "def show(block=False):\n    \"\"\"Show current figures using vispy\n\n    Parameters\n    ----------\n    block : bool\n        If True, blocking mode will be used. If False, then non-blocking\n        / interactive mode will be used.\n\n    Returns\n    -------\n    canvases : list\n        List of the vispy canvases that were created.\n    \"\"\"\n    if not has_matplotlib():\n        raise ImportError('Requires matplotlib version >= 1.2')\n    cs = [_mpl_to_vispy(plt.figure(ii)) for ii in plt.get_fignums()]\n    if block and len(cs) > 0:\n        cs[0].app.run()\n    return cs"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef random(adjacency_mat, directed=False, random_state=None):\n    if random_state is None:\n        random_state = np.random\n    elif not isinstance(random_state, np.random.RandomState):\n        random_state = np.random.RandomState(random_state)\n\n    if issparse(adjacency_mat):\n        adjacency_mat = adjacency_mat.tocoo()\n\n    # Randomly place nodes, visual coordinate system is between 0 and 1\n    num_nodes = adjacency_mat.shape[0]\n    node_coords = random_state.rand(num_nodes, 2)\n\n    line_vertices, arrows = _straight_line_vertices(adjacency_mat,\n                                                    node_coords, directed)\n\n    yield node_coords, line_vertices, arrows", "response": "Generate a random node - line - line - arrows for the given graph adjacency matrix."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngenerating an isocurve from 2D data.", "response": "def isocurve(data, level, connected=False, extend_to_edge=False):\n    \"\"\"\n    Generate isocurve from 2D data using marching squares algorithm.\n\n    Parameters\n    ----------\n    data : ndarray\n        2D numpy array of scalar values\n    level : float\n        The level at which to generate an isosurface\n    connected : bool\n        If False, return a single long list of point pairs\n        If True, return multiple long lists of connected point \n        locations. (This is slower but better for drawing \n        continuous lines)\n    extend_to_edge : bool\n        If True, extend the curves to reach the exact edges of \n        the data. \n    \"\"\"    \n    # This function is SLOW; plenty of room for optimization here.\n    \n    if extend_to_edge:\n        d2 = np.empty((data.shape[0]+2, data.shape[1]+2), dtype=data.dtype)\n        d2[1:-1, 1:-1] = data\n        d2[0, 1:-1] = data[0]\n        d2[-1, 1:-1] = data[-1]\n        d2[1:-1, 0] = data[:, 0]\n        d2[1:-1, -1] = data[:, -1]\n        d2[0, 0] = d2[0, 1]\n        d2[0, -1] = d2[1, -1]\n        d2[-1, 0] = d2[-1, 1]\n        d2[-1, -1] = d2[-1, -2]\n        data = d2\n    \n    side_table = [\n        [],\n        [0, 1],\n        [1, 2],\n        [0, 2],\n        [0, 3],\n        [1, 3],\n        [0, 1, 2, 3],\n        [2, 3],\n        [2, 3],\n        [0, 1, 2, 3],\n        [1, 3],\n        [0, 3],\n        [0, 2],\n        [1, 2],\n        [0, 1],\n        []\n    ]\n    \n    edge_key = [\n        [(0, 1), (0, 0)],\n        [(0, 0), (1, 0)],\n        [(1, 0), (1, 1)],\n        [(1, 1), (0, 1)]\n    ]\n    \n    level = float(level)\n    lines = []\n    \n    # mark everything below the isosurface level\n    mask = data < level\n    \n    ## make four sub-fields and compute indexes for grid cells\n    index = np.zeros([x-1 for x in data.shape], dtype=np.ubyte)\n    fields = np.empty((2, 2), dtype=object)\n    slices = [slice(0, -1), slice(1, None)]\n    for i in [0, 1]:\n        for j in [0, 1]:\n            fields[i, j] = mask[slices[i], slices[j]]\n            vertIndex = i+2*j\n            index += (fields[i, j] * 2**vertIndex).astype(np.ubyte)\n    \n    # add lines\n    for i in range(index.shape[0]):                 # data x-axis\n        for j in range(index.shape[1]):             # data y-axis     \n            sides = side_table[index[i, j]]\n            for l in range(0, len(sides), 2):     # faces for this grid cell\n                edges = sides[l:l+2]\n                pts = []\n                for m in [0, 1]:      # points in this face\n                    # p1, p2 are points at either side of an edge\n                    p1 = edge_key[edges[m]][0] \n                    p2 = edge_key[edges[m]][1]\n                    # v1 and v2 are the values at p1 and p2\n                    v1 = data[i+p1[0], j+p1[1]] \n                    v2 = data[i+p2[0], j+p2[1]]\n                    f = (level-v1) / (v2-v1)\n                    fi = 1.0 - f\n                    # interpolate between corners\n                    p = (p1[0]*fi + p2[0]*f + i + 0.5, \n                         p1[1]*fi + p2[1]*f + j + 0.5)\n                    if extend_to_edge:\n                        # check bounds\n                        p = (min(data.shape[0]-2, max(0, p[0]-1)),\n                             min(data.shape[1]-2, max(0, p[1]-1)))\n                    if connected:\n                        gridKey = (i + (1 if edges[m] == 2 else 0), \n                                   j + (1 if edges[m] == 3 else 0), \n                                   edges[m] % 2)\n                        # give the actual position and a key identifying the \n                        # grid location (for connecting segments)\n                        pts.append((p, gridKey))\n                    else:\n                        pts.append(p)\n                \n                lines.append(pts)\n\n    if not connected:\n        return lines\n                \n    # turn disjoint list of segments into continuous lines\n\n    points = {}  # maps each point to its connections\n    for a, b in lines:\n        if a[1] not in points:\n            points[a[1]] = []\n        points[a[1]].append([a, b])\n        if b[1] not in points:\n            points[b[1]] = []\n        points[b[1]].append([b, a])\n\n    # rearrange into chains\n    for k in list(points.keys()):\n        try:\n            chains = points[k]\n        except KeyError:  # already used this point elsewhere\n            continue\n        for chain in chains:\n            x = None\n            while True:\n                if x == chain[-1][1]:\n                    break  # nothing left to do on this chain\n                    \n                x = chain[-1][1]\n                if x == k:\n                    # chain has looped; we're done and can ignore the opposite\n                    # chain\n                    break\n                y = chain[-2][1]\n                connects = points[x]\n                for conn in connects[:]:\n                    if conn[1][1] != y:\n                        chain.extend(conn[1:])\n                del points[x]\n            if chain[0][1] == chain[-1][1]:\n                # looped chain; no need to continue the other direction\n                chains.pop()\n                break\n                \n    # extract point locations \n    lines = []\n    for chain in points.values():\n        if len(chain) == 2:\n            # join together ends of chain\n            chain = chain[1][1:][::-1] + chain[0]\n        else:\n            chain = chain[0]\n        lines.append([pt[0] for pt in chain])\n    \n    return lines"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncheck if an enum is valid.", "response": "def check_enum(enum, name=None, valid=None):\n    \"\"\" Get lowercase string representation of enum.\n    \"\"\"\n    name = name or 'enum'\n    # Try to convert\n    res = None\n    if isinstance(enum, int):\n        if hasattr(enum, 'name') and enum.name.startswith('GL_'):\n            res = enum.name[3:].lower()\n    elif isinstance(enum, string_types):\n        res = enum.lower()\n    # Check\n    if res is None:\n        raise ValueError('Could not determine string represenatation for'\n                         'enum %r' % enum)\n    elif valid and res not in valid:\n        raise ValueError('Value of %s must be one of %r, not %r' % \n                         (name, valid, enum))\n    return res"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ndraw a 2D texture to the current viewport.", "response": "def draw_texture(tex):\n    \"\"\"Draw a 2D texture to the current viewport\n\n    Parameters\n    ----------\n    tex : instance of Texture2D\n        The texture to draw.\n    \"\"\"\n    from .program import Program\n    program = Program(vert_draw, frag_draw)\n    program['u_texture'] = tex\n    program['a_position'] = [[-1., -1.], [-1., 1.], [1., -1.], [1., 1.]]\n    program['a_texcoord'] = [[0., 1.], [0., 0.], [1., 1.], [1., 0.]]\n    program.draw('triangle_strip')"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nmatches pattern against the output of func passing the results as floats to func.", "response": "def _get_dpi_from(cmd, pattern, func):\n    \"\"\"Match pattern against the output of func, passing the results as\n    floats to func.  If anything fails, return None.\n    \"\"\"\n    try:\n        out, _ = run_subprocess([cmd])\n    except (OSError, CalledProcessError):\n        pass\n    else:\n        match = re.search(pattern, out)\n        if match:\n            return func(*map(float, match.groups()))"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets the DPI of the current OS entry.", "response": "def get_dpi(raise_error=True):\n    \"\"\"Get screen DPI from the OS\n\n    Parameters\n    ----------\n    raise_error : bool\n        If True, raise an error if DPI could not be determined.\n\n    Returns\n    -------\n    dpi : float\n        Dots per inch of the primary screen.\n    \"\"\"\n    # If we are running without an X server (e.g. OSMesa), use a fixed DPI\n    if 'DISPLAY' not in os.environ:\n        return 96.\n\n    from_xdpyinfo = _get_dpi_from(\n        'xdpyinfo', r'(\\d+)x(\\d+) dots per inch',\n        lambda x_dpi, y_dpi: (x_dpi + y_dpi) / 2)\n    if from_xdpyinfo is not None:\n        return from_xdpyinfo\n\n    from_xrandr = _get_dpi_from(\n        'xrandr', r'(\\d+)x(\\d+).*?(\\d+)mm x (\\d+)mm',\n        lambda x_px, y_px, x_mm, y_mm: 25.4 * (x_px / x_mm + y_px / y_mm) / 2)\n    if from_xrandr is not None:\n        return from_xrandr\n    if raise_error:\n        raise RuntimeError('could not determine DPI')\n    else:\n        logger.warning('could not determine DPI')\n    return 96"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsets the data of the arrows.", "response": "def set_data(self, adjacency_mat=None, **kwargs):\n        \"\"\"Set the data\n\n        Parameters\n        ----------\n        adjacency_mat : ndarray | None\n            The adjacency matrix.\n        **kwargs : dict\n            Keyword arguments to pass to the arrows.\n        \"\"\"\n        if adjacency_mat is not None:\n            if adjacency_mat.shape[0] != adjacency_mat.shape[1]:\n                raise ValueError(\"Adjacency matrix should be square.\")\n\n            self._adjacency_mat = adjacency_mat\n\n        for k in self._arrow_attributes:\n            if k in kwargs:\n                translated = (self._arrow_kw_trans[k] if k in\n                              self._arrow_kw_trans else k)\n\n                setattr(self._edges, translated, kwargs.pop(k))\n\n        arrow_kwargs = {}\n        for k in self._arrow_kwargs:\n            if k in kwargs:\n                translated = (self._arrow_kw_trans[k] if k in\n                              self._arrow_kw_trans else k)\n\n                arrow_kwargs[translated] = kwargs.pop(k)\n\n        node_kwargs = {}\n        for k in self._node_kwargs:\n            if k in kwargs:\n                translated = (self._node_kw_trans[k] if k in\n                              self._node_kw_trans else k)\n\n                node_kwargs[translated] = kwargs.pop(k)\n\n        if len(kwargs) > 0:\n            raise TypeError(\"%s.set_data() got invalid keyword arguments: %S\"\n                            % (self.__class__.__name__, list(kwargs.keys())))\n\n        # The actual data is set in GraphVisual.animate_layout or\n        # GraphVisual.set_final_layout\n        self._arrow_data = arrow_kwargs\n        self._node_data = node_kwargs\n\n        if not self._animate:\n            self.set_final_layout()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef calc_size(rect, orientation):\n        (total_halfx, total_halfy) = rect.center\n        if orientation in [\"bottom\", \"top\"]:\n            (total_major_axis, total_minor_axis) = (total_halfx, total_halfy)\n        else:\n            (total_major_axis, total_minor_axis) = (total_halfy, total_halfx)\n\n        major_axis = total_major_axis * (1.0 -\n                                         ColorBarWidget.major_axis_padding)\n        minor_axis = major_axis * ColorBarWidget.minor_axis_ratio\n\n        # if the minor axis is \"leaking\" from the padding, then clamp\n        minor_axis = np.minimum(minor_axis,\n                                total_minor_axis *\n                                (1.0 - ColorBarWidget.minor_axis_padding))\n\n        return (major_axis, minor_axis)", "response": "Calculate a size of a color bar entry."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef dtype_reduce(dtype, level=0, depth=0):\n    dtype = np.dtype(dtype)\n    fields = dtype.fields\n\n    # No fields\n    if fields is None:\n        if len(dtype.shape):\n            count = reduce(mul, dtype.shape)\n        else:\n            count = 1\n        # size = dtype.itemsize / count\n        if dtype.subdtype:\n            name = str(dtype.subdtype[0])\n        else:\n            name = str(dtype)\n        return ['', count, name]\n    else:\n        items = []\n        name = ''\n        # Get reduced fields\n        for key, value in fields.items():\n            l = dtype_reduce(value[0], level, depth + 1)\n            if type(l[0]) is str:\n                items.append([key, l[1], l[2]])\n            else:\n                items.append(l)\n            name += key + ','\n\n        # Check if we can reduce item list\n        ctype = None\n        count = 0\n        for i, item in enumerate(items):\n            # One item is a list, we cannot reduce\n            if type(item[0]) is not str:\n                return items\n            else:\n                if i == 0:\n                    ctype = item[2]\n                    count += item[1]\n                else:\n                    if item[2] != ctype:\n                        return items\n                    count += item[1]\n        if depth >= level:\n            return [name, count, ctype]\n        else:\n            return items", "response": "Reduces the dtype up to a given level when it is possible"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef fetchcode(utype, prefix=\"\"):\n\n    utype = np.dtype(utype)\n    _utype = dtype_reduce(utype, level=1)\n\n    header = \"\"\"\nuniform   sampler2D uniforms;\nuniform   vec3      uniforms_shape;\nattribute float     collection_index;\n\n\"\"\"\n\n    # Header generation (easy)\n    types = {1: 'float', 2: 'vec2 ', 3: 'vec3 ',\n             4: 'vec4 ', 9: 'mat3 ', 16: 'mat4 '}\n    for name, count, _ in _utype:\n        if name != '__unused__':\n            header += \"varying %s %s%s;\\n\" % (types[count], prefix, name)\n\n    # Body generation (not so easy)\n    body = \"\"\"\\nvoid fetch_uniforms() {\n    float rows   = uniforms_shape.x;\n    float cols   = uniforms_shape.y;\n    float count  = uniforms_shape.z;\n    float index  = collection_index;\n    int index_x  = int(mod(index, (floor(cols/(count/4.0))))) * int(count/4.0);\n    int index_y  = int(floor(index / (floor(cols/(count/4.0)))));\n    float size_x = cols - 1.0;\n    float size_y = rows - 1.0;\n    float ty     = 0.0;\n    if (size_y > 0.0)\n        ty = float(index_y)/size_y;\n    int i = index_x;\n    vec4 _uniform;\\n\"\"\"\n\n    _utype = dict([(name, count) for name, count, _ in _utype])\n    store = 0\n    # Be very careful with utype name order (_utype.keys is wrong)\n    for name in utype.names:\n        if name == '__unused__':\n            continue\n        count, shift = _utype[name], 0\n        size = count\n        while count:\n            if store == 0:\n                body += \"\\n    _uniform = texture2D(uniforms, vec2(float(i++)/size_x,ty));\\n\"  # noqa\n                store = 4\n            if store == 4:\n                a = \"xyzw\"\n            elif store == 3:\n                a = \"yzw\"\n            elif store == 2:\n                a = \"zw\"\n            elif store == 1:\n                a = \"w\"\n            if shift == 0:\n                b = \"xyzw\"\n            elif shift == 1:\n                b = \"yzw\"\n            elif shift == 2:\n                b = \"zw\"\n            elif shift == 3:\n                b = \"w\"\n            i = min(min(len(b), count), len(a))\n            if size > 1:\n                body += \"    %s%s.%s = _uniform.%s;\\n\" % (prefix, name, b[:i], a[:i])  # noqa\n            else:\n                body += \"    %s%s = _uniform.%s;\\n\" % (prefix, name, a[:i])\n            count -= i\n            shift += i\n            store -= i\n\n    body += \"\"\"}\\n\\n\"\"\"\n    return header + body", "response": "Generate the GLSL code needed to retrieve fake uniform values from a\n    texture."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef create_cube():\n    vtype = [('position', np.float32, 3),\n             ('texcoord', np.float32, 2),\n             ('normal', np.float32, 3),\n             ('color',    np.float32, 4)]\n    itype = np.uint32\n\n    # Vertices positions\n    p = np.array([[1, 1, 1], [-1, 1, 1], [-1, -1, 1], [1, -1, 1],\n                  [1, -1, -1], [1, 1, -1], [-1, 1, -1], [-1, -1, -1]])\n\n    # Face Normals\n    n = np.array([[0, 0, 1], [1, 0, 0], [0, 1, 0],\n                  [-1, 0, 1], [0, -1, 0], [0, 0, -1]])\n\n    # Vertice colors\n    c = np.array([[1, 1, 1, 1], [0, 1, 1, 1], [0, 0, 1, 1], [1, 0, 1, 1],\n                  [1, 0, 0, 1], [1, 1, 0, 1], [0, 1, 0, 1], [0, 0, 0, 1]])\n\n    # Texture coords\n    t = np.array([[0, 0], [0, 1], [1, 1], [1, 0]])\n\n    faces_p = [0, 1, 2, 3,\n               0, 3, 4, 5,\n               0, 5, 6, 1,\n               1, 6, 7, 2,\n               7, 4, 3, 2,\n               4, 7, 6, 5]\n    faces_c = [0, 1, 2, 3,\n               0, 3, 4, 5,\n               0, 5, 6, 1,\n               1, 6, 7, 2,\n               7, 4, 3, 2,\n               4, 7, 6, 5]\n    faces_n = [0, 0, 0, 0,\n               1, 1, 1, 1,\n               2, 2, 2, 2,\n               3, 3, 3, 3,\n               4, 4, 4, 4,\n               5, 5, 5, 5]\n    faces_t = [0, 1, 2, 3,\n               0, 1, 2, 3,\n               0, 1, 2, 3,\n               3, 2, 1, 0,\n               0, 1, 2, 3,\n               0, 1, 2, 3]\n\n    vertices = np.zeros(24, vtype)\n    vertices['position'] = p[faces_p]\n    vertices['normal'] = n[faces_n]\n    vertices['color'] = c[faces_c]\n    vertices['texcoord'] = t[faces_t]\n\n    filled = np.resize(\n        np.array([0, 1, 2, 0, 2, 3], dtype=itype), 6 * (2 * 3))\n    filled += np.repeat(4 * np.arange(6, dtype=itype), 6)\n    filled = filled.reshape((len(filled) // 3, 3))\n\n    outline = np.resize(\n        np.array([0, 1, 1, 2, 2, 3, 3, 0], dtype=itype), 6 * (2 * 4))\n    outline += np.repeat(4 * np.arange(6, dtype=itype), 8)\n\n    return vertices, filled, outline", "response": "Generate a new unfilled and outlined cube."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef create_plane(width=1, height=1, width_segments=1, height_segments=1,\n                 direction='+z'):\n    \"\"\" Generate vertices & indices for a filled and outlined plane.\n\n    Parameters\n    ----------\n    width : float\n        Plane width.\n    height : float\n        Plane height.\n    width_segments : int\n        Plane segments count along the width.\n    height_segments : float\n        Plane segments count along the height.\n    direction: unicode\n        ``{'-x', '+x', '-y', '+y', '-z', '+z'}``\n        Direction the plane will be facing.\n\n    Returns\n    -------\n    vertices : array\n        Array of vertices suitable for use as a VertexBuffer.\n    faces : array\n        Indices to use to produce a filled plane.\n    outline : array\n        Indices to use to produce an outline of the plane.\n\n    References\n    ----------\n    .. [1] Cabello, R. (n.d.). PlaneBufferGeometry.js. Retrieved May 12, 2015,\n        from http://git.io/vU1Fh\n    \"\"\"\n\n    x_grid = width_segments\n    y_grid = height_segments\n\n    x_grid1 = x_grid + 1\n    y_grid1 = y_grid + 1\n\n    # Positions, normals and texcoords.\n    positions = np.zeros(x_grid1 * y_grid1 * 3)\n    normals = np.zeros(x_grid1 * y_grid1 * 3)\n    texcoords = np.zeros(x_grid1 * y_grid1 * 2)\n\n    y = np.arange(y_grid1) * height / y_grid - height / 2\n    x = np.arange(x_grid1) * width / x_grid - width / 2\n\n    positions[::3] = np.tile(x, y_grid1)\n    positions[1::3] = -np.repeat(y, x_grid1)\n\n    normals[2::3] = 1\n\n    texcoords[::2] = np.tile(np.arange(x_grid1) / x_grid, y_grid1)\n    texcoords[1::2] = np.repeat(1 - np.arange(y_grid1) / y_grid, x_grid1)\n\n    # Faces and outline.\n    faces, outline = [], []\n    for i_y in range(y_grid):\n        for i_x in range(x_grid):\n            a = i_x + x_grid1 * i_y\n            b = i_x + x_grid1 * (i_y + 1)\n            c = (i_x + 1) + x_grid1 * (i_y + 1)\n            d = (i_x + 1) + x_grid1 * i_y\n\n            faces.extend(((a, b, d), (b, c, d)))\n            outline.extend(((a, b), (b, c), (c, d), (d, a)))\n\n    positions = np.reshape(positions, (-1, 3))\n    texcoords = np.reshape(texcoords, (-1, 2))\n    normals = np.reshape(normals, (-1, 3))\n\n    faces = np.reshape(faces, (-1, 3)).astype(np.uint32)\n    outline = np.reshape(outline, (-1, 2)).astype(np.uint32)\n\n    direction = direction.lower()\n    if direction in ('-x', '+x'):\n        shift, neutral_axis = 1, 0\n    elif direction in ('-y', '+y'):\n        shift, neutral_axis = -1, 1\n    elif direction in ('-z', '+z'):\n        shift, neutral_axis = 0, 2\n\n    sign = -1 if '-' in direction else 1\n\n    positions = np.roll(positions, shift, -1)\n    normals = np.roll(normals, shift, -1) * sign\n    colors = np.ravel(positions)\n    colors = np.hstack((np.reshape(np.interp(colors,\n                                             (np.min(colors),\n                                              np.max(colors)),\n                                             (0, 1)),\n                                   positions.shape),\n                        np.ones((positions.shape[0], 1))))\n    colors[..., neutral_axis] = 0\n\n    vertices = np.zeros(positions.shape[0],\n                        [('position', np.float32, 3),\n                         ('texcoord', np.float32, 2),\n                         ('normal', np.float32, 3),\n                         ('color', np.float32, 4)])\n\n    vertices['position'] = positions\n    vertices['texcoord'] = texcoords\n    vertices['normal'] = normals\n    vertices['color'] = colors\n\n    return vertices, faces, outline", "response": "Generate a filled and outlined version of a Cabello plane."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef create_box(width=1, height=1, depth=1, width_segments=1, height_segments=1,\n               depth_segments=1, planes=None):\n    \"\"\" Generate vertices & indices for a filled and outlined box.\n\n    Parameters\n    ----------\n    width : float\n        Box width.\n    height : float\n        Box height.\n    depth : float\n        Box depth.\n    width_segments : int\n        Box segments count along the width.\n    height_segments : float\n        Box segments count along the height.\n    depth_segments : float\n        Box segments count along the depth.\n    planes: array_like\n        Any combination of ``{'-x', '+x', '-y', '+y', '-z', '+z'}``\n        Included planes in the box construction.\n\n    Returns\n    -------\n    vertices : array\n        Array of vertices suitable for use as a VertexBuffer.\n    faces : array\n        Indices to use to produce a filled box.\n    outline : array\n        Indices to use to produce an outline of the box.\n    \"\"\"\n\n    planes = (('+x', '-x', '+y', '-y', '+z', '-z')\n              if planes is None else\n              [d.lower() for d in planes])\n\n    w_s, h_s, d_s = width_segments, height_segments, depth_segments\n\n    planes_m = []\n    if '-z' in planes:\n        planes_m.append(create_plane(width, depth, w_s, d_s, '-z'))\n        planes_m[-1][0]['position'][..., 2] -= height / 2\n    if '+z' in planes:\n        planes_m.append(create_plane(width, depth, w_s, d_s, '+z'))\n        planes_m[-1][0]['position'][..., 2] += height / 2\n\n    if '-y' in planes:\n        planes_m.append(create_plane(height, width, h_s, w_s, '-y'))\n        planes_m[-1][0]['position'][..., 1] -= depth / 2\n    if '+y' in planes:\n        planes_m.append(create_plane(height, width, h_s, w_s, '+y'))\n        planes_m[-1][0]['position'][..., 1] += depth / 2\n\n    if '-x' in planes:\n        planes_m.append(create_plane(depth, height, d_s, h_s, '-x'))\n        planes_m[-1][0]['position'][..., 0] -= width / 2\n    if '+x' in planes:\n        planes_m.append(create_plane(depth, height, d_s, h_s, '+x'))\n        planes_m[-1][0]['position'][..., 0] += width / 2\n\n    positions = np.zeros((0, 3), dtype=np.float32)\n    texcoords = np.zeros((0, 2), dtype=np.float32)\n    normals = np.zeros((0, 3), dtype=np.float32)\n\n    faces = np.zeros((0, 3), dtype=np.uint32)\n    outline = np.zeros((0, 2), dtype=np.uint32)\n\n    offset = 0\n    for vertices_p, faces_p, outline_p in planes_m:\n        positions = np.vstack((positions, vertices_p['position']))\n        texcoords = np.vstack((texcoords, vertices_p['texcoord']))\n        normals = np.vstack((normals, vertices_p['normal']))\n\n        faces = np.vstack((faces, faces_p + offset))\n        outline = np.vstack((outline, outline_p + offset))\n        offset += vertices_p['position'].shape[0]\n\n    vertices = np.zeros(positions.shape[0],\n                        [('position', np.float32, 3),\n                         ('texcoord', np.float32, 2),\n                         ('normal', np.float32, 3),\n                         ('color', np.float32, 4)])\n\n    colors = np.ravel(positions)\n    colors = np.hstack((np.reshape(np.interp(colors,\n                                             (np.min(colors),\n                                              np.max(colors)),\n                                             (0, 1)),\n                                   positions.shape),\n                        np.ones((positions.shape[0], 1))))\n\n    vertices['position'] = positions\n    vertices['texcoord'] = texcoords\n    vertices['normal'] = normals\n    vertices['color'] = colors\n\n    return vertices, faces, outline", "response": "Generates a new unfilled and outlined box."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef create_sphere(rows=10, cols=10, depth=10, radius=1.0, offset=True,\n                  subdivisions=3, method='latitude'):\n    \"\"\"Create a sphere\n\n    Parameters\n    ----------\n    rows : int\n        Number of rows (for method='latitude' and 'cube').\n    cols : int\n        Number of columns (for method='latitude' and 'cube').\n    depth : int\n        Number of depth segments (for method='cube').\n    radius : float\n        Sphere radius.\n    offset : bool\n        Rotate each row by half a column (for method='latitude').\n    subdivisions : int\n        Number of subdivisions to perform (for method='ico')\n    method : str\n        Method for generating sphere. Accepts 'latitude' for latitude-\n        longitude, 'ico' for icosahedron, and 'cube' for cube based\n        tessellation.\n\n    Returns\n    -------\n    sphere : MeshData\n        Vertices and faces computed for a spherical surface.\n    \"\"\"\n    if method == 'latitude':\n        return _latitude(rows, cols, radius, offset)\n    elif method == 'ico':\n        return _ico(radius, subdivisions)\n    elif method == 'cube':\n        return _cube(rows, cols, depth, radius)\n    else:\n        raise Exception(\"Invalid method. Accepts: 'latitude', 'ico', 'cube'\")", "response": "Create a spherical sphere."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef create_cylinder(rows, cols, radius=[1.0, 1.0], length=1.0, offset=False):\n    verts = np.empty((rows+1, cols, 3), dtype=np.float32)\n    if isinstance(radius, int):\n        radius = [radius, radius]  # convert to list\n    # compute vertices\n    th = np.linspace(2 * np.pi, 0, cols).reshape(1, cols)\n    # radius as a function of z\n    r = np.linspace(radius[0], radius[1], num=rows+1,\n                    endpoint=True).reshape(rows+1, 1)\n    verts[..., 2] = np.linspace(0, length, num=rows+1,\n                                endpoint=True).reshape(rows+1, 1)  # z\n    if offset:\n        # rotate each row by 1/2 column\n        th = th + ((np.pi / cols) * np.arange(rows+1).reshape(rows+1, 1))\n    verts[..., 0] = r * np.cos(th)  # x = r cos(th)\n    verts[..., 1] = r * np.sin(th)  # y = r sin(th)\n    # just reshape: no redundant vertices...\n    verts = verts.reshape((rows+1)*cols, 3)\n    # compute faces\n    faces = np.empty((rows*cols*2, 3), dtype=np.uint32)\n    rowtemplate1 = (((np.arange(cols).reshape(cols, 1) +\n                      np.array([[0, 1, 0]])) % cols) +\n                    np.array([[0, 0, cols]]))\n    rowtemplate2 = (((np.arange(cols).reshape(cols, 1) +\n                      np.array([[0, 1, 1]])) % cols) +\n                    np.array([[cols, 0, cols]]))\n    for row in range(rows):\n        start = row * cols * 2\n        faces[start:start+cols] = rowtemplate1 + row * cols\n        faces[start+cols:start+(cols*2)] = rowtemplate2 + row * cols\n\n    return MeshData(vertices=verts, faces=faces)", "response": "Create a new cylinder in the current system."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating a new cone in the current surface.", "response": "def create_cone(cols, radius=1.0, length=1.0):\n    \"\"\"Create a cone\n\n    Parameters\n    ----------\n    cols : int\n        Number of faces.\n    radius : float\n        Base cone radius.\n    length : float\n        Length of the cone.\n\n    Returns\n    -------\n    cone : MeshData\n        Vertices and faces computed for a cone surface.\n    \"\"\"\n    verts = np.empty((cols+1, 3), dtype=np.float32)\n    # compute vertexes\n    th = np.linspace(2 * np.pi, 0, cols+1).reshape(1, cols+1)\n    verts[:-1, 2] = 0.0\n    verts[:-1, 0] = radius * np.cos(th[0, :-1])  # x = r cos(th)\n    verts[:-1, 1] = radius * np.sin(th[0, :-1])  # y = r sin(th)\n    # Add the extremity\n    verts[-1, 0] = 0.0\n    verts[-1, 1] = 0.0\n    verts[-1, 2] = length\n    verts = verts.reshape((cols+1), 3)  # just reshape: no redundant vertices\n    # compute faces\n    faces = np.empty((cols, 3), dtype=np.uint32)\n    template = np.array([[0, 1]])\n    for pos in range(cols):\n        faces[pos, :-1] = template + pos\n    faces[:, 2] = cols\n    faces[-1, 1] = 0\n\n    return MeshData(vertices=verts, faces=faces)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate a 3D arrow using a cylinder plus a cone.", "response": "def create_arrow(rows, cols, radius=0.1, length=1.0,\n                 cone_radius=None, cone_length=None):\n    \"\"\"Create a 3D arrow using a cylinder plus cone\n\n    Parameters\n    ----------\n    rows : int\n        Number of rows.\n    cols : int\n        Number of columns.\n    radius : float\n        Base cylinder radius.\n    length : float\n        Length of the arrow.\n    cone_radius : float\n        Radius of the cone base.\n           If None, then this defaults to 2x the cylinder radius.\n    cone_length : float\n        Length of the cone.\n           If None, then this defaults to 1/3 of the arrow length.\n\n    Returns\n    -------\n    arrow : MeshData\n        Vertices and faces computed for a cone surface.\n    \"\"\"\n    # create the cylinder\n    md_cyl = None\n    if cone_radius is None:\n        cone_radius = radius*2.0\n    if cone_length is None:\n        con_L = length/3.0\n        cyl_L = length*2.0/3.0\n    else:\n        cyl_L = max(0, length - cone_length)\n        con_L = min(cone_length, length)\n    if cyl_L != 0:\n        md_cyl = create_cylinder(rows, cols, radius=[radius, radius],\n                                 length=cyl_L)\n    # create the cone\n    md_con = create_cone(cols, radius=cone_radius, length=con_L)\n    verts = md_con.get_vertices()\n    nbr_verts_con = verts.size//3\n    faces = md_con.get_faces()\n    if md_cyl is not None:\n        trans = np.array([[0.0, 0.0, cyl_L]])\n        verts = np.vstack((verts+trans, md_cyl.get_vertices()))\n        faces = np.vstack((faces, md_cyl.get_faces()+nbr_verts_con))\n\n    return MeshData(vertices=verts, faces=faces)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef create_grid_mesh(xs, ys, zs):\n    '''Generate vertices and indices for an implicitly connected mesh.\n\n    The intention is that this makes it simple to generate a mesh\n    from meshgrid data.\n\n    Parameters\n    ----------\n    xs : ndarray\n        A 2d array of x coordinates for the vertices of the mesh. Must\n        have the same dimensions as ys and zs.\n    ys : ndarray\n        A 2d array of y coordinates for the vertices of the mesh. Must\n        have the same dimensions as xs and zs.\n    zs : ndarray\n        A 2d array of z coordinates for the vertices of the mesh. Must\n        have the same dimensions as xs and ys.\n\n    Returns\n    -------\n    vertices : ndarray\n        The array of vertices in the mesh.\n    indices : ndarray\n        The array of indices for the mesh.\n    '''\n\n    shape = xs.shape\n    length = shape[0] * shape[1]\n\n    vertices = np.zeros((length, 3))\n\n    vertices[:, 0] = xs.reshape(length)\n    vertices[:, 1] = ys.reshape(length)\n    vertices[:, 2] = zs.reshape(length)\n\n    basic_indices = np.array([0, 1, 1 + shape[1], 0,\n                              0 + shape[1], 1 + shape[1]],\n                             dtype=np.uint32)\n\n    inner_grid_length = (shape[0] - 1) * (shape[1] - 1)\n\n    offsets = np.arange(inner_grid_length)\n    offsets += np.repeat(np.arange(shape[0] - 1), shape[1] - 1)\n    offsets = np.repeat(offsets, 6)\n    indices = np.resize(basic_indices, len(offsets)) + offsets\n\n    indices = indices.reshape((len(indices) // 3, 3))\n\n    return vertices, indices", "response": "Generate vertices and indices for an implicitly connected mesh."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _straight_line_vertices(adjacency_mat, node_coords, directed=False):\n\n    if not issparse(adjacency_mat):\n        adjacency_mat = np.asarray(adjacency_mat, float)\n\n    if (adjacency_mat.ndim != 2 or adjacency_mat.shape[0] !=\n            adjacency_mat.shape[1]):\n        raise ValueError(\"Adjacency matrix should be square.\")\n\n    arrow_vertices = np.array([])\n\n    edges = _get_edges(adjacency_mat)\n    line_vertices = node_coords[edges.ravel()]\n\n    if directed:\n        arrows = np.array(list(_get_directed_edges(adjacency_mat)))\n        arrow_vertices = node_coords[arrows.ravel()]\n        arrow_vertices = arrow_vertices.reshape((len(arrow_vertices)/2, 4))\n\n    return line_vertices, arrow_vertices", "response": "Generates the vertices for straight lines between nodes."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _rescale_layout(pos, scale=1):\n\n    pos -= pos.min(axis=0)\n    pos *= scale / pos.max()\n\n    return pos", "response": "Rescale the given coordinate list to the range [ 0 scale )."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget unique FT_Library handle", "response": "def get_handle():\n    '''\n    Get unique FT_Library handle\n    '''\n    global __handle__\n    if not __handle__:\n        __handle__ = FT_Library()\n        error = FT_Init_FreeType(byref(__handle__))\n        if error:\n            raise RuntimeError(hex(error))\n    return __handle__"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate a new base camera object of the specified type.", "response": "def make_camera(cam_type, *args, **kwargs):\n    \"\"\" Factory function for creating new cameras using a string name.\n\n    Parameters\n    ----------\n    cam_type : str\n        May be one of:\n\n            * 'panzoom' : Creates :class:`PanZoomCamera`\n            * 'turntable' : Creates :class:`TurntableCamera`\n            * None : Creates :class:`Camera`\n\n    Notes\n    -----\n    All extra arguments are passed to the __init__ method of the selected\n    Camera class.\n    \"\"\"\n    cam_types = {None: BaseCamera}\n    for camType in (BaseCamera, PanZoomCamera, PerspectiveCamera,\n                    TurntableCamera, FlyCamera, ArcballCamera):\n        cam_types[camType.__name__[:-6].lower()] = camType\n\n    try:\n        return cam_types[cam_type](*args, **kwargs)\n    except KeyError:\n        raise KeyError('Unknown camera type \"%s\". Options are: %s' %\n                       (cam_type, cam_types.keys()))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsetting the position of the datapoints in the log file", "response": "def set_data_values(self, label, x, y, z):\n        \"\"\"\n        Set the position of the datapoints\n        \"\"\"\n        # TODO: avoid re-allocating an array every time\n        self.layers[label]['data'] = np.array([x, y, z]).transpose()\n        self._update()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef SegmentCollection(mode=\"agg-fast\", *args, **kwargs):\n\n    if mode == \"raw\":\n        return RawSegmentCollection(*args, **kwargs)\n    return AggSegmentCollection(*args, **kwargs)", "response": "A segment collection function."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef surface(func, umin=0, umax=2 * np.pi, ucount=64, urepeat=1.0,\n            vmin=0, vmax=2 * np.pi, vcount=64, vrepeat=1.0):\n    \"\"\"\n    Computes the parameterization of a parametric surface\n\n    func: function(u,v)\n        Parametric function used to build the surface\n    \"\"\"\n\n    vtype = [('position', np.float32, 3),\n             ('texcoord', np.float32, 2),\n             ('normal',   np.float32, 3)]\n    itype = np.uint32\n\n    # umin, umax, ucount = 0, 2*np.pi, 64\n    # vmin, vmax, vcount = 0, 2*np.pi, 64\n\n    vcount += 1\n    ucount += 1\n    n = vcount * ucount\n\n    Un = np.repeat(np.linspace(0, 1, ucount, endpoint=True), vcount)\n    Vn = np.tile(np.linspace(0, 1, vcount, endpoint=True), ucount)\n    U = umin + Un * (umax - umin)\n    V = vmin + Vn * (vmax - vmin)\n\n    vertices = np.zeros(n, dtype=vtype)\n    for i, (u, v) in enumerate(zip(U, V)):\n        vertices[\"position\"][i] = func(u, v)\n\n    vertices[\"texcoord\"][:, 0] = Un * urepeat\n    vertices[\"texcoord\"][:, 1] = Vn * vrepeat\n\n    indices = []\n    for i in range(ucount - 1):\n        for j in range(vcount - 1):\n            indices.append(i * (vcount) + j)\n            indices.append(i * (vcount) + j + 1)\n            indices.append(i * (vcount) + j + vcount + 1)\n            indices.append(i * (vcount) + j + vcount)\n            indices.append(i * (vcount) + j + vcount + 1)\n            indices.append(i * (vcount) + j)\n    indices = np.array(indices, dtype=itype)\n    vertices[\"normal\"] = normals(vertices[\"position\"],\n                                 indices.reshape(len(indices) / 3, 3))\n\n    return vertices, indices", "response": "Computes the parameterization of a parametric surface\n ArcGIS object."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a point collection of the current page.", "response": "def PointCollection(mode=\"raw\", *args, **kwargs):\n    \"\"\"\n    mode: string\n      - \"raw\"  (speed: fastest, size: small,   output: ugly)\n      - \"agg\"  (speed: fast,    size: small,   output: beautiful)\n    \"\"\"\n\n    if mode == \"raw\":\n        return RawPointCollection(*args, **kwargs)\n    return AggPointCollection(*args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nadd new data to the right side of every line strip and remove as much data from the left.", "response": "def roll_data(self, data):\n        \"\"\"Append new data to the right side of every line strip and remove\n        as much data from the left.\n        \n        Parameters\n        ----------\n        data : array-like\n            A data array to append.\n        \"\"\"\n        data = data.astype('float32')[..., np.newaxis]\n        s1 = self._data_shape[1] - self._offset\n        if data.shape[1] > s1:\n            self._pos_tex[:, self._offset:] = data[:, :s1]\n            self._pos_tex[:, :data.shape[1] - s1] = data[:, s1:]\n            self._offset = (self._offset + data.shape[1]) % self._data_shape[1]\n        else:\n            self._pos_tex[:, self._offset:self._offset+data.shape[1]] = data\n            self._offset += data.shape[1]\n        self.shared_program['offset'] = self._offset\n        self.update()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef set_data(self, index, data):\n        self._pos_tex[index, :] = data\n        self.update()", "response": "Set the complete data for a single line strip."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating a program and add it to this MultiProgram.", "response": "def add_program(self, name=None):\n        \"\"\"Create a program and add it to this MultiProgram.\n        \n        It is the caller's responsibility to keep a reference to the returned \n        program.\n        \n        The *name* must be unique, but is otherwise arbitrary and used for \n        debugging purposes.\n        \"\"\"\n        if name is None:\n            name = 'program' + str(self._next_prog_id)\n            self._next_prog_id += 1\n                \n        if name in self._programs:\n            raise KeyError(\"Program named '%s' already exists.\" % name)\n        \n        # create a program and update it to look like the rest\n        prog = ModularProgram(self._vcode, self._fcode)\n        for key, val in self._set_items.items():\n            prog[key] = val\n        self.frag._new_program(prog)\n        self.vert._new_program(prog)\n        \n        self._programs[name] = prog\n        return prog"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _new_program(self, p):\n        for k, v in self._set_items.items():\n            getattr(p, self._shader)[k] = v", "response": "Update the items in the shader with the new items."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef attach(self, canvas):\n        self._canvas = canvas\n        canvas.events.resize.connect(self.on_resize)\n        canvas.events.mouse_wheel.connect(self.on_mouse_wheel)\n        canvas.events.mouse_move.connect(self.on_mouse_move)", "response": "Attach this tranform to a canvas."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef on_mouse_move(self, event):\n        if event.is_dragging:\n            dxy = event.pos - event.last_event.pos\n            button = event.press_event.button\n\n            if button == 1:\n                dxy = self.canvas_tr.map(dxy)\n                o = self.canvas_tr.map([0, 0])\n                t = dxy - o\n                self.move(t)\n            elif button == 2:\n                center = self.canvas_tr.map(event.press_event.pos)\n                if self._aspect is None:\n                    self.zoom(np.exp(dxy * (0.01, -0.01)), center)\n                else:\n                    s = dxy[1] * -0.01\n                    self.zoom(np.exp(np.array([s, s])), center)\n                    \n            self.shader_map()", "response": "Mouse move handler\n\n        Parameters\n        ----------\n        event : instance of Event\n            The event."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncalculate and returns the tangents normals and binormals for the tube.", "response": "def _frenet_frames(points, closed):\n    '''Calculates and returns the tangents, normals and binormals for\n    the tube.'''\n    tangents = np.zeros((len(points), 3))\n    normals = np.zeros((len(points), 3))\n\n    epsilon = 0.0001\n\n    # Compute tangent vectors for each segment\n    tangents = np.roll(points, -1, axis=0) - np.roll(points, 1, axis=0)\n    if not closed:\n        tangents[0] = points[1] - points[0]\n        tangents[-1] = points[-1] - points[-2]\n    mags = np.sqrt(np.sum(tangents * tangents, axis=1))\n    tangents /= mags[:, np.newaxis]\n\n    # Get initial normal and binormal\n    t = np.abs(tangents[0])\n\n    smallest = np.argmin(t)\n    normal = np.zeros(3)\n    normal[smallest] = 1.\n\n    vec = np.cross(tangents[0], normal)\n\n    normals[0] = np.cross(tangents[0], vec)\n\n    # Compute normal and binormal vectors along the path\n    for i in range(1, len(points)):\n        normals[i] = normals[i-1]\n\n        vec = np.cross(tangents[i-1], tangents[i])\n        if norm(vec) > epsilon:\n            vec /= norm(vec)\n            theta = np.arccos(np.clip(tangents[i-1].dot(tangents[i]), -1, 1))\n            normals[i] = rotate(-np.degrees(theta),\n                                vec)[:3, :3].dot(normals[i])\n\n    if closed:\n        theta = np.arccos(np.clip(normals[0].dot(normals[-1]), -1, 1))\n        theta /= len(points) - 1\n\n        if tangents[0].dot(np.cross(normals[0], normals[-1])) > 0:\n            theta *= -1.\n\n        for i in range(1, len(points)):\n            normals[i] = rotate(-np.degrees(theta*i),\n                                tangents[i])[:3, :3].dot(normals[i])\n\n    binormals = np.cross(tangents, normals)\n\n    return tangents, normals, binormals"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef max_order(self):\n        # TODO: cache value\n        combo = int(0)\n        for iv in self._interval_set._intervals:\n            combo |= iv[0] | iv[1]\n\n        ret = AbstractMOC.HPY_MAX_NORDER - (utils.number_trailing_zeros(combo) // 2)\n        if ret < 0:\n            ret = 0\n\n        return ret", "response": "Returns the maximum number of HEALPix cells in the MOC instance."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the intersection of this MOC and another MOCs.", "response": "def intersection(self, another_moc, *args):\n        \"\"\"\n        Intersection between the MOC instance and other MOCs.\n\n        Parameters\n        ----------\n        another_moc : `~mocpy.moc.MOC`\n            The MOC used for performing the intersection with self.\n        args : `~mocpy.moc.MOC`\n            Other additional MOCs to perform the intersection with.\n\n        Returns\n        -------\n        result : `~mocpy.moc.MOC`/`~mocpy.tmoc.TimeMOC`\n            The resulting MOC.\n        \"\"\"\n        interval_set = self._interval_set.intersection(another_moc._interval_set)\n        for moc in args:\n            interval_set = interval_set.intersection(moc._interval_set)\n\n        return self.__class__(interval_set)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef union(self, another_moc, *args):\n        interval_set = self._interval_set.union(another_moc._interval_set)\n        for moc in args:\n            interval_set = interval_set.union(moc._interval_set)\n\n        return self.__class__(interval_set)", "response": "Union between the MOC instance and another MOCs."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef difference(self, another_moc, *args):\n        interval_set = self._interval_set.difference(another_moc._interval_set)\n        for moc in args:\n            interval_set = interval_set.difference(moc._interval_set)\n\n        return self.__class__(interval_set)", "response": "Difference between this MOC and another MOC."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn all the pixels neighbours of ipix", "response": "def _neighbour_pixels(hp, ipix):\n        \"\"\"\n        Returns all the pixels neighbours of ``ipix``\n        \"\"\"\n        neigh_ipix = np.unique(hp.neighbours(ipix).ravel())\n        # Remove negative pixel values returned by `~astropy_healpix.HEALPix.neighbours`\n        return neigh_ipix[np.where(neigh_ipix >= 0)]"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates a MOC from a numpy array representing the HEALPix cells.", "response": "def from_cells(cls, cells):\n        \"\"\"\n        Creates a MOC from a numpy array representing the HEALPix cells.\n\n        Parameters\n        ----------\n        cells : `numpy.ndarray`\n            Must be a numpy structured array (See https://docs.scipy.org/doc/numpy-1.15.0/user/basics.rec.html).\n            The structure of a cell contains 3 attributes:\n\n            - A `ipix` value being a np.uint64\n            - A `depth` value being a np.uint32\n            - A `fully_covered` flag bit stored in a np.uint8\n\n        Returns\n        -------\n        moc : `~mocpy.moc.MOC`\n            The MOC.\n        \"\"\"\n        shift = (AbstractMOC.HPY_MAX_NORDER - cells[\"depth\"]) << 1\n\n        p1 = cells[\"ipix\"]\n        p2 = cells[\"ipix\"] + 1\n\n        intervals = np.vstack((p1 << shift, p2 << shift)).T\n\n        return cls(IntervalSet(intervals))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef from_json(cls, json_moc):\n        intervals = np.array([])\n        for order, pix_l in json_moc.items():\n            if len(pix_l) == 0:\n                continue\n            pix = np.array(pix_l)\n            p1 = pix\n            p2 = pix + 1\n            shift = 2 * (AbstractMOC.HPY_MAX_NORDER - int(order))\n\n            itv = np.vstack((p1 << shift, p2 << shift)).T\n            if intervals.size == 0:\n                intervals = itv\n            else:\n                intervals = np.vstack((intervals, itv))\n\n        return cls(IntervalSet(intervals))", "response": "Creates a MOC from a dictionary of HEALPix cell arrays indexed by their depth."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _uniq_pixels_iterator(self):\n        intervals_uniq_l = IntervalSet.to_nuniq_interval_set(self._interval_set)._intervals\n        for uniq_iv in intervals_uniq_l:\n            for uniq in range(uniq_iv[0], uniq_iv[1]):\n                yield uniq", "response": "Generator giving the NUNIQ HEALPix pixels of the MOC."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nloads a MOC from a FITS file.", "response": "def from_fits(cls, filename):\n        \"\"\"\n        Loads a MOC from a FITS file.\n\n        The specified FITS file must store the MOC (i.e. the list of HEALPix cells it contains) in a binary HDU table.\n\n        Parameters\n        ----------\n        filename : str\n            The path to the FITS file.\n\n        Returns\n        -------\n        result : `~mocpy.moc.MOC` or `~mocpy.tmoc.TimeMOC`\n            The resulting MOC.\n        \"\"\"\n        table = Table.read(filename)\n\n        intervals = np.vstack((table['UNIQ'], table['UNIQ']+1)).T\n\n        nuniq_interval_set = IntervalSet(intervals)\n        interval_set = IntervalSet.from_nuniq_interval_set(nuniq_interval_set)\n        return cls(interval_set)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncreates a MOC from a string.", "response": "def from_str(cls, value):\n        \"\"\"\n        Create a MOC from a str.\n        \n        This grammar is expressed is the `MOC IVOA <http://ivoa.net/documents/MOC/20190215/WD-MOC-1.1-20190215.pdf>`__\n        specification at section 2.3.2.\n\n        Parameters\n        ----------\n        value : str\n            The MOC as a string following the grammar rules.\n        \n        Returns\n        -------\n        moc : `~mocpy.moc.MOC` or `~mocpy.tmoc.TimeMOC`\n            The resulting MOC\n        \n        Examples\n        --------\n        >>> from mocpy import MOC\n        >>> moc = MOC.from_str(\"2/2-25,28,29 4/0 6/\")\n        \"\"\"\n        # Import lark parser when from_str is called\n        # at least one time\n        from lark import Lark, Transformer\n        class ParsingException(Exception):\n            pass\n\n        class TreeToJson(Transformer):\n            def value(self, items):\n                res = {}\n                for item in items:\n                    if item is not None: # Do not take into account the \"sep\" branches\n                        res.update(item)\n                return res\n\n            def sep(self, items):\n                pass\n\n            def depthpix(self, items):\n                depth = str(items[0])\n                pixs_l = items[1:][0]\n                return {depth: pixs_l}\n\n            def uniq_pix(self, pix):\n                if pix:\n                    return [int(pix[0])]\n\n            def range_pix(self, range_pix):\n                lower_bound = int(range_pix[0])\n                upper_bound = int(range_pix[1])\n                return np.arange(lower_bound, upper_bound + 1, dtype=int)\n\n            def pixs(self, items):\n                ipixs = []\n                for pix in items:\n                    if pix is not None: # Do not take into account the \"sep\" branches\n                        ipixs.extend(pix)\n                return ipixs\n\n        # Initialize the parser when from_str is called\n        # for the first time\n        if AbstractMOC.LARK_PARSER_STR is None:\n            AbstractMOC.LARK_PARSER_STR = Lark(r\"\"\"\n                value: depthpix (sep+ depthpix)*\n                depthpix : INT \"/\" sep* pixs\n                pixs : pix (sep+ pix)*\n                pix : INT? -> uniq_pix\n                    | (INT \"-\" INT) -> range_pix\n                sep : \" \" | \",\" | \"\\n\" | \"\\r\"\n\n                %import common.INT\n                \"\"\", start='value')\n\n        try:\n            tree = AbstractMOC.LARK_PARSER_STR.parse(value)\n        except Exception as err:\n            raise ParsingException(\"Could not parse {0}. \\n Check the grammar section 2.3.2 of http://ivoa.net/documents/MOC/20190215/WD-MOC-1.1-20190215.pdf to see the correct syntax for writing a MOC from a str\".format(value))\n\n        moc_json = TreeToJson().transform(tree)\n\n        return cls.from_json(moc_json)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nserialize a MOC to the JSON format.", "response": "def _to_json(uniq):\n        \"\"\"\n        Serializes a MOC to the JSON format.\n\n        Parameters\n        ----------\n        uniq : `~numpy.ndarray`\n            The array of HEALPix cells representing the MOC to serialize.\n\n        Returns\n        -------\n        result_json : {str : [int]}\n            A dictionary of HEALPix cell lists indexed by their depth.\n        \"\"\"\n        result_json = {}\n\n        depth, ipix = utils.uniq2orderipix(uniq)\n        min_depth = np.min(depth[0])\n        max_depth = np.max(depth[-1])\n\n        for d in range(min_depth, max_depth+1):\n            pix_index = np.where(depth == d)[0]\n            if pix_index.size:\n                # there are pixels belonging to the current order\n                ipix_depth = ipix[pix_index]\n                result_json[str(d)] = ipix_depth.tolist()\n\n        return result_json"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nserialize a MOC to the STRING format.", "response": "def _to_str(uniq):\n        \"\"\"\n        Serializes a MOC to the STRING format.\n\n        HEALPix cells are separated by a comma. The HEALPix cell at order 0 and number 10 is encoded\n        by the string: \"0/10\", the first digit representing the depth and the second the HEALPix cell number\n        for this depth. HEALPix cells next to each other within a specific depth can be expressed as a range and \n        therefore written like that: \"12/10-150\". This encodes the list of HEALPix cells from 10 to 150 at the\n        depth 12.\n\n        Parameters\n        ----------\n        uniq : `~numpy.ndarray`\n            The array of HEALPix cells representing the MOC to serialize.\n\n        Returns\n        -------\n        result : str\n            The serialized MOC.\n        \"\"\"\n        def write_cells(serial, a, b, sep=''):\n            if a == b:\n                serial += '{0}{1}'.format(a, sep)\n            else:\n                serial += '{0}-{1}{2}'.format(a, b, sep)\n            return serial\n\n        res = ''\n\n        if uniq.size == 0: \n            return res\n\n        depth, ipixels = utils.uniq2orderipix(uniq)\n        min_depth = np.min(depth[0])\n        max_depth = np.max(depth[-1])\n\n        for d in range(min_depth, max_depth+1):\n            pix_index = np.where(depth == d)[0]\n\n            if pix_index.size > 0:\n                # Serialize the depth followed by a slash\n                res += '{0}/'.format(d)\n\n                # Retrieve the pixel(s) for this depth\n                ipix_depth = ipixels[pix_index]\n                if ipix_depth.size == 1:\n                    # If there is only one pixel we serialize it and\n                    # go to the next depth\n                    res = write_cells(res, ipix_depth[0], ipix_depth[0])\n                else:\n                    # Sort them in case there are several\n                    ipix_depth = np.sort(ipix_depth)\n\n                    beg_range = ipix_depth[0]\n                    last_range = beg_range\n\n                    # Loop over the sorted pixels by tracking the lower bound of\n                    # the current range and the last pixel.\n                    for ipix in ipix_depth[1:]:\n                        # If the current pixel does not follow the previous one\n                        # then we can end a range and serializes it\n                        if ipix > last_range + 1:\n                            res = write_cells(res, beg_range, last_range, sep=',')\n                            # The current pixel is the beginning of a new range\n                            beg_range = ipix\n\n                        last_range = ipix\n\n                    # Write the last range\n                    res = write_cells(res, beg_range, last_range)\n\n                # Add a ' ' separator before writing serializing the pixels of the next depth\n                res += ' '\n\n        # Remove the last ' ' character\n        res = res[:-1]\n\n        return res"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _to_fits(self, uniq, optional_kw_dict=None):\n        depth = self.max_order\n        if depth <= 13:\n            fits_format = '1J'\n        else:\n            fits_format = '1K'\n\n        tbhdu = fits.BinTableHDU.from_columns(\n            fits.ColDefs([\n                fits.Column(name='UNIQ', format=fits_format, array=uniq)\n            ]))\n        tbhdu.header['PIXTYPE'] = 'HEALPIX'\n        tbhdu.header['ORDERING'] = 'NUNIQ'\n        tbhdu.header.update(self._fits_header_keywords)\n        tbhdu.header['MOCORDER'] = depth\n        tbhdu.header['MOCTOOL'] = 'MOCPy'\n        if optional_kw_dict:\n            for key in optional_kw_dict:\n                tbhdu.header[key] = optional_kw_dict[key]\n\n        thdulist = fits.HDUList([fits.PrimaryHDU(), tbhdu])\n        return thdulist", "response": "Serializes a MOC to the FITS format."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef serialize(self, format='fits', optional_kw_dict=None):\n        formats = ('fits', 'json', 'str')\n        if format not in formats:\n            raise ValueError('format should be one of %s' % (str(formats)))\n\n        uniq_l = []\n        for uniq in self._uniq_pixels_iterator():\n            uniq_l.append(uniq)\n\n        uniq = np.array(uniq_l)\n\n        if format == 'fits':\n            result = self._to_fits(uniq=uniq,\n                                   optional_kw_dict=optional_kw_dict)\n        elif format == 'str':\n            result = self.__class__._to_str(uniq=uniq)\n        else:\n            # json format serialization\n            result = self.__class__._to_json(uniq=uniq)\n\n        return result", "response": "Serializes the MOC into a specific format."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef write(self, path, format='fits', overwrite=False, optional_kw_dict=None):\n        serialization = self.serialize(format=format, optional_kw_dict=optional_kw_dict)\n        if format == 'fits':\n            serialization.writeto(path, overwrite=overwrite)\n        else:\n            import json\n            with open(path, 'w') as h:\n                h.write(json.dumps(serialization, sort_keys=True, indent=2))", "response": "Writes the MOC to a file."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ndegrades the MOC instance to a new less precise MOC instance.", "response": "def degrade_to_order(self, new_order):\n        \"\"\"\n        Degrades the MOC instance to a new, less precise, MOC.\n\n        The maximum depth (i.e. the depth of the smallest HEALPix cells that can be found in the MOC) of the\n        degraded MOC is set to ``new_order``. \n\n        Parameters\n        ----------\n        new_order : int\n            Maximum depth of the output degraded MOC.\n\n        Returns\n        -------\n        moc : `~mocpy.moc.MOC` or `~mocpy.tmoc.TimeMOC`\n            The degraded MOC.\n        \"\"\"\n        shift = 2 * (AbstractMOC.HPY_MAX_NORDER - new_order)\n        ofs = (int(1) << shift) - 1\n        mask = ~ofs\n        adda = int(0)\n        addb = ofs\n\n        iv_set = []\n\n        for iv in self._interval_set._intervals:\n            a = (iv[0] + adda) & mask\n            b = (iv[1] + addb) & mask\n            if b > a:\n                iv_set.append((a, b))\n\n        return self.__class__(IntervalSet(np.asarray(iv_set)))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef set_cursor_x(self, x):\n\n        if x >= 0 and x <= self.server.server_info.get(\"screen_width\"):\n            self.cursor_x = x\n            self.server.request(\"screen_set %s cursor_x %i\" % (self.ref, self.cursor_x))", "response": "Set Screen Cursor X Position"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsets Screen Cursor Y Position", "response": "def set_cursor_y(self, y):\n        \"\"\" Set Screen Cursor Y Position \"\"\"\n\n        if y >= 0 and y <= self.server.server_info.get(\"screen_height\"):\n            self.cursor_y = y\n            self.server.request(\"screen_set %s cursor_y %i\" % (self.ref, self.cursor_y))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef set_duration(self, duration):\n\n        if duration > 0:\n            self.duration = duration\n            self.server.request(\"screen_set %s duration %i\" % (self.ref, (self.duration * 8)))", "response": "Set Screen Change Interval Duration"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef set_timeout(self, timeout):\n\n        if timeout > 0:\n            self.timeout = timeout\n            self.server.request(\"screen_set %s timeout %i\" % (self.ref, (self.timeout * 8)))", "response": "Set Screen Timeout Duration"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset Screen Priority Class", "response": "def set_priority(self, priority):\n        \"\"\" Set Screen Priority Class \"\"\"\n\n        if priority in [\"hidden\", \"background\", \"info\", \"foreground\", \"alert\", \"input\"]:\n            self.priority = priority\n            self.server.request(\"screen_set %s priority %s\" % (self.ref, self.priority))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set_backlight(self, state):\n\n        if state in [\"on\", \"off\", \"toggle\", \"open\", \"blink\", \"flash\"]:\n            self.backlight = state\n            self.server.request(\"screen_set %s backlight %s\" % (self.ref, self.backlight))", "response": "Set Screen Backlight Mode"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsets Screen Heartbeat Display Mode", "response": "def set_heartbeat(self, state):\n        \"\"\" Set Screen Heartbeat Display Mode \"\"\"\n\n        if state in [\"on\", \"off\", \"open\"]:\n            self.heartbeat = state\n            self.server.request(\"screen_set %s heartbeat %s\" % (self.ref, self.heartbeat))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset Screen Cursor Mode", "response": "def set_cursor(self, cursor):\n        \"\"\" Set Screen Cursor Mode \"\"\"\n\n        if cursor in [\"on\", \"off\", \"under\", \"block\"]:\n            self.cursor = cursor\n            self.server.request(\"screen_set %s cursor %s\" % (self.ref, self.cursor))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nclear the current cache entry.", "response": "def clear(self):\n        \"\"\" Clear Screen \"\"\"\n        widgets.StringWidget(self, ref=\"_w1_\", text=\" \" * 20, x=1, y=1)\n        widgets.StringWidget(self, ref=\"_w2_\", text=\" \" * 20, x=1, y=2)\n        widgets.StringWidget(self, ref=\"_w3_\", text=\" \" * 20, x=1, y=3)\n        widgets.StringWidget(self, ref=\"_w4_\", text=\" \" * 20, x=1, y=4)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nadds a String Widget to the Screen.", "response": "def add_string_widget(self, ref, text=\"Text\", x=1, y=1):\n        \"\"\" Add String Widget \"\"\"\n\n        if ref not in self.widgets:\n            widget = widgets.StringWidget(screen=self, ref=ref, text=text, x=x, y=y)\n            self.widgets[ref] = widget\n            return self.widgets[ref]"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nadding a Title Widget to the screen.", "response": "def add_title_widget(self, ref, text=\"Title\"):\n        \"\"\" Add Title Widget \"\"\"\n\n        if ref not in self.widgets:\n            widget = widgets.TitleWidget(screen=self, ref=ref, text=text)\n            self.widgets[ref] = widget\n            return self.widgets[ref]"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nadds Horizontal Bar Widget", "response": "def add_hbar_widget(self, ref, x=1, y=1, length=10):\n        \"\"\" Add Horizontal Bar Widget \"\"\"\n\n        if ref not in self.widgets:\n            widget = widgets.HBarWidget(screen=self, ref=ref, x=x, y=y, length=length)\n            self.widgets[ref] = widget\n            return self.widgets[ref]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding Vertical Bar Widget", "response": "def add_vbar_widget(self, ref, x=1, y=1, length=10):\n        \"\"\" Add Vertical Bar Widget \"\"\"\n\n        if ref not in self.widgets:\n            widget = widgets.VBarWidget(screen=self, ref=ref, x=x, y=y, length=length)\n            self.widgets[ref] = widget\n            return self.widgets[ref]"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nadd a Number Widget to the Screen.", "response": "def add_number_widget(self, ref, x=1, value=1):\n        \"\"\" Add Number Widget \"\"\"\n\n        if ref not in self.widgets:\n            widget = widgets.NumberWidget(screen=self, ref=ref, x=x, value=value)\n            self.widgets[ref] = widget\n            return self.widgets[ref]"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef orbit(self, azim, elev):\n        self.azimuth += azim\n        self.elevation = np.clip(self.elevation + elev, -90, 90)\n        self.view_changed()", "response": "Orbits the camera around the center position."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nupdates rotation parmeters based on mouse movement", "response": "def _update_rotation(self, event):\n        \"\"\"Update rotation parmeters based on mouse movement\"\"\"\n        p1 = event.mouse_event.press_event.pos\n        p2 = event.mouse_event.pos\n        if self._event_value is None:\n            self._event_value = self.azimuth, self.elevation\n        self.azimuth = self._event_value[0] - (p2 - p1)[0] * 0.5\n        self.elevation = self._event_value[1] + (p2 - p1)[1] * 0.5"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _rotate_tr(self):\n        up, forward, right = self._get_dim_vectors()\n        self.transform.rotate(self.elevation, -right)\n        self.transform.rotate(self.azimuth, up)", "response": "Rotate the transformation matrix based on camera parameters"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _dist_to_trans(self, dist):\n        rae = np.array([self.roll, self.azimuth, self.elevation]) * np.pi / 180\n        sro, saz, sel = np.sin(rae)\n        cro, caz, cel = np.cos(rae)\n        dx = (+ dist[0] * (cro * caz + sro * sel * saz)\n              + dist[1] * (sro * caz - cro * sel * saz))\n        dy = (+ dist[0] * (cro * saz - sro * sel * caz)\n              + dist[1] * (sro * saz + cro * sel * caz))\n        dz = (- dist[0] * sro * cel + dist[1] * cro * cel)\n        return dx, dy, dz", "response": "Convert mouse x y movement into x y z translations"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nset the configuration for GLFW", "response": "def _set_config(c):\n    \"\"\"Set gl configuration for GLFW \"\"\"\n    glfw.glfwWindowHint(glfw.GLFW_RED_BITS, c['red_size'])\n    glfw.glfwWindowHint(glfw.GLFW_GREEN_BITS, c['green_size'])\n    glfw.glfwWindowHint(glfw.GLFW_BLUE_BITS, c['blue_size'])\n    glfw.glfwWindowHint(glfw.GLFW_ALPHA_BITS, c['alpha_size'])\n\n    glfw.glfwWindowHint(glfw.GLFW_ACCUM_RED_BITS, 0)\n    glfw.glfwWindowHint(glfw.GLFW_ACCUM_GREEN_BITS, 0)\n    glfw.glfwWindowHint(glfw.GLFW_ACCUM_BLUE_BITS, 0)\n    glfw.glfwWindowHint(glfw.GLFW_ACCUM_ALPHA_BITS, 0)\n\n    glfw.glfwWindowHint(glfw.GLFW_DEPTH_BITS, c['depth_size'])\n    glfw.glfwWindowHint(glfw.GLFW_STENCIL_BITS, c['stencil_size'])\n    # glfw.glfwWindowHint(glfw.GLFW_CONTEXT_VERSION_MAJOR, c['major_version'])\n    # glfw.glfwWindowHint(glfw.GLFW_CONTEXT_VERSION_MINOR, c['minor_version'])\n    # glfw.glfwWindowHint(glfw.GLFW_SRGB_CAPABLE, c['srgb'])\n    glfw.glfwWindowHint(glfw.GLFW_SAMPLES, c['samples'])\n    glfw.glfwWindowHint(glfw.GLFW_STEREO, c['stereo'])\n    if not c['double_buffer']:\n        raise RuntimeError('GLFW must double buffer, consider using a '\n                           'different backend, or using double buffering')"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _process_mod(self, key, down):\n        if key in MOD_KEYS:\n            if down:\n                if key not in self._mod:\n                    self._mod.append(key)\n            elif key in self._mod:\n                self._mod.pop(self._mod.index(key))\n        return self._mod", "response": "Process the mod key."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _patch():\n    import sys\n    from OpenGL import GL\n    if sys.version_info > (3,):\n        buffersubdatafunc = GL.glBufferSubData\n        if hasattr(buffersubdatafunc, 'wrapperFunction'):\n            buffersubdatafunc = buffersubdatafunc.wrapperFunction\n        _m = sys.modules[buffersubdatafunc.__module__]\n        _m.long = int\n    \n    # Fix missing enum\n    try:\n        from OpenGL.GL.VERSION import GL_2_0\n        GL_2_0.GL_OBJECT_SHADER_SOURCE_LENGTH = GL_2_0.GL_SHADER_SOURCE_LENGTH\n    except Exception:\n        pass", "response": "Monkey - patch pyopengl to fix a bug in glBufferSubData."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ntry getting the given function from PyOpenGL and return it as a dummy function.", "response": "def _get_function_from_pyopengl(funcname):\n    \"\"\" Try getting the given function from PyOpenGL, return\n    a dummy function (that shows a warning when called) if it\n    could not be found.\n    \"\"\"\n    func = None\n    \n    # Get function from GL\n    try:\n        func = getattr(_GL, funcname)\n    except AttributeError:\n        # Get function from FBO\n        try:\n            func = getattr(_FBO, funcname)\n        except AttributeError:\n            func = None\n    \n    # Try using \"alias\"\n    if not bool(func):\n        # Some functions are known by a slightly different name\n        # e.g. glDepthRangef, glClearDepthf\n        if funcname.endswith('f'):\n            try:\n                func = getattr(_GL, funcname[:-1])\n            except AttributeError:\n                pass\n\n    # Set dummy function if we could not find it\n    if func is None:\n        func = _make_unavailable_func(funcname)\n        logger.warning('warning: %s not available' % funcname)\n    return func"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ninject functions from OpenGL. GL into _pyopengl namespace.", "response": "def _inject():\n    \"\"\" Copy functions from OpenGL.GL into _pyopengl namespace.\n    \"\"\"\n    NS = _pyopengl2.__dict__\n    for glname, ourname in _pyopengl2._functions_to_import:\n        func = _get_function_from_pyopengl(glname)\n        NS[ourname] = func"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _get_vispy_font_filename(face, bold, italic):\n    name = face + '-'\n    name += 'Regular' if not bold and not italic else ''\n    name += 'Bold' if bold else ''\n    name += 'Italic' if italic else ''\n    name += '.ttf'\n    return load_data_file('fonts/%s' % name)", "response": "Fetch a remote vispy font filename"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _check_color_dim(val):\n    val = np.atleast_2d(val)\n    if val.shape[1] not in (3, 4):\n        raise RuntimeError('Value must have second dimension of size 3 or 4')\n    return val, val.shape[1]", "response": "Ensure val is Nx3 or Nx4."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _hex_to_rgba(hexs):\n    hexs = np.atleast_1d(np.array(hexs, '|U9'))\n    out = np.ones((len(hexs), 4), np.float32)\n    for hi, h in enumerate(hexs):\n        assert isinstance(h, string_types)\n        off = 1 if h[0] == '#' else 0\n        assert len(h) in (6+off, 8+off)\n        e = (len(h)-off) // 2\n        out[hi, :e] = [int(h[i:i+2], 16) / 255.\n                       for i in range(off, len(h), 2)]\n    return out", "response": "Convert hex to rgba"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _rgb_to_hex(rgbs):\n    rgbs, n_dim = _check_color_dim(rgbs)\n    return np.array(['#%02x%02x%02x' % tuple((255*rgb[:3]).astype(np.uint8))\n                     for rgb in rgbs], '|U7')", "response": "Convert rgb to hex triplet"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nconverting Nx3 or Nx4 rgb to hsv", "response": "def _rgb_to_hsv(rgbs):\n    \"\"\"Convert Nx3 or Nx4 rgb to hsv\"\"\"\n    rgbs, n_dim = _check_color_dim(rgbs)\n    hsvs = list()\n    for rgb in rgbs:\n        rgb = rgb[:3]  # don't use alpha here\n        idx = np.argmax(rgb)\n        val = rgb[idx]\n        c = val - np.min(rgb)\n        if c == 0:\n            hue = 0\n            sat = 0\n        else:\n            if idx == 0:  # R == max\n                hue = ((rgb[1] - rgb[2]) / c) % 6\n            elif idx == 1:  # G == max\n                hue = (rgb[2] - rgb[0]) / c + 2\n            else:  # B == max\n                hue = (rgb[0] - rgb[1]) / c + 4\n            hue *= 60\n            sat = c / val\n        hsv = [hue, sat, val]\n        hsvs.append(hsv)\n    hsvs = np.array(hsvs, dtype=np.float32)\n    if n_dim == 4:\n        hsvs = np.concatenate((hsvs, rgbs[:, 3]), axis=1)\n    return hsvs"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nconverting Nx3 or Nx4 hsv to rgb", "response": "def _hsv_to_rgb(hsvs):\n    \"\"\"Convert Nx3 or Nx4 hsv to rgb\"\"\"\n    hsvs, n_dim = _check_color_dim(hsvs)\n    # In principle, we *might* be able to vectorize this, but might as well\n    # wait until a compelling use case appears\n    rgbs = list()\n    for hsv in hsvs:\n        c = hsv[1] * hsv[2]\n        m = hsv[2] - c\n        hp = hsv[0] / 60\n        x = c * (1 - abs(hp % 2 - 1))\n        if 0 <= hp < 1:\n            r, g, b = c, x, 0\n        elif hp < 2:\n            r, g, b = x, c, 0\n        elif hp < 3:\n            r, g, b = 0, c, x\n        elif hp < 4:\n            r, g, b = 0, x, c\n        elif hp < 5:\n            r, g, b = x, 0, c\n        else:\n            r, g, b = c, 0, x\n        rgb = [r + m, g + m, b + m]\n        rgbs.append(rgb)\n    rgbs = np.array(rgbs, dtype=np.float32)\n    if n_dim == 4:\n        rgbs = np.concatenate((rgbs, hsvs[:, 3]), axis=1)\n    return rgbs"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nconverts Nx3 or Nx4 lab to rgb", "response": "def _lab_to_rgb(labs):\n    \"\"\"Convert Nx3 or Nx4 lab to rgb\"\"\"\n    # adapted from BSD-licensed work in MATLAB by Mark Ruzon\n    # Based on ITU-R Recommendation BT.709 using the D65\n    labs, n_dim = _check_color_dim(labs)\n\n    # Convert Lab->XYZ (silly indexing used to preserve dimensionality)\n    y = (labs[:, 0] + 16.) / 116.\n    x = (labs[:, 1] / 500.) + y\n    z = y - (labs[:, 2] / 200.)\n    xyz = np.concatenate(([x], [y], [z]))  # 3xN\n    over = xyz > 0.2068966\n    xyz[over] = xyz[over] ** 3.\n    xyz[~over] = (xyz[~over] - 0.13793103448275862) / 7.787\n\n    # Convert XYZ->LAB\n    rgbs = np.dot(_xyz2rgb_norm, xyz).T\n    over = rgbs > 0.0031308\n    rgbs[over] = 1.055 * (rgbs[over] ** (1. / 2.4)) - 0.055\n    rgbs[~over] *= 12.92\n    if n_dim == 4:\n        rgbs = np.concatenate((rgbs, labs[:, 3]), axis=1)\n    rgbs = np.clip(rgbs, 0., 1.)\n    return rgbs"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get(self, tags):\n        # Try to find our name\n        value = tags.get(self.name, '')\n\n        for name in self.alternate_tags:\n            # Iterate of alternates until a non-empty value is found\n            value = value or tags.get(name, '')\n\n        # If we still have nothing, return our default\n        value = value or self.default\n        return value", "response": "Find an adequate value for this field from a dict of tags."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nparse the function signature in the code.", "response": "def parse_function_signature(code):\n    \"\"\"\n    Return the name, arguments, and return type of the first function\n    definition found in *code*. Arguments are returned as [(type, name), ...].\n    \"\"\"\n    m = re.search(\"^\\s*\" + re_func_decl + \"\\s*{\", code, re.M)\n    if m is None:\n        print(code)\n        raise Exception(\"Failed to parse function signature. \"\n                        \"Full code is printed above.\")\n    rtype, name, args = m.groups()[:3]\n    if args == 'void' or args.strip() == '':\n        args = []\n    else:\n        args = [tuple(arg.strip().split(' ')) for arg in args.split(',')]\n    return name, args, rtype"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef find_functions(code):\n    regex = \"^\\s*\" + re_func_decl + \"\\s*{\"\n    \n    funcs = []\n    while True:\n        m = re.search(regex, code, re.M)\n        if m is None:\n            return funcs\n        \n        rtype, name, args = m.groups()[:3]\n        if args == 'void' or args.strip() == '':\n            args = []\n        else:\n            args = [tuple(arg.strip().split(' ')) for arg in args.split(',')]\n        funcs.append((name, args, rtype))\n        \n        code = code[m.end():]", "response": "Find all function \n    definitions found in code."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef find_prototypes(code):\n\n    prots = []\n    lines = code.split('\\n')\n    for line in lines:\n        m = re.match(\"\\s*\" + re_func_prot, line)\n        if m is not None:\n            rtype, name, args = m.groups()[:3]\n            if args == 'void' or args.strip() == '':\n                args = []\n            else:\n                args = [tuple(arg.strip().split(' '))\n                        for arg in args.split(',')]\n            prots.append((name, args, rtype))\n\n    return prots", "response": "Find all function prototypes in a code."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef find_program_variables(code):\n    vars = {}\n    lines = code.split('\\n')\n    for line in lines:\n        m = re.match(r\"\\s*\" + re_prog_var_declaration + r\"\\s*(=|;)\", line)\n        if m is not None:\n            vtype, dtype, names = m.groups()[:3]\n            for name in names.split(','):\n                vars[name.strip()] = (vtype, dtype)\n    return vars", "response": "Find program variables in the sequence of code lines."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _set_config(c):\n    func = sdl2.SDL_GL_SetAttribute\n    func(sdl2.SDL_GL_RED_SIZE, c['red_size'])\n    func(sdl2.SDL_GL_GREEN_SIZE, c['green_size'])\n    func(sdl2.SDL_GL_BLUE_SIZE, c['blue_size'])\n    func(sdl2.SDL_GL_ALPHA_SIZE, c['alpha_size'])\n    func(sdl2.SDL_GL_DEPTH_SIZE, c['depth_size'])\n    func(sdl2.SDL_GL_STENCIL_SIZE, c['stencil_size'])\n    func(sdl2.SDL_GL_DOUBLEBUFFER, 1 if c['double_buffer'] else 0)\n    samps = c['samples']\n    func(sdl2.SDL_GL_MULTISAMPLEBUFFERS, 1 if samps > 0 else 0)\n    func(sdl2.SDL_GL_MULTISAMPLESAMPLES, samps if samps > 0 else 0)\n    func(sdl2.SDL_GL_STEREO, c['stereo'])", "response": "Set the GL configuration for SDL2"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating a response object from the raw_response.", "response": "def create_response(self, message=None, end_session=False, card_obj=None,\n                        reprompt_message=None, is_ssml=None):\n        \"\"\"\n        message - text message to be spoken out by the Echo\n        end_session - flag to determine whether this interaction should end the session\n        card_obj = JSON card object to substitute the 'card' field in the raw_response\n        \"\"\"\n        response = dict(self.base_response)\n        if message:\n            response['response'] = self.create_speech(message, is_ssml)\n        response['response']['shouldEndSession'] = end_session\n        if card_obj:\n            response['response']['card'] = card_obj\n        if reprompt_message:\n            response['response']['reprompt'] = self.create_speech(reprompt_message, is_ssml)\n        return Response(response)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating a card object for the raw_response", "response": "def create_card(self, title=None, subtitle=None, content=None, card_type=\"Simple\"):\n        \"\"\"\n        card_obj = JSON card object to substitute the 'card' field in the raw_response\n        format:\n        {\n          \"type\": \"Simple\", #COMPULSORY\n          \"title\": \"string\", #OPTIONAL\n          \"subtitle\": \"string\", #OPTIONAL\n          \"content\": \"string\" #OPTIONAL\n        }\n        \"\"\"\n        card = {\"type\": card_type}\n        if title: card[\"title\"] = title\n        if subtitle: card[\"subtitle\"] = subtitle\n        if content: card[\"content\"] = content\n        return card"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef intent(self, intent):\n        ''' Decorator to register intent handler'''\n\n        def _handler(func):\n            self._handlers['IntentRequest'][intent] = func\n            return func\n\n        return _handler", "response": "Decorator to register intent handler"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef request(self, request_type):\n        ''' Decorator to register generic request handler '''\n\n        def _handler(func):\n            self._handlers[request_type] = func\n            return func\n\n        return _handler", "response": "Decorator to register generic request handler"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nrouting the request to the right handler function", "response": "def route_request(self, request_json, metadata=None):\n\n        ''' Route the request object to the right handler function '''\n        request = Request(request_json)\n        request.metadata = metadata\n        # add reprompt handler or some such for default?\n        handler_fn = self._handlers[self._default] # Set default handling for noisy requests\n\n        if not request.is_intent() and (request.request_type() in self._handlers):\n            '''  Route request to a non intent handler '''\n            handler_fn = self._handlers[request.request_type()]\n\n        elif request.is_intent() and request.intent_name() in self._handlers['IntentRequest']:\n            ''' Route to right intent handler '''\n            handler_fn = self._handlers['IntentRequest'][request.intent_name()]\n\n        response = handler_fn(request)\n        response.set_session(request.session)\n        return response.to_json()"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _viewbox_unset(self, viewbox):\n        self._viewbox = None\n        # Disconnect\n        viewbox.events.mouse_press.disconnect(self.viewbox_mouse_event)\n        viewbox.events.mouse_release.disconnect(self.viewbox_mouse_event)\n        viewbox.events.mouse_move.disconnect(self.viewbox_mouse_event)\n        viewbox.events.mouse_wheel.disconnect(self.viewbox_mouse_event)\n        viewbox.events.resize.disconnect(self.viewbox_resize_event)", "response": "Friend method of viewbox to unregister itself."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsetting the range of the camera for the given camera.", "response": "def set_range(self, x=None, y=None, z=None, margin=0.05):\n        \"\"\" Set the range of the view region for the camera\n\n        Parameters\n        ----------\n        x : tuple | None\n            X range.\n        y : tuple | None\n            Y range.\n        z : tuple | None\n            Z range.\n        margin : float\n            Margin to use.\n\n        Notes\n        -----\n        The view is set to the given range or to the scene boundaries\n        if ranges are not specified. The ranges should be 2-element\n        tuples specifying the min and max for each dimension.\n\n        For the PanZoomCamera the view is fully defined by the range.\n        For e.g. the TurntableCamera the elevation and azimuth are not\n        set. One should use reset() for that.\n        \"\"\"\n        # Flag to indicate that this is an initializing (not user-invoked)\n        init = self._xlim is None\n\n        # Collect given bounds\n        bounds = [None, None, None]\n        if x is not None:\n            bounds[0] = float(x[0]), float(x[1])\n        if y is not None:\n            bounds[1] = float(y[0]), float(y[1])\n        if z is not None:\n            bounds[2] = float(z[0]), float(z[1])\n        # If there is no viewbox, store given bounds in lim variables, and stop\n        if self._viewbox is None:\n            self._set_range_args = bounds[0], bounds[1], bounds[2], margin\n            return\n\n        # There is a viewbox, we're going to set the range for real\n        self._resetting = True\n\n        # Get bounds from viewbox if not given\n        if all([(b is None) for b in bounds]):\n            bounds = self._viewbox.get_scene_bounds()\n        else:\n            for i in range(3):\n                if bounds[i] is None:\n                    bounds[i] = self._viewbox.get_scene_bounds(i)\n        \n        # Calculate ranges and margins\n        ranges = [b[1] - b[0] for b in bounds]\n        margins = [(r*margin or 0.1) for r in ranges]\n        # Assign limits for this camera\n        bounds_margins = [(b[0]-m, b[1]+m) for b, m in zip(bounds, margins)]\n        self._xlim, self._ylim, self._zlim = bounds_margins\n        # Store center location\n        if (not init) or (self._center is None):\n            self._center = [(b[0] + r / 2) for b, r in zip(bounds, ranges)]\n\n        # Let specific camera handle it\n        self._set_range(init)\n\n        # Finish\n        self._resetting = False\n        self.view_changed()"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets the current view state of the camera.", "response": "def get_state(self):\n        \"\"\" Get the current view state of the camera\n\n        Returns a dict of key-value pairs. The exact keys depend on the\n        camera. Can be passed to set_state() (of this or another camera\n        of the same type) to reproduce the state.\n        \"\"\"\n        D = {}\n        for key in self._state_props:\n            D[key] = getattr(self, key)\n        return D"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef set_state(self, state=None, **kwargs):\n        D = state or {}\n        D.update(kwargs)\n        for key, val in D.items():\n            if key not in self._state_props:\n                raise KeyError('Not a valid camera state property %r' % key)\n            setattr(self, key, val)", "response": "Set the view state of the camera."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nlinking this camera with another camera.", "response": "def link(self, camera):\n        \"\"\" Link this camera with another camera of the same type\n\n        Linked camera's keep each-others' state in sync.\n\n        Parameters\n        ----------\n        camera : instance of Camera\n            The other camera to link.\n        \"\"\"\n        cam1, cam2 = self, camera\n        # Remove if already linked\n        while cam1 in cam2._linked_cameras:\n            cam2._linked_cameras.remove(cam1)\n        while cam2 in cam1._linked_cameras:\n            cam1._linked_cameras.remove(cam2)\n        # Link both ways\n        cam1._linked_cameras.append(cam2)\n        cam2._linked_cameras.append(cam1)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncalls when the camera is viewed.", "response": "def view_changed(self):\n        \"\"\" Called when this camera is changes its view. Also called\n        when its associated with a viewbox.\n        \"\"\"\n        if self._resetting:\n            return  # don't update anything while resetting (are in set_range)\n        if self._viewbox:\n            # Set range if necessary\n            if self._xlim is None:\n                args = self._set_range_args or ()\n                self.set_range(*args)\n            # Store default state if we have not set it yet\n            if self._default_state is None:\n                self.set_default_state()\n            # Do the actual update\n            self._update_transform()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nhandling canvas change events.", "response": "def on_canvas_change(self, event):\n        \"\"\"Canvas change event handler\n\n        Parameters\n        ----------\n        event : instance of Event\n            The event.\n        \"\"\"\n        # Connect key events from canvas to camera. \n        # TODO: canvas should keep track of a single node with keyboard focus.\n        if event.old is not None:\n            event.old.events.key_press.disconnect(self.viewbox_key_event)\n            event.old.events.key_release.disconnect(self.viewbox_key_event)\n        if event.new is not None:\n            event.new.events.key_press.connect(self.viewbox_key_event)\n            event.new.events.key_release.connect(self.viewbox_key_event)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _set_scene_transform(self, tr):\n        # todo: check whether transform has changed, connect to\n        # transform.changed event\n        pre_tr = self.pre_transform\n        if pre_tr is None:\n            self._scene_transform = tr\n        else:\n            self._transform_cache.roll()\n            self._scene_transform = self._transform_cache.get([pre_tr, tr])\n\n        # Mark the transform dynamic so that it will not be collapsed with\n        # others \n        self._scene_transform.dynamic = True\n        \n        # Update scene\n        self._viewbox.scene.transform = self._scene_transform\n        self._viewbox.update()\n\n        # Apply same state to linked cameras, but prevent that camera\n        # to return the favor\n        for cam in self._linked_cameras:\n            if cam is self._linked_cameras_no_update:\n                continue\n            try:\n                cam._linked_cameras_no_update = self\n                cam.set_state(self.get_state())\n            finally:\n                cam._linked_cameras_no_update = None", "response": "Sets the viewbox scene transform."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _set_config(c):\n    glformat = QGLFormat()\n    glformat.setRedBufferSize(c['red_size'])\n    glformat.setGreenBufferSize(c['green_size'])\n    glformat.setBlueBufferSize(c['blue_size'])\n    glformat.setAlphaBufferSize(c['alpha_size'])\n    if QT5_NEW_API:\n        # Qt5 >= 5.4.0 - below options automatically enabled if nonzero.\n        glformat.setSwapBehavior(glformat.DoubleBuffer if c['double_buffer']\n                                 else glformat.SingleBuffer)\n    else:\n        # Qt4 and Qt5 < 5.4.0 - buffers must be explicitly requested.\n        glformat.setAccum(False)\n        glformat.setRgba(True)\n        glformat.setDoubleBuffer(True if c['double_buffer'] else False)\n        glformat.setDepth(True if c['depth_size'] else False)\n        glformat.setStencil(True if c['stencil_size'] else False)\n        glformat.setSampleBuffers(True if c['samples'] else False)\n    glformat.setDepthBufferSize(c['depth_size'] if c['depth_size'] else 0)\n    glformat.setStencilBufferSize(c['stencil_size'] if c['stencil_size']\n                                  else 0)\n    glformat.setSamples(c['samples'] if c['samples'] else 0)\n    glformat.setStereo(c['stereo'])\n    return glformat", "response": "Set the OpenGL configuration"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the window id of a PySide Widget. Might also work for PyQt4.", "response": "def get_window_id(self):\n        \"\"\" Get the window id of a PySide Widget. Might also work for PyQt4.\n        \"\"\"\n        # Get Qt win id\n        winid = self.winId()\n\n        # On Linux this is it\n        if IS_RPI:\n            nw = (ctypes.c_int * 3)(winid, self.width(), self.height())\n            return ctypes.pointer(nw)\n        elif IS_LINUX:\n            return int(winid)  # Is int on PySide, but sip.voidptr on PyQt\n\n        # Get window id from stupid capsule thingy\n        # http://translate.google.com/translate?hl=en&sl=zh-CN&u=http://www.cnb\n        #logs.com/Shiren-Y/archive/2011/04/06/2007288.html&prev=/search%3Fq%3Dp\n        # yside%2Bdirectx%26client%3Dfirefox-a%26hs%3DIsJ%26rls%3Dorg.mozilla:n\n        #l:official%26channel%3Dfflb%26biw%3D1366%26bih%3D614\n        # Prepare\n        ctypes.pythonapi.PyCapsule_GetName.restype = ctypes.c_char_p\n        ctypes.pythonapi.PyCapsule_GetName.argtypes = [ctypes.py_object]\n        ctypes.pythonapi.PyCapsule_GetPointer.restype = ctypes.c_void_p\n        ctypes.pythonapi.PyCapsule_GetPointer.argtypes = [ctypes.py_object,\n                                                          ctypes.c_char_p]\n        # Extract handle from capsule thingy\n        name = ctypes.pythonapi.PyCapsule_GetName(winid)\n        handle = ctypes.pythonapi.PyCapsule_GetPointer(winid, name)\n        return handle"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef obj(x):\r\n    \r\n    x1 = x[0]\r\n    x2 = x[1]\r\n    \r\n    f = (4 - 2.1*(x1*x1) + (x1*x1*x1*x1)/3.0)*(x1*x1) + x1*x2 + (-4 + 4*(x2*x2))*(x2*x2)\r\n    return f", "response": "A very simple function to make a random number."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef PathCollection(mode=\"agg\", *args, **kwargs):\n\n    if mode == \"raw\":\n        return RawPathCollection(*args, **kwargs)\n    elif mode == \"agg+\":\n        return AggPathCollection(*args, **kwargs)\n    return AggFastPathCollection(*args, **kwargs)", "response": "mode: string\n      - \"raw\"   (speed: fastest, size: small, output: ugly, no dash,\n                 no thickness)\n      - \"agg\"   (speed: medium, size: medium output: nice, some flaws, no dash)\n      - \"agg+\"  (speed: slow, size: big, output: perfect, no dash)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef map(self, coords):\n        m = np.empty(coords.shape)\n        m[:, :3] = (coords[:, :3] * self.scale[np.newaxis, :3] +\n                    coords[:, 3:] * self.translate[np.newaxis, :3])\n        m[:, 3] = coords[:, 3]\n        return m", "response": "Map the coordinates of the\n            to the corresponding logarithmic one."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nchange the translation of this transform by the amount given.", "response": "def move(self, move):\n        \"\"\"Change the translation of this transform by the amount given.\n\n        Parameters\n        ----------\n        move : array-like\n            The values to be added to the current translation of the transform.\n        \"\"\"\n        move = as_vec4(move, default=(0, 0, 0, 0))\n        self.translate = self.translate + move"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nupdating the transform such that its scale factor is changed and translate is left unchanged.", "response": "def zoom(self, zoom, center=(0, 0, 0), mapped=True):\n        \"\"\"Update the transform such that its scale factor is changed, but\n        the specified center point is left unchanged.\n\n        Parameters\n        ----------\n        zoom : array-like\n            Values to multiply the transform's current scale\n            factors.\n        center : array-like\n            The center point around which the scaling will take place.\n        mapped : bool\n            Whether *center* is expressed in mapped coordinates (True) or\n            unmapped coordinates (False).\n        \"\"\"\n        zoom = as_vec4(zoom, default=(1, 1, 1, 1))\n        center = as_vec4(center, default=(0, 0, 0, 0))\n        scale = self.scale * zoom\n        if mapped:\n            trans = center - (center - self.translate) * zoom\n        else:\n            trans = self.scale * (1 - zoom) * center + self.translate\n        self._set_st(scale=scale, translate=trans)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef from_mapping(cls, x0, x1):\n        t = cls()\n        t.set_mapping(x0, x1)\n        return t", "response": "Create an STTransform from the given mapping."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef set_mapping(self, x0, x1, update=True):\n        # if args are Rect, convert to array first\n        if isinstance(x0, Rect):\n            x0 = x0._transform_in()[:3]\n        if isinstance(x1, Rect):\n            x1 = x1._transform_in()[:3]\n        \n        x0 = np.asarray(x0)\n        x1 = np.asarray(x1)\n        if (x0.ndim != 2 or x0.shape[0] != 2 or x1.ndim != 2 or \n                x1.shape[0] != 2):\n            raise TypeError(\"set_mapping requires array inputs of shape \"\n                            \"(2, N).\")\n        denom = x0[1] - x0[0]\n        mask = denom == 0\n        denom[mask] = 1.0\n        s = (x1[1] - x1[0]) / denom\n        s[mask] = 1.0\n        s[x0[1] == x0[0]] = 1.0\n        t = x1[0] - s * x0[0]\n        s = as_vec4(s, default=(1, 1, 1, 1))\n        t = as_vec4(t, default=(0, 0, 0, 0))\n        self._set_st(scale=s, translate=t, update=update)", "response": "Configure this transform such that it maps points x0 to x1."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ntranslate the matrix of the sequence of items in the sequence at the given position.", "response": "def translate(self, pos):\n        \"\"\"\n        Translate the matrix\n\n        The translation is applied *after* the transformations already present\n        in the matrix.\n\n        Parameters\n        ----------\n        pos : arrayndarray\n            Position to translate by.\n        \"\"\"\n        self.matrix = np.dot(self.matrix, transforms.translate(pos[0, :3]))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef scale(self, scale, center=None):\n        scale = transforms.scale(as_vec4(scale, default=(1, 1, 1, 1))[0, :3])\n        if center is not None:\n            center = as_vec4(center)[0, :3]\n            scale = np.dot(np.dot(transforms.translate(-center), scale),\n                           transforms.translate(center))\n        self.matrix = np.dot(self.matrix, scale)", "response": "Scale the matrix about a given origin."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nrotates the matrix by some angle about a given axis.", "response": "def rotate(self, angle, axis):\n        \"\"\"\n        Rotate the matrix by some angle about a given axis.\n\n        The rotation is applied *after* the transformations already present\n        in the matrix.\n\n        Parameters\n        ----------\n        angle : float\n            The angle of rotation, in degrees.\n        axis : array-like\n            The x, y and z coordinates of the axis vector to rotate around.\n        \"\"\"\n        self.matrix = np.dot(self.matrix, transforms.rotate(angle, axis))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset the matrix that maps points1 onto points2.", "response": "def set_mapping(self, points1, points2):\n        \"\"\" Set to a 3D transformation matrix that maps points1 onto points2.\n\n        Parameters\n        ----------\n        points1 : array-like, shape (4, 3)\n            Four starting 3D coordinates.\n        points2 : array-like, shape (4, 3)\n            Four ending 3D coordinates.\n        \"\"\"\n        # note: need to transpose because util.functions uses opposite\n        # of standard linear algebra order.\n        self.matrix = transforms.affine_map(points1, points2).T"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset ortho transform for the current locale.", "response": "def set_ortho(self, l, r, b, t, n, f):\n        \"\"\"Set ortho transform\n\n        Parameters\n        ----------\n        l : float\n            Left.\n        r : float\n            Right.\n        b : float\n            Bottom.\n        t : float\n            Top.\n        n : float\n            Near.\n        f : float\n            Far.\n        \"\"\"\n        self.matrix = transforms.ortho(l, r, b, t, n, f)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef set_perspective(self, fov, aspect, near, far):\n        self.matrix = transforms.perspective(fov, aspect, near, far)", "response": "Set the perspective of the object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef set_frustum(self, l, r, b, t, n, f):\n        self.matrix = transforms.frustum(l, r, b, t, n, f)", "response": "Set the frustum of the current object."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncomputing the log2 of a 32 bit integer using a look up table.", "response": "def log2_lut(v):\n    \"\"\"\n    See `this algo <https://graphics.stanford.edu/~seander/bithacks.html#IntegerLogLookup>`__ for\n    computing the log2 of a 32 bit integer using a look up table\n\n    Parameters\n    ----------\n    v : int\n        32 bit integer\n\n    Returns\n    -------\n\n    \"\"\"\n    res = np.zeros(v.shape, dtype=np.int32)\n\n    tt = v >> 16\n    tt_zero = (tt == 0)\n    tt_not_zero = ~tt_zero\n\n    t_h = tt >> 8\n    t_zero_h = (t_h == 0) & tt_not_zero\n    t_not_zero_h = ~t_zero_h & tt_not_zero\n\n    res[t_zero_h] = LogTable256[tt[t_zero_h]] + 16\n    res[t_not_zero_h] = LogTable256[t_h[t_not_zero_h]] + 24\n\n    t_l = v >> 8\n    t_zero_l = (t_l == 0) & tt_zero\n    t_not_zero_l = ~t_zero_l & tt_zero\n\n    res[t_zero_l] = LogTable256[v[t_zero_l]]\n    res[t_not_zero_l] = LogTable256[t_l[t_not_zero_l]] + 8\n\n    return res"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef uniq2orderipix(uniq):\n    order = ((np.log2(uniq//4)) // 2)\n    order = order.astype(int)\n    ipix = uniq - 4 * (4**order)\n\n    return order, ipix", "response": "convert a HEALPix pixel coded as a NUNIQ number\n    to a ( norder ipix ) tuple"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset the data for the current object.", "response": "def set_data(self, data=None, **kwargs):\n        \"\"\"Set the line data\n\n        Parameters\n        ----------\n        data : array-like\n            The data.\n        **kwargs : dict\n            Keywoard arguments to pass to MarkerVisual and LineVisal.\n        \"\"\"\n        if data is None:\n            pos = None\n        else:\n            if isinstance(data, tuple):\n                pos = np.array(data).T.astype(np.float32)\n            else:\n                pos = np.atleast_1d(data).astype(np.float32)\n\n            if pos.ndim == 1:\n                pos = pos[:, np.newaxis]\n            elif pos.ndim > 2:\n                raise ValueError('data must have at most two dimensions')\n\n            if pos.size == 0:\n                pos = self._line.pos\n\n                # if both args and keywords are zero, then there is no\n                # point in calling this function.\n                if len(kwargs) == 0:\n                    raise TypeError(\"neither line points nor line properties\"\n                                    \"are provided\")\n            elif pos.shape[1] == 1:\n                x = np.arange(pos.shape[0], dtype=np.float32)[:, np.newaxis]\n                pos = np.concatenate((x, pos), axis=1)\n            # if args are empty, don't modify position\n            elif pos.shape[1] > 3:\n                raise TypeError(\"Too many coordinates given (%s; max is 3).\"\n                                % pos.shape[1])\n\n        # todo: have both sub-visuals share the same buffers.\n        line_kwargs = {}\n        for k in self._line_kwargs:\n            if k in kwargs:\n                k_ = self._kw_trans[k] if k in self._kw_trans else k\n                line_kwargs[k] = kwargs.pop(k_)\n        if pos is not None or len(line_kwargs) > 0:\n            self._line.set_data(pos=pos, **line_kwargs)\n\n        marker_kwargs = {}\n        for k in self._marker_kwargs:\n            if k in kwargs:\n                k_ = self._kw_trans[k] if k in self._kw_trans else k\n                marker_kwargs[k_] = kwargs.pop(k)\n        if pos is not None or len(marker_kwargs) > 0:\n            self._markers.set_data(pos=pos, **marker_kwargs)\n        if len(kwargs) > 0:\n            raise TypeError(\"Invalid keyword arguments: %s\" % kwargs.keys())"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsets the data of the current object.", "response": "def set_data(self, pos=None, color=None):\n        \"\"\"Set the data\n\n        Parameters\n        ----------\n        pos : float\n            Position of the line along the axis.\n        color : list, tuple, or array\n            The color to use when drawing the line. If an array is given, it\n            must be of shape (1, 4) and provide one rgba color per vertex.\n        \"\"\"\n        if pos is not None:\n            pos = float(pos)\n            xy = self._pos\n            if self._is_vertical:\n                xy[0, 0] = pos\n                xy[0, 1] = -1\n                xy[1, 0] = pos\n                xy[1, 1] = 1\n            else:\n                xy[0, 0] = -1\n                xy[0, 1] = pos\n                xy[1, 0] = 1\n                xy[1, 1] = pos\n            self._changed['pos'] = True\n\n        if color is not None:\n            color = np.array(color, dtype=np.float32)\n            if color.ndim != 1 or color.shape[0] != 4:\n                raise ValueError('color must be a 4 element float rgba tuple,'\n                                 ' list or array')\n            self._color = color\n            self._changed['color'] = True"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncompute the bounding values of this visual along the given axis.", "response": "def _compute_bounds(self, axis, view):\n        \"\"\"Return the (min, max) bounding values of this visual along *axis*\n        in the local coordinate system.\n        \"\"\"\n        is_vertical = self._is_vertical\n        pos = self._pos\n        if axis == 0 and is_vertical:\n            return (pos[0, 0], pos[0, 0])\n        elif axis == 1 and not is_vertical:\n            return (self._pos[0, 1], self._pos[0, 1])\n\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef curve3_bezier(p1, p2, p3):\n    x1, y1 = p1\n    x2, y2 = p2\n    x3, y3 = p3\n    points = []\n    _curve3_recursive_bezier(points, x1, y1, x2, y2, x3, y3)\n\n    dx, dy = points[0][0] - x1, points[0][1] - y1\n    if (dx * dx + dy * dy) > 1e-10:\n        points.insert(0, (x1, y1))\n\n    dx, dy = points[-1][0] - x3, points[-1][1] - y3\n    if (dx * dx + dy * dy) > 1e-10:\n        points.append((x3, y3))\n\n    return np.array(points).reshape(len(points), 2)", "response": "Generate the vertices for a quadratic Bezier curve."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ngenerate the vertices for a third order Bezier curve.", "response": "def curve4_bezier(p1, p2, p3, p4):\n    \"\"\"\n    Generate the vertices for a third order Bezier curve.\n\n    The vertices returned by this function can be passed to a LineVisual or\n    ArrowVisual.\n\n    Parameters\n    ----------\n    p1 : array\n        2D coordinates of the start point\n    p2 : array\n        2D coordinates of the first curve point\n    p3 : array\n        2D coordinates of the second curve point\n    p4 : array\n        2D coordinates of the end point\n\n    Returns\n    -------\n    coords : list\n        Vertices for the Bezier curve.\n\n    See Also\n    --------\n    curve3_bezier\n\n    Notes\n    -----\n    For more information about Bezier curves please refer to the `Wikipedia`_\n    page.\n\n    .. _Wikipedia: https://en.wikipedia.org/wiki/B%C3%A9zier_curve\n    \"\"\"\n    x1, y1 = p1\n    x2, y2 = p2\n    x3, y3 = p3\n    x4, y4 = p4\n    points = []\n    _curve4_recursive_bezier(points, x1, y1, x2, y2, x3, y3, x4, y4)\n\n    dx, dy = points[0][0] - x1, points[0][1] - y1\n    if (dx * dx + dy * dy) > 1e-10:\n        points.insert(0, (x1, y1))\n    dx, dy = points[-1][0] - x4, points[-1][1] - y4\n    if (dx * dx + dy * dy) > 1e-10:\n        points.append((x4, y4))\n\n    return np.array(points).reshape(len(points), 2)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef render_to_texture(self, data, texture, offset, size):\n        assert isinstance(texture, Texture2D)\n        set_state(blend=False, depth_test=False)\n\n        # calculate the negative half (within object)\n        orig_tex = Texture2D(255 - data, format='luminance', \n                             wrapping='clamp_to_edge', interpolation='nearest')\n        edf_neg_tex = self._render_edf(orig_tex)\n\n        # calculate positive half (outside object)\n        orig_tex[:, :, 0] = data\n        \n        edf_pos_tex = self._render_edf(orig_tex)\n\n        # render final product to output texture\n        self.program_insert['u_texture'] = orig_tex\n        self.program_insert['u_pos_texture'] = edf_pos_tex\n        self.program_insert['u_neg_texture'] = edf_neg_tex\n        self.fbo_to[-1].color_buffer = texture\n        with self.fbo_to[-1]:\n            set_viewport(tuple(offset) + tuple(size))\n            self.program_insert.draw('triangle_strip')", "response": "Render a SDF to a texture at a given offset and size."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nrendering an EDF to a texture", "response": "def _render_edf(self, orig_tex):\n        \"\"\"Render an EDF to a texture\"\"\"\n        # Set up the necessary textures\n        sdf_size = orig_tex.shape[:2]\n\n        comp_texs = []\n        for _ in range(2):\n            tex = Texture2D(sdf_size + (4,), format='rgba',\n                            interpolation='nearest', wrapping='clamp_to_edge')\n            comp_texs.append(tex)\n        self.fbo_to[0].color_buffer = comp_texs[0]\n        self.fbo_to[1].color_buffer = comp_texs[1]\n        for program in self.programs[1:]:  # program_seed does not need this\n            program['u_texh'], program['u_texw'] = sdf_size\n\n        # Do the rendering\n        last_rend = 0\n        with self.fbo_to[last_rend]:\n            set_viewport(0, 0, sdf_size[1], sdf_size[0])\n            self.program_seed['u_texture'] = orig_tex\n            self.program_seed.draw('triangle_strip')\n        stepsize = (np.array(sdf_size) // 2).max()\n        while stepsize > 0:\n            self.program_flood['u_step'] = stepsize\n            self.program_flood['u_texture'] = comp_texs[last_rend]\n            last_rend = 1 if last_rend == 0 else 0\n            with self.fbo_to[last_rend]:\n                set_viewport(0, 0, sdf_size[1], sdf_size[0])\n                self.program_flood.draw('triangle_strip')\n            stepsize //= 2\n        return comp_texs[last_rend]"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _add_intent_interactive(self, intent_num=0):        \n        '''\n        Interactively add a new intent to the intent schema object \n        '''\n        print (\"Name of intent number : \", intent_num)\n        slot_type_mappings = load_builtin_slots()\n        intent_name = read_from_user(str)\n        print (\"How many slots?\")        \n        num_slots = read_from_user(int)\n        slot_list = []\n        for i in range(num_slots):\n            print (\"Slot name no.\", i+1)\n            slot_name = read_from_user(str).strip()\n            print (\"Slot type? Enter a number for AMAZON supported types below,\"\n                   \"else enter a string for a Custom Slot\")\n            print (json.dumps(slot_type_mappings, indent=True))\n            slot_type_str = read_from_user(str)\n            try: slot_type = slot_type_mappings[int(slot_type_str)]['name'] \n            except: slot_type = slot_type_str\n            slot_list += [self.build_slot(slot_name, slot_type)]                    \n        self.add_intent(intent_name, slot_list)", "response": "Interactively add a new intent to the schema object \n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef from_filename(self, filename):\n        '''\n        Build an IntentSchema from a file path \n        creates a new intent schema if the file does not exist, throws an error if the file\n        exists but cannot be loaded as a JSON\n        '''\n        if os.path.exists(filename):\n            with open(filename) as fp:\n                return IntentSchema(json.load(fp, object_pairs_hook=OrderedDict))\n        else:\n            print ('File does not exist')\n            return IntentSchema()", "response": "Build an IntentSchema from a file path \n        creates a new IntentSchema if the file does not exist throws an error if the file does not exist returns an IntentSchema"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nannotating functions with VoiceHandler so that they can be automatically mapped to non - intent requests.", "response": "def launch_request_handler(request):\n    \"\"\" Annotate functions with @VoiceHandler so that they can be automatically mapped \n    to request types. Use the 'request_type' field to map them to non-intent requests \"\"\"\n\n    user_id = request.access_token()\n    if user_id in twitter_cache.users():\n\n        user_cache = twitter_cache.get_user_state(user_id)        \n        user_cache[\"amzn_id\"]= request.user_id()\n        base_message = \"Welcome to Twitter, {} . How may I help you today ?\".format(user_cache[\"screen_name\"])\n        print (user_cache)        \n        if 'pending_action' in user_cache:\n            base_message += \" You have one pending action . \"\n            print (\"Found pending action\")\n            if 'description' in user_cache['pending_action']:\n                print (\"Found description\")\n                base_message += user_cache['pending_action']['description']\n        return r.create_response(base_message)\n\n    card = r.create_card(title=\"Please log into twitter\", card_type=\"LinkAccount\")\n    return r.create_response(message=\"Welcome to twitter, looks like you haven't logged in!\"\n                             \" Log in via the alexa app.\", card_obj=card,\n                             end_session=True)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef post_tweet_intent_handler(request):\n    tweet = request.get_slot_value(\"Tweet\")\n    tweet = tweet if tweet else \"\"    \n    if tweet:\n        user_state = twitter_cache.get_user_state(request.access_token())\n        def action():\n            return post_tweet(request.access_token(), tweet)\n\n        message = \"I am ready to post the tweet, {} ,\\n Please say yes to confirm or stop to cancel .\".format(tweet)\n        user_state['pending_action'] = {\"action\" : action,\n                                        \"description\" : message} \n        return r.create_response(message=message, end_session=False)\n    else:\n        # No tweet could be disambiguated\n        message = \" \".join(\n            [\n                \"I'm sorry, I couldn't understand what you wanted to tweet .\",\n                \"Please prepend the message with either post or tweet .\"\n            ]\n        )\n        return alexa.create_response(message=message, end_session=False)", "response": "Post a tweet to the VoiceHandler."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef tweet_list_handler(request, tweet_list_builder, msg_prefix=\"\"):\n\n    \"\"\" This is a generic function to handle any intent that reads out a list of tweets\"\"\"\n    # tweet_list_builder is a function that takes a unique identifier and returns a list of things to say\n    tweets = tweet_list_builder(request.access_token())\n    print (len(tweets), 'tweets found')\n    if tweets:\n        twitter_cache.initialize_user_queue(user_id=request.access_token(),\n                                            queue=tweets)\n        text_to_read_out = twitter_cache.user_queue(request.access_token()).read_out_next(MAX_RESPONSE_TWEETS)        \n        message = msg_prefix + text_to_read_out + \", say 'next' to hear more, or reply to a tweet by number.\"\n        return alexa.create_response(message=message,\n                                     end_session=False)\n    else:\n        return alexa.create_response(message=\"Sorry, no tweets found, please try something else\", \n                                 end_session=False)", "response": "This function handles the generic intent that reads out a list of tweets and returns a list of tweets."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef focused_on_tweet(request):\n    slots = request.get_slot_map()\n    if \"Index\" in slots and slots[\"Index\"]:\n        index = int(slots['Index'])\n\n    elif \"Ordinal\" in slots and slots[\"Index\"]:\n        parse_ordinal = lambda inp : int(\"\".join([l for l in inp if l in string.digits]))\n        index = parse_ordinal(slots['Ordinal'])\n    else:\n        return False\n        \n    index = index - 1 # Going from regular notation to CS notation\n    user_state = twitter_cache.get_user_state(request.access_token())\n    queue = user_state['user_queue'].queue()\n    if index < len(queue):\n        # Analyze tweet in queue\n        tweet_to_analyze = queue[index]\n        user_state['focus_tweet'] = tweet_to_analyze\n        return index + 1 # Returning to regular notation\n        twitter_cache.serialize()\n    return False", "response": "Return index if focused on tweet False if couldn t find it"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nhandle the next intent", "response": "def next_intent_handler(request):\n    \"\"\"\n    Takes care of things whenver the user says 'next'\n    \"\"\"\n\n    message = \"Sorry, couldn't find anything in your next queue\"\n    end_session = True\n    if True:\n        user_queue = twitter_cache.user_queue(request.access_token())\n        if not user_queue.is_finished():\n            message = user_queue.read_out_next(MAX_RESPONSE_TWEETS)\n            if not user_queue.is_finished():\n                end_session = False\n                message = message + \". Please, say 'next' if you want me to read out more. \"\n    return alexa.create_response(message=message,\n                                 end_session=end_session)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef use_app(backend_name=None, call_reuse=True):\n    global default_app\n\n    # If we already have a default_app, raise error or return\n    if default_app is not None:\n        names = default_app.backend_name.lower().replace('(', ' ').strip(') ')\n        names = [name for name in names.split(' ') if name]\n        if backend_name and backend_name.lower() not in names:\n            raise RuntimeError('Can only select a backend once, already using '\n                               '%s.' % names)\n        else:\n            if call_reuse:\n                default_app.reuse()\n            return default_app  # Current backend matches backend_name\n\n    # Create default app\n    default_app = Application(backend_name)\n    return default_app", "response": "Get or create a default application object for the specified backend."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nwriting data to the GL buffer.", "response": "def glBufferData(target, data, usage):\n    \"\"\" Data can be numpy array or the size of data to allocate.\n    \"\"\"\n    if isinstance(data, int):\n        size = data\n        data = ctypes.c_voidp(0)\n    else:\n        if not data.flags['C_CONTIGUOUS'] or not data.flags['ALIGNED']:\n            data = data.copy('C')\n        data_ = data\n        size = data_.nbytes\n        data = data_.ctypes.data\n    res = _lib.glBufferData(target, size, data, usage)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsets the mesh data for the current object.", "response": "def set_data(self, vertices=None, faces=None, vertex_colors=None,\n                 face_colors=None, color=None, meshdata=None):\n        \"\"\"Set the mesh data\n\n        Parameters\n        ----------\n        vertices : array-like | None\n            The vertices.\n        faces : array-like | None\n            The faces.\n        vertex_colors : array-like | None\n            Colors to use for each vertex.\n        face_colors : array-like | None\n            Colors to use for each face.\n        color : instance of Color\n            The color to use.\n        meshdata : instance of MeshData | None\n            The meshdata.\n        \"\"\"\n        if meshdata is not None:\n            self._meshdata = meshdata\n        else:\n            self._meshdata = MeshData(vertices=vertices, faces=faces,\n                                      vertex_colors=vertex_colors,\n                                      face_colors=face_colors)\n        self._bounds = self._meshdata.get_bounds()\n        if color is not None:\n            self._color = Color(color)\n        self.mesh_data_changed()"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets the bounds of the Visual", "response": "def bounds(self, axis, view=None):\n        \"\"\"Get the bounds of the Visual\n\n        Parameters\n        ----------\n        axis : int\n            The axis.\n        view : instance of VisualView\n            The view to use.\n        \"\"\"\n        if view is None:\n            view = self\n        if axis not in self._vshare.bounds:\n            self._vshare.bounds[axis] = self._compute_bounds(axis, view)\n        return self._vshare.bounds[axis]"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ndefines the set of GL state parameters to use when drawing .", "response": "def set_gl_state(self, preset=None, **kwargs):\n        \"\"\"Define the set of GL state parameters to use when drawing\n\n        Parameters\n        ----------\n        preset : str\n            Preset to use.\n        **kwargs : dict\n            Keyword arguments to `gloo.set_state`.\n        \"\"\"\n        self._vshare.gl_state = kwargs\n        self._vshare.gl_state['preset'] = preset"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nmodifies the set of GL state parameters to use when drawing", "response": "def update_gl_state(self, *args, **kwargs):\n        \"\"\"Modify the set of GL state parameters to use when drawing\n\n        Parameters\n        ----------\n        *args : tuple\n            Arguments.\n        **kwargs : dict\n            Keyword argments.\n        \"\"\"\n        if len(args) == 1:\n            self._vshare.gl_state['preset'] = args[0]\n        elif len(args) != 0:\n            raise TypeError(\"Only one positional argument allowed.\")\n        self._vshare.gl_state.update(kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _get_hook(self, shader, name):\n        assert name in ('pre', 'post')\n        key = (shader, name)\n        if key in self._hooks:\n            return self._hooks[key]\n        hook = StatementList()\n        if shader == 'vert':\n            self.view_program.vert[name] = hook\n        elif shader == 'frag':\n            self.view_program.frag[name] = hook\n        self._hooks[key] = hook\n        return hook", "response": "Return a FunctionChain that Filters may use to modify the program."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nattaches a Filter to this visual.", "response": "def attach(self, filt, view=None):\n        \"\"\"Attach a Filter to this visual\n\n        Each filter modifies the appearance or behavior of the visual.\n\n        Parameters\n        ----------\n        filt : object\n            The filter to attach.\n        view : instance of VisualView | None\n            The view to use.\n        \"\"\"\n        if view is None:\n            self._vshare.filters.append(filt)\n            for view in self._vshare.views.keys():\n                filt._attach(view)\n        else:\n            view._filters.append(filt)\n            filt._attach(view)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ndetaching a filter from the hierarchy.", "response": "def detach(self, filt, view=None):\n        \"\"\"Detach a filter.\n\n        Parameters\n        ----------\n        filt : object\n            The filter to detach.\n        view : instance of VisualView | None\n            The view to use.\n        \"\"\"\n        if view is None:\n            self._vshare.filters.remove(filt)\n            for view in self._vshare.views.keys():\n                filt._detach(view)\n        else:\n            view._filters.remove(filt)\n            filt._detach(view)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nadds a subvisual to the set of subvisuals.", "response": "def add_subvisual(self, visual):\n        \"\"\"Add a subvisual\n\n        Parameters\n        ----------\n        visual : instance of Visual\n            The visual to add.\n        \"\"\"\n        visual.transforms = self.transforms\n        visual._prepare_transforms(visual)\n        self._subvisuals.append(visual)\n        visual.events.update.connect(self._subv_update)\n        self.update()"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nremoves a subvisual from the set of subvisuals.", "response": "def remove_subvisual(self, visual):\n        \"\"\"Remove a subvisual\n\n        Parameters\n        ----------\n        visual : instance of Visual\n            The visual to remove.\n        \"\"\"\n        visual.events.update.disconnect(self._subv_update)\n        self._subvisuals.remove(visual)\n        self.update()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ndefining the set of GL state parameters to use when drawing", "response": "def set_gl_state(self, preset=None, **kwargs):\n        \"\"\"Define the set of GL state parameters to use when drawing\n\n        Parameters\n        ----------\n        preset : str\n            Preset to use.\n        **kwargs : dict\n            Keyword arguments to `gloo.set_state`.\n        \"\"\"\n        for v in self._subvisuals:\n            v.set_gl_state(preset=preset, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef update_gl_state(self, *args, **kwargs):\n        for v in self._subvisuals:\n            v.update_gl_state(*args, **kwargs)", "response": "Modify the set of GL state parameters to use when drawing\n            is called"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nattach a Filter to this visual.", "response": "def attach(self, filt, view=None):\n        \"\"\"Attach a Filter to this visual\n\n        Each filter modifies the appearance or behavior of the visual.\n\n        Parameters\n        ----------\n        filt : object\n            The filter to attach.\n        view : instance of VisualView | None\n            The view to use.\n        \"\"\"\n        for v in self._subvisuals:\n            v.attach(filt, v)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef detach(self, filt, view=None):\n        for v in self._subvisuals:\n            v.detach(filt, v)", "response": "Detach a filter from all the subvisuals."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef addMov(self, product, quantity=None, mode=\"buy\", stop_limit=None,\n               auto_margin=None, name_counter=None):\n        \"\"\"main function for placing movements\n        stop_limit = {'gain': [mode, value], 'loss': [mode, value]}\"\"\"\n        # ~ ARGS ~\n        if (not isinstance(product, type('')) or\n                (not isinstance(name_counter, type('')) and\n                 name_counter is not None)):\n            raise ValueError('product and name_counter have to be a string')\n        if not isinstance(stop_limit, type({})) and stop_limit is not None:\n            raise ValueError('it has to be a dictionary')\n        # exclusive args\n        if quantity is not None and auto_margin is not None:\n            raise ValueError(\"quantity and auto_margin are exclusive\")\n        elif quantity is None and auto_margin is None:\n            raise ValueError(\"need at least one quantity\")\n        # ~ MAIN ~\n        # open new window\n        mov = self.new_mov(product)\n        mov.open()\n        mov.set_mode(mode)\n        # set quantity\n        if quantity is not None:\n            mov.set_quantity(quantity)\n            # for best performance in long times\n            try:\n                margin = mov.get_unit_value() * quantity\n            except TimeoutError:\n                mov.close()\n                logger.warning(\"market closed for %s\" % mov.product)\n                return False\n        # auto_margin calculate quantity (how simple!)\n        elif auto_margin is not None:\n            unit_value = mov.get_unit_value()\n            mov.set_quantity(auto_margin * unit_value)\n            margin = auto_margin\n        # stop limit (how can be so simple!)\n        if stop_limit is not None:\n            mov.set_limit('gain', stop_limit['gain'][0], stop_limit['gain'][1])\n            mov.set_limit('loss', stop_limit['loss'][0], stop_limit['loss'][1])\n        # confirm\n        try:\n            mov.confirm()\n        except (exceptions.MaxQuantLimit, exceptions.MinQuantLimit) as e:\n            logger.warning(e.err)\n            # resolve immediately\n            mov.set_quantity(e.quant)\n            mov.confirm()\n        except Exception:\n            logger.exception('undefined error in movement confirmation')\n        mov_logger.info(f\"added {mov.product} movement of {mov.quantity} \" +\n                        f\"with margin of {margin}\")\n        mov_logger.debug(f\"stop_limit: {stop_limit}\")", "response": "add a new Movements to the current window"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nchecking stocks in preference", "response": "def checkStock(self):\n        \"\"\"check stocks in preference\"\"\"\n        if not self.preferences:\n            logger.debug(\"no preferences\")\n            return None\n        soup = BeautifulSoup(\n            self.xpath(path['stock-table'])[0].html, \"html.parser\")\n        count = 0\n        # iterate through product in left panel\n        for product in soup.select(\"div.tradebox\"):\n            prod_name = product.select(\"span.instrument-name\")[0].text\n            stk_name = [x for x in self.preferences\n                        if x.lower() in prod_name.lower()]\n            if not stk_name:\n                continue\n            name = prod_name\n            if not [x for x in self.stocks if x.product == name]:\n                self.stocks.append(Stock(name))\n            stock = [x for x in self.stocks if x.product == name][0]\n            if 'tradebox-market-closed' in product['class']:\n                stock.market = False\n            if not stock.market:\n                logger.debug(\"market closed for %s\" % stock.product)\n                continue\n            sell_price = product.select(\"div.tradebox-price-sell\")[0].text\n            buy_price = product.select(\"div.tradebox-price-buy\")[0].text\n            sent = int(product.select(path['sent'])[0].text.strip('%')) / 100\n            stock.new_rec([sell_price, buy_price, sent])\n            count += 1\n        logger.debug(f\"added %d stocks\" % count)\n        return self.stocks"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nclear the left panel and preferences", "response": "def clearPrefs(self):\n        \"\"\"clear the left panel and preferences\"\"\"\n        self.preferences.clear()\n        tradebox_num = len(self.css('div.tradebox'))\n        for i in range(tradebox_num):\n            self.xpath(path['trade-box'])[0].right_click()\n            self.css1('div.item-trade-contextmenu-list-remove').click()\n        logger.info(\"cleared preferences\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nadds preference in self. preferences", "response": "def addPrefs(self, prefs=[]):\n        \"\"\"add preference in self.preferences\"\"\"\n        if len(prefs) == len(self.preferences) == 0:\n            logger.debug(\"no preferences\")\n            return None\n        self.preferences.extend(prefs)\n        self.css1(path['search-btn']).click()\n        count = 0\n        for pref in self.preferences:\n            self.css1(path['search-pref']).fill(pref)\n            self.css1(path['pref-icon']).click()\n            btn = self.css1('div.add-to-watchlist-popup-item .icon-wrapper')\n            if not self.css1('svg', btn)['class'] is None:\n                btn.click()\n                count += 1\n            # remove window\n            self.css1(path['pref-icon']).click()\n        # close finally\n        self.css1(path['back-btn']).click()\n        self.css1(path['back-btn']).click()\n        logger.debug(\"updated %d preferences\" % count)\n        return self.preferences"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nloading glyph from font into dict", "response": "def _load_glyph(f, char, glyphs_dict):\n    \"\"\"Load glyph from font into dict\"\"\"\n    from ...ext.freetype import (FT_LOAD_RENDER, FT_LOAD_NO_HINTING,\n                                 FT_LOAD_NO_AUTOHINT)\n    flags = FT_LOAD_RENDER | FT_LOAD_NO_HINTING | FT_LOAD_NO_AUTOHINT\n    face = _load_font(f['face'], f['bold'], f['italic'])\n    face.set_char_size(f['size'] * 64)\n    # get the character of interest\n    face.load_char(char, flags)\n    bitmap = face.glyph.bitmap\n    width = face.glyph.bitmap.width\n    height = face.glyph.bitmap.rows\n    bitmap = np.array(bitmap.buffer)\n    w0 = bitmap.size // height if bitmap.size > 0 else 0\n    bitmap.shape = (height, w0)\n    bitmap = bitmap[:, :width].astype(np.ubyte)\n\n    left = face.glyph.bitmap_left\n    top = face.glyph.bitmap_top\n    advance = face.glyph.advance.x / 64.\n    glyph = dict(char=char, offset=(left, top), bitmap=bitmap,\n                 advance=advance, kerning={})\n    glyphs_dict[char] = glyph\n    # Generate kerning\n    for other_char, other_glyph in glyphs_dict.items():\n        kerning = face.get_kerning(other_char, char)\n        glyph['kerning'][other_char] = kerning.x / 64.\n        kerning = face.get_kerning(char, other_char)\n        other_glyph['kerning'][char] = kerning.x / 64."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _set_clipper(self, node, clipper):\n        if node in self._clippers:\n            self.detach(self._clippers.pop(node))\n        if clipper is not None:\n            self.attach(clipper)\n            self._clippers[node] = clipper", "response": "Assign a clipper that is inherited from a parent node."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _update_trsys(self, event):\n        doc = self.document_node\n        scene = self.scene_node\n        root = self.root_node\n        self.transforms.visual_transform = self.node_transform(scene)\n        self.transforms.scene_transform = scene.node_transform(doc)\n        self.transforms.document_transform = doc.node_transform(root)\n\n        Node._update_trsys(self, event)", "response": "Update the transforms object for this Node ; assign these to the visual s TransformSystem."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef cfnumber_to_number(cfnumber):\n    numeric_type = cf.CFNumberGetType(cfnumber)\n    cfnum_to_ctype = {kCFNumberSInt8Type: c_int8, kCFNumberSInt16Type: c_int16,\n                      kCFNumberSInt32Type: c_int32,\n                      kCFNumberSInt64Type: c_int64,\n                      kCFNumberFloat32Type: c_float,\n                      kCFNumberFloat64Type: c_double,\n                      kCFNumberCharType: c_byte, kCFNumberShortType: c_short,\n                      kCFNumberIntType: c_int, kCFNumberLongType: c_long,\n                      kCFNumberLongLongType: c_longlong,\n                      kCFNumberFloatType: c_float,\n                      kCFNumberDoubleType: c_double,\n                      kCFNumberCFIndexType: CFIndex,\n                      kCFNumberCGFloatType: CGFloat}\n\n    if numeric_type in cfnum_to_ctype:\n        t = cfnum_to_ctype[numeric_type]\n        result = t()\n        if cf.CFNumberGetValue(cfnumber, numeric_type, byref(result)):\n            return result.value\n    else:\n        raise Exception(\n            'cfnumber_to_number: unhandled CFNumber type %d' % numeric_type)", "response": "Convert CFNumber to python int or float."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef cftype_to_value(cftype):\n    if not cftype:\n        return None\n    typeID = cf.CFGetTypeID(cftype)\n    if typeID in known_cftypes:\n        convert_function = known_cftypes[typeID]\n        return convert_function(cftype)\n    else:\n        return cftype", "response": "Convert a CFType into an equivalent python type."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef cfset_to_set(cfset):\n    count = cf.CFSetGetCount(cfset)\n    buffer = (c_void_p * count)()\n    cf.CFSetGetValues(cfset, byref(buffer))\n    return set([cftype_to_value(c_void_p(buffer[i])) for i in range(count)])", "response": "Convert CFSet to python set."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nconverts CFArray to python list.", "response": "def cfarray_to_list(cfarray):\n    \"\"\"Convert CFArray to python list.\"\"\"\n    count = cf.CFArrayGetCount(cfarray)\n    return [cftype_to_value(c_void_p(cf.CFArrayGetValueAtIndex(cfarray, i)))\n            for i in range(count)]"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef ctype_for_encoding(self, encoding):\n        if encoding in self.typecodes:\n            return self.typecodes[encoding]\n        elif encoding[0:1] == b'^' and encoding[1:] in self.typecodes:\n            return POINTER(self.typecodes[encoding[1:]])\n        elif encoding[0:1] == b'^' and encoding[1:] in [CGImageEncoding,\n                                                        NSZoneEncoding]:\n            return c_void_p\n        elif encoding[0:1] == b'r' and encoding[1:] in self.typecodes:\n            return self.typecodes[encoding[1:]]\n        elif encoding[0:2] == b'r^' and encoding[2:] in self.typecodes:\n            return POINTER(self.typecodes[encoding[2:]])\n        else:\n            raise Exception('unknown encoding for %s: %s'\n                            % (self.name, encoding))", "response": "Return ctypes type for an encoded Objective - C type."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef classmethod(self, encoding):\n        # Add encodings for hidden self and cmd arguments.\n        encoding = ensure_bytes(encoding)\n        typecodes = parse_type_encoding(encoding)\n        typecodes.insert(1, b'@:')\n        encoding = b''.join(typecodes)\n\n        def decorator(f):\n            def objc_class_method(objc_cls, objc_cmd, *args):\n                py_cls = ObjCClass(objc_cls)\n                py_cls.objc_cmd = objc_cmd\n                args = convert_method_arguments(encoding, args)\n                result = f(py_cls, *args)\n                if isinstance(result, ObjCClass):\n                    result = result.ptr.value\n                elif isinstance(result, ObjCInstance):\n                    result = result.ptr.value\n                return result\n            name = f.__name__.replace('_', ':')\n            self.add_class_method(objc_class_method, name, encoding)\n            return objc_class_method\n        return decorator", "response": "Function decorator for class methods."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef append(self, P0, P1, itemsize=None, **kwargs):\n\n        itemsize = itemsize or 1\n        itemcount = len(P0) // itemsize\n\n        V = np.empty(itemcount, dtype=self.vtype)\n\n        # Apply default values on vertices\n        for name in self.vtype.names:\n            if name not in ['collection_index', 'P0', 'P1', 'index']:\n                V[name] = kwargs.get(name, self._defaults[name])\n\n        V['P0'] = P0\n        V['P1'] = P1\n        V = V.repeat(4, axis=0)\n        V['index'] = np.resize([0, 1, 2, 3], 4 * itemcount * itemsize)\n\n        I = np.ones((itemcount, 6), dtype=int)\n        I[:] = 0, 1, 2, 0, 2, 3\n        I[:] += 4 * np.arange(itemcount)[:, np.newaxis]\n        I = I.ravel()\n\n        # Uniforms\n        if self.utype:\n            U = np.zeros(itemcount, dtype=self.utype)\n            for name in self.utype.names:\n                if name not in [\"__unused__\"]:\n                    U[name] = kwargs.get(name, self._defaults[name])\n        else:\n            U = None\n\n        Collection.append(\n            self, vertices=V, uniforms=U, indices=I, itemsize=4 * itemcount)", "response": "Append a new set of segments to the collection."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_frag_shader(volumes, clipped=False, n_volume_max=5):\n\n    declarations = \"\"\n    before_loop = \"\"\n    in_loop = \"\"\n    after_loop = \"\"\n\n    for index in range(n_volume_max):\n        declarations += \"uniform $sampler_type u_volumetex_{0:d};\\n\".format(index)\n        before_loop += \"dummy = $sample(u_volumetex_{0:d}, loc).g;\\n\".format(index)\n\n    declarations += \"uniform $sampler_type dummy1;\\n\"\n    declarations += \"float dummy;\\n\"\n\n    for label in sorted(volumes):\n\n        index = volumes[label]['index']\n\n        # Global declarations\n        declarations += \"uniform float u_weight_{0:d};\\n\".format(index)\n        declarations += \"uniform int u_enabled_{0:d};\\n\".format(index)\n\n        # Declarations before the raytracing loop\n        before_loop += \"float max_val_{0:d} = 0;\\n\".format(index)\n\n        # Calculation inside the main raytracing loop\n\n        in_loop += \"if(u_enabled_{0:d} == 1) {{\\n\\n\".format(index)\n\n        if clipped:\n            in_loop += (\"if(loc.r > u_clip_min.r && loc.r < u_clip_max.r &&\\n\"\n                        \"   loc.g > u_clip_min.g && loc.g < u_clip_max.g &&\\n\"\n                        \"   loc.b > u_clip_min.b && loc.b < u_clip_max.b) {\\n\\n\")\n\n        in_loop += \"// Sample texture for layer {0}\\n\".format(label)\n        in_loop += \"val = $sample(u_volumetex_{0:d}, loc).g;\\n\".format(index)\n\n        if volumes[label].get('multiply') is not None:\n            index_other = volumes[volumes[label]['multiply']]['index']\n            in_loop += (\"if (val != 0) {{ val *= $sample(u_volumetex_{0:d}, loc).g; }}\\n\"\n                        .format(index_other))\n\n        in_loop += \"max_val_{0:d} = max(val, max_val_{0:d});\\n\\n\".format(index)\n\n        if clipped:\n            in_loop += \"}\\n\\n\"\n\n        in_loop += \"}\\n\\n\"\n\n        # Calculation after the main loop\n\n        after_loop += \"// Compute final color for layer {0}\\n\".format(label)\n        after_loop += (\"color = $cmap{0:d}(max_val_{0:d});\\n\"\n                       \"color.a *= u_weight_{0:d};\\n\"\n                       \"total_color += color.a * color;\\n\"\n                       \"max_alpha = max(color.a, max_alpha);\\n\"\n                       \"count += color.a;\\n\\n\").format(index)\n\n    if not clipped:\n        before_loop += \"\\nfloat val3 = u_clip_min.g + u_clip_max.g;\\n\\n\"\n\n    # Code esthetics\n    before_loop = indent(before_loop, \" \" * 4).strip()\n    in_loop = indent(in_loop, \" \" * 16).strip()\n    after_loop = indent(after_loop, \" \" * 4).strip()\n\n    return FRAG_SHADER.format(declarations=declarations,\n                              before_loop=before_loop,\n                              in_loop=in_loop,\n                              after_loop=after_loop)", "response": "Get the fragment shader code for the given volumes."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nconnect to the EGL display server.", "response": "def eglGetDisplay(display=EGL_DEFAULT_DISPLAY):\n    \"\"\" Connect to the EGL display server.\n    \"\"\"\n    res = _lib.eglGetDisplay(display)\n    if not res or res == EGL_NO_DISPLAY:\n        raise RuntimeError('Could not create display')\n    return res"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef eglInitialize(display):\n    majorVersion = (_c_int*1)()\n    minorVersion = (_c_int*1)()\n    res = _lib.eglInitialize(display, majorVersion, minorVersion)\n    if res == EGL_FALSE:\n        raise RuntimeError('Could not initialize')\n    return majorVersion[0], minorVersion[0]", "response": "Initialize EGL and return EGL version tuple."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nquery string from display", "response": "def eglQueryString(display, name):\n    \"\"\" Query string from display\n    \"\"\"\n    out = _lib.eglQueryString(display, name)\n    if not out:\n        raise RuntimeError('Could not query %s' % name)\n    return out"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_edges(self, indexed=None):\n        \n        if indexed is None:\n            if self._edges is None:\n                self._compute_edges(indexed=None)\n            return self._edges\n        elif indexed == 'faces':\n            if self._edges_indexed_by_faces is None:\n                self._compute_edges(indexed='faces')\n            return self._edges_indexed_by_faces\n        else:\n            raise Exception(\"Invalid indexing mode. Accepts: None, 'faces'\")", "response": "Returns the edges of the current node in the current mesh."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset the faces of the current skeleton.", "response": "def set_faces(self, faces):\n        \"\"\"Set the faces\n\n        Parameters\n        ----------\n        faces : ndarray\n            (Nf, 3) array of faces. Each row in the array contains\n            three indices into the vertex array, specifying the three corners\n            of a triangular face.\n        \"\"\"\n        self._faces = faces\n        self._edges = None\n        self._edges_indexed_by_faces = None\n        self._vertex_faces = None\n        self._vertices_indexed_by_faces = None\n        self.reset_normals()\n        self._vertex_colors_indexed_by_faces = None\n        self._face_colors_indexed_by_faces = None"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget the vertices in the unique key store.", "response": "def get_vertices(self, indexed=None):\n        \"\"\"Get the vertices\n\n        Parameters\n        ----------\n        indexed : str | None\n            If Note, return an array (N,3) of the positions of vertices in\n            the mesh. By default, each unique vertex appears only once.\n            If indexed is 'faces', then the array will instead contain three\n            vertices per face in the mesh (and a single vertex may appear more\n            than once in the array).\n\n        Returns\n        -------\n        vertices : ndarray\n            The vertices.\n        \"\"\"\n        if indexed is None:\n            if (self._vertices is None and\n                    self._vertices_indexed_by_faces is not None):\n                self._compute_unindexed_vertices()\n            return self._vertices\n        elif indexed == 'faces':\n            if (self._vertices_indexed_by_faces is None and\n                    self._vertices is not None):\n                self._vertices_indexed_by_faces = \\\n                    self._vertices[self.get_faces()]\n            return self._vertices_indexed_by_faces\n        else:\n            raise Exception(\"Invalid indexing mode. Accepts: None, 'faces'\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_bounds(self):\n        if self._vertices_indexed_by_faces is not None:\n            v = self._vertices_indexed_by_faces\n        elif self._vertices is not None:\n            v = self._vertices\n        else:\n            return None\n        bounds = [(v[:, ax].min(), v[:, ax].max()) for ax in range(v.shape[1])]\n        return bounds", "response": "Get the mesh bounds Returns -------\n        bounds = list of tuples of mesh bounds."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting the vertices of the current object.", "response": "def set_vertices(self, verts=None, indexed=None, reset_normals=True):\n        \"\"\"Set the mesh vertices\n\n        Parameters\n        ----------\n        verts : ndarray | None\n            The array (Nv, 3) of vertex coordinates.\n        indexed : str | None\n            If indexed=='faces', then the data must have shape (Nf, 3, 3) and\n            is assumed to be already indexed as a list of faces. This will\n            cause any pre-existing normal vectors to be cleared unless\n            reset_normals=False.\n        reset_normals : bool\n            If True, reset the normals.\n        \"\"\"\n        if indexed is None:\n            if verts is not None:\n                self._vertices = verts\n            self._vertices_indexed_by_faces = None\n        elif indexed == 'faces':\n            self._vertices = None\n            if verts is not None:\n                self._vertices_indexed_by_faces = verts\n        else:\n            raise Exception(\"Invalid indexing mode. Accepts: None, 'faces'\")\n\n        if reset_normals:\n            self.reset_normals()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn True if this data set has vertex color information.", "response": "def has_vertex_color(self):\n        \"\"\"Return True if this data set has vertex color information\"\"\"\n        for v in (self._vertex_colors, self._vertex_colors_indexed_by_faces,\n                  self._vertex_colors_indexed_by_edges):\n            if v is not None:\n                return True\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns True if this data set has face color information.", "response": "def has_face_color(self):\n        \"\"\"Return True if this data set has face color information\"\"\"\n        for v in (self._face_colors, self._face_colors_indexed_by_faces,\n                  self._face_colors_indexed_by_edges):\n            if v is not None:\n                return True\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget face normals of the current object.", "response": "def get_face_normals(self, indexed=None):\n        \"\"\"Get face normals\n\n        Parameters\n        ----------\n        indexed : str | None\n            If None, return an array (Nf, 3) of normal vectors for each face.\n            If 'faces', then instead return an indexed array (Nf, 3, 3)\n            (this is just the same array with each vector copied three times).\n\n        Returns\n        -------\n        normals : ndarray\n            The normals.\n        \"\"\"\n        if self._face_normals is None:\n            v = self.get_vertices(indexed='faces')\n            self._face_normals = np.cross(v[:, 1] - v[:, 0],\n                                          v[:, 2] - v[:, 0])\n\n        if indexed is None:\n            return self._face_normals\n        elif indexed == 'faces':\n            if self._face_normals_indexed_by_faces is None:\n                norms = np.empty((self._face_normals.shape[0], 3, 3),\n                                 dtype=np.float32)\n                norms[:] = self._face_normals[:, np.newaxis, :]\n                self._face_normals_indexed_by_faces = norms\n            return self._face_normals_indexed_by_faces\n        else:\n            raise Exception(\"Invalid indexing mode. Accepts: None, 'faces'\")"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget vertex normals for the unique entry in the mesh.", "response": "def get_vertex_normals(self, indexed=None):\n        \"\"\"Get vertex normals\n\n        Parameters\n        ----------\n        indexed : str | None\n            If None, return an (N, 3) array of normal vectors with one entry\n            per unique vertex in the mesh. If indexed is 'faces', then the\n            array will contain three normal vectors per face (and some\n            vertices may be repeated).\n\n        Returns\n        -------\n        normals : ndarray\n            The normals.\n        \"\"\"\n        if self._vertex_normals is None:\n            faceNorms = self.get_face_normals()\n            vertFaces = self.get_vertex_faces()\n            self._vertex_normals = np.empty(self._vertices.shape,\n                                            dtype=np.float32)\n            for vindex in xrange(self._vertices.shape[0]):\n                faces = vertFaces[vindex]\n                if len(faces) == 0:\n                    self._vertex_normals[vindex] = (0, 0, 0)\n                    continue\n                norms = faceNorms[faces]  # get all face normals\n                norm = norms.sum(axis=0)  # sum normals\n                renorm = (norm**2).sum()**0.5\n                if renorm > 0:\n                    norm /= renorm\n                self._vertex_normals[vindex] = norm\n\n        if indexed is None:\n            return self._vertex_normals\n        elif indexed == 'faces':\n            return self._vertex_normals[self.get_faces()]\n        else:\n            raise Exception(\"Invalid indexing mode. Accepts: None, 'faces'\")"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_vertex_colors(self, indexed=None):\n        if indexed is None:\n            return self._vertex_colors\n        elif indexed == 'faces':\n            if self._vertex_colors_indexed_by_faces is None:\n                self._vertex_colors_indexed_by_faces = \\\n                    self._vertex_colors[self.get_faces()]\n            return self._vertex_colors_indexed_by_faces\n        else:\n            raise Exception(\"Invalid indexing mode. Accepts: None, 'faces'\")", "response": "Get vertex colors for a specific locale."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsets the vertex color array for the current object.", "response": "def set_vertex_colors(self, colors, indexed=None):\n        \"\"\"Set the vertex color array\n\n        Parameters\n        ----------\n        colors : array\n            Array of colors. Must have shape (Nv, 4) (indexing by vertex)\n            or shape (Nf, 3, 4) (vertices indexed by face).\n        indexed : str | None\n            Should be 'faces' if colors are indexed by faces.\n        \"\"\"\n        colors = _fix_colors(np.asarray(colors))\n        if indexed is None:\n            if colors.ndim != 2:\n                raise ValueError('colors must be 2D if indexed is None')\n            if colors.shape[0] != self.n_vertices:\n                raise ValueError('incorrect number of colors %s, expected %s'\n                                 % (colors.shape[0], self.n_vertices))\n            self._vertex_colors = colors\n            self._vertex_colors_indexed_by_faces = None\n        elif indexed == 'faces':\n            if colors.ndim != 3:\n                raise ValueError('colors must be 3D if indexed is \"faces\"')\n            if colors.shape[0] != self.n_faces:\n                raise ValueError('incorrect number of faces')\n            self._vertex_colors = None\n            self._vertex_colors_indexed_by_faces = colors\n        else:\n            raise ValueError('indexed must be None or \"faces\"')"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the face colors of the current node.", "response": "def get_face_colors(self, indexed=None):\n        \"\"\"Get the face colors\n\n        Parameters\n        ----------\n        indexed : str | None\n            If indexed is None, return (Nf, 4) array of face colors.\n            If indexed=='faces', then instead return an indexed array\n            (Nf, 3, 4)  (note this is just the same array with each color\n            repeated three times).\n        \n        Returns\n        -------\n        colors : ndarray\n            The colors.\n        \"\"\"\n        if indexed is None:\n            return self._face_colors\n        elif indexed == 'faces':\n            if (self._face_colors_indexed_by_faces is None and\n                    self._face_colors is not None):\n                Nf = self._face_colors.shape[0]\n                self._face_colors_indexed_by_faces = \\\n                    np.empty((Nf, 3, 4), dtype=self._face_colors.dtype)\n                self._face_colors_indexed_by_faces[:] = \\\n                    self._face_colors.reshape(Nf, 1, 4)\n            return self._face_colors_indexed_by_faces\n        else:\n            raise Exception(\"Invalid indexing mode. Accepts: None, 'faces'\")"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef set_face_colors(self, colors, indexed=None):\n        colors = _fix_colors(colors)\n        if colors.shape[0] != self.n_faces:\n            raise ValueError('incorrect number of colors %s, expected %s'\n                             % (colors.shape[0], self.n_faces))\n        if indexed is None:\n            if colors.ndim != 2:\n                raise ValueError('colors must be 2D if indexed is None')\n            self._face_colors = colors\n            self._face_colors_indexed_by_faces = None\n        elif indexed == 'faces':\n            if colors.ndim != 3:\n                raise ValueError('colors must be 3D if indexed is \"faces\"')\n            self._face_colors = None\n            self._face_colors_indexed_by_faces = colors\n        else:\n            raise ValueError('indexed must be None or \"faces\"')", "response": "Set the face color array."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef n_faces(self):\n        if self._faces is not None:\n            return self._faces.shape[0]\n        elif self._vertices_indexed_by_faces is not None:\n            return self._vertices_indexed_by_faces.shape[0]", "response": "The number of faces in the mesh."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a list of vertex indices that use it.", "response": "def get_vertex_faces(self):\n        \"\"\"\n        List mapping each vertex index to a list of face indices that use it.\n        \"\"\"\n        if self._vertex_faces is None:\n            self._vertex_faces = [[] for i in xrange(len(self.get_vertices()))]\n            for i in xrange(self._faces.shape[0]):\n                face = self._faces[i]\n                for ind in face:\n                    self._vertex_faces[ind].append(i)\n        return self._vertex_faces"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef save(self):\n        import pickle\n        if self._faces is not None:\n            names = ['_vertices', '_faces']\n        else:\n            names = ['_vertices_indexed_by_faces']\n\n        if self._vertex_colors is not None:\n            names.append('_vertex_colors')\n        elif self._vertex_colors_indexed_by_faces is not None:\n            names.append('_vertex_colors_indexed_by_faces')\n\n        if self._face_colors is not None:\n            names.append('_face_colors')\n        elif self._face_colors_indexed_by_faces is not None:\n            names.append('_face_colors_indexed_by_faces')\n\n        state = dict([(n, getattr(self, n)) for n in names])\n        return pickle.dumps(state)", "response": "Serialize this mesh to a string appropriate for disk storage\n       "}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef restore(self, state):\n        import pickle\n        state = pickle.loads(state)\n        for k in state:\n            if isinstance(state[k], list):\n                state[k] = np.array(state[k])\n            setattr(self, k, state[k])", "response": "Restore the state of a previously saved object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a base color map for a given set of color maps.", "response": "def cubehelix(start=0.5, rot=1, gamma=1.0, reverse=True, nlev=256.,\n         minSat=1.2, maxSat=1.2, minLight=0., maxLight=1.,\n         **kwargs):\n    \"\"\"\n    A full implementation of Dave Green's \"cubehelix\" for Matplotlib.\n    Based on the FORTRAN 77 code provided in\n    D.A. Green, 2011, BASI, 39, 289.\n\n    http://adsabs.harvard.edu/abs/2011arXiv1108.5083G\n\n    User can adjust all parameters of the cubehelix algorithm.\n    This enables much greater flexibility in choosing color maps, while\n    always ensuring the color map scales in intensity from black\n    to white. A few simple examples:\n\n    Default color map settings produce the standard \"cubehelix\".\n\n    Create color map in only blues by setting rot=0 and start=0.\n\n    Create reverse (white to black) backwards through the rainbow once\n    by setting rot=1 and reverse=True.\n\n    Parameters\n    ----------\n    start : scalar, optional\n        Sets the starting position in the color space. 0=blue, 1=red,\n        2=green. Defaults to 0.5.\n    rot : scalar, optional\n        The number of rotations through the rainbow. Can be positive\n        or negative, indicating direction of rainbow. Negative values\n        correspond to Blue->Red direction. Defaults to -1.5\n    gamma : scalar, optional\n        The gamma correction for intensity. Defaults to 1.0\n    reverse : boolean, optional\n        Set to True to reverse the color map. Will go from black to\n        white. Good for density plots where shade~density. Defaults to False\n    nlev : scalar, optional\n        Defines the number of discrete levels to render colors at.\n        Defaults to 256.\n    sat : scalar, optional\n        The saturation intensity factor. Defaults to 1.2\n        NOTE: this was formerly known as \"hue\" parameter\n    minSat : scalar, optional\n        Sets the minimum-level saturation. Defaults to 1.2\n    maxSat : scalar, optional\n        Sets the maximum-level saturation. Defaults to 1.2\n    startHue : scalar, optional\n        Sets the starting color, ranging from [0, 360], as in\n        D3 version by @mbostock\n        NOTE: overrides values in start parameter\n    endHue : scalar, optional\n        Sets the ending color, ranging from [0, 360], as in\n        D3 version by @mbostock\n        NOTE: overrides values in rot parameter\n    minLight : scalar, optional\n        Sets the minimum lightness value. Defaults to 0.\n    maxLight : scalar, optional\n        Sets the maximum lightness value. Defaults to 1.\n\n    Returns\n    -------\n    data : ndarray, shape (N, 3)\n        Control points.\n    \"\"\"\n\n# override start and rot if startHue and endHue are set\n    if kwargs is not None:\n        if 'startHue' in kwargs:\n            start = (kwargs.get('startHue') / 360. - 1.) * 3.\n        if 'endHue' in kwargs:\n            rot = kwargs.get('endHue') / 360. - start / 3. - 1.\n        if 'sat' in kwargs:\n            minSat = kwargs.get('sat')\n            maxSat = kwargs.get('sat')\n\n# set up the parameters\n    fract = np.linspace(minLight, maxLight, nlev)\n    angle = 2.0 * pi * (start / 3.0 + rot * fract + 1.)\n    fract = fract**gamma\n\n    satar = np.linspace(minSat, maxSat, nlev)\n    amp = satar * fract * (1. - fract) / 2.\n\n# compute the RGB vectors according to main equations\n    red = fract + amp * (-0.14861 * np.cos(angle) + 1.78277 * np.sin(angle))\n    grn = fract + amp * (-0.29227 * np.cos(angle) - 0.90649 * np.sin(angle))\n    blu = fract + amp * (1.97294 * np.cos(angle))\n\n# find where RBB are outside the range [0,1], clip\n    red[np.where((red > 1.))] = 1.\n    grn[np.where((grn > 1.))] = 1.\n    blu[np.where((blu > 1.))] = 1.\n\n    red[np.where((red < 0.))] = 0.\n    grn[np.where((grn < 0.))] = 0.\n    blu[np.where((blu < 0.))] = 0.\n\n# optional color reverse\n    if reverse is True:\n        red = red[::-1]\n        blu = blu[::-1]\n        grn = grn[::-1]\n\n    return np.array((red, grn, blu)).T"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nconvert matplotlib color code to hex color code", "response": "def color_to_hex(color):\n    \"\"\"Convert matplotlib color code to hex color code\"\"\"\n    if color is None or colorConverter.to_rgba(color)[3] == 0:\n        return 'none'\n    else:\n        rgb = colorConverter.to_rgb(color)\n        return '#{0:02X}{1:02X}{2:02X}'.format(*(int(255 * c) for c in rgb))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nconvert a many - to - one mapping to a one - to - one mapping", "response": "def _many_to_one(input_dict):\n    \"\"\"Convert a many-to-one mapping to a one-to-one mapping\"\"\"\n    return dict((key, val)\n                for keys, val in input_dict.items()\n                for key in keys)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_dasharray(obj):\n    if obj.__dict__.get('_dashSeq', None) is not None:\n        return ','.join(map(str, obj._dashSeq))\n    else:\n        ls = obj.get_linestyle()\n        dasharray = LINESTYLES.get(ls, 'not found')\n        if dasharray == 'not found':\n            warnings.warn(\"line style '{0}' not understood: \"\n                          \"defaulting to solid line.\".format(ls))\n            dasharray = LINESTYLES['solid']\n        return dasharray", "response": "Get an SVG dash array for the given matplotlib line or path object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef SVG_path(path, transform=None, simplify=False):\n    if transform is not None:\n        path = path.transformed(transform)\n\n    vc_tuples = [(vertices if path_code != Path.CLOSEPOLY else [],\n                  PATH_DICT[path_code])\n                 for (vertices, path_code)\n                 in path.iter_segments(simplify=simplify)]\n\n    if not vc_tuples:\n        # empty path is a special case\n        return np.zeros((0, 2)), []\n    else:\n        vertices, codes = zip(*vc_tuples)\n        vertices = np.array(list(itertools.chain(*vertices))).reshape(-1, 2)\n        return vertices, list(codes)", "response": "Construct the vertices and SVG codes for the path."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_path_style(path, fill=True):\n    style = {}\n    style['alpha'] = path.get_alpha()\n    if style['alpha'] is None:\n        style['alpha'] = 1\n    style['edgecolor'] = color_to_hex(path.get_edgecolor())\n    if fill:\n        style['facecolor'] = color_to_hex(path.get_facecolor())\n    else:\n        style['facecolor'] = 'none'\n    style['edgewidth'] = path.get_linewidth()\n    style['dasharray'] = get_dasharray(path)\n    style['zorder'] = path.get_zorder()\n    return style", "response": "Get the style dictionary for matplotlib path objects"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_line_style(line):\n    style = {}\n    style['alpha'] = line.get_alpha()\n    if style['alpha'] is None:\n        style['alpha'] = 1\n    style['color'] = color_to_hex(line.get_color())\n    style['linewidth'] = line.get_linewidth()\n    style['dasharray'] = get_dasharray(line)\n    style['zorder'] = line.get_zorder()\n    return style", "response": "Get the style dictionary for matplotlib line objects"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the style dictionary for matplotlib marker objects", "response": "def get_marker_style(line):\n    \"\"\"Get the style dictionary for matplotlib marker objects\"\"\"\n    style = {}\n    style['alpha'] = line.get_alpha()\n    if style['alpha'] is None:\n        style['alpha'] = 1\n\n    style['facecolor'] = color_to_hex(line.get_markerfacecolor())\n    style['edgecolor'] = color_to_hex(line.get_markeredgecolor())\n    style['edgewidth'] = line.get_markeredgewidth()\n\n    style['marker'] = line.get_marker()\n    markerstyle = MarkerStyle(line.get_marker())\n    markersize = line.get_markersize()\n    markertransform = (markerstyle.get_transform() +\n                       Affine2D().scale(markersize, -markersize))\n    style['markerpath'] = SVG_path(markerstyle.get_path(),\n                                   markertransform)\n    style['markersize'] = markersize\n    style['zorder'] = line.get_zorder()\n    return style"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the text style dict for a text instance", "response": "def get_text_style(text):\n    \"\"\"Return the text style dict for a text instance\"\"\"\n    style = {}\n    style['alpha'] = text.get_alpha()\n    if style['alpha'] is None:\n        style['alpha'] = 1\n    style['fontsize'] = text.get_size()\n    style['color'] = color_to_hex(text.get_color())\n    style['halign'] = text.get_horizontalalignment()  # left, center, right\n    style['valign'] = text.get_verticalalignment()  # baseline, center, top\n    style['malign'] = text._multialignment  # text alignment when '\\n' in text\n    style['rotation'] = text.get_rotation()\n    style['zorder'] = text.get_zorder()\n    return style"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the property dictionary for a matplotlib. Axis instance", "response": "def get_axis_properties(axis):\n    \"\"\"Return the property dictionary for a matplotlib.Axis instance\"\"\"\n    props = {}\n    label1On = axis._major_tick_kw.get('label1On', True)\n\n    if isinstance(axis, matplotlib.axis.XAxis):\n        if label1On:\n            props['position'] = \"bottom\"\n        else:\n            props['position'] = \"top\"\n    elif isinstance(axis, matplotlib.axis.YAxis):\n        if label1On:\n            props['position'] = \"left\"\n        else:\n            props['position'] = \"right\"\n    else:\n        raise ValueError(\"{0} should be an Axis instance\".format(axis))\n\n    # Use tick values if appropriate\n    locator = axis.get_major_locator()\n    props['nticks'] = len(locator())\n    if isinstance(locator, ticker.FixedLocator):\n        props['tickvalues'] = list(locator())\n    else:\n        props['tickvalues'] = None\n\n    # Find tick formats\n    formatter = axis.get_major_formatter()\n    if isinstance(formatter, ticker.NullFormatter):\n        props['tickformat'] = \"\"\n    elif isinstance(formatter, ticker.FixedFormatter):\n        props['tickformat'] = list(formatter.seq)\n    elif not any(label.get_visible() for label in axis.get_ticklabels()):\n        props['tickformat'] = \"\"\n    else:\n        props['tickformat'] = None\n\n    # Get axis scale\n    props['scale'] = axis.get_scale()\n\n    # Get major tick label size (assumes that's all we really care about!)\n    labels = axis.get_ticklabels()\n    if labels:\n        props['fontsize'] = labels[0].get_fontsize()\n    else:\n        props['fontsize'] = None\n\n    # Get associated grid\n    props['grid'] = get_grid_style(axis)\n\n    return props"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning an iterator over all childen and nested children using obj s get_children method.", "response": "def iter_all_children(obj, skipContainers=False):\n    \"\"\"\n    Returns an iterator over all childen and nested children using\n    obj's get_children() method\n\n    if skipContainers is true, only childless objects are returned.\n    \"\"\"\n    if hasattr(obj, 'get_children') and len(obj.get_children()) > 0:\n        for child in obj.get_children():\n            if not skipContainers:\n                yield child\n            # could use `yield from` in python 3...\n            for grandchild in iter_all_children(child, skipContainers):\n                yield grandchild\n    else:\n        yield obj"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef image_to_base64(image):\n    ax = image.axes\n    binary_buffer = io.BytesIO()\n\n    # image is saved in axes coordinates: we need to temporarily\n    # set the correct limits to get the correct image\n    lim = ax.axis()\n    ax.axis(image.get_extent())\n    image.write_png(binary_buffer)\n    ax.axis(lim)\n\n    binary_buffer.seek(0)\n    return base64.b64encode(binary_buffer.read()).decode('utf-8')", "response": "Convert a matplotlib image to a base64 png representation."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef set_interactive(enabled=True, app=None):\n    if enabled:\n        inputhook_manager.enable_gui('vispy', app)\n    else:\n        inputhook_manager.disable_gui()", "response": "Activate the IPython hook for VisPy."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nwrite text and scroll the log.", "response": "def write(self, text='', wrap=True):\n        \"\"\"Write text and scroll\n\n        Parameters\n        ----------\n        text : str\n            Text to write. ``''`` can be used for a blank line, as a newline\n            is automatically added to the end of each line.\n        wrap : str\n            If True, long messages will be wrapped to span multiple lines.\n        \"\"\"\n        # Clear line\n        if not isinstance(text, string_types):\n            raise TypeError('text must be a string')\n        # ensure we only have ASCII chars\n        text = text.encode('utf-8').decode('ascii', errors='replace')\n        self._pending_writes.append((text, wrap))\n        self.update()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _do_pending_writes(self):\n        for text, wrap in self._pending_writes:\n            # truncate in case of *really* long messages\n            text = text[-self._n_cols*self._n_rows:]\n            text = text.split('\\n')\n            text = [t if len(t) > 0 else '' for t in text]\n            nr, nc = self._n_rows, self._n_cols\n            for para in text:\n                para = para[:nc] if not wrap else para\n                lines = [para[ii:(ii+nc)] for ii in range(0, len(para), nc)]\n                lines = [''] if len(lines) == 0 else lines\n                for line in lines:\n                    # Update row and scroll if necessary\n                    self._text_lines.insert(0, line)\n                    self._text_lines = self._text_lines[:nr]\n                    self._bytes_012[1:] = self._bytes_012[:-1]\n                    self._bytes_345[1:] = self._bytes_345[:-1]\n                    self._insert_text_buf(line, 0)\n        self._pending_writes = []", "response": "Do any pending text writes"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ninsert text into bytes buffers", "response": "def _insert_text_buf(self, line, idx):\n        \"\"\"Insert text into bytes buffers\"\"\"\n        self._bytes_012[idx] = 0\n        self._bytes_345[idx] = 0\n        # Crop text if necessary\n        I = np.array([ord(c) - 32 for c in line[:self._n_cols]])\n        I = np.clip(I, 0, len(__font_6x8__)-1)\n        if len(I) > 0:\n            b = __font_6x8__[I]\n            self._bytes_012[idx, :len(I)] = b[:, :3]\n            self._bytes_345[idx, :len(I)] = b[:, 3:]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset verbatim code replacement AttributeNames AttributeNames", "response": "def replace(self, str1, str2):\n        \"\"\" Set verbatim code replacement\n        \n        It is strongly recommended to use function['$foo'] = 'bar' where\n        possible because template variables are less likely to changed\n        than the code itself in future versions of vispy.\n        \n        Parameters\n        ----------\n        str1 : str\n            String to replace\n        str2 : str\n            String to replace str1 with\n        \"\"\"\n        if str2 != self._replacements.get(str1, None):\n            self._replacements[str1] = str2\n            self.changed(code_changed=True)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _parse_template_vars(self):\n        template_vars = set()\n        for var in parsing.find_template_variables(self._code):\n            var = var.lstrip('$')\n            if var == self.name:\n                continue\n            if var in ('pre', 'post'):\n                raise ValueError('GLSL uses reserved template variable $%s' % \n                                 var)\n            template_vars.add(var)\n        return template_vars", "response": "find all template variables in self. _code excluding the\n        function name."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns code with new name expressions and replacements applied.", "response": "def _get_replaced_code(self, names):\n        \"\"\" Return code, with new name, expressions, and replacements applied.\n        \"\"\"\n        code = self._code\n        \n        # Modify name\n        fname = names[self]\n        code = code.replace(\" \" + self.name + \"(\", \" \" + fname + \"(\")\n\n        # Apply string replacements first -- these may contain $placeholders\n        for key, val in self._replacements.items():\n            code = code.replace(key, val)\n        \n        # Apply assignments to the end of the function\n        \n        # Collect post lines\n        post_lines = []\n        for key, val in self._assignments.items():\n            if isinstance(key, Variable):\n                key = names[key]\n            if isinstance(val, ShaderObject):\n                val = val.expression(names)\n            line = '    %s = %s;' % (key, val)\n            post_lines.append(line)\n            \n        # Add a default $post placeholder if needed\n        if 'post' in self._expressions:\n            post_lines.append('    $post')\n            \n        # Apply placeholders for hooks\n        post_text = '\\n'.join(post_lines)\n        if post_text:\n            post_text = '\\n' + post_text + '\\n'\n        code = code.rpartition('}')\n        code = code[0] + post_text + code[1] + code[2]\n\n        # Add a default $pre placeholder if needed\n        if 'pre' in self._expressions:\n            m = re.search(fname + r'\\s*\\([^{]*\\)\\s*{', code)\n            if m is None:\n                raise RuntimeError(\"Cound not find beginning of function '%s'\" \n                                   % fname) \n            ind = m.span()[1]\n            code = code[:ind] + \"\\n    $pre\\n\" + code[ind:]\n        \n        # Apply template variables\n        for key, val in self._expressions.items():\n            val = val.expression(names)\n            search = r'\\$' + key + r'($|[^a-zA-Z0-9_])'\n            code = re.sub(search, val+r'\\1', code)\n\n        # Done\n        if '$' in code:\n            v = parsing.find_template_variables(code)\n            logger.warning('Unsubstituted placeholders in code: %s\\n'\n                           '  replacements made: %s', \n                           v, list(self._expressions.keys()))\n        \n        return code + '\\n'"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning * code * with indentation and leading / trailing blank lines removed.", "response": "def _clean_code(self, code):\n        \"\"\" Return *code* with indentation and leading/trailing blank lines\n        removed. \n        \"\"\"\n        lines = code.split(\"\\n\")\n        min_indent = 100\n        for line in lines:\n            if line.strip() != \"\":\n                indent = len(line) - len(line.lstrip())\n                min_indent = min(indent, min_indent)\n        if min_indent > 0:\n            lines = [line[min_indent:] for line in lines]\n        code = \"\\n\".join(lines)\n        return code"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating a new ChainFunction and attach it to the current object", "response": "def add_chain(self, var):\n        \"\"\"\n        Create a new ChainFunction and attach to $var.\n        \"\"\"\n        chain = FunctionChain(var, [])\n        self._chains[var] = chain\n        self[var] = chain"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nappends a new function to the end of the chain.", "response": "def append(self, function, update=True):\n        \"\"\" Append a new function to the end of this chain.\n        \"\"\"\n        self._funcs.append(function)\n        self._add_dep(function)\n        if update:\n            self._update()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef insert(self, index, function, update=True):\n        self._funcs.insert(index, function)\n        self._add_dep(function)\n        if update:\n            self._update()", "response": "Insert a new function into the chain at the specified index."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nremoves a function from the chain.", "response": "def remove(self, function, update=True):\n        \"\"\" Remove a function from the chain.\n        \"\"\"\n        self._funcs.remove(function)\n        self._remove_dep(function)\n        if update:\n            self._update()"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nadd an item to the list unless it is already present.", "response": "def add(self, item, position=5):\n        \"\"\"Add an item to the list unless it is already present.\n        \n        If the item is an expression, then a semicolon will be appended to it\n        in the final compiled code.\n        \"\"\"\n        if item in self.items:\n            return\n        self.items[item] = position\n        self._add_dep(item)\n        self.order = None\n        self.changed(code_changed=True)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef remove(self, item):\n        self.items.pop(item)\n        self._remove_dep(item)\n        self.order = None\n        self.changed(code_changed=True)", "response": "Remove an item from the list."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning an array of vertex indexes three per triangular face in the mesh.", "response": "def faces(self):\n        \"\"\"Return an array (Nf, 3) of vertex indexes, three per triangular\n        face in the mesh.\n\n        If faces have not been computed for this mesh, the function\n        computes them.\n        If no vertices or faces are specified, the function returns None.\n        \"\"\"\n\n        if self._faces is None:\n            if self._vertices is None:\n                return None\n            self.triangulate()\n        return self._faces"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn an array of vertices.", "response": "def vertices(self):\n        \"\"\"Return an array (Nf, 3) of vertices.\n\n        If only faces exist, the function computes the vertices and\n        returns them.\n        If no vertices or faces are specified, the function returns None.\n        \"\"\"\n\n        if self._faces is None:\n            if self._vertices is None:\n                return None\n            self.triangulate()\n        return self._vertices"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning an array of vertex indexes representing the convex hull of this mesh.", "response": "def convex_hull(self):\n        \"\"\"Return an array of vertex indexes representing the convex hull.\n\n        If faces have not been computed for this mesh, the function\n        computes them.\n        If no vertices or faces are specified, the function returns None.\n        \"\"\"\n        if self._faces is None:\n            if self._vertices is None:\n                return None\n            self.triangulate()\n        return self._convex_hull"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef triangulate(self):\n        npts = self._vertices.shape[0]\n        if np.any(self._vertices[0] != self._vertices[1]):\n            # start != end, so edges must wrap around to beginning.\n            edges = np.empty((npts, 2), dtype=np.uint32)\n            edges[:, 0] = np.arange(npts)\n            edges[:, 1] = edges[:, 0] + 1\n            edges[-1, 1] = 0\n        else:\n            # start == end; no wrapping required.\n            edges = np.empty((npts-1, 2), dtype=np.uint32)\n            edges[:, 0] = np.arange(npts)\n            edges[:, 1] = edges[:, 0] + 1\n\n        tri = Triangulation(self._vertices, edges)\n        tri.triangulate()\n        return tri.pts, tri.tris", "response": "Triangulates the set of vertices and stores the triangles in faces and the convex hull."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nlocate a filename into the shader library.", "response": "def find(name):\n    \"\"\"Locate a filename into the shader library.\"\"\"\n\n    if op.exists(name):\n        return name\n\n    path = op.dirname(__file__) or '.'\n\n    paths = [path] + config['include_path']\n\n    for path in paths:\n        filename = op.abspath(op.join(path, name))\n        if op.exists(filename):\n            return filename\n\n        for d in os.listdir(path):\n            fullpath = op.abspath(op.join(path, d))\n            if op.isdir(fullpath):\n                filename = op.abspath(op.join(fullpath, name))\n                if op.exists(filename):\n                    return filename\n\n    return None"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get(name):\n\n    filename = find(name)\n    if filename is None:\n        raise RuntimeError('Could not find %s' % name)\n    with open(filename) as fid:\n        return fid.read()", "response": "Retrieve code from the given filename."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nexpecting - try many times with sleep time", "response": "def expect(func, args, times=7, sleep_t=0.5):\n    \"\"\"try many times as in times with sleep time\"\"\"\n    while times > 0:\n        try:\n            return func(*args)\n        except Exception as e:\n            times -= 1\n            logger.debug(\"expect failed - attempts left: %d\" % times)\n            time.sleep(sleep_t)\n            if times == 0:\n                raise exceptions.BaseExc(e)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef num(string):\n    if not isinstance(string, type('')):\n        raise ValueError(type(''))\n    try:\n        string = re.sub('[^a-zA-Z0-9\\.\\-]', '', string)\n        number = re.findall(r\"[-+]?\\d*\\.\\d+|[-+]?\\d+\", string)\n        return float(number[0])\n    except Exception as e:\n        logger = logging.getLogger('tradingAPI.utils.num')\n        logger.debug(\"number not found in %s\" % string)\n        logger.debug(e)\n        return None", "response": "convert a string to float"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_number_unit(number):\n    n = str(float(number))\n    mult, submult = n.split('.')\n    if float(submult) != 0:\n        unit = '0.' + (len(submult)-1)*'0' + '1'\n        return float(unit)\n    else:\n        return float(1)", "response": "get the unit of number"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_pip(mov=None, api=None, name=None):\n    # ~ check args\n    if mov is None and api is None:\n        logger.error(\"need at least one of those\")\n        raise ValueError()\n    elif mov is not None and api is not None:\n        logger.error(\"mov and api are exclusive\")\n        raise ValueError()\n    if api is not None:\n        if name is None:\n            logger.error(\"need a name\")\n            raise ValueError()\n        mov = api.new_mov(name)\n        mov.open()\n    if mov is not None:\n        mov._check_open()\n    # find in the collection\n    try:\n        logger.debug(len(Glob().theCollector.collection))\n        pip = Glob().theCollector.collection['pip']\n        if name is not None:\n            pip_res = pip[name]\n        elif mov is not None:\n            pip_res = pip[mov.product]\n        logger.debug(\"pip found in the collection\")\n        return pip_res\n    except KeyError:\n        logger.debug(\"pip not found in the collection\")\n    # ~ vars\n    records = []\n    intervals = [10, 20, 30]\n\n    def _check_price(interval=10):\n        timeout = time.time() + interval\n        while time.time() < timeout:\n            records.append(mov.get_price())\n            time.sleep(0.5)\n\n    # find variation\n    for interval in intervals:\n        _check_price(interval)\n        if min(records) == max(records):\n            logger.debug(\"no variation in %d seconds\" % interval)\n            if interval == intervals[-1]:\n                raise TimeoutError(\"no variation\")\n        else:\n            break\n    # find longer price\n    for price in records:\n        if 'best_price' not in locals():\n            best_price = price\n        if len(str(price)) > len(str(best_price)):\n            logger.debug(\"found new best_price %f\" % price)\n            best_price = price\n    # get pip\n    pip = get_number_unit(best_price)\n    Glob().pipHandler.add_val({mov.product: pip})\n    return pip", "response": "get value of pip"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the total amount of items in the cache.", "response": "def itemsize(self):\n        \"\"\" Individual item sizes \"\"\"\n        return self._items[:self._count, 1] - self._items[:self._count, 0]"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef reserve(self, capacity):\n\n        if capacity >= self._data.size:\n            capacity = int(2 ** np.ceil(np.log2(capacity)))\n            self._data = np.resize(self._data, capacity)", "response": "Reserves the underlying array to the given capacity."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef insert(self, index, data, itemsize=None):\n\n        if not self._sizeable:\n            raise AttributeError(\"List is not sizeable\")\n\n        if isinstance(data, (list, tuple)) and isinstance(data[0], (list, tuple)):  # noqa\n            itemsize = [len(l) for l in data]\n            data = [item for sublist in data for item in sublist]\n\n        data = np.array(data, copy=False).ravel()\n        size = data.size\n\n        # Check item size and get item number\n        if itemsize is not None:\n            if isinstance(itemsize, int):\n                if (size % itemsize) != 0:\n                    raise ValueError(\"Cannot partition data as requested\")\n                _count = size // itemsize\n                _itemsize = np.ones(_count, dtype=int) * (size // _count)\n            else:\n                _itemsize = np.array(itemsize, copy=False)\n                _count = len(itemsize)\n                if _itemsize.sum() != size:\n                    raise ValueError(\"Cannot partition data as requested\")\n        else:\n            _count = 1\n\n        # Check if data array is big enough and resize it if necessary\n        if self._size + size >= self._data.size:\n            capacity = int(2 ** np.ceil(np.log2(self._size + size)))\n            self._data = np.resize(self._data, capacity)\n\n        # Check if item array is big enough and resize it if necessary\n        if self._count + _count >= len(self._items):\n            capacity = int(2 ** np.ceil(np.log2(self._count + _count)))\n            self._items = np.resize(self._items, (capacity, 2))\n\n        # Check index\n        if index < 0:\n            index += len(self)\n        if index < 0 or index > len(self):\n            raise IndexError(\"List insertion index out of range\")\n\n        # Inserting\n        if index < self._count:\n            istart = index\n            dstart = self._items[istart][0]\n            dstop = self._items[istart][1]\n            # Move data\n            Z = self._data[dstart:self._size]\n            self._data[dstart + size:self._size + size] = Z\n            # Update moved items\n            I = self._items[istart:self._count] + size\n            self._items[istart + _count:self._count + _count] = I\n\n        # Appending\n        else:\n            dstart = self._size\n            istart = self._count\n\n        # Only one item (faster)\n        if _count == 1:\n            # Store data\n            self._data[dstart:dstart + size] = data\n            self._size += size\n            # Store data location (= item)\n            self._items[istart][0] = dstart\n            self._items[istart][1] = dstart + size\n            self._count += 1\n\n        # Several items\n        else:\n            # Store data\n            dstop = dstart + size\n            self._data[dstart:dstop] = data\n            self._size += size\n\n            # Store items\n            items = np.ones((_count, 2), int) * dstart\n            C = _itemsize.cumsum()\n            items[1:, 0] += C[:-1]\n            items[0:, 1] += C\n            istop = istart + _count\n            self._items[istart:istop] = items\n            self._count += _count", "response": "Insert data before index."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nappending data to the end of the array.", "response": "def append(self, data, itemsize=None):\n        \"\"\"\n        Append data to the end.\n\n        Parameters\n        ----------\n\n        data : array_like\n            An array, any object exposing the array interface, an object\n            whose __array__ method returns an array, or any (nested) sequence.\n\n        itemsize:  int or 1-D array\n            If `itemsize is an integer, N, the array will be divided\n            into elements of size N. If such partition is not possible,\n            an error is raised.\n\n            If `itemsize` is 1-D array, the array will be divided into\n            elements whose succesive sizes will be picked from itemsize.\n            If the sum of itemsize values is different from array size,\n            an error is raised.\n        \"\"\"\n\n        self.insert(len(self), data, itemsize)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef minimize(func, bounds=None, nvar=None, args=(), disp=False,\r\n             eps=1e-4,\r\n             maxf=20000,\r\n             maxT=6000,\r\n             algmethod=0,\r\n             fglobal=-1e100,\r\n             fglper=0.01,\r\n             volper=-1.0,\r\n             sigmaper=-1.0,\r\n             **kwargs\r\n             ):\r\n    \"\"\"\r\n    Solve an optimization problem using the DIRECT (Dividing Rectangles) algorithm.\r\n    It can be used to solve general nonlinear programming problems of the form:\r\n\r\n    .. math::\r\n\r\n           \\min_ {x \\in R^n} f(x)\r\n\r\n    subject to\r\n\r\n    .. math::\r\n\r\n           x_L \\leq  x  \\leq x_U\r\n    \r\n    Where :math:`x` are the optimization variables (with upper and lower\r\n    bounds), :math:`f(x)` is the objective function.\r\n\r\n    Parameters\r\n    ----------\r\n    func : objective function\r\n        called as `func(x, *args)`; does not need to be defined everywhere,\r\n        raise an Exception where function is not defined\r\n    \r\n    bounds : array-like\r\n            ``(min, max)`` pairs for each element in ``x``, defining\r\n            the bounds on that parameter.\r\n\r\n    nvar: integer\r\n        Dimensionality of x (only needed if `bounds` is not defined)\r\n        \r\n    eps : float\r\n        Ensures sufficient decrease in function value when a new potentially\r\n        optimal interval is chosen.\r\n\r\n    maxf : integer\r\n        Approximate upper bound on objective function evaluations.\r\n        \r\n        .. note::\r\n        \r\n            Maximal allowed value is 90000 see documentation of Fortran library.\r\n    \r\n    maxT : integer\r\n        Maximum number of iterations.\r\n        \r\n        .. note::\r\n        \r\n            Maximal allowed value is 6000 see documentation of Fortran library.\r\n        \r\n    algmethod : integer\r\n        Whether to use the original or modified DIRECT algorithm. Possible values:\r\n        \r\n        * ``algmethod=0`` - use the original DIRECT algorithm\r\n        * ``algmethod=1`` - use the modified DIRECT-l algorithm\r\n    \r\n    fglobal : float\r\n        Function value of the global optimum. If this value is not known set this\r\n        to a very large negative value.\r\n        \r\n    fglper : float\r\n        Terminate the optimization when the percent error satisfies:\r\n        \r\n        .. math::\r\n\r\n            100*(f_{min} - f_{global})/\\max(1, |f_{global}|) \\leq f_{glper}\r\n        \r\n    volper : float\r\n        Terminate the optimization once the volume of a hyperrectangle is less\r\n        than volper percent of the original hyperrectangel.\r\n        \r\n    sigmaper : float\r\n        Terminate the optimization once the measure of the hyperrectangle is less\r\n        than sigmaper.\r\n    \r\n    Returns\r\n    -------\r\n    res : OptimizeResult\r\n        The optimization result represented as a ``OptimizeResult`` object.\r\n        Important attributes are: ``x`` the solution array, ``success`` a\r\n        Boolean flag indicating if the optimizer exited successfully and\r\n        ``message`` which describes the cause of the termination. See\r\n        `OptimizeResult` for a description of other attributes.\r\n\r\n    \"\"\"\r\n    \r\n    if bounds is None:\r\n        l = np.zeros(nvar, dtype=np.float64)\r\n        u = np.ones(nvar, dtype=np.float64)\r\n    else:\r\n        bounds = np.asarray(bounds)\r\n        l = bounds[:, 0] \r\n        u = bounds[:, 1] \r\n\r\n    def _objective_wrap(x, iidata, ddata, cdata, n, iisize, idsize, icsize):\r\n        \"\"\"\r\n        Wrap the python objective to comply with the signature required by the\r\n        Fortran library.\r\n\r\n        Returns the function value and a flag indicating whether function is defined.\r\n        If function is not defined return np.nan\r\n        \"\"\"\r\n        try:\r\n            return func(x, *args), 0\r\n        except:\r\n            return np.nan, 1\r\n\r\n    #\r\n    # Dummy values so that the python wrapper will comply with the required\r\n    # signature of the fortran library.\r\n    #\r\n    iidata = np.ones(0, dtype=np.int32)\r\n    ddata = np.ones(0, dtype=np.float64)\r\n    cdata = np.ones([0, 40], dtype=np.uint8)\r\n\r\n    #\r\n    # Call the DIRECT algorithm\r\n    #\r\n    x, fun, ierror = direct(\r\n                        _objective_wrap,\r\n                        eps,\r\n                        maxf,\r\n                        maxT,\r\n                        l,\r\n                        u,\r\n                        algmethod,\r\n                        'dummylogfile', \r\n                        fglobal,\r\n                        fglper,\r\n                        volper,\r\n                        sigmaper,\r\n                        iidata,\r\n                        ddata,\r\n                        cdata,\r\n                        disp\r\n                        )\r\n\r\n    return OptimizeResult(x=x,fun=fun, status=ierror, success=ierror>0,\r\n                          message=SUCCESS_MESSAGES[ierror-1] if ierror>0 else ERROR_MESSAGES[abs(ierror)-1])", "response": "Returns a new object that minimizes the given function."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_dpi(raise_error=True):\n    try:\n        user32.SetProcessDPIAware()\n    except AttributeError:\n        pass  # not present on XP\n    dc = user32.GetDC(0)\n    h_size = gdi32.GetDeviceCaps(dc, HORZSIZE)\n    v_size = gdi32.GetDeviceCaps(dc, VERTSIZE)\n    h_res = gdi32.GetDeviceCaps(dc, HORZRES)\n    v_res = gdi32.GetDeviceCaps(dc, VERTRES)\n    user32.ReleaseDC(None, dc)\n    return (h_res/float(h_size) + v_res/float(v_size)) * 0.5 * 25.4", "response": "Get the DPI from the OS and return it."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef build_if_needed(self):\n        if self._need_build:\n            self._build()\n            self._need_build = False\n        self.update_variables()", "response": "Build the shader source if necessary."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a function that maps a number n from range a b c d to a range a . Optionally a curvefn can be provided to transform output. Optionally a normfn can be provided to transform output.", "response": "def nmap(a, b, c, d, curvefn=None, normfn=None):\n    \"\"\"\n    Returns a function that maps a number n from range (a, b) onto a range\n    (c, d). If no curvefn is given, linear mapping will be used. Optionally a\n    normalisation function normfn can be provided to transform output.\n    \"\"\"\n    if not curvefn:\n        curvefn = lambda x: x\n\n    def map(n):\n        r = 1.0 * (n - a) / (b - a)\n        out = curvefn(r) * (d - c) + c\n        if not normfn:\n            return out\n        return normfn(out)\n    return map"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nlinks this axis to a ViewBox This makes it so that the axis s domain always matches the visible range in the ViewBox.", "response": "def link_view(self, view):\n        \"\"\"Link this axis to a ViewBox\n\n        This makes it so that the axis's domain always matches the\n        visible range in the ViewBox.\n\n        Parameters\n        ----------\n        view : instance of ViewBox\n            The ViewBox to link.\n        \"\"\"\n        if view is self._linked_view:\n            return\n        if self._linked_view is not None:\n            self._linked_view.scene.transform.changed.disconnect(\n                self._view_changed)\n        self._linked_view = view\n        view.scene.transform.changed.connect(self._view_changed)\n        self._view_changed()"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nupdates the axis domain based on the current transform.", "response": "def _view_changed(self, event=None):\n        \"\"\"Linked view transform has changed; update ticks.\n        \"\"\"\n        tr = self.node_transform(self._linked_view.scene)\n        p1, p2 = tr.map(self._axis_ends())\n        if self.orientation in ('left', 'right'):\n            self.axis.domain = (p1[1], p2[1])\n        else:\n            self.axis.domain = (p1[0], p2[0])"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef viewbox_mouse_event(self, event):\n        # When the attached ViewBox reseives a mouse event, it is sent to the\n        # camera here.\n        \n        self.mouse_pos = event.pos[:2]\n        if event.type == 'mouse_wheel':\n            # wheel rolled; adjust the magnification factor and hide the \n            # event from the superclass\n            m = self.mag_target \n            m *= 1.2 ** event.delta[1]\n            m = m if m > 1 else 1\n            self.mag_target = m\n        else:\n            # send everything _except_ wheel events to the superclass\n            super(MagnifyCamera, self).viewbox_mouse_event(event)\n            \n        # start the timer to smoothly modify the transform properties. \n        if not self.timer.running:\n            self.timer.start()\n        \n        self._update_transform()", "response": "This method is called by the mouse event handler to send the viewbox events to the camera."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef glBufferData(target, data, usage):\n    if isinstance(data, int):\n        size = data\n        data = ctypes.c_voidp(0)\n    else:\n        if not data.flags['C_CONTIGUOUS'] or not data.flags['ALIGNED']:\n            data = data.copy('C')\n        data_ = data\n        size = data_.nbytes\n        data = data_.ctypes.data\n    try:\n        nativefunc = glBufferData._native\n    except AttributeError:\n        nativefunc = glBufferData._native = _get_gl_func(\"glBufferData\", None, (ctypes.c_uint, ctypes.c_int, ctypes.c_void_p, ctypes.c_uint,))\n    res = nativefunc(target, size, data, usage)", "response": "This function is used to allocate memory for a buffer."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef next_power_of_2(n):\n    n -= 1  # greater than OR EQUAL TO n\n    shift = 1\n    while (n + 1) & n:  # n+1 is not a power of 2 yet\n        n |= n >> shift\n        shift *= 2\n    return max(4, n + 1)", "response": "Return next power of 2 greater than or equal to n"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef append(self, vertices, uniforms=None, indices=None, itemsize=None):\n\n        # Vertices\n        # -----------------------------\n        vertices = np.array(vertices).astype(self.vtype).ravel()\n        vsize = self._vertices_list.size\n\n        # No itemsize given\n        # -----------------\n        if itemsize is None:\n            index = 0\n            count = 1\n\n        # Uniform itemsize (int)\n        # ----------------------\n        elif isinstance(itemsize, int):\n            count = len(vertices) / itemsize\n            index = np.repeat(np.arange(count), itemsize)\n\n        # Individual itemsize (array)\n        # ---------------------------\n        elif isinstance(itemsize, (np.ndarray, list)):\n            count = len(itemsize)\n            index = np.repeat(np.arange(count), itemsize)\n        else:\n            raise ValueError(\"Itemsize not understood\")\n\n        if self.utype:\n            vertices[\"collection_index\"] = index + len(self)\n        self._vertices_list.append(vertices, itemsize)\n\n        # Indices\n        # -----------------------------\n        if self.itype is not None:\n            # No indices given (-> automatic generation)\n            if indices is None:\n                indices = vsize + np.arange(len(vertices))\n                self._indices_list.append(indices, itemsize)\n\n            # Indices given\n            # FIXME: variables indices (list of list or ArrayList)\n            else:\n                if itemsize is None:\n                    I = np.array(indices) + vsize\n                elif isinstance(itemsize, int):\n                    I = vsize + (np.tile(indices, count) +\n                                 itemsize * np.repeat(np.arange(count), len(indices)))  # noqa\n                else:\n                    raise ValueError(\"Indices not compatible with items\")\n                self._indices_list.append(I, len(indices))\n\n        # Uniforms\n        # -----------------------------\n        if self.utype:\n            if uniforms is None:\n                uniforms = np.zeros(count, dtype=self.utype)\n            else:\n                uniforms = np.array(uniforms).astype(self.utype).ravel()\n            self._uniforms_list.append(uniforms, itemsize=1)\n\n        self._need_update = True", "response": "Append a new entry to the internal list."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _compute_texture_shape(self, size=1):\n\n        # We should use this line but we may not have a GL context yet\n        # linesize = gl.glGetInteger(gl.GL_MAX_TEXTURE_SIZE)\n        linesize = 1024\n        count = self._uniforms_float_count\n        cols = 4 * linesize // int(count)\n        rows = max(1, int(math.ceil(size / float(cols))))\n        shape = rows, cols * (count // 4), count\n        self._ushape = shape\n        return shape", "response": "Compute uniform texture shape"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_layout(name, *args, **kwargs):\n    if name not in _layout_map:\n        raise KeyError(\"Graph layout '%s' not found. Should be one of %s\"\n                       % (name, AVAILABLE_LAYOUTS))\n\n    layout = _layout_map[name]\n\n    if inspect.isclass(layout):\n        layout = layout(*args, **kwargs)\n\n    return layout", "response": "Returns a graph layout with the given name."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef update_viewer_state(rec, context):\n\n    if '_protocol' not in rec:\n\n        rec.pop('properties')\n\n        rec['state'] = {}\n        rec['state']['values'] = rec.pop('options')\n\n        layer_states = []\n\n        for layer in rec['layers']:\n            state_id = str(uuid.uuid4())\n            state_cls = STATE_CLASS[layer['_type'].split('.')[-1]]\n            state = state_cls(layer=context.object(layer.pop('layer')))\n            properties = set(layer.keys()) - set(['_type'])\n            for prop in sorted(properties, key=state.update_priority, reverse=True):\n                value = layer.pop(prop)\n                value = context.object(value)\n                if isinstance(value, six.string_types) and value == 'fixed':\n                    value = 'Fixed'\n                if isinstance(value, six.string_types) and value == 'linear':\n                    value = 'Linear'\n                setattr(state, prop, value)\n            context.register_object(state_id, state)\n            layer['state'] = state_id\n            layer_states.append(state)\n\n        list_id = str(uuid.uuid4())\n        context.register_object(list_id, layer_states)\n        rec['state']['values']['layers'] = list_id\n\n        rec['state']['values']['visible_axes'] = rec['state']['values'].pop('visible_box')", "response": "Update the state of the viewer in - place."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef remove_comments(code):\n\n    pattern = r\"(\\\".*?\\\"|\\'.*?\\')|(/\\*.*?\\*/|//[^\\r\\n]*\\n)\"\n    # first group captures quoted strings (double or single)\n    # second group captures comments (//single-line or /* multi-line */)\n    regex = re.compile(pattern, re.MULTILINE | re.DOTALL)\n\n    def do_replace(match):\n        # if the 2nd group (capturing comments) is not None,\n        # it means we have captured a non-quoted (real) comment string.\n        if match.group(2) is not None:\n            return \"\"  # so we will return empty to remove the comment\n        else:  # otherwise, we will return the 1st group\n            return match.group(1)  # captured quoted-string\n\n    return regex.sub(do_replace, code)", "response": "Remove C - style comment from GLSL code string."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nmerge all includes recursively.", "response": "def merge_includes(code):\n    \"\"\"Merge all includes recursively.\"\"\"\n\n    pattern = '\\#\\s*include\\s*\"(?P<filename>[a-zA-Z0-9\\_\\-\\.\\/]+)\"'\n    regex = re.compile(pattern)\n    includes = []\n\n    def replace(match):\n        filename = match.group(\"filename\")\n\n        if filename not in includes:\n            includes.append(filename)\n            path = glsl.find(filename)\n            if not path:\n                logger.critical('\"%s\" not found' % filename)\n                raise RuntimeError(\"File not found\", filename)\n            text = '\\n// --- start of \"%s\" ---\\n' % filename\n            with open(path) as fh:\n                text += fh.read()\n            text += '// --- end of \"%s\" ---\\n' % filename\n            return text\n        return ''\n\n    # Limit recursion to depth 10\n    for i in range(10):\n        if re.search(regex, code):\n            code = re.sub(regex, replace, code)\n        else:\n            break\n\n    return code"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nadd a new widget to the grid.", "response": "def add_widget(self, widget=None, row=None, col=None, row_span=1,\n                   col_span=1, **kwargs):\n        \"\"\"\n        Add a new widget to this grid. This will cause other widgets in the\n        grid to be resized to make room for the new widget. Can be used\n        to replace a widget as well\n\n        Parameters\n        ----------\n        widget : Widget | None\n            The Widget to add. New widget is constructed if widget is None.\n        row : int\n            The row in which to add the widget (0 is the topmost row)\n        col : int\n            The column in which to add the widget (0 is the leftmost column)\n        row_span : int\n            The number of rows to be occupied by this widget. Default is 1.\n        col_span : int\n            The number of columns to be occupied by this widget. Default is 1.\n        **kwargs : dict\n            parameters sent to the new Widget that is constructed if\n            widget is None\n\n        Notes\n        -----\n        The widget's parent is automatically set to this grid, and all other\n        parent(s) are removed.\n        \"\"\"\n        if row is None:\n            row = self._next_cell[0]\n        if col is None:\n            col = self._next_cell[1]\n\n        if widget is None:\n            widget = Widget(**kwargs)\n        else:\n            if kwargs:\n                raise ValueError(\"cannot send kwargs if widget is given\")\n\n        _row = self._cells.setdefault(row, {})\n        _row[col] = widget\n        self._grid_widgets[self._n_added] = (row, col, row_span, col_span,\n                                             widget)\n        self._n_added += 1\n        widget.parent = self\n\n        self._next_cell = [row, col+col_span]\n\n        widget._var_w = Variable(\"w-(row: %s | col: %s)\" % (row, col))\n        widget._var_h = Variable(\"h-(row: %s | col: %s)\" % (row, col))\n\n        # update stretch based on colspan/rowspan\n        # usually, if you make something consume more grids or columns,\n        # you also want it to actually *take it up*, ratio wise.\n        # otherwise, it will never *use* the extra rows and columns,\n        # thereby collapsing the extras to 0.\n        stretch = list(widget.stretch)\n        stretch[0] = col_span if stretch[0] is None else stretch[0]\n        stretch[1] = row_span if stretch[1] is None else stretch[1]\n        widget.stretch = stretch\n\n        self._need_solver_recreate = True\n\n        return widget"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef remove_widget(self, widget):\n\n        self._grid_widgets = dict((key, val)\n                                  for (key, val) in self._grid_widgets.items()\n                                  if val[-1] != widget)\n\n        self._need_solver_recreate = True", "response": "Removes a widget from this grid\n           "}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef resize_widget(self, widget, row_span, col_span):\n\n        row = None\n        col = None\n\n        for (r, c, rspan, cspan, w) in self._grid_widgets.values():\n            if w == widget:\n                row = r\n                col = c\n\n                break\n\n        if row is None or col is None:\n            raise ValueError(\"%s not found in grid\" % widget)\n\n        self.remove_widget(widget)\n        self.add_widget(widget, row, col, row_span, col_span)\n        self._need_solver_recreate = True", "response": "Resize a widget in the grid to new dimensions."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate a new Grid and add it as a child widget.", "response": "def add_grid(self, row=None, col=None, row_span=1, col_span=1,\n                 **kwargs):\n        \"\"\"\n        Create a new Grid and add it as a child widget.\n\n        Parameters\n        ----------\n        row : int\n            The row in which to add the widget (0 is the topmost row)\n        col : int\n            The column in which to add the widget (0 is the leftmost column)\n        row_span : int\n            The number of rows to be occupied by this widget. Default is 1.\n        col_span : int\n            The number of columns to be occupied by this widget. Default is 1.\n        **kwargs : dict\n            Keyword arguments to pass to the new `Grid`.\n        \"\"\"\n        from .grid import Grid\n        grid = Grid(**kwargs)\n        return self.add_widget(grid, row, col, row_span, col_span)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates a new ViewBox and add it as a child widget.", "response": "def add_view(self, row=None, col=None, row_span=1, col_span=1,\n                 **kwargs):\n        \"\"\"\n        Create a new ViewBox and add it as a child widget.\n\n        Parameters\n        ----------\n        row : int\n            The row in which to add the widget (0 is the topmost row)\n        col : int\n            The column in which to add the widget (0 is the leftmost column)\n        row_span : int\n            The number of rows to be occupied by this widget. Default is 1.\n        col_span : int\n            The number of columns to be occupied by this widget. Default is 1.\n        **kwargs : dict\n            Keyword arguments to pass to `ViewBox`.\n        \"\"\"\n        from .viewbox import ViewBox\n        view = ViewBox(**kwargs)\n        return self.add_widget(view, row, col, row_span, col_span)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef find_font(face, bold, italic):\n    bold = FC_WEIGHT_BOLD if bold else FC_WEIGHT_REGULAR\n    italic = FC_SLANT_ITALIC if italic else FC_SLANT_ROMAN\n    face = face.encode('utf8')\n    fontconfig.FcInit()\n    pattern = fontconfig.FcPatternCreate()\n    fontconfig.FcPatternAddInteger(pattern, FC_WEIGHT, bold)\n    fontconfig.FcPatternAddInteger(pattern, FC_SLANT, italic)\n    fontconfig.FcPatternAddString(pattern, FC_FAMILY, face)\n    fontconfig.FcConfigSubstitute(0, pattern, FcMatchPattern)\n    fontconfig.FcDefaultSubstitute(pattern)\n    result = FcType()\n    match = fontconfig.FcFontMatch(0, pattern, byref(result))\n    fontconfig.FcPatternDestroy(pattern)\n    if not match:\n        raise RuntimeError('Could not match font \"%s\"' % face)\n    value = FcValue()\n    fontconfig.FcPatternGet(match, FC_FAMILY, 0, byref(value))\n    if(value.u.s != face):\n        warnings.warn('Could not find face match \"%s\", falling back to \"%s\"'\n                      % (face, value.u.s))\n    result = fontconfig.FcPatternGet(match, FC_FILE, 0, byref(value))\n    if result != 0:\n        raise RuntimeError('No filename or FT face for \"%s\"' % face)\n    fname = value.u.s\n    return fname.decode('utf-8')", "response": "Find font in the current language"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef set_log_level(verbose, match=None, return_old=False):\n    # This method is responsible for setting properties of the handler and\n    # formatter such that proper messages (possibly with the vispy caller\n    # prepended) are displayed. Storing log messages is only available\n    # via the context handler (use_log_level), so that configuration is\n    # done by the context handler itself.\n    if isinstance(verbose, bool):\n        verbose = 'info' if verbose else 'warning'\n    if isinstance(verbose, string_types):\n        verbose = verbose.lower()\n        if verbose not in logging_types:\n            raise ValueError('Invalid argument \"%s\"' % verbose)\n        verbose = logging_types[verbose]\n    else:\n        raise TypeError('verbose must be a bool or string')\n    logger = logging.getLogger('vispy')\n    old_verbose = logger.level\n    old_match = _lh._vispy_set_match(match)\n    logger.setLevel(verbose)\n    if verbose <= logging.DEBUG:\n        _lf._vispy_set_prepend(True)\n    else:\n        _lf._vispy_set_prepend(False)\n    out = None\n    if return_old:\n        out = (old_verbose, old_match)\n    return out", "response": "Convenience function for setting the logging level of the given log objects."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsends an exception and traceback to the logger. This function is used in cases where an exception is handled safely but nevertheless should generate a descriptive error message. An extra line is inserted into the stack trace indicating where the exception was caught. Parameters ---------- level : str See ``set_log_level`` for options. tb_skip : int The number of traceback entries to ignore, prior to the point where the exception was caught. The default is 2.", "response": "def log_exception(level='warning', tb_skip=2):\n    \"\"\"\n    Send an exception and traceback to the logger.\n    \n    This function is used in cases where an exception is handled safely but\n    nevertheless should generate a descriptive error message. An extra line\n    is inserted into the stack trace indicating where the exception was caught.\n    \n    Parameters\n    ----------\n    level : str\n        See ``set_log_level`` for options.\n    tb_skip : int\n        The number of traceback entries to ignore, prior to the point where\n        the exception was caught. The default is 2.\n    \"\"\"\n    stack = \"\".join(traceback.format_stack()[:-tb_skip])\n    tb = traceback.format_exception(*sys.exc_info())\n    msg = tb[0]  # \"Traceback (most recent call last):\"\n    msg += stack\n    msg += \"  << caught exception here: >>\\n\"\n    msg += \"\".join(tb[1:]).rstrip()\n    logger.log(logging_types[level], msg)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nhandles exceptions in the exception namespace.", "response": "def _handle_exception(ignore_callback_errors, print_callback_errors, obj,\n                      cb_event=None, node=None):\n    \"\"\"Helper for prining errors in callbacks\n\n    See EventEmitter._invoke_callback for a use example.\n    \"\"\"\n    if not hasattr(obj, '_vispy_err_registry'):\n        obj._vispy_err_registry = {}\n    registry = obj._vispy_err_registry\n\n    if cb_event is not None:\n        cb, event = cb_event\n        exp_type = 'callback'\n    else:\n        exp_type = 'node'\n    type_, value, tb = sys.exc_info()\n    tb = tb.tb_next  # Skip *this* frame\n    sys.last_type = type_\n    sys.last_value = value\n    sys.last_traceback = tb\n    del tb  # Get rid of it in this namespace\n    # Handle\n    if not ignore_callback_errors:\n        raise\n    if print_callback_errors != \"never\":\n        this_print = 'full'\n        if print_callback_errors in ('first', 'reminders'):\n            # need to check to see if we've hit this yet\n            if exp_type == 'callback':\n                key = repr(cb) + repr(event)\n            else:\n                key = repr(node)\n            if key in registry:\n                registry[key] += 1\n                if print_callback_errors == 'first':\n                    this_print = None\n                else:  # reminders\n                    ii = registry[key]\n                    # Use logarithmic selection\n                    # (1, 2, ..., 10, 20, ..., 100, 200, ...)\n                    if ii == (2 ** int(np.log2(ii))):\n                        this_print = ii\n                    else:\n                        this_print = None\n            else:\n                registry[key] = 1\n        if this_print == 'full':\n            logger.log_exception()\n            if exp_type == 'callback':\n                logger.error(\"Invoking %s for %s\" % (cb, event))\n            else:  # == 'node':\n                logger.error(\"Drawing node %s\" % node)\n        elif this_print is not None:\n            if exp_type == 'callback':\n                logger.error(\"Invoking %s repeat %s\"\n                             % (cb, this_print))\n            else:  # == 'node':\n                logger.error(\"Drawing node %s repeat %s\"\n                             % (node, this_print))"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nserializes a NumPy array.", "response": "def _serialize_buffer(buffer, array_serialization=None):\n    \"\"\"Serialize a NumPy array.\"\"\"\n    if array_serialization == 'binary':\n        # WARNING: in NumPy 1.9, tostring() has been renamed to tobytes()\n        # but tostring() is still here for now for backward compatibility.\n        return buffer.ravel().tostring()\n    elif array_serialization == 'base64':\n        return {'storage_type': 'base64',\n                'buffer': base64.b64encode(buffer).decode('ascii')\n                }\n    raise ValueError(\"The array serialization method should be 'binary' or \"\n                     \"'base64'.\")"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nlog message emitter that optionally matches and or records", "response": "def _vispy_emit_match_andor_record(self, record):\n        \"\"\"Log message emitter that optionally matches and/or records\"\"\"\n        test = record.getMessage()\n        match = self._vispy_match\n        if (match is None or re.search(match, test) or\n                re.search(match, _get_vispy_caller())):\n            if self._vispy_emit_record:\n                fmt_rec = self._vispy_formatter.format(record)\n                self._vispy_emit_list.append(fmt_rec)\n            if self._vispy_print_msg:\n                return logging.StreamHandler.emit(self, record)\n            else:\n                return"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef create(self, obj, ref=None):\n        if isinstance(ref, Variable):\n            ref = ref.name\n        elif isinstance(ref, string_types) and ref.startswith('gl_'):\n            # gl_ names not allowed for variables\n            ref = ref[3:].lower()\n        \n        # Allow any type of object to be converted to ShaderObject if it\n        # provides a magic method:\n        if hasattr(obj, '_shader_object'):\n            obj = obj._shader_object()\n        \n        if isinstance(obj, ShaderObject):\n            if isinstance(obj, Variable) and obj.name is None:\n                obj.name = ref\n        elif isinstance(obj, string_types):\n            obj = TextExpression(obj)\n        else:\n            obj = Variable(ref, obj)\n            # Try prepending the name to indicate attribute, uniform, varying\n            if obj.vtype and obj.vtype[0] in 'auv':\n                obj.name = obj.vtype[0] + '_' + obj.name \n        \n        return obj", "response": "Convert obj to a new ShaderObject."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef dependencies(self, sort=False):\n        alldeps = []\n        if sort:\n            def key(obj):\n                # sort deps such that we get functions, variables, self.\n                if not isinstance(obj, Variable):\n                    return (0, 0)\n                else:\n                    return (1, obj.vtype)\n            \n            deps = sorted(self._deps, key=key)\n        else:\n            deps = self._deps\n        \n        for dep in deps:\n            alldeps.extend(dep.dependencies(sort=sort))\n        alldeps.append(self)\n        return alldeps", "response": "Return all dependencies required to use this object."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _add_dep(self, dep):\n        if dep in self._deps:\n            self._deps[dep] += 1\n        else:\n            self._deps[dep] = 1\n            dep._dependents[self] = None", "response": "Add a dependency to this object."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _remove_dep(self, dep):\n        refcount = self._deps[dep]\n        if refcount == 1:\n            self._deps.pop(dep)\n            dep._dependents.pop(self)\n        else:\n            self._deps[dep] -= 1", "response": "Decrement the reference count for the dependency and remove it from the list of dependents."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _dep_changed(self, dep, code_changed=False, value_changed=False):\n        self.changed(code_changed, value_changed)", "response": "Called when a dependency s expression has changed."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ninform dependents that this shaderobject has changed.", "response": "def changed(self, code_changed=False, value_changed=False):\n        \"\"\"Inform dependents that this shaderobject has changed.\n        \"\"\"\n        for d in self._dependents:\n            d._dep_changed(self, code_changed=code_changed,\n                           value_changed=value_changed)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef eq(a, b):\n    if a is b:\n        return True\n    if a is None or b is None:\n        return True if a is None and b is None else False\n\n    try:\n        e = a == b\n    except ValueError:\n        return False\n    except AttributeError:\n        return False\n    except Exception:\n        print(\"a:\", str(type(a)), str(a))\n        print(\"b:\", str(type(b)), str(b))\n        raise\n    t = type(e)\n    if t is bool:\n        return e\n    elif t is bool_:\n        return bool(e)\n    elif isinstance(e, ndarray):\n        try:\n            # disaster: if a is empty and b is not, then e.all() is True\n            if a.shape != b.shape:\n                return False\n        except Exception:\n            return False\n        if (hasattr(e, 'implements') and e.implements('MetaArray')):\n            return e.asarray().all()\n        else:\n            return e.all()\n    else:\n        raise Exception(\"== operator returned type %s\" % str(type(e)))", "response": "Guaranteed equality function for the two objects a and b."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef zoom(self, factor, center=None):\n        assert len(center) in (2, 3, 4)\n        # Get scale factor, take scale ratio into account\n        if np.isscalar(factor):\n            scale = [factor, factor]\n        else:\n            if len(factor) != 2:\n                raise TypeError(\"factor must be scalar or length-2 sequence.\")\n            scale = list(factor)\n        if self.aspect is not None:\n            scale[0] = scale[1]\n\n        # Init some variables\n        center = center if (center is not None) else self.center\n        # Make a new object (copy), so that allocation will\n        # trigger view_changed:\n        rect = Rect(self.rect)\n        # Get space from given center to edges\n        left_space = center[0] - rect.left\n        right_space = rect.right - center[0]\n        bottom_space = center[1] - rect.bottom\n        top_space = rect.top - center[1]\n        # Scale these spaces\n        rect.left = center[0] - left_space * scale[0]\n        rect.right = center[0] + right_space * scale[0]\n        rect.bottom = center[1] - bottom_space * scale[1]\n        rect.top = center[1] + top_space * scale[1]\n        self.rect = rect", "response": "Zooms the current state of the object at the given center."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef pan(self, *pan):\n        if len(pan) == 1:\n            pan = pan[0]\n        self.rect = self.rect + pan", "response": "Pan the view.\n\n        Parameters\n        ----------\n        *pan : length-2 sequence\n            The distance to pan the view, in the coordinate system of the\n            scene."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nhandle a mouse event and updates the transform accordingly.", "response": "def viewbox_mouse_event(self, event):\n        \"\"\"\n        The SubScene received a mouse event; update transform\n        accordingly.\n\n        Parameters\n        ----------\n        event : instance of Event\n            The event.\n        \"\"\"\n        if event.handled or not self.interactive:\n            return\n\n        # Scrolling\n        BaseCamera.viewbox_mouse_event(self, event)\n\n        if event.type == 'mouse_wheel':\n            center = self._scene_transform.imap(event.pos)\n            self.zoom((1 + self.zoom_factor) ** (-event.delta[1] * 30), center)\n            event.handled = True\n\n        elif event.type == 'mouse_move':\n            if event.press_event is None:\n                return\n\n            modifiers = event.mouse_event.modifiers\n            p1 = event.mouse_event.press_event.pos\n            p2 = event.mouse_event.pos\n\n            if 1 in event.buttons and not modifiers:\n                # Translate\n                p1 = np.array(event.last_event.pos)[:2]\n                p2 = np.array(event.pos)[:2]\n                p1s = self._transform.imap(p1)\n                p2s = self._transform.imap(p2)\n                self.pan(p1s-p2s)\n                event.handled = True\n            elif 2 in event.buttons and not modifiers:\n                # Zoom\n                p1c = np.array(event.last_event.pos)[:2]\n                p2c = np.array(event.pos)[:2]\n                scale = ((1 + self.zoom_factor) **\n                         ((p1c-p2c) * np.array([1, -1])))\n                center = self._transform.imap(event.press_event.pos[:2])\n                self.zoom(scale, center)\n                event.handled = True\n            else:\n                event.handled = False\n        elif event.type == 'mouse_press':\n            # accept the event if it is button 1 or 2.\n            # This is required in order to receive future events\n            event.handled = event.button in [1, 2]\n        else:\n            event.handled = False"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nset the data for the current object.", "response": "def set_data(self, vol, clim=None):\n        \"\"\" Set the volume data. \n\n        Parameters\n        ----------\n        vol : ndarray\n            The 3D volume.\n        clim : tuple | None\n            Colormap limits to use. None will use the min and max values.\n        \"\"\"\n        # Check volume\n        if not isinstance(vol, np.ndarray):\n            raise ValueError('Volume visual needs a numpy array.')\n        if not ((vol.ndim == 3) or (vol.ndim == 4 and vol.shape[-1] <= 4)):\n            raise ValueError('Volume visual needs a 3D image.')\n        \n        # Handle clim\n        if clim is not None:\n            clim = np.array(clim, float)\n            if not (clim.ndim == 1 and clim.size == 2):\n                raise ValueError('clim must be a 2-element array-like')\n            self._clim = tuple(clim)\n        if self._clim is None:\n            self._clim = vol.min(), vol.max()\n        \n        # Apply clim\n        vol = np.array(vol, dtype='float32', copy=False)\n        if self._clim[1] == self._clim[0]:\n            if self._clim[0] != 0.:\n                vol *= 1.0 / self._clim[0]\n        else:\n            vol -= self._clim[0]\n            vol /= self._clim[1] - self._clim[0]\n        \n        # Apply to texture\n        self._tex.set_data(vol)  # will be efficient if vol is same shape\n        self.shared_program['u_shape'] = (vol.shape[2], vol.shape[1], \n                                          vol.shape[0])\n        \n        shape = vol.shape[:3]\n        if self._vol_shape != shape:\n            self._vol_shape = shape\n            self._need_vertex_update = True\n        self._vol_shape = shape\n        \n        # Get some stats\n        self._kb_for_texture = np.prod(self._vol_shape) / 1024"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates and set the vertex data for the current entry in the internal buffer.", "response": "def _create_vertex_data(self):\n        \"\"\" Create and set positions and texture coords from the given shape\n        \n        We have six faces with 1 quad (2 triangles) each, resulting in\n        6*2*3 = 36 vertices in total.\n        \"\"\"\n        shape = self._vol_shape\n        \n        # Get corner coordinates. The -0.5 offset is to center\n        # pixels/voxels. This works correctly for anisotropic data.\n        x0, x1 = -0.5, shape[2] - 0.5\n        y0, y1 = -0.5, shape[1] - 0.5\n        z0, z1 = -0.5, shape[0] - 0.5\n\n        pos = np.array([\n            [x0, y0, z0],\n            [x1, y0, z0],\n            [x0, y1, z0],\n            [x1, y1, z0],\n            [x0, y0, z1],\n            [x1, y0, z1],\n            [x0, y1, z1],\n            [x1, y1, z1],\n        ], dtype=np.float32)\n        \n        \"\"\"\n          6-------7\n         /|      /|\n        4-------5 |\n        | |     | |\n        | 2-----|-3\n        |/      |/\n        0-------1\n        \"\"\"\n        \n        # Order is chosen such that normals face outward; front faces will be\n        # culled.\n        indices = np.array([2, 6, 0, 4, 5, 6, 7, 2, 3, 0, 1, 5, 3, 7],\n                           dtype=np.uint32)\n        \n        # Apply\n        self._vertices.set_data(pos)\n        self._index_buffer.set_data(indices)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset the data for the current object.", "response": "def set_data(self, pos=None, color=None):\n        \"\"\"Set the data\n\n        Parameters\n        ----------\n        pos : list, tuple or numpy array\n            Bounds of the region along the axis. len(pos) must be >=2.\n        color : list, tuple, or array\n            The color to use when drawing the line. It must have a shape of\n            (1, 4) for a single color region or (len(pos), 4) for a multicolor\n            region.\n        \"\"\"\n        new_pos = self._pos\n        new_color = self._color\n\n        if pos is not None:\n            num_elements = len(pos)\n            pos = np.array(pos, dtype=np.float32)\n            if pos.ndim != 1:\n                raise ValueError('Expected 1D array')\n            vertex = np.empty((num_elements * 2, 2), dtype=np.float32)\n            if self._is_vertical:\n                vertex[:, 0] = np.repeat(pos, 2)\n                vertex[:, 1] = np.tile([-1, 1], num_elements)\n            else:\n                vertex[:, 1] = np.repeat(pos, 2)\n                vertex[:, 0] = np.tile([1, -1], num_elements)\n            new_pos = vertex\n            self._changed['pos'] = True\n\n        if color is not None:\n            color = np.array(color, dtype=np.float32)\n            num_elements = new_pos.shape[0] / 2\n            if color.ndim == 2:\n                if color.shape[0] != num_elements:\n                    raise ValueError('Expected a color for each pos')\n                if color.shape[1] != 4:\n                    raise ValueError('Each color must be a RGBA array')\n                color = np.repeat(color, 2, axis=0).astype(np.float32)\n            elif color.ndim == 1:\n                if color.shape[0] != 4:\n                    raise ValueError('Each color must be a RGBA array')\n                color = np.repeat([color], new_pos.shape[0], axis=0)\n                color = color.astype(np.float32)\n            else:\n                raise ValueError('Expected a numpy array of shape '\n                                 '(%d, 4) or (1, 4)' % num_elements)\n            new_color = color\n            self._changed['color'] = True\n\n        # Ensure pos and color have the same size\n        if new_pos.shape[0] != new_color.shape[0]:\n            raise ValueError('pos and color does must have the same size')\n\n        self._color = new_color\n        self._pos = new_pos"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nmerge overlapping intervals. This method is called only once in the constructor.", "response": "def _merge_intervals(self, min_depth):\n        \"\"\"\n        Merge overlapping intervals.\n\n        This method is called only once in the constructor.\n        \"\"\"\n        def add_interval(ret, start, stop):\n            if min_depth is not None:\n                shift = 2 * (29 - min_depth)\n                mask = (int(1) << shift) - 1\n\n                if stop - start < mask:\n                    ret.append((start, stop))\n                else:\n                    ofs = start & mask\n                    st = start\n                    if ofs > 0:\n                        st = (start - ofs) + (mask + 1)\n                        ret.append((start, st))\n\n                    while st + mask + 1 < stop:\n                        ret.append((st, st + mask + 1))\n                        st = st + mask + 1\n\n                    ret.append((st, stop))\n            else:\n                ret.append((start, stop))\n\n        ret = []\n        start = stop = None\n        # Use numpy sort method\n        self._intervals.sort(axis=0)\n        for itv in self._intervals:\n            if start is None:\n                start, stop = itv\n                continue\n\n            # gap between intervals\n            if itv[0] > stop:\n                add_interval(ret, start, stop)\n                start, stop = itv\n            else:\n                # merge intervals\n                if itv[1] > stop:\n                    stop = itv[1]\n\n        if start is not None and stop is not None:\n            add_interval(ret, start, stop)\n\n        self._intervals = np.asarray(ret)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef union(self, another_is):\n        result = IntervalSet()\n        if another_is.empty():\n            result._intervals = self._intervals\n        elif self.empty():\n            result._intervals = another_is._intervals\n        else:\n            # res has no overlapping intervals\n            result._intervals = IntervalSet.merge(self._intervals,\n                                                  another_is._intervals,\n                                                  lambda in_a, in_b: in_a or in_b)\n        return result", "response": "Return the union between self and another_is."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nconverting an IntervalSet using the NESTED numbering scheme to an IntervalSet containing UNIQ numbers for HEALPix cells.", "response": "def to_nuniq_interval_set(cls, nested_is):\n        \"\"\"\n        Convert an IntervalSet using the NESTED numbering scheme to an IntervalSet containing UNIQ numbers for HEALPix\n        cells.\n\n        Parameters\n        ----------\n        nested_is : `IntervalSet`\n            IntervalSet object storing HEALPix cells as [ipix*4^(29-order), (ipix+1)*4^(29-order)[ intervals.\n\n        Returns\n        -------\n        interval : `IntervalSet`\n            IntervalSet object storing HEALPix cells as [ipix + 4*4^(order), ipix+1 + 4*4^(order)[ intervals.\n        \"\"\"\n        r2 = nested_is.copy()\n        res = []\n\n        if r2.empty():\n            return IntervalSet()\n\n        order = 0\n        while not r2.empty():\n            shift = int(2 * (IntervalSet.HPY_MAX_ORDER - order))\n            ofs = (int(1) << shift) - 1\n            ofs2 = int(1) << (2 * order + 2)\n\n            r4 = []\n            for iv in r2._intervals:\n                a = (int(iv[0]) + ofs) >> shift\n                b = int(iv[1]) >> shift\n\n                c = a << shift\n                d = b << shift\n                if d > c:\n                    r4.append((c, d))\n                    res.append((a + ofs2, b + ofs2))\n\n            if len(r4) > 0:\n                r4_is = IntervalSet(np.asarray(r4))\n                r2 = r2.difference(r4_is)\n\n            order += 1\n\n        return IntervalSet(np.asarray(res))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef from_nuniq_interval_set(cls, nuniq_is):\n        nested_is = IntervalSet()\n        # Appending a list is faster than appending a numpy array\n        # For these algorithms we append a list and create the interval set from the finished list\n        rtmp = []\n        last_order = 0\n        intervals = nuniq_is._intervals\n        diff_order = IntervalSet.HPY_MAX_ORDER\n        shift_order = 2 * diff_order\n        for interval in intervals:\n            for j in range(interval[0], interval[1]):\n                order, i_pix = uniq2orderipix(j)\n\n                if order != last_order:\n                    nested_is = nested_is.union(IntervalSet(np.asarray(rtmp)))\n                    rtmp = []\n                    last_order = order\n                    diff_order = IntervalSet.HPY_MAX_ORDER - order\n                    shift_order = 2 * diff_order\n\n                rtmp.append((i_pix << shift_order, (i_pix + 1) << shift_order))\n\n        nested_is = nested_is.union(IntervalSet(np.asarray(rtmp)))\n        return nested_is", "response": "Convert an IntervalSet containing NUNIQ intervals to an IntervalSet representing HEALPix entries representing HEALPix cells following the NESTED numbering scheme."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nmerges two lists of intervals according to the boolean function op and return the result of the operation op between the two lists of intervals a_intervals and b_intervals.", "response": "def merge(a_intervals, b_intervals, op):\n        \"\"\"\n        Merge two lists of intervals according to the boolean function op\n\n        ``a_intervals`` and ``b_intervals`` need to be sorted and consistent (no overlapping intervals).\n        This operation keeps the resulting interval set consistent.\n\n        Parameters\n        ----------\n        a_intervals : `~numpy.ndarray`\n            A sorted merged list of intervals represented as a N x 2 numpy array\n        b_intervals : `~numpy.ndarray`\n            A sorted merged list of intervals represented as a N x 2 numpy array\n        op : `function`\n            Lambda function taking two params and returning the result of the operation between\n            these two params.\n            Exemple : lambda in_a, in_b: in_a and in_b describes the intersection of ``a_intervals`` and\n            ``b_intervals`` whereas lambda in_a, in_b: in_a or in_b describes the union of ``a_intervals`` and\n            ``b_intervals``.\n\n        Returns\n        -------\n        array : `numpy.ndarray`\n            a N x 2 numpy containing intervals resulting from the op between ``a_intervals`` and ``b_intervals``.\n        \"\"\"\n        a_endpoints = a_intervals.flatten().tolist()\n        b_endpoints = b_intervals.flatten().tolist()\n\n        sentinel = max(a_endpoints[-1], b_endpoints[-1]) + 1\n\n        a_endpoints += [sentinel]\n        b_endpoints += [sentinel]\n\n        a_index = 0\n        b_index = 0\n\n        res = []\n\n        scan = min(a_endpoints[0], b_endpoints[0])\n        while scan < sentinel:\n            in_a = not ((scan < a_endpoints[a_index]) ^ (a_index % 2))\n            in_b = not ((scan < b_endpoints[b_index]) ^ (b_index % 2))\n            in_res = op(in_a, in_b)\n\n            if in_res ^ (len(res) % 2):\n                res += [scan]\n            if scan == a_endpoints[a_index]:\n                a_index += 1\n            if scan == b_endpoints[b_index]:\n                b_index += 1\n\n            scan = min(a_endpoints[a_index], b_endpoints[b_index])\n\n        return np.asarray(res).reshape((-1, 2))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef delete(self):\n        # We only allow the object from being deleted once, otherwise\n        # we might be deleting another GPU object that got our gl-id\n        # after our GPU object was deleted. Also note that e.g.\n        # DataBufferView does not have the _glir attribute.\n        if hasattr(self, '_glir'):\n            # Send our final command into the queue\n            self._glir.command('DELETE', self._id)\n            # Tell master glir queue that this queue is no longer being used\n            self._glir._deletable = True\n            # Detach the queue\n            del self._glir", "response": "Delete the object from the GPU memory."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsets the data of the object.", "response": "def set_data(self, image):\n        \"\"\"Set the data\n\n        Parameters\n        ----------\n        image : array-like\n            The image data.\n        \"\"\"\n        data = np.asarray(image)\n        if self._data is None or self._data.shape != data.shape:\n            self._need_vertex_update = True\n        self._data = data\n        self._need_texture_upload = True"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nrebuild the _data_lookup_fn using different interpolations within the shader", "response": "def _build_interpolation(self):\n        \"\"\"Rebuild the _data_lookup_fn using different interpolations within\n        the shader\n        \"\"\"\n        interpolation = self._interpolation\n        self._data_lookup_fn = self._interpolation_fun[interpolation]\n        self.shared_program.frag['get_data'] = self._data_lookup_fn\n\n        # only 'bilinear' uses 'linear' texture interpolation\n        if interpolation == 'bilinear':\n            texture_interpolation = 'linear'\n        else:\n            # 'nearest' (and also 'bilinear') doesn't use spatial_filters.frag\n            # so u_kernel and shape setting is skipped\n            texture_interpolation = 'nearest'\n            if interpolation != 'nearest':\n                self.shared_program['u_kernel'] = self._kerneltex\n                self._data_lookup_fn['shape'] = self._data.shape[:2][::-1]\n\n        if self._texture.interpolation != texture_interpolation:\n            self._texture.interpolation = texture_interpolation\n\n        self._data_lookup_fn['texture'] = self._texture\n\n        self._need_interpolation_update = False"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nrebuilds the vertex buffers used for rendering the image when using the subdivide method.", "response": "def _build_vertex_data(self):\n        \"\"\"Rebuild the vertex buffers used for rendering the image when using\n        the subdivide method.\n        \"\"\"\n        grid = self._grid\n        w = 1.0 / grid[1]\n        h = 1.0 / grid[0]\n\n        quad = np.array([[0, 0, 0], [w, 0, 0], [w, h, 0],\n                         [0, 0, 0], [w, h, 0], [0, h, 0]],\n                        dtype=np.float32)\n        quads = np.empty((grid[1], grid[0], 6, 3), dtype=np.float32)\n        quads[:] = quad\n\n        mgrid = np.mgrid[0.:grid[1], 0.:grid[0]].transpose(1, 2, 0)\n        mgrid = mgrid[:, :, np.newaxis, :]\n        mgrid[..., 0] *= w\n        mgrid[..., 1] *= h\n\n        quads[..., :2] += mgrid\n        tex_coords = quads.reshape(grid[1]*grid[0]*6, 3)\n        tex_coords = np.ascontiguousarray(tex_coords[:, :2])\n        vertices = tex_coords * self.size\n\n        self._subdiv_position.set_data(vertices.astype('float32'))\n        self._subdiv_texcoord.set_data(tex_coords.astype('float32'))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nupdate the method used for view.", "response": "def _update_method(self, view):\n        \"\"\"Decide which method to use for *view* and configure it accordingly.\n        \"\"\"\n        method = self._method\n        if method == 'auto':\n            if view.transforms.get_transform().Linear:\n                method = 'subdivide'\n            else:\n                method = 'impostor'\n        view._method_used = method\n\n        if method == 'subdivide':\n            view.view_program['method'] = 0\n            view.view_program['a_position'] = self._subdiv_position\n            view.view_program['a_texcoord'] = self._subdiv_texcoord\n        elif method == 'impostor':\n            view.view_program['method'] = 1\n            view.view_program['a_position'] = self._impostor_coords\n            view.view_program['a_texcoord'] = self._impostor_coords\n        else:\n            raise ValueError(\"Unknown image draw method '%s'\" % method)\n\n        self.shared_program['image_size'] = self.size\n        view._need_method_update = False\n        self._prepare_transforms(view)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef append(self, P, closed=False, itemsize=None, **kwargs):\n\n        itemsize = itemsize or len(P)\n        itemcount = len(P) / itemsize\n\n        P = P.reshape(itemcount, itemsize, 3)\n        if closed:\n            V = np.empty((itemcount, itemsize + 3), dtype=self.vtype)\n            # Apply default values on vertices\n            for name in self.vtype.names:\n                if name not in ['collection_index', 'prev', 'curr', 'next']:\n                    V[name][1:-2] = kwargs.get(name, self._defaults[name])\n            V['prev'][:, 2:-1] = P\n            V['prev'][:, 1] = V['prev'][:, -2]\n            V['curr'][:, 1:-2] = P\n            V['curr'][:, -2] = V['curr'][:, 1]\n            V['next'][:, 0:-3] = P\n            V['next'][:, -3] = V['next'][:, 0]\n            V['next'][:, -2] = V['next'][:, 1]\n        else:\n            V = np.empty((itemcount, itemsize + 2), dtype=self.vtype)\n            # Apply default values on vertices\n            for name in self.vtype.names:\n                if name not in ['collection_index', 'prev', 'curr', 'next']:\n                    V[name][1:-1] = kwargs.get(name, self._defaults[name])\n            V['prev'][:, 2:] = P\n            V['prev'][:, 1] = V['prev'][:, 2]\n            V['curr'][:, 1:-1] = P\n            V['next'][:, :-2] = P\n            V['next'][:, -2] = V['next'][:, -3]\n\n        V[:, 0] = V[:, 1]\n        V[:, -1] = V[:, -2]\n        V = V.ravel()\n        V = np.repeat(V, 2, axis=0)\n        V['id'] = np.tile([1, -1], len(V) / 2)\n        if closed:\n            V = V.reshape(itemcount, 2 * (itemsize + 3))\n        else:\n            V = V.reshape(itemcount, 2 * (itemsize + 2))\n        V[\"id\"][:, :2] = 2, -2\n        V[\"id\"][:, -2:] = 2, -2\n        V = V.ravel()\n\n        # Uniforms\n        if self.utype:\n            U = np.zeros(itemcount, dtype=self.utype)\n            for name in self.utype.names:\n                if name not in [\"__unused__\"]:\n                    U[name] = kwargs.get(name, self._defaults[name])\n        else:\n            U = None\n\n        Collection.append(self, vertices=V, uniforms=U,\n                          itemsize=2 * (itemsize + 2 + closed))", "response": "Append a new set of vertices to the collection."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngiving a path P return the baked vertices as they should be copied in", "response": "def bake(self, P, key='curr', closed=False, itemsize=None):\n        \"\"\"\n        Given a path P, return the baked vertices as they should be copied in\n        the collection if the path has already been appended.\n\n        Example:\n        --------\n\n        paths.append(P)\n        P *= 2\n        paths['prev'][0] = bake(P,'prev')\n        paths['curr'][0] = bake(P,'curr')\n        paths['next'][0] = bake(P,'next')\n        \"\"\"\n\n        itemsize = itemsize or len(P)\n        itemcount = len(P) / itemsize  # noqa\n        n = itemsize\n\n        if closed:\n            I = np.arange(n + 3)\n            if key == 'prev':\n                I -= 2\n                I[0], I[1], I[-1] = n - 1, n - 1, n - 1\n            elif key == 'next':\n                I[0], I[-3], I[-2], I[-1] = 1, 0, 1, 1\n            else:\n                I -= 1\n                I[0], I[-1], I[n + 1] = 0, 0, 0\n        else:\n            I = np.arange(n + 2)\n            if key == 'prev':\n                I -= 2\n                I[0], I[1], I[-1] = 0, 0, n - 2\n            elif key == 'next':\n                I[0], I[-1], I[-2] = 1, n - 1, n - 1\n            else:\n                I -= 1\n                I[0], I[-1] = 0, n - 1\n        I = np.repeat(I, 2)\n        return P[I]"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ndraws the current context.", "response": "def draw(self, mode=\"triangle_strip\"):\n        \"\"\" Draw collection \"\"\"\n\n        gl.glDepthMask(gl.GL_FALSE)\n        Collection.draw(self, mode)\n        gl.glDepthMask(gl.GL_TRUE)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _stop_timers(canvas):\n    for attr in dir(canvas):\n        try:\n            attr_obj = getattr(canvas, attr)\n        except NotImplementedError:\n            # This try/except is needed because canvas.position raises\n            # an error (it is not implemented in this backend).\n            attr_obj = None\n        if isinstance(attr_obj, Timer):\n            attr_obj.stop()", "response": "Stop all timers in a canvas."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nprints stack trace from last call that didn t originate from here", "response": "def _last_stack_str():\n    \"\"\"Print stack trace from call that didn't originate from here\"\"\"\n    stack = extract_stack()\n    for s in stack[::-1]:\n        if op.join('vispy', 'gloo', 'buffer.py') not in __file__:\n            break\n    return format_list([s])[0]"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef set_subdata(self, data, offset=0, copy=False):\n        data = np.array(data, copy=copy)\n        nbytes = data.nbytes\n\n        if offset < 0:\n            raise ValueError(\"Offset must be positive\")\n        elif (offset + nbytes) > self._nbytes:\n            raise ValueError(\"Data does not fit into buffer\")\n\n        # If the whole buffer is to be written, we clear any pending data\n        # (because they will be overwritten anyway)\n        if nbytes == self._nbytes and offset == 0:\n            self._glir.command('SIZE', self._id, nbytes)\n        self._glir.command('DATA', self._id, offset, data)", "response": "Set a sub - region of the buffer."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set_data(self, data, copy=False):\n        data = np.array(data, copy=copy)\n        nbytes = data.nbytes\n\n        if nbytes != self._nbytes:\n            self.resize_bytes(nbytes)\n        else:\n            # Use SIZE to discard any previous data setting\n            self._glir.command('SIZE', self._id, nbytes)\n        \n        if nbytes:  # Only set data if there *is* data\n            self._glir.command('DATA', self._id, 0, data)", "response": "Set the data in the buffer."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef resize_bytes(self, size):\n        self._nbytes = size\n        self._glir.command('SIZE', self._id, size)\n        # Invalidate any view on this buffer\n        for view in self._views:\n            if view() is not None:\n                view()._valid = False\n        self._views = []", "response": "Resize this buffer to a new size in bytes."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set_subdata(self, data, offset=0, copy=False, **kwargs):\n        data = self._prepare_data(data, **kwargs)\n        offset = offset * self.itemsize\n        Buffer.set_subdata(self, data=data, offset=offset, copy=copy)", "response": "Set a sub - region of the buffer."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef set_data(self, data, copy=False, **kwargs):\n        data = self._prepare_data(data, **kwargs)\n        self._dtype = data.dtype\n        self._stride = data.strides[-1]\n        self._itemsize = self._dtype.itemsize\n        Buffer.set_data(self, data=data, copy=copy)", "response": "Set data for the current object."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef glsl_type(self):\n        if self.dtype is None:\n            return None\n        dtshape = self.dtype[0].shape\n        n = dtshape[0] if dtshape else 1\n        if n > 1:\n            dtype = 'vec%d' % n\n        else:\n            dtype = 'float' if 'f' in self.dtype[0].base.kind else 'int'\n        return 'attribute', dtype", "response": "GLSL declaration string required for a variable to hold this data."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncompiling all code and return a dict where the keys are determined by the keyword arguments passed to __init__.", "response": "def compile(self, pretty=True):\n        \"\"\" Compile all code and return a dict {name: code} where the keys\n        are determined by the keyword arguments passed to __init__().\n\n        Parameters\n        ----------\n        pretty : bool\n            If True, use a slower method to mangle object names. This produces\n            GLSL that is more readable.\n            If False, then the output is mostly unreadable GLSL, but is about\n            10x faster to compile.\n\n        \"\"\"\n        # Authoritative mapping of {obj: name}\n        self._object_names = {}\n\n        #\n        # 1. collect list of dependencies for each shader\n        #\n\n        # maps {shader_name: [deps]}\n        self._shader_deps = {}\n\n        for shader_name, shader in self.shaders.items():\n            this_shader_deps = []\n            self._shader_deps[shader_name] = this_shader_deps\n            dep_set = set()\n\n            for dep in shader.dependencies(sort=True):\n                # visit each object no more than once per shader\n                if dep.name is None or dep in dep_set:\n                    continue\n                this_shader_deps.append(dep)\n                dep_set.add(dep)\n\n        #\n        # 2. Assign names to all objects.\n        #\n        if pretty:\n            self._rename_objects_pretty()\n        else:\n            self._rename_objects_fast()\n\n        #\n        # 3. Now we have a complete namespace; concatenate all definitions\n        # together in topological order.\n        #\n        compiled = {}\n        obj_names = self._object_names\n\n        for shader_name, shader in self.shaders.items():\n            code = []\n            for dep in self._shader_deps[shader_name]:\n                dep_code = dep.definition(obj_names)\n                if dep_code is not None:\n                    # strip out version pragma if present;\n                    regex = r'#version (\\d+)'\n                    m = re.search(regex, dep_code)\n                    if m is not None:\n                        # check requested version\n                        if m.group(1) != '120':\n                            raise RuntimeError(\"Currently only GLSL #version \"\n                                               \"120 is supported.\")\n                        dep_code = re.sub(regex, '', dep_code)\n                    code.append(dep_code)\n\n            compiled[shader_name] = '\\n'.join(code)\n\n        self.code = compiled\n        return compiled"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _rename_objects_fast(self):\n        for shader_name, deps in self._shader_deps.items():\n            for dep in deps:\n                name = dep.name\n                if name != 'main':\n                    ext = '_%x' % id(dep)\n                    name = name[:32-len(ext)] + ext\n                self._object_names[dep] = name", "response": "Rename all objects quickly to guaranteed - unique names using the\n        id"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nrenames all objects like name_1 to avoid conflicts. Objects are only renamed if necessary.", "response": "def _rename_objects_pretty(self):\n        \"\"\" Rename all objects like \"name_1\" to avoid conflicts. Objects are\n        only renamed if necessary.\n\n        This method produces more readable GLSL, but is rather slow.\n        \"\"\"\n        #\n        # 1. For each object, add its static names to the global namespace\n        #    and make a list of the shaders used by the object.\n        #\n\n        # {name: obj} mapping for finding unique names\n        # initialize with reserved keywords.\n        self._global_ns = dict([(kwd, None) for kwd in gloo.util.KEYWORDS])\n        # functions are local per-shader\n        self._shader_ns = dict([(shader, {}) for shader in self.shaders])\n\n        # for each object, keep a list of shaders the object appears in\n        obj_shaders = {}\n\n        for shader_name, deps in self._shader_deps.items():\n            for dep in deps:\n                # Add static names to namespace\n                for name in dep.static_names():\n                    self._global_ns[name] = None\n\n                obj_shaders.setdefault(dep, []).append(shader_name)\n\n        #\n        # 2. Assign new object names\n        #\n        name_index = {}\n        for obj, shaders in obj_shaders.items():\n            name = obj.name\n            if self._name_available(obj, name, shaders):\n                # hooray, we get to keep this name\n                self._assign_name(obj, name, shaders)\n            else:\n                # boo, find a new name\n                while True:\n                    index = name_index.get(name, 0) + 1\n                    name_index[name] = index\n                    ext = '_%d' % index\n                    new_name = name[:32-len(ext)] + ext\n                    if self._name_available(obj, new_name, shaders):\n                        self._assign_name(obj, new_name, shaders)\n                        break"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns True if name is available for obj in all shaders.", "response": "def _name_available(self, obj, name, shaders):\n        \"\"\" Return True if *name* is available for *obj* in *shaders*.\n        \"\"\"\n        if name in self._global_ns:\n            return False\n        shaders = self.shaders if self._is_global(obj) else shaders\n        for shader in shaders:\n            if name in self._shader_ns[shader]:\n                return False\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nassigning name to obj in all shaders.", "response": "def _assign_name(self, obj, name, shaders):\n        \"\"\" Assign *name* to *obj* in *shaders*.\n        \"\"\"\n        if self._is_global(obj):\n            assert name not in self._global_ns\n            self._global_ns[name] = obj\n        else:\n            for shader in shaders:\n                ns = self._shader_ns[shader]\n                assert name not in ns\n                ns[name] = obj\n        self._object_names[obj] = name"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _update(self):\n\n        x, y = self._pos\n        halfw, halfh = self._halfdim\n\n        # test that width and height are non-zero\n        if halfw <= 0:\n            raise ValueError(\"half-width must be positive and non-zero\"\n                             \", not %s\" % halfw)\n        if halfh <= 0:\n            raise ValueError(\"half-height must be positive and non-zero\"\n                             \", not %s\" % halfh)\n\n        # test that the given width and height is consistent\n        # with the orientation\n        if (self._orientation == \"bottom\" or self._orientation == \"top\"):\n                if halfw < halfh:\n                    raise ValueError(\"half-width(%s) < half-height(%s) for\"\n                                     \"%s orientation,\"\n                                     \" expected half-width >= half-height\" %\n                                     (halfw, halfh, self._orientation, ))\n        else:  # orientation == left or orientation == right\n            if halfw > halfh:\n                raise ValueError(\"half-width(%s) > half-height(%s) for\"\n                                 \"%s orientation,\"\n                                 \" expected half-width <= half-height\" %\n                                 (halfw, halfh, self._orientation, ))\n\n        # Set up the attributes that the shaders require\n        vertices = np.array([[x - halfw, y - halfh],\n                             [x + halfw, y - halfh],\n                             [x + halfw, y + halfh],\n                             # tri 2\n                             [x - halfw, y - halfh],\n                             [x + halfw, y + halfh],\n                             [x - halfw, y + halfh]],\n                            dtype=np.float32)\n\n        self.shared_program['a_position'] = vertices", "response": "Updates the internal state of the object store."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _update(self):\n        self._colorbar.halfdim = self._halfdim\n        self._border.halfdim = self._halfdim\n\n        self._label.text = self._label_str\n        self._ticks[0].text = str(self._clim[0])\n        self._ticks[1].text = str(self._clim[1])\n\n        self._update_positions()\n\n        self._colorbar._update()\n        self._border._update()", "response": "Updates the colorbar and border based on the objects\n           that are used internally by the ColorBarVisual\n       ."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _update_positions(self):\n        self._colorbar.pos = self._pos\n        self._border.pos = self._pos\n\n        if self._orientation == \"right\" or self._orientation == \"left\":\n            self._label.rotation = -90\n\n        x, y = self._pos\n        halfw, halfh = self._halfdim\n\n        label_anchors = \\\n            ColorBarVisual._get_label_anchors(center=self._pos,\n                                              halfdim=self._halfdim,\n                                              orientation=self._orientation,\n                                              transforms=self.label.transforms)\n        self._label.anchors = label_anchors\n\n        ticks_anchors = \\\n            ColorBarVisual._get_ticks_anchors(center=self._pos,\n                                              halfdim=self._halfdim,\n                                              orientation=self._orientation,\n                                              transforms=self.label.transforms)\n\n        self._ticks[0].anchors = ticks_anchors\n        self._ticks[1].anchors = ticks_anchors\n\n        (label_pos, ticks_pos) = \\\n            ColorBarVisual._calc_positions(center=self._pos,\n                                           halfdim=self._halfdim,\n                                           border_width=self.border_width,\n                                           orientation=self._orientation,\n                                           transforms=self.transforms)\n\n        self._label.pos = label_pos\n        self._ticks[0].pos = ticks_pos[0]\n        self._ticks[1].pos = ticks_pos[1]", "response": "Updates the positions of the colorbars and labels based on the current state of the object."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncalculate the text centeritions of the ColorBar object.", "response": "def _calc_positions(center, halfdim, border_width,\n                        orientation, transforms):\n        \"\"\"\n        Calculate the text centeritions given the ColorBar\n        parameters.\n\n        Note\n        ----\n        This is static because in principle, this\n        function does not need access to the state of the ColorBar\n        at all. It's a computation function that computes coordinate\n        transforms\n\n        Parameters\n        ----------\n        center: tuple (x, y)\n            Center of the ColorBar\n        halfdim: tuple (halfw, halfh)\n            Half of the dimensions measured from the center\n        border_width: float\n            Width of the border of the ColorBar\n        orientation: \"top\" | \"bottom\" | \"left\" | \"right\"\n            Position of the label with respect to the ColorBar\n        transforms: TransformSystem\n            the transforms of the ColorBar\n        \"\"\"\n        (x, y) = center\n        (halfw, halfh) = halfdim\n\n        visual_to_doc = transforms.get_transform('visual', 'document')\n        doc_to_visual = transforms.get_transform('document', 'visual')\n\n        # doc_widths = visual_to_doc.map(np.array([halfw, halfh, 0, 0],\n        #                                         dtype=np.float32))\n\n        doc_x = visual_to_doc.map(np.array([halfw, 0, 0, 0], dtype=np.float32))\n        doc_y = visual_to_doc.map(np.array([0, halfh, 0, 0], dtype=np.float32))\n\n        if doc_x[0] < 0:\n            doc_x *= -1\n\n        if doc_y[1] < 0:\n            doc_y *= -1\n\n        # doc_halfw = np.abs(doc_widths[0])\n        # doc_halfh = np.abs(doc_widths[1])\n\n        if orientation == \"top\":\n            doc_perp_vector = -doc_y\n        elif orientation == \"bottom\":\n            doc_perp_vector = doc_y\n        elif orientation == \"left\":\n            doc_perp_vector = -doc_x\n        if orientation == \"right\":\n            doc_perp_vector = doc_x\n\n        perp_len = np.linalg.norm(doc_perp_vector)\n        doc_perp_vector /= perp_len\n        perp_len += border_width\n        perp_len += 5  # pixels\n        perp_len *= ColorBarVisual.text_padding_factor\n        doc_perp_vector *= perp_len\n\n        doc_center = visual_to_doc.map(np.array([x, y, 0, 0],\n                                                dtype=np.float32))\n        doc_label_pos = doc_center + doc_perp_vector\n        visual_label_pos = doc_to_visual.map(doc_label_pos)[:3]\n\n        # next, calculate tick positions\n        if orientation in [\"top\", \"bottom\"]:\n            doc_ticks_pos = [doc_label_pos - doc_x,\n                             doc_label_pos + doc_x]\n        else:\n            doc_ticks_pos = [doc_label_pos + doc_y,\n                             doc_label_pos - doc_y]\n\n        visual_ticks_pos = []\n        visual_ticks_pos.append(doc_to_visual.map(doc_ticks_pos[0])[:3])\n        visual_ticks_pos.append(doc_to_visual.map(doc_ticks_pos[1])[:3])\n\n        return (visual_label_pos, visual_ticks_pos)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef add_pseudo_fields(self):\n        fields = []\n        if self.backlight_on != enums.BACKLIGHT_ON_NEVER:\n            fields.append(\n                display_fields.BacklightPseudoField(ref='0', backlight_rule=self.backlight_on)\n            )\n\n        fields.append(\n            display_fields.PriorityPseudoField(\n                ref='0',\n                priority_playing=self.priority_playing,\n                priority_not_playing=self.priority_not_playing,\n            )\n        )\n\n        self.pattern.add_pseudo_fields(fields, self.screen)", "response": "Add pseudo fields ( e. g non - displayed fields to the display."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a new Rect padded by padding on all sides of the rectangle.", "response": "def padded(self, padding):\n        \"\"\"Return a new Rect padded (smaller) by padding on all sides\n\n        Parameters\n        ----------\n        padding : float\n            The padding.\n\n        Returns\n        -------\n        rect : instance of Rect\n            The padded rectangle.\n        \"\"\"\n        return Rect(pos=(self.pos[0]+padding, self.pos[1]+padding),\n                    size=(self.size[0]-2*padding, self.size[1]-2*padding))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef normalized(self):\n        return Rect(pos=(min(self.left, self.right),\n                         min(self.top, self.bottom)),\n                    size=(abs(self.width), abs(self.height)))", "response": "Return a Rect covering the same area but with height and width as positive."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a Rect with the same bounds but with axes inverted", "response": "def flipped(self, x=False, y=True):\n        \"\"\"Return a Rect with the same bounds but with axes inverted\n\n        Parameters\n        ----------\n        x : bool\n            Flip the X axis.\n        y : bool\n            Flip the Y axis.\n\n        Returns\n        -------\n        rect : instance of Rect\n            The flipped rectangle.\n        \"\"\"\n        pos = list(self.pos)\n        size = list(self.size)\n        for i, flip in enumerate((x, y)):\n            if flip:\n                pos[i] += size[i]\n                size[i] *= -1\n        return Rect(pos, size)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning array of coordinates that can be mapped by Transform classes.", "response": "def _transform_in(self):\n        \"\"\"Return array of coordinates that can be mapped by Transform\n        classes.\"\"\"\n        return np.array([\n            [self.left, self.bottom, 0, 1],\n            [self.right, self.top, 0, 1]])"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef configure(self, viewport=None, fbo_size=None, fbo_rect=None,\n                  canvas=None):\n        \"\"\"Automatically configure the TransformSystem:\n\n        * canvas_transform maps from the Canvas logical pixel\n          coordinate system to the framebuffer coordinate system, taking into \n          account the logical/physical pixel scale factor, current FBO \n          position, and y-axis inversion.\n        * framebuffer_transform maps from the current GL viewport on the\n          framebuffer coordinate system to clip coordinates (-1 to 1). \n          \n          \n        Parameters\n        ==========\n        viewport : tuple or None\n            The GL viewport rectangle (x, y, w, h). If None, then it\n            is assumed to cover the entire canvas.\n        fbo_size : tuple or None\n            The size of the active FBO. If None, then it is assumed to have the\n            same size as the canvas's framebuffer.\n        fbo_rect : tuple or None\n            The position and size (x, y, w, h) of the FBO in the coordinate\n            system of the canvas's framebuffer. If None, then the bounds are\n            assumed to cover the entire active framebuffer.\n        canvas : Canvas instance\n            Optionally set the canvas for this TransformSystem. See the \n            `canvas` property.\n        \"\"\"\n        # TODO: check that d2f and f2r transforms still contain a single\n        # STTransform (if the user has modified these, then auto-config should\n        # either fail or replace the transforms)\n        if canvas is not None:\n            self.canvas = canvas\n        canvas = self._canvas\n        if canvas is None:\n            raise RuntimeError(\"No canvas assigned to this TransformSystem.\")\n       \n        # By default, this should invert the y axis--canvas origin is in top\n        # left, whereas framebuffer origin is in bottom left.\n        map_from = [(0, 0), canvas.size]\n        map_to = [(0, canvas.physical_size[1]), (canvas.physical_size[0], 0)]\n        self._canvas_transform.transforms[1].set_mapping(map_from, map_to)\n\n        if fbo_rect is None:\n            self._canvas_transform.transforms[0].scale = (1, 1, 1)\n            self._canvas_transform.transforms[0].translate = (0, 0, 0)\n        else:\n            # Map into FBO coordinates\n            map_from = [(fbo_rect[0], fbo_rect[1]),\n                        (fbo_rect[0] + fbo_rect[2], fbo_rect[1] + fbo_rect[3])]\n            map_to = [(0, 0), fbo_size]\n            self._canvas_transform.transforms[0].set_mapping(map_from,  map_to)\n            \n        if viewport is None:\n            if fbo_size is None:\n                # viewport covers entire canvas\n                map_from = [(0, 0), canvas.physical_size]\n            else:\n                # viewport covers entire FBO\n                map_from = [(0, 0), fbo_size]\n        else:\n            map_from = [viewport[:2], \n                        (viewport[0] + viewport[2], viewport[1] + viewport[3])]\n        map_to = [(-1, -1), (1, 1)]\n        self._framebuffer_transform.transforms[0].set_mapping(map_from, map_to)", "response": "Automatically configure the TransformSystem."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the physical resolution of the document coordinate system.", "response": "def dpi(self):\n        \"\"\" Physical resolution of the document coordinate system (dots per\n        inch).\n        \"\"\"\n        if self._dpi is None:\n            if self._canvas is None:\n                return None\n            else:\n                return self.canvas.dpi\n        else:\n            return self._dpi"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_transform(self, map_from='visual', map_to='render'):\n        tr = ['visual', 'scene', 'document', 'canvas', 'framebuffer', 'render']\n        ifrom = tr.index(map_from)\n        ito = tr.index(map_to)\n        \n        if ifrom < ito:\n            trs = [getattr(self, '_' + t + '_transform')\n                   for t in tr[ifrom:ito]][::-1]\n        else:\n            trs = [getattr(self, '_' + t + '_transform').inverse\n                   for t in tr[ito:ifrom]]\n        return self._cache.get(trs)", "response": "Returns a transform mapping between any two coordinate systems."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _calculate_delta_pos(adjacency_arr, pos, t, optimal):\n    # XXX eventually this should be refactored for the sparse case to only\n    # do the necessary pairwise distances\n    delta = pos[:, np.newaxis, :] - pos\n\n    # Distance between points\n    distance2 = (delta*delta).sum(axis=-1)\n    # Enforce minimum distance of 0.01\n    distance2 = np.where(distance2 < 0.0001, 0.0001, distance2)\n    distance = np.sqrt(distance2)\n    # Displacement \"force\"\n    displacement = np.zeros((len(delta), 2))\n    for ii in range(2):\n        displacement[:, ii] = (\n            delta[:, :, ii] *\n            ((optimal * optimal) / (distance*distance) -\n             (adjacency_arr * distance) / optimal)).sum(axis=1)\n\n    length = np.sqrt((displacement**2).sum(axis=1))\n    length = np.where(length < 0.01, 0.1, length)\n    delta_pos = displacement * t / length[:, np.newaxis]\n    return delta_pos", "response": "Helper function to calculate the delta position of a single object in a sequence of points."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef use(app=None, gl=None):\n    if app is None and gl is None:\n        raise TypeError('Must specify at least one of \"app\" or \"gl\".')\n\n    # Example for future. This wont work (yet).\n    if app == 'ipynb_webgl':\n        app = 'headless'\n        gl = 'webgl'\n\n    if app == 'osmesa':\n        from ..util.osmesa_gl import fix_osmesa_gl_lib\n        fix_osmesa_gl_lib()\n        if gl is not None:\n            raise ValueError(\"Do not specify gl when using osmesa\")\n\n    # Apply now\n    if gl:\n        from .. import gloo, config\n        config['gl_backend'] = gl\n        gloo.gl.use_gl(gl)\n    if app:\n        from ..app import use_app\n        use_app(app)", "response": "Set the usage options for the specified app and GL backend."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nruns command using subprocess. Popen and return the output of the subprocess. CalledProcessError is raised if the return code is zero.", "response": "def run_subprocess(command, return_code=False, **kwargs):\n    \"\"\"Run command using subprocess.Popen\n\n    Run command and wait for command to complete. If the return code was zero\n    then return, otherwise raise CalledProcessError.\n    By default, this will also add stdout= and stderr=subproces.PIPE\n    to the call to Popen to suppress printing to the terminal.\n\n    Parameters\n    ----------\n    command : list of str\n        Command to run as subprocess (see subprocess.Popen documentation).\n    return_code : bool\n        If True, the returncode will be returned, and no error checking\n        will be performed (so this function should always return without\n        error).\n    **kwargs : dict\n        Additional kwargs to pass to ``subprocess.Popen``.\n\n    Returns\n    -------\n    stdout : str\n        Stdout returned by the process.\n    stderr : str\n        Stderr returned by the process.\n    code : int\n        The command exit code. Only returned if ``return_code`` is True.\n    \"\"\"\n    # code adapted with permission from mne-python\n    use_kwargs = dict(stderr=subprocess.PIPE, stdout=subprocess.PIPE)\n    use_kwargs.update(kwargs)\n\n    p = subprocess.Popen(command, **use_kwargs)\n    output = p.communicate()\n\n    # communicate() may return bytes, str, or None depending on the kwargs\n    # passed to Popen(). Convert all to unicode str:\n    output = ['' if s is None else s for s in output]\n    output = [s.decode('utf-8') if isinstance(s, bytes) else s for s in output]\n    output = tuple(output)\n\n    if not return_code and p.returncode:\n        print(output[0])\n        print(output[1])\n        err_fun = subprocess.CalledProcessError.__init__\n        if 'output' in inspect.getargspec(err_fun).args:\n            raise subprocess.CalledProcessError(p.returncode, command, output)\n        else:\n            raise subprocess.CalledProcessError(p.returncode, command)\n    if return_code:\n        output = output + (p.returncode,)\n    return output"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nstarts the timer. A timeout event will be generated every *interval* seconds. If *interval* is None, then self.interval will be used. If *iterations* is specified, the timer will stop after emitting that number of events. If unspecified, then the previous value of self.iterations will be used. If the value is negative, then the timer will continue running until stop() is called. If the timer is already running when this function is called, nothing happens (timer continues running as it did previously, without changing the interval, number of iterations, or emitting a timer start event).", "response": "def start(self, interval=None, iterations=None):\n        \"\"\"Start the timer.\n\n        A timeout event will be generated every *interval* seconds.\n        If *interval* is None, then self.interval will be used.\n\n        If *iterations* is specified, the timer will stop after\n        emitting that number of events. If unspecified, then\n        the previous value of self.iterations will be used. If the value is\n        negative, then the timer will continue running until stop() is called.\n\n        If the timer is already running when this function is called, nothing\n        happens (timer continues running as it did previously, without\n        changing the interval, number of iterations, or emitting a timer\n        start event).\n        \"\"\"\n        if self.running:\n            return  # don't do anything if already running\n        self.iter_count = 0\n        if interval is not None:\n            self.interval = interval\n        if iterations is not None:\n            self.max_iterations = iterations\n        self._backend._vispy_start(self.interval)\n        self._running = True\n        self._first_emit_time = precision_time()\n        self._last_emit_time = precision_time()\n        self.events.start(type='timer_start')"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a numpy array of all the HEALPix indexes contained in the MOC at its max order.", "response": "def _best_res_pixels(self):\n        \"\"\"\n        Returns a numpy array of all the HEALPix indexes contained in the MOC at its max order.\n\n        Returns\n        -------\n        result : `~numpy.ndarray`\n            The array of HEALPix at ``max_order``\n        \"\"\"\n        factor = 2 * (AbstractMOC.HPY_MAX_NORDER - self.max_order)\n        pix_l = []\n        for iv in self._interval_set._intervals:\n            for val in range(iv[0] >> factor, iv[1] >> factor):\n                pix_l.append(val)\n\n        return np.asarray(pix_l)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a boolean array of the positions lying inside or outside the MOC.", "response": "def contains(self, ra, dec, keep_inside=True):\n        \"\"\"\n        Returns a boolean mask array of the positions lying inside (or outside) the MOC instance.\n\n        Parameters\n        ----------\n        ra : `astropy.units.Quantity`\n            Right ascension array\n        dec : `astropy.units.Quantity`\n            Declination array\n        keep_inside : bool, optional\n            True by default. If so the mask describes coordinates lying inside the MOC. If ``keep_inside``\n            is false, contains will return the mask of the coordinates lying outside the MOC.\n\n        Returns\n        -------\n        array : `~np.ndarray`\n            A mask boolean array\n        \"\"\"\n        depth = self.max_order\n        m = np.zeros(nside2npix(1 << depth), dtype=bool)\n\n        pix_id = self._best_res_pixels()\n        m[pix_id] = True\n\n        if not keep_inside:\n            m = np.logical_not(m)\n\n        hp = HEALPix(nside=(1 << depth), order='nested')\n        pix = hp.lonlat_to_healpix(ra, dec)\n\n        return m[pix]"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef add_neighbours(self):\n        # Get the pixels array of the MOC at the its max order.\n        ipix = self._best_res_pixels()\n\n        hp = HEALPix(nside=(1 << self.max_order), order='nested')\n        # Get the HEALPix array containing the neighbors of ``ipix``.\n        # This array \"extends\" ``ipix`` by one degree of neighbors. \n        extend_ipix = AbstractMOC._neighbour_pixels(hp, ipix)\n        \n        # Compute the difference between ``extend_ipix`` and ``ipix`` to get only the neighboring pixels\n        # located at the border of the MOC.\n        neigh_ipix = np.setdiff1d(extend_ipix, ipix)\n\n        shift = 2 * (AbstractMOC.HPY_MAX_NORDER - self.max_order)\n        neigh_itv = np.vstack((neigh_ipix << shift, (neigh_ipix + 1) << shift)).T\n        # This array of HEALPix neighbors are added to the MOC to get an ``extended`` MOC at its max order.\n        self._interval_set = self._interval_set.union(IntervalSet(neigh_itv))\n        return self", "response": "Adds the neighbours of the MOC to the MOC instance."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef remove_neighbours(self):\n        # Get the HEALPix cells of the MOC at its max depth\n        ipix = self._best_res_pixels()\n\n        hp = HEALPix(nside=(1 << self.max_order), order='nested')\n        # Extend it to include the max depth neighbor cells.\n        extend_ipix = AbstractMOC._neighbour_pixels(hp, ipix)\n\n        # Get only the max depth HEALPix cells lying at the border of the MOC\n        neigh_ipix = np.setxor1d(extend_ipix, ipix)\n\n        # Remove these pixels from ``ipix``\n        border_ipix = AbstractMOC._neighbour_pixels(hp, neigh_ipix)\n        reduced_ipix = np.setdiff1d(ipix, border_ipix)\n\n        # Build the reduced MOC, i.e. MOC without its pixels which were located at its border.\n        shift = 2 * (AbstractMOC.HPY_MAX_NORDER - self.max_order)\n        reduced_itv = np.vstack((reduced_ipix << shift, (reduced_ipix + 1) << shift)).T\n        self._interval_set = IntervalSet(reduced_itv)\n        return self", "response": "Removes all HEALPix cells from the MOC instance."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef fill(self, ax, wcs, **kw_mpl_pathpatch):\n        fill.fill(self, ax, wcs, **kw_mpl_pathpatch)", "response": "Fills the MOC with the WCS and the MOCs."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef border(self, ax, wcs, **kw_mpl_pathpatch):\n        border.border(self, ax, wcs, **kw_mpl_pathpatch)", "response": "Draws the border of the MOC on a matplotlib axis."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate a MOC from an image stored as a FITS file.", "response": "def from_image(cls, header, max_norder, mask=None):\n        \"\"\"\n        Creates a `~mocpy.moc.MOC` from an image stored as a FITS file.\n\n        Parameters\n        ----------\n        header : `astropy.io.fits.Header`\n            FITS header containing all the info of where the image is located (position, size, etc...)\n        max_norder : int\n            The moc resolution.\n        mask : `numpy.ndarray`, optional\n            A boolean array of the same size of the image where pixels having the value 1 are part of\n            the final MOC and pixels having the value 0 are not.\n\n        Returns\n        -------\n        moc : `~mocpy.moc.MOC`\n            The resulting MOC.\n        \"\"\"\n        # load the image data\n        height = header['NAXIS2']\n        width = header['NAXIS1']\n\n        # use wcs from astropy to locate the image in the world coordinates\n        w = wcs.WCS(header)\n\n        if mask is not None:\n            # We have an array of pixels that are part of of survey\n            y, x = np.where(mask)\n            pix_crd = np.dstack((x, y))[0]\n        else:\n            # If we do not have a mask array we create the moc of all the image\n            #\n            step_pix = 1\n            \"\"\"\n            Coords returned by wcs_pix2world method correspond to pixel centers. We want to retrieve the moc pix\n            crossing the borders of the image so we have to add 1/2 to the pixels coords before computing the lonlat.\n            \n            The step between two pix_crd is set to `step_pix` but can be diminished to have a better precision at the \n            borders so that all the image is covered (a too big step does not retrieve all\n            the moc pix crossing the borders of the image).\n            \"\"\"\n            x, y = np.mgrid[0.5:(width + 0.5 + step_pix):step_pix, 0.5:(height + 0.5 + step_pix):step_pix]\n            pix_crd = np.dstack((x.ravel(), y.ravel()))[0]\n\n        frame = wcs.utils.wcs_to_celestial_frame(w)\n        world_pix_crd = SkyCoord(w.wcs_pix2world(pix_crd, 1), unit='deg', frame=frame)\n\n        hp = HEALPix(nside=(1 << max_norder), order='nested', frame=ICRS())\n        ipix = hp.skycoord_to_healpix(world_pix_crd)\n        # remove doubles\n        ipix = np.unique(ipix)\n\n        shift = 2 * (AbstractMOC.HPY_MAX_NORDER - max_norder)\n        intervals_arr = np.vstack((ipix << shift, (ipix + 1) << shift)).T\n\n        # This MOC will be consistent when one will do operations on the moc (union, inter, ...) or\n        # simply write it to a fits or json file\n        interval_set = IntervalSet(intervals_arr)\n\n        return cls(interval_set=interval_set)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef from_fits_images(cls, path_l, max_norder):\n        moc = MOC()\n        for path in path_l:\n            header = fits.getheader(path)\n            current_moc = MOC.from_image(header=header, max_norder=max_norder)\n            moc = moc.union(current_moc)\n\n        return moc", "response": "Loads a MOC from a set of FITS file images."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate a MOC object from a VizieR table.", "response": "def from_vizier_table(cls, table_id, nside=256):\n        \"\"\"\n        Creates a `~mocpy.moc.MOC` object from a VizieR table.\n\n        **Info**: This method is already implemented in `astroquery.cds <https://astroquery.readthedocs.io/en/latest/cds/cds.html>`__. You can ask to get a `mocpy.moc.MOC` object\n        from a vizier catalog ID.\n\n        Parameters\n        ----------\n        table_id : str\n            table index\n        nside : int, optional\n            256 by default\n\n        Returns\n        -------\n        result : `~mocpy.moc.MOC`\n            The resulting MOC.\n        \"\"\"\n        nside_possible_values = (8, 16, 32, 64, 128, 256, 512)\n        if nside not in nside_possible_values:\n            raise ValueError('Bad value for nside. Must be in {0}'.format(nside_possible_values))\n\n        result = cls.from_ivorn('ivo://CDS/' + table_id, nside)\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef from_ivorn(cls, ivorn, nside=256):\n        return cls.from_url('%s?%s' % (MOC.MOC_SERVER_ROOT_URL,\n                                       urlencode({\n                                           'ivorn': ivorn,\n                                           'get': 'moc',\n                                           'order': int(np.log2(nside))\n                                       })))", "response": "Creates a MOC object from a given ivorn."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate a ~mocpy. moc. MOC object from a given url.", "response": "def from_url(cls, url):\n        \"\"\"\n        Creates a `~mocpy.moc.MOC` object from a given url.\n\n        Parameters\n        ----------\n        url : str\n            The url of a FITS file storing a MOC.\n\n        Returns\n        -------\n        result : `~mocpy.moc.MOC`\n            The resulting MOC.\n        \"\"\"\n        path = download_file(url, show_progress=False, timeout=60)\n        return cls.from_fits(path)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef from_skycoords(cls, skycoords, max_norder):\n        hp = HEALPix(nside=(1 << max_norder), order='nested')\n        ipix = hp.lonlat_to_healpix(skycoords.icrs.ra, skycoords.icrs.dec)\n\n        shift = 2 * (AbstractMOC.HPY_MAX_NORDER - max_norder)\n        intervals = np.vstack((ipix << shift, (ipix + 1) << shift)).T\n\n        interval_set = IntervalSet(intervals)\n        return cls(interval_set)", "response": "Creates a MOC from an astropy. coordinates. SkyCoord object."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating a MOC from an astropy lon lat and max_norder.", "response": "def from_lonlat(cls, lon, lat, max_norder):\n        \"\"\"\n        Creates a MOC from astropy lon, lat `astropy.units.Quantity`.\n        \n        Parameters\n        ----------\n        lon : `astropy.units.Quantity`\n            The longitudes of the sky coordinates belonging to the MOC.\n        lat : `astropy.units.Quantity`\n            The latitudes of the sky coordinates belonging to the MOC.\n        max_norder : int\n            The depth of the smallest HEALPix cells contained in the MOC.\n        \n        Returns\n        -------\n        result : `~mocpy.moc.MOC`\n            The resulting MOC\n        \"\"\"\n        hp = HEALPix(nside=(1 << max_norder), order='nested')\n        ipix = hp.lonlat_to_healpix(lon, lat)\n\n        shift = 2 * (AbstractMOC.HPY_MAX_NORDER - max_norder)\n        intervals = np.vstack((ipix << shift, (ipix + 1) << shift)).T\n\n        interval_set = IntervalSet(intervals)\n        return cls(interval_set)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncreates a MOC from a polygon.", "response": "def from_polygon_skycoord(cls, skycoord, inside=None, max_depth=10):\n        \"\"\"\n        Creates a MOC from a polygon.\n\n        The polygon is given as an `astropy.coordinates.SkyCoord` that contains the \n        vertices of the polygon. Concave and convex polygons are accepted but\n        self-intersecting ones are currently not properly handled.\n\n        Parameters\n        ----------\n        skycoord : `astropy.coordinates.SkyCoord`\n            The sky coordinates defining the vertices of a polygon. It can describe a convex or\n            concave polygon but not a self-intersecting one.\n        inside : `astropy.coordinates.SkyCoord`, optional\n            A point that will be inside the MOC is needed as it is not possible to determine the inside area of a polygon \n            on the unit sphere (there is no infinite area that can be considered as the outside because on the sphere,\n            a closed polygon delimits two finite areas).\n            Possible improvement: take the inside area as the one covering the smallest region on the sphere.\n\n            If inside=None (default behavior), the mean of all the vertices is taken as lying inside the polygon. That approach may not work for \n            concave polygons.\n        max_depth : int, optional\n            The resolution of the MOC. Set to 10 by default.\n\n        Returns\n        -------\n        result : `~mocpy.moc.MOC`\n            The resulting MOC\n        \"\"\"\n        return MOC.from_polygon(lon=skycoord.icrs.ra, lat=skycoord.icrs.dec,\n                                inside=inside, max_depth=max_depth)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating a MOC from a polygon.", "response": "def from_polygon(cls, lon, lat, inside=None, max_depth=10):\n        \"\"\"\n        Creates a MOC from a polygon\n\n        The polygon is given as lon and lat `astropy.units.Quantity` that define the \n        vertices of the polygon. Concave and convex polygons are accepted but\n        self-intersecting ones are currently not properly handled.\n\n        Parameters\n        ----------\n        lon : `astropy.units.Quantity`\n            The longitudes defining the polygon. Can describe convex and\n            concave polygons but not self-intersecting ones.\n        lat : `astropy.units.Quantity`\n            The latitudes defining the polygon. Can describe convex and concave\n            polygons but not self-intersecting ones.\n        inside : `astropy.coordinates.SkyCoord`, optional\n            A point that will be inside the MOC is needed as it is not possible to determine the inside area of a polygon \n            on the unit sphere (there is no infinite area that can be considered as the outside because on the sphere,\n            a closed polygon delimits two finite areas).\n            Possible improvement: take the inside area as the one covering the smallest region on the sphere.\n\n            If inside=None (default behavior), the mean of all the vertices is taken as lying inside the polygon. That approach may not work for \n            concave polygons.\n        max_depth : int, optional\n            The resolution of the MOC. Set to 10 by default.\n\n        Returns\n        -------\n        result : `~mocpy.moc.MOC`\n            The resulting MOC\n        \"\"\"\n        from .polygon import PolygonComputer\n\n        polygon_computer = PolygonComputer(lon, lat, inside, max_depth)\n        # Create the moc from the python dictionary\n\n        moc = MOC.from_json(polygon_computer.ipix)\n        # We degrade it to the user-requested order\n        if polygon_computer.degrade_to_max_depth:\n            moc = moc.degrade_to_order(max_depth)\n\n        return moc"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef sky_fraction(self):\n        pix_id = self._best_res_pixels()\n        nb_pix_filled = pix_id.size\n        return nb_pix_filled / float(3 << (2*(self.max_order + 1)))", "response": "Return the sky fraction covered by the MOC\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef plot(self, title='MOC', frame=None):\n        frame = ICRS() if frame is None else frame\n\n        from matplotlib.colors import LinearSegmentedColormap\n        import matplotlib.pyplot as plt\n\n        plot_order = 8\n        if self.max_order > plot_order:\n            plotted_moc = self.degrade_to_order(plot_order)\n        else:\n            plotted_moc = self\n\n        num_pixels_map = 1024\n        delta = 2. * np.pi / num_pixels_map\n\n        x = np.arange(-np.pi, np.pi, delta)\n        y = np.arange(-np.pi/2, np.pi/2, delta)\n        lon_rad, lat_rad = np.meshgrid(x, y)\n        hp = HEALPix(nside=(1 << plotted_moc.max_order), order='nested')\n\n        if frame and not isinstance(frame, BaseCoordinateFrame):\n            raise ValueError(\"Only Galactic/ICRS coordinate systems are supported.\"\n                             \"Please set `coord` to either 'C' or 'G'.\")\n\n        pix_map = hp.lonlat_to_healpix(lon_rad * u.rad, lat_rad * u.rad)\n\n        m = np.zeros(nside2npix(1 << plotted_moc.max_order))\n        pix_id = plotted_moc._best_res_pixels()\n\n        # change the HEALPix cells if the frame of the MOC is not the same as the one associated with the plot method.\n        if isinstance(frame, Galactic):\n            lon, lat = hp.boundaries_lonlat(pix_id, step=2)\n            sky_crd = SkyCoord(lon, lat, unit='deg')\n            pix_id = hp.lonlat_to_healpix(sky_crd.galactic.l, sky_crd.galactic.b)\n\n        m[pix_id] = 1\n\n        z = np.flip(m[pix_map], axis=1)\n\n        plt.figure(figsize=(10, 10))\n\n        ax = plt.subplot(111, projection=\"mollweide\")\n        ax.set_xticklabels(['150\u00b0', '120\u00b0', '90\u00b0', '60\u00b0', '30\u00b0', '0\u00b0', '330\u00b0', '300\u00b0', '270\u00b0', '240\u00b0', '210\u00b0', '180\u00b0'])\n\n        color_map = LinearSegmentedColormap.from_list('w2r', ['#eeeeee', '#aa0000'])\n        color_map.set_under('w')\n        color_map.set_bad('gray')\n\n        ax.pcolormesh(x, y, z, cmap=color_map, vmin=0, vmax=1)\n        ax.tick_params(labelsize=14, labelcolor='#000000')\n        plt.title(title)\n        plt.grid(True, linestyle='--', linewidth=1, color='#555555')\n\n        plt.show()", "response": "Plots the MOC object using a mollweide projection."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef inverse(self):\n        if self._inverse is None:\n            self._inverse = InverseTransform(self)\n        return self._inverse", "response": "Returns the inverse of this transform."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _tile_ticks(self, frac, tickvec):\n        origins = np.tile(self.axis._vec, (len(frac), 1))\n        origins = self.axis.pos[0].T + (origins.T*frac).T\n        endpoints = tickvec + origins\n        return origins, endpoints", "response": "Tiles tick marks along the axis."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _get_tick_frac_labels(self):\n        minor_num = 4  # number of minor ticks per major division\n        if (self.axis.scale_type == 'linear'):\n            domain = self.axis.domain\n            if domain[1] < domain[0]:\n                flip = True\n                domain = domain[::-1]\n            else:\n                flip = False\n            offset = domain[0]\n            scale = domain[1] - domain[0]\n\n            transforms = self.axis.transforms\n            length = self.axis.pos[1] - self.axis.pos[0]  # in logical coords\n            n_inches = np.sqrt(np.sum(length ** 2)) / transforms.dpi\n\n            # major = np.linspace(domain[0], domain[1], num=11)\n            # major = MaxNLocator(10).tick_values(*domain)\n            major = _get_ticks_talbot(domain[0], domain[1], n_inches, 2)\n\n            labels = ['%g' % x for x in major]\n            majstep = major[1] - major[0]\n            minor = []\n            minstep = majstep / (minor_num + 1)\n            minstart = 0 if self.axis._stop_at_major[0] else -1\n            minstop = -1 if self.axis._stop_at_major[1] else 0\n            for i in range(minstart, len(major) + minstop):\n                maj = major[0] + i * majstep\n                minor.extend(np.linspace(maj + minstep,\n                                         maj + majstep - minstep,\n                                         minor_num))\n            major_frac = (major - offset) / scale\n            minor_frac = (np.array(minor) - offset) / scale\n            major_frac = major_frac[::-1] if flip else major_frac\n            use_mask = (major_frac > -0.0001) & (major_frac < 1.0001)\n            major_frac = major_frac[use_mask]\n            labels = [l for li, l in enumerate(labels) if use_mask[li]]\n            minor_frac = minor_frac[(minor_frac > -0.0001) &\n                                    (minor_frac < 1.0001)]\n        elif self.axis.scale_type == 'logarithmic':\n            return NotImplementedError\n        elif self.axis.scale_type == 'power':\n            return NotImplementedError\n        return major_frac, minor_frac, labels", "response": "Get the ticks minor ticks and major labels"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ninterleave planes in the input image data.", "response": "def interleave_planes(ipixels, apixels, ipsize, apsize):\n    \"\"\"\n    Interleave (colour) planes, e.g. RGB + A = RGBA.\n\n    Return an array of pixels consisting of the `ipsize` elements of\n    data from each pixel in `ipixels` followed by the `apsize` elements\n    of data from each pixel in `apixels`.  Conventionally `ipixels`\n    and `apixels` are byte arrays so the sizes are bytes, but it\n    actually works with any arrays of the same type.  The returned\n    array is the same type as the input arrays which should be the\n    same type as each other.\n    \"\"\"\n\n    itotal = len(ipixels)\n    atotal = len(apixels)\n    newtotal = itotal + atotal\n    newpsize = ipsize + apsize\n    # Set up the output buffer\n    # See http://www.python.org/doc/2.4.4/lib/module-array.html#l2h-1356\n    out = array(ipixels.typecode)\n    # It's annoying that there is no cheap way to set the array size :-(\n    out.extend(ipixels)\n    out.extend(apixels)\n    # Interleave in the pixel data\n    for i in range(ipsize):\n        out[i:newtotal:newpsize] = ipixels[i:itotal:ipsize]\n    for i in range(apsize):\n        out[i+ipsize:newtotal:newpsize] = apixels[i:atotal:apsize]\n    return out"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nwriting out the PNG file by writing out the chunks.", "response": "def write_chunks(out, chunks):\n    \"\"\"Create a PNG file by writing out the chunks.\"\"\"\n\n    out.write(_signature)\n    for chunk in chunks:\n        write_chunk(out, *chunk)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef filter_scanline(type, line, fo, prev=None):\n\n    assert 0 <= type < 5\n\n    # The output array.  Which, pathetically, we extend one-byte at a\n    # time (fortunately this is linear).\n    out = array('B', [type])\n\n    def sub():\n        ai = -fo\n        for x in line:\n            if ai >= 0:\n                x = (x - line[ai]) & 0xff\n            out.append(x)\n            ai += 1\n    def up():\n        for i,x in enumerate(line):\n            x = (x - prev[i]) & 0xff\n            out.append(x)\n    def average():\n        ai = -fo\n        for i,x in enumerate(line):\n            if ai >= 0:\n                x = (x - ((line[ai] + prev[i]) >> 1)) & 0xff\n            else:\n                x = (x - (prev[i] >> 1)) & 0xff\n            out.append(x)\n            ai += 1\n    def paeth():\n        # http://www.w3.org/TR/PNG/#9Filter-type-4-Paeth\n        ai = -fo # also used for ci\n        for i,x in enumerate(line):\n            a = 0\n            b = prev[i]\n            c = 0\n\n            if ai >= 0:\n                a = line[ai]\n                c = prev[ai]\n            p = a + b - c\n            pa = abs(p - a)\n            pb = abs(p - b)\n            pc = abs(p - c)\n            if pa <= pb and pa <= pc:\n                Pr = a\n            elif pb <= pc:\n                Pr = b\n            else:\n                Pr = c\n\n            x = (x - Pr) & 0xff\n            out.append(x)\n            ai += 1\n\n    if not prev:\n        # We're on the first line.  Some of the filters can be reduced\n        # to simpler cases which makes handling the line \"off the top\"\n        # of the image simpler.  \"up\" becomes \"none\"; \"paeth\" becomes\n        # \"left\" (non-trivial, but true). \"average\" needs to be handled\n        # specially.\n        if type == 2: # \"up\"\n            type = 0\n        elif type == 3:\n            prev = [0]*len(line)\n        elif type == 4: # \"paeth\"\n            type = 1\n    if type == 0:\n        out.extend(line)\n    elif type == 1:\n        sub()\n    elif type == 2:\n        up()\n    elif type == 3:\n        average()\n    else: # type == 4\n        paeth()\n    return out", "response": "Apply a filter to a scanline."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef from_array(a, mode=None, info={}):\n\n    # We abuse the *info* parameter by modifying it.  Take a copy here.\n    # (Also typechecks *info* to some extent).\n    info = dict(info)\n\n    # Syntax check mode string.\n    bitdepth = None\n    try:\n        # Assign the 'L' or 'RGBA' part to `gotmode`.\n        if mode.startswith('L'):\n            gotmode = 'L'\n            mode = mode[1:]\n        elif mode.startswith('RGB'):\n            gotmode = 'RGB'\n            mode = mode[3:]\n        else:\n            raise Error()\n        if mode.startswith('A'):\n            gotmode += 'A'\n            mode = mode[1:]\n\n        # Skip any optional ';'\n        while mode.startswith(';'):\n            mode = mode[1:]\n\n        # Parse optional bitdepth\n        if mode:\n            try:\n                bitdepth = int(mode)\n            except (TypeError, ValueError):\n                raise Error()\n    except Error:\n        raise Error(\"mode string should be 'RGB' or 'L;16' or similar.\")\n    mode = gotmode\n\n    # Get bitdepth from *mode* if possible.\n    if bitdepth:\n        if info.get('bitdepth') and bitdepth != info['bitdepth']:\n            raise Error(\"mode bitdepth (%d) should match info bitdepth (%d).\" %\n              (bitdepth, info['bitdepth']))\n        info['bitdepth'] = bitdepth\n\n    # Fill in and/or check entries in *info*.\n    # Dimensions.\n    if 'size' in info:\n        # Check width, height, size all match where used.\n        for dimension,axis in [('width', 0), ('height', 1)]:\n            if dimension in info:\n                if info[dimension] != info['size'][axis]:\n                    raise Error(\n                      \"info[%r] should match info['size'][%r].\" %\n                      (dimension, axis))\n        info['width'],info['height'] = info['size']\n    if 'height' not in info:\n        try:\n            l = len(a)\n        except TypeError:\n            raise Error(\n              \"len(a) does not work, supply info['height'] instead.\")\n        info['height'] = l\n    # Colour format.\n    if 'greyscale' in info:\n        if bool(info['greyscale']) != ('L' in mode):\n            raise Error(\"info['greyscale'] should match mode.\")\n    info['greyscale'] = 'L' in mode\n    if 'alpha' in info:\n        if bool(info['alpha']) != ('A' in mode):\n            raise Error(\"info['alpha'] should match mode.\")\n    info['alpha'] = 'A' in mode\n\n    planes = len(mode)\n    if 'planes' in info:\n        if info['planes'] != planes:\n            raise Error(\"info['planes'] should match mode.\")\n\n    # In order to work out whether we the array is 2D or 3D we need its\n    # first row, which requires that we take a copy of its iterator.\n    # We may also need the first row to derive width and bitdepth.\n    a,t = itertools.tee(a)\n    row = t.next()\n    del t\n    try:\n        row[0][0]\n        threed = True\n        testelement = row[0]\n    except (IndexError, TypeError):\n        threed = False\n        testelement = row\n    if 'width' not in info:\n        if threed:\n            width = len(row)\n        else:\n            width = len(row) // planes\n        info['width'] = width\n\n    # Not implemented yet\n    assert not threed\n\n    if 'bitdepth' not in info:\n        try:\n            dtype = testelement.dtype\n            # goto the \"else:\" clause.  Sorry.\n        except AttributeError:\n            try:\n                # Try a Python array.array.\n                bitdepth = 8 * testelement.itemsize\n            except AttributeError:\n                # We can't determine it from the array element's\n                # datatype, use a default of 8.\n                bitdepth = 8\n        else:\n            # If we got here without exception, we now assume that\n            # the array is a numpy array.\n            if dtype.kind == 'b':\n                bitdepth = 1\n            else:\n                bitdepth = 8 * dtype.itemsize\n        info['bitdepth'] = bitdepth\n\n    for thing in 'width height bitdepth greyscale alpha'.split():\n        assert thing in info\n    return Image(a, info)", "response": "Create a PNG image object from a 2 - dimensional array."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef make_palette(self):\n\n        p = array('B')\n        t = array('B')\n\n        for x in self.palette:\n            p.extend(x[0:3])\n            if len(x) > 3:\n                t.append(x[3])\n        p = tostring(p)\n        t = tostring(t)\n        if t:\n            return p,t\n        return p,None", "response": "Create the byte sequences for a PLY and if necessary a\n tRNS chunk. Returned as a pair ( p t ) will be a pair ( t p ) will be a pair ( t ) will be a pair ( p t )"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef write(self, outfile, rows):\n\n        if self.interlace:\n            fmt = 'BH'[self.bitdepth > 8]\n            a = array(fmt, itertools.chain(*rows))\n            return self.write_array(outfile, a)\n\n        nrows = self.write_passes(outfile, rows)\n        if nrows != self.height:\n            raise ValueError(\n              \"rows supplied (%d) does not match height (%d)\" %\n              (nrows, self.height))", "response": "Write a PNG image to the output file."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nwrites a PNG image to the output file.", "response": "def write_passes(self, outfile, rows, packed=False):\n        \"\"\"\n        Write a PNG image to the output file.\n\n        Most users are expected to find the :meth:`write` or\n        :meth:`write_array` method more convenient.\n        \n        The rows should be given to this method in the order that\n        they appear in the output file.  For straightlaced images,\n        this is the usual top to bottom ordering, but for interlaced\n        images the rows should have already been interlaced before\n        passing them to this function.\n\n        `rows` should be an iterable that yields each row.  When\n        `packed` is ``False`` the rows should be in boxed row flat pixel\n        format; when `packed` is ``True`` each row should be a packed\n        sequence of bytes.\n        \"\"\"\n\n        # http://www.w3.org/TR/PNG/#5PNG-file-signature\n        outfile.write(_signature)\n\n        # http://www.w3.org/TR/PNG/#11IHDR\n        write_chunk(outfile, 'IHDR',\n                    struct.pack(\"!2I5B\", self.width, self.height,\n                                self.bitdepth, self.color_type,\n                                0, 0, self.interlace))\n\n        # See :chunk:order\n        # http://www.w3.org/TR/PNG/#11gAMA\n        if self.gamma is not None:\n            write_chunk(outfile, 'gAMA',\n                        struct.pack(\"!L\", int(round(self.gamma*1e5))))\n\n        # See :chunk:order\n        # http://www.w3.org/TR/PNG/#11sBIT\n        if self.rescale:\n            write_chunk(outfile, 'sBIT',\n                struct.pack('%dB' % self.planes,\n                            *[self.rescale[0]]*self.planes))\n        \n        # :chunk:order: Without a palette (PLTE chunk), ordering is\n        # relatively relaxed.  With one, gAMA chunk must precede PLTE\n        # chunk which must precede tRNS and bKGD.\n        # See http://www.w3.org/TR/PNG/#5ChunkOrdering\n        if self.palette:\n            p,t = self.make_palette()\n            write_chunk(outfile, 'PLTE', p)\n            if t:\n                # tRNS chunk is optional. Only needed if palette entries\n                # have alpha.\n                write_chunk(outfile, 'tRNS', t)\n\n        # http://www.w3.org/TR/PNG/#11tRNS\n        if self.transparent is not None:\n            if self.greyscale:\n                write_chunk(outfile, 'tRNS',\n                            struct.pack(\"!1H\", *self.transparent))\n            else:\n                write_chunk(outfile, 'tRNS',\n                            struct.pack(\"!3H\", *self.transparent))\n\n        # http://www.w3.org/TR/PNG/#11bKGD\n        if self.background is not None:\n            if self.greyscale:\n                write_chunk(outfile, 'bKGD',\n                            struct.pack(\"!1H\", *self.background))\n            else:\n                write_chunk(outfile, 'bKGD',\n                            struct.pack(\"!3H\", *self.background))\n\n        # http://www.w3.org/TR/PNG/#11IDAT\n        if self.compression is not None:\n            compressor = zlib.compressobj(self.compression)\n        else:\n            compressor = zlib.compressobj()\n\n        # Choose an extend function based on the bitdepth.  The extend\n        # function packs/decomposes the pixel values into bytes and\n        # stuffs them onto the data array.\n        data = array('B')\n        if self.bitdepth == 8 or packed:\n            extend = data.extend\n        elif self.bitdepth == 16:\n            # Decompose into bytes\n            def extend(sl):\n                fmt = '!%dH' % len(sl)\n                data.extend(array('B', struct.pack(fmt, *sl)))\n        else:\n            # Pack into bytes\n            assert self.bitdepth < 8\n            # samples per byte\n            spb = int(8/self.bitdepth)\n            def extend(sl):\n                a = array('B', sl)\n                # Adding padding bytes so we can group into a whole\n                # number of spb-tuples.\n                l = float(len(a))\n                extra = math.ceil(l / float(spb))*spb - l\n                a.extend([0]*int(extra))\n                # Pack into bytes\n                l = group(a, spb)\n                l = map(lambda e: reduce(lambda x,y:\n                                           (x << self.bitdepth) + y, e), l)\n                data.extend(l)\n        if self.rescale:\n            oldextend = extend\n            factor = \\\n              float(2**self.rescale[1]-1) / float(2**self.rescale[0]-1)\n            def extend(sl):\n                oldextend(map(lambda x: int(round(factor*x)), sl))\n\n        # Build the first row, testing mostly to see if we need to\n        # changed the extend function to cope with NumPy integer types\n        # (they cause our ordinary definition of extend to fail, so we\n        # wrap it).  See\n        # http://code.google.com/p/pypng/issues/detail?id=44\n        enumrows = enumerate(rows)\n        del rows\n\n        # First row's filter type.\n        data.append(0)\n        # :todo: Certain exceptions in the call to ``.next()`` or the\n        # following try would indicate no row data supplied.\n        # Should catch.\n        i,row = enumrows.next()\n        try:\n            # If this fails...\n            extend(row)\n        except:\n            # ... try a version that converts the values to int first.\n            # Not only does this work for the (slightly broken) NumPy\n            # types, there are probably lots of other, unknown, \"nearly\"\n            # int types it works for.\n            def wrapmapint(f):\n                return lambda sl: f(map(int, sl))\n            extend = wrapmapint(extend)\n            del wrapmapint\n            extend(row)\n\n        for i,row in enumrows:\n            # Add \"None\" filter type.  Currently, it's essential that\n            # this filter type be used for every scanline as we do not\n            # mark the first row of a reduced pass image; that means we\n            # could accidentally compute the wrong filtered scanline if\n            # we used \"up\", \"average\", or \"paeth\" on such a line.\n            data.append(0)\n            extend(row)\n            if len(data) > self.chunk_limit:\n                compressed = compressor.compress(tostring(data))\n                if len(compressed):\n                    write_chunk(outfile, 'IDAT', compressed)\n                # Because of our very witty definition of ``extend``,\n                # above, we must re-use the same ``data`` object.  Hence\n                # we use ``del`` to empty this one, rather than create a\n                # fresh one (which would be my natural FP instinct).\n                del data[:]\n        if len(data):\n            compressed = compressor.compress(tostring(data))\n        else:\n            compressed = strtobytes('')\n        flushed = compressor.flush()\n        if len(compressed) or len(flushed):\n            write_chunk(outfile, 'IDAT', compressed + flushed)\n        # http://www.w3.org/TR/PNG/#11IEND\n        write_chunk(outfile, 'IEND')\n        return i+1"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nwrite PNG file to outfile.", "response": "def write_packed(self, outfile, rows):\n        \"\"\"\n        Write PNG file to `outfile`.  The pixel data comes from `rows`\n        which should be in boxed row packed format.  Each row should be\n        a sequence of packed bytes.\n\n        Technically, this method does work for interlaced images but it\n        is best avoided.  For interlaced images, the rows should be\n        presented in the order that they appear in the file.\n\n        This method should not be used when the source image bit depth\n        is not one naturally supported by PNG; the bit depth should be\n        1, 2, 4, 8, or 16.\n        \"\"\"\n\n        if self.rescale:\n            raise Error(\"write_packed method not suitable for bit depth %d\" %\n              self.rescale[0])\n        return self.write_passes(outfile, rows, packed=True)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef convert_pnm(self, infile, outfile):\n\n        if self.interlace:\n            pixels = array('B')\n            pixels.fromfile(infile,\n                            (self.bitdepth/8) * self.color_planes *\n                            self.width * self.height)\n            self.write_passes(outfile, self.array_scanlines_interlace(pixels))\n        else:\n            self.write_passes(outfile, self.file_scanlines(infile))", "response": "Convert a PNM file into PNG."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef convert_ppm_and_pgm(self, ppmfile, pgmfile, outfile):\n        pixels = array('B')\n        pixels.fromfile(ppmfile,\n                        (self.bitdepth/8) * self.color_planes *\n                        self.width * self.height)\n        apixels = array('B')\n        apixels.fromfile(pgmfile,\n                         (self.bitdepth/8) *\n                         self.width * self.height)\n        pixels = interleave_planes(pixels, apixels,\n                                   (self.bitdepth/8) * self.color_planes,\n                                   (self.bitdepth/8))\n        if self.interlace:\n            self.write_passes(outfile, self.array_scanlines_interlace(pixels))\n        else:\n            self.write_passes(outfile, self.array_scanlines(pixels))", "response": "Convert a PPM and PGM file containing raw pixel data into PNG outfile."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef file_scanlines(self, infile):\n\n        # Values per row\n        vpr = self.width * self.planes\n        row_bytes = vpr\n        if self.bitdepth > 8:\n            assert self.bitdepth == 16\n            row_bytes *= 2\n            fmt = '>%dH' % vpr\n            def line():\n                return array('H', struct.unpack(fmt, infile.read(row_bytes)))\n        else:\n            def line():\n                scanline = array('B', infile.read(row_bytes))\n                return scanline\n        for y in range(self.height):\n            yield line()", "response": "Generates boxed rows in flat pixel format from the input file\n        infile."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nundo the filter for a scanline.", "response": "def undo_filter(self, filter_type, scanline, previous):\n        \"\"\"Undo the filter for a scanline.  `scanline` is a sequence of\n        bytes that does not include the initial filter type byte.\n        `previous` is decoded previous scanline (for straightlaced\n        images this is the previous pixel row, but for interlaced\n        images, it is the previous scanline in the reduced image, which\n        in general is not the previous pixel row in the final image).\n        When there is no previous scanline (the first row of a\n        straightlaced image, or the first row in one of the passes in an\n        interlaced image), then this argument should be ``None``.\n\n        The scanline will have the effects of filtering removed, and the\n        result will be returned as a fresh sequence of bytes.\n        \"\"\"\n\n        # :todo: Would it be better to update scanline in place?\n        # Yes, with the Cython extension making the undo_filter fast,\n        # updating scanline inplace makes the code 3 times faster\n        # (reading 50 images of 800x800 went from 40s to 16s)\n        result = scanline\n\n        if filter_type == 0:\n            return result\n\n        if filter_type not in (1,2,3,4):\n            raise FormatError('Invalid PNG Filter Type.'\n              '  See http://www.w3.org/TR/2003/REC-PNG-20031110/#9Filters .')\n\n        # Filter unit.  The stride from one pixel to the corresponding\n        # byte from the previous pixel.  Normally this is the pixel\n        # size in bytes, but when this is smaller than 1, the previous\n        # byte is used instead.\n        fu = max(1, self.psize)\n\n        # For the first line of a pass, synthesize a dummy previous\n        # line.  An alternative approach would be to observe that on the\n        # first line 'up' is the same as 'null', 'paeth' is the same\n        # as 'sub', with only 'average' requiring any special case.\n        if not previous:\n            previous = array('B', [0]*len(scanline))\n\n        def sub():\n            \"\"\"Undo sub filter.\"\"\"\n\n            ai = 0\n            # Loop starts at index fu.  Observe that the initial part\n            # of the result is already filled in correctly with\n            # scanline.\n            for i in range(fu, len(result)):\n                x = scanline[i]\n                a = result[ai]\n                result[i] = (x + a) & 0xff\n                ai += 1\n\n        def up():\n            \"\"\"Undo up filter.\"\"\"\n\n            for i in range(len(result)):\n                x = scanline[i]\n                b = previous[i]\n                result[i] = (x + b) & 0xff\n\n        def average():\n            \"\"\"Undo average filter.\"\"\"\n\n            ai = -fu\n            for i in range(len(result)):\n                x = scanline[i]\n                if ai < 0:\n                    a = 0\n                else:\n                    a = result[ai]\n                b = previous[i]\n                result[i] = (x + ((a + b) >> 1)) & 0xff\n                ai += 1\n\n        def paeth():\n            \"\"\"Undo Paeth filter.\"\"\"\n\n            # Also used for ci.\n            ai = -fu\n            for i in range(len(result)):\n                x = scanline[i]\n                if ai < 0:\n                    a = c = 0\n                else:\n                    a = result[ai]\n                    c = previous[ai]\n                b = previous[i]\n                p = a + b - c\n                pa = abs(p - a)\n                pb = abs(p - b)\n                pc = abs(p - c)\n                if pa <= pb and pa <= pc:\n                    pr = a\n                elif pb <= pc:\n                    pr = b\n                else:\n                    pr = c\n                result[i] = (x + pr) & 0xff\n                ai += 1\n\n        # Call appropriate filter algorithm.  Note that 0 has already\n        # been dealt with.\n        (None,\n         pngfilters.undo_filter_sub,\n         pngfilters.undo_filter_up,\n         pngfilters.undo_filter_average,\n         pngfilters.undo_filter_paeth)[filter_type](fu, scanline, previous, result)\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef deinterlace(self, raw):\n\n        # Values per row (of the target image)\n        vpr = self.width * self.planes\n\n        # Make a result array, and make it big enough.  Interleaving\n        # writes to the output array randomly (well, not quite), so the\n        # entire output array must be in memory.\n        fmt = 'BH'[self.bitdepth > 8]\n        a = array(fmt, [0]*vpr*self.height)\n        source_offset = 0\n\n        for xstart, ystart, xstep, ystep in _adam7:\n            if xstart >= self.width:\n                continue\n            # The previous (reconstructed) scanline.  None at the\n            # beginning of a pass to indicate that there is no previous\n            # line.\n            recon = None\n            # Pixels per row (reduced pass image)\n            ppr = int(math.ceil((self.width-xstart)/float(xstep)))\n            # Row size in bytes for this pass.\n            row_size = int(math.ceil(self.psize * ppr))\n            for y in range(ystart, self.height, ystep):\n                filter_type = raw[source_offset]\n                source_offset += 1\n                scanline = raw[source_offset:source_offset+row_size]\n                source_offset += row_size\n                recon = self.undo_filter(filter_type, scanline, recon)\n                # Convert so that there is one element per pixel value\n                flat = self.serialtoflat(recon, ppr)\n                if xstep == 1:\n                    assert xstart == 0\n                    offset = y * vpr\n                    a[offset:offset+vpr] = flat\n                else:\n                    offset = y * vpr + xstart * self.planes\n                    end_offset = (y+1) * vpr\n                    skip = self.planes * xstep\n                    for i in range(self.planes):\n                        a[offset+i:end_offset:skip] = \\\n                            flat[i::self.planes]\n        return a", "response": "Read raw pixel data undo filters and flatten the image."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\niterating over the bytes of the bytes of the next boxed scanline in flat pixel format.", "response": "def iterboxed(self, rows):\n        \"\"\"Iterator that yields each scanline in boxed row flat pixel\n        format.  `rows` should be an iterator that yields the bytes of\n        each row in turn.\n        \"\"\"\n\n        def asvalues(raw):\n            \"\"\"Convert a row of raw bytes into a flat row.  Result will\n            be a freshly allocated object, not shared with\n            argument.\n            \"\"\"\n\n            if self.bitdepth == 8:\n                return array('B', raw)\n            if self.bitdepth == 16:\n                raw = tostring(raw)\n                return array('H', struct.unpack('!%dH' % (len(raw)//2), raw))\n            assert self.bitdepth < 8\n            width = self.width\n            # Samples per byte\n            spb = 8//self.bitdepth\n            out = array('B')\n            mask = 2**self.bitdepth - 1\n            shifts = map(self.bitdepth.__mul__, reversed(range(spb)))\n            for o in raw:\n                out.extend(map(lambda i: mask&(o>>i), shifts))\n            return out[:width]\n\n        return imap(asvalues, rows)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nconvert serial format ( byte stream ) pixel data to flat row.", "response": "def serialtoflat(self, bytes, width=None):\n        \"\"\"Convert serial format (byte stream) pixel data to flat row\n        flat pixel.\n        \"\"\"\n\n        if self.bitdepth == 8:\n            return bytes\n        if self.bitdepth == 16:\n            bytes = tostring(bytes)\n            return array('H',\n              struct.unpack('!%dH' % (len(bytes)//2), bytes))\n        assert self.bitdepth < 8\n        if width is None:\n            width = self.width\n        # Samples per byte\n        spb = 8//self.bitdepth\n        out = array('B')\n        mask = 2**self.bitdepth - 1\n        shifts = map(self.bitdepth.__mul__, reversed(range(spb)))\n        l = width\n        for o in bytes:\n            out.extend([(mask&(o>>s)) for s in shifts][:l])\n            l -= spb\n            if l <= 0:\n                l = width\n        return out"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef iterstraight(self, raw):\n\n        # length of row, in bytes\n        rb = self.row_bytes\n        a = array('B')\n        # The previous (reconstructed) scanline.  None indicates first\n        # line of image.\n        recon = None\n        for some in raw:\n            a.extend(some)\n            while len(a) >= rb + 1:\n                filter_type = a[0]\n                scanline = a[1:rb+1]\n                del a[:rb+1]\n                recon = self.undo_filter(filter_type, scanline, recon)\n                yield recon\n        if len(a) != 0:\n            # :file:format We get here with a file format error:\n            # when the available bytes (after decompressing) do not\n            # pack into exact rows.\n            raise FormatError(\n              'Wrong size for decompressed IDAT chunk.')\n        assert len(a) == 0", "response": "Iterator that undoes the effect of filtering and yields\n        each row in serialised format."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nread just enough of the input to determine the next available pair length and type. Returns None if there are no more chunks.", "response": "def chunklentype(self):\n        \"\"\"Reads just enough of the input to determine the next\n        chunk's length and type, returned as a (*length*, *type*) pair\n        where *type* is a string.  If there are no more chunks, ``None``\n        is returned.\n        \"\"\"\n\n        x = self.file.read(8)\n        if not x:\n            return None\n        if len(x) != 8:\n            raise FormatError(\n              'End of file whilst reading chunk length and type.')\n        length,type = struct.unpack('!I4s', x)\n        type = bytestostr(type)\n        if length > 2**31-1:\n            raise FormatError('Chunk %s is too large: %d.' % (type,length))\n        return length,type"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef read(self, lenient=False):\n\n        def iteridat():\n            \"\"\"Iterator that yields all the ``IDAT`` chunks as strings.\"\"\"\n            while True:\n                try:\n                    type, data = self.chunk(lenient=lenient)\n                except ValueError as e:\n                    raise ChunkError(e.args[0])\n                if type == 'IEND':\n                    # http://www.w3.org/TR/PNG/#11IEND\n                    break\n                if type != 'IDAT':\n                    continue\n                # type == 'IDAT'\n                # http://www.w3.org/TR/PNG/#11IDAT\n                if self.colormap and not self.plte:\n                    warnings.warn(\"PLTE chunk is required before IDAT chunk\")\n                yield data\n\n        def iterdecomp(idat):\n            \"\"\"Iterator that yields decompressed strings.  `idat` should\n            be an iterator that yields the ``IDAT`` chunk data.\n            \"\"\"\n\n            # Currently, with no max_length parameter to decompress,\n            # this routine will do one yield per IDAT chunk: Not very\n            # incremental.\n            d = zlib.decompressobj()\n            # Each IDAT chunk is passed to the decompressor, then any\n            # remaining state is decompressed out.\n            for data in idat:\n                # :todo: add a max_length argument here to limit output\n                # size.\n                yield array('B', d.decompress(data))\n            yield array('B', d.flush())\n\n        self.preamble(lenient=lenient)\n        raw = iterdecomp(iteridat())\n\n        if self.interlace:\n            raw = array('B', itertools.chain(*raw))\n            arraycode = 'BH'[self.bitdepth>8]\n            # Like :meth:`group` but producing an array.array object for\n            # each row.\n            pixels = imap(lambda *row: array(arraycode, row),\n                       *[iter(self.deinterlace(raw))]*self.width*self.planes)\n        else:\n            pixels = self.iterboxed(self.iterstraight(raw))\n        meta = dict()\n        for attr in 'greyscale alpha planes bitdepth interlace'.split():\n            meta[attr] = getattr(self, attr)\n        meta['size'] = (self.width, self.height)\n        for attr in 'gamma transparent background'.split():\n            a = getattr(self, attr, None)\n            if a is not None:\n                meta[attr] = a\n        if self.plte:\n            meta['palette'] = self.palette()\n        return self.width, self.height, pixels, meta", "response": "Read the PNG file and decode it."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef palette(self, alpha='natural'):\n\n        if not self.plte:\n            raise FormatError(\n                \"Required PLTE chunk is missing in colour type 3 image.\")\n        plte = group(array('B', self.plte), 3)\n        if self.trns or alpha == 'force':\n            trns = array('B', self.trns or '')\n            trns.extend([255]*(len(plte)-len(trns)))\n            plte = map(operator.add, plte, group(trns, 1))\n        return plte", "response": "Returns a sequence of 3 - tuples or 4 - tuples for the given image."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef asDirect(self):\n\n        self.preamble()\n\n        # Simple case, no conversion necessary.\n        if not self.colormap and not self.trns and not self.sbit:\n            return self.read()\n\n        x,y,pixels,meta = self.read()\n\n        if self.colormap:\n            meta['colormap'] = False\n            meta['alpha'] = bool(self.trns)\n            meta['bitdepth'] = 8\n            meta['planes'] = 3 + bool(self.trns)\n            plte = self.palette()\n            def iterpal(pixels):\n                for row in pixels:\n                    row = map(plte.__getitem__, row)\n                    yield array('B', itertools.chain(*row))\n            pixels = iterpal(pixels)\n        elif self.trns:\n            # It would be nice if there was some reasonable way\n            # of doing this without generating a whole load of\n            # intermediate tuples.  But tuples does seem like the\n            # easiest way, with no other way clearly much simpler or\n            # much faster.  (Actually, the L to LA conversion could\n            # perhaps go faster (all those 1-tuples!), but I still\n            # wonder whether the code proliferation is worth it)\n            it = self.transparent\n            maxval = 2**meta['bitdepth']-1\n            planes = meta['planes']\n            meta['alpha'] = True\n            meta['planes'] += 1\n            typecode = 'BH'[meta['bitdepth']>8]\n            def itertrns(pixels):\n                for row in pixels:\n                    # For each row we group it into pixels, then form a\n                    # characterisation vector that says whether each\n                    # pixel is opaque or not.  Then we convert\n                    # True/False to 0/maxval (by multiplication),\n                    # and add it as the extra channel.\n                    row = group(row, planes)\n                    opa = map(it.__ne__, row)\n                    opa = map(maxval.__mul__, opa)\n                    opa = zip(opa) # convert to 1-tuples\n                    yield array(typecode,\n                      itertools.chain(*map(operator.add, row, opa)))\n            pixels = itertrns(pixels)\n        targetbitdepth = None\n        if self.sbit:\n            sbit = struct.unpack('%dB' % len(self.sbit), self.sbit)\n            targetbitdepth = max(sbit)\n            if targetbitdepth > meta['bitdepth']:\n                raise Error('sBIT chunk %r exceeds bitdepth %d' %\n                    (sbit,self.bitdepth))\n            if min(sbit) <= 0:\n                raise Error('sBIT chunk %r has a 0-entry' % sbit)\n            if targetbitdepth == meta['bitdepth']:\n                targetbitdepth = None\n        if targetbitdepth:\n            shift = meta['bitdepth'] - targetbitdepth\n            meta['bitdepth'] = targetbitdepth\n            def itershift(pixels):\n                for row in pixels:\n                    yield map(shift.__rrshift__, row)\n            pixels = itershift(pixels)\n        return x,y,pixels,meta", "response": "Returns the image data as a direct representation of an anonymization of an anonymization of an image."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn image pixels as per : meth : asDirect method but scale all pixel values to be floating point values between 0. 0 and maxval*.", "response": "def asFloat(self, maxval=1.0):\n        \"\"\"Return image pixels as per :meth:`asDirect` method, but scale\n        all pixel values to be floating point values between 0.0 and\n        *maxval*.\n        \"\"\"\n\n        x,y,pixels,info = self.asDirect()\n        sourcemaxval = 2**info['bitdepth']-1\n        del info['bitdepth']\n        info['maxval'] = float(maxval)\n        factor = float(maxval)/float(sourcemaxval)\n        def iterfloat():\n            for row in pixels:\n                yield map(factor.__mul__, row)\n        return x,y,iterfloat(),info"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef asRGB(self):\n\n        width,height,pixels,meta = self.asDirect()\n        if meta['alpha']:\n            raise Error(\"will not convert image with alpha channel to RGB\")\n        if not meta['greyscale']:\n            return width,height,pixels,meta\n        meta['greyscale'] = False\n        typecode = 'BH'[meta['bitdepth'] > 8]\n        def iterrgb():\n            for row in pixels:\n                a = array(typecode, [0]) * 3 * width\n                for i in range(3):\n                    a[i::3] = row\n                yield a\n        return width,height,iterrgb(),meta", "response": "Return image as RGB pixels."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn image as RGBA pixels.", "response": "def asRGBA(self):\n        \"\"\"Return image as RGBA pixels.  Greyscales are expanded into\n        RGB triplets; an alpha channel is synthesized if necessary.\n        The return values are as for the :meth:`read` method\n        except that the *metadata* reflect the returned pixels, not the\n        source image.  In particular, for this method\n        ``metadata['greyscale']`` will be ``False``, and\n        ``metadata['alpha']`` will be ``True``.\n        \"\"\"\n\n        width,height,pixels,meta = self.asDirect()\n        if meta['alpha'] and not meta['greyscale']:\n            return width,height,pixels,meta\n        typecode = 'BH'[meta['bitdepth'] > 8]\n        maxval = 2**meta['bitdepth'] - 1\n        maxbuffer = struct.pack('=' + typecode, maxval) * 4 * width\n        def newarray():\n            return array(typecode, maxbuffer)\n\n        if meta['alpha'] and meta['greyscale']:\n            # LA to RGBA\n            def convert():\n                for row in pixels:\n                    # Create a fresh target row, then copy L channel\n                    # into first three target channels, and A channel\n                    # into fourth channel.\n                    a = newarray()\n                    pngfilters.convert_la_to_rgba(row, a)\n                    yield a\n        elif meta['greyscale']:\n            # L to RGBA\n            def convert():\n                for row in pixels:\n                    a = newarray()\n                    pngfilters.convert_l_to_rgba(row, a)\n                    yield a\n        else:\n            assert not meta['alpha'] and not meta['greyscale']\n            # RGB to RGBA\n            def convert():\n                for row in pixels:\n                    a = newarray()\n                    pngfilters.convert_rgb_to_rgba(row, a)\n                    yield a\n        meta['alpha'] = True\n        meta['greyscale'] = False\n        return width,height,convert(),meta"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nloads a file from the remote demo - data repository.", "response": "def load_data_file(fname, directory=None, force_download=False):\n    \"\"\"Get a standard vispy demo data file\n\n    Parameters\n    ----------\n    fname : str\n        The filename on the remote ``demo-data`` repository to download,\n        e.g. ``'molecular_viewer/micelle.npy'``. These correspond to paths\n        on ``https://github.com/vispy/demo-data/``.\n    directory : str | None\n        Directory to use to save the file. By default, the vispy\n        configuration directory is used.\n    force_download : bool | str\n        If True, the file will be downloaded even if a local copy exists\n        (and this copy will be overwritten). Can also be a YYYY-MM-DD date\n        to ensure a file is up-to-date (modified date of a file on disk,\n        if present, is checked).\n\n    Returns\n    -------\n    fname : str\n        The path to the file on the local system.\n    \"\"\"\n    _url_root = 'http://github.com/vispy/demo-data/raw/master/'\n    url = _url_root + fname\n    if directory is None:\n        directory = config['data_path']\n        if directory is None:\n            raise ValueError('config[\"data_path\"] is not defined, '\n                             'so directory must be supplied')\n\n    fname = op.join(directory, op.normcase(fname))  # convert to native\n    if op.isfile(fname):\n        if not force_download:  # we're done\n            return fname\n        if isinstance(force_download, string_types):\n            ntime = time.strptime(force_download, '%Y-%m-%d')\n            ftime = time.gmtime(op.getctime(fname))\n            if ftime >= ntime:\n                return fname\n            else:\n                print('File older than %s, updating...' % force_download)\n    if not op.isdir(op.dirname(fname)):\n        os.makedirs(op.abspath(op.dirname(fname)))\n    # let's go get the file\n    _fetch_file(url, fname)\n    return fname"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ndownloads a file chunk by chunk and show advancement", "response": "def _chunk_read(response, local_file, chunk_size=65536, initial_size=0):\n    \"\"\"Download a file chunk by chunk and show advancement\n\n    Can also be used when resuming downloads over http.\n\n    Parameters\n    ----------\n    response: urllib.response.addinfourl\n        Response to the download request in order to get file size.\n    local_file: file\n        Hard disk file where data should be written.\n    chunk_size: integer, optional\n        Size of downloaded chunks. Default: 8192\n    initial_size: int, optional\n        If resuming, indicate the initial size of the file.\n    \"\"\"\n    # Adapted from NISL:\n    # https://github.com/nisl/tutorial/blob/master/nisl/datasets.py\n\n    bytes_so_far = initial_size\n    # Returns only amount left to download when resuming, not the size of the\n    # entire file\n    total_size = int(response.headers['Content-Length'].strip())\n    total_size += initial_size\n\n    progress = ProgressBar(total_size, initial_value=bytes_so_far,\n                           max_chars=40, spinner=True, mesg='downloading')\n    while True:\n        chunk = response.read(chunk_size)\n        bytes_so_far += len(chunk)\n        if not chunk:\n            sys.stderr.write('\\n')\n            break\n        _chunk_write(chunk, local_file, progress)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nwrite a chunk to file and update the progress bar", "response": "def _chunk_write(chunk, local_file, progress):\n    \"\"\"Write a chunk to file and update the progress bar\"\"\"\n    local_file.write(chunk)\n    progress.update_with_increment_value(len(chunk))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ndownload requested file from url and save it to file_name.", "response": "def _fetch_file(url, file_name, print_destination=True):\n    \"\"\"Load requested file, downloading it if needed or requested\n\n    Parameters\n    ----------\n    url: string\n        The url of file to be downloaded.\n    file_name: string\n        Name, along with the path, of where downloaded file will be saved.\n    print_destination: bool, optional\n        If true, destination of where file was saved will be printed after\n        download finishes.\n    \"\"\"\n    # Adapted from NISL:\n    # https://github.com/nisl/tutorial/blob/master/nisl/datasets.py\n\n    temp_file_name = file_name + \".part\"\n    local_file = None\n    initial_size = 0\n    # Checking file size and displaying it alongside the download url\n    n_try = 3\n    for ii in range(n_try):\n        try:\n            data = urllib.request.urlopen(url, timeout=15.)\n        except Exception as e:\n            if ii == n_try - 1:\n                raise RuntimeError('Error while fetching file %s.\\n'\n                                   'Dataset fetching aborted (%s)' % (url, e))\n    try:\n        file_size = int(data.headers['Content-Length'].strip())\n        print('Downloading data from %s (%s)' % (url, sizeof_fmt(file_size)))\n        local_file = open(temp_file_name, \"wb\")\n        _chunk_read(data, local_file, initial_size=initial_size)\n        # temp file must be closed prior to the move\n        if not local_file.closed:\n            local_file.close()\n        shutil.move(temp_file_name, file_name)\n        if print_destination is True:\n            sys.stdout.write('File saved as %s.\\n' % file_name)\n    except Exception as e:\n        raise RuntimeError('Error while fetching file %s.\\n'\n                           'Dataset fetching aborted (%s)' % (url, e))\n    finally:\n        if local_file is not None:\n            if not local_file.closed:\n                local_file.close()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef update(self, cur_value, mesg=None):\n        # Ensure floating-point division so we can get fractions of a percent\n        # for the progressbar.\n        self.cur_value = cur_value\n        progress = float(self.cur_value) / self.max_value\n        num_chars = int(progress * self.max_chars)\n        num_left = self.max_chars - num_chars\n\n        # Update the message\n        if mesg is not None:\n            self.mesg = mesg\n\n        # The \\r tells the cursor to return to the beginning of the line rather\n        # than starting a new line.  This allows us to have a progressbar-style\n        # display in the console window.\n        bar = self.template.format(self.progress_character * num_chars,\n                                   ' ' * num_left,\n                                   progress * 100,\n                                   self.spinner_symbols[self.spinner_index],\n                                   self.mesg)\n        sys.stdout.write(bar)\n        # Increament the spinner\n        if self.spinner:\n            self.spinner_index = (self.spinner_index + 1) % self.n_spinner\n\n        # Force a flush because sometimes when using bash scripts and pipes,\n        # the output is not printed until after the program exits.\n        sys.stdout.flush()", "response": "Update the progressbar with current value of process and message."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nupdating the progressbar with the value of the increment instead of the current value of process as in update", "response": "def update_with_increment_value(self, increment_value, mesg=None):\n        \"\"\"Update progressbar with the value of the increment instead of the\n        current value of process as in update()\n\n        Parameters\n        ----------\n        increment_value : int\n            Value of the increment of process.  The percent of the progressbar\n            will be computed as\n            (self.cur_value + increment_value / max_value) * 100\n        mesg : str\n            Message to display to the right of the progressbar.  If None, the\n            last message provided will be used.  To clear the current message,\n            pass a null string, ''.\n        \"\"\"\n        self.cur_value += increment_value\n        self.update(self.cur_value, mesg)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the default widget that occupies the entire area of the canvas.", "response": "def central_widget(self):\n        \"\"\" Returns the default widget that occupies the entire area of the\n        canvas. \n        \"\"\"\n        if self._central_widget is None:\n            self._central_widget = Widget(size=self.size, parent=self.scene)\n        return self._central_widget"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef render(self, region=None, size=None, bgcolor=None):\n        self.set_current()\n        # Set up a framebuffer to render to\n        offset = (0, 0) if region is None else region[:2]\n        csize = self.size if region is None else region[2:]\n        s = self.pixel_scale\n        size = tuple([x * s for x in csize]) if size is None else size\n        fbo = gloo.FrameBuffer(color=gloo.RenderBuffer(size[::-1]),\n                               depth=gloo.RenderBuffer(size[::-1]))\n\n        self.push_fbo(fbo, offset, csize)\n        try:\n            self._draw_scene(bgcolor=bgcolor)\n            return fbo.read()\n        finally:\n            self.pop_fbo()", "response": "Render the scene to an offscreen buffer and return the image array."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ndrawing a visual and its children to the canvas or currently active one.", "response": "def draw_visual(self, visual, event=None):\n        \"\"\" Draw a visual and its children to the canvas or currently active\n        framebuffer.\n        \n        Parameters\n        ----------\n        visual : Visual\n            The visual to draw\n        event : None or DrawEvent\n            Optionally specifies the original canvas draw event that initiated\n            this draw.\n        \"\"\"\n        prof = Profiler()\n        \n        # make sure this canvas's context is active\n        self.set_current()\n        \n        try:\n            self._drawing = True\n            # get order to draw visuals\n            if visual not in self._draw_order:\n                self._draw_order[visual] = self._generate_draw_order()\n            order = self._draw_order[visual]\n            \n            # draw (while avoiding branches with visible=False)\n            stack = []\n            invisible_node = None\n            for node, start in order:\n                if start:\n                    stack.append(node)\n                    if invisible_node is None:\n                        if not node.visible:\n                            # disable drawing until we exit this node's subtree\n                            invisible_node = node\n                        else:\n                            if hasattr(node, 'draw'):\n                                node.draw()\n                                prof.mark(str(node))\n                else:\n                    if node is invisible_node:\n                        invisible_node = None\n                    stack.pop()\n        finally:\n            self._drawing = False"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngenerating the order to draw visuals.", "response": "def _generate_draw_order(self, node=None):\n        \"\"\"Return a list giving the order to draw visuals.\n        \n        Each node appears twice in the list--(node, True) appears before the\n        node's children are drawn, and (node, False) appears after.\n        \"\"\"\n        if node is None:\n            node = self._scene\n        order = [(node, True)]\n        children = node.children\n        children.sort(key=lambda ch: ch.order)\n        for ch in children:\n            order.extend(self._generate_draw_order(ch))\n        order.append((node, False))\n        return order"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef visual_at(self, pos):\n        tr = self.transforms.get_transform('canvas', 'framebuffer')\n        fbpos = tr.map(pos)[:2]\n\n        try:\n            id_ = self._render_picking(region=(fbpos[0], fbpos[1],\n                                               1, 1))\n            vis = VisualNode._visual_ids.get(id_[0, 0], None)\n        except RuntimeError:\n            # Don't have read_pixels() support for IPython. Fall back to\n            # bounds checking.\n            return self._visual_bounds_at(pos)\n        return vis", "response": "Return the visual at a given position."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _visual_bounds_at(self, pos, node=None):\n        if node is None:\n            node = self.scene\n            \n        for ch in node.children:\n            hit = self._visual_bounds_at(pos, ch)\n            if hit is not None:\n                return hit\n        \n        if (not isinstance(node, VisualNode) or not node.visible or \n                not node.interactive):\n            return None\n        \n        bounds = [node.bounds(axis=i) for i in range(2)]\n        \n        if None in bounds:\n            return None\n        \n        tr = self.scene.node_transform(node).inverse\n        corners = np.array([\n            [bounds[0][0], bounds[1][0]],\n            [bounds[0][0], bounds[1][1]],\n            [bounds[0][1], bounds[1][0]],\n            [bounds[0][1], bounds[1][1]]])\n        bounds = tr.map(corners)\n        xhit = bounds[:, 0].min() < pos[0] < bounds[:, 0].max()\n        yhit = bounds[:, 1].min() < pos[1] < bounds[:, 1].max()\n        if xhit and yhit:\n            return node", "response": "Find a visual whose bounding rect encompasses pos."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a list of visuals within radius pixels of pos.", "response": "def visuals_at(self, pos, radius=10):\n        \"\"\"Return a list of visuals within *radius* pixels of *pos*.\n        \n        Visuals are sorted by their proximity to *pos*.\n        \n        Parameters\n        ----------\n        pos : tuple\n            (x, y) position at which to find visuals.\n        radius : int\n            Distance away from *pos* to search for visuals.\n        \"\"\"\n        tr = self.transforms.get_transform('canvas', 'framebuffer')\n        pos = tr.map(pos)[:2]\n\n        id = self._render_picking(region=(pos[0]-radius, pos[1]-radius,\n                                          radius * 2 + 1, radius * 2 + 1))\n        ids = []\n        seen = set()\n        for i in range(radius):\n            subr = id[radius-i:radius+i+1, radius-i:radius+i+1]\n            subr_ids = set(list(np.unique(subr)))\n            ids.extend(list(subr_ids - seen))\n            seen |= subr_ids\n        visuals = [VisualNode._visual_ids.get(x, None) for x in ids]\n        return [v for v in visuals if v is not None]"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _render_picking(self, **kwargs):\n        try:\n            self._scene.picking = True\n            img = self.render(bgcolor=(0, 0, 0, 0), **kwargs)\n        finally:\n            self._scene.picking = False\n        img = img.astype('int32') * [2**0, 2**8, 2**16, 2**24]\n        id_ = img.sum(axis=2).astype('int32')\n        return id_", "response": "Render the scene in picking mode returning a 2D array of visual \n        IDs."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ndisconnect from the mouse events and notifies the related events that the user has closed the resource.", "response": "def on_close(self, event):\n        \"\"\"Close event handler\n\n        Parameters\n        ----------\n        event : instance of Event\n            The event.\n        \"\"\"\n        self.events.mouse_press.disconnect(self._process_mouse_event)\n        self.events.mouse_move.disconnect(self._process_mouse_event)\n        self.events.mouse_release.disconnect(self._process_mouse_event)\n        self.events.mouse_wheel.disconnect(self._process_mouse_event)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef push_viewport(self, viewport):\n        vp = list(viewport)\n        # Normalize viewport before setting;\n        if vp[2] < 0:\n            vp[0] += vp[2]\n            vp[2] *= -1\n        if vp[3] < 0:\n            vp[1] += vp[3]\n            vp[3] *= -1\n\n        self._vp_stack.append(vp)\n        try:\n            self.context.set_viewport(*vp)\n        except:\n            self._vp_stack.pop()\n            raise\n        \n        self._update_transforms()", "response": "Pushes a viewport on the stack."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\npop a viewport from the stack.", "response": "def pop_viewport(self):\n        \"\"\" Pop a viewport from the stack.\n        \"\"\"\n        vp = self._vp_stack.pop()\n        # Activate latest\n        if len(self._vp_stack) > 0:\n            self.context.set_viewport(*self._vp_stack[-1])\n        else:\n            self.context.set_viewport(0, 0, *self.physical_size)\n        \n        self._update_transforms()\n        return vp"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef push_fbo(self, fbo, offset, csize):\n        self._fb_stack.append((fbo, offset, csize))\n        try:\n            fbo.activate()\n            h, w = fbo.color_buffer.shape[:2]\n            self.push_viewport((0, 0, w, h))\n        except Exception:\n            self._fb_stack.pop()\n            raise\n        \n        self._update_transforms()", "response": "Push a new FBO onto the stack."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef pop_fbo(self):\n        fbo = self._fb_stack.pop()\n        fbo[0].deactivate()\n        self.pop_viewport()\n        if len(self._fb_stack) > 0:\n            old_fbo = self._fb_stack[-1]\n            old_fbo[0].activate()\n        \n        self._update_transforms()\n        return fbo", "response": "Pop an FBO from the stack."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nupdates the canvas s TransformSystem to correct for the current .", "response": "def _update_transforms(self):\n        \"\"\"Update the canvas's TransformSystem to correct for the current \n        canvas size, framebuffer, and viewport.\n        \"\"\"\n        if len(self._fb_stack) == 0:\n            fb_size = fb_rect = None\n        else:\n            fb, origin, fb_size = self._fb_stack[-1]\n            fb_rect = origin + fb_size\n            \n        if len(self._vp_stack) == 0:\n            viewport = None\n        else:\n            viewport = self._vp_stack[-1]\n        \n        self.transforms.configure(viewport=viewport, fbo_size=fb_size,\n                                  fbo_rect=fb_rect)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef resize(self, shape, format=None, internalformat=None):\n        return self._resize(shape, format, internalformat)", "response": "Set the texture size and format of the a\n           ."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsetting the data for the current node in the texture.", "response": "def set_data(self, data, offset=None, copy=False):\n        \"\"\"Set texture data\n\n        Parameters\n        ----------\n        data : ndarray\n            Data to be uploaded\n        offset: int | tuple of ints\n            Offset in texture where to start copying data\n        copy: bool\n            Since the operation is deferred, data may change before\n            data is actually uploaded to GPU memory. Asking explicitly\n            for a copy will prevent this behavior.\n\n        Notes\n        -----\n        This operation implicitely resizes the texture to the shape of\n        the data if given offset is None.\n        \"\"\"\n        return self._set_data(data, offset, copy)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset the data of the current object to be uploaded to GPU memory.", "response": "def set_data(self, data, offset=None, copy=False):\n        \"\"\"Set texture data\n\n        Parameters\n        ----------\n        data : ndarray\n            Data to be uploaded\n        offset: int | tuple of ints\n            Offset in texture where to start copying data\n        copy: bool\n            Since the operation is deferred, data may change before\n            data is actually uploaded to GPU memory. Asking explicitly\n            for a copy will prevent this behavior.\n\n        Notes\n        -----\n        This operation implicitely resizes the texture to the shape of\n        the data if given offset is None.\n        \"\"\"\n        self._set_emulated_shape(data)\n        Texture2D.set_data(self, self._normalize_emulated_shape(data),\n                           offset, copy)\n        self._update_variables()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef resize(self, shape, format=None, internalformat=None):\n        self._set_emulated_shape(shape)\n        Texture2D.resize(self, self._normalize_emulated_shape(shape),\n                         format, internalformat)\n        self._update_variables()", "response": "Set the size and format of the texture."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget a free region of given size and allocate it.", "response": "def get_free_region(self, width, height):\n        \"\"\"Get a free region of given size and allocate it\n\n        Parameters\n        ----------\n        width : int\n            Width of region to allocate\n        height : int\n            Height of region to allocate\n\n        Returns\n        -------\n        bounds : tuple | None\n            A newly allocated region as (x, y, w, h) or None\n            (if failed).\n        \"\"\"\n        best_height = best_width = np.inf\n        best_index = -1\n        for i in range(len(self._atlas_nodes)):\n            y = self._fit(i, width, height)\n            if y >= 0:\n                node = self._atlas_nodes[i]\n                if (y+height < best_height or\n                        (y+height == best_height and node[2] < best_width)):\n                    best_height = y+height\n                    best_index = i\n                    best_width = node[2]\n                    region = node[0], y, width, height\n        if best_index == -1:\n            return None\n\n        node = region[0], region[1] + height, width\n        self._atlas_nodes.insert(best_index, node)\n        i = best_index+1\n        while i < len(self._atlas_nodes):\n            node = self._atlas_nodes[i]\n            prev_node = self._atlas_nodes[i-1]\n            if node[0] < prev_node[0]+prev_node[2]:\n                shrink = prev_node[0]+prev_node[2] - node[0]\n                x, y, w = self._atlas_nodes[i]\n                self._atlas_nodes[i] = x+shrink, y, w-shrink\n                if self._atlas_nodes[i][2] <= 0:\n                    del self._atlas_nodes[i]\n                    i -= 1\n                else:\n                    break\n            else:\n                break\n            i += 1\n\n        # Merge nodes\n        i = 0\n        while i < len(self._atlas_nodes)-1:\n            node = self._atlas_nodes[i]\n            next_node = self._atlas_nodes[i+1]\n            if node[1] == next_node[1]:\n                self._atlas_nodes[i] = node[0], node[1], node[2]+next_node[2]\n                del self._atlas_nodes[i+1]\n            else:\n                i += 1\n\n        return region"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _fit(self, index, width, height):\n        node = self._atlas_nodes[index]\n        x, y = node[0], node[1]\n        width_left = width\n        if x+width > self._shape[1]:\n            return -1\n        i = index\n        while width_left > 0:\n            node = self._atlas_nodes[i]\n            y = max(y, node[1])\n            if y+height > self._shape[0]:\n                return -1\n            width_left -= node[2]\n            i += 1\n        return y", "response": "Test if region ( width height fit into self. _atlas_nodes [ index ]"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _vector_or_scalar(x, type='row'):\n    if isinstance(x, (list, tuple)):\n        x = np.array(x)\n    if isinstance(x, np.ndarray):\n        assert x.ndim == 1\n        if type == 'column':\n            x = x[:, None]\n    return x", "response": "Convert an object to either a scalar or a row or column vector."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _vector(x, type='row'):\n    if isinstance(x, (list, tuple)):\n        x = np.array(x, dtype=np.float32)\n    elif not isinstance(x, np.ndarray):\n        x = np.array([x], dtype=np.float32)\n    assert x.ndim == 1\n    if type == 'column':\n        x = x[:, None]\n    return x", "response": "Convert an object to a row or column vector."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _normalize(x, cmin=None, cmax=None, clip=True):\n    if not isinstance(x, np.ndarray):\n        x = np.array(x)\n    if cmin is None:\n        cmin = x.min()\n    if cmax is None:\n        cmax = x.max()\n    if cmin == cmax:\n        return .5 * np.ones(x.shape)\n    else:\n        cmin, cmax = float(cmin), float(cmax)\n        y = (x - cmin) * 1. / (cmax - cmin)\n        if clip:\n            y = np.clip(y, 0., 1.)\n        return y", "response": "Normalize an array from the range cmin cmax to [ 0 1 ) with optional clipping."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _mix_simple(a, b, x):\n    x = np.clip(x, 0.0, 1.0)\n    return (1.0 - x)*a + x*b", "response": "Mix b with a with proportion x."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nperforming smooth Hermite interpolation between 0 and 1 when edge0 < x < edge1.", "response": "def smoothstep(edge0, edge1, x):\n    \"\"\" performs smooth Hermite interpolation\n        between 0 and 1 when edge0 < x < edge1.  \"\"\"\n    # Scale, bias and saturate x to 0..1 range\n    x = np.clip((x - edge0)/(edge1 - edge0), 0.0, 1.0)\n    # Evaluate polynomial\n    return x*x*(3 - 2*x)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nstep interpolation from a set of colors. x belongs in [ 0 1 ).", "response": "def step(colors, x, controls=None):\n    x = x.ravel()\n    \"\"\"Step interpolation from a set of colors. x belongs in [0, 1].\"\"\"\n    assert (controls[0], controls[-1]) == (0., 1.)\n    ncolors = len(colors)\n    assert ncolors == len(controls) - 1\n    assert ncolors >= 2\n    x_step = _find_controls(x, controls, ncolors-1)\n    return colors[x_step, ...]"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _glsl_mix(controls=None):\n    assert (controls[0], controls[-1]) == (0., 1.)\n    ncolors = len(controls)\n    assert ncolors >= 2\n    if ncolors == 2:\n        s = \"    return mix($color_0, $color_1, t);\\n\"\n    else:\n        s = \"\"\n        for i in range(ncolors-1):\n            if i == 0:\n                ifs = 'if (t < %.6f)' % (controls[i+1])\n            elif i == (ncolors-2):\n                ifs = 'else'\n            else:\n                ifs = 'else if (t < %.6f)' % (controls[i+1])\n            adj_t = '(t - %s) / %s' % (controls[i],\n                                       controls[i+1] - controls[i])\n            s += (\"%s {\\n    return mix($color_%d, $color_%d, %s);\\n} \" %\n                  (ifs, i, i+1, adj_t))\n    return \"vec4 colormap(float t) {\\n%s\\n}\" % s", "response": "Generate a GLSL template function from a given interpolation patterns\n    and control points."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _process_glsl_template(template, colors):\n    for i in range(len(colors) - 1, -1, -1):\n        color = colors[i]\n        assert len(color) == 4\n        vec4_color = 'vec4(%.3f, %.3f, %.3f, %.3f)' % tuple(color)\n        template = template.replace('$color_%d' % i, vec4_color)\n    return template", "response": "Replace color_i by color i in the GLSL template."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nobtain a colormap from the _colormaps dictionary.", "response": "def get_colormap(name, *args, **kwargs):\n    \"\"\"Obtain a colormap\n\n    Some colormaps can have additional configuration parameters. Refer to\n    their corresponding documentation for more information.\n\n    Parameters\n    ----------\n    name : str | Colormap\n        Colormap name. Can also be a Colormap for pass-through.\n\n    Examples\n    --------\n\n        >>> get_colormap('autumn')\n        >>> get_colormap('single_hue', hue=10)\n    \"\"\"\n    if isinstance(name, BaseColormap):\n        cmap = name\n    else:\n        if not isinstance(name, string_types):\n            raise TypeError('colormap must be a Colormap or string name')\n        if name not in _colormaps:\n            raise KeyError('colormap name %s not found' % name)\n        cmap = _colormaps[name]\n\n        if inspect.isclass(cmap):\n            cmap = cmap(*args, **kwargs)\n\n    return cmap"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the Python mapping function from the 0 1 interval to a list of rgba colors.", "response": "def map(self, x):\n        \"\"\"The Python mapping function from the [0,1] interval to a\n        list of rgba colors\n\n        Parameters\n        ----------\n        x : array-like\n            The values to map.\n\n        Returns\n        -------\n        colors : list\n            List of rgba colors.\n        \"\"\"\n        return self._map_function(self.colors.rgba, x, self._controls)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef visual_border_width(self):\n        render_to_doc =  \\\n            self.transforms.get_transform('document', 'visual')\n\n        vec = render_to_doc.map([self.border_width, self.border_width, 0])\n        origin = render_to_doc.map([0, 0, 0])\n\n        visual_border_width = [vec[0] - origin[0], vec[1] - origin[1]]\n\n        # we need to flip the y axis because coordinate systems are inverted\n        visual_border_width[1] *= -1\n\n        return visual_border_width", "response": "The border width in visual coordinates"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef run(self, fig):\n        # Calling savefig executes the draw() command, putting elements\n        # in the correct place.\n        fig.savefig(io.BytesIO(), format='png', dpi=fig.dpi)\n        if self.close_mpl:\n            import matplotlib.pyplot as plt\n            plt.close(fig)\n        self.crawl_fig(fig)", "response": "Run the exporter on the given figure"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nprocess the transform and convert data to figure or data coordinates.", "response": "def process_transform(transform, ax=None, data=None, return_trans=False,\n                          force_trans=None):\n        \"\"\"Process the transform and convert data to figure or data coordinates\n\n        Parameters\n        ----------\n        transform : matplotlib Transform object\n            The transform applied to the data\n        ax : matplotlib Axes object (optional)\n            The axes the data is associated with\n        data : ndarray (optional)\n            The array of data to be transformed.\n        return_trans : bool (optional)\n            If true, return the final transform of the data\n        force_trans : matplotlib.transform instance (optional)\n            If supplied, first force the data to this transform\n\n        Returns\n        -------\n        code : string\n            Code is either \"data\", \"axes\", \"figure\", or \"display\", indicating\n            the type of coordinates output.\n        transform : matplotlib transform\n            the transform used to map input data to output data.\n            Returned only if return_trans is True\n        new_data : ndarray\n            Data transformed to match the given coordinate code.\n            Returned only if data is specified\n        \"\"\"\n        if isinstance(transform, transforms.BlendedGenericTransform):\n            warnings.warn(\"Blended transforms not yet supported. \"\n                          \"Zoom behavior may not work as expected.\")\n\n        if force_trans is not None:\n            if data is not None:\n                data = (transform - force_trans).transform(data)\n            transform = force_trans\n\n        code = \"display\"\n        if ax is not None:\n            for (c, trans) in [(\"data\", ax.transData),\n                               (\"axes\", ax.transAxes),\n                               (\"figure\", ax.figure.transFigure),\n                               (\"display\", transforms.IdentityTransform())]:\n                if transform.contains_branch(trans):\n                    code, transform = (c, transform - trans)\n                    break\n\n        if data is not None:\n            if return_trans:\n                return code, transform.transform(data), transform\n            else:\n                return code, transform.transform(data)\n        else:\n            if return_trans:\n                return code, transform\n            else:\n                return code"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncrawl the figure and process all axes", "response": "def crawl_fig(self, fig):\n        \"\"\"Crawl the figure and process all axes\"\"\"\n        with self.renderer.draw_figure(fig=fig,\n                                       props=utils.get_figure_properties(fig)):\n            for ax in fig.axes:\n                self.crawl_ax(ax)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncrawl the axes and process all elements within the axes.", "response": "def crawl_ax(self, ax):\n        \"\"\"Crawl the axes and process all elements within\"\"\"\n        with self.renderer.draw_axes(ax=ax,\n                                     props=utils.get_axes_properties(ax)):\n            for line in ax.lines:\n                self.draw_line(ax, line)\n            for text in ax.texts:\n                self.draw_text(ax, text)\n            for (text, ttp) in zip([ax.xaxis.label, ax.yaxis.label, ax.title],\n                                   [\"xlabel\", \"ylabel\", \"title\"]):\n                if(hasattr(text, 'get_text') and text.get_text()):\n                    self.draw_text(ax, text, force_trans=ax.transAxes,\n                                   text_type=ttp)\n            for artist in ax.artists:\n                # TODO: process other artists\n                if isinstance(artist, matplotlib.text.Text):\n                    self.draw_text(ax, artist)\n            for patch in ax.patches:\n                self.draw_patch(ax, patch)\n            for collection in ax.collections:\n                self.draw_collection(ax, collection)\n            for image in ax.images:\n                self.draw_image(ax, image)\n\n            legend = ax.get_legend()\n            if legend is not None:\n                props = utils.get_legend_properties(ax, legend)\n                with self.renderer.draw_legend(legend=legend, props=props):\n                    if props['visible']:\n                        self.crawl_legend(ax, legend)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef crawl_legend(self, ax, legend):\n        legendElements = list(utils.iter_all_children(legend._legend_box,\n                                                      skipContainers=True))\n        legendElements.append(legend.legendPatch)\n        for child in legendElements:\n            # force a large zorder so it appears on top\n            child.set_zorder(1E6 + child.get_zorder())\n\n            try:\n                # What kind of object...\n                if isinstance(child, matplotlib.patches.Patch):\n                    self.draw_patch(ax, child, force_trans=ax.transAxes)\n                elif isinstance(child, matplotlib.text.Text):\n                    if not (child is legend.get_children()[-1]\n                            and child.get_text() == 'None'):\n                        self.draw_text(ax, child, force_trans=ax.transAxes)\n                elif isinstance(child, matplotlib.lines.Line2D):\n                    self.draw_line(ax, child, force_trans=ax.transAxes)\n                elif isinstance(child, matplotlib.collections.Collection):\n                    self.draw_collection(ax, child,\n                                         force_pathtrans=ax.transAxes)\n                else:\n                    warnings.warn(\"Legend element %s not impemented\" % child)\n            except NotImplementedError:\n                warnings.warn(\"Legend element %s not impemented\" % child)", "response": "Recursively look through objects in legend and draw them."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef draw_line(self, ax, line, force_trans=None):\n        coordinates, data = self.process_transform(line.get_transform(),\n                                                   ax, line.get_xydata(),\n                                                   force_trans=force_trans)\n        linestyle = utils.get_line_style(line)\n        if linestyle['dasharray'] is None:\n            linestyle = None\n        markerstyle = utils.get_marker_style(line)\n        if (markerstyle['marker'] in ['None', 'none', None]\n                or markerstyle['markerpath'][0].size == 0):\n            markerstyle = None\n        label = line.get_label()\n        if markerstyle or linestyle:\n            self.renderer.draw_marked_line(data=data, coordinates=coordinates,\n                                           linestyle=linestyle,\n                                           markerstyle=markerstyle,\n                                           label=label,\n                                           mplobj=line)", "response": "Process a matplotlib line and call renderer. draw_line"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef draw_text(self, ax, text, force_trans=None, text_type=None):\n        content = text.get_text()\n        if content:\n            transform = text.get_transform()\n            position = text.get_position()\n            coords, position = self.process_transform(transform, ax,\n                                                      position,\n                                                      force_trans=force_trans)\n            style = utils.get_text_style(text)\n            self.renderer.draw_text(text=content, position=position,\n                                    coordinates=coords,\n                                    text_type=text_type,\n                                    style=style, mplobj=text)", "response": "Process a matplotlib text object and call renderer. draw_text"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nprocesses a matplotlib patch object and call renderer. draw_path", "response": "def draw_patch(self, ax, patch, force_trans=None):\n        \"\"\"Process a matplotlib patch object and call renderer.draw_path\"\"\"\n        vertices, pathcodes = utils.SVG_path(patch.get_path())\n        transform = patch.get_transform()\n        coordinates, vertices = self.process_transform(transform,\n                                                       ax, vertices,\n                                                       force_trans=force_trans)\n        linestyle = utils.get_path_style(patch, fill=patch.get_fill())\n        self.renderer.draw_path(data=vertices,\n                                coordinates=coordinates,\n                                pathcodes=pathcodes,\n                                style=linestyle,\n                                mplobj=patch)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef draw_collection(self, ax, collection,\n                        force_pathtrans=None,\n                        force_offsettrans=None):\n        \"\"\"Process a matplotlib collection and call renderer.draw_collection\"\"\"\n        (transform, transOffset,\n         offsets, paths) = collection._prepare_points()\n\n        offset_coords, offsets = self.process_transform(\n            transOffset, ax, offsets, force_trans=force_offsettrans)\n        path_coords = self.process_transform(\n            transform, ax, force_trans=force_pathtrans)\n\n        processed_paths = [utils.SVG_path(path) for path in paths]\n        processed_paths = [(self.process_transform(\n            transform, ax, path[0], force_trans=force_pathtrans)[1], path[1])\n            for path in processed_paths]\n\n        path_transforms = collection.get_transforms()\n        try:\n            # matplotlib 1.3: path_transforms are transform objects.\n            # Convert them to numpy arrays.\n            path_transforms = [t.get_matrix() for t in path_transforms]\n        except AttributeError:\n            # matplotlib 1.4: path transforms are already numpy arrays.\n            pass\n\n        styles = {'linewidth': collection.get_linewidths(),\n                  'facecolor': collection.get_facecolors(),\n                  'edgecolor': collection.get_edgecolors(),\n                  'alpha': collection._alpha,\n                  'zorder': collection.get_zorder()}\n\n        offset_dict = {\"data\": \"before\",\n                       \"screen\": \"after\"}\n        offset_order = offset_dict[collection.get_offset_position()]\n\n        self.renderer.draw_path_collection(paths=processed_paths,\n                                           path_coordinates=path_coords,\n                                           path_transforms=path_transforms,\n                                           offsets=offsets,\n                                           offset_coordinates=offset_coords,\n                                           offset_order=offset_order,\n                                           styles=styles,\n                                           mplobj=collection)", "response": "Process a matplotlib collection and call renderer. draw_path_collection"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef draw_image(self, ax, image):\n        self.renderer.draw_image(imdata=utils.image_to_base64(image),\n                                 extent=image.get_extent(),\n                                 coordinates=\"data\",\n                                 style={\"alpha\": image.get_alpha(),\n                                        \"zorder\": image.get_zorder()},\n                                 mplobj=image)", "response": "Process a matplotlib image object and call renderer. draw_image"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef draw_marked_line(self, data, coordinates, linestyle, markerstyle,\n                         label, mplobj=None):\n        \"\"\"Draw a line that also has markers.\n\n        If this isn't reimplemented by a renderer object, by default, it will\n        make a call to BOTH draw_line and draw_markers when both markerstyle\n        and linestyle are not None in the same Line2D object.\n\n        \"\"\"\n        if linestyle is not None:\n            self.draw_line(data, coordinates, linestyle, label, mplobj)\n        if markerstyle is not None:\n            self.draw_markers(data, coordinates, markerstyle, label, mplobj)", "response": "Draw a line that also has markers."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ndraw a line from the data coordinates and style.", "response": "def draw_line(self, data, coordinates, style, label, mplobj=None):\n        \"\"\"\n        Draw a line. By default, draw the line via the draw_path() command.\n        Some renderers might wish to override this and provide more\n        fine-grained behavior.\n\n        In matplotlib, lines are generally created via the plt.plot() command,\n        though this command also can create marker collections.\n\n        Parameters\n        ----------\n        data : array_like\n            A shape (N, 2) array of datapoints.\n        coordinates : string\n            A string code, which should be either 'data' for data coordinates,\n            or 'figure' for figure (pixel) coordinates.\n        style : dictionary\n            a dictionary specifying the appearance of the line.\n        mplobj : matplotlib object\n            the matplotlib plot element which generated this line\n        \"\"\"\n        pathcodes = ['M'] + (data.shape[0] - 1) * ['L']\n        pathstyle = dict(facecolor='none', **style)\n        pathstyle['edgecolor'] = pathstyle.pop('color')\n        pathstyle['edgewidth'] = pathstyle.pop('linewidth')\n        self.draw_path(data=data, coordinates=coordinates,\n                       pathcodes=pathcodes, style=pathstyle, mplobj=mplobj)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nbuild an iterator over the elements of the path collection", "response": "def _iter_path_collection(paths, path_transforms, offsets, styles):\n        \"\"\"Build an iterator over the elements of the path collection\"\"\"\n        N = max(len(paths), len(offsets))\n\n        if not path_transforms:\n            path_transforms = [np.eye(3)]\n\n        edgecolor = styles['edgecolor']\n        if np.size(edgecolor) == 0:\n            edgecolor = ['none']\n        facecolor = styles['facecolor']\n        if np.size(facecolor) == 0:\n            facecolor = ['none']\n\n        elements = [paths, path_transforms, offsets,\n                    edgecolor, styles['linewidth'], facecolor]\n\n        it = itertools\n        return it.islice(py3k.zip(*py3k.map(it.cycle, elements)), N)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ndraws a collection of paths.", "response": "def draw_path_collection(self, paths, path_coordinates, path_transforms,\n                             offsets, offset_coordinates, offset_order,\n                             styles, mplobj=None):\n        \"\"\"\n        Draw a collection of paths. The paths, offsets, and styles are all\n        iterables, and the number of paths is max(len(paths), len(offsets)).\n\n        By default, this is implemented via multiple calls to the draw_path()\n        function. For efficiency, Renderers may choose to customize this\n        implementation.\n\n        Examples of path collections created by matplotlib are scatter plots,\n        histograms, contour plots, and many others.\n\n        Parameters\n        ----------\n        paths : list\n            list of tuples, where each tuple has two elements:\n            (data, pathcodes).  See draw_path() for a description of these.\n        path_coordinates: string\n            the coordinates code for the paths, which should be either\n            'data' for data coordinates, or 'figure' for figure (pixel)\n            coordinates.\n        path_transforms: array_like\n            an array of shape (*, 3, 3), giving a series of 2D Affine\n            transforms for the paths. These encode translations, rotations,\n            and scalings in the standard way.\n        offsets: array_like\n            An array of offsets of shape (N, 2)\n        offset_coordinates : string\n            the coordinates code for the offsets, which should be either\n            'data' for data coordinates, or 'figure' for figure (pixel)\n            coordinates.\n        offset_order : string\n            either \"before\" or \"after\". This specifies whether the offset\n            is applied before the path transform, or after.  The matplotlib\n            backend equivalent is \"before\"->\"data\", \"after\"->\"screen\".\n        styles: dictionary\n            A dictionary in which each value is a list of length N, containing\n            the style(s) for the paths.\n        mplobj : matplotlib object\n            the matplotlib plot element which generated this collection\n        \"\"\"\n        if offset_order == \"before\":\n            raise NotImplementedError(\"offset before transform\")\n\n        for tup in self._iter_path_collection(paths, path_transforms,\n                                              offsets, styles):\n            (path, path_transform, offset, ec, lw, fc) = tup\n            vertices, pathcodes = path\n            path_transform = transforms.Affine2D(path_transform)\n            vertices = path_transform.transform(vertices)\n            # This is a hack:\n            if path_coordinates == \"figure\":\n                path_coordinates = \"points\"\n            style = {\"edgecolor\": utils.color_to_hex(ec),\n                     \"facecolor\": utils.color_to_hex(fc),\n                     \"edgewidth\": lw,\n                     \"dasharray\": \"10,0\",\n                     \"alpha\": styles['alpha'],\n                     \"zorder\": styles['zorder']}\n            self.draw_path(data=vertices, coordinates=path_coordinates,\n                           pathcodes=pathcodes, style=style, offset=offset,\n                           offset_coordinates=offset_coordinates,\n                           mplobj=mplobj)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ndraw a set of markers for the current object.", "response": "def draw_markers(self, data, coordinates, style, label, mplobj=None):\n        \"\"\"\n        Draw a set of markers. By default, this is done by repeatedly\n        calling draw_path(), but renderers should generally overload\n        this method to provide a more efficient implementation.\n\n        In matplotlib, markers are created using the plt.plot() command.\n\n        Parameters\n        ----------\n        data : array_like\n            A shape (N, 2) array of datapoints.\n        coordinates : string\n            A string code, which should be either 'data' for data coordinates,\n            or 'figure' for figure (pixel) coordinates.\n        style : dictionary\n            a dictionary specifying the appearance of the markers.\n        mplobj : matplotlib object\n            the matplotlib plot element which generated this marker collection\n        \"\"\"\n        vertices, pathcodes = style['markerpath']\n        pathstyle = dict((key, style[key]) for key in ['alpha', 'edgecolor',\n                                                       'facecolor', 'zorder',\n                                                       'edgewidth'])\n        pathstyle['dasharray'] = \"10,0\"\n        for vertex in data:\n            self.draw_path(data=vertices, coordinates=\"points\",\n                           pathcodes=pathcodes, style=pathstyle,\n                           offset=vertex, offset_coordinates=coordinates,\n                           mplobj=mplobj)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndraw a path from the data coordinates and pathcodes associated with the data.", "response": "def draw_path(self, data, coordinates, pathcodes, style,\n                  offset=None, offset_coordinates=\"data\", mplobj=None):\n        \"\"\"\n        Draw a path.\n\n        In matplotlib, paths are created by filled regions, histograms,\n        contour plots, patches, etc.\n\n        Parameters\n        ----------\n        data : array_like\n            A shape (N, 2) array of datapoints.\n        coordinates : string\n            A string code, which should be either 'data' for data coordinates,\n            'figure' for figure (pixel) coordinates, or \"points\" for raw\n            point coordinates (useful in conjunction with offsets, below).\n        pathcodes : list\n            A list of single-character SVG pathcodes associated with the data.\n            Path codes are one of ['M', 'm', 'L', 'l', 'Q', 'q', 'T', 't',\n                                   'S', 's', 'C', 'c', 'Z', 'z']\n            See the SVG specification for details.  Note that some path codes\n            consume more than one datapoint (while 'Z' consumes none), so\n            in general, the length of the pathcodes list will not be the same\n            as that of the data array.\n        style : dictionary\n            a dictionary specifying the appearance of the line.\n        offset : list (optional)\n            the (x, y) offset of the path. If not given, no offset will\n            be used.\n        offset_coordinates : string (optional)\n            A string code, which should be either 'data' for data coordinates,\n            or 'figure' for figure (pixel) coordinates.\n        mplobj : matplotlib object\n            the matplotlib plot element which generated this path\n        \"\"\"\n        raise NotImplementedError()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate a TimeMOC from an astropy. time. Time object.", "response": "def from_times(cls, times, delta_t=DEFAULT_OBSERVATION_TIME):\n        \"\"\"\n        Create a TimeMOC from a `astropy.time.Time`\n\n        Parameters\n        ----------\n        times : `astropy.time.Time`\n            astropy observation times\n        delta_t : `astropy.time.TimeDelta`, optional\n            the duration of one observation. It is set to 30 min by default. This data is used to compute the\n            more efficient TimeMOC order to represent the observations (Best order = the less precise order which\n            is able to discriminate two observations separated by ``delta_t``).\n\n        Returns\n        -------\n        time_moc : `~mocpy.tmoc.TimeMOC`\n        \"\"\"\n        times_arr = np.asarray(times.jd * TimeMOC.DAY_MICRO_SEC, dtype=int)\n        intervals_arr = np.vstack((times_arr, times_arr + 1)).T\n\n        # degrade the TimeMoc to the order computer from ``delta_t``\n        order = TimeMOC.time_resolution_to_order(delta_t)\n        return TimeMOC(IntervalSet(intervals_arr)).degrade_to_order(order)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating a TimeMOC from a range defined by two astropy. time. Time objects.", "response": "def from_time_ranges(cls, min_times, max_times, delta_t=DEFAULT_OBSERVATION_TIME):\n        \"\"\"\n        Create a TimeMOC from a range defined by two `astropy.time.Time`\n\n        Parameters\n        ----------\n        min_times : `astropy.time.Time`\n            astropy times defining the left part of the intervals\n        max_times : `astropy.time.Time`\n            astropy times defining the right part of the intervals\n        delta_t : `astropy.time.TimeDelta`, optional\n            the duration of one observation. It is set to 30 min by default. This data is used to compute the\n            more efficient TimeMOC order to represent the observations (Best order = the less precise order which\n            is able to discriminate two observations separated by ``delta_t``).\n\n        Returns\n        -------\n        time_moc : `~mocpy.tmoc.TimeMOC`\n        \"\"\"\n        min_times_arr = np.asarray(min_times.jd * TimeMOC.DAY_MICRO_SEC, dtype=int)\n        max_times_arr = np.asarray(max_times.jd * TimeMOC.DAY_MICRO_SEC, dtype=int)\n\n        intervals_arr = np.vstack((min_times_arr, max_times_arr + 1)).T\n\n        # degrade the TimeMoc to the order computer from ``delta_t``\n        order = TimeMOC.time_resolution_to_order(delta_t)\n        return TimeMOC(IntervalSet(intervals_arr)).degrade_to_order(order)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nadds all the pixels at max order in the neighbourhood of the moc", "response": "def add_neighbours(self):\n        \"\"\"\n        Add all the pixels at max order in the neighbourhood of the moc\n\n        \"\"\"\n        time_delta = 1 << (2*(IntervalSet.HPY_MAX_ORDER - self.max_order))\n\n        intervals_arr = self._interval_set._intervals\n        intervals_arr[:, 0] = np.maximum(intervals_arr[:, 0] - time_delta, 0)\n        intervals_arr[:, 1] = np.minimum(intervals_arr[:, 1] + time_delta, (1 << 58) - 1)\n\n        self._interval_set = IntervalSet(intervals_arr)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nremove all the pixels at max order located at the bound of the moc", "response": "def remove_neighbours(self):\n        \"\"\"\n        Remove all the pixels at max order located at the bound of the moc\n\n        \"\"\"\n        time_delta = 1 << (2*(IntervalSet.HPY_MAX_ORDER - self.max_order))\n\n        intervals_arr = self._interval_set._intervals\n        intervals_arr[:, 0] = np.minimum(intervals_arr[:, 0] + time_delta, (1 << 58) - 1)\n        intervals_arr[:, 1] = np.maximum(intervals_arr[:, 1] - time_delta, 0)\n\n        good_intervals = intervals_arr[:, 1] > intervals_arr[:, 0]\n\n        self._interval_set = IntervalSet(intervals_arr[good_intervals])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nprocess the degradation of self and another_moc.", "response": "def _process_degradation(self, another_moc, order_op):\n        \"\"\"\n        Degrade (down-sampling) self and ``another_moc`` to ``order_op`` order\n\n        Parameters\n        ----------\n        another_moc : `~mocpy.tmoc.TimeMoc`\n        order_op : int\n            the order in which self and ``another_moc`` will be down-sampled to.\n\n        Returns\n        -------\n        result : (`~mocpy.tmoc.TimeMoc`, `~mocpy.tmoc.TimeMoc`)\n            self and ``another_moc`` degraded TimeMocs\n\n        \"\"\"\n        max_order = max(self.max_order, another_moc.max_order)\n        if order_op > max_order:\n            message = 'Requested time resolution for the operation cannot be applied.\\n' \\\n                      'The TimeMoc object resulting from the operation is of time resolution {0} sec.'.format(\n                TimeMOC.order_to_time_resolution(max_order).sec)\n            warnings.warn(message, UserWarning)\n\n        self_degradation = self.degrade_to_order(order_op)\n        another_moc_degradation = another_moc.degrade_to_order(order_op)\n\n        result = self_degradation, another_moc_degradation\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef intersection(self, another_moc, delta_t=DEFAULT_OBSERVATION_TIME):\n\n        order_op = TimeMOC.time_resolution_to_order(delta_t)\n\n        self_degraded, moc_degraded = self._process_degradation(another_moc, order_op)\n        return super(TimeMOC, self_degraded).intersection(moc_degraded)", "response": "Intersection between self and another_moc."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef total_duration(self):\n\n        if self._interval_set.empty():\n            return 0\n\n        total_time_us = 0\n        # The interval set is checked for consistency before looping over all the intervals\n        for (start_time, stop_time) in self._interval_set._intervals:\n            total_time_us = total_time_us + (stop_time - start_time)\n\n        duration = TimeDelta(total_time_us / 1e6, format='sec', scale='tdb')\n        return duration", "response": "Get the total duration covered by the temporal moc\n           "}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef consistency(self):\n\n        result = self.total_duration.jd / (self.max_time - self.min_time).jd\n        return result", "response": "Get the percentage of fill between the min and max time of the moc."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef min_time(self):\n\n        min_time = Time(self._interval_set.min / TimeMOC.DAY_MICRO_SEC, format='jd', scale='tdb')\n        return min_time", "response": "Returns the minimum time of the tmoc first observation"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting the max time of the tmoc last observation", "response": "def max_time(self):\n        \"\"\"\n        Get the `~astropy.time.Time` time of the tmoc last observation\n\n        Returns\n        -------\n        max_time : `~astropy.time.Time`\n            time of the last observation\n\n        \"\"\"\n\n        max_time = Time(self._interval_set.max / TimeMOC.DAY_MICRO_SEC, format='jd', scale='tdb')\n        return max_time"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a mask array that contains the values of the given times in the object.", "response": "def contains(self, times, keep_inside=True, delta_t=DEFAULT_OBSERVATION_TIME):\n        \"\"\"\n        Get a mask array (e.g. a numpy boolean array) of times being inside (or outside) the\n        TMOC instance.\n\n        Parameters\n        ----------\n        times : `astropy.time.Time`\n            astropy times to check whether they are contained in the TMOC or not.\n        keep_inside : bool, optional\n            True by default. If so the filtered table contains only observations that are located the MOC.\n            If ``keep_inside`` is False, the filtered table contains all observations lying outside the MOC.\n        delta_t : `astropy.time.TimeDelta`, optional\n            the duration of one observation. It is set to 30 min by default. This data is used to compute the\n            more efficient TimeMOC order to represent the observations (Best order = the less precise order which\n            is able to discriminate two observations separated by ``delta_t``).\n\n        Returns\n        -------\n        array : `~numpy.darray`\n            A mask boolean array\n        \"\"\"\n        # the requested order for filtering the astropy observations table is more precise than the order\n        # of the TimeMoc object\n        current_max_order = self.max_order\n        new_max_order = TimeMOC.time_resolution_to_order(delta_t)\n        if new_max_order > current_max_order:\n            message = 'Requested time resolution filtering cannot be applied.\\n' \\\n                      'Filtering is applied with a time resolution of {0} sec.'.format(\n                TimeMOC.order_to_time_resolution(current_max_order).sec)\n            warnings.warn(message, UserWarning)\n\n        rough_tmoc = self.degrade_to_order(new_max_order)\n\n        pix_arr = (times.jd * TimeMOC.DAY_MICRO_SEC)\n        pix_arr = pix_arr.astype(int)\n\n        intervals_arr = rough_tmoc._interval_set._intervals\n        inf_arr = np.vstack([pix_arr[i] >= intervals_arr[:, 0] for i in range(pix_arr.shape[0])])\n        sup_arr = np.vstack([pix_arr[i] <= intervals_arr[:, 1] for i in range(pix_arr.shape[0])])\n\n        if keep_inside:\n            res = inf_arr & sup_arr\n            filtered_rows = np.any(res, axis=1)\n        else:\n            res = ~inf_arr | ~sup_arr\n            filtered_rows = np.all(res, axis=1)\n\n        return filtered_rows"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nplot the time of the object in a time window.", "response": "def plot(self, title='TimeMoc', view=(None, None)):\n        \"\"\"\n        Plot the TimeMoc in a time window.\n\n        This method uses interactive matplotlib. The user can move its mouse through the plot to see the\n        time (at the mouse position).\n\n        Parameters\n        ----------\n        title : str, optional\n            The title of the plot. Set to 'TimeMoc' by default.\n        view : (`~astropy.time.Time`, `~astropy.time.Time`), optional\n            Define the view window in which the observations are plotted. Set to (None, None) by default (i.e.\n            all the observation time window is rendered).\n\n        \"\"\"\n        from matplotlib.colors import LinearSegmentedColormap\n        import matplotlib.pyplot as plt\n\n        if self._interval_set.empty():\n            print('Nothing to print. This TimeMoc object is empty.')\n            return\n\n        plot_order = 15\n        if self.max_order > plot_order:\n            plotted_moc = self.degrade_to_order(plot_order)\n        else:\n            plotted_moc = self\n\n        min_jd = plotted_moc.min_time.jd if not view[0] else view[0].jd\n        max_jd = plotted_moc.max_time.jd if not view[1] else view[1].jd\n\n        if max_jd < min_jd:\n            raise ValueError(\"Invalid selection: max_jd = {0} must be > to min_jd = {1}\".format(max_jd, min_jd))\n\n        fig1 = plt.figure(figsize=(9.5, 5))\n        ax = fig1.add_subplot(111)\n\n        ax.set_xlabel('iso')\n        ax.get_yaxis().set_visible(False)\n\n        size = 2000\n        delta = (max_jd - min_jd) / size\n        min_jd_time = min_jd\n\n        ax.set_xticks([0, size])\n        ax.set_xticklabels(Time([min_jd_time, max_jd], format='jd', scale='tdb').iso, rotation=70)\n\n        y = np.zeros(size)\n        for (s_time_us, e_time_us) in plotted_moc._interval_set._intervals:\n            s_index = int((s_time_us / TimeMOC.DAY_MICRO_SEC - min_jd_time) / delta)\n            e_index = int((e_time_us / TimeMOC.DAY_MICRO_SEC - min_jd_time) / delta)\n            y[s_index:(e_index+1)] = 1.0\n\n        # hack in case of full time mocs.\n        if np.all(y):\n            y[0] = 0\n\n        z = np.tile(y, (int(size//10), 1))\n\n        plt.title(title)\n\n        color_map = LinearSegmentedColormap.from_list('w2r', ['#fffff0', '#aa0000'])\n        color_map.set_under('w')\n        color_map.set_bad('gray')\n\n        plt.imshow(z, interpolation='bilinear', cmap=color_map)\n\n        def on_mouse_motion(event):\n            for txt in ax.texts:\n                txt.set_visible(False)\n\n            text = ax.text(0, 0, \"\", va=\"bottom\", ha=\"left\")\n\n            time = Time(event.xdata * delta + min_jd_time, format='jd', scale='tdb')\n\n            tx = '{0}'.format(time.iso)\n            text.set_position((event.xdata - 50, 700))\n            text.set_rotation(70)\n            text.set_text(tx)\n\n        cid = fig1.canvas.mpl_connect('motion_notify_event', on_mouse_motion)\n\n        plt.show()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nhandling a new update.", "response": "def handle(self, client, subhooks=()):\n        \"\"\"Handle a new update.\n\n        Fetches new data from the client, then compares it to the previous\n        lookup.\n\n        Returns:\n            (bool, new_data): whether changes occurred, and the new value.\n        \"\"\"\n        new_data = self.fetch(client)\n\n        # Holds the list of updated fields.\n        updated = {}\n\n        if not subhooks:\n            # We always want to compare to previous values.\n            subhooks = [self.name]\n\n        for subhook in subhooks:\n            new_key = self.extract_key(new_data, subhook)\n            if new_key != self.previous_keys.get(subhook):\n                updated[subhook] = new_key\n\n        if updated:\n            logger.debug(\"Hook %s: data changed from %r to %r\", self.name, self.previous_keys, updated)\n            self.previous_keys.update(updated)\n            return (True, new_data)\n\n        return (False, None)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _text_to_vbo(text, font, anchor_x, anchor_y, lowres_size):\n    # Necessary to flush commands before requesting current viewport because\n    # There may be a set_viewport command waiting in the queue.\n    # TODO: would be nicer if each canvas just remembers and manages its own\n    # viewport, rather than relying on the context for this.\n    canvas = context.get_current_canvas()\n    canvas.context.flush_commands()\n\n    text_vtype = np.dtype([('a_position', np.float32, 2),\n                           ('a_texcoord', np.float32, 2)])\n    vertices = np.zeros(len(text) * 4, dtype=text_vtype)\n    prev = None\n    width = height = ascender = descender = 0\n    ratio, slop = 1. / font.ratio, font.slop\n    x_off = -slop\n    # Need to make sure we have a unicode string here (Py2.7 mis-interprets\n    # characters like \"\u2022\" otherwise)\n    if sys.version[0] == '2' and isinstance(text, str):\n        text = text.decode('utf-8')\n    # Need to store the original viewport, because the font[char] will\n    # trigger SDF rendering, which changes our viewport\n    # todo: get rid of call to glGetParameter!\n    orig_viewport = canvas.context.get_viewport()\n    for ii, char in enumerate(text):\n        glyph = font[char]\n        kerning = glyph['kerning'].get(prev, 0.) * ratio\n        x0 = x_off + glyph['offset'][0] * ratio + kerning\n        y0 = glyph['offset'][1] * ratio + slop\n        x1 = x0 + glyph['size'][0]\n        y1 = y0 - glyph['size'][1]\n        u0, v0, u1, v1 = glyph['texcoords']\n        position = [[x0, y0], [x0, y1], [x1, y1], [x1, y0]]\n        texcoords = [[u0, v0], [u0, v1], [u1, v1], [u1, v0]]\n        vi = ii * 4\n        vertices['a_position'][vi:vi+4] = position\n        vertices['a_texcoord'][vi:vi+4] = texcoords\n        x_move = glyph['advance'] * ratio + kerning\n        x_off += x_move\n        ascender = max(ascender, y0 - slop)\n        descender = min(descender, y1 + slop)\n        width += x_move\n        height = max(height, glyph['size'][1] - 2*slop)\n        prev = char\n    # Also analyse chars with large ascender and descender, otherwise the\n    # vertical alignment can be very inconsistent\n    for char in 'hy':\n        glyph = font[char]\n        y0 = glyph['offset'][1] * ratio + slop\n        y1 = y0 - glyph['size'][1]\n        ascender = max(ascender, y0 - slop)\n        descender = min(descender, y1 + slop)\n        height = max(height, glyph['size'][1] - 2*slop)\n\n    if orig_viewport is not None:\n        canvas.context.set_viewport(*orig_viewport)\n\n    # Tight bounding box (loose would be width, font.height /.asc / .desc)\n    width -= glyph['advance'] * ratio - (glyph['size'][0] - 2*slop)\n    dx = dy = 0\n    if anchor_y == 'top':\n        dy = -ascender\n    elif anchor_y in ('center', 'middle'):\n        dy = -(height / 2 + descender)\n    elif anchor_y == 'bottom':\n        dy = -descender\n    # Already referenced to baseline\n    # elif anchor_y == 'baseline':\n    #     dy = -descender\n    if anchor_x == 'right':\n        dx = -width\n    elif anchor_x == 'center':\n        dx = -width / 2.\n    vertices['a_position'] += (dx, dy)\n    vertices['a_position'] /= lowres_size\n    return vertices", "response": "Convert text to VBO."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nbuilding and store a glyph corresponding to a single character.", "response": "def _load_char(self, char):\n        \"\"\"Build and store a glyph corresponding to an individual character\n\n        Parameters\n        ----------\n        char : str\n            A single character to be represented.\n        \"\"\"\n        assert isinstance(char, string_types) and len(char) == 1\n        assert char not in self._glyphs\n        # load new glyph data from font\n        _load_glyph(self._font, char, self._glyphs)\n        # put new glyph into the texture\n        glyph = self._glyphs[char]\n        bitmap = glyph['bitmap']\n\n        # convert to padded array\n        data = np.zeros((bitmap.shape[0] + 2*self._spread,\n                         bitmap.shape[1] + 2*self._spread), np.uint8)\n        data[self._spread:-self._spread, self._spread:-self._spread] = bitmap\n\n        # Store, while scaling down to proper size\n        height = data.shape[0] // self.ratio\n        width = data.shape[1] // self.ratio\n        region = self._atlas.get_free_region(width + 2, height + 2)\n        if region is None:\n            raise RuntimeError('Cannot store glyph')\n        x, y, w, h = region\n        x, y, w, h = x + 1, y + 1, w - 2, h - 2\n\n        self._renderer.render_to_texture(data, self._atlas, (x, y), (w, h))\n        u0 = x / float(self._atlas.shape[1])\n        v0 = y / float(self._atlas.shape[0])\n        u1 = (x+w) / float(self._atlas.shape[1])\n        v1 = (y+h) / float(self._atlas.shape[0])\n        texcoords = (u0, v0, u1, v1)\n        glyph.update(dict(size=(w, h), texcoords=texcoords))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_font(self, face, bold=False, italic=False):\n        key = '%s-%s-%s' % (face, bold, italic)\n        if key not in self._fonts:\n            font = dict(face=face, bold=bold, italic=italic)\n            self._fonts[key] = TextureFont(font, self._renderer)\n        return self._fonts[key]", "response": "Get a font described by face and size"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef stft(x, n_fft=1024, step=512, fs=2*np.pi, window='hann'):\n    x = np.asarray(x, float)\n    if x.ndim != 1:\n        raise ValueError('x must be 1D')\n    if window is not None:\n        if window not in ('hann',):\n            raise ValueError('window must be \"hann\" or None')\n        w = np.hanning(n_fft)\n    else:\n        w = np.ones(n_fft)\n    n_fft = int(n_fft)\n    step = max(n_fft // 2, 1) if step is None else int(step)\n    fs = float(fs)\n    zero_pad = n_fft - len(x)\n    if zero_pad > 0:\n        x = np.concatenate((x, np.zeros(zero_pad, float)))\n    n_freqs = n_fft // 2 + 1\n    n_estimates = (len(x) - n_fft) // step + 1\n    result = np.empty((n_freqs, n_estimates), np.complex128)\n    for ii in range(n_estimates):\n        result[:, ii] = np.fft.rfft(w * x[ii * step:ii * step + n_fft]) / n_fft\n    return result", "response": "Compute the STFT of the data."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef fft_freqs(n_fft, fs):\n    return np.arange(0, (n_fft // 2 + 1)) / float(n_fft) * float(fs)", "response": "Return the frequency of the DFT in the specified FFT."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsets the data used for this visual.", "response": "def set_data(self, pos=None, color=None, width=None, connect=None,\n                 arrows=None):\n        \"\"\"Set the data used for this visual\n\n        Parameters\n        ----------\n        pos : array\n            Array of shape (..., 2) or (..., 3) specifying vertex coordinates.\n        color : Color, tuple, or array\n            The color to use when drawing the line. If an array is given, it\n            must be of shape (..., 4) and provide one rgba color per vertex.\n            Can also be a colormap name, or appropriate `Function`.\n        width:\n            The width of the line in px. Line widths > 1px are only\n            guaranteed to work when using 'agg' method.\n        connect : str or array\n            Determines which vertices are connected by lines.\n\n                * \"strip\" causes the line to be drawn with each vertex\n                  connected to the next.\n                * \"segments\" causes each pair of vertices to draw an\n                  independent line segment\n                * numpy arrays specify the exact set of segment pairs to\n                  connect.\n        arrows : array\n            A Nx4 matrix where each row contains the x and y coordinate of the\n            first and second vertex of the arrow body. Remember that the second\n            vertex is used as center point for the arrow head, and the first\n            vertex is only used for determining the arrow head orientation.\n\n        \"\"\"\n\n        if arrows is not None:\n            self._arrows = arrows\n            self._arrows_changed = True\n\n        LineVisual.set_data(self, pos, color, width, connect)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef strip_html(text):\n    def reply_to(text):\n        replying_to = []\n        split_text = text.split()\n        for index, token in enumerate(split_text):\n            if token.startswith('@'): replying_to.append(token[1:])\n            else:\n                message = split_text[index:]\n                break\n        rply_msg = \"\"\n        if len(replying_to) > 0:\n            rply_msg = \"Replying to \"\n            for token in replying_to[:-1]: rply_msg += token+\",\"                \n            if len(replying_to)>1: rply_msg += 'and '\n            rply_msg += replying_to[-1]+\". \"\n        return rply_msg + \" \".join(message)\n        \n    text = reply_to(text)      \n    text = text.replace('@', ' ')\n    return \" \".join([token for token in text.split() \n                     if  ('http:' not in token) and ('https:' not in token)])", "response": "Remove ugly twitter html"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef make_twitter_request(url, user_id, params={}, request_type='GET'):\n    if request_type == \"GET\":\n        return requests.get(url, auth=get_twitter_auth(user_id), params=params)\n    elif request_type == \"POST\":\n        return requests.post(url, auth=get_twitter_auth(user_id), params=params)", "response": "Generates a request to twitter API using a particular user s authorization"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef geo_search(user_id, search_location):\n    url = \"https://api.twitter.com/1.1/geo/search.json\"\n    params =  {\"query\" : search_location }\n    response = make_twitter_request(url, user_id, params).json()\n    return response", "response": "Search for a location - free form\n   "}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nread out the tweets from the processed Tweets list.", "response": "def read_out_tweets(processed_tweets, speech_convertor=None):\n    \"\"\"\n    Input - list of processed 'Tweets'\n    output - list of spoken responses\n    \"\"\"\n    return [\"tweet number {num} by {user}. {text}.\".format(num=index+1, user=user, text=text)\n               for index, (user, text) in enumerate(processed_tweets)]"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsearches twitter API for tweets about a user.", "response": "def search_for_tweets_about(user_id, params):\n    \"\"\" Search twitter API \"\"\"\n    url = \"https://api.twitter.com/1.1/search/tweets.json\"\n    response = make_twitter_request(url, user_id, params)\n    return process_tweets(response.json()[\"statuses\"])"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nadding value in form of dict", "response": "def add_val(self, val):\n        \"\"\"add value in form of dict\"\"\"\n        if not isinstance(val, type({})):\n            raise ValueError(type({}))\n        self.read()\n        self.config.update(val)\n        self.save()"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nread a single segment of a mesh from a file.", "response": "def read_mesh(fname):\n    \"\"\"Read mesh data from file.\n\n    Parameters\n    ----------\n    fname : str\n        File name to read. Format will be inferred from the filename.\n        Currently only '.obj' and '.obj.gz' are supported.\n\n    Returns\n    -------\n    vertices : array\n        Vertices.\n    faces : array | None\n        Triangle face definitions.\n    normals : array\n        Normals for the mesh.\n    texcoords : array | None\n        Texture coordinates.\n    \"\"\"\n    # Check format\n    fmt = op.splitext(fname)[1].lower()\n    if fmt == '.gz':\n        fmt = op.splitext(op.splitext(fname)[0])[1].lower()\n\n    if fmt in ('.obj'):\n        return WavefrontReader.read(fname)\n    elif not format:\n        raise ValueError('read_mesh needs could not determine format.')\n    else:\n        raise ValueError('read_mesh does not understand format %s.' % fmt)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nwrite a mesh to a file.", "response": "def write_mesh(fname, vertices, faces, normals, texcoords, name='',\n               format='obj', overwrite=False, reshape_faces=True):\n    \"\"\" Write mesh data to file.\n\n    Parameters\n    ----------\n    fname : str\n        Filename to write. Must end with \".obj\" or \".gz\".\n    vertices : array\n        Vertices.\n    faces : array | None\n        Triangle face definitions.\n    normals : array\n        Normals for the mesh.\n    texcoords : array | None\n        Texture coordinates.\n    name : str\n        Name of the object.\n    format : str\n        Currently only \"obj\" is supported.\n    overwrite : bool\n        If the file exists, overwrite it.\n    reshape_faces : bool\n        Reshape the `faces` array to (Nf, 3). Set to `False`\n        if you need to write a mesh with non triangular faces.\n    \"\"\"\n    # Check file\n    if op.isfile(fname) and not overwrite:\n        raise IOError('file \"%s\" exists, use overwrite=True' % fname)\n\n    # Check format\n    if format not in ('obj'):\n        raise ValueError('Only \"obj\" format writing currently supported')\n    WavefrontWriter.write(fname, vertices, faces,\n                          normals, texcoords, name, reshape_faces)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set_shaders(self, vert, frag):\n        if not vert or not frag:\n            raise ValueError('Vertex and fragment code must both be non-empty')\n        \n        # pre-process shader code for #include directives\n        vert, frag = preprocess(vert), preprocess(frag)\n        \n        # Store source code, send it to glir, parse the code for variables\n        self._shaders = vert, frag\n\n        self._glir.command('SHADERS', self._id, vert, frag)\n        # All current variables become pending variables again\n        for key, val in self._user_variables.items():\n            self._pending_variables[key] = val\n        self._user_variables = {}\n        # Parse code (and process pending variables)\n        self._parse_variables_from_code()", "response": "Set the vertex and fragment shaders."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nparses variables from the source code.", "response": "def _parse_variables_from_code(self):\n        \"\"\" Parse uniforms, attributes and varyings from the source code.\n        \"\"\"\n        \n        # Get one string of code with comments removed\n        code = '\\n\\n'.join(self._shaders)\n        code = re.sub(r'(.*)(//.*)', r'\\1', code, re.M)\n        \n        # Regexp to look for variable names\n        var_regexp = (\"\\s*VARIABLE\\s+\"  # kind of variable\n                      \"((highp|mediump|lowp)\\s+)?\"  # Precision (optional)\n                      \"(?P<type>\\w+)\\s+\"  # type\n                      \"(?P<name>\\w+)\\s*\"  # name\n                      \"(\\[(?P<size>\\d+)\\])?\"  # size (optional)\n                      \"(\\s*\\=\\s*[0-9.]+)?\"  # default value (optional)\n                      \"\\s*;\"  # end\n                      )\n        \n        # Parse uniforms, attributes and varyings\n        self._code_variables = {}\n        for kind in ('uniform', 'attribute', 'varying', 'const'):\n            regex = re.compile(var_regexp.replace('VARIABLE', kind),\n                               flags=re.MULTILINE)\n            for m in re.finditer(regex, code):\n                gtype = m.group('type')\n                size = int(m.group('size')) if m.group('size') else -1\n                this_kind = kind\n                if size >= 1:\n                    # uniform arrays get added both as individuals and full\n                    for i in range(size):\n                        name = '%s[%d]' % (m.group('name'), i)\n                        self._code_variables[name] = kind, gtype, name, -1\n                    this_kind = 'uniform_array'\n                name = m.group('name')\n                self._code_variables[name] = this_kind, gtype, name, size\n\n        # Now that our code variables are up-to date, we can process\n        # the variables that were set but yet unknown.\n        self._process_pending_variables()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef bind(self, data):\n        # Check\n        if not isinstance(data, VertexBuffer):\n            raise ValueError('Program.bind() requires a VertexBuffer.')\n        # Apply\n        for name in data.dtype.names:\n            self[name] = data[name]", "response": "Binds a vertex buffer that has structured data\n        \n            to the program."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ntries to apply the pending variables that were not set but not known yet.", "response": "def _process_pending_variables(self):\n        \"\"\" Try to apply the variables that were set but not known yet.\n        \"\"\"\n        # Clear our list of pending variables\n        self._pending_variables, pending = {}, self._pending_variables\n        # Try to apply it. On failure, it will be added again\n        for name, data in pending.items():\n            self[name] = data"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ndraw the attribute arrays in the specified mode.", "response": "def draw(self, mode='triangles', indices=None, check_error=True):\n        \"\"\" Draw the attribute arrays in the specified mode.\n\n        Parameters\n        ----------\n        mode : str | GL_ENUM\n            'points', 'lines', 'line_strip', 'line_loop', 'triangles',\n            'triangle_strip', or 'triangle_fan'.\n        indices : array\n            Array of indices to draw.\n        check_error:\n            Check error after draw.\n        \n        \"\"\"\n        \n        # Invalidate buffer (data has already been sent)\n        self._buffer = None\n        \n        # Check if mode is valid\n        mode = check_enum(mode)\n        if mode not in ['points', 'lines', 'line_strip', 'line_loop',\n                        'triangles', 'triangle_strip', 'triangle_fan']:\n            raise ValueError('Invalid draw mode: %r' % mode)\n        \n        # Check leftover variables, warn, discard them\n        # In GLIR we check whether all attributes are indeed set\n        for name in self._pending_variables:\n            logger.warn('Variable %r is given but not known.' % name)\n        self._pending_variables = {}\n        \n        # Check attribute sizes\n        attributes = [vbo for vbo in self._user_variables.values() \n                      if isinstance(vbo, DataBuffer)]\n        sizes = [a.size for a in attributes]\n        if len(attributes) < 1:\n            raise RuntimeError('Must have at least one attribute')\n        if not all(s == sizes[0] for s in sizes[1:]):\n            msg = '\\n'.join(['%s: %s' % (str(a), a.size) for a in attributes])\n            raise RuntimeError('All attributes must have the same size, got:\\n'\n                               '%s' % msg)\n        \n        # Get the glir queue that we need now\n        canvas = get_current_canvas()\n        assert canvas is not None\n        \n        # Associate canvas\n        canvas.context.glir.associate(self.glir)\n        \n        # Indexbuffer\n        if isinstance(indices, IndexBuffer):\n            canvas.context.glir.associate(indices.glir)\n            logger.debug(\"Program drawing %r with index buffer\" % mode)\n            gltypes = {np.dtype(np.uint8): 'UNSIGNED_BYTE',\n                       np.dtype(np.uint16): 'UNSIGNED_SHORT',\n                       np.dtype(np.uint32): 'UNSIGNED_INT'}\n            selection = indices.id, gltypes[indices.dtype], indices.size\n            canvas.context.glir.command('DRAW', self._id, mode, selection)\n        elif indices is None:\n            selection = 0, attributes[0].size\n            logger.debug(\"Program drawing %r with %r\" % (mode, selection))\n            canvas.context.glir.command('DRAW', self._id, mode, selection)\n        else:\n            raise TypeError(\"Invalid index: %r (must be IndexBuffer)\" %\n                            indices)\n        \n        # Process GLIR commands\n        canvas.context.flush_commands()"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nupdate the data in this object.", "response": "def set_data(self, x=None, y=None, z=None, colors=None):\n        \"\"\"Update the data in this surface plot.\n\n        Parameters\n        ----------\n        x : ndarray | None\n            1D array of values specifying the x positions of vertices in the\n            grid. If None, values will be assumed to be integers.\n        y : ndarray | None\n            1D array of values specifying the x positions of vertices in the\n            grid. If None, values will be assumed to be integers.\n        z : ndarray\n            2D array of height values for each grid vertex.\n        colors : ndarray\n            (width, height, 4) array of vertex colors.\n        \"\"\"\n        if x is not None:\n            if self._x is None or len(x) != len(self._x):\n                self.__vertices = None\n            self._x = x\n\n        if y is not None:\n            if self._y is None or len(y) != len(self._y):\n                self.__vertices = None\n            self._y = y\n\n        if z is not None:\n            if self._x is not None and z.shape[0] != len(self._x):\n                raise TypeError('Z values must have shape (len(x), len(y))')\n            if self._y is not None and z.shape[1] != len(self._y):\n                raise TypeError('Z values must have shape (len(x), len(y))')\n            self._z = z\n            if (self.__vertices is not None and\n                    self._z.shape != self.__vertices.shape[:2]):\n                self.__vertices = None\n\n        if self._z is None:\n            return\n\n        update_mesh = False\n        new_vertices = False\n\n        # Generate vertex and face array\n        if self.__vertices is None:\n            new_vertices = True\n            self.__vertices = np.empty((self._z.shape[0], self._z.shape[1], 3),\n                                       dtype=np.float32)\n            self.generate_faces()\n            self.__meshdata.set_faces(self.__faces)\n            update_mesh = True\n\n        # Copy x, y, z data into vertex array\n        if new_vertices or x is not None:\n            if x is None:\n                if self._x is None:\n                    x = np.arange(self._z.shape[0])\n                else:\n                    x = self._x\n            self.__vertices[:, :, 0] = x.reshape(len(x), 1)\n            update_mesh = True\n\n        if new_vertices or y is not None:\n            if y is None:\n                if self._y is None:\n                    y = np.arange(self._z.shape[1])\n                else:\n                    y = self._y\n            self.__vertices[:, :, 1] = y.reshape(1, len(y))\n            update_mesh = True\n\n        if new_vertices or z is not None:\n            self.__vertices[..., 2] = self._z\n            update_mesh = True\n\n        if colors is not None:\n            self.__meshdata.set_vertex_colors(colors)\n            update_mesh = True\n\n        # Update MeshData\n        if update_mesh:\n            self.__meshdata.set_vertices(\n                self.__vertices.reshape(self.__vertices.shape[0] *\n                                        self.__vertices.shape[1], 3))\n            MeshVisual.set_data(self, meshdata=self.__meshdata)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef map(self, coords):\n        for tr in reversed(self.transforms):\n            coords = tr.map(coords)\n        return coords", "response": "Map the given coords to the corresponding set of keys."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ninversing map coordinates Parameters ---------- coords : array-like Coordinates to inverse map. Returns ------- coords : ndarray Coordinates.", "response": "def imap(self, coords):\n        \"\"\"Inverse map coordinates\n\n        Parameters\n        ----------\n        coords : array-like\n            Coordinates to inverse map.\n\n        Returns\n        -------\n        coords : ndarray\n            Coordinates.\n        \"\"\"\n        for tr in self.transforms:\n            coords = tr.imap(coords)\n        return coords"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nadding a new transform to the end of the chain.", "response": "def append(self, tr):\n        \"\"\"\n        Add a new transform to the end of this chain.\n\n        Parameters\n        ----------\n        tr : instance of Transform\n            The transform to use.\n        \"\"\"\n        self.transforms.append(tr)\n        tr.changed.connect(self._subtr_changed)\n        self._rebuild_shaders()\n        self.update()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef prepend(self, tr):\n        self.transforms.insert(0, tr)\n        tr.changed.connect(self._subtr_changed)\n        self._rebuild_shaders()\n        self.update()", "response": "Adds a new transform to the beginning of this chain."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ngenerate a simplified chain by joining adjacent transforms.", "response": "def source_changed(self, event):\n        \"\"\"Generate a simplified chain by joining adjacent transforms.\n        \"\"\"\n        # bail out early if the chain is empty\n        transforms = self._chain.transforms[:]\n        if len(transforms) == 0:\n            self.transforms = []\n            return\n        \n        # If the change signal comes from a transform that already appears in\n        # our simplified transform list, then there is no need to re-simplify.\n        if event is not None:\n            for source in event.sources[::-1]:\n                if source in self.transforms:\n                    self.update(event)\n                    return\n        \n        # First flatten the chain by expanding all nested chains\n        new_chain = []\n        while len(transforms) > 0:\n            tr = transforms.pop(0)\n            if isinstance(tr, ChainTransform) and not tr.dynamic:\n                transforms = tr.transforms[:] + transforms\n            else:\n                new_chain.append(tr)\n        \n        # Now combine together all compatible adjacent transforms\n        cont = True\n        tr = new_chain\n        while cont:\n            new_tr = [tr[0]]\n            cont = False\n            for t2 in tr[1:]:\n                t1 = new_tr[-1]\n                pr = t1 * t2\n                if (not t1.dynamic and not t2.dynamic and not \n                   isinstance(pr, ChainTransform)):\n                    cont = True\n                    new_tr.pop()\n                    new_tr.append(pr)\n                else:\n                    new_tr.append(t2)\n            tr = new_tr\n\n        self.transforms = tr"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef pack_iterable(messages):\n    '''Pack an iterable of messages in the TCP protocol format'''\n    # [ 4-byte body size ]\n    # [ 4-byte num messages ]\n    # [ 4-byte message #1 size ][ N-byte binary data ]\n    #      ... (repeated <num_messages> times)\n    return pack_string(\n        struct.pack('>l', len(messages)) +\n        ''.join(map(pack_string, messages)))", "response": "Pack an iterable of messages in the TCP protocol format"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef hexify(message):\n    '''Print out printable characters, but others in hex'''\n    import string\n    hexified = []\n    for char in message:\n        if (char in '\\n\\r \\t') or (char not in string.printable):\n            hexified.append('\\\\x%02x' % ord(char))\n        else:\n            hexified.append(char)\n    return ''.join(hexified)", "response": "Print out printable characters but others in hex"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncleans the running items from a previous session.", "response": "def clean(self):\n        \"\"\"Clean queue items from a previous session.\n\n        In case a previous session crashed and there are still some running\n        entries in the queue ('running', 'stopping', 'killing'), we clean those\n        and enqueue them again.\n        \"\"\"\n        for _, item in self.queue.items():\n            if item['status'] in ['paused', 'running', 'stopping', 'killing']:\n                item['status'] = 'queued'\n                item['start'] = ''\n                item['end'] = ''"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nremoving all completed tasks from the queue.", "response": "def clear(self):\n        \"\"\"Remove all completed tasks from the queue.\"\"\"\n        for key in list(self.queue.keys()):\n            if self.queue[key]['status'] in ['done', 'failed']:\n                del self.queue[key]\n        self.write()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef next(self):\n        smallest = None\n        for key in self.queue.keys():\n            if self.queue[key]['status'] == 'queued':\n                if smallest is None or key < smallest:\n                    smallest = key\n        return smallest", "response": "Get the next processable item in the queue."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreading the queue of the last pueue session or set self. queue = {}.", "response": "def read(self):\n        \"\"\"Read the queue of the last pueue session or set `self.queue = {}`.\"\"\"\n        queue_path = os.path.join(self.config_dir, 'queue')\n        if os.path.exists(queue_path):\n            queue_file = open(queue_path, 'rb')\n            try:\n                self.queue = pickle.load(queue_file)\n            except Exception:\n                print('Queue file corrupted, deleting old queue')\n                os.remove(queue_path)\n                self.queue = {}\n            queue_file.close()\n        else:\n            self.queue = {}"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef write(self):\n        queue_path = os.path.join(self.config_dir, 'queue')\n        queue_file = open(queue_path, 'wb+')\n        try:\n            pickle.dump(self.queue, queue_file, -1)\n        except Exception:\n            print('Error while writing to queue file. Wrong file permissions?')\n        queue_file.close()", "response": "Write the current queue to a file. We need this to continue an earlier session."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef add_new(self, command):\n        self.queue[self.next_key] = command\n        self.queue[self.next_key]['status'] = 'queued'\n        self.queue[self.next_key]['returncode'] = ''\n        self.queue[self.next_key]['stdout'] = ''\n        self.queue[self.next_key]['stderr'] = ''\n        self.queue[self.next_key]['start'] = ''\n        self.queue[self.next_key]['end'] = ''\n\n        self.next_key += 1\n        self.write()", "response": "Add a new entry to the queue."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nremoving a key from the queue return False if no such key exists.", "response": "def remove(self, key):\n        \"\"\"Remove a key from the queue, return `False` if no such key exists.\"\"\"\n        if key in self.queue:\n            del self.queue[key]\n            self.write()\n            return True\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef restart(self, key):\n        if key in self.queue:\n            if self.queue[key]['status'] in ['failed', 'done']:\n                new_entry = {'command': self.queue[key]['command'],\n                             'path': self.queue[key]['path']}\n                self.add_new(new_entry)\n                self.write()\n                return True\n        return False", "response": "Restart a previously finished entry."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef receive_data(socket):\n    answer = b\"\"\n    while True:\n        packet = socket.recv(4096)\n        if not packet: break\n        answer += packet\n    response = pickle.loads(answer)\n    socket.close()\n    return response", "response": "Receive an answer from the daemon and return the response."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef connect_socket(root_dir):\n    # Get config directory where the daemon socket is located\n    config_dir = os.path.join(root_dir, '.config/pueue')\n\n    # Create Socket and exit with 1, if socket can't be created\n    try:\n        client = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)\n        socket_path = os.path.join(config_dir, 'pueue.sock')\n        if os.path.exists(socket_path):\n            client.connect(socket_path)\n        else:\n            print(\"Socket doesn't exist\")\n            raise Exception\n    except:\n        print(\"Error connecting to socket. Make sure the daemon is running\")\n        sys.exit(1)\n    return client", "response": "Connect to a daemon s socket."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef from_raw(conn, raw):\n        '''Return a new response from a raw buffer'''\n        frame_type = struct.unpack('>l', raw[0:4])[0]\n        message = raw[4:]\n        if frame_type == FRAME_TYPE_MESSAGE:\n            return Message(conn, frame_type, message)\n        elif frame_type == FRAME_TYPE_RESPONSE:\n            return Response(conn, frame_type, message)\n        elif frame_type == FRAME_TYPE_ERROR:\n            return Error(conn, frame_type, message)\n        else:\n            raise TypeError('Unknown frame type: %s' % frame_type)", "response": "Return a new response from a raw buffer"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef pack(cls, data):\n        '''Pack the provided data into a Response'''\n        return struct.pack('>ll', len(data) + 4, cls.FRAME_TYPE) + data", "response": "Pack the provided data into a Response"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nindicates that this message is finished processing", "response": "def fin(self):\n        '''Indicate that this message is finished processing'''\n        self.connection.fin(self.id)\n        self.processed = True"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nhandles the exception and requeue the message if necessary.", "response": "def handle(self):\n        '''Make sure this message gets either 'fin' or 'req'd'''\n        try:\n            yield self\n        except:\n            # Requeue the message and raise the original exception\n            typ, value, trace = sys.exc_info()\n            if not self.processed:\n                try:\n                    self.req(self.delay())\n                except socket.error:\n                    self.connection.close()\n            raise typ, value, trace\n        else:\n            if not self.processed:\n                try:\n                    self.fin()\n                except socket.error:\n                    self.connection.close()"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef find(cls, name):\n        '''Find the exception class by name'''\n        if not cls.mapping:  # pragma: no branch\n            for _, obj in inspect.getmembers(exceptions):\n                if inspect.isclass(obj):\n                    if issubclass(obj, exceptions.NSQException):  # pragma: no branch\n                        if hasattr(obj, 'name'):\n                            cls.mapping[obj.name] = obj\n        klass = cls.mapping.get(name)\n        if klass == None:\n            raise TypeError('No matching exception for %s' % name)\n        return klass", "response": "Find the exception class by name"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning an instance of the corresponding exception", "response": "def exception(self):\n        '''Return an instance of the corresponding exception'''\n        code, _, message = self.data.partition(' ')\n        return self.find(code)(message)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nparse the gdb version from the gdb header.", "response": "def parse_gdb_version(line):\n    r\"\"\"Parse the gdb version from the gdb header.\n\n    From GNU coding standards: the version starts after the last space of the\n    first line.\n\n    >>> DOCTEST_GDB_VERSIONS = [\n    ... r'~\"GNU gdb (GDB) 7.5.1\\n\"',\n    ... r'~\"GNU gdb (Sourcery CodeBench Lite 2011.09-69) 7.2.50.20100908-cvs\\n\"',\n    ... r'~\"GNU gdb (GDB) SUSE (7.5.1-2.5.1)\\n\"',\n    ... r'~\"GNU gdb (GDB) Fedora (7.6-32.fc19)\\n\"',\n    ... r'~\"GNU gdb (GDB) 7.6.1.dummy\\n\"',\n    ... ]\n    >>> for header in DOCTEST_GDB_VERSIONS:\n    ...     print(parse_gdb_version(header))\n    7.5.1\n    7.2.50.20100908\n    7.5.1\n    7.6\n    7.6.1\n\n    \"\"\"\n    if line.startswith('~\"') and line.endswith(r'\\n\"'):\n        version = line[2:-3].rsplit(' ', 1)\n        if len(version) == 2:\n            # Strip after first non digit or '.' character. Allow for linux\n            # Suse non conformant implementation that encloses the version in\n            # brackets.\n            version = ''.join(takewhile(lambda x: x.isdigit() or x == '.',\n                                                    version[1].lstrip('(')))\n            return version.strip('.')\n    return ''"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nspawn gdb and attach to a process.", "response": "def spawn_gdb(pid, address=DFLT_ADDRESS, gdb='gdb', verbose=False,\n              ctx=None, proc_iut=None):\n    \"\"\"Spawn gdb and attach to a process.\"\"\"\n\n    parent, child = socket.socketpair()\n    proc = Popen([gdb, '--interpreter=mi', '-nx'],\n                    bufsize=0, stdin=child, stdout=child, stderr=STDOUT)\n    child.close()\n\n    connections = {}\n    gdb = GdbSocket(ctx, address, proc, proc_iut, parent, verbose,\n                    connections)\n    gdb.mi_command('-target-attach %d' % pid)\n    gdb.cli_command('python import pdb_clone.bootstrappdb_gdb')\n    asyncore.loop(map=connections)\n    proc.wait()\n    return gdb.error"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nspawning the process then repeatedly attach to the process.", "response": "def attach_loop(argv):\n    \"\"\"Spawn the process, then repeatedly attach to the process.\"\"\"\n\n    # Check if the pdbhandler module is built into python.\n    p = Popen((sys.executable, '-X', 'pdbhandler', '-c',\n                'import pdbhandler; pdbhandler.get_handler().host'),\n               stdout=PIPE, stderr=STDOUT)\n    p.wait()\n    use_xoption = True if p.returncode == 0 else False\n\n    # Spawn the process.\n    args = [sys.executable]\n    if use_xoption:\n        # Use SIGUSR2 as faulthandler is set on python test suite with\n        # SIGUSR1.\n        args.extend(['-X', 'pdbhandler=localhost 7935 %d' % signal.SIGUSR2])\n        args.extend(argv)\n        proc = Popen(args)\n    else:\n        args.extend(argv)\n        proc = Popen(args)\n\n    # Repeatedly attach to the process using the '-X' python option or gdb.\n    ctx = Context()\n    error = None\n    time.sleep(.5 + random.random())\n    while not error and proc.poll() is None:\n        if use_xoption:\n            os.kill(proc.pid, signal.SIGUSR2)\n            connections = {}\n            dev_null = io.StringIO() if PY3 else StringIO.StringIO()\n            asock = AttachSocketWithDetach(connections, stdout=dev_null)\n            asock.create_socket(socket.AF_INET, socket.SOCK_STREAM)\n            connect_process(asock, ctx, proc)\n            asyncore.loop(map=connections)\n        else:\n            error = spawn_gdb(proc.pid, ctx=ctx, proc_iut=proc)\n        time.sleep(random.random())\n\n    if error and gdb_terminated(error):\n        error = None\n    if proc.poll() is None:\n        proc.terminate()\n    else:\n        print('pdb-attach: program under test return code:', proc.wait())\n\n    result = str(ctx.result)\n    if result:\n        print(result)\n    return error"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nskips this py - pdb command to avoid attaching within the same loop.", "response": "def skip(self):\n        \"\"\"Skip this py-pdb command to avoid attaching within the same loop.\"\"\"\n\n        line = self.line\n        self.line = ''\n        # 'line' is the statement line of the previous py-pdb command.\n        if line in self.lines:\n            if not self.skipping:\n                self.skipping = True\n                printflush('Skipping lines', end='')\n            printflush('.', end='')\n            return True\n        elif line:\n            self.lines.append(line)\n            if len(self.lines) > 30:\n                self.lines.popleft()\n\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nmove the current log to a new file with timestamp and create a new empty log file.", "response": "def rotate(self, log):\n        \"\"\"Move the current log to a new file with timestamp and create a new empty log file.\"\"\"\n        self.write(log, rotate=True)\n        self.write({})"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nwrites the output of all finished processes to a compiled log file.", "response": "def write(self, log, rotate=False):\n        \"\"\"Write the output of all finished processes to a compiled log file.\"\"\"\n        # Get path for logfile\n        if rotate:\n            timestamp = time.strftime('-%Y%m%d-%H%M')\n            logPath = os.path.join(self.log_dir, 'queue{}.log'.format(timestamp))\n        else:\n            logPath = os.path.join(self.log_dir, 'queue.log')\n\n        # Remove existing Log\n        if os.path.exists(logPath):\n            os.remove(logPath)\n\n        log_file = open(logPath, 'w')\n        log_file.write('Pueue log for executed Commands: \\n \\n')\n\n        # Format, color and write log\n        for key, logentry in log.items():\n            if logentry.get('returncode') is not None:\n                try:\n                    # Get returncode color:\n                    returncode = logentry['returncode']\n                    if returncode == 0:\n                        returncode = Color('{autogreen}' + '{}'.format(returncode) + '{/autogreen}')\n                    else:\n                        returncode = Color('{autored}' + '{}'.format(returncode) + '{/autored}')\n\n                    # Write command id with returncode and actual command\n                    log_file.write(\n                        Color('{autoyellow}' + 'Command #{} '.format(key) + '{/autoyellow}') +\n                        'exited with returncode {}: \\n'.format(returncode) +\n                        '\"{}\" \\n'.format(logentry['command'])\n                    )\n                    # Write path\n                    log_file.write('Path: {} \\n'.format(logentry['path']))\n                    # Write times\n                    log_file.write('Start: {}, End: {} \\n'\n                                   .format(logentry['start'], logentry['end']))\n\n                    # Write STDERR\n                    if logentry['stderr']:\n                        log_file.write(Color('{autored}Stderr output: {/autored}\\n    ') + logentry['stderr'])\n\n                    # Write STDOUT\n                    if len(logentry['stdout']) > 0:\n                        log_file.write(Color('{autogreen}Stdout output: {/autogreen}\\n    ') + logentry['stdout'])\n\n                    log_file.write('\\n')\n                except Exception as a:\n                    print('Failed while writing to log file. Wrong file permissions?')\n                    print('Exception: {}'.format(str(a)))\n\n        log_file.close()"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nremoves all logs which are older than the specified time.", "response": "def remove_old(self, max_log_time):\n        \"\"\"Remove all logs which are older than the specified time.\"\"\"\n        files = glob.glob('{}/queue-*'.format(self.log_dir))\n        files = list(map(lambda x: os.path.basename(x), files))\n\n        for log_file in files:\n            # Get time stamp from filename\n            name = os.path.splitext(log_file)[0]\n            timestamp = name.split('-', maxsplit=1)[1]\n\n            # Get datetime from time stamp\n            time = datetime.strptime(timestamp, '%Y%m%d-%H%M')\n            now = datetime.now()\n\n            # Get total delta in seconds\n            delta = now - time\n            seconds = delta.total_seconds()\n\n            # Delete log file, if the delta is bigger than the specified log time\n            if seconds > int(max_log_time):\n                log_filePath = os.path.join(self.log_dir, log_file)\n                os.remove(log_filePath)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef wrap(function, *args, **kwargs):\n    '''Wrap a function that returns a request with some exception handling'''\n    try:\n        req = function(*args, **kwargs)\n        logger.debug('Got %s: %s', req.status_code, req.content)\n        if req.status_code == 200:\n            return req\n        else:\n            raise ClientException(req.reason, req.content)\n    except ClientException:\n        raise\n    except Exception as exc:\n        raise ClientException(exc)", "response": "Wrap a function that returns a request with some exception handling"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef json_wrap(function, *args, **kwargs):\n    '''Return the json content of a function that returns a request'''\n    try:\n        # Some responses have data = None, but they generally signal a\n        # successful API call as well.\n        response = json.loads(function(*args, **kwargs).content)\n        if 'data' in response:\n            return response['data'] or True\n        else:\n            return response\n    except Exception as exc:\n        raise ClientException(exc)", "response": "Return the json content of a function that returns a request"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nensuring that the response body is OK", "response": "def ok_check(function, *args, **kwargs):\n    '''Ensure that the response body is OK'''\n    req = function(*args, **kwargs)\n    if req.content.lower() != 'ok':\n        raise ClientException(req.content)\n    return req.content"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get(self, path, *args, **kwargs):\n        '''GET the provided endpoint'''\n        target = self._host.relative(path).utf8\n        if not isinstance(target, basestring):\n            # on older versions of the `url` library, .utf8 is a method, not a property\n            target = target()\n        params = kwargs.get('params', {})\n        params.update(self._params)\n        kwargs['params'] = params\n        logger.debug('GET %s with %s, %s', target, args, kwargs)\n        return requests.get(target, *args, **kwargs)", "response": "GET the provided endpoint"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ndecode a resumable upload bitmap node to hash of unit_id", "response": "def decode_resumable_upload_bitmap(bitmap_node, number_of_units):\n    \"\"\"Decodes bitmap_node to hash of unit_id: is_uploaded\n\n    bitmap_node -- bitmap node of resumable_upload with\n                   'count' number and 'words' containing array\n    number_of_units -- number of units we are uploading to\n                       define the number of bits for bitmap\n    \"\"\"\n    bitmap = 0\n    for token_id in range(int(bitmap_node['count'])):\n        value = int(bitmap_node['words'][token_id])\n        bitmap = bitmap | (value << (0xf * token_id))\n\n    result = {}\n\n    for unit_id in range(number_of_units):\n        mask = 1 << unit_id\n        result[unit_id] = (bitmap & mask) == mask\n\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef compute_hash_info(fd, unit_size=None):\n\n    logger.debug(\"compute_hash_info(%s, unit_size=%s)\", fd, unit_size)\n\n    fd.seek(0, os.SEEK_END)\n    file_size = fd.tell()\n    fd.seek(0, os.SEEK_SET)\n\n    units = []\n    unit_counter = 0\n\n    file_hash = hashlib.sha256()\n    unit_hash = hashlib.sha256()\n\n    for chunk in iter(lambda: fd.read(HASH_CHUNK_SIZE_BYTES), b''):\n        file_hash.update(chunk)\n\n        unit_hash.update(chunk)\n        unit_counter += len(chunk)\n\n        if unit_size is not None and unit_counter == unit_size:\n            # flush the current unit hash\n            units.append(unit_hash.hexdigest().lower())\n            unit_counter = 0\n            unit_hash = hashlib.sha256()\n\n    if unit_size is not None and unit_counter > 0:\n        # leftover block\n        units.append(unit_hash.hexdigest().lower())\n\n    fd.seek(0, os.SEEK_SET)\n\n    return MediaFireHashInfo(\n        file=file_hash.hexdigest().lower(),\n        units=units,\n        size=file_size\n    )", "response": "Get the MediaFireHashInfo structure from the fd unit_size"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef upload(self, fd, name=None, folder_key=None, filedrop_key=None,\n               path=None, action_on_duplicate=None):\n        \"\"\"Upload file, returns UploadResult object\n\n        fd -- file-like object to upload from, expects exclusive access\n        name -- file name\n        folder_key -- folderkey of the target folder\n        path -- path to file relative to folder_key\n        filedrop_key -- filedrop to use instead of folder_key\n        action_on_duplicate -- skip, keep, replace\n        \"\"\"\n\n        # Get file handle content length in the most reliable way\n        fd.seek(0, os.SEEK_END)\n        size = fd.tell()\n        fd.seek(0, os.SEEK_SET)\n\n        if size > UPLOAD_SIMPLE_LIMIT_BYTES:\n            resumable = True\n        else:\n            resumable = False\n\n        logger.debug(\"Calculating checksum\")\n        hash_info = compute_hash_info(fd)\n\n        if hash_info.size != size:\n            # Has the file changed beween computing the hash\n            # and calling upload()?\n            raise ValueError(\"hash_info.size mismatch\")\n\n        upload_info = _UploadInfo(fd=fd, name=name, folder_key=folder_key,\n                                  hash_info=hash_info, size=size, path=path,\n                                  filedrop_key=filedrop_key,\n                                  action_on_duplicate=action_on_duplicate)\n\n        # Check whether file is present\n        check_result = self._upload_check(upload_info, resumable)\n\n        upload_result = None\n        upload_func = None\n\n        folder_key = check_result.get('folder_key', None)\n        if folder_key is not None:\n            # We know precisely what folder_key to use, drop path\n            upload_info.folder_key = folder_key\n            upload_info.path = None\n\n        if check_result['hash_exists'] == 'yes':\n            # file exists somewhere in MediaFire\n            if check_result['in_folder'] == 'yes' and \\\n                    check_result['file_exists'] == 'yes':\n                # file exists in this directory\n                different_hash = check_result.get('different_hash', 'no')\n                if different_hash == 'no':\n                    # file is already there\n                    upload_func = self._upload_none\n\n            if not upload_func:\n                # different hash or in other folder\n                upload_func = self._upload_instant\n\n        if not upload_func:\n            if resumable:\n                resumable_upload_info = check_result['resumable_upload']\n                upload_info.hash_info = compute_hash_info(\n                    fd, int(resumable_upload_info['unit_size']))\n                upload_func = self._upload_resumable\n            else:\n                upload_func = self._upload_simple\n\n        # Retry retriable exceptions\n        retries = UPLOAD_RETRY_COUNT\n        while retries > 0:\n            try:\n                # Provide check_result to avoid calling API twice\n                upload_result = upload_func(upload_info, check_result)\n            except (RetriableUploadError, MediaFireConnectionError):\n                retries -= 1\n                logger.exception(\"%s failed (%d retries left)\",\n                                 upload_func.__name__, retries)\n                # Refresh check_result for next iteration\n                check_result = self._upload_check(upload_info, resumable)\n            except Exception:\n                logger.exception(\"%s failed\", upload_func)\n                break\n            else:\n                break\n\n        if upload_result is None:\n            raise UploadError(\"Upload failed\")\n\n        return upload_result", "response": "Upload a file to MediaFire and return a new object containing the upload result."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\npolls upload until quickkey is found.", "response": "def _poll_upload(self, upload_key, action):\n        \"\"\"Poll upload until quickkey is found\n\n        upload_key -- upload_key returned by upload/* functions\n        \"\"\"\n\n        if len(upload_key) != UPLOAD_KEY_LENGTH:\n            # not a regular 11-char-long upload key\n            # There is no API to poll filedrop uploads\n            return UploadResult(\n                action=action,\n                quickkey=None,\n                hash_=None,\n                filename=None,\n                size=None,\n                created=None,\n                revision=None\n            )\n\n        quick_key = None\n        while quick_key is None:\n            poll_result = self._api.upload_poll(upload_key)\n            doupload = poll_result['doupload']\n\n            logger.debug(\"poll(%s): status=%d, description=%s, filename=%s,\"\n                         \" result=%d\",\n                         upload_key, int(doupload['status']),\n                         doupload['description'], doupload['filename'],\n                         int(doupload['result']))\n\n            if int(doupload['result']) != 0:\n                break\n\n            if doupload['fileerror'] != '':\n                # TODO: we may have to handle this a bit more dramatically\n                logger.warning(\"poll(%s): fileerror=%d\", upload_key,\n                               int(doupload['fileerror']))\n                break\n\n            if int(doupload['status']) == STATUS_NO_MORE_REQUESTS:\n                quick_key = doupload['quickkey']\n            elif int(doupload['status']) == STATUS_UPLOAD_IN_PROGRESS:\n                # BUG: http://forum.mediafiredev.com/showthread.php?588\n                raise RetriableUploadError(\n                    \"Invalid state transition ({})\".format(\n                        doupload['description']\n                    )\n                )\n            else:\n                time.sleep(UPLOAD_POLL_INTERVAL)\n\n        return UploadResult(\n            action=action,\n            quickkey=doupload['quickkey'],\n            hash_=doupload['hash'],\n            filename=doupload['filename'],\n            size=doupload['size'],\n            created=doupload['created'],\n            revision=doupload['revision']\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nupload a single unit and return a raw upload and resumable unit.", "response": "def _upload_resumable_unit(self, uu_info):\n        \"\"\"Upload a single unit and return raw upload/resumable result\n\n        uu_info -- UploadUnitInfo instance\n        \"\"\"\n\n        # Get actual unit size\n        unit_size = uu_info.fd.len\n\n        if uu_info.hash_ is None:\n            raise ValueError('UploadUnitInfo.hash_ is now required')\n\n        return self._api.upload_resumable(\n            uu_info.fd,\n            uu_info.upload_info.size,\n            uu_info.upload_info.hash_info.file,\n            uu_info.hash_,\n            uu_info.uid,\n            unit_size,\n            filedrop_key=uu_info.upload_info.filedrop_key,\n            folder_key=uu_info.upload_info.folder_key,\n            path=uu_info.upload_info.path,\n            action_on_duplicate=uu_info.upload_info.action_on_duplicate)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nprepares and upload all resumable units and return upload_key", "response": "def _upload_resumable_all(self, upload_info, bitmap,\n                              number_of_units, unit_size):\n        \"\"\"Prepare and upload all resumable units and return upload_key\n\n        upload_info -- UploadInfo object\n        bitmap -- bitmap node of upload/check\n        number_of_units -- number of units requested\n        unit_size -- size of a single upload unit in bytes\n        \"\"\"\n\n        fd = upload_info.fd\n\n        upload_key = None\n\n        for unit_id in range(number_of_units):\n            upload_status = decode_resumable_upload_bitmap(\n                bitmap, number_of_units)\n\n            if upload_status[unit_id]:\n                logger.debug(\"Skipping unit %d/%d - already uploaded\",\n                             unit_id + 1, number_of_units)\n                continue\n\n            logger.debug(\"Uploading unit %d/%d\",\n                         unit_id + 1, number_of_units)\n\n            offset = unit_id * unit_size\n\n            with SubsetIO(fd, offset, unit_size) as unit_fd:\n\n                unit_info = _UploadUnitInfo(\n                    upload_info=upload_info,\n                    hash_=upload_info.hash_info.units[unit_id],\n                    fd=unit_fd,\n                    uid=unit_id)\n\n                upload_result = self._upload_resumable_unit(unit_info)\n\n                # upload_key is needed for polling\n                if upload_key is None:\n                    upload_key = upload_result['doupload']['key']\n\n        return upload_key"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef reset(self):\n        if not self.hooked:\n            self.hooked = True\n            sys.path_hooks.append(self)\n            sys.path.insert(0, self.PATH_ENTRY)\n            return\n\n        for modname in self:\n            if modname in sys.modules:\n                del sys.modules[modname]\n                submods = []\n                for subm in sys.modules:\n                    if subm.startswith(modname + '.'):\n                        submods.append(subm)\n                # All submodules of modname may not have been imported by the\n                # debuggee, but they are still removed from sys.modules as\n                # there is no way to distinguish them.\n                for subm in submods:\n                    del sys.modules[subm]\n        self[:] = []", "response": "Remove from sys. modules the modules imported by the debuggee."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_func_lno(self, funcname):\n\n        class FuncLineno(ast.NodeVisitor):\n            def __init__(self):\n                self.clss = []\n\n            def generic_visit(self, node):\n                for child in ast.iter_child_nodes(node):\n                    for item in self.visit(child):\n                        yield item\n\n            def visit_ClassDef(self, node):\n                self.clss.append(node.name)\n                for item in self.generic_visit(node):\n                    yield item\n                self.clss.pop()\n\n            def visit_FunctionDef(self, node):\n                # Only allow non nested function definitions.\n                name = '.'.join(itertools.chain(self.clss, [node.name]))\n                yield name, node.lineno\n\n        if self.functions_firstlno is None:\n            self.functions_firstlno = {}\n            for name, lineno in FuncLineno().visit(self.node):\n                if (name not in self.functions_firstlno or\n                        self.functions_firstlno[name] < lineno):\n                    self.functions_firstlno[name] = lineno\n        try:\n            return self.functions_firstlno[funcname]\n        except KeyError:\n            raise BdbSourceError('{}: function \"{}\" not found.'.format(\n                self.filename, funcname))", "response": "Returns the first line number of the last defined funcname function."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the actual breakpoint line number.", "response": "def get_actual_bp(self, lineno):\n        \"\"\"Get the actual breakpoint line number.\n\n        When an exact match cannot be found in the lnotab expansion of the\n        module code object or one of its subcodes, pick up the next valid\n        statement line number.\n\n        Return the statement line defined by the tuple (code firstlineno,\n        statement line number) which is at the shortest distance to line\n        'lineno' and greater or equal to 'lineno'. When 'lineno' is the first\n        line number of a subcode, use its first statement line instead.\n        \"\"\"\n\n        def _distance(code, module_level=False):\n            \"\"\"The shortest distance to the next valid statement.\"\"\"\n            subcodes = dict((c.co_firstlineno, c) for c in code.co_consts\n                                if isinstance(c, types.CodeType) and not\n                                    c.co_name.startswith('<'))\n            # Get the shortest distance to the subcode whose first line number\n            # is the last to be less or equal to lineno. That is, find the\n            # index of the first subcode whose first_lno is the first to be\n            # strictly greater than lineno.\n            subcode_dist = None\n            subcodes_flnos = sorted(subcodes)\n            idx = bisect(subcodes_flnos, lineno)\n            if idx != 0:\n                flno = subcodes_flnos[idx-1]\n                subcode_dist = _distance(subcodes[flno])\n\n            # Check if lineno is a valid statement line number in the current\n            # code, excluding function or method definition lines.\n            code_lnos = sorted(code_line_numbers(code))\n            # Do not stop at execution of function definitions.\n            if not module_level and len(code_lnos) > 1:\n                code_lnos = code_lnos[1:]\n            if lineno in code_lnos and lineno not in subcodes_flnos:\n                return 0, (code.co_firstlineno, lineno)\n\n            # Compute the distance to the next valid statement in this code.\n            idx = bisect(code_lnos, lineno)\n            if idx == len(code_lnos):\n                # lineno is greater that all 'code' line numbers.\n                return subcode_dist\n            actual_lno = code_lnos[idx]\n            dist = actual_lno - lineno\n            if subcode_dist and subcode_dist[0] < dist:\n                return subcode_dist\n            if actual_lno not in subcodes_flnos:\n                return dist, (code.co_firstlineno, actual_lno)\n            else:\n                # The actual line number is the line number of the first\n                # statement of the subcode following lineno (recursively).\n                return _distance(subcodes[actual_lno])\n\n        if self.code:\n            code_dist = _distance(self.code, module_level=True)\n        if not self.code or not code_dist:\n            raise BdbSourceError('{}: line {} is after the last '\n                'valid statement.'.format(self.filename, lineno))\n        return code_dist[1]"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_breakpoints(self, lineno):\n        try:\n            firstlineno, actual_lno = self.bdb_module.get_actual_bp(lineno)\n        except BdbSourceError:\n            return []\n        if firstlineno not in self:\n            return []\n        code_bps = self[firstlineno]\n        if actual_lno not in code_bps:\n            return []\n        return [bp for bp in sorted(code_bps[actual_lno],\n                    key=attrgetter('number')) if bp.line == lineno]", "response": "Return the list of breakpoints set at lineno."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef settrace(self, do_set):\n        if do_set:\n            sys.settrace(self.trace_dispatch)\n        else:\n            sys.settrace(None)", "response": "Set or remove the trace function."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef restart(self):\n        _module_finder.reset()\n        linecache.checkcache()\n        for module_bpts in self.breakpoints.values():\n            module_bpts.reset()", "response": "Restart the debugger after source code changes."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef set_until(self, frame, lineno=None):\n        if lineno is None:\n            lineno = frame.f_lineno + 1\n        self._set_stopinfo(frame, lineno)", "response": "Stop when the current line number in frame is greater than lineno or\n        when returning from frame."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nstarts debugging from frame.", "response": "def set_trace(self, frame=None):\n        \"\"\"Start debugging from `frame`.\n\n        If frame is not specified, debugging starts from caller's frame.\n        \"\"\"\n        # First disable tracing temporarily as set_trace() may be called while\n        # tracing is in use. For example when called from a signal handler and\n        # within a debugging session started with runcall().\n        self.settrace(False)\n\n        if not frame:\n            frame = sys._getframe().f_back\n        frame.f_trace = self.trace_dispatch\n\n        # Do not change botframe when the debuggee has been started from an\n        # instance of Pdb with one of the family of run methods.\n        self.reset(ignore_first_call_event=False, botframe=self.botframe)\n        self.topframe = frame\n        while frame:\n            if frame is self.botframe:\n                break\n            botframe = frame\n            frame = frame.f_back\n        else:\n            self.botframe = botframe\n\n        # Must trace the bottom frame to disable tracing on termination,\n        # see issue 13044.\n        if not self.botframe.f_trace:\n            self.botframe.f_trace = self.trace_dispatch\n\n        self.settrace(True)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn True if the breakpoint is enabled and False if it is not.", "response": "def process_hit_event(self, frame):\n        \"\"\"Return (stop_state, delete_temporary) at a breakpoint hit event.\"\"\"\n        if not self.enabled:\n            return False, False\n        # Count every hit when breakpoint is enabled.\n        self.hits += 1\n        # A conditional breakpoint.\n        if self.cond:\n            try:\n                if not eval_(self.cond, frame.f_globals, frame.f_locals):\n                    return False, False\n            except Exception:\n                # If the breakpoint condition evaluation fails, the most\n                # conservative thing is to stop on the breakpoint.  Don't\n                # delete temporary, as another hint to the user.\n                return True, False\n        if self.ignore > 0:\n            self.ignore -= 1\n            return False, False\n        return True, True"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef listdir(directory):\n    file_names = list()\n    for filename in os.listdir(directory):\n        file_path = os.path.join(directory, filename)\n        if os.path.isdir(file_path):\n            filename = f'{filename}{os.path.sep}'\n        file_names.append(filename)\n    return file_names", "response": "Returns list of files and directories for local directory by path"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_options(option_type, from_options):\n    _options = dict()\n\n    for key in option_type.keys:\n        key_with_prefix = f'{option_type.prefix}{key}'\n        if key not in from_options and key_with_prefix not in from_options:\n            _options[key] = ''\n        elif key in from_options:\n            _options[key] = from_options.get(key)\n        else:\n            _options[key] = from_options.get(key_with_prefix)\n\n    return _options", "response": "Extract options for specified option type from all options dictionary\n   "}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the HTTP headers of the specified WebDAV actions.", "response": "def get_headers(self, action, headers_ext=None):\n        \"\"\"Returns HTTP headers of specified WebDAV actions.\n\n        :param action: the identifier of action.\n        :param headers_ext: (optional) the addition headers list witch sgould be added to basic HTTP headers for\n                            the specified action.\n        :return: the dictionary of headers for specified action.\n        \"\"\"\n        if action in Client.http_header:\n            try:\n                headers = Client.http_header[action].copy()\n            except AttributeError:\n                headers = Client.http_header[action][:]\n        else:\n            headers = list()\n\n        if headers_ext:\n            headers.extend(headers_ext)\n\n        if self.webdav.token:\n            webdav_token = f'Authorization: OAuth {self.webdav.token}'\n            headers.append(webdav_token)\n        return dict([map(lambda s: s.strip(), i.split(':')) for i in headers])"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nexecutes a request to the WebDAV server for the specified action and path.", "response": "def execute_request(self, action, path, data=None, headers_ext=None):\n        \"\"\"Generate request to WebDAV server for specified action and path and execute it.\n\n        :param action: the action for WebDAV server which should be executed.\n        :param path: the path to resource for action\n        :param data: (optional) Dictionary or list of tuples ``[(key, value)]`` (will be form-encoded), bytes,\n                     or file-like object to send in the body of the :class:`Request`.\n        :param headers_ext: (optional) the addition headers list witch should be added to basic HTTP headers for\n                            the specified action.\n        :return: HTTP response of request.\n        \"\"\"\n        response = self.session.request(\n            method=Client.requests[action],\n            url=self.get_url(path),\n            auth=self.webdav.auth,\n            headers=self.get_headers(action, headers_ext),\n            timeout=self.timeout,\n            data=data\n        )\n        if response.status_code == 507:\n            raise NotEnoughSpace()\n        if 499 < response.status_code < 600:\n            raise ServerException(url=self.get_url(path), code=response.status_code, message=response.content)\n        if response.status_code >= 400:\n            raise ResponseErrorCode(url=self.get_url(path), code=response.status_code, message=response.content)\n        return response"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef valid(self):\n        return True if self.webdav.valid() and self.proxy.valid() else False", "response": "Validates of WebDAV and proxy settings."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef list(self, remote_path=root):\n        directory_urn = Urn(remote_path, directory=True)\n        if directory_urn.path() != Client.root:\n            if not self.check(directory_urn.path()):\n                raise RemoteResourceNotFound(directory_urn.path())\n\n        response = self.execute_request(action='list', path=directory_urn.quote())\n        urns = WebDavXmlUtils.parse_get_list_response(response.content)\n\n        path = Urn.normalize_path(self.get_full_path(directory_urn))\n        return [urn.filename() for urn in urns if Urn.compare_path(path, urn.path()) is False]", "response": "Returns list of nested files and directories for remote WebDAV directory by path."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning an amount of free space on remote WebDAV server.", "response": "def free(self):\n        \"\"\"Returns an amount of free space on remote WebDAV server.\n        More information you can find by link http://webdav.org/specs/rfc4918.html#METHOD_PROPFIND\n\n        :return: an amount of free space in bytes.\n        \"\"\"\n        data = WebDavXmlUtils.create_free_space_request_content()\n        response = self.execute_request(action='free', path='', data=data)\n        return WebDavXmlUtils.parse_free_space_response(response.content, self.webdav.hostname)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef check(self, remote_path=root):\n        urn = Urn(remote_path)\n        try:\n            response = self.execute_request(action='check', path=urn.quote())\n        except ResponseErrorCode:\n            return False\n\n        if int(response.status_code) == 200:\n            return True\n\n        return False", "response": "Checks an existence of remote resource on WebDAV server by remote path."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nmake new directory on WebDAV server.", "response": "def mkdir(self, remote_path):\n        \"\"\"Makes new directory on WebDAV server.\n        More information you can find by link http://webdav.org/specs/rfc4918.html#METHOD_MKCOL\n\n        :param remote_path: path to directory\n        :return: True if request executed with code 200 or 201 and False otherwise.\n\n        \"\"\"\n        directory_urn = Urn(remote_path, directory=True)\n\n        try:\n            response = self.execute_request(action='mkdir', path=directory_urn.quote())\n\n            return response.status_code in (200, 201)\n        except ResponseErrorCode as e:\n            if e.code == 405:\n                return True\n\n            raise"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ndownloading file from WebDAV and writes it in buffer.", "response": "def download_from(self, buff, remote_path):\n        \"\"\"Downloads file from WebDAV and writes it in buffer.\n\n        :param buff: buffer object for writing of downloaded file content.\n        :param remote_path: path to file on WebDAV server.\n        \"\"\"\n        urn = Urn(remote_path)\n        if self.is_dir(urn.path()):\n            raise OptionNotValid(name='remote_path', value=remote_path)\n\n        if not self.check(urn.path()):\n            raise RemoteResourceNotFound(urn.path())\n\n        response = self.execute_request(action='download', path=urn.quote())\n        buff.write(response.content)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef download(self, remote_path, local_path, progress=None):\n        urn = Urn(remote_path)\n        if self.is_dir(urn.path()):\n            self.download_directory(local_path=local_path, remote_path=remote_path, progress=progress)\n        else:\n            self.download_file(local_path=local_path, remote_path=remote_path, progress=progress)", "response": "Downloads remote resource from WebDAV and saves it in local path."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef download_directory(self, remote_path, local_path, progress=None):\n        urn = Urn(remote_path, directory=True)\n        if not self.is_dir(urn.path()):\n            raise OptionNotValid(name='remote_path', value=remote_path)\n\n        if os.path.exists(local_path):\n            shutil.rmtree(local_path)\n\n        os.makedirs(local_path)\n\n        for resource_name in self.list(urn.path()):\n            _remote_path = f'{urn.path()}{resource_name}'\n            _local_path = os.path.join(local_path, resource_name)\n            self.download(local_path=_local_path, remote_path=_remote_path, progress=progress)", "response": "Downloads all nested files and directories from remote WebDAV server to local WebDAV server."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nopening a file from WebDAV server and saves it temprorary then opens it for further manipulations.", "response": "def open(self, file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None):\n        \"\"\"Downloads file from WebDAV server and saves it temprorary, then opens it for further manipulations.\n        Has the same interface as built-in open()\n\n        :param file: the path to remote file for opening.\n        \"\"\"\n        urn = Urn(file)\n        urn_path = urn.path()\n\n        remote_file_exists = self.check(urn_path)\n\n        if not remote_file_exists:\n            if 'r' in mode:\n                raise RemoteResourceNotFound(urn_path)\n        elif self.is_dir(urn_path):\n            raise OptionNotValid(name='file', value=file)\n\n        with tempfile.TemporaryDirectory() as temp_dir:\n            local_path = f'{temp_dir}{os.path.sep}{file}'\n\n            if remote_file_exists:\n                self.download_file(file, local_path)\n            else:\n                if ('w' in mode or 'a' in mode or 'x' in mode) and os.path.sep in local_path:\n                    os.makedirs(local_path.rsplit(os.path.sep, 1)[0], exist_ok=True)\n\n            with open(file=local_path, mode=mode, buffering=buffering, encoding=encoding, errors=errors,\n                      newline=newline, closefd=closefd, opener=opener) as f:\n                yield f\n\n            if 'w' in mode or 'a' in mode or 'x' in mode:\n                self.upload_file(file, local_path)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ndownload file from WebDAV server and saves it locally.", "response": "def download_file(self, remote_path, local_path, progress=None):\n        \"\"\"Downloads file from WebDAV server and save it locally.\n        More information you can find by link http://webdav.org/specs/rfc4918.html#rfc.section.9.4\n\n        :param remote_path: the path to remote file for downloading.\n        :param local_path: the path to save file locally.\n        :param progress: progress function. Not supported now.\n        \"\"\"\n        urn = Urn(remote_path)\n        if self.is_dir(urn.path()):\n            raise OptionNotValid(name='remote_path', value=remote_path)\n\n        if os.path.isdir(local_path):\n            raise OptionNotValid(name='local_path', value=local_path)\n\n        if os.path.sep in local_path:\n            os.makedirs(local_path.rsplit(os.path.sep, 1)[0], exist_ok=True)\n\n        if not self.check(urn.path()):\n            raise RemoteResourceNotFound(urn.path())\n\n        with open(local_path, 'wb') as local_file:\n            response = self.execute_request('download', urn.quote())\n            for block in response.iter_content(1024):\n                local_file.write(block)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef download_sync(self, remote_path, local_path, callback=None):\n        self.download(local_path=local_path, remote_path=remote_path)\n        if callback:\n            callback()", "response": "Downloads remote resources from WebDAV server synchronously."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ndownloads remote resources from WebDAV server asynchronously.", "response": "def download_async(self, remote_path, local_path, callback=None):\n        \"\"\"Downloads remote resources from WebDAV server asynchronously\n\n        :param remote_path: the path to remote resource on WebDAV server. Can be file and directory.\n        :param local_path: the path to save resource locally.\n        :param callback: the callback which will be invoked when downloading is complete.\n        \"\"\"\n        target = (lambda: self.download_sync(local_path=local_path, remote_path=remote_path, callback=callback))\n        threading.Thread(target=target).start()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef upload_to(self, buff, remote_path):\n        urn = Urn(remote_path)\n        if urn.is_dir():\n            raise OptionNotValid(name='remote_path', value=remote_path)\n\n        if not self.check(urn.parent()):\n            raise RemoteParentNotFound(urn.path())\n\n        self.execute_request(action='upload', path=urn.quote(), data=buff)", "response": "Uploads file from buffer to remote path on WebDAV server."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nuploads resource to remote path on WebDAV server.", "response": "def upload(self, remote_path, local_path, progress=None):\n        \"\"\"Uploads resource to remote path on WebDAV server.\n        In case resource is directory it will upload all nested files and directories.\n        More information you can find by link http://webdav.org/specs/rfc4918.html#METHOD_PUT\n\n        :param remote_path: the path for uploading resources on WebDAV server. Can be file and directory.\n        :param local_path: the path to local resource for uploading.\n        :param progress: Progress function. Not supported now.\n        \"\"\"\n        if os.path.isdir(local_path):\n            self.upload_directory(local_path=local_path, remote_path=remote_path, progress=progress)\n        else:\n            self.upload_file(local_path=local_path, remote_path=remote_path)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nuploading a directory to WebDAV server.", "response": "def upload_directory(self, remote_path, local_path, progress=None):\n        \"\"\"Uploads directory to remote path on WebDAV server.\n        In case directory is exist on remote server it will delete it and then upload directory with nested files and\n        directories.\n\n        :param remote_path: the path to directory for uploading on WebDAV server.\n        :param local_path: the path to local directory for uploading.\n        :param progress: Progress function. Not supported now.\n        \"\"\"\n        urn = Urn(remote_path, directory=True)\n        if not urn.is_dir():\n            raise OptionNotValid(name='remote_path', value=remote_path)\n\n        if not os.path.isdir(local_path):\n            raise OptionNotValid(name='local_path', value=local_path)\n\n        if not os.path.exists(local_path):\n            raise LocalResourceNotFound(local_path)\n\n        if self.check(urn.path()):\n            self.clean(urn.path())\n\n        self.mkdir(remote_path)\n\n        for resource_name in listdir(local_path):\n            _remote_path = f'{urn.path()}{resource_name}'\n            _local_path = os.path.join(local_path, resource_name)\n            self.upload(local_path=_local_path, remote_path=_remote_path, progress=progress)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef upload_file(self, remote_path, local_path, progress=None):\n        if not os.path.exists(local_path):\n            raise LocalResourceNotFound(local_path)\n\n        urn = Urn(remote_path)\n        if urn.is_dir():\n            raise OptionNotValid(name='remote_path', value=remote_path)\n\n        if os.path.isdir(local_path):\n            raise OptionNotValid(name='local_path', value=local_path)\n\n        if not self.check(urn.parent()):\n            raise RemoteParentNotFound(urn.path())\n\n        with open(local_path, 'rb') as local_file:\n            file_size = os.path.getsize(local_path)\n            if file_size > self.large_size:\n                raise ResourceTooBig(path=local_path, size=file_size, max_size=self.large_size)\n\n            self.execute_request(action='upload', path=urn.quote(), data=local_file)", "response": "Uploads file to remote path on WebDAV server."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nuploads resource to remote path synchronously.", "response": "def upload_sync(self, remote_path, local_path, callback=None):\n        \"\"\"Uploads resource to remote path on WebDAV server synchronously.\n        In case resource is directory it will upload all nested files and directories.\n\n        :param remote_path: the path for uploading resources on WebDAV server. Can be file and directory.\n        :param local_path: the path to local resource for uploading.\n        :param callback: the callback which will be invoked when downloading is complete.\n        \"\"\"\n        self.upload(local_path=local_path, remote_path=remote_path)\n\n        if callback:\n            callback()"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nuploads resource to remote path on WebDAV server asynchronously.", "response": "def upload_async(self, remote_path, local_path, callback=None):\n        \"\"\"Uploads resource to remote path on WebDAV server asynchronously.\n        In case resource is directory it will upload all nested files and directories.\n\n        :param remote_path: the path for uploading resources on WebDAV server. Can be file and directory.\n        :param local_path: the path to local resource for uploading.\n        :param callback: the callback which will be invoked when downloading is complete.\n        \"\"\"\n        target = (lambda: self.upload_sync(local_path=local_path, remote_path=remote_path, callback=callback))\n        threading.Thread(target=target).start()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncopy resource from one place to another on WebDAV server.", "response": "def copy(self, remote_path_from, remote_path_to):\n        \"\"\"Copies resource from one place to another on WebDAV server.\n        More information you can find by link http://webdav.org/specs/rfc4918.html#METHOD_COPY\n\n        :param remote_path_from: the path to resource which will be copied,\n        :param remote_path_to: the path where resource will be copied.\n        \"\"\"\n        urn_from = Urn(remote_path_from)\n        if not self.check(urn_from.path()):\n            raise RemoteResourceNotFound(urn_from.path())\n\n        urn_to = Urn(remote_path_to)\n        if not self.check(urn_to.parent()):\n            raise RemoteParentNotFound(urn_to.path())\n\n        header_destination = f'Destination: {self.get_full_path(urn_to)}'\n        self.execute_request(action='copy', path=urn_from.quote(), headers_ext=[header_destination])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nmove resource from one place to another on WebDAV server.", "response": "def move(self, remote_path_from, remote_path_to, overwrite=False):\n        \"\"\"Moves resource from one place to another on WebDAV server.\n        More information you can find by link http://webdav.org/specs/rfc4918.html#METHOD_MOVE\n\n        :param remote_path_from: the path to resource which will be moved,\n        :param remote_path_to: the path where resource will be moved.\n        :param overwrite: (optional) the flag, overwrite file if it exists. Defaults is False\n        \"\"\"\n        urn_from = Urn(remote_path_from)\n        if not self.check(urn_from.path()):\n            raise RemoteResourceNotFound(urn_from.path())\n\n        urn_to = Urn(remote_path_to)\n        if not self.check(urn_to.parent()):\n            raise RemoteParentNotFound(urn_to.path())\n\n        header_destination = f'Destination: {self.get_full_path(urn_to)}'\n        header_overwrite = f'Overwrite: {\"T\" if overwrite else \"F\"}'\n        self.execute_request(action='move', path=urn_from.quote(), headers_ext=[header_destination, header_overwrite])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nclean ( Deletes ) a remote resource on WebDAV server.", "response": "def clean(self, remote_path):\n        \"\"\"Cleans (Deletes) a remote resource on WebDAV server. The name of method is not changed for back compatibility\n        with original library.\n        More information you can find by link http://webdav.org/specs/rfc4918.html#METHOD_DELETE\n\n        :param remote_path: the remote resource whisch will be deleted.\n        \"\"\"\n        urn = Urn(remote_path)\n        self.execute_request(action='clean', path=urn.quote())"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting information about resource on WebDAV.", "response": "def info(self, remote_path):\n        \"\"\"Gets information about resource on WebDAV.\n        More information you can find by link http://webdav.org/specs/rfc4918.html#METHOD_PROPFIND\n\n        :param remote_path: the path to remote resource.\n        :return: a dictionary of information attributes and them values with following keys:\n                 `created`: date of resource creation,\n                 `name`: name of resource,\n                 `size`: size of resource,\n                 `modified`: date of resource modification.\n        \"\"\"\n        urn = Urn(remote_path)\n        if not self.check(urn.path()) and not self.check(Urn(remote_path, directory=True).path()):\n            raise RemoteResourceNotFound(remote_path)\n\n        response = self.execute_request(action='info', path=urn.quote())\n        path = self.get_full_path(urn)\n        return WebDavXmlUtils.parse_info_response(content=response.content, path=path, hostname=self.webdav.hostname)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef is_dir(self, remote_path):\n        urn = Urn(remote_path)\n        parent_urn = Urn(urn.parent())\n        if not self.check(urn.path()) and not self.check(Urn(remote_path, directory=True).path()):\n            raise RemoteResourceNotFound(remote_path)\n\n        response = self.execute_request(action='info', path=parent_urn.quote())\n        path = self.get_full_path(urn)\n        return WebDavXmlUtils.parse_is_dir_response(content=response.content, path=path, hostname=self.webdav.hostname)", "response": "Checks if the remote resource is a directory."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_property(self, remote_path, option):\n        urn = Urn(remote_path)\n        if not self.check(urn.path()):\n            raise RemoteResourceNotFound(urn.path())\n\n        data = WebDavXmlUtils.create_get_property_request_content(option)\n        response = self.execute_request(action='get_property', path=urn.quote(), data=data)\n        return WebDavXmlUtils.parse_get_property_response(response.content, option['name'])", "response": "Gets the metadata property of the remote resource on WebDAV server."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef set_property(self, remote_path, option):\n        self.set_property_batch(remote_path=remote_path, option=[option])", "response": "Sets the property of the remote resource on WebDAV server."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef set_property_batch(self, remote_path, option):\n        urn = Urn(remote_path)\n        if not self.check(urn.path()):\n            raise RemoteResourceNotFound(urn.path())\n\n        data = WebDavXmlUtils.create_set_property_batch_request_content(option)\n        self.execute_request(action='set_property', path=urn.quote(), data=data)", "response": "Sets batch metadata properties of remote resource on WebDAV server in batch."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nparses the response content XML from WebDAV server and extracts file and directory names.", "response": "def parse_get_list_response(content):\n        \"\"\"Parses of response content XML from WebDAV server and extract file and directory names.\n\n        :param content: the XML content of HTTP response from WebDAV server for getting list of files by remote path.\n        :return: list of extracted file or directory names.\n        \"\"\"\n        try:\n            tree = etree.fromstring(content)\n            hrees = [Urn.separate + unquote(urlsplit(hree.text).path) for hree in tree.findall('.//{DAV:}href')]\n            return [Urn(hree) for hree in hrees]\n        except etree.XMLSyntaxError:\n            return list()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef create_free_space_request_content():\n        root = etree.Element('propfind', xmlns='DAV:')\n        prop = etree.SubElement(root, 'prop')\n        etree.SubElement(prop, 'quota-available-bytes')\n        etree.SubElement(prop, 'quota-used-bytes')\n        tree = etree.ElementTree(root)\n        return WebDavXmlUtils.etree_to_string(tree)", "response": "Creates an XML string for requesting of free space on remote WebDAV server."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef parse_free_space_response(content, hostname):\n        try:\n            tree = etree.fromstring(content)\n            node = tree.find('.//{DAV:}quota-available-bytes')\n            if node is not None:\n                return int(node.text)\n            else:\n                raise MethodNotSupported(name='free', server=hostname)\n        except TypeError:\n            raise MethodNotSupported(name='free', server=hostname)\n        except etree.XMLSyntaxError:\n            return str()", "response": "Parses the response content XML from WebDAV server and extracts an amount of free space in bytes."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nparse the response content XML from WebDAV server and extracts an information about resource.", "response": "def parse_info_response(content, path, hostname):\n        \"\"\"Parses of response content XML from WebDAV server and extract an information about resource.\n\n        :param content: the XML content of HTTP response from WebDAV server.\n        :param path: the path to resource.\n        :param hostname: the server hostname.\n        :return: a dictionary of information attributes and them values with following keys:\n                 `created`: date of resource creation,\n                 `name`: name of resource,\n                 `size`: size of resource,\n                 `modified`: date of resource modification.\n        \"\"\"\n        response = WebDavXmlUtils.extract_response_for_path(content=content, path=path, hostname=hostname)\n        find_attributes = {\n            'created': './/{DAV:}creationdate',\n            'name': './/{DAV:}displayname',\n            'size': './/{DAV:}getcontentlength',\n            'modified': './/{DAV:}getlastmodified'\n        }\n        info = dict()\n        for (name, value) in find_attributes.items():\n            info[name] = response.findtext(value)\n        return info"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nparse the response content XML from WebDAV server and extracts an information about resource.", "response": "def parse_is_dir_response(content, path, hostname):\n        \"\"\"Parses of response content XML from WebDAV server and extract an information about resource.\n\n        :param content: the XML content of HTTP response from WebDAV server.\n        :param path: the path to resource.\n        :param hostname: the server hostname.\n        :return: True in case the remote resource is directory and False otherwise.\n        \"\"\"\n        response = WebDavXmlUtils.extract_response_for_path(content=content, path=path, hostname=hostname)\n        resource_type = response.find('.//{DAV:}resourcetype')\n\n        if resource_type is None:\n            raise MethodNotSupported(name='is_dir', server=hostname)\n\n        dir_type = resource_type.find('{DAV:}collection')\n\n        return dir_type is not None"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef create_get_property_request_content(option):\n        root = etree.Element('propfind', xmlns='DAV:')\n        prop = etree.SubElement(root, 'prop')\n        etree.SubElement(prop, option.get('name', ''), xmlns=option.get('namespace', ''))\n        tree = etree.ElementTree(root)\n        return WebDavXmlUtils.etree_to_string(tree)", "response": "Creates an XML for requesting of getting a property value of remote WebDAV resource."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef parse_get_property_response(content, name):\n        tree = etree.fromstring(content)\n        return tree.xpath('//*[local-name() = $name]', name=name)[0].text", "response": "Parses the response content XML from WebDAV server for getting metadata property value for some resource."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef create_set_property_batch_request_content(options):\n        root_node = etree.Element('propertyupdate', xmlns='DAV:')\n        set_node = etree.SubElement(root_node, 'set')\n        prop_node = etree.SubElement(set_node, 'prop')\n        for option in options:\n            opt_node = etree.SubElement(prop_node, option['name'], xmlns=option.get('namespace', ''))\n            opt_node.text = option.get('value', '')\n        tree = etree.ElementTree(root_node)\n        return WebDavXmlUtils.etree_to_string(tree)", "response": "Creates an XML for requesting of setting a property values for remote WebDAV resource in batch."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating a string from lxml. etree. ElementTree with XML declaration and UTF - 8 encoding.", "response": "def etree_to_string(tree):\n        \"\"\"Creates string from lxml.etree.ElementTree with XML declaration and UTF-8 encoding.\n\n        :param tree: the instance of ElementTree\n        :return: the string of XML.\n        \"\"\"\n        buff = BytesIO()\n        tree.write(buff, xml_declaration=True, encoding='UTF-8')\n        return buff.getvalue()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef extract_response_for_path(content, path, hostname):\n        try:\n            tree = etree.fromstring(content)\n            responses = tree.findall('{DAV:}response')\n\n            n_path = Urn.normalize_path(path)\n\n            for resp in responses:\n                href = resp.findtext('{DAV:}href')\n\n                if Urn.compare_path(n_path, href) is True:\n                    return resp\n            raise RemoteResourceNotFound(path)\n        except etree.XMLSyntaxError:\n            raise MethodNotSupported(name='is_dir', server=hostname)", "response": "Extracts the response for a remote resource defined by path."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef cleanup(config_dir):\n    stdout_path = os.path.join(config_dir, 'pueue.stdout')\n    stderr_path = os.path.join(config_dir, 'pueue.stderr')\n    if os._exists(stdout_path):\n        os.remove(stdout_path)\n    if os._exists(stderr_path):\n        os.remove(stderr_path)\n\n    socketPath = os.path.join(config_dir, 'pueue.sock')\n    if os.path.exists(socketPath):\n        os.remove(socketPath)", "response": "Remove temporary stderr and stdout files as well as the daemon socket."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting the descriptor output and handle incorrect UTF - 8 encoding of subprocess logs.", "response": "def get_descriptor_output(descriptor, key, handler=None):\n    \"\"\"Get the descriptor output and handle incorrect UTF-8 encoding of subprocess logs.\n\n    In case an process contains valid UTF-8 lines as well as invalid lines, we want to preserve\n    the valid and remove the invalid ones.\n    To do this we need to get each line and check for an UnicodeDecodeError.\n    \"\"\"\n    line = 'stub'\n    lines = ''\n    while line != '':\n        try:\n            line = descriptor.readline()\n            lines += line\n        except UnicodeDecodeError:\n            error_msg = \"Error while decoding output of process {}\".format(key)\n            if handler:\n                handler.logger.error(\"{} with command {}\".format(\n                    error_msg, handler.queue[key]['command']))\n            lines += error_msg + '\\n'\n    return lines.replace('\\n', '\\n    ')"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nrequesting the conversion server for a given file.", "response": "def request(self, hash_, quickkey, doc_type, page=None,\n                output=None, size_id=None, metadata=None,\n                request_conversion_only=None):\n        \"\"\"Query conversion server\n\n        hash_: 4 characters of file hash\n        quickkey: File quickkey\n        doc_type: \"i\" for image, \"d\" for documents\n        page: The page to convert. If page is set to 'initial', the first\n              10 pages of the document will be provided. (document)\n        output: \"pdf\", \"img\", or \"swf\" (document)\n        size_id: 0,1,2 (document)\n                 0-9, a-f, z (image)\n        metadata: Set to 1 to get metadata dict\n        request_conversion_only: Request conversion w/o content\n        \"\"\"\n\n        if len(hash_) > 4:\n            hash_ = hash_[:4]\n\n        query = QueryParams({\n            'quickkey': quickkey,\n            'doc_type': doc_type,\n            'page': page,\n            'output': output,\n            'size_id': size_id,\n            'metadata': metadata,\n            'request_conversion_only': request_conversion_only\n        })\n\n        url = API_ENDPOINT + '?' + hash_ + '&' + urlencode(query)\n\n        response = self.http.get(url, stream=True)\n\n        if response.status_code == 204:\n            raise ConversionServerError(\"Unable to fulfill request. \"\n                                        \"The document will not be converted.\",\n                                        response.status_code)\n\n        response.raise_for_status()\n\n        if response.headers['content-type'] == 'application/json':\n            return response.json()\n\n        return response"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncalls every command that was set for the current active breakpoints. Returns True if the normal interaction function must be called False otherwise.", "response": "def bp_commands(self, frame, breakpoint_hits):\n        \"\"\"Call every command that was set for the current active breakpoints.\n\n        Returns True if the normal interaction function must be called,\n        False otherwise.\"\"\"\n        # Handle multiple breakpoints on the same line (issue 14789)\n        effective_bp_list, temporaries = breakpoint_hits\n        silent = True\n        doprompt = False\n        atleast_one_cmd = False\n        for bp in effective_bp_list:\n            if bp in self.commands:\n                if not atleast_one_cmd:\n                    atleast_one_cmd = True\n                    self.setup(frame, None)\n                lastcmd_back = self.lastcmd\n                for line in self.commands[bp]:\n                    self.onecmd(line)\n                self.lastcmd = lastcmd_back\n                if not self.commands_silent[bp]:\n                    silent = False\n                if self.commands_doprompt[bp]:\n                    doprompt = True\n        # Delete the temporary breakpoints.\n        tmp_to_delete = ' '.join(str(bp) for bp in temporaries)\n        if tmp_to_delete:\n            self.do_clear(tmp_to_delete)\n\n        if atleast_one_cmd:\n            return doprompt, silent\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef user_return(self, frame, return_value):\n        frame.f_locals['__return__'] = return_value\n        self.message('--Return--')\n        self.interaction(frame, None)", "response": "This function is called when a user returns a value."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef user_exception(self, frame, exc_info):\n        exc_type, exc_value, exc_traceback = exc_info\n        frame.f_locals['__exception__'] = exc_type, exc_value\n\n        # An 'Internal StopIteration' exception is an exception debug event\n        # issued by the interpreter when handling a subgenerator run with\n        # 'yield from' or a generator controled by a for loop. No exception has\n        # actually occured in this case. The debugger uses this debug event to\n        # stop when the debuggee is returning from such generators.\n        prefix = 'Internal ' if (PY34 and not exc_traceback\n                                    and exc_type is StopIteration) else ''\n        self.message('--Exception--\\n%s%s' % (prefix,\n            traceback.format_exception_only(exc_type, exc_value)[-1].strip()))\n        self.interaction(frame, exc_traceback)", "response": "This function is called if an exception occurs and only if we are to stop at or just below this level."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nhandling alias expansion and ';;' separator.", "response": "def precmd(self, line):\n        \"\"\"Handle alias expansion and ';;' separator.\"\"\"\n        if not line.strip():\n            return line\n        args = line.split()\n        while args[0] in self.aliases:\n            line = self.aliases[args[0]]\n            ii = 1\n            for tmpArg in args[1:]:\n                line = line.replace(\"%\" + str(ii),\n                                      tmpArg)\n                ii += 1\n            line = line.replace(\"%*\", ' '.join(args[1:]))\n            args = line.split()\n        # split into ';;' separated commands\n        # unless it's an alias command\n        if args[0] != 'alias':\n            marker = line.find(';;')\n            if marker >= 0:\n                # queue up everything after marker\n                next = line[marker+2:].lstrip()\n                self.cmdqueue.append(next)\n                line = line[:marker].rstrip()\n        return line"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef onecmd(self, line):\n        if not self.commands_defining:\n            return cmd.Cmd.onecmd(self, line)\n        else:\n            return self.handle_command_def(line)", "response": "Interpret the argument as though it had been typed in response\n        to the prompt."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef handle_command_def(self, line):\n        cmd, arg, line = self.parseline(line)\n        if not cmd:\n            return\n        if cmd == 'silent':\n            self.commands_silent[self.commands_bnum] = True\n            return # continue to handle other cmd def in the cmd list\n        elif cmd == 'end':\n            self.cmdqueue = []\n            return 1 # end of cmd list\n        cmdlist = self.commands[self.commands_bnum]\n        if arg:\n            cmdlist.append(cmd+' '+arg)\n        else:\n            cmdlist.append(cmd)\n        # Determine if we must stop\n        try:\n            func = getattr(self, 'do_' + cmd)\n        except AttributeError:\n            func = self.default\n        # one of the resuming commands\n        if func.__name__ in self.commands_resuming:\n            self.commands_doprompt[self.commands_bnum] = False\n            self.cmdqueue = []\n            return 1\n        return", "response": "Handles one command line during command list definition."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncommands [bpnumber] (com) ... (com) end (Pdb) Specify a list of commands for breakpoint number bpnumber. The commands themselves are entered on the following lines. Type a line containing just 'end' to terminate the commands. The commands are executed when the breakpoint is hit. To remove all commands from a breakpoint, type commands and follow it immediately with end; that is, give no commands. With no bpnumber argument, commands refers to the last breakpoint set. You can use breakpoint commands to start your program up again. Simply use the continue command, or step, or any other command that resumes execution. Specifying any command resuming execution (currently continue, step, next, return, jump, quit and their abbreviations) terminates the command list (as if that command was immediately followed by end). This is because any time you resume execution (even with a simple next or step), you may encounter another breakpoint -- which could have its own command list, leading to ambiguities about which list to execute. If you use the 'silent' command in the command list, the usual message about stopping at a breakpoint is not printed. This may be desirable for breakpoints that are to print a specific message and then continue. If none of the other commands print anything, you will see no sign that the breakpoint was reached.", "response": "def do_commands(self, arg):\n        \"\"\"commands [bpnumber]\n        (com) ...\n        (com) end\n        (Pdb)\n\n        Specify a list of commands for breakpoint number bpnumber.\n        The commands themselves are entered on the following lines.\n        Type a line containing just 'end' to terminate the commands.\n        The commands are executed when the breakpoint is hit.\n\n        To remove all commands from a breakpoint, type commands and\n        follow it immediately with end; that is, give no commands.\n\n        With no bpnumber argument, commands refers to the last\n        breakpoint set.\n\n        You can use breakpoint commands to start your program up\n        again.  Simply use the continue command, or step, or any other\n        command that resumes execution.\n\n        Specifying any command resuming execution (currently continue,\n        step, next, return, jump, quit and their abbreviations)\n        terminates the command list (as if that command was\n        immediately followed by end).  This is because any time you\n        resume execution (even with a simple next or step), you may\n        encounter another breakpoint -- which could have its own\n        command list, leading to ambiguities about which list to\n        execute.\n\n        If you use the 'silent' command in the command list, the usual\n        message about stopping at a breakpoint is not printed.  This\n        may be desirable for breakpoints that are to print a specific\n        message and then continue.  If none of the other commands\n        print anything, you will see no sign that the breakpoint was\n        reached.\n        \"\"\"\n        if not arg:\n            bnum = len(bdb.Breakpoint.bpbynumber) - 1\n        else:\n            try:\n                bnum = int(arg)\n            except Exception:\n                self.error(\"Usage: commands [bnum]\\n        ...\\n        end\")\n                return\n        self.commands_bnum = bnum\n        # Save old definitions for the case of a keyboard interrupt.\n        if bnum in self.commands:\n            old_command_defs = (self.commands[bnum],\n                                self.commands_doprompt[bnum],\n                                self.commands_silent[bnum])\n        else:\n            old_command_defs = None\n        self.commands[bnum] = []\n        self.commands_doprompt[bnum] = True\n        self.commands_silent[bnum] = False\n\n        prompt_back = self.prompt\n        self.prompt = '(com) '\n        self.commands_defining = True\n        try:\n            self.cmdloop()\n        except KeyboardInterrupt:\n            # Restore old definitions.\n            if old_command_defs:\n                self.commands[bnum] = old_command_defs[0]\n                self.commands_doprompt[bnum] = old_command_defs[1]\n                self.commands_silent[bnum] = old_command_defs[2]\n            else:\n                del self.commands[bnum]\n                del self.commands_doprompt[bnum]\n                del self.commands_silent[bnum]\n            self.error('command definition aborted, old commands restored')\n        finally:\n            self.commands_defining = False\n            self.prompt = prompt_back"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef do_break(self, arg, temporary = 0):\n        if not arg:\n            all_breaks = '\\n'.join(bp.bpformat() for bp in\n                                bdb.Breakpoint.bpbynumber if bp)\n            if all_breaks:\n                self.message(\"Num Type         Disp Enb   Where\")\n                self.message(all_breaks)\n            return\n\n        # Parse arguments, comma has lowest precedence and cannot occur in\n        # filename.\n        args = arg.rsplit(',', 1)\n        cond =  args[1].strip() if len(args) == 2 else None\n        # Parse stuff before comma: [filename:]lineno | function.\n        args = args[0].rsplit(':', 1)\n        name = args[0].strip()\n        lineno =  args[1] if len(args) == 2 else args[0]\n        try:\n            lineno = int(lineno)\n        except ValueError:\n            if len(args) == 2:\n                self.error('Bad lineno: \"{}\".'.format(lineno))\n            else:\n                # Attempt the list of possible function or method fully\n                # qualified names and corresponding filenames.\n                candidates = get_fqn_fname(name, self.curframe)\n                for fqn, fname in candidates:\n                    try:\n                        bp = self.set_break(fname, None, temporary, cond, fqn)\n                        self.message('Breakpoint {:d} at {}:{:d}'.format(\n                                                bp.number, bp.file, bp.line))\n                        return\n                    except bdb.BdbError:\n                        pass\n                if not candidates:\n                    self.error(\n                        'Not a function or a built-in: \"{}\"'.format(name))\n                else:\n                    self.error('Bad name: \"{}\".'.format(name))\n        else:\n            filename = self.curframe.f_code.co_filename\n            if len(args) == 2 and name:\n                filename = name\n            if filename.startswith('<') and filename.endswith('>'):\n                # allow <doctest name>: doctest installs a hook at\n                # linecache.getlines to allow <doctest name> to be\n                # linecached and readable.\n                if filename == '<string>' and self.mainpyfile:\n                    filename = self.mainpyfile\n            else:\n                root, ext = os.path.splitext(filename)\n                if ext == '':\n                    filename = filename + '.py'\n                if not os.path.exists(filename):\n                    self.error('Bad filename: \"{}\".'.format(arg))\n                    return\n            try:\n                bp = self.set_break(filename, lineno, temporary, cond)\n            except bdb.BdbError as err:\n                self.error(err)\n            else:\n                self.message('Breakpoint {:d} at {}:{:d}'.format(\n                                        bp.number, bp.file, bp.line))", "response": "Set a breakpoint at the current line of the current file."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nproduce a reasonable default.", "response": "def defaultFile(self):\n        \"\"\"Produce a reasonable default.\"\"\"\n        filename = self.curframe.f_code.co_filename\n        if filename == '<string>' and self.mainpyfile:\n            filename = self.mainpyfile\n        return filename"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nenables the breakpoint numbers given as a space separated list of breakpoint numbers.", "response": "def do_enable(self, arg):\n        \"\"\"enable bpnumber [bpnumber ...]\n        Enables the breakpoints given as a space separated list of\n        breakpoint numbers.\n        \"\"\"\n        args = arg.split()\n        for i in args:\n            try:\n                bp = self.get_bpbynumber(i)\n            except ValueError as err:\n                self.error(err)\n            else:\n                bp.enable()\n                self.done_breakpoint_state(bp, True)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef do_disable(self, arg):\n        args = arg.split()\n        for i in args:\n            try:\n                bp = self.get_bpbynumber(i)\n            except ValueError as err:\n                self.error(err)\n            else:\n                bp.disable()\n                self.done_breakpoint_state(bp, False)", "response": "Disable the breakpoint with the given number."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsets a condition for the breakpoint.", "response": "def do_condition(self, arg):\n        \"\"\"condition bpnumber [condition]\n        Set a new condition for the breakpoint, an expression which\n        must evaluate to true before the breakpoint is honored.  If\n        condition is absent, any existing condition is removed; i.e.,\n        the breakpoint is made unconditional.\n        \"\"\"\n        args = arg.split(' ', 1)\n        try:\n            cond = args[1]\n        except IndexError:\n            cond = None\n        try:\n            bp = self.get_bpbynumber(args[0].strip())\n        except IndexError:\n            self.error('Breakpoint number expected')\n        except ValueError as err:\n            self.error(err)\n        else:\n            bp.cond = cond\n            if not cond:\n                self.message('Breakpoint %d is now unconditional.' % bp.number)\n            else:\n                self.message('New condition set for breakpoint %d.' % bp.number)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef do_ignore(self, arg):\n        args = arg.split(' ', 1)\n        try:\n            count = int(args[1].strip())\n        except Exception:\n            count = 0\n        try:\n            bp = self.get_bpbynumber(args[0].strip())\n        except IndexError:\n            self.error('Breakpoint number expected')\n        except ValueError as err:\n            self.error(err)\n        else:\n            bp.ignore = count\n            if count > 0:\n                if count > 1:\n                    countstr = '%d crossings' % count\n                else:\n                    countstr = '1 crossing'\n                self.message('Will ignore next %s of breakpoint %d.' %\n                             (countstr, bp.number))\n            else:\n                self.message('Will stop next time breakpoint %d is reached.'\n                             % bp.number)", "response": "ignore bpnumber [ count ]"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nclear all breakpoint numbers at a specific line in a file.", "response": "def do_clear(self, arg):\n        \"\"\"cl(ear) filename:lineno\\ncl(ear) [bpnumber [bpnumber...]]\n        With a space separated list of breakpoint numbers, clear\n        those breakpoints.  Without argument, clear all breaks (but\n        first ask confirmation).  With a filename:lineno argument,\n        clear all breaks at that line in that file.\n        \"\"\"\n        if not arg:\n            try:\n                if PY3:\n                    reply = input('Clear all breaks? ')\n                else:\n                    reply = raw_input('Clear all breaks? ')\n            except EOFError:\n                reply = 'no'\n            reply = reply.strip().lower()\n            if reply in ('y', 'yes'):\n                bplist = [bp for bp in bdb.Breakpoint.bpbynumber if bp]\n                self.clear_all_breaks()\n                for bp in bplist:\n                    self.done_delete_breakpoint(bp)\n            return\n        if ':' in arg:\n            # Make sure it works for \"clear C:\\foo\\bar.py:12\"\n            i = arg.rfind(':')\n            filename = arg[:i]\n            arg = arg[i+1:]\n            try:\n                lineno = int(arg)\n            except ValueError:\n                err = \"Invalid line number (%s)\" % arg\n            else:\n                bplist = self.get_breaks(filename, lineno)\n                err = self.clear_break(filename, lineno)\n            if err:\n                self.error(err)\n            else:\n                for bp in bplist:\n                    self.done_delete_breakpoint(bp)\n            return\n        numberlist = arg.split()\n        for i in numberlist:\n            try:\n                bp = self.get_bpbynumber(i)\n            except ValueError as err:\n                self.error(err)\n            else:\n                self.clear_bpbynumber(i)\n                self.done_delete_breakpoint(bp)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef do_up(self, arg):\n        if self.curindex == 0:\n            self.error('Oldest frame')\n            return\n        try:\n            count = int(arg or 1)\n        except ValueError:\n            self.error('Invalid frame count (%s)' % arg)\n            return\n        if count < 0:\n            newframe = 0\n        else:\n            newframe = max(0, self.curindex - count)\n        self._select_frame(newframe)", "response": "u ( p ) [ count ] Move the current frame count up in the current stack trace."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef do_until(self, arg):\n        if arg:\n            try:\n                lineno = int(arg)\n            except ValueError:\n                self.error('Error in argument: %r' % arg)\n                return\n            if lineno <= self.curframe.f_lineno:\n                self.error('\"until\" line number is smaller than current '\n                           'line number')\n                return\n        else:\n            lineno = None\n        self.set_until(self.curframe, lineno)\n        self.set_sigint_handler()\n        return 1", "response": "This function is used to continue execution until the current line with the specified number is reached."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef do_run(self, arg):\n        if arg:\n            argv0 = sys.argv[0:1]\n            sys.argv = shlex.split(arg)\n            sys.argv[:0] = argv0\n        # this is caught in the main debugger loop\n        raise Restart", "response": "run - run the debugged python program"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef do_jump(self, arg):\n        if self.curindex + 1 != len(self.stack):\n            self.error('You can only jump within the bottom frame')\n            return\n        try:\n            arg = int(arg)\n        except ValueError:\n            self.error(\"The 'jump' command requires a line number\")\n        else:\n            try:\n                # Do the jump, fix up our copy of the stack, and display the\n                # new position\n                self.curframe.f_lineno = arg\n                self.stack[self.curindex] = self.stack[self.curindex][0], arg\n                self.print_stack_entry(self.stack[self.curindex])\n            except ValueError as e:\n                self.error('Jump failed: %s' % e)", "response": "Jump to the next line in the current iteration."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndebug code Enter a recursive debugger that steps through the code argument.", "response": "def do_debug(self, arg):\n        \"\"\"debug code\n        Enter a recursive debugger that steps through the code\n        argument (which is an arbitrary expression or statement to be\n        executed in the current environment).\n        \"\"\"\n        self.settrace(False)\n        globals = self.curframe.f_globals\n        locals = self.get_locals(self.curframe)\n        p = Pdb(self.completekey, self.stdin, self.stdout, debug=True)\n        p.prompt = \"(%s) \" % self.prompt.strip()\n        self.message(\"ENTERING RECURSIVE DEBUGGER\")\n        sys.call_tracing(p.run, (arg, globals, locals))\n        self.message(\"LEAVING RECURSIVE DEBUGGER\")\n        self.settrace(True)\n        self.lastcmd = p.lastcmd"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef do_quit(self, arg):\n        if isinstance(self.stdin, RemoteSocket) and not self.is_debug_instance:\n            return self.do_detach(arg)\n        self._user_requested_quit = True\n        self.set_quit()\n        return 1", "response": "quit - Quit from the debugger."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef do_args(self, arg):\n        co = self.curframe.f_code\n        dict = self.get_locals(self.curframe)\n        n = co.co_argcount\n        if co.co_flags & 4: n = n+1\n        if co.co_flags & 8: n = n+1\n        for i in range(n):\n            name = co.co_varnames[i]\n            if name in dict:\n                self.message('%s = %s' % (name, bdb.safe_repr(dict[name])))\n            else:\n                self.message('%s = *** undefined ***' % (name,))", "response": "a ( rgs ) Print the argument list of the current function."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef do_retval(self, arg):\n        locals = self.get_locals(self.curframe)\n        if '__return__' in locals:\n            self.message(bdb.safe_repr(locals['__return__']))\n        else:\n            self.error('Not yet returned!')", "response": "retval Print the return value of the last function."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef do_pp(self, arg):\n        obj = self._getval(arg)\n        try:\n            repr(obj)\n        except Exception:\n            self.message(bdb.safe_repr(obj))\n        else:\n            self.message(pprint.pformat(obj))", "response": "pp expression\n            Pretty - print the value of the expression."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef do_list(self, arg):\n        self.lastcmd = 'list'\n        last = None\n        if arg and arg != '.':\n            try:\n                if ',' in arg:\n                    first, last = arg.split(',')\n                    first = int(first.strip())\n                    last = int(last.strip())\n                    if last < first:\n                        # assume it's a count\n                        last = first + last\n                else:\n                    first = int(arg.strip())\n                    first = max(1, first - 5)\n            except ValueError:\n                self.error('Error in argument: %r' % arg)\n                return\n        elif self.lineno is None or arg == '.':\n            first = max(1, self.curframe.f_lineno - 5)\n        else:\n            first = self.lineno + 1\n        if last is None:\n            last = first + 10\n        filename = self.curframe.f_code.co_filename\n        breaklist = self.get_file_breaks(filename)\n        try:\n            lines = linecache.getlines(filename, self.curframe.f_globals)\n            self._print_lines(lines[first-1:last], first, breaklist,\n                              self.curframe)\n            self.lineno = min(last, len(lines))\n            if len(lines) < last:\n                self.message('[EOF]')\n        except KeyboardInterrupt:\n            pass", "response": "l - list - list source code for the current file."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsources expression Try to get source code for the given object and display it.", "response": "def do_source(self, arg):\n        \"\"\"source expression\n        Try to get source code for the given object and display it.\n        \"\"\"\n        try:\n            obj = self._getval(arg)\n        except Exception:\n            return\n        try:\n            lines, lineno = getsourcelines(obj, self.get_locals(self.curframe))\n        except (IOError, TypeError) as err:\n            self.error(err)\n            return\n        self._print_lines(lines, lineno)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _print_lines(self, lines, start, breaks=(), frame=None):\n        if frame:\n            current_lineno = frame.f_lineno\n            exc_lineno = self.tb_lineno.get(frame, -1)\n        else:\n            current_lineno = exc_lineno = -1\n        for lineno, line in enumerate(lines, start):\n            s = str(lineno).rjust(3)\n            if len(s) < 4:\n                s += ' '\n            if lineno in breaks:\n                s += 'B'\n            else:\n                s += ' '\n            if lineno == current_lineno:\n                s += '->'\n            elif lineno == exc_lineno:\n                s += '>>'\n            self.message(s + '\\t' + line.rstrip())", "response": "Print a range of lines."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef do_whatis(self, arg):\n        try:\n            value = self._getval(arg)\n        except Exception:\n            # _getval() already printed the error\n            return\n        code = None\n        # Is it a function?\n        try:\n            code = value.__code__\n        except Exception:\n            pass\n        if code:\n            self.message('Function %s' % code.co_name)\n            return\n        # Is it an instance method?\n        try:\n            code = value.__func__.__code__\n        except Exception:\n            pass\n        if code:\n            self.message('Method %s' % code.co_name)\n            return\n        # Is it a class?\n        if value.__class__ is type:\n            self.message('Class %s.%s' % (value.__module__, value.__name__))\n            return\n        # None of the above...\n        self.message(type(value))", "response": "whatis Print the type of the argument."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ndisplays [ expression ] Display the value of the expression each time execution stops in the current frame.", "response": "def do_display(self, arg):\n        \"\"\"display [expression]\n\n        Display the value of the expression if it changed, each time execution\n        stops in the current frame.\n\n        Without expression, list all display expressions for the current frame.\n        \"\"\"\n        if not arg:\n            self.message('Currently displaying:')\n            for item in self.displaying.get(self.curframe, {}).items():\n                self.message('%s: %s' % bdb.safe_repr(item))\n        else:\n            val = self._getval_except(arg)\n            self.displaying.setdefault(self.curframe, {})[arg] = val\n            self.message('display %s: %s' % (arg, bdb.safe_repr(val)))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef do_undisplay(self, arg):\n        if arg:\n            try:\n                del self.displaying.get(self.curframe, {})[arg]\n            except KeyError:\n                self.error('not displaying %s' % arg)\n        else:\n            self.displaying.pop(self.curframe, None)", "response": "Undisplay the expression with the current frame."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ninteracting with the current scope.", "response": "def do_interact(self, arg):\n        \"\"\"interact\n\n        Start an interative interpreter whose global namespace\n        contains all the (global and local) names found in the current scope.\n        \"\"\"\n        def readfunc(prompt):\n            self.stdout.write(prompt)\n            self.stdout.flush()\n            line = self.stdin.readline()\n            line = line.rstrip('\\r\\n')\n            if line == 'EOF':\n                raise EOFError\n            return line\n\n        ns = self.curframe.f_globals.copy()\n        ns.update(self.get_locals(self.curframe))\n        if isinstance(self.stdin, RemoteSocket):\n            # Main interpreter redirection of the code module.\n            if PY3:\n                import sys as _sys\n            else:\n                # Parent module 'pdb_clone' not found while handling absolute\n                # import.\n                _sys = __import__('sys', level=0)\n            code.sys = _sys\n            self.redirect(code.interact, local=ns, readfunc=readfunc)\n        else:\n            code.interact(\"*interactive*\", local=ns)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nalias [name [command [parameter parameter ...] ]] Create an alias called 'name' that executes 'command'. The command must *not* be enclosed in quotes. Replaceable parameters can be indicated by %1, %2, and so on, while %* is replaced by all the parameters. If no command is given, the current alias for name is shown. If no name is given, all aliases are listed. Aliases may be nested and can contain anything that can be legally typed at the pdb prompt. Note! You *can* override internal pdb commands with aliases! Those internal commands are then hidden until the alias is removed. Aliasing is recursively applied to the first word of the command line; all other words in the line are left alone. As an example, here are two useful aliases (especially when placed in the .pdbrc file): # Print instance variables (usage \"pi classInst\") alias pi for k in %1.__dict__.keys(): print(\"%1.\",k,\"=\",%1.__dict__[k]) # Print instance variables in self alias ps pi self", "response": "def do_alias(self, arg):\n        \"\"\"alias [name [command [parameter parameter ...] ]]\n        Create an alias called 'name' that executes 'command'.  The\n        command must *not* be enclosed in quotes.  Replaceable\n        parameters can be indicated by %1, %2, and so on, while %* is\n        replaced by all the parameters.  If no command is given, the\n        current alias for name is shown. If no name is given, all\n        aliases are listed.\n\n        Aliases may be nested and can contain anything that can be\n        legally typed at the pdb prompt.  Note!  You *can* override\n        internal pdb commands with aliases!  Those internal commands\n        are then hidden until the alias is removed.  Aliasing is\n        recursively applied to the first word of the command line; all\n        other words in the line are left alone.\n\n        As an example, here are two useful aliases (especially when\n        placed in the .pdbrc file):\n\n        # Print instance variables (usage \"pi classInst\")\n        alias pi for k in %1.__dict__.keys(): print(\"%1.\",k,\"=\",%1.__dict__[k])\n        # Print instance variables in self\n        alias ps pi self\n        \"\"\"\n        args = arg.split()\n        if len(args) == 0:\n            keys = sorted(self.aliases.keys())\n            for alias in keys:\n                self.message(\"%s = %s\" % (alias, self.aliases[alias]))\n            return\n        if args[0] in self.aliases and len(args) == 1:\n            self.message(\"%s = %s\" % (args[0], self.aliases[args[0]]))\n        else:\n            self.aliases[args[0]] = ' '.join(args[1:])"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef do_thread(self, arg):\n        # Import the threading module in the main interpreter to get an\n        # enumeration of the main interpreter threads.\n        if PY3:\n            try:\n                import threading\n            except ImportError:\n                import dummy_threading as threading\n        else:\n            # Do not use relative import detection to avoid the RuntimeWarning:\n            # Parent module 'pdb_clone' not found while handling absolute\n            # import.\n            try:\n                threading = __import__('threading', level=0)\n            except ImportError:\n                threading = __import__('dummy_threading', level=0)\n\n\n        if not self.pdb_thread:\n            self.pdb_thread = threading.current_thread()\n        if not self.current_thread:\n            self.current_thread = self.pdb_thread\n        current_frames = sys._current_frames()\n        tlist = sorted(threading.enumerate(), key=attrgetter('name', 'ident'))\n        try:\n            self._do_thread(arg, current_frames, tlist)\n        finally:\n            # For some reason this local must be explicitly deleted in order\n            # to release the subinterpreter.\n            del current_frames", "response": "This command is used to display a summary of all active threads."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef do_help(self, arg):\n        if not arg:\n            return cmd.Cmd.do_help(self, arg)\n        try:\n            try:\n                topic = getattr(self, 'help_' + arg)\n                return topic()\n            except AttributeError:\n                command = getattr(self, 'do_' + arg)\n        except AttributeError:\n            self.error('No help for %r' % arg)\n        else:\n            if sys.flags.optimize >= 2:\n                self.error('No help for %r; please do not run Python with -OO '\n                           'if you need command help' % arg)\n                return\n            self.message(command.__doc__.rstrip())", "response": "Help for a specific command name"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef read(self, limit=-1):\n        remaining = self.len - self.parent_fd.tell() + self.offset\n\n        if limit > remaining or limit == -1:\n            limit = remaining\n\n        return self.parent_fd.read(limit)", "response": "Read content. See file. read"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nseeks to the specified offset in the file.", "response": "def seek(self, offset, whence=os.SEEK_SET):\n        \"\"\"Seek to position in stream, see file.seek\"\"\"\n\n        pos = None\n        if whence == os.SEEK_SET:\n            pos = self.offset + offset\n        elif whence == os.SEEK_CUR:\n            pos = self.tell() + offset\n        elif whence == os.SEEK_END:\n            pos = self.offset + self.len + offset\n        else:\n            raise ValueError(\"invalid whence {}\".format(whence))\n\n        if pos > self.offset + self.len or pos < self.offset:\n            raise ValueError(\"seek position beyond chunk area\")\n\n        self.parent_fd.seek(pos, os.SEEK_SET)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef close(self):\n        try:\n            self.parent_fd.fileno()\n        except io.UnsupportedOperation:\n            logger.debug(\"Not closing parent_fd - reusing existing\")\n        else:\n            self.parent_fd.close()", "response": "Close file and close parent file."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _build_query(self, uri, params=None, action_token_type=None):\n\n        if params is None:\n            params = QueryParams()\n\n        params['response_format'] = 'json'\n\n        session_token = None\n\n        if action_token_type in self._action_tokens:\n            # Favor action token\n            using_action_token = True\n            session_token = self._action_tokens[action_token_type]\n        else:\n            using_action_token = False\n            if self._session:\n                session_token = self._session['session_token']\n\n        if session_token:\n            params['session_token'] = session_token\n\n        # make order of parameters predictable for testing\n        keys = list(params.keys())\n        keys.sort()\n\n        query = urlencode([tuple([key, params[key]]) for key in keys])\n\n        if not using_action_token and self._session:\n            secret_key_mod = int(self._session['secret_key']) % 256\n\n            signature_base = (str(secret_key_mod) +\n                              self._session['time'] +\n                              uri + '?' + query).encode('ascii')\n\n            query += '&signature=' + hashlib.md5(signature_base).hexdigest()\n\n        return query", "response": "Build a query string from the uri and params."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef request(self, action, params=None, action_token_type=None,\n                upload_info=None, headers=None):\n        \"\"\"Perform request to MediaFire API\n\n        action -- \"category/name\" of method to call\n        params -- dict of parameters or query string\n        action_token_type -- action token to use: None, \"upload\", \"image\"\n        upload_info -- in case of upload, dict of \"fd\" and \"filename\"\n        headers -- additional headers to send (used for upload)\n\n        session_token and signature generation/update is handled automatically\n        \"\"\"\n\n        uri = self._build_uri(action)\n\n        if isinstance(params, six.text_type):\n            query = params\n        else:\n            query = self._build_query(uri, params, action_token_type)\n\n        if headers is None:\n            headers = {}\n\n        if upload_info is None:\n            # Use request body for query\n            data = query\n            headers['Content-Type'] = FORM_MIMETYPE\n        else:\n            # Use query string for query since payload is file\n            uri += '?' + query\n\n            if \"filename\" in upload_info:\n                data = MultipartEncoder(\n                    fields={'file': (\n                        upload_info[\"filename\"],\n                        upload_info[\"fd\"],\n                        UPLOAD_MIMETYPE\n                    )}\n                )\n                headers[\"Content-Type\"] = data.content_type\n            else:\n                data = upload_info[\"fd\"]\n                headers[\"Content-Type\"] = UPLOAD_MIMETYPE\n\n        logger.debug(\"uri=%s query=%s\",\n                     uri, query if not upload_info else None)\n\n        try:\n            # bytes from now on\n            url = (API_BASE + uri).encode('utf-8')\n            if isinstance(data, six.text_type):\n                # request's data is bytes, dict, or filehandle\n                data = data.encode('utf-8')\n\n            response = self.http.post(url, data=data,\n                                      headers=headers, stream=True)\n        except RequestException as ex:\n            logger.exception(\"HTTP request failed\")\n            raise MediaFireConnectionError(\n                \"RequestException: {}\".format(ex))\n\n        return self._process_response(response)", "response": "Perform a request to MediaFire API and return the response."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nparse response and return a dict with the key and the value.", "response": "def _process_response(self, response):\n        \"\"\"Parse response\"\"\"\n\n        forward_raw = False\n        content_type = response.headers['Content-Type']\n        if content_type != 'application/json':\n            logger.debug(\"headers: %s\", response.headers)\n            # API BUG: text/xml content-type with json payload\n            # http://forum.mediafiredev.com/showthread.php?136\n            if content_type == 'text/xml':\n                # we never request xml, so check it quacks like JSON\n                if not response.text.lstrip().startswith('{'):\n                    forward_raw = True\n            else:\n                # _process_response can't deal with non-json,\n                # return response as is\n                forward_raw = True\n\n        if forward_raw:\n            response.raise_for_status()\n            return response\n\n        logger.debug(\"response: %s\", response.text)\n\n        # if we are here, then most likely have json\n        try:\n            response_node = response.json()['response']\n        except ValueError:\n            # promised JSON but failed\n            raise MediaFireApiError(\"JSON decode failure\")\n\n        if response_node.get('new_key', 'no') == 'yes':\n            self._regenerate_secret_key()\n\n        # check for errors\n        if response_node['result'] != 'Success':\n            raise MediaFireApiError(response_node['message'],\n                                    response_node['error'])\n\n        return response_node"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _regenerate_secret_key(self):\n        # Don't regenerate the key if we have none\n        if self._session and 'secret_key' in self._session:\n            self._session['secret_key'] = (\n                int(self._session['secret_key']) * 16807) % 2147483647", "response": "Regenerate the secret key for the user."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef session(self, value):\n\n        # unset session token\n        if value is None:\n            self._session = None\n            return\n\n        if not isinstance(value, dict):\n            raise ValueError(\"session info is required\")\n\n        session_parsed = {}\n\n        for key in [\"session_token\", \"time\", \"secret_key\"]:\n            if key not in value:\n                raise ValueError(\"Missing parameter: {}\".format(key))\n            session_parsed[key] = value[key]\n\n        for key in [\"ekey\", \"pkey\"]:\n            # nice to have, but not mandatory\n            if key in value:\n                session_parsed[key] = value[key]\n\n        self._session = session_parsed", "response": "Set session token from user s get_session_token method."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef set_action_token(self, type_=None, action_token=None):\n        if action_token is None:\n            del self._action_tokens[type_]\n        else:\n            self._action_tokens[type_] = action_token", "response": "Set the action token for the specified type"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef user_get_session_token(self, app_id=None, email=None, password=None,\n                               ekey=None, fb_access_token=None,\n                               tw_oauth_token=None,\n                               tw_oauth_token_secret=None, api_key=None):\n        \"\"\"user/get_session_token\n\n        http://www.mediafire.com/developers/core_api/1.3/user/#get_session_token\n        \"\"\"\n\n        if app_id is None:\n            raise ValueError(\"app_id must be defined\")\n\n        params = QueryParams({\n            'application_id': str(app_id),\n            'token_version': 2,\n            'response_format': 'json'\n        })\n\n        if fb_access_token:\n            params['fb_access_token'] = fb_access_token\n            signature_keys = ['fb_access_token']\n        elif tw_oauth_token and tw_oauth_token_secret:\n            params['tw_oauth_token'] = tw_oauth_token\n            params['tw_oauth_token_secret'] = tw_oauth_token_secret\n            signature_keys = ['tw_oauth_token',\n                              'tw_oauth_token_secret']\n        elif (email or ekey) and password:\n            signature_keys = []\n            if email:\n                signature_keys.append('email')\n                params['email'] = email\n\n            if ekey:\n                signature_keys.append('ekey')\n                params['ekey'] = ekey\n\n            params['password'] = password\n            signature_keys.append('password')\n        else:\n            raise ValueError(\"Credentials not provided\")\n\n        signature_keys.append('application_id')\n\n        signature = hashlib.sha1()\n        for key in signature_keys:\n            signature.update(str(params[key]).encode('ascii'))\n\n        # Note: If the app uses a callback URL to provide its API key,\n        # or if it does not have the \"Require Secret Key\" option checked,\n        # then the API key may be omitted from the signature\n        if api_key:\n            signature.update(api_key.encode('ascii'))\n\n        query = urlencode(params)\n        query += '&signature=' + signature.hexdigest()\n\n        return self.request('user/get_session_token', params=query)", "response": "Get the session token for a user."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef user_set_avatar(self, action=None, quick_key=None, url=None):\n        return self.request(\"user/set_avatar\", QueryParams({\n            \"action\": action,\n            \"quick_key\": quick_key,\n            \"url\": url\n        }))", "response": "This method is used to set the user s avatar."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nupdating the user information.", "response": "def user_update(self, display_name=None, first_name=None, last_name=None,\n                    email=None, password=None, current_password=None,\n                    birth_date=None, gender=None, website=None, subdomain=None,\n                    location=None, newsletter=None, primary_usage=None,\n                    timezone=None):\n        \"\"\"\n        user/update\n\n        http://www.mediafire.com/developers/core_api/1.3/user/#update\n        \"\"\"\n        return self.request(\"user/update\", QueryParams({\n            \"display_name\": display_name,\n            \"first_name\": first_name,\n            \"last_name\": last_name,\n            \"email\": email,\n            \"password\": password,\n            \"current_password\": current_password,\n            \"birth_date\": birth_date,\n            \"gender\": gender,\n            \"website\": website,\n            \"subdomain\": subdomain,\n            \"location\": location,\n            \"newsletter\": newsletter,\n            \"primary_usage\": primary_usage,\n            \"timezone\": timezone\n        }))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef folder_get_info(self, folder_key=None, device_id=None, details=None):\n        return self.request('folder/get_info', QueryParams({\n            'folder_key': folder_key,\n            'device_id': device_id,\n            'details': details\n        }))", "response": "Get information about the current folder."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting content of a specific folder.", "response": "def folder_get_content(self, folder_key=None, content_type=None,\n                           filter_=None, device_id=None, order_by=None,\n                           order_direction=None, chunk=None, details=None,\n                           chunk_size=None):\n        \"\"\"folder/get_content\n\n        http://www.mediafire.com/developers/core_api/1.3/folder/#get_content\n        \"\"\"\n        return self.request('folder/get_content', QueryParams({\n            'folder_key': folder_key,\n            'content_type': content_type,\n            'filter': filter_,\n            'device_id': device_id,\n            'order_by': order_by,\n            'order_direction': order_direction,\n            'chunk': chunk,\n            'details': details,\n            'chunk_size': chunk_size\n        }))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef folder_create(self, foldername=None, parent_key=None,\n                      action_on_duplicate=None, mtime=None):\n        \"\"\"folder/create\n\n        http://www.mediafire.com/developers/core_api/1.3/folder/#create\n        \"\"\"\n        return self.request('folder/create', QueryParams({\n            'foldername': foldername,\n            'parent_key': parent_key,\n            'action_on_duplicate': action_on_duplicate,\n            'mtime': mtime\n        }))", "response": "Create a new folder."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nupload a check to the MediaFire API.", "response": "def upload_check(self, filename=None, folder_key=None, filedrop_key=None,\n                     size=None, hash_=None, path=None, resumable=None):\n        \"\"\"upload/check\n\n        http://www.mediafire.com/developers/core_api/1.3/upload/#check\n        \"\"\"\n        return self.request('upload/check', QueryParams({\n            'filename': filename,\n            'folder_key': folder_key,\n            'filedrop_key': filedrop_key,\n            'size': size,\n            'hash': hash_,\n            'path': path,\n            'resumable': resumable\n        }))"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nuploads a resumable file to MediaFire.", "response": "def upload_resumable(self, fd, filesize, filehash, unit_hash, unit_id,\n                         unit_size, quick_key=None, action_on_duplicate=None,\n                         mtime=None, version_control=None, folder_key=None,\n                         filedrop_key=None, path=None, previous_hash=None):\n        \"\"\"upload/resumable\n\n        http://www.mediafire.com/developers/core_api/1.3/upload/#resumable\n        \"\"\"\n        action = 'upload/resumable'\n\n        headers = {\n            'x-filesize': str(filesize),\n            'x-filehash': filehash,\n            'x-unit-hash': unit_hash,\n            'x-unit-id': str(unit_id),\n            'x-unit-size': str(unit_size)\n        }\n\n        params = QueryParams({\n            'quick_key': quick_key,\n            'action_on_duplicate': action_on_duplicate,\n            'mtime': mtime,\n            'version_control': version_control,\n            'folder_key': folder_key,\n            'filedrop_key': filedrop_key,\n            'path': path,\n            'previous_hash': previous_hash\n        })\n\n        upload_info = {\n            \"fd\": fd,\n            \"filename\": \"chunk\"\n        }\n\n        return self.request(action, params, action_token_type=\"upload\",\n                            upload_info=upload_info, headers=headers)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nuploading an instant file to MediaFire.", "response": "def upload_instant(self, filename, size, hash_, quick_key=None,\n                       folder_key=None, filedrop_key=None, path=None,\n                       action_on_duplicate=None, mtime=None,\n                       version_control=None, previous_hash=None):\n        \"\"\"upload/instant\n\n        http://www.mediafire.com/developers/core_api/1.3/upload/#instant\n        \"\"\"\n        return self.request('upload/instant', QueryParams({\n            'filename': filename,\n            'size': size,\n            'hash': hash_,\n            'quick_key': quick_key,\n            'folder_key': folder_key,\n            'filedrop_key': filedrop_key,\n            'path': path,\n            'action_on_duplicate': action_on_duplicate,\n            'mtime': mtime,\n            'version_control': version_control,\n            'previous_hash': previous_hash\n        }))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nupdate the file with the quick key filename description mtime and privacy", "response": "def file_update(self, quick_key, filename=None, description=None,\n                    mtime=None, privacy=None):\n        \"\"\"file/update\n\n        http://www.mediafire.com/developers/core_api/1.3/file/#update\n        \"\"\"\n        return self.request('file/update', QueryParams({\n            'quick_key': quick_key,\n            'filename': filename,\n            'description': description,\n            'mtime': mtime,\n            'privacy': privacy\n        }))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef file_update_file(self, quick_key, file_extension=None, filename=None,\n                         description=None, mtime=None, privacy=None,\n                         timezone=None):\n        \"\"\"file/update_file\n\n        http://www.mediafire.com/developers/core_api/1.3/file/#update_file\n        \"\"\"\n        return self.request('file/update', QueryParams({\n            'quick_key': quick_key,\n            'file_extension': file_extension,\n            'filename': filename,\n            'description': description,\n            'mtime': mtime,\n            'privacy': privacy,\n            'timezone': timezone\n        }))", "response": "Update a file in the mediafire system"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ndownloading a set of keys from the MediaFire API.", "response": "def file_zip(self, keys, confirm_download=None, meta_only=None):\n        \"\"\"file/zip\n\n        http://www.mediafire.com/developers/core_api/1.3/file/#zip\n        \"\"\"\n        return self.request('file/zip', QueryParams({\n            'keys': keys,\n            'confirm_download': confirm_download,\n            'meta_only': meta_only\n        }))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _reset(self):\n        '''Reset all of our stateful variables'''\n        self._socket = None\n        # The pending messages we have to send, and the current buffer we're\n        # sending\n        self._pending = deque()\n        self._out_buffer = ''\n        # Our read buffer\n        self._buffer = ''\n        # The identify response we last received from the server\n        self._identify_response = {}\n        # Our ready state\n        self.last_ready_sent = 0\n        self.ready = 0", "response": "Reset all of our stateful variables"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef connect(self, force=False):\n        '''Establish a connection'''\n        # Don't re-establish existing connections\n        if not force and self.alive():\n            return True\n\n        self._reset()\n\n        # Otherwise, try to connect\n        with self._socket_lock:\n            try:\n                logger.info('Creating socket...')\n                self._socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n                self._socket.settimeout(self._timeout)\n                logger.info('Connecting to %s, %s', self.host, self.port)\n                self._socket.connect((self.host, self.port))\n                # Set our socket's blocking state to whatever ours is\n                self._socket.setblocking(self._blocking)\n                # Safely write our magic\n                self._pending.append(constants.MAGIC_V2)\n                while self.pending():\n                    self.flush()\n                # And send our identify command\n                self.identify(self._identify_options)\n                while self.pending():\n                    self.flush()\n                self._reconnnection_counter.success()\n                # Wait until we've gotten a response to IDENTIFY, try to read\n                # one. Also, only spend up to the provided timeout waiting to\n                # establish the connection.\n                limit = time.time() + self._timeout\n                responses = self._read(1)\n                while (not responses) and (time.time() < limit):\n                    responses = self._read(1)\n                if not responses:\n                    raise ConnectionTimeoutException(\n                        'Read identify response timed out (%ss)' % self._timeout)\n                self.identified(responses[0])\n                return True\n            except:\n                logger.exception('Failed to connect')\n                if self._socket:\n                    self._socket.close()\n                self._reconnnection_counter.failed()\n                self._reset()\n                return False", "response": "Establish a connection to the Asterisk Manager and return True if successful False otherwise."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef socket(self, blocking=True):\n        '''Blockingly yield the socket'''\n        # If the socket is available, then yield it. Otherwise, yield nothing\n        if self._socket_lock.acquire(blocking):\n            try:\n                yield self._socket\n            finally:\n                self._socket_lock.release()", "response": "Blockingly yield the socket"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef identified(self, res):\n        '''Handle a response to our 'identify' command. Returns response'''\n        # If they support it, they should give us a JSON blob which we should\n        # inspect.\n        try:\n            res.data = json.loads(res.data)\n            self._identify_response = res.data\n            logger.info('Got identify response: %s', res.data)\n        except:\n            logger.warn('Server does not support feature negotiation')\n            self._identify_response = {}\n\n        # Save our max ready count unless it's not provided\n        self.max_rdy_count = self._identify_response.get(\n            'max_rdy_count', self.max_rdy_count)\n        if self._identify_options.get('tls_v1', False):\n            if not self._identify_response.get('tls_v1', False):\n                raise UnsupportedException(\n                    'NSQd instance does not support TLS')\n            else:\n                self._socket = TLSSocket.wrap_socket(self._socket)\n\n        # Now is the appropriate time to send auth\n        if self._identify_response.get('auth_required', False):\n            if not self._auth_secret:\n                raise UnsupportedException(\n                    'Auth required but not provided')\n            else:\n                self.auth(self._auth_secret)\n                # If we're not talking over TLS, warn the user\n                if not self._identify_response.get('tls_v1', False):\n                    logger.warn('Using AUTH without TLS')\n        elif self._auth_secret:\n            logger.warn('Authentication secret provided but not required')\n        return res", "response": "Handle a response to our identify command. Returns response"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsetting whether or not this message is blocking", "response": "def setblocking(self, blocking):\n        '''Set whether or not this message is blocking'''\n        for sock in self.socket():\n            sock.setblocking(blocking)\n            self._blocking = blocking"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef flush(self):\n        '''Flush some of the waiting messages, returns count written'''\n        # When profiling, we found that while there was some efficiency to be\n        # gained elsewhere, the big performance hit is sending lots of small\n        # messages at a time. In particular, consumers send many 'FIN' messages\n        # which are very small indeed and the cost of dispatching so many system\n        # calls is very high. Instead, we prefer to glom together many messages\n        # into a single string to send at once.\n        total = 0\n        for sock in self.socket(blocking=False):\n            # If there's nothing left in the out buffer, take whatever's in the\n            # pending queue.\n            #\n            # When using SSL, if the socket throws 'SSL_WANT_WRITE', then the\n            # subsequent send requests have to send the same buffer.\n            pending = self._pending\n            data = self._out_buffer or ''.join(\n                pending.popleft() for _ in xrange(len(pending)))\n            try:\n                # Try to send as much of the first message as possible\n                total = sock.send(data)\n            except socket.error as exc:\n                # Catch (errno, message)-type socket.errors\n                if exc.args[0] not in self.WOULD_BLOCK_ERRS:\n                    raise\n                self._out_buffer = data\n            else:\n                self._out_buffer = None\n            finally:\n                if total < len(data):\n                    # Save the rest of the message that could not be sent\n                    self._pending.appendleft(data[total:])\n        return total", "response": "Flush some of the waiting messages returns count written"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef send(self, command, message=None):\n        '''Send a command over the socket with length endcoded'''\n        if message:\n            joined = command + constants.NL + util.pack(message)\n        else:\n            joined = command + constants.NL\n        if self._blocking:\n            for sock in self.socket():\n                sock.sendall(joined)\n        else:\n            self._pending.append(joined)", "response": "Send a command over the socket with length endcoded"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nsend an identification message", "response": "def identify(self, data):\n        '''Send an identification message'''\n        return self.send(constants.IDENTIFY, json.dumps(data))"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsubscribes to a topic / channel", "response": "def sub(self, topic, channel):\n        '''Subscribe to a topic/channel'''\n        return self.send(' '.join((constants.SUB, topic, channel)))"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\npublishes a message to a topic", "response": "def pub(self, topic, message):\n        '''Publish to a topic'''\n        return self.send(' '.join((constants.PUB, topic)), message)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\npublishing multiple messages to a topic", "response": "def mpub(self, topic, *messages):\n        '''Publish multiple messages to a topic'''\n        return self.send(constants.MPUB + ' ' + topic, messages)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nindicates that you re ready to receive count entries from the cache", "response": "def rdy(self, count):\n        '''Indicate that you're ready to receive'''\n        self.ready = count\n        self.last_ready_sent = count\n        return self.send(constants.RDY + ' ' + str(count))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef req(self, message_id, timeout):\n        '''Re-queue a message'''\n        return self.send(constants.REQ + ' ' + message_id + ' ' + str(timeout))", "response": "Re - queue a message"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nread from the socket and return all the responses read.", "response": "def _read(self, limit=1000):\n        '''Return all the responses read'''\n        # It's important to know that it may return no responses or multiple\n        # responses. It depends on how the buffering works out. First, read from\n        # the socket\n        for sock in self.socket():\n            if sock is None:\n                # Race condition. Connection has been closed.\n                return []\n            try:\n                packet = sock.recv(4096)\n            except socket.timeout:\n                # If the socket times out, return nothing\n                return []\n            except socket.error as exc:\n                # Catch (errno, message)-type socket.errors\n                if exc.args[0] in self.WOULD_BLOCK_ERRS:\n                    return []\n                else:\n                    raise\n\n            # Append our newly-read data to our buffer\n            self._buffer += packet\n\n        responses = []\n        total = 0\n        buf = self._buffer\n        remaining = len(buf)\n        while limit and (remaining >= 4):\n            size = struct.unpack('>l', buf[total:(total + 4)])[0]\n            # Now check to see if there's enough left in the buffer to read\n            # the message.\n            if (remaining - 4) >= size:\n                responses.append(Response.from_raw(\n                    self, buf[(total + 4):(total + size + 4)]))\n                total += (size + 4)\n                remaining -= (size + 4)\n                limit -= 1\n            else:\n                break\n        self._buffer = self._buffer[total:]\n        return responses"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef read(self):\n        '''Responses from an established socket'''\n        responses = self._read()\n        # Determine the number of messages in here and decrement our ready\n        # count appropriately\n        self.ready -= sum(\n            map(int, (r.frame_type == Message.FRAME_TYPE for r in responses)))\n        return responses", "response": "Reads a set of responses from an established socket and returns them as a list of Message objects."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef discover(self, topic):\n        '''Run the discovery mechanism'''\n        logger.info('Discovering on topic %s', topic)\n        producers = []\n        for lookupd in self._lookupd:\n            logger.info('Discovering on %s', lookupd)\n            try:\n                # Find all the current producers on this instance\n                for producer in lookupd.lookup(topic)['producers']:\n                    logger.info('Found producer %s on %s', producer, lookupd)\n                    producers.append(\n                        (producer['broadcast_address'], producer['tcp_port']))\n            except ClientException:\n                logger.exception('Failed to query %s', lookupd)\n\n        new = []\n        for host, port in producers:\n            conn = self._connections.get((host, port))\n            if not conn:\n                logger.info('Discovered %s:%s', host, port)\n                new.append(self.connect(host, port))\n            elif not conn.alive():\n                logger.info('Reconnecting to %s:%s', host, port)\n                if conn.connect():\n                    conn.setblocking(0)\n                    self.reconnected(conn)\n            else:\n                logger.debug('Connection to %s:%s still alive', host, port)\n\n        # And return all the new connections\n        return [conn for conn in new if conn]", "response": "Run the discovery mechanism on a topic and return a list of all the connections that are still alive."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef check_connections(self):\n        '''Connect to all the appropriate instances'''\n        logger.info('Checking connections')\n        if self._lookupd:\n            self.discover(self._topic)\n\n        # Make sure we're connected to all the prescribed hosts\n        for hostspec in self._nsqd_tcp_addresses:\n            logger.debug('Checking nsqd instance %s', hostspec)\n            host, port = hostspec.split(':')\n            port = int(port)\n            conn = self._connections.get((host, port), None)\n            # If there is no connection to it, we have to try to connect\n            if not conn:\n                logger.info('Connecting to %s:%s', host, port)\n                self.connect(host, port)\n            elif not conn.alive():\n                # If we've connected to it before, but it's no longer alive,\n                # we'll have to make a decision about when to try to reconnect\n                # to it, if we need to reconnect to it at all\n                if conn.ready_to_reconnect():\n                    logger.info('Reconnecting to %s:%s', host, port)\n                    if conn.connect():\n                        conn.setblocking(0)\n                        self.reconnected(conn)\n            else:\n                logger.debug('Checking freshness')\n                now = time.time()\n                time_check = math.ceil(now - self.last_recv_timestamp)\n                if time_check >= ((self.heartbeat_interval * 2) / 1000.0):\n                    if conn.ready_to_reconnect():\n                        logger.info('Reconnecting to %s:%s', host, port)\n                        if conn.connect():\n                            conn.setblocking(0)\n                            self.reconnected(conn)", "response": "Connect to all the appropriate instances."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nruns periodic reconnection checks", "response": "def connection_checker(self):\n        '''Run periodic reconnection checks'''\n        thread = ConnectionChecker(self)\n        logger.info('Starting connection-checker thread')\n        thread.start()\n        try:\n            yield thread\n        finally:\n            logger.info('Stopping connection-checker')\n            thread.stop()\n            logger.info('Joining connection-checker')\n            thread.join()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nconnecting to the provided host and port.", "response": "def connect(self, host, port):\n        '''Connect to the provided host, port'''\n        conn = connection.Connection(host, port,\n            reconnection_backoff=self._reconnection_backoff,\n            auth_secret=self._auth_secret,\n            timeout=self._connect_timeout,\n            **self._identify_options)\n        if conn.alive():\n            conn.setblocking(0)\n        self.add(conn)\n        return conn"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nadds a connection to the list of available connection objects.", "response": "def add(self, connection):\n        '''Add a connection'''\n        key = (connection.host, connection.port)\n        with self._lock:\n            if key not in self._connections:\n                self._connections[key] = connection\n                self.added(connection)\n                return connection\n            else:\n                return None"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nremoving a connection from the list of available connections.", "response": "def remove(self, connection):\n        '''Remove a connection'''\n        key = (connection.host, connection.port)\n        with self._lock:\n            found = self._connections.pop(key, None)\n        try:\n            self.close_connection(found)\n        except Exception as exc:\n            logger.warn('Failed to close %s: %s', connection, exc)\n        return found"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreading from any of the connected sockets and return a list of the unique identifiers that can be used to store the messages.", "response": "def read(self):\n        '''Read from any of the connections that need it'''\n        # We'll check all living connections\n        connections = [c for c in self.connections() if c.alive()]\n\n        if not connections:\n            # If there are no connections, obviously we return no messages, but\n            # we should wait the duration of the timeout\n            time.sleep(self._timeout)\n            return []\n\n        # Not all connections need to be written to, so we'll only concern\n        # ourselves with those that require writes\n        writes = [c for c in connections if c.pending()]\n        try:\n            readable, writable, exceptable = select.select(\n                connections, writes, connections, self._timeout)\n        except exceptions.ConnectionClosedException:\n            logger.exception('Tried selecting on closed client')\n            return []\n        except select.error:\n            logger.exception('Error running select')\n            return []\n\n        # If we returned because the timeout interval passed, log it and return\n        if not (readable or writable or exceptable):\n            logger.debug('Timed out...')\n            return []\n\n        responses = []\n        # For each readable socket, we'll try to read some responses\n        for conn in readable:\n            try:\n                for res in conn.read():\n                    # We'll capture heartbeats and respond to them automatically\n                    if (isinstance(res, Response) and res.data == HEARTBEAT):\n                        logger.info('Sending heartbeat to %s', conn)\n                        conn.nop()\n                        logger.debug('Setting last_recv_timestamp')\n                        self.last_recv_timestamp = time.time()\n                        continue\n                    elif isinstance(res, Error):\n                        nonfatal = (\n                            exceptions.FinFailedException,\n                            exceptions.ReqFailedException,\n                            exceptions.TouchFailedException\n                        )\n                        if not isinstance(res.exception(), nonfatal):\n                            # If it's not any of the non-fatal exceptions, then\n                            # we have to close this connection\n                            logger.error(\n                                'Closing %s: %s', conn, res.exception())\n                            self.close_connection(conn)\n                    responses.append(res)\n                    logger.debug('Setting last_recv_timestamp')\n                    self.last_recv_timestamp = time.time()\n            except exceptions.NSQException:\n                logger.exception('Failed to read from %s', conn)\n                self.close_connection(conn)\n            except socket.error:\n                logger.exception('Failed to read from %s', conn)\n                self.close_connection(conn)\n\n        # For each writable socket, flush some data out\n        for conn in writable:\n            try:\n                conn.flush()\n            except socket.error:\n                logger.exception('Failed to flush %s', conn)\n                self.close_connection(conn)\n\n        # For each connection with an exception, try to close it and remove it\n        # from our connections\n        for conn in exceptable:\n            self.close_connection(conn)\n\n        return responses"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\npicks a random living connection", "response": "def random_connection(self):\n        '''Pick a random living connection'''\n        # While at the moment there's no need for this to be a context manager\n        # per se, I would like to use that interface since I anticipate\n        # adding some wrapping around it at some point.\n        yield random.choice(\n            [conn for conn in self.connections() if conn.alive()])"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nwaiting for a response from the server.", "response": "def wait_response(self):\n        '''Wait for a response'''\n        responses = self.read()\n        while not responses:\n            responses = self.read()\n        return responses"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\npublishing the provided message to the provided topic", "response": "def pub(self, topic, message):\n        '''Publish the provided message to the provided topic'''\n        with self.random_connection() as client:\n            client.pub(topic, message)\n            return self.wait_response()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef mpub(self, topic, *messages):\n        '''Publish messages to a topic'''\n        with self.random_connection() as client:\n            client.mpub(topic, *messages)\n            return self.wait_response()", "response": "Publish messages to a topic"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef create_socket(self):\n        socket_path = os.path.join(self.config_dir, 'pueue.sock')\n        # Create Socket and exit with 1, if socket can't be created\n        try:\n            if os.path.exists(socket_path):\n                os.remove(socket_path)\n            self.socket = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)\n            self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n            self.socket.bind(socket_path)\n            self.socket.setblocking(0)\n            self.socket.listen(0)\n            # Set file permissions\n            os.chmod(socket_path, stat.S_IRWXU)\n        except Exception:\n            self.logger.error(\"Daemon couldn't socket. Aborting\")\n            self.logger.exception()\n            sys.exit(1)\n\n        return self.socket", "response": "Create a socket for the daemon."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates all directories needed for logs and configs.", "response": "def initialize_directories(self, root_dir):\n        \"\"\"Create all directories needed for logs and configs.\"\"\"\n        if not root_dir:\n            root_dir = os.path.expanduser('~')\n\n        # Create config directory, if it doesn't exist\n        self.config_dir = os.path.join(root_dir, '.config/pueue')\n        if not os.path.exists(self.config_dir):\n            os.makedirs(self.config_dir)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef respond_client(self, answer, socket):\n        response = pickle.dumps(answer, -1)\n        socket.sendall(response)\n        self.read_list.remove(socket)\n        socket.close()", "response": "Send an answer to the client."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nread a previous configuration file or create a new one with default values.", "response": "def read_config(self):\n        \"\"\"Read a previous configuration file or create a new with default values.\"\"\"\n        config_file = os.path.join(self.config_dir, 'pueue.ini')\n        self.config = configparser.ConfigParser()\n        # Try to get configuration file and return it\n        # If this doesn't work, a new default config file will be created\n        if os.path.exists(config_file):\n            try:\n                self.config.read(config_file)\n                return\n            except Exception:\n                self.logger.error('Error while parsing config file. Deleting old config')\n                self.logger.exception()\n\n        self.config['default'] = {\n            'resumeAfterStart': False,\n            'maxProcesses': 1,\n            'customShell': 'default',\n        }\n        self.config['log'] = {\n            'logTime': 60*60*24*14,\n        }\n        self.write_config()"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nwrites the current configuration to the config file.", "response": "def write_config(self):\n        \"\"\"Write the current configuration to the config file.\"\"\"\n        config_file = os.path.join(self.config_dir, 'pueue.ini')\n        with open(config_file, 'w') as file_descriptor:\n            self.config.write(file_descriptor)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef main(self):\n        try:\n            while self.running:\n                # Trigger the processing of finished processes by the ProcessHandler.\n                # If there are finished processes we write the log to keep it up to date.\n                if self.process_handler.check_finished():\n                    self.logger.write(self.queue)\n\n                if self.reset and self.process_handler.all_finished():\n                    # Rotate log and reset queue\n                    self.logger.rotate(self.queue)\n                    self.queue.reset()\n                    self.reset = False\n\n                # Check if the ProcessHandler has any free slots to spawn a new process\n                if not self.paused and not self.reset and self.running:\n                    self.process_handler.check_for_new()\n\n                # This is the communication section of the daemon.\n                # 1. Receive message from the client\n                # 2. Check payload and call respective function with payload as parameter.\n                # 3. Execute logic\n                # 4. Return payload with response to client\n\n                # Create list for waitable objects\n                readable, writable, failed = select.select(self.read_list, [], [], 1)\n                for waiting_socket in readable:\n                    if waiting_socket is self.socket:\n                        # Listening for clients to connect.\n                        # Client sockets are added to readlist to be processed.\n                        try:\n                            client_socket, client_address = self.socket.accept()\n                            self.read_list.append(client_socket)\n                        except Exception:\n                            self.logger.warning('Daemon rejected client')\n                    else:\n                        # Trying to receive instruction from client socket\n                        try:\n                            instruction = waiting_socket.recv(1048576)\n                        except (EOFError, OSError):\n                            self.logger.warning('Client died while sending message, dropping received data.')\n                            # Remove client socket\n                            self.read_list.remove(waiting_socket)\n                            waiting_socket.close()\n                            instruction = None\n\n                        # Check for valid instruction\n                        if instruction is not None:\n                            # Check if received data can be unpickled.\n                            try:\n                                payload = pickle.loads(instruction)\n                            except EOFError:\n                                # Instruction is ignored if it can't be unpickled\n                                self.logger.error('Received message is incomplete, dropping received data.')\n                                self.read_list.remove(waiting_socket)\n                                waiting_socket.close()\n                                # Set invalid payload\n                                payload = {'mode': ''}\n\n                            functions = {\n                                'add': self.add,\n                                'remove': self.remove,\n                                'edit': self.edit_command,\n                                'switch': self.switch,\n                                'send': self.pipe_to_process,\n                                'status': self.send_status,\n                                'start': self.start,\n                                'pause': self.pause,\n                                'stash': self.stash,\n                                'enqueue': self.enqueue,\n                                'restart': self.restart,\n                                'kill': self.kill_process,\n                                'reset': self.reset_everything,\n                                'clear': self.clear,\n                                'config': self.set_config,\n                                'STOPDAEMON': self.stop_daemon,\n                            }\n\n                            if payload['mode'] in functions.keys():\n                                self.logger.debug('Payload received:')\n                                self.logger.debug(payload)\n                                response = functions[payload['mode']](payload)\n\n                                self.logger.debug('Sending payload:')\n                                self.logger.debug(response)\n                                try:\n                                    self.respond_client(response, waiting_socket)\n                                except (BrokenPipeError):\n                                    self.logger.warning('Client disconnected during message dispatching. Function successfully executed anyway.')\n                                    # Remove client socket\n                                    self.read_list.remove(waiting_socket)\n                                    waiting_socket.close()\n                                    instruction = None\n                            else:\n                                self.respond_client({'message': 'Unknown Command',\n                                                    'status': 'error'}, waiting_socket)\n        except Exception:\n            self.logger.exception()\n\n        # Wait for killed or stopped processes to finish (cleanup)\n        self.process_handler.wait_for_finish()\n        # Close socket, clean everything up and exit\n        self.socket.close()\n        cleanup(self.config_dir)\n        sys.exit(0)", "response": "This function is the main function of the daemon. It is responsible for the main function of the daemon. It is responsible for the main function of the daemon."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nkill current processes and initiate daemon shutdown. The daemon will shut down after a last check on all killed processes.", "response": "def stop_daemon(self, payload=None):\n        \"\"\"Kill current processes and initiate daemon shutdown.\n\n        The daemon will shut down after a last check on all killed processes.\n        \"\"\"\n        kill_signal = signals['9']\n        self.process_handler.kill_all(kill_signal, True)\n        self.running = False\n\n        return {'message': 'Pueue daemon shutting down',\n                'status': 'success'}"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef set_config(self, payload):\n        self.config['default'][payload['option']] = str(payload['value'])\n\n        if payload['option'] == 'maxProcesses':\n            self.process_handler.set_max(payload['value'])\n        if payload['option'] == 'customShell':\n            path = payload['value']\n            if os.path.isfile(path) and os.access(path, os.X_OK):\n                self.process_handler.set_shell(path)\n            elif path == 'default':\n                self.process_handler.set_shell()\n            else:\n                return {'message': \"File in path doesn't exist or is not executable.\",\n                        'status': 'error'}\n\n        self.write_config()\n\n        return {'message': 'Configuration successfully updated.',\n                'status': 'success'}", "response": "Update the current config depending on the payload and save it."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef pipe_to_process(self, payload):\n        message = payload['input']\n        key = payload['key']\n        if not self.process_handler.is_running(key):\n            return {'message': 'No running process for this key',\n                    'status': 'error'}\n        self.process_handler.send_to_process(message, key)\n        return {'message': 'Message sent',\n                'status': 'success'}", "response": "Send something to stdin of a specific process."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsends the daemon status and the current queue for displaying.", "response": "def send_status(self, payload):\n        \"\"\"Send the daemon status and the current queue for displaying.\"\"\"\n        answer = {}\n        data = []\n        # Get daemon status\n        if self.paused:\n            answer['status'] = 'paused'\n        else:\n            answer['status'] = 'running'\n\n        # Add current queue or a message, that queue is empty\n        if len(self.queue) > 0:\n            data = deepcopy(self.queue.queue)\n            # Remove stderr and stdout output for transfer\n            # Some outputs are way to big for the socket buffer\n            # and this is not needed by the client\n            for key, item in data.items():\n                if 'stderr' in item:\n                    del item['stderr']\n                if 'stdout' in item:\n                    del item['stdout']\n        else:\n            data = 'Queue is empty'\n        answer['data'] = data\n\n        return answer"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef reset_everything(self, payload):\n        kill_signal = signals['9']\n        self.process_handler.kill_all(kill_signal, True)\n        self.process_handler.wait_for_finish()\n        self.reset = True\n\n        answer = {'message': 'Resetting current queue', 'status': 'success'}\n        return answer", "response": "Kill all processes delete the queue and clean everything up."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef clear(self, payload):\n        self.logger.rotate(self.queue)\n        self.queue.clear()\n        self.logger.write(self.queue)\n\n        answer = {'message': 'Finished entries have been removed.', 'status': 'success'}\n        return answer", "response": "Clear the queue from any done or failed entries."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nstarting the daemon and all processes or only specific processes.", "response": "def start(self, payload):\n        \"\"\"Start the daemon and all processes or only specific processes.\"\"\"\n        # Start specific processes, if `keys` is given in the payload\n        if payload.get('keys'):\n            succeeded = []\n            failed = []\n            for key in payload.get('keys'):\n                success = self.process_handler.start_process(key)\n                if success:\n                    succeeded.append(str(key))\n                else:\n                    failed.append(str(key))\n\n            message = ''\n            if len(succeeded) > 0:\n                message += 'Started processes: {}.'.format(', '.join(succeeded))\n                status = 'success'\n            if len(failed) > 0:\n                message += '\\nNo paused, queued or stashed process for keys: {}'.format(', '.join(failed))\n                status = 'error'\n\n            answer = {'message': message.strip(), 'status': status}\n\n        # Start a all processes and the daemon\n        else:\n            self.process_handler.start_all()\n            if self.paused:\n                self.paused = False\n                answer = {'message': 'Daemon and all processes started.',\n                          'status': 'success'}\n            else:\n                answer = {'message': 'Daemon already running, starting all processes.',\n                          'status': 'success'}\n        return answer"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef pause(self, payload):\n        # Pause specific processes, if `keys` is given in the payload\n        if payload.get('keys'):\n            succeeded = []\n            failed = []\n            for key in payload.get('keys'):\n                success = self.process_handler.pause_process(key)\n                if success:\n                    succeeded.append(str(key))\n                else:\n                    failed.append(str(key))\n\n            message = ''\n            if len(succeeded) > 0:\n                message += 'Paused processes: {}.'.format(', '.join(succeeded))\n                status = 'success'\n            if len(failed) > 0:\n                message += '\\nNo running process for keys: {}'.format(', '.join(failed))\n                status = 'error'\n\n            answer = {'message': message.strip(), 'status': status}\n\n        # Pause all processes and the daemon\n        else:\n            if payload.get('wait'):\n                self.paused = True\n                answer = {'message': 'Pausing daemon, but waiting for processes to finish.',\n                          'status': 'success'}\n            else:\n                self.process_handler.pause_all()\n                if not self.paused:\n                    self.paused = True\n                    answer = {'message': 'Daemon and all processes paused.',\n                              'status': 'success'}\n                else:\n                    answer = {'message': 'Daemon already paused, pausing all processes anyway.',\n                              'status': 'success'}\n\n        return answer", "response": "Start the daemon and all processes or only specific processes."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nedits the command of a specific entry.", "response": "def edit_command(self, payload):\n        \"\"\"Edit the command of a specific entry.\"\"\"\n        key = payload['key']\n        command = payload['command']\n        if self.queue[key]:\n            if self.queue[key]['status'] in ['queued', 'stashed']:\n                self.queue[key]['command'] = command\n                answer = {'message': 'Command updated', 'status': 'error'}\n            else:\n                answer = {'message': \"Entry is not 'queued' or 'stashed'\",\n                          'status': 'error'}\n        else:\n            answer = {'message': 'No entry with this key', 'status': 'error'}\n\n        # Pause all processes and the daemon\n        return answer"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef stash(self, payload):\n        succeeded = []\n        failed = []\n        for key in payload['keys']:\n            if self.queue.get(key) is not None:\n                if self.queue[key]['status'] == 'queued':\n                    self.queue[key]['status'] = 'stashed'\n                    succeeded.append(str(key))\n                else:\n                    failed.append(str(key))\n            else:\n                failed.append(str(key))\n\n        message = ''\n        if len(succeeded) > 0:\n            message += 'Stashed entries: {}.'.format(', '.join(succeeded))\n            status = 'success'\n        if len(failed) > 0:\n            message += '\\nNo queued entry for keys: {}'.format(', '.join(failed))\n            status = 'error'\n\n        answer = {'message': message.strip(), 'status': status}\n\n        return answer", "response": "Stash the specified processes."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\npauses the daemon and kill all processes or kill a specific process.", "response": "def kill_process(self, payload):\n        \"\"\"Pause the daemon and kill all processes or kill a specific process.\"\"\"\n        # Kill specific processes, if `keys` is given in the payload\n        kill_signal = signals[payload['signal'].lower()]\n        kill_shell = payload.get('all', False)\n        if payload.get('keys'):\n            succeeded = []\n            failed = []\n            for key in payload.get('keys'):\n                success = self.process_handler.kill_process(key, kill_signal, kill_shell)\n                if success:\n                    succeeded.append(str(key))\n                else:\n                    failed.append(str(key))\n\n            message = ''\n            if len(succeeded) > 0:\n                message += \"Signal '{}' sent to processes: {}.\".format(payload['signal'], ', '.join(succeeded))\n                status = 'success'\n            if len(failed) > 0:\n                message += '\\nNo running process for keys: {}'.format(', '.join(failed))\n                status = 'error'\n\n            answer = {'message': message.strip(), 'status': status}\n\n        # Kill all processes and the daemon\n        else:\n            self.process_handler.kill_all(kill_signal, kill_shell)\n            if kill_signal == signal.SIGINT or \\\n               kill_signal == signal.SIGTERM or \\\n               kill_signal == signal.SIGKILL:\n                self.paused = True\n            answer = {'message': 'Signal send to all processes.',\n                      'status': 'success'}\n        return answer"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nremoving specified entries from the queue.", "response": "def remove(self, payload):\n        \"\"\"Remove specified entries from the queue.\"\"\"\n        succeeded = []\n        failed = []\n        for key in payload['keys']:\n            running = self.process_handler.is_running(key)\n            if not running:\n                removed = self.queue.remove(key)\n                if removed:\n                    succeeded.append(str(key))\n                else:\n                    failed.append(str(key))\n            else:\n                failed.append(str(key))\n\n        message = ''\n        if len(succeeded) > 0:\n            message += 'Removed entries: {}.'.format(', '.join(succeeded))\n            status = 'success'\n        if len(failed) > 0:\n            message += '\\nRunning or non-existing entry for keys: {}'.format(', '.join(failed))\n            status = 'error'\n\n        answer = {'message': message.strip(), 'status': status}\n\n        return answer"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nswitch the two specified entry positions in the queue.", "response": "def switch(self, payload):\n        \"\"\"Switch the two specified entry positions in the queue.\"\"\"\n        first = payload['first']\n        second = payload['second']\n        running = self.process_handler.is_running(first) or self.process_handler.is_running(second)\n        if running:\n            answer = {\n                'message': \"Can't switch running processes, \"\n                \"please stop the processes before switching them.\",\n                'status': 'error'\n            }\n\n        else:\n            switched = self.queue.switch(first, second)\n            if switched:\n                answer = {\n                    'message': 'Entries #{} and #{} switched'.format(first, second),\n                    'status': 'success'\n                }\n            else:\n                answer = {'message': \"One or both entries do not exist or are not queued/stashed.\",\n                          'status': 'error'}\n        return answer"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nrestart the specified entries.", "response": "def restart(self, payload):\n        \"\"\"Restart the specified entries.\"\"\"\n        succeeded = []\n        failed = []\n        for key in payload['keys']:\n            restarted = self.queue.restart(key)\n            if restarted:\n                succeeded.append(str(key))\n            else:\n                failed.append(str(key))\n\n        message = ''\n        if len(succeeded) > 0:\n            message += 'Restarted entries: {}.'.format(', '.join(succeeded))\n            status = 'success'\n        if len(failed) > 0:\n            message += '\\nNo finished entry for keys: {}'.format(', '.join(failed))\n            status = 'error'\n\n        answer = {'message': message.strip(), 'status': status}\n        return answer"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef sendall(self, data, flags=0):\n        '''Same as socket.sendall'''\n        count = len(data)\n        while count:\n            sent = self.send(data, flags)\n            # This could probably be a buffer object\n            data = data[sent:]\n            count -= sent", "response": "Same as socket. sendall"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef do_file_upload(client, args):\n\n    # Sanity check\n    if len(args.paths) > 1:\n        # destination must be a directory\n        try:\n            resource = client.get_resource_by_uri(args.dest_uri)\n        except ResourceNotFoundError:\n            resource = None\n\n        if resource and not isinstance(resource, Folder):\n            print(\"file-upload: \"\n                  \"target '{}' is not a directory\".format(args.dest_uri))\n            return None\n\n    with client.upload_session():\n        for src_path in args.paths:\n            print(\"Uploading {} to {}\".format(src_path, args.dest_uri))\n            result = client.upload_file(src_path, args.dest_uri)\n\n            print(\"Uploaded {}, result={}\".format(src_path, result))\n\n    return True", "response": "Upload files to the specified target."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ndownloading file from the server", "response": "def do_file_download(client, args):\n    \"\"\"Download file\"\"\"\n\n    # Sanity check\n    if not os.path.isdir(args.dest_path) and not args.dest_path.endswith('/'):\n        print(\"file-download: \"\n              \"target '{}' is not a directory\".format(args.dest_path))\n        if not os.path.exists(args.dest_path):\n            print(\"\\tHint: add trailing / to create one\")\n        return None\n\n    for src_uri in args.uris:\n        print(\"Downloading {} to {}\".format(src_uri, args.dest_path))\n        client.download_file(src_uri, args.dest_path)\n        print(\"Downloaded {}\".format(src_uri))\n\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef do_file_show(client, args):\n    for src_uri in args.uris:\n        client.download_file(src_uri, sys.stdout.buffer)\n\n    return True", "response": "Output file contents to stdout"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef do_resource_delete(client, args):\n    for resource_uri in args.uris:\n        client.delete_resource(resource_uri, purge=args.purge)\n        print(\"Deleted {}\".format(resource_uri))\n    return True", "response": "Remove resource from the cluster"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\npublishing a message to a topic", "response": "def pub(self, topic, message):\n        '''Publish a message to a topic'''\n        return self.post('pub', params={'topic': topic}, data=message)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsending multiple messages to a topic. Optionally pack the messages.", "response": "def mpub(self, topic, messages, binary=True):\n        '''Send multiple messages to a topic. Optionally pack the messages'''\n        if binary:\n            # Pack and ship the data\n            return self.post('mpub', data=pack(messages)[4:],\n                params={'topic': topic, 'binary': True})\n        elif any('\\n' in m for m in messages):\n            # If any of the messages has a newline, then you must use the binary\n            # calling format\n            raise ClientException(\n                'Use `binary` flag in mpub for messages with newlines')\n        else:\n            return self.post(\n                '/mpub', params={'topic': topic}, data='\\n'.join(messages))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nadding a new command to the daemon queue.", "response": "def execute_add(args, root_dir=None):\n    \"\"\"Add a new command to the daemon queue.\n\n    Args:\n        args['command'] (list(str)): The actual programm call. Something like ['ls', '-a'] or ['ls -al']\n        root_dir (string): The path to the root directory the daemon is running in.\n    \"\"\"\n\n    # We accept a list of strings.\n    # This is done to create a better commandline experience with argparse.\n    command = ' '.join(args['command'])\n\n    # Send new instruction to daemon\n    instruction = {\n        'command': command,\n        'path': os.getcwd()\n    }\n    print_command_factory('add')(instruction, root_dir)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nedits a existing queue entry in the daemon.", "response": "def execute_edit(args, root_dir=None):\n    \"\"\"Edit a existing queue command in the daemon.\n\n    Args:\n        args['key'] int: The key of the queue entry to be edited\n        root_dir (string): The path to the root directory the daemon is running in.\n    \"\"\"\n    # Get editor\n    EDITOR = os.environ.get('EDITOR', 'vim')\n    # Get command from server\n    key = args['key']\n    status = command_factory('status')({}, root_dir=root_dir)\n\n    # Check if queue is not empty, the entry exists and is queued or stashed\n    if not isinstance(status['data'], str) and key in status['data']:\n        if status['data'][key]['status'] in ['queued', 'stashed']:\n            command = status['data'][key]['command']\n        else:\n            print(\"Entry is not 'queued' or 'stashed'\")\n            sys.exit(1)\n    else:\n        print('No entry with this key')\n        sys.exit(1)\n\n    with tempfile.NamedTemporaryFile(suffix=\".tmp\") as tf:\n        tf.write(command.encode('utf-8'))\n        tf.flush()\n        call([EDITOR, tf.name])\n\n        # do the parsing with `tf` using regular File operations.\n        # for instance:\n        tf.seek(0)\n        edited_command = tf.read().decode('utf-8')\n\n    print_command_factory('edit')({\n        'key': key,\n        'command': edited_command,\n    }, root_dir=root_dir)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef command_factory(command):\n    def communicate(body={}, root_dir=None):\n        \"\"\"Communicate with the daemon.\n\n        This function sends a payload to the daemon and returns the unpickled\n        object sent by the daemon.\n\n        Args:\n            body (dir): Any other arguments that should be put into the payload.\n            root_dir (str): The root directory in which we expect the daemon.\n                            We need this to connect to the daemons socket.\n        Returns:\n            function: The returned payload.\n        \"\"\"\n\n        client = connect_socket(root_dir)\n        body['mode'] = command\n        # Delete the func entry we use to call the correct function with argparse\n        # as functions can't be pickled and this shouldn't be send to the daemon.\n        if 'func' in body:\n            del body['func']\n        data_string = pickle.dumps(body, -1)\n        client.send(data_string)\n\n        # Receive message, unpickle and return it\n        response = receive_data(client)\n        return response\n    return communicate", "response": "A factory for direct daemon communication."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate file descriptors for process output.", "response": "def get_descriptor(self, number):\n        \"\"\"Create file descriptors for process output.\"\"\"\n        # Create stdout file and get file descriptor\n        stdout_path = os.path.join(self.config_dir,\n                                   'pueue_process_{}.stdout'.format(number))\n        if os.path.exists(stdout_path):\n            os.remove(stdout_path)\n        out_descriptor = open(stdout_path, 'w+')\n\n        # Create stderr file and get file descriptor\n        stderr_path = os.path.join(self.config_dir,\n                                   'pueue_process_{}.stderr'.format(number))\n        if os.path.exists(stderr_path):\n            os.remove(stderr_path)\n        err_descriptor = open(stderr_path, 'w+')\n\n        self.descriptors[number] = {}\n        self.descriptors[number]['stdout'] = out_descriptor\n        self.descriptors[number]['stdout_path'] = stdout_path\n        self.descriptors[number]['stderr'] = err_descriptor\n        self.descriptors[number]['stderr_path'] = stderr_path\n        return out_descriptor, err_descriptor"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef clean_descriptor(self, number):\n        self.descriptors[number]['stdout'].close()\n        self.descriptors[number]['stderr'].close()\n\n        if os.path.exists(self.descriptors[number]['stdout_path']):\n            os.remove(self.descriptors[number]['stdout_path'])\n\n        if os.path.exists(self.descriptors[number]['stderr_path']):\n            os.remove(self.descriptors[number]['stderr_path'])", "response": "Close file descriptor and remove underlying files."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef check_finished(self):\n        changed = False\n        for key in list(self.processes.keys()):\n            # Poll process and check if it finshed\n            process = self.processes[key]\n            process.poll()\n            if process.returncode is not None:\n                # If a process is terminated by `stop` or `kill`\n                # we want to queue it again instead closing it as failed.\n                if key not in self.stopping:\n                    # Get std_out and err_out\n                    output, error_output = process.communicate()\n\n                    descriptor = self.descriptors[key]\n                    descriptor['stdout'].seek(0)\n                    descriptor['stderr'].seek(0)\n                    output = get_descriptor_output(descriptor['stdout'], key, handler=self)\n                    error_output = get_descriptor_output(descriptor['stderr'], key, handler=self)\n\n                    # Mark queue entry as finished and save returncode\n                    self.queue[key]['returncode'] = process.returncode\n                    if process.returncode != 0:\n                        self.queue[key]['status'] = 'failed'\n                    else:\n                        self.queue[key]['status'] = 'done'\n\n                    # Add outputs to queue\n                    self.queue[key]['stdout'] = output\n                    self.queue[key]['stderr'] = error_output\n                    self.queue[key]['end'] = str(datetime.now().strftime(\"%H:%M\"))\n\n                    self.queue.write()\n                    changed = True\n                else:\n                    self.stopping.remove(key)\n                    if key in self.to_remove:\n                        self.to_remove.remove(key)\n                        del self.queue[key]\n                    else:\n                        if key in self.to_stash:\n                            self.to_stash.remove(key)\n                            self.queue[key]['status'] = 'stashed'\n                        else:\n                            self.queue[key]['status'] = 'queued'\n                        self.queue[key]['start'] = ''\n                        self.queue[key]['end'] = ''\n\n                    self.queue.write()\n\n                self.clean_descriptor(key)\n                del self.processes[key]\n\n        # If anything should be logged we return True\n        return changed", "response": "Poll all processes and handle any finished processes."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nchecking if we can start a new process.", "response": "def check_for_new(self):\n        \"\"\"Check if we can start a new process.\"\"\"\n        free_slots = self.max_processes - len(self.processes)\n        for item in range(free_slots):\n            key = self.queue.next()\n            if key is not None:\n                self.spawn_new(key)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nspawning a new task and save it to the queue.", "response": "def spawn_new(self, key):\n        \"\"\"Spawn a new task and save it to the queue.\"\"\"\n        # Check if path exists\n        if not os.path.exists(self.queue[key]['path']):\n            self.queue[key]['status'] = 'failed'\n            error_msg = \"The directory for this command doesn't exist anymore: {}\".format(self.queue[key]['path'])\n            self.logger.error(error_msg)\n            self.queue[key]['stdout'] = ''\n            self.queue[key]['stderr'] = error_msg\n\n        else:\n            # Get file descriptors\n            stdout, stderr = self.get_descriptor(key)\n\n            if self.custom_shell != 'default':\n                # Create subprocess\n                self.processes[key] = subprocess.Popen(\n                    [\n                        self.custom_shell,\n                        '-i',\n                        '-c',\n                        self.queue[key]['command'],\n                    ],\n                    stdout=stdout,\n                    stderr=stderr,\n                    stdin=subprocess.PIPE,\n                    universal_newlines=True,\n                    preexec_fn=os.setsid,\n                    cwd=self.queue[key]['path']\n                )\n            else:\n                # Create subprocess\n                self.processes[key] = subprocess.Popen(\n                    self.queue[key]['command'],\n                    shell=True,\n                    stdout=stdout,\n                    stderr=stderr,\n                    stdin=subprocess.PIPE,\n                    universal_newlines=True,\n                    preexec_fn=os.setsid,\n                    cwd=self.queue[key]['path']\n                )\n            self.queue[key]['status'] = 'running'\n            self.queue[key]['start'] = str(datetime.now().strftime(\"%H:%M\"))\n\n        self.queue.write()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef kill_all(self, kill_signal, kill_shell=False):\n        for key in self.processes.keys():\n            self.kill_process(key, kill_signal, kill_shell)", "response": "Kill all running processes."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nstart a specific process.", "response": "def start_process(self, key):\n        \"\"\"Start a specific processes.\"\"\"\n        if key in self.processes and key in self.paused:\n            os.killpg(os.getpgid(self.processes[key].pid), signal.SIGCONT)\n            self.queue[key]['status'] = 'running'\n            self.paused.remove(key)\n            return True\n        elif key not in self.processes:\n            if self.queue[key]['status'] in ['queued', 'stashed']:\n                self.spawn_new(key)\n                return True\n\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef pause_process(self, key):\n        if key in self.processes and key not in self.paused:\n            os.killpg(os.getpgid(self.processes[key].pid), signal.SIGSTOP)\n            self.queue[key]['status'] = 'paused'\n            self.paused.append(key)\n            return True\n        return False", "response": "Pause a specific process."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncreates a closure which creates a running daemon.", "response": "def daemon_factory(path):\n    \"\"\"Create a closure which creates a running daemon.\n\n    We need to create a closure that contains the correct path the daemon should\n    be started with. This is needed as the `Daemonize` library\n    requires a callable function for daemonization and doesn't accept any arguments.\n    This function cleans up sockets and output files in case we encounter any exceptions.\n    \"\"\"\n    def start_daemon():\n        root_dir = path\n        config_dir = os.path.join(root_dir, '.config/pueue')\n        try:\n            daemon = Daemon(root_dir=root_dir)\n            daemon.main()\n        except KeyboardInterrupt:\n            print('Keyboard interrupt. Shutting down')\n            daemon.stop_daemon()\n        except Exception:\n            try:\n                daemon.stop_daemon()\n            except Exception:\n                pass\n            cleanup(config_dir)\n            raise\n    return start_daemon"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nregistering a new handler for signal signum.", "response": "def register(host=DFLT_ADDRESS[0], port=DFLT_ADDRESS[1],\n             signum=signal.SIGUSR1):\n    \"\"\"Register a pdb handler for signal 'signum'.\n\n    The handler sets pdb to listen on the ('host', 'port') internet address\n    and to start a remote debugging session on accepting a socket connection.\n    \"\"\"\n    _pdbhandler._register(host, port, signum)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_handler():\n    host, port, signum = _pdbhandler._registered()\n    if signum:\n        return Handler(host if host else DFLT_ADDRESS[0].encode(),\n                       port if port else DFLT_ADDRESS[1], signum)", "response": "Return the handler as a named tuple."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef wait(self, timeout):\n        '''Wait for the provided time to elapse'''\n        logger.debug('Waiting for %fs', timeout)\n        return self._event.wait(timeout)", "response": "Wait for the provided time to elapse"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nrunning the callback periodically", "response": "def run(self):\n        '''Run the callback periodically'''\n        while not self.wait(self.delay()):\n            try:\n                logger.info('Invoking callback %s', self.callback)\n                self.callback()\n            except StandardError:\n                logger.exception('Callback failed')"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nlogs-in to MediaFire account.", "response": "def login(self, email=None, password=None, app_id=None, api_key=None):\n        \"\"\"Login to MediaFire account.\n\n        Keyword arguments:\n        email -- account email\n        password -- account password\n        app_id -- application ID\n        api_key -- API Key (optional)\n        \"\"\"\n        session_token = self.api.user_get_session_token(\n            app_id=app_id, email=email, password=password, api_key=api_key)\n\n        # install session token back into api client\n        self.api.session = session_token"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_resource_by_uri(self, uri):\n\n        location = self._parse_uri(uri)\n\n        if location.startswith(\"/\"):\n            # Use path lookup only, root=myfiles\n            result = self.get_resource_by_path(location)\n        elif \"/\" in location:\n            # mf:abcdefjhijklm/name\n            resource_key, path = location.split('/', 2)\n            parent_folder = self.get_resource_by_key(resource_key)\n            if not isinstance(parent_folder, Folder):\n                raise NotAFolderError(resource_key)\n            # perform additional lookup by path\n            result = self.get_resource_by_path(\n                path, folder_key=parent_folder['folderkey'])\n        else:\n            # mf:abcdefjhijklm\n            result = self.get_resource_by_key(location)\n\n        return result", "response": "Return resource described by MediaFire URI."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_resource_by_key(self, resource_key):\n\n        # search for quick_key by default\n        lookup_order = [\"quick_key\", \"folder_key\"]\n\n        if len(resource_key) == FOLDER_KEY_LENGTH:\n            lookup_order = [\"folder_key\", \"quick_key\"]\n\n        resource = None\n\n        for lookup_key in lookup_order:\n            try:\n                if lookup_key == \"folder_key\":\n                    info = self.api.folder_get_info(folder_key=resource_key)\n                    resource = Folder(info['folder_info'])\n                elif lookup_key == \"quick_key\":\n                    info = self.api.file_get_info(quick_key=resource_key)\n                    resource = File(info['file_info'])\n            except MediaFireApiError:\n                # TODO: Check response code\n                pass\n\n            if resource:\n                break\n\n        if not resource:\n            raise ResourceNotFoundError(resource_key)\n\n        return resource", "response": "Return resource by quick_key or folder_key."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a resource by remote path.", "response": "def get_resource_by_path(self, path, folder_key=None):\n        \"\"\"Return resource by remote path.\n\n        path -- remote path\n\n        Keyword arguments:\n        folder_key -- what to use as the root folder (None for root)\n        \"\"\"\n        logger.debug(\"resolving %s\", path)\n\n        # remove empty path components\n        path = posixpath.normpath(path)\n        components = [t for t in path.split(posixpath.sep) if t != '']\n\n        if not components:\n            # request for root\n            return Folder(\n                self.api.folder_get_info(folder_key)['folder_info']\n            )\n\n        resource = None\n\n        for component in components:\n            exists = False\n            for item in self._folder_get_content_iter(folder_key):\n                name = item['name'] if 'name' in item else item['filename']\n\n                if name == component:\n                    exists = True\n                    if components[-1] != component:\n                        # still have components to go through\n                        if 'filename' in item:\n                            # found a file, expected a directory\n                            raise NotAFolderError(item['filename'])\n                        folder_key = item['folderkey']\n                    else:\n                        # found the leaf\n                        resource = item\n                    break\n\n                if resource is not None:\n                    break\n\n            if not exists:\n                # intermediate component does not exist - bailing out\n                break\n\n        if resource is None:\n            raise ResourceNotFoundError(path)\n\n        if \"quickkey\" in resource:\n            file_info = self.api.file_get_info(\n                resource['quickkey'])['file_info']\n            result = File(file_info)\n        elif \"folderkey\" in resource:\n            folder_info = self.api.folder_get_info(\n                resource['folderkey'])['folder_info']\n            result = Folder(folder_info)\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns iterator for directory contents.", "response": "def get_folder_contents_iter(self, uri):\n        \"\"\"Return iterator for directory contents.\n\n        uri -- mediafire URI\n\n        Example:\n\n            for item in get_folder_contents_iter('mf:///Documents'):\n                print(item)\n        \"\"\"\n        resource = self.get_resource_by_uri(uri)\n\n        if not isinstance(resource, Folder):\n            raise NotAFolderError(uri)\n\n        folder_key = resource['folderkey']\n\n        for item in self._folder_get_content_iter(folder_key):\n            if 'filename' in item:\n                # Work around https://mediafire.mantishub.com/view.php?id=5\n                # TODO: remove in 1.0\n                if \".patch.\" in item['filename']:\n                    continue\n                yield File(item)\n            elif 'name' in item:\n                yield Folder(item)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef create_folder(self, uri, recursive=False):\n        logger.info(\"Creating %s\", uri)\n\n        # check that folder exists already\n        try:\n            resource = self.get_resource_by_uri(uri)\n\n            if isinstance(resource, Folder):\n                return resource\n            else:\n                raise NotAFolderError(uri)\n        except ResourceNotFoundError:\n            pass\n\n        location = self._parse_uri(uri)\n\n        folder_name = posixpath.basename(location)\n        parent_uri = 'mf://' + posixpath.dirname(location)\n\n        try:\n            parent_node = self.get_resource_by_uri(parent_uri)\n            if not isinstance(parent_node, Folder):\n                raise NotAFolderError(parent_uri)\n            parent_key = parent_node['folderkey']\n        except ResourceNotFoundError:\n            if recursive:\n                result = self.create_folder(parent_uri, recursive=True)\n                parent_key = result['folderkey']\n            else:\n                raise\n\n        # We specify exact location, so don't allow duplicates\n        result = self.api.folder_create(\n            folder_name, parent_key=parent_key, action_on_duplicate='skip')\n\n        logger.info(\"Created folder '%s' [mf:%s]\",\n                    result['name'], result['folder_key'])\n\n        return self.get_resource_by_key(result['folder_key'])", "response": "Create folder.\n\n        uri -- MediaFire URI\n\n        Keyword arguments:\n        recursive -- set to True to create intermediate folders."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ndelete folder. uri -- MediaFire folder URI Keyword arguments: purge -- delete the folder without sending it to Trash", "response": "def delete_folder(self, uri, purge=False):\n        \"\"\"Delete folder.\n\n        uri -- MediaFire folder URI\n\n        Keyword arguments:\n        purge -- delete the folder without sending it to Trash\n        \"\"\"\n\n        try:\n            resource = self.get_resource_by_uri(uri)\n        except ResourceNotFoundError:\n            # Nothing to remove\n            return None\n\n        if not isinstance(resource, Folder):\n            raise ValueError(\"Folder expected, got {}\".format(type(resource)))\n\n        if purge:\n            func = self.api.folder_purge\n        else:\n            func = self.api.folder_delete\n\n        try:\n            result = func(resource['folderkey'])\n        except MediaFireApiError as err:\n            if err.code == 100:\n                logger.debug(\n                    \"Delete folder returns error 900 but folder is deleted: \"\n                    \"http://forum.mediafiredev.com/showthread.php?129\")\n\n                result = {}\n            else:\n                raise\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ndeletes a file from the MediaFire.", "response": "def delete_file(self, uri, purge=False):\n        \"\"\"Delete file.\n\n        uri -- MediaFire file URI\n\n        Keyword arguments:\n        purge -- delete the file without sending it to Trash.\n        \"\"\"\n        try:\n            resource = self.get_resource_by_uri(uri)\n        except ResourceNotFoundError:\n            # Nothing to remove\n            return None\n\n        if not isinstance(resource, File):\n            raise ValueError(\"File expected, got {}\".format(type(resource)))\n\n        if purge:\n            func = self.api.file_purge\n        else:\n            func = self.api.file_delete\n\n        return func(resource['quickkey'])"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ndeleting a resource from the mediafire store.", "response": "def delete_resource(self, uri, purge=False):\n        \"\"\"Delete file or folder\n\n        uri -- mediafire URI\n\n        Keyword arguments:\n        purge -- delete the resource without sending it to Trash.\n        \"\"\"\n        try:\n            resource = self.get_resource_by_uri(uri)\n        except ResourceNotFoundError:\n            # Nothing to remove\n            return None\n\n        if isinstance(resource, File):\n            result = self.delete_file(uri, purge)\n        elif isinstance(resource, Folder):\n            result = self.delete_folder(uri, purge)\n        else:\n            raise ValueError('Unsupported resource: {}'.format(type(resource)))\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _prepare_upload_info(self, source, dest_uri):\n\n        try:\n            dest_resource = self.get_resource_by_uri(dest_uri)\n        except ResourceNotFoundError:\n            dest_resource = None\n\n        is_fh = hasattr(source, 'read')\n\n        folder_key = None\n        name = None\n\n        if dest_resource:\n            if isinstance(dest_resource, File):\n                folder_key = dest_resource['parent_folderkey']\n                name = dest_resource['filename']\n            elif isinstance(dest_resource, Folder):\n                if is_fh:\n                    raise ValueError(\"Cannot determine target file name\")\n                basename = posixpath.basename(source)\n                dest_uri = posixpath.join(dest_uri, basename)\n                try:\n                    result = self.get_resource_by_uri(dest_uri)\n                    if isinstance(result, Folder):\n                        raise ValueError(\"Target is a folder (file expected)\")\n                    folder_key = result.get('parent_folderkey', None)\n                    name = result['filename']\n                except ResourceNotFoundError:\n                    # ok, neither a file nor folder, proceed\n                    folder_key = dest_resource['folderkey']\n                    name = basename\n            else:\n                raise Exception(\"Unknown resource type\")\n        else:\n            # get parent resource\n            parent_uri = '/'.join(dest_uri.split('/')[0:-1])\n            result = self.get_resource_by_uri(parent_uri)\n            if not isinstance(result, Folder):\n                raise NotAFolderError(\"Parent component is not a folder\")\n\n            folder_key = result['folderkey']\n            name = posixpath.basename(dest_uri)\n\n        return folder_key, name", "response": "Prepare Upload object resolve paths"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef upload_file(self, source, dest_uri):\n\n        folder_key, name = self._prepare_upload_info(source, dest_uri)\n\n        is_fh = hasattr(source, 'read')\n        fd = None\n\n        try:\n            if is_fh:\n                # Re-using filehandle\n                fd = source\n            else:\n                # Handling fs open/close\n                fd = open(source, 'rb')\n\n            return MediaFireUploader(self.api).upload(\n                fd, name, folder_key=folder_key,\n                action_on_duplicate='replace')\n        finally:\n            # Close filehandle if we opened it\n            if fd and not is_fh:\n                fd.close()", "response": "Upload a file to MediaFire."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef download_file(self, src_uri, target):\n        resource = self.get_resource_by_uri(src_uri)\n        if not isinstance(resource, File):\n            raise MediaFireError(\"Only files can be downloaded\")\n\n        quick_key = resource['quickkey']\n        result = self.api.file_get_links(quick_key=quick_key,\n                                         link_type='direct_download')\n        direct_download = result['links'][0]['direct_download']\n\n        # Force download over HTTPS\n        direct_download = direct_download.replace('http:', 'https:')\n\n        name = resource['filename']\n\n        target_is_filehandle = True if hasattr(target, 'write') else False\n\n        if not target_is_filehandle:\n            if (os.path.exists(target) and os.path.isdir(target)) or \\\n                    target.endswith(\"/\"):\n                target = os.path.join(target, name)\n\n            if not os.path.isdir(os.path.dirname(target)):\n                os.makedirs(os.path.dirname(target))\n\n            logger.info(\"Downloading %s to %s\", src_uri, target)\n\n        response = requests.get(direct_download, stream=True)\n        try:\n            if target_is_filehandle:\n                out_fd = target\n            else:\n                out_fd = open(target, 'wb')\n\n            checksum = hashlib.sha256()\n            for chunk in response.iter_content(chunk_size=4096):\n                if chunk:\n                    out_fd.write(chunk)\n                    checksum.update(chunk)\n\n            checksum_hex = checksum.hexdigest().lower()\n            if checksum_hex != resource['hash']:\n                raise DownloadError(\"Hash mismatch ({} != {})\".format(\n                    resource['hash'], checksum_hex))\n\n            logger.info(\"Download completed successfully\")\n        finally:\n            if not target_is_filehandle:\n                out_fd.close()", "response": "Download file from MediaFire."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nupdate the file metadata for a MediaFire file.", "response": "def update_file_metadata(self, uri, filename=None, description=None,\n                             mtime=None, privacy=None):\n        \"\"\"Update file metadata.\n\n        uri -- MediaFire file URI\n\n        Supplying the following keyword arguments would change the\n        metadata on the server side:\n\n        filename -- rename file\n        description -- set file description string\n        mtime -- set file modification time\n        privacy -- set file privacy - 'private' or 'public'\n        \"\"\"\n\n        resource = self.get_resource_by_uri(uri)\n\n        if not isinstance(resource, File):\n            raise ValueError('Expected File, got {}'.format(type(resource)))\n\n        result = self.api.file_update(resource['quickkey'], filename=filename,\n                                      description=description,\n                                      mtime=mtime, privacy=privacy)\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nupdating the folder metadata.", "response": "def update_folder_metadata(self, uri, foldername=None, description=None,\n                               mtime=None, privacy=None,\n                               privacy_recursive=None):\n        \"\"\"Update folder metadata.\n\n        uri -- MediaFire file URI\n\n        Supplying the following keyword arguments would change the\n        metadata on the server side:\n\n        filename -- rename file\n        description -- set file description string\n        mtime -- set file modification time\n        privacy -- set file privacy - 'private' or 'public'\n        recursive -- update folder privacy recursively\n        \"\"\"\n\n        resource = self.get_resource_by_uri(uri)\n\n        if not isinstance(resource, Folder):\n            raise ValueError('Expected Folder, got {}'.format(type(resource)))\n\n        result = self.api.folder_update(resource['folderkey'],\n                                        foldername=foldername,\n                                        description=description,\n                                        mtime=mtime,\n                                        privacy=privacy,\n                                        privacy_recursive=privacy_recursive)\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _parse_uri(uri):\n\n        tokens = urlparse(uri)\n\n        if tokens.netloc != '':\n            logger.error(\"Invalid URI: %s\", uri)\n            raise ValueError(\"MediaFire URI format error: \"\n                             \"host should be empty - mf:///path\")\n\n        if tokens.scheme != '' and tokens.scheme != URI_SCHEME:\n            raise ValueError(\"MediaFire URI format error: \"\n                             \"must start with 'mf:' or '/'\")\n\n        return posixpath.normpath(tokens.path)", "response": "Parse and validate MediaFire URI."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef raw(self):\n        '''All the raw, unaggregated stats (with duplicates).'''\n        topic_keys = (\n            'message_count',\n            'depth',\n            'backend_depth',\n            'paused'\n        )\n\n        channel_keys = (\n            'in_flight_count',\n            'timeout_count',\n            'paused',\n            'deferred_count',\n            'message_count',\n            'depth',\n            'backend_depth',\n            'requeue_count'\n        )\n        \n        for host, stats in self.merged.items():\n            for topic, stats in stats.get('topics', {}).items():\n                prefix = 'host.%s.topic.%s' % (host, topic)\n                for key in topic_keys:\n                    value = int(stats.get(key, -1))\n                    yield (\n                        'host.%s.topic.%s.%s' % (host, topic, key),\n                        value,\n                        False\n                    )\n                    yield (\n                        'topic.%s.%s' % (topic, key),\n                        value,\n                        True\n                    )\n                    yield (\n                        'topics.%s' % key,\n                        value,\n                        True\n                    )\n                \n                for chan, stats in stats.get('channels', {}).items():\n                    data = {\n                        key: int(stats.get(key, -1)) for key in channel_keys\n                    }\n                    data['clients'] = len(stats.get('clients', []))\n\n                    for key, value in data.items():\n                        yield (\n                            'host.%s.topic.%s.channel.%s.%s' % (host, topic, chan, key),\n                            value,\n                            False\n                        )\n                        yield (\n                            'host.%s.topic.%s.channels.%s' % (host, topic, key),\n                            value,\n                            True\n                        )\n                        yield (\n                            'topic.%s.channels.%s' % (topic, key),\n                            value,\n                            True\n                        )\n                        yield (\n                            'channels.%s' % key,\n                            value,\n                            True\n                        )", "response": "All the raw unaggregated stats."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef stats(self):\n        '''Stats that have been aggregated appropriately.'''\n        data = Counter()\n        for name, value, aggregated in self.raw:\n            if aggregated:\n                data['%s.max' % name] = max(data['%s.max' % name], value)\n                data['%s.total' % name] += value\n            else:\n                data[name] = value\n\n        return sorted(data.items())", "response": "Stats that have been aggregated appropriately."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_curline():\n    if Frame:\n        frame = Frame.get_selected_python_frame()\n        if frame:\n            line = ''\n            f = frame.get_pyop()\n            if f and not f.is_optimized_out():\n                cwd = os.path.join(os.getcwd(), '')\n                fname = f.filename()\n                if cwd in fname:\n                    fname = fname[len(cwd):]\n                try:\n                    line = f.current_line()\n                except IOError:\n                    pass\n                if line:\n                    # Use repr(line) to avoid UnicodeDecodeError on the\n                    # following print invocation.\n                    line = repr(line).strip(\"'\")\n                    line = line[:-2] if line.endswith(r'\\n') else line\n                    return ('-> %s(%s): %s' % (fname,\n                                        f.current_line_num(), line))\n    return ''", "response": "Return the current python source line."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef reconnected(self, conn):\n        '''Subscribe connection and manipulate its RDY state'''\n        conn.sub(self._topic, self._channel)\n        conn.rdy(1)", "response": "Subscribe and manipulate its RDY state"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef distribute_ready(self):\n        '''Distribute the ready state across all of the connections'''\n        connections = [c for c in self.connections() if c.alive()]\n        if len(connections) > self._max_in_flight:\n            raise NotImplementedError(\n                'Max in flight must be greater than number of connections')\n        else:\n            # Distribute the ready count evenly among the connections\n            for count, conn in distribute(self._max_in_flight, connections):\n                # We cannot exceed the maximum RDY count for a connection\n                if count > conn.max_rdy_count:\n                    logger.info(\n                        'Using max_rdy_count (%i) instead of %i for %s RDY',\n                        conn.max_rdy_count, count, conn)\n                    count = conn.max_rdy_count\n                logger.info('Sending RDY %i to %s', count, conn)\n                conn.rdy(count)", "response": "Distribute the ready state across all of the connections"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ndetermining whether or not we need to redistribute the ready state.", "response": "def needs_distribute_ready(self):\n        '''Determine whether or not we need to redistribute the ready state'''\n        # Try to pre-empty starvation by comparing current RDY against\n        # the last value sent.\n        alive = [c for c in self.connections() if c.alive()]\n        if any(c.ready <= (c.last_ready_sent * 0.25) for c in alive):\n            return True"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nread some number of messages from the server.", "response": "def read(self):\n        '''Read some number of messages'''\n        found = Client.read(self)\n\n        # Redistribute our ready state if necessary\n        if self.needs_distribute_ready():\n            self.distribute_ready()\n\n        # Finally, return all the results we've read\n        return found"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nyielding n - length chunks or blocks from iterable.", "response": "def grouper(iterable, n):\n    '''Collect data into fixed-length chunks or blocks'''\n    args = [iter(iterable)] * n\n    for group in izip_longest(fillvalue=None, *args):\n        group = [g for g in group if g != None]\n        yield group"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef basic(topic='topic', channel='channel', count=1e6, size=10, gevent=False,\n    max_in_flight=2500, profile=False):\n    '''Basic benchmark'''\n    if gevent:\n        from gevent import monkey\n        monkey.patch_all()\n\n    # Check the types of the arguments\n    count = int(count)\n    size = int(size)\n    max_in_flight = int(max_in_flight)\n\n    from nsq.http import nsqd\n    from nsq.reader import Reader\n\n    print 'Publishing messages...'\n    for batch in grouper(messages(count, size), 1000):\n        nsqd.Client('http://localhost:4151').mpub(topic, batch)\n\n    print 'Consuming messages'\n    client = Reader(topic, channel, nsqd_tcp_addresses=['localhost:4150'],\n        max_in_flight=max_in_flight)\n    with closing(client):\n        start = -time.time()\n        if profile:\n            with profiler():\n                for message in islice(client, count):\n                    message.fin()\n        else:\n            for message in islice(client, count):\n                message.fin()\n        start += time.time()\n    print 'Finished %i messages in %fs (%5.2f messages / second)' % (\n        count, start, count / start)", "response": "Basic benchmark for the current thread."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nread a stream of floats and give summary statistics", "response": "def stats():\n    '''Read a stream of floats and give summary statistics'''\n    import re\n    import sys\n    import math\n    values = []\n    for line in sys.stdin:\n        values.extend(map(float, re.findall(r'\\d+\\.?\\d+', line)))\n\n    mean = sum(values) / len(values)\n    variance = sum((val - mean) ** 2 for val in values) / len(values)\n    print '%3i items; mean: %10.5f; std-dev: %10.5f' % (\n        len(values), mean, math.sqrt(variance))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef ready(self):\n        '''Whether or not enough time has passed since the last failure'''\n        if self._last_failed:\n            delta = time.time() - self._last_failed\n            return delta >= self.backoff()\n        return True", "response": "Whether or not enough time has passed since the last failure"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef execute_status(args, root_dir=None):\n    status = command_factory('status')({}, root_dir=root_dir)\n    # First rows, showing daemon status\n    if status['status'] == 'running':\n        status['status'] = Color('{autogreen}' + '{}'.format(status['status']) + '{/autogreen}')\n    elif status['status'] in ['paused']:\n        status['status'] = Color('{autoyellow}' + '{}'.format(status['status']) + '{/autoyellow}')\n\n    print('Daemon: {}\\n'.format(status['status']))\n\n    # Handle queue data\n    data = status['data']\n    if isinstance(data, str):\n        print(data)\n    elif isinstance(data, dict):\n        # Format incomming data to be compatible with Terminaltables\n        formatted_data = []\n        formatted_data.append(['Index', 'Status', 'Code',\n                               'Command', 'Path', 'Start', 'End'])\n        for key, entry in sorted(data.items(), key=operator.itemgetter(0)):\n            formatted_data.append(\n                [\n                    '#{}'.format(key),\n                    entry['status'],\n                    '{}'.format(entry['returncode']),\n                    entry['command'],\n                    entry['path'],\n                    entry['start'],\n                    entry['end']\n                ]\n            )\n\n        # Create AsciiTable instance and define style\n        table = AsciiTable(formatted_data)\n        table.outer_border = False\n        table.inner_column_border = False\n\n        terminal_width = terminal_size()\n        customWidth = table.column_widths\n        # If the text is wider than the actual terminal size, we\n        # compute a new size for the Command and Path column.\n        if (reduce(lambda a, b: a+b, table.column_widths) + 10) > terminal_width[0]:\n            # We have to subtract 14 because of table paddings\n            left_space = math.floor((terminal_width[0] - customWidth[0] - customWidth[1] - customWidth[2] - customWidth[5] - customWidth[6] - 14)/2)\n\n            if customWidth[3] < left_space:\n                customWidth[4] = 2*left_space - customWidth[3]\n            elif customWidth[4] < left_space:\n                customWidth[3] = 2*left_space - customWidth[4]\n            else:\n                customWidth[3] = left_space\n                customWidth[4] = left_space\n\n        # Format long strings to match the console width\n        for i, entry in enumerate(table.table_data):\n            for j, string in enumerate(entry):\n                max_width = customWidth[j]\n                wrapped_string = '\\n'.join(wrap(string, max_width))\n                if j == 1:\n                    if wrapped_string == 'done' or wrapped_string == 'running' or wrapped_string == 'paused':\n                        wrapped_string = Color('{autogreen}' + '{}'.format(wrapped_string) + '{/autogreen}')\n                    elif wrapped_string in ['queued', 'stashed']:\n                        wrapped_string = Color('{autoyellow}' + '{}'.format(wrapped_string) + '{/autoyellow}')\n                    elif wrapped_string in ['failed', 'stopping', 'killing']:\n                        wrapped_string = Color('{autored}' + '{}'.format(wrapped_string) + '{/autored}')\n                elif j == 2:\n                    if wrapped_string == '0' and wrapped_string != 'Code':\n                        wrapped_string = Color('{autogreen}' + '{}'.format(wrapped_string) + '{/autogreen}')\n                    elif wrapped_string != '0' and wrapped_string != 'Code':\n                        wrapped_string = Color('{autored}' + '{}'.format(wrapped_string) + '{/autored}')\n\n                table.table_data[i][j] = wrapped_string\n\n        print(table.table)\n    print('')", "response": "Print the status of the daemon."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef execute_log(args, root_dir):\n    # Print the logs of all specified processes\n    if args.get('keys'):\n        config_dir = os.path.join(root_dir, '.config/pueue')\n        queue_path = os.path.join(config_dir, 'queue')\n        if os.path.exists(queue_path):\n            queue_file = open(queue_path, 'rb')\n            try:\n                queue = pickle.load(queue_file)\n            except Exception:\n                print('Queue log file seems to be corrupted. Aborting.')\n                return\n            queue_file.close()\n        else:\n            print('There is no queue log file. Aborting.')\n            return\n\n        for key in args.get('keys'):\n            # Check if there is an entry with this key\n            if queue.get(key) and queue[key]['status'] in ['failed', 'done']:\n                entry = queue[key]\n                print('Log of entry: {}'.format(key))\n                print('Returncode: {}'.format(entry['returncode']))\n                print('Command: {}'.format(entry['command']))\n                print('Path: {}'.format(entry['path']))\n                print('Start: {}, End: {} \\n'.format(entry['start'], entry['end']))\n\n                # Write STDERR\n                if len(entry['stderr']) > 0:\n                    print(Color('{autored}Stderr output: {/autored}\\n    ') + entry['stderr'])\n\n                # Write STDOUT\n                if len(entry['stdout']) > 0:\n                    print(Color('{autogreen}Stdout output: {/autogreen}\\n    ') + entry['stdout'])\n            else:\n                print('No finished process with key {}.'.format(key))\n\n    # Print the log of all processes\n    else:\n        log_path = os.path.join(root_dir, '.local/share/pueue/queue.log')\n        log_file = open(log_path, 'r')\n        print(log_file.read())", "response": "Execute the log file of all processes in the specified root directory."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nprints stderr and stdout of the current running process. Args: args['watch'] (bool): If True, we open a curses session and tail the output live in the console. root_dir (string): The path to the root directory the daemon is running in.", "response": "def execute_show(args, root_dir):\n    \"\"\"Print stderr and stdout of the current running process.\n\n    Args:\n        args['watch'] (bool): If True, we open a curses session and tail\n                              the output live in the console.\n        root_dir (string): The path to the root directory the daemon is running in.\n\n    \"\"\"\n    key = None\n    if args.get('key'):\n        key = args['key']\n        status = command_factory('status')({}, root_dir=root_dir)\n        if key not in status['data'] or status['data'][key]['status'] != 'running':\n            print('No running process with this key, use `log` to show finished processes.')\n            return\n\n    # In case no key provided, we take the oldest running process\n    else:\n        status = command_factory('status')({}, root_dir=root_dir)\n        if isinstance(status['data'], str):\n            print(status['data'])\n            return\n        for k in sorted(status['data'].keys()):\n            if status['data'][k]['status'] == 'running':\n                key = k\n                break\n        if key is None:\n            print('No running process, use `log` to show finished processes.')\n            return\n\n    config_dir = os.path.join(root_dir, '.config/pueue')\n    # Get current pueueSTDout file from tmp\n    stdoutFile = os.path.join(config_dir, 'pueue_process_{}.stdout'.format(key))\n    stderrFile = os.path.join(config_dir, 'pueue_process_{}.stderr'.format(key))\n    stdoutDescriptor = open(stdoutFile, 'r')\n    stderrDescriptor = open(stderrFile, 'r')\n    running = True\n    # Continually print output with curses or just print once\n    if args['watch']:\n        # Initialize curses\n        stdscr = curses.initscr()\n        curses.noecho()\n        curses.cbreak()\n        curses.curs_set(2)\n        stdscr.keypad(True)\n        stdscr.refresh()\n\n        try:\n            # Update output every two seconds\n            while running:\n                stdscr.clear()\n                stdoutDescriptor.seek(0)\n                message = stdoutDescriptor.read()\n                stdscr.addstr(0, 0, message)\n                stdscr.refresh()\n                time.sleep(2)\n        except Exception:\n            # Curses cleanup\n            curses.nocbreak()\n            stdscr.keypad(False)\n            curses.echo()\n            curses.endwin()\n    else:\n        print('Stdout output:\\n')\n        stdoutDescriptor.seek(0)\n        print(get_descriptor_output(stdoutDescriptor, key))\n        print('\\n\\nStderr output:\\n')\n        stderrDescriptor.seek(0)\n        print(get_descriptor_output(stderrDescriptor, key))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nfetch a song track by given ID.", "response": "def fetch_track(self, track_id, terr=KKBOXTerritory.TAIWAN):\n        '''\n        Fetches a song track by given ID.\n\n        :param track_id: the track ID.\n        :type track_id: str\n        :return: API response.\n        :rtype: dict\n\n        See `https://docs-en.kkbox.codes/v1.1/reference#tracks-track_id`.\n        '''\n        url = 'https://api.kkbox.com/v1.1/tracks/%s' % track_id\n        url += '?' + url_parse.urlencode({'territory': terr})\n        return self.http._post_data(url, None, self.http._headers_with_access_token())"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nshow a specific Indicator by id", "response": "def show(self, user, feed, id):\n        \"\"\"\n        Show a specific indicator by id\n\n        :param user: feed username\n        :param feed: feed name\n        :param id: indicator endpoint id [INT]\n        :return: dict\n\n        Example:\n            ret = Indicator.show('csirtgadgets','port-scanners', '1234')\n        \"\"\"\n        uri = '/users/{}/feeds/{}/indicators/{}'.format(user, feed, id)\n        return self.client.get(uri)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef create(self):\n        uri = '/users/{0}/feeds/{1}/indicators'\\\n            .format(self.user, self.feed)\n\n        data = {\n            \"indicator\": json.loads(str(self.indicator)),\n            \"comment\": self.comment,\n            \"content\": self.content\n        }\n\n        if self.attachment:\n            attachment = self._file_to_attachment(\n                self.attachment, filename=self.attachment_name)\n\n            data['attachment'] = {\n                'data': attachment['data'],\n                'filename': attachment['filename']\n            }\n\n        if not data['indicator'].get('indicator'):\n            data['indicator']['indicator'] = attachment['sha1']\n\n        if not data['indicator'].get('indicator'):\n            raise Exception('Missing indicator')\n\n        return self.client.post(uri, data)", "response": "Submit action on the Indicator object"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates a list of Indicator Objects for a user and feed.", "response": "def create_bulk(self, indicators, user, feed):\n        from .constants import API_VERSION\n        if API_VERSION == '1':\n            print(\"create_bulk currently un-avail with APIv1\")\n            raise SystemExit\n\n        \"\"\"\n        Submit action against the IndicatorBulk endpoint\n\n        :param indicators: list of Indicator Objects\n        :param user: feed username\n        :param feed: feed name\n        :return: list of Indicator Objects submitted\n\n        from csirtgsdk.client import Client\n        from csirtgsdk.indicator import Indicator\n\n        remote = 'https://csirtg.io/api'\n        token = ''\n        verify_ssl = True\n\n        i = {\n            'indicator': 'example.com',\n            'feed': 'test',\n            'user': 'admin',\n            'comment': 'this is a test',\n        }\n\n        data = []\n\n        cli = Client(remote=remote, token=token, verify_ssl=verify_ssl)\n\n        for x in range(0, 5):\n            data.append(\n                Indicator(cli, i)\n            )\n\n        ret = cli.submit_bulk(data, 'csirtgadgets', 'test-feed')\n        \"\"\"\n\n        uri = '/users/{0}/feeds/{1}/indicators_bulk'.format(user, feed)\n\n        data = {\n            'indicators': [\n                {\n                    'indicator': i.args.indicator,\n                    'feed_id': i.args.feed,\n                    'tag_list': i.args.tags,\n                    \"description\": i.args.description,\n                    \"portlist\": i.args.portlist,\n                    \"protocol\": i.args.protocol,\n                    'firsttime': i.args.firsttime,\n                    'lasttime': i.args.lasttime,\n                    'portlist_src': i.args.portlist_src,\n                    'comment': {\n                        'content': i.args.comment\n                    },\n                    'rdata': i.args.rdata,\n                    'rtype': i.args.rtype,\n                    'content': i.args.content,\n                    'provider': i.args.provider,\n                } for i in indicators\n                ]\n        }\n        return self.client.post(uri, data)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef bind_global_key(conn, event_type, key_string, cb):\n    root = conn.get_setup().roots[0].root\n    return bind_key(conn, event_type, root, key_string, cb)", "response": "Bind a global key to the root window."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef bind_key(conn, event_type, wid, key_string, cb):\n    assert event_type in ('KeyPress', 'KeyRelease')\n\n    mods, kc = parse_keystring(conn, key_string)\n    key = (wid, mods, kc)\n\n    if not kc:\n        print(\"Could not find a keycode for \" + key_string)\n        return False\n\n    if not __keygrabs[key] and not grab_key(conn, wid, mods, kc):\n        return False\n\n    __keybinds[key].append(cb)\n    __keygrabs[key] += 1\n\n    return True", "response": "Binds a function cb to a particular key press or key release window."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef lookup_string(conn, kstr):\n    if kstr in keysyms:\n        return get_keycode(conn, keysyms[kstr])\n    elif len(kstr) > 1 and kstr.capitalize() in keysyms:\n        return get_keycode(conn, keysyms[kstr.capitalize()])\n\n    return None", "response": "Returns the keycode associated with a string representation of a keysym."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a keyboard mapping cookie that can be used to fetch the table of keysyms in the current X environment.", "response": "def get_keyboard_mapping(conn):\n    \"\"\"\n    Return a keyboard mapping cookie that can be used to fetch the table of\n    keysyms in the current X environment.\n\n    :rtype: xcb.xproto.GetKeyboardMappingCookie\n    \"\"\"\n    mn, mx = get_min_max_keycode(conn)\n\n    return conn.core.GetKeyboardMapping(mn, mx - mn + 1)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_keyboard_mapping_unchecked(conn):\n    mn, mx = get_min_max_keycode()\n\n    return conn.core.GetKeyboardMappingUnchecked(mn, mx - mn + 1)", "response": "Returns an unchecked keyboard mapping cookie that can be used to fetch the current X environment s keysyms."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_keysym(conn, keycode, col=0, kbmap=None):\n    if kbmap is None:\n        kbmap = __kbmap\n\n    mn, mx = get_min_max_keycode(conn)\n    per = kbmap.keysyms_per_keycode\n    ind = (keycode - mn) * per + col\n\n    return kbmap.keysyms[ind]", "response": "Get the keysym associated with a particular keycode in the current XMacro environment."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ngive a keysym find the keycode mapped to it in the current X environment.", "response": "def get_keycode(conn, keysym):\n    \"\"\"\n    Given a keysym, find the keycode mapped to it in the current X environment.\n    It is necessary to search the keysym table in order to do this, including\n    all columns.\n\n    :param keysym: An X keysym.\n    :return: A keycode or None if one could not be found.\n    :rtype: int\n    \"\"\"\n    mn, mx = get_min_max_keycode(conn)\n    cols = __kbmap.keysyms_per_keycode\n    for i in range(mn, mx + 1):\n        for j in range(0, cols):\n            ks = get_keysym(conn, i, col=j)\n            if ks == keysym:\n                return i\n\n    return None"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nfetching and creates the keycode - > modifier mask mapping. Typically you don t have to use this---xpybutil will keep this up to date.", "response": "def get_keys_to_mods(conn):\n    \"\"\"\n    Fetches and creates the keycode -> modifier mask mapping. Typically, you\n    shouldn't have to use this---xpybutil will keep this up to date if it\n    changes.\n\n    This function may be useful in that it should closely replicate the output\n    of the ``xmodmap`` command. For example:\n\n     ::\n\n        keymods = get_keys_to_mods()\n        for kc in sorted(keymods, key=lambda kc: keymods[kc]):\n            print keymods[kc], hex(kc), get_keysym_string(get_keysym(kc))\n\n    Which will very closely replicate ``xmodmap``. I'm not getting precise\n    results quite yet, but I do believe I'm getting at least most of what\n    matters. (i.e., ``xmodmap`` returns valid keysym strings for some that\n    I cannot.)\n\n    :return: A dict mapping from keycode to modifier mask.\n    :rtype: dict\n    \"\"\"\n    mm = xproto.ModMask\n    modmasks = [mm.Shift, mm.Lock, mm.Control,\n                mm._1, mm._2, mm._3, mm._4, mm._5] # order matters\n\n    mods = conn.core.GetModifierMapping().reply()\n\n    res = {}\n    keyspermod = mods.keycodes_per_modifier\n    for mmi in range(0, len(modmasks)):\n        row = mmi * keyspermod\n        for kc in mods.keycodes[row:row + keyspermod]:\n            res[kc] = modmasks[mmi]\n\n    return res"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a list of modifiers that were pressed in a key press event.", "response": "def get_modifiers(state):\n    \"\"\"\n    Takes a ``state`` (typically found in key press or button press events)\n    and returns a string list representation of the modifiers that were pressed\n    when generating the event.\n\n    :param state: Typically from ``some_event.state``.\n    :return: List of modifier string representations.\n    :rtype: [str]\n    \"\"\"\n    ret = []\n\n    if state & xproto.ModMask.Shift:\n        ret.append('Shift')\n    if state & xproto.ModMask.Lock:\n        ret.append('Lock')\n    if state & xproto.ModMask.Control:\n        ret.append('Control')\n    if state & xproto.ModMask._1:\n        ret.append('Mod1')\n    if state & xproto.ModMask._2:\n        ret.append('Mod2')\n    if state & xproto.ModMask._3:\n        ret.append('Mod3')\n    if state & xproto.ModMask._4:\n        ret.append('Mod4')\n    if state & xproto.ModMask._5:\n        ret.append('Mod5')\n    if state & xproto.KeyButMask.Button1:\n        ret.append('Button1')\n    if state & xproto.KeyButMask.Button2:\n        ret.append('Button2')\n    if state & xproto.KeyButMask.Button3:\n        ret.append('Button3')\n    if state & xproto.KeyButMask.Button4:\n        ret.append('Button4')\n    if state & xproto.KeyButMask.Button5:\n        ret.append('Button5')\n\n    return ret"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef grab_key(conn, wid, modifiers, key):\n    try:\n        for mod in TRIVIAL_MODS:\n            conn.core.GrabKeyChecked(True, wid, modifiers | mod, key, GM.Async,\n                                     GM.Async).check()\n\n        return True\n    except xproto.BadAccess:\n        return False", "response": "Grabs a key for a particular window and a modifiers and key value."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef ungrab_key(conn, wid, modifiers, key):\n    try:\n        for mod in TRIVIAL_MODS:\n            conn.core.UngrabKeyChecked(key, wid, modifiers | mod).check()\n\n        return True\n    except xproto.BadAccess:\n        return False", "response": "Ungrabs a key that was grabbed by grab_key."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef update_keyboard_mapping(conn, e):\n    global __kbmap, __keysmods\n\n    newmap = get_keyboard_mapping(conn).reply()\n\n    if e is None:\n        __kbmap = newmap\n        __keysmods = get_keys_to_mods(conn)\n        return\n\n    if e.request == xproto.Mapping.Keyboard:\n        changes = {}\n        for kc in range(*get_min_max_keycode(conn)):\n            knew = get_keysym(kc, kbmap=newmap)\n            oldkc = get_keycode(conn, knew)\n            if oldkc != kc:\n                changes[oldkc] = kc\n\n        __kbmap = newmap\n        __regrab(changes)\n    elif e.request == xproto.Mapping.Modifier:\n        __keysmods = get_keys_to_mods()", "response": "Updates the keyboard mapping for the current keycode."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef run_keybind_callbacks(e):\n    kc, mods = e.detail, e.state\n    for mod in TRIVIAL_MODS:\n        mods &= ~mod\n\n    key = (e.event, mods, kc)\n    serviced = False\n    for cb in __keybinds.get(key, []):\n        try:\n            cb(e)\n            serviced = True\n        except TypeError:\n            cb()\n    return serviced", "response": "A function that intercepts all key press and release events and runs all corresponding callback functions."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ntaking a dictionary of changes (mapping old keycode to new keycode) and regrabs any keys that have been changed with the updated keycode. :param changes: Mapping of changes from old keycode to new keycode. :type changes: dict :rtype: void", "response": "def __regrab(changes):\n    \"\"\"\n    Takes a dictionary of changes (mapping old keycode to new keycode) and\n    regrabs any keys that have been changed with the updated keycode.\n\n    :param changes: Mapping of changes from old keycode to new keycode.\n    :type changes: dict\n    :rtype: void\n    \"\"\"\n    for wid, mods, kc in __keybinds.keys():\n        if kc in changes:\n            ungrab_key(wid, mods, kc)\n            grab_key(wid, mods, changes[kc])\n\n            old = (wid, mods, kc)\n            new = (wid, mods, changes[kc])\n            __keybinds[new] = __keybinds[old]\n            del __keybinds[old]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting a list of Storage objects from the API.", "response": "def get_storages(self, storage_type='normal'):\n        \"\"\"\n        Return a list of Storage objects from the API.\n\n        Storage types: public, private, normal, backup, cdrom, template, favorite\n        \"\"\"\n        res = self.get_request('/storage/' + storage_type)\n        return Storage._create_storage_objs(res['storages'], cloud_manager=self)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_storage(self, storage):\n        res = self.get_request('/storage/' + str(storage))\n        return Storage(cloud_manager=self, **res['storage'])", "response": "Return a Storage object from the API."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef create_storage(self, size=10, tier='maxiops', title='Storage disk', zone='fi-hel1', backup_rule={}):\n        body = {\n            'storage': {\n                'size': size,\n                'tier': tier,\n                'title': title,\n                'zone': zone,\n                'backup_rule': backup_rule\n            }\n        }\n        res = self.post_request('/storage', body)\n        return Storage(cloud_manager=self, **res['storage'])", "response": "Create a Storage object. Returns an object based on the API s response."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef modify_storage(self, storage, size, title, backup_rule={}):\n        res = self._modify_storage(str(storage), size, title, backup_rule)\n        return Storage(cloud_manager=self, **res['storage'])", "response": "Modify a storage object. Returns an object based on the API s response."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef attach_storage(self, server, storage, storage_type, address):\n        body = {'storage_device': {}}\n        if storage:\n            body['storage_device']['storage'] = str(storage)\n\n        if storage_type:\n            body['storage_device']['type'] = storage_type\n\n        if address:\n            body['storage_device']['address'] = address\n\n        url = '/server/{0}/storage/attach'.format(server)\n        res = self.post_request(url, body)\n        return Storage._create_storage_objs(res['server']['storage_devices'], cloud_manager=self)", "response": "Attach a Storage object to a Server. Return a list of the server s storages."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef detach_storage(self, server, address):\n        body = {'storage_device': {'address': address}}\n        url = '/server/{0}/storage/detach'.format(server)\n        res = self.post_request(url, body)\n        return Storage._create_storage_objs(res['server']['storage_devices'], cloud_manager=self)", "response": "Detach a Storage object to a Server. Return a list of the server s storages."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nresets the internal state of the object.", "response": "def _reset(self, **kwargs):\n        \"\"\"\n        Reset after repopulating from API.\n        \"\"\"\n\n        # there are some inconsistenciens in the API regarding these\n        # note: this could be written in fancier ways, but this way is simpler\n\n        if 'uuid' in kwargs:\n            self.uuid = kwargs['uuid']\n        elif 'storage' in kwargs:  # let's never use storage.storage internally\n            self.uuid = kwargs['storage']\n\n        if 'title' in kwargs:\n            self.title = kwargs['title']\n        elif 'storage_title' in kwargs:\n            self.title = kwargs['storage_title']\n\n        if 'size' in kwargs:\n            self.size = kwargs['size']\n        elif 'storage_size' in kwargs:\n            self.size = kwargs['storage_size']\n\n        # send the rest to super._reset\n\n        filtered_kwargs = dict(\n            (key, val)\n            for key, val in kwargs.items()\n            if key not in ['uuid', 'storage', 'title', 'storage_title', 'size', 'storage_size']\n        )\n        super(Storage, self)._reset(**filtered_kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsaving the current storage to the API.", "response": "def save(self):\n        \"\"\"\n        Save (modify) the storage to the API.\n        Note: only size and title are updateable fields.\n        \"\"\"\n        res = self.cloud_manager._modify_storage(self, self.size, self.title)\n        self._reset(**res['storage'])"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef to_dict(self):\n        body = {\n            'tier': self.tier,\n            'title': self.title,\n            'size': self.size,\n        }\n\n        # optionals\n\n        if hasattr(self, 'address') and self.address:\n            body['address'] = self.address\n\n        if hasattr(self, 'zone') and self.zone:\n            body['zone'] = self.zone\n\n        return body", "response": "Returns a dict that can be serialised to JSON and sent to UpCloud s API."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nfetch an album by given ID.", "response": "def fetch_album(self, album_id, terr=KKBOXTerritory.TAIWAN):\n        '''\n        Fetches an album by given ID.\n\n        :param album_id: the album ID.\n        :type album_id: str\n        :param terr: the current territory.\n        :return: API response.\n        :rtype: dict\n\n        See `https://docs-en.kkbox.codes/v1.1/reference#albums-album_id`.\n        '''\n        url = 'https://api.kkbox.com/v1.1/albums/%s' % album_id\n        url += '?' + url_parse.urlencode({'territory': terr})\n        return self.http._post_data(url, None, self.http._headers_with_access_token())"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef lookup(self):\n        print \"%s by %s, size: %s, uploaded %s ago\" % (self.name, self.author,\n                                                       self.size, self.age)", "response": "Prints name author size and age of the object"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _get_max_page(self, url):\n        html = requests.get(url).text\n        pq = PyQuery(html)\n        try:\n            tds = int(pq(\"h2\").text().split()[-1])\n            if tds % 25:\n                return tds / 25 + 1\n            return tds / 25\n        except ValueError:\n            raise ValueError(\"No results found!\")", "response": "Get the maximum number of pages from a URL."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef build(self, update=True):\n        ret = self.base + self.query\n        page = \"\".join((\"/\", str(self.page), \"/\"))\n\n        if self.category:\n            category = \" category:\" + self.category\n        else:\n            category = \"\"\n\n        if self.order:\n            order = \"\".join((\"?field=\", self.order[0], \"&sorder=\", self.order[1]))\n        else:\n            order = \"\"\n\n        ret = \"\".join((self.base, self.query, category, page, order))\n\n        if update:\n            self.max_page = self._get_max_page(ret)\n        return ret", "response": "Build and return url. Also update max_page."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nbuilds and return url.", "response": "def build(self, update=True):\n        \"\"\"\n        Build and return url. Also update max_page.\n        URL structure for user torrent lists differs from other result lists\n        as the page number is part of the query string and not the URL path\n        \"\"\"\n        query_str = \"?page={}\".format(self.page)\n        if self.order:\n            query_str += \"\".join((\"&field=\", self.order[0], \"&sorder=\",self.order[1]))\n\n        ret = \"\".join((self.base, self.user, \"/uploads/\", query_str))\n\n        if update:\n            self.max_page = self._get_max_page(ret)\n        return ret"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nparse url and yield namedtuple Torrent for every torrent on page", "response": "def _items(self):\n        \"\"\"\n        Parse url and yield namedtuple Torrent for every torrent on page\n        \"\"\"\n        torrents = map(self._get_torrent, self._get_rows())\n\n        for t in torrents:\n            yield t"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nparse a table row into namedtuple", "response": "def _get_torrent(self, row):\n        \"\"\"\n        Parse row into namedtuple\n        \"\"\"\n        td = row(\"td\")\n        name = td(\"a.cellMainLink\").text()\n        name = name.replace(\" . \", \".\").replace(\" .\", \".\")\n        author = td(\"a.plain\").text()\n        verified_author = True if td(\".lightgrey>.ka-verify\") else False\n        category = td(\"span\").find(\"strong\").find(\"a\").eq(0).text()\n        verified_torrent = True if td(\".icon16>.ka-green\") else False\n        comments = td(\".iaconbox>.icommentjs>.iconvalue\").text()\n        torrent_link = \"http://\" + BASE.domain\n        if td(\"a.cellMainLink\").attr(\"href\") is not None:\n            torrent_link += td(\"a.cellMainLink\").attr(\"href\")\n        magnet_link = td(\"a[data-nop]\").eq(1).attr(\"href\")\n        download_link = td(\"a[data-download]\").attr(\"href\")\n\n        td_centers = row(\"td.center\")\n        size = td_centers.eq(0).text()\n        files = td_centers.eq(1).text()\n        age = \" \".join(td_centers.eq(2).text().split())\n        seed = td_centers.eq(3).text()\n        leech = td_centers.eq(4).text()\n\n        return Torrent(name, author, verified_author, category, size,\n                       files, age, seed, leech, verified_torrent, comments,\n                       torrent_link, magnet_link, download_link)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting all rows on page", "response": "def _get_rows(self):\n        \"\"\"\n        Return all rows on page\n        \"\"\"\n        html = requests.get(self.url.build()).text\n        if re.search('did not match any documents', html):\n            return []\n        pq = PyQuery(html)\n        rows = pq(\"table.data\").find(\"tr\")\n        return map(rows.eq, range(rows.size()))[1:]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef pages(self, page_from, page_to):\n        if not all([page_from < self.url.max_page, page_from > 0,\n                    page_to <= self.url.max_page, page_to > page_from]):\n            raise IndexError(\"Invalid page numbers\")\n\n        size = (page_to + 1) - page_from\n        threads = ret = []\n        page_list = range(page_from, page_to+1)\n\n        locks = [threading.Lock() for i in range(size)]\n\n        for lock in locks[1:]:\n            lock.acquire()\n\n        def t_function(pos):\n            \"\"\"\n            Thread function that fetch page for list of torrents\n            \"\"\"\n            res = self.page(page_list[pos]).list()\n            locks[pos].acquire()\n            ret.extend(res)\n            if pos != size-1:\n                locks[pos+1].release()\n\n        threads = [threading.Thread(target=t_function, args=(i,))\n                   for i in range(size)]\n\n        for thread in threads:\n            thread.start()\n\n        for thread in threads:\n            thread.join()\n\n        for torrent in ret:\n            yield torrent", "response": "Yields torrents in range from page_from to page_to"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef all(self):\n        return self.pages(self.url.page, self.url.max_page)", "response": "Yield torrents in range from current page to last page"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsetting field and order by arguments", "response": "def order(self, field, order=None):\n        \"\"\"\n        Set field and order set by arguments\n        \"\"\"\n        if not order:\n            order = ORDER.DESC\n        self.url.order = (field, order)\n        self.url.set_page(1)\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nchange category of current search and return self", "response": "def category(self, category):\n        \"\"\"\n        Change category of current search and return self\n        \"\"\"\n        self.url.category = category\n        self.url.set_page(1)\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ndestroy this FirewallRule from the API.", "response": "def destroy(self):\n        \"\"\"\n        Remove this FirewallRule from the API.\n\n        This instance must be associated with a server for this method to work,\n        which is done by instantiating via server.get_firewall_rules().\n        \"\"\"\n        if not hasattr(self, 'server') or not self.server:\n            raise Exception(\n                \"\"\"FirewallRule not associated with server;\n                please use or server.get_firewall_rules() to get objects\n                that are associated with a server.\n                \"\"\")\n        return self.server.cloud_manager.delete_firewall_rule(\n            self.server.uuid,\n            self.position\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nfetching new release categories by given ID.", "response": "def fetch_new_release_category(self, category_id, terr=KKBOXTerritory.TAIWAN):\n        '''\n        Fetches new release categories by given ID.\n\n        :param category_id: the station ID.\n        :type category_id: str\n        :param terr: the current territory.\n        :return: API response.\n        :rtype: list\n\n        See `https://docs-en.kkbox.codes/v1.1/reference#newreleasecategories-category_id`\n        '''\n        url = 'https://api.kkbox.com/v1.1/new-release-categories/%s' % category_id\n        url += '?' + url_parse.urlencode({'territory': terr})\n        return self.http._post_data(url, None, self.http._headers_with_access_token())"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nfetch the top tracks of an artist by given ID.", "response": "def fetch_top_tracks_of_artist(self, artist_id, terr=KKBOXTerritory.TAIWAN):\n        '''\n        Fetcher top tracks belong to an artist by given ID.\n\n        :param artist_id: the artist ID.\n        :type artist_id: str\n        :param terr: the current territory.\n        :return: API response.\n        :rtype: dict\n\n        See 'https://docs-en.kkbox.codes/v1.1/reference#artists-artist_id-toptracks'\n        '''\n        url = 'https://api.kkbox.com/v1.1/artists/%s/top-tracks' % artist_id\n        url += '?' + url_parse.urlencode({'territory': terr})\n        return self.http._post_data(url, None, self.http._headers_with_access_token())"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_tags(self):\n        res = self.get_request('/tag')\n        return [Tag(cloud_manager=self, **tag) for tag in res['tags']['tag']]", "response": "List all tags as Tag objects."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_tag(self, name):\n        res = self.get_request('/tag/' + name)\n        return Tag(cloud_manager=self, **res['tag'])", "response": "Return the tag as Tag object."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate a new Tag. Only name is mandatory.", "response": "def create_tag(self, name, description=None, servers=[]):\n        \"\"\"\n        Create a new Tag. Only name is mandatory.\n\n        Returns the created Tag object.\n        \"\"\"\n        servers = [str(server) for server in servers]\n        body = {'tag': Tag(name, description, servers).to_dict()}\n        res = self.request('POST', '/tag', body)\n\n        return Tag(cloud_manager=self, **res['tag'])"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nputs /tag/name. Returns a dict that can be used to create a Tag object. Private method used by the Tag class and TagManager.modify_tag.", "response": "def _modify_tag(self, name, description, servers, new_name):\n        \"\"\"\n        PUT /tag/name. Returns a dict that can be used to create a Tag object.\n\n        Private method used by the Tag class and TagManager.modify_tag.\n        \"\"\"\n        body = {'tag': Tag(new_name, description, servers).to_dict()}\n        res = self.request('PUT', '/tag/' + name, body)\n        return res['tag']"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nput /tag/name. Returns a new Tag object based on the API response.", "response": "def modify_tag(self, name, description=None, servers=None, new_name=None):\n        \"\"\"\n        PUT /tag/name. Returns a new Tag object based on the API response.\n        \"\"\"\n        res = self._modify_tag(name, description, servers, new_name)\n        return Tag(cloud_manager=self, **res['tag'])"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nremove tags from a server.", "response": "def remove_tags(self, server, tags):\n        \"\"\"\n        Remove tags from a server.\n\n        - server: Server object or UUID string\n        - tags: list of Tag objects or strings\n        \"\"\"\n        uuid = str(server)\n        tags = [str(tag) for tag in tags]\n\n        url = '/server/{0}/untag/{1}'.format(uuid, ','.join(tags))\n        return self.post_request(url)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nassign object attributes from API responses.", "response": "def assignIfExists(opts, default=None, **kwargs):\n    \"\"\"\n    Helper for assigning object attributes from API responses.\n    \"\"\"\n    for opt in opts:\n        if(opt in kwargs):\n            return kwargs[opt]\n    return default"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef try_it_n_times(operation, expected_error_codes, custom_error='operation failed', n=10):\n    for i in itertools.count():\n        try:\n            operation()\n            break\n        except UpCloudAPIError as e:\n            if e.error_code not in expected_error_codes:\n                raise e\n            sleep(3)\n        if i >= n - 1:\n            raise UpCloudClientError(custom_error)", "response": "Try a given operation n times."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef hkdf_extract(salt, input_key_material, hash=hashlib.sha512):\n\t'''\n\tExtract a pseudorandom key suitable for use with hkdf_expand\n\tfrom the input_key_material and a salt using HMAC with the\n\tprovided hash (default SHA-512).\n\n\tsalt should be a random, application-specific byte string. If\n\tsalt is None or the empty string, an all-zeros string of the same\n\tlength as the hash's block size will be used instead per the RFC.\n\t\n\tSee the HKDF draft RFC and paper for usage notes.\n\t'''\n\thash_len = hash().digest_size\n\tif salt == None or len(salt) == 0:\n\t\tsalt = bytearray((0,) * hash_len)\n\treturn hmac.new(bytes(salt), buffer(input_key_material), hash).digest()", "response": "This function extracts a pseudorandom key suitable for use with HKDF."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef hkdf_expand(pseudo_random_key, info=b\"\", length=32, hash=hashlib.sha512):\n\t'''\n\tExpand `pseudo_random_key` and `info` into a key of length `bytes` using\n\tHKDF's expand function based on HMAC with the provided hash (default\n\tSHA-512). See the HKDF draft RFC and paper for usage notes.\n\t'''\n\thash_len = hash().digest_size\n\tlength = int(length)\n\tif length > 255 * hash_len:\n\t\traise Exception(\"Cannot expand to more than 255 * %d = %d bytes using the specified hash function\" %\\\n\t\t\t(hash_len, 255 * hash_len))\n\tblocks_needed = length // hash_len + (0 if length % hash_len == 0 else 1) # ceil\n\tokm = b\"\"\n\toutput_block = b\"\"\n\tfor counter in range(blocks_needed):\n\t\toutput_block = hmac.new(pseudo_random_key, buffer(output_block + info + bytearray((counter + 1,))),\\\n\t\t\thash).digest()\n\t\tokm += output_block\n\treturn okm[:length]", "response": "This function expands the pseudo_random_key and info into a key of length using the HKDF algorithm."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ngenerate a new key material based on the info and length.", "response": "def expand(self, info=b\"\", length=32):\n\t\t'''\n\t\tGenerate output key material based on an `info` value\n\n\t\tArguments:\n\t\t- info - context to generate the OKM\n\t\t- length - length in bytes of the key to generate\n\n\t\tSee the HKDF draft RFC for guidance.\n\t\t'''\n\t\treturn hkdf_expand(self._prk, info, length, self._hash)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _reset(self, server, **kwargs):\n        if server:\n            # handle storage, ip_address dicts and tags if they exist\n            Server._handle_server_subobjs(server, kwargs.get('cloud_manager'))\n\n            for key in server:\n                object.__setattr__(self, key, server[key])\n\n        for key in kwargs:\n            object.__setattr__(self, key, kwargs[key])", "response": "Reset the object with new values given as params."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\npopulates the object with the current data.", "response": "def populate(self):\n        \"\"\"\n        Sync changes from the API to the local object.\n\n        Note: syncs ip_addresses and storage_devices too (/server/uuid endpoint)\n        \"\"\"\n        server, IPAddresses, storages = self.cloud_manager.get_server_data(self.uuid)\n        self._reset(\n            server,\n            ip_addresses=IPAddresses,\n            storage_devices=storages,\n            populated=True\n        )\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsaving the current object to the API.", "response": "def save(self):\n        \"\"\"\n        Sync local changes in server's attributes to the API.\n\n        Note: DOES NOT sync IPAddresses and storage_devices,\n        use add_ip, add_storage, remove_ip, remove_storage instead.\n        \"\"\"\n        # dict comprehension that also works with 2.6\n        # http://stackoverflow.com/questions/21069668/alternative-to-dict-comprehension-prior-to-python-2-7\n        kwargs = dict(\n            (field, getattr(self, field))\n            for field in self.updateable_fields\n            if hasattr(self, field)\n        )\n\n        self.cloud_manager.modify_server(self.uuid, **kwargs)\n        self._reset(kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nstarts the server. Note: slow and blocking request. The API waits for confirmation from UpCloud's IaaS backend before responding.", "response": "def start(self, timeout=120):\n        \"\"\"\n        Start the server. Note: slow and blocking request.\n\n        The API waits for confirmation from UpCloud's IaaS backend before responding.\n        \"\"\"\n        path = '/server/{0}/start'.format(self.uuid)\n        self.cloud_manager.post_request(path, timeout=timeout)\n        object.__setattr__(self, 'state', 'started')"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nadds a new IP - address to the server.", "response": "def add_ip(self, family='IPv4'):\n        \"\"\"\n        Allocate a new (random) IP-address to the Server.\n        \"\"\"\n        IP = self.cloud_manager.attach_ip(self.uuid, family)\n        self.ip_addresses.append(IP)\n        return IP"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nremoving the specified IP - address from the server.", "response": "def remove_ip(self, IPAddress):\n        \"\"\"\n        Release the specified IP-address from the server.\n        \"\"\"\n        self.cloud_manager.release_ip(IPAddress.address)\n        self.ip_addresses.remove(IPAddress)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef add_storage(self, storage=None, type='disk', address=None):\n        self.cloud_manager.attach_storage(server=self.uuid,\n                                          storage=storage.uuid,\n                                          storage_type=type,\n                                          address=address)\n        storage.address = address\n        storage.type = type\n        self.storage_devices.append(storage)", "response": "Add a storage device to the server."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef remove_storage(self, storage):\n        if not hasattr(storage, 'address'):\n            raise Exception(\n                ('Storage does not have an address. '\n                 'Access the Storage via Server.storage_devices '\n                 'so they include an address. '\n                 '(This is due how the API handles Storages)')\n            )\n\n        self.cloud_manager.detach_storage(server=self.uuid, address=storage.address)\n        self.storage_devices.remove(storage)", "response": "Removes a storage from a Server."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef add_tags(self, tags):\n        if self.cloud_manager.assign_tags(self.uuid, tags):\n            tags = self.tags + [str(tag) for tag in tags]\n            object.__setattr__(self, 'tags', tags)", "response": "Adds tags to a server. Accepts tags as strings or Tag objects."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef remove_tags(self, tags):\n        if self.cloud_manager.remove_tags(self, tags):\n            new_tags = [tag for tag in self.tags if tag not in tags]\n            object.__setattr__(self, 'tags', new_tags)", "response": "Removes tags from a server."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nprepares a JSON serializable dict from a Server instance with nested.", "response": "def prepare_post_body(self):\n        \"\"\"\n        Prepare a JSON serializable dict from a Server instance with nested.\n\n        Storage instances.\n        \"\"\"\n        body = dict()\n        # mandatory\n        body['server'] = {\n            'hostname': self.hostname,\n            'zone': self.zone,\n            'title': self.title,\n            'storage_devices': {}\n        }\n\n        # optional fields\n\n        for optional_field in self.optional_fields:\n            if hasattr(self, optional_field):\n                body['server'][optional_field] = getattr(self, optional_field)\n\n        # set password_delivery default as 'none' to prevent API from sending\n        # emails (with credentials) about each created server\n        if not hasattr(self, 'password_delivery'):\n            body['server']['password_delivery'] = 'none'\n\n        # collect storage devices and create a unique title (see: Storage.title in API doc)\n        # for each of them\n\n        body['server']['storage_devices'] = {\n            'storage_device': []\n        }\n\n        storage_title_id = 0  # running number for unique storage titles\n        for storage in self.storage_devices:\n            if not hasattr(storage, 'os') or storage.os is None:\n                storage_title_id += 1\n            storage_body = storage.to_dict()\n\n            # setup default titles for storages unless the user has specified\n            # them at storage.title\n            if not hasattr(storage, 'title') or not storage.title:\n                if hasattr(storage, 'os') and storage.os:\n                    storage_body['title'] = self.hostname + ' OS disk'\n                else:\n                    storage_body['title'] = self.hostname + ' storage disk ' + str(storage_title_id)\n\n\n            # figure out the storage `action` parameter\n            # public template\n            if hasattr(storage, 'os') and storage.os:\n                storage_body['action'] = 'clone'\n                storage_body['storage'] = OperatingSystems.get_OS_UUID(storage.os)\n\n            # private template\n            elif hasattr(storage, 'uuid'):\n                storage_body['action'] = 'clone'\n                storage_body['storage'] = storage.uuid\n\n            # create a new storage\n            else:\n                storage_body['action'] = 'create'\n\n            body['server']['storage_devices']['storage_device'].append(storage_body)\n\n        if hasattr(self, 'ip_addresses') and self.ip_addresses:\n            body['server']['ip_addresses'] = {\n                'ip_address': [\n                    ip.to_dict() for ip in self.ip_addresses\n                ]\n            }\n\n\n        return body"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a JSON serializable dict for read - only purposes.", "response": "def to_dict(self):\n        \"\"\"\n        Prepare a JSON serializable dict for read-only purposes.\n\n        Includes storages and IP-addresses.\n        Use prepare_post_body for POST and .save() for PUT.\n        \"\"\"\n        fields = dict(vars(self).items())\n\n        if self.populated:\n            fields['ip_addresses'] = []\n            fields['storage_devices'] = []\n            for ip in self.ip_addresses:\n                fields['ip_addresses'].append({\n                    'address': ip.address,\n                    'access': ip.access,\n                    'family': ip.family\n                })\n\n            for storage in self.storage_devices:\n                fields['storage_devices'].append({\n                    'address': storage.address,\n                    'storage': storage.uuid,\n                    'storage_size': storage.size,\n                    'storage_title': storage.title,\n                    'type': storage.type,\n                })\n\n        del fields['populated']\n        del fields['cloud_manager']\n        return fields"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting the server s IP address.", "response": "def get_ip(self, access='public', addr_family=None, strict=None):\n        \"\"\"\n        Return the server's IP address.\n\n        Params:\n        - addr_family: IPv4, IPv6 or None. None prefers IPv4 but will\n                       return IPv6 if IPv4 addr was not available.\n        - access: 'public' or 'private'\n        \"\"\"\n        if addr_family not in ['IPv4', 'IPv6', None]:\n            raise Exception(\"`addr_family` must be 'IPv4', 'IPv6' or None\")\n\n        if access not in ['private', 'public']:\n            raise Exception(\"`access` must be 'public' or 'private'\")\n\n        if not hasattr(self, 'ip_addresses'):\n            self.populate()\n\n        # server can have several public or private IPs\n        ip_addrs = [\n            ip_addr for ip_addr in self.ip_addresses\n            if ip_addr.access == access\n        ]\n\n        # prefer addr_family (or IPv4 if none given)\n        preferred_family = addr_family if addr_family else 'IPv4'\n        for ip_addr in ip_addrs:\n            if ip_addr.family == preferred_family:\n                return ip_addr.address\n\n        # any IP (of the right access) will do if available and addr_family is None\n        return ip_addrs[0].address if ip_addrs and not addr_family else None"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_public_ip(self, addr_family=None, *args, **kwargs):\n        return self.get_ip('public', addr_family, *args, **kwargs)", "response": "Get public IP address"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_private_ip(self, addr_family=None, *args, **kwargs):\n        return self.get_ip('private', addr_family, *args, **kwargs)", "response": "Get the private IP address for this class."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _wait_for_state_change(self, target_states, update_interval=10):\n        while self.state not in target_states:\n            if self.state == 'error':\n                raise Exception('server is in error state')\n\n            # update server state every 10s\n            sleep(update_interval)\n            self.populate()", "response": "Blocking wait until the state of the entry is in target_states."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef ensure_started(self):\n        # server is either starting or stopping (or error)\n        if self.state in ['maintenance', 'error']:\n            self._wait_for_state_change(['stopped', 'started'])\n\n        if self.state == 'stopped':\n            self.start()\n            self._wait_for_state_change(['started'])\n\n        if self.state == 'started':\n            return True\n        else:\n            # something went wrong, fail explicitly\n            raise Exception('unknown server state: ' + self.state)", "response": "Start a server and waits until it is fully started."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nstopping a server and its storages.", "response": "def stop_and_destroy(self, sync=True):\n        \"\"\"\n        Destroy a server and its storages. Stops the server before destroying.\n\n        Syncs the server state from the API, use sync=False to disable.\n        \"\"\"\n        def _self_destruct():\n            \"\"\"destroy the server and all storages attached to it.\"\"\"\n\n            # try_it_n_times util is used as a convenience because\n            # Servers and Storages can fluctuate between \"maintenance\" and their\n            # original state due to several different reasons especially when\n            # destroying infrastructure.\n\n            # first destroy server\n            try_it_n_times(operation=self.destroy,\n                           expected_error_codes=['SERVER_STATE_ILLEGAL'],\n                           custom_error='destroying server failed')\n\n            # storages may be deleted instantly after server DELETE\n            for storage in self.storage_devices:\n                try_it_n_times(operation=storage.destroy,\n                               expected_error_codes=['STORAGE_STATE_ILLEGAL'],\n                               custom_error='destroying storage failed')\n\n        if sync:\n            self.populate()\n\n        # server is either starting or stopping (or error)\n        if self.state in ['maintenance', 'error']:\n            self._wait_for_state_change(['stopped', 'started'])\n\n        if self.state == 'started':\n            try_it_n_times(operation=self.stop,\n                           expected_error_codes=['SERVER_STATE_ILLEGAL'],\n                           custom_error='stopping server failed')\n\n            self._wait_for_state_change(['stopped'])\n\n        if self.state == 'stopped':\n            _self_destruct()\n        else:\n            raise Exception('unknown server state: ' + self.state)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef revert(self):\n        if self.filepath:\n            if path.isfile(self.filepath):\n                serialised_file = open(self.filepath, \"r\")\n                try:\n                    self.state = json.load(serialised_file)\n                except ValueError:\n                    print(\"No JSON information could be read from the persistence file - could be empty: %s\" % self.filepath)\n                    self.state = {}\n                finally:\n                    serialised_file.close()\n            else:\n                print(\"The persistence file has not yet been created or does not exist, so the state cannot be read from it yet.\")\n        else:\n            print(\"Filepath to the persistence file is not set. State cannot be read.\")\n            return False", "response": "Revert the state to the version stored on disc."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef sync(self):\n        if self.filepath:\n            serialised_file = open(self.filepath, \"w\")\n            json.dump(self.state, serialised_file)\n            serialised_file.close()\n        else:\n            print(\"Filepath to the persistence file is not set. State cannot be synced to disc.\")", "response": "Synchronise and update the stored state to the in - memory state."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _reset(self, **kwargs):\n        # set object attributes from params\n        for key in kwargs:\n            setattr(self, key, kwargs[key])\n\n        # set defaults (if need be) where the default is not None\n        for attr in self.ATTRIBUTES:\n            if not hasattr(self, attr) and self.ATTRIBUTES[attr] is not None:\n                setattr(self, attr, self.ATTRIBUTES[attr])", "response": "Reset the object attributes to the values in kwargs."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef to_dict(self):\n        return dict(\n            (attr, getattr(self, attr))\n            for attr in self.ATTRIBUTES\n            if hasattr(self, attr)\n        )", "response": "Return a dict that can be serialised to JSON and sent to UpCloud s API."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _require_bucket(self, bucket_name):\n        if not self.exists(bucket_name) and not self.claim_bucket(bucket_name):\n            raise OFSException(\"Invalid bucket: %s\" % bucket_name)\n        return self._get_bucket(bucket_name)", "response": "Try to create the bucket."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef del_stream(self, bucket, label):\n        bucket = self._require_bucket(bucket)\n        key = self._require_key(bucket, label)\n        key.delete()", "response": "Delete the stream for the given bucket and label. Will fail if the bucket or label don t exist."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nauthenticating a HTTP request by filling in Authorization field header.", "response": "def authenticate_request(self, method, bucket='', key='', headers=None):\n        '''Authenticate a HTTP request by filling in Authorization field header.\n\n        :param method: HTTP method (e.g. GET, PUT, POST)\n        :param bucket: name of the bucket.\n        :param key: name of key within bucket.\n        :param headers: dictionary of additional HTTP headers.\n\n        :return: boto.connection.HTTPRequest object with Authorization header\n        filled (NB: will also have a Date field if none before and a User-Agent\n        field will be set to Boto).\n        '''\n        # following is extracted from S3Connection.make_request and the method\n        # it calls: AWSAuthConnection.make_request\n        path = self.conn.calling_format.build_path_base(bucket, key)\n        auth_path = self.conn.calling_format.build_auth_path(bucket, key)\n        http_request = boto.connection.AWSAuthConnection.build_base_http_request(\n                self.conn,\n                method,\n                path,\n                auth_path,\n                {},\n                headers\n                )\n        http_request.authorize(connection=self.conn)\n        return http_request"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_resources_to_check(client_site_url, apikey):\n    url = client_site_url + u\"deadoralive/get_resources_to_check\"\n    response = requests.get(url, headers=dict(Authorization=apikey))\n    if not response.ok:\n        raise CouldNotGetResourceIDsError(\n            u\"Couldn't get resource IDs to check: {code} {reason}\".format(\n                code=response.status_code, reason=response.reason))\n    return response.json()", "response": "Get a list of resource IDs to check for broken links."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the URL for the given resource ID.", "response": "def get_url_for_id(client_site_url, apikey, resource_id):\n    \"\"\"Return the URL for the given resource ID.\n\n    Contacts the client site's API to get the URL for the ID and returns it.\n\n    :raises CouldNotGetURLError: if getting the URL fails for any reason\n\n    \"\"\"\n    # TODO: Handle invalid responses from the client site.\n    url = client_site_url + u\"deadoralive/get_url_for_resource_id\"\n    params = {\"resource_id\": resource_id}\n    response = requests.get(url, headers=dict(Authorization=apikey),\n                            params=params)\n    if not response.ok:\n        raise CouldNotGetURLError(\n            u\"Couldn't get URL for resource {id}: {code} {reason}\".format(\n                id=resource_id, code=response.status_code,\n                reason=response.reason))\n\n    return response.json()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncheck whether the given URL is dead or alive.", "response": "def check_url(url):\n    \"\"\"Check whether the given URL is dead or alive.\n\n    Returns a dict with four keys:\n\n        \"url\": The URL that was checked (string)\n        \"alive\": Whether the URL was working, True or False\n        \"status\": The HTTP status code of the response from the URL,\n            e.g. 200, 401, 500 (int)\n        \"reason\": The reason for the success or failure of the check,\n            e.g. \"OK\", \"Unauthorized\", \"Internal Server Error\" (string)\n\n    The \"status\" may be None if we did not get a valid HTTP response,\n    e.g. in the event of a timeout, DNS failure or invalid HTTP response.\n\n    The \"reason\" will always be a string, but may be a requests library\n    exception string rather than an HTTP reason string if we did not get a valid\n    HTTP response.\n\n    \"\"\"\n    result = {\"url\": url}\n    try:\n        response = requests.get(url)\n        result[\"status\"] = response.status_code\n        result[\"reason\"] = response.reason\n        response.raise_for_status()  # Raise if status_code is not OK.\n        result[\"alive\"] = True\n    except AttributeError as err:\n        if err.message == \"'NoneType' object has no attribute 'encode'\":\n            # requests seems to throw these for some invalid URLs.\n            result[\"alive\"] = False\n            result[\"reason\"] = \"Invalid URL\"\n            result[\"status\"] = None\n        else:\n            raise\n    except requests.exceptions.RequestException as err:\n        result[\"alive\"] = False\n        if \"reason\" not in result:\n            result[\"reason\"] = str(err)\n        if \"status\" not in result:\n            # This can happen if the response is invalid HTTP, if we get a DNS\n            # failure, or a timeout, etc.\n            result[\"status\"] = None\n\n    # We should always have these four fields in the result.\n    assert \"url\" in result\n    assert result.get(\"alive\") in (True, False)\n    assert \"status\" in result\n    assert \"reason\" in result\n\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\npost the given link check result to the client site.", "response": "def upsert_result(client_site_url, apikey, resource_id, result):\n    \"\"\"Post the given link check result to the client site.\"\"\"\n\n    # TODO: Handle exceptions and unexpected results.\n    url = client_site_url + u\"deadoralive/upsert\"\n    params = result.copy()\n    params[\"resource_id\"] = resource_id\n    requests.post(url, headers=dict(Authorization=apikey), params=params)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_check_and_report(client_site_url, apikey, get_resource_ids_to_check,\n                         get_url_for_id, check_url, upsert_result):\n    \"\"\"Get links from the client site, check them, and post the results back.\n\n    Get resource IDs from the client site, get the URL for each resource ID from\n    the client site, check each URL, and post the results back to the client\n    site.\n\n    This function can be called repeatedly to keep on getting more links from\n    the client site and checking them.\n\n    The functions that this function calls to carry out the various tasks are\n    taken as parameters to this function for testing purposes - it makes it\n    easy for tests to pass in mock functions. It also decouples the code nicely.\n\n    :param client_site_url: the base URL of the client site\n    :type client_site_url: string\n\n    :param apikey: the API key to use when making requests to the client site\n    :type apikey: string or None\n\n    :param get_resource_ids_to_check: The function to call to get the list of\n        resource IDs to be checked from the client site. See\n        get_resource_ids_to_check() above for the interface that this function\n        should implement.\n    :type get_resource_ids_to_check: callable\n\n    :param get_url_for_id: The function to call to get the URL for a given\n        resource ID from the client site. See get_url_for_id() above for the\n        interface that this function should implement.\n    :type get_url_for_id: callable\n\n    :param check_url: The function to call to check whether a URL is dead or\n        alive. See check_url() above for the interface that this function\n        should implement.\n    :type check_url: callable\n\n    :param upsert_result: The function to call to post a link check result to\n        the client site. See upsert_result() above for the interface that this\n        function should implement.\n    :type upsert_result: callable\n\n    \"\"\"\n    logger = _get_logger()\n    resource_ids = get_resource_ids_to_check(client_site_url, apikey)\n    for resource_id in resource_ids:\n        try:\n            url = get_url_for_id(client_site_url, apikey, resource_id)\n        except CouldNotGetURLError:\n            logger.info(u\"This link checker was not authorized to access \"\n                        \"resource {0}, skipping.\".format(resource_id))\n            continue\n        result = check_url(url)\n        status = result[\"status\"]\n        reason = result[\"reason\"]\n        if result[\"alive\"]:\n            logger.info(u\"Checking URL {0} of resource {1} succeeded with \"\n                        \"status {2}:\".format(url, resource_id, status))\n        else:\n            logger.info(u\"Checking URL {0} of resource {1} failed with error \"\n                        \"{2}:\".format(url, resource_id, reason))\n        upsert_result(client_site_url, apikey, resource_id=resource_id,\n                      result=result)", "response": "This function is used to get links from the client site check them and post the results back to the client site."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn buffered bytes without advancing the position.", "response": "def peek(self, n=1):\n        \"\"\"Returns buffered bytes without advancing the position.\"\"\"\n        if n > len(self._readbuffer) - self._offset:\n            chunk = self.read(n)\n            self._offset -= len(chunk)\n\n        # Return up to 512 bytes to reduce allocation overhead for tight loops.\n        return self._readbuffer[self._offset: self._offset + 512]"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreads and return up to n bytes.", "response": "def read(self, n=-1):\n        \"\"\"Read and return up to n bytes.\n        If the argument is omitted, None, or negative, data is read and returned until EOF is reached..\n        \"\"\"\n\n        buf = b''\n        while n < 0 or n is None or n > len(buf):\n            data = self.read1(n)\n            if len(data) == 0:\n                return buf\n\n            buf += data\n\n        return buf"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nread in the table of contents for the ZIP file.", "response": "def _RealGetContents(self):\n        \"\"\"Read in the table of contents for the ZIP file.\"\"\"\n        fp = self.fp\n        endrec = _EndRecData(fp)\n        if not endrec:\n            raise BadZipfile(\"File is not a zip file\")\n        if self.debug > 1:\n            print(endrec)\n        size_cd = endrec[_ECD_SIZE]             # bytes in central directory\n        offset_cd = endrec[_ECD_OFFSET]         # offset of central directory\n        self.comment = endrec[_ECD_COMMENT]     # archive comment\n\n        # \"concat\" is zero, unless zip was concatenated to another file\n        concat = endrec[_ECD_LOCATION] - size_cd - offset_cd\n        if endrec[_ECD_SIGNATURE] == stringEndArchive64:\n            # If Zip64 extension structures are present, account for them\n            concat -= (sizeEndCentDir64 + sizeEndCentDir64Locator)\n\n        if self.debug > 2:\n            inferred = concat + offset_cd\n            print(\"given, inferred, offset\", offset_cd, inferred, concat)\n        # self.start_dir:  Position of start of central directory\n        self.start_dir = offset_cd + concat\n        fp.seek(self.start_dir, 0)\n        data = fp.read(size_cd)\n        fp = cStringIO.StringIO(data)\n        total = 0\n        while total < size_cd:\n            centdir = fp.read(sizeCentralDir)\n            if centdir[0:4] != stringCentralDir:\n                raise BadZipfile(\"Bad magic number for central directory\")\n            centdir = struct.unpack(structCentralDir, centdir)\n            if self.debug > 2:\n                print(centdir)\n            filename = fp.read(centdir[_CD_FILENAME_LENGTH])\n            # Create ZipInfo instance to store file information\n            x = ZipInfo(filename)\n            x.extra = fp.read(centdir[_CD_EXTRA_FIELD_LENGTH])\n            x.comment = fp.read(centdir[_CD_COMMENT_LENGTH])\n            x.header_offset = centdir[_CD_LOCAL_HEADER_OFFSET]\n            (x.create_version, x.create_system, x.extract_version, x.reserved,\n                x.flag_bits, x.compress_type, t, d,\n                x.CRC, x.compress_size, x.file_size) = centdir[1:12]\n            x.volume, x.internal_attr, x.external_attr = centdir[15:18]\n            # Convert date/time code to (year, month, day, hour, min, sec)\n            x._raw_time = t\n            x.date_time = ( (d>>9)+1980, (d>>5)&0xF, d&0x1F,\n                                     t>>11, (t>>5)&0x3F, (t&0x1F) * 2 )\n\n            x._decodeExtra()\n            x.header_offset = x.header_offset + concat\n            x.filename = x._decodeFilename()\n            self.filelist.append(x)\n            self.NameToInfo[x.filename] = x\n\n            # update total bytes read from central directory\n            total = (total + sizeCentralDir + centdir[_CD_FILENAME_LENGTH]\n                     + centdir[_CD_EXTRA_FIELD_LENGTH]\n                     + centdir[_CD_COMMENT_LENGTH])\n\n            if self.debug > 2:\n                print(\"total\", total)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nopen a new file - like object for the given name.", "response": "def open(self, name, mode=\"r\", pwd=None):\n        \"\"\"Return file-like object for 'name'.\"\"\"\n        if mode not in (\"r\", \"U\", \"rU\"):\n            raise RuntimeError('open() requires mode \"r\", \"U\", or \"rU\"')\n        if not self.fp:\n            raise RuntimeError(\n                \"Attempt to read ZIP archive that was already closed\"\n            )\n\n        # Only open a new file for instances where we were not\n        # given a file object in the constructor\n        if self._filePassed:\n            zef_file = self.fp\n        else:\n            zef_file = open(self.filename, 'rb')\n\n        # Make sure we have an info object\n        if isinstance(name, ZipInfo):\n            # 'name' is already an info object\n            zinfo = name\n        else:\n            # Get info object for name\n            zinfo = self.getinfo(name)\n\n        zef_file.seek(zinfo.header_offset, 0)\n\n        # Skip the file header:\n        fheader = zef_file.read(sizeFileHeader)\n        if fheader[0:4] != stringFileHeader:\n            raise BadZipfile(\"Bad magic number for file header\")\n\n        fheader = struct.unpack(structFileHeader, fheader)\n        fname = zef_file.read(fheader[_FH_FILENAME_LENGTH])\n        if fheader[_FH_EXTRA_FIELD_LENGTH]:\n            zef_file.read(fheader[_FH_EXTRA_FIELD_LENGTH])\n\n        if fname != zinfo.orig_filename.encode('utf-8'):\n            raise BadZipfile(\n                'File name in directory \"%s\" and header \"%s\" differ.' % (\n                    zinfo.orig_filename, fname)\n            )\n\n        # check for encrypted flag & handle password\n        is_encrypted = zinfo.flag_bits & 0x1\n        zd = None\n        if is_encrypted:\n            if not pwd:\n                pwd = self.pwd\n            if not pwd:\n                raise RuntimeError(\"File %s is encrypted, \" \\\n                      \"password required for extraction\" % name)\n\n            zd = _ZipDecrypter(pwd)\n            # The first 12 bytes in the cypher stream is an encryption header\n            #  used to strengthen the algorithm. The first 11 bytes are\n            #  completely random, while the 12th contains the MSB of the CRC,\n            #  or the MSB of the file time depending on the header type\n            #  and is used to check the correctness of the password.\n            bytes = zef_file.read(12)\n            h = map(zd, bytes[0:12])\n            if zinfo.flag_bits & 0x8:\n                # compare against the file type from extended local headers\n                check_byte = (zinfo._raw_time >> 8) & 0xff\n            else:\n                # compare against the CRC otherwise\n                check_byte = (zinfo.CRC >> 24) & 0xff\n            if ord(h[11]) != check_byte:\n                raise RuntimeError(\"Bad password for file\", name)\n\n        return  ZipExtFile(zef_file, mode, zinfo, zd)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nremoving a member from the archive.", "response": "def remove(self, member):\n        \"\"\"Remove a member from the archive.\"\"\"\n        # Make sure we have an info object\n        if isinstance(member, ZipInfo):\n            # 'member' is already an info object\n            zinfo = member\n        else:\n            # Get info object for name\n            zinfo = self.getinfo(member)\n\n        # compute the location of the file data in the local file header,\n        # by adding the lengths of the records before it\n        zlen = len(zinfo.FileHeader()) + zinfo.compress_size\n        fileidx = self.filelist.index(zinfo)\n        fileofs = sum(\n            [len(self.filelist[f].FileHeader()) + self.filelist[f].compress_size\n            for f in xrange(0, fileidx)]\n            )\n\n        self.fp.seek(fileofs + zlen)\n        after = self.fp.read()\n        self.fp.seek(fileofs)\n        self.fp.write(after)\n        self.fp.seek(-zlen, 2)\n        self.fp.truncate()\n\n        self._didModify = True\n        self.filelist.remove(zinfo)\n        del self.NameToInfo[member]"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _get_codename(self, pathname, basename):\n        file_py  = pathname + \".py\"\n        file_pyc = pathname + \".pyc\"\n        file_pyo = pathname + \".pyo\"\n        if os.path.isfile(file_pyo) and \\\n                            os.stat(file_pyo).st_mtime >= os.stat(file_py).st_mtime:\n            fname = file_pyo    # Use .pyo file\n        elif not os.path.isfile(file_pyc) or \\\n             os.stat(file_pyc).st_mtime < os.stat(file_py).st_mtime:\n            import py_compile\n            if self.debug:\n                print(\"Compiling\", file_py)\n            try:\n                py_compile.compile(file_py, file_pyc, None, True)\n            except py_compile.PyCompileError as err:\n                print(err.msg)\n            fname = file_pyc\n        else:\n            fname = file_pyc\n        archivename = os.path.split(fname)[1]\n        if basename:\n            archivename = \"%s/%s\" % (basename, archivename)\n        return (fname, archivename)", "response": "Returns the correct filename and archivename for the path."}
