{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef on_button_release(self, event):\n        self.queue_draw(self.view)\n        x0, y0, x1, y1 = self.x0, self.y0, self.x1, self.y1\n        rectangle = (min(x0, x1), min(y0, y1), abs(x1 - x0), abs(y1 - y0))\n        selected_items = self.view.get_items_in_rectangle(rectangle, intersect=False)\n        self.view.handle_new_selection(selected_items)\n\n        return True", "response": "Select or deselect rubber banded groups of items\n        "}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nhandling button press events.", "response": "def on_button_press(self, event):\n        \"\"\"Handle button press events.\n\n        If the (mouse) button is pressed on top of a Handle (item.Handle), that handle is grabbed and can be\n        dragged around.\n        \"\"\"\n        if not event.get_button()[1] == 1:  # left mouse button\n            return False\n        view = self.view\n\n        if isinstance(view.hovered_item, StateView):\n            distance = view.hovered_item.border_width / 2.\n            item, handle = HandleFinder(view.hovered_item, view).get_handle_at_point((event.x, event.y), distance)\n        else:\n            item, handle = HandleFinder(view.hovered_item, view).get_handle_at_point((event.x, event.y))\n\n        if not handle:\n            return False\n\n        # Only move ports when the MOVE_PORT_MODIFIER key is pressed\n        if isinstance(item, (StateView, PortView)) and \\\n            handle in [port.handle for port in item.get_all_ports()] and \\\n                not (event.get_state()[1] & constants.MOVE_PORT_MODIFIER):\n            return False\n\n        # Do not move from/to handles of connections (only their waypoints)\n        if isinstance(item, ConnectionView) and handle in item.end_handles(include_waypoints=True):\n            return False\n\n        if handle:\n            view.hovered_item = item\n\n            self.motion_handle = None\n\n            self.grab_handle(item, handle)\n\n            return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _set_motion_handle(self, event):\n        item = self.grabbed_item\n        handle = self.grabbed_handle\n        pos = event.x, event.y\n        self.motion_handle = HandleInMotion(item, handle, self.view)\n        self.motion_handle.GLUE_DISTANCE = self._parent_state_v.border_width\n        self.motion_handle.start_move(pos)", "response": "Sets the motion handle to currently grabbed handle\n       "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating a temporary connection view based on the current state and parent state.", "response": "def _create_temporary_connection(self):\n        \"\"\"Creates a placeholder connection view\n\n        :return: New placeholder connection\n        :rtype: rafcon.gui.mygaphas.items.connection.ConnectionPlaceholderView\n        \"\"\"\n        if self._is_transition:\n            self._connection_v = TransitionPlaceholderView(self._parent_state_v.hierarchy_level)\n        else:\n            self._connection_v = DataFlowPlaceholderView(self._parent_state_v.hierarchy_level)\n        self.view.canvas.add(self._connection_v, self._parent_state_v)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _handle_temporary_connection(self, old_sink, new_sink, of_target=True):\n\n        def sink_set_and_differs(sink_a, sink_b):\n            if not sink_a:\n                return False\n            if not sink_b:\n                return True\n            if sink_a.port != sink_b.port:\n                return True\n            return False\n\n        if sink_set_and_differs(old_sink, new_sink):\n            sink_port_v = old_sink.port.port_v\n            self._disconnect_temporarily(sink_port_v, target=of_target)\n\n        if sink_set_and_differs(new_sink, old_sink):\n            sink_port_v = new_sink.port.port_v\n            self._connect_temporarily(sink_port_v, target=of_target)", "response": "Connect connection to new_sink and return the new_sink s entry ID."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _connect_temporarily(self, port_v, target=True):\n        if target:\n            handle = self._connection_v.to_handle()\n        else:\n            handle = self._connection_v.from_handle()\n        port_v.add_connected_handle(handle, self._connection_v, moving=True)\n        port_v.tmp_connect(handle, self._connection_v)\n        self._connection_v.set_port_for_handle(port_v, handle)\n        # Redraw state of port to make hover state visible\n        self._redraw_port(port_v)", "response": "Connect to the current connection and the given port"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nremoving a connection between the current connection and the given port", "response": "def _disconnect_temporarily(self, port_v, target=True):\n        \"\"\"Removes a connection between the current connection and the given port\n\n        :param rafcon.gui.mygaphas.items.ports.PortView port_v: The port that was connected\n        :param bool target: Whether the connection origin or target should be disconnected\n        \"\"\"\n        if target:\n            handle = self._connection_v.to_handle()\n        else:\n            handle = self._connection_v.from_handle()\n        port_v.remove_connected_handle(handle)\n        port_v.tmp_disconnect()\n        self._connection_v.reset_port_for_handle(handle)\n        # Redraw state of port to make hover state visible\n        self._redraw_port(port_v)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nhandle button press events.", "response": "def on_button_press(self, event):\n        \"\"\"Handle button press events.\n\n        If the (mouse) button is pressed on top of a Handle (item.Handle), that handle is grabbed and can be\n        dragged around.\n        \"\"\"\n        if not event.get_button()[1] == 1:  # left mouse button\n            return False\n        view = self.view\n\n        item, handle = HandleFinder(view.hovered_item, view).get_handle_at_point((event.x, event.y))\n\n        if not handle:  # Require a handle\n            return False\n\n        # Connection handle must belong to a port and the MOVE_PORT_MODIFIER must not be pressed\n        if not isinstance(item, StateView) or handle not in [port.handle for port in item.get_all_ports()] or (\n                    event.get_state()[1] & constants.MOVE_PORT_MODIFIER):\n            return False\n\n        for port in item.get_all_ports():\n            if port.handle is handle:\n                self._start_port_v = port\n                if port in item.get_logic_ports():\n                    self._is_transition = True\n                if port is item.income or isinstance(port, InputPortView) or port in item.scoped_variables:\n                    self._parent_state_v = port.parent\n                elif port.parent.parent:\n                    self._parent_state_v = port.parent.parent\n                else:  # Outgoing port of the root state was clicked on, no connection can be drawn here\n                    self._parent_state_v = None\n\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef on_button_press(self, event):\n        if not event.get_button()[1] == 1:  # left mouse button\n            return False\n        view = self.view\n\n        item, handle = HandleFinder(view.hovered_item, view).get_handle_at_point((event.x, event.y))\n\n        # Handle must be the end handle of a connection\n        if not handle or not isinstance(item, ConnectionView) or handle not in item.end_handles():\n            return False\n\n        if handle is item.from_handle():\n            self._start_port_v = item.from_port\n        else:\n            self._start_port_v = item.to_port\n\n        self._parent_state_v = item.parent\n        self._end_handle = handle\n        if isinstance(item, TransitionView):\n            self._is_transition = True\n        self._connection_v = item\n\n        return True", "response": "Handle button press events."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef register_view(self, view):\n        super(ToolBarController, self).register_view(view)\n        self.view['button_new'].connect('clicked', self.on_button_new_clicked)\n        self.view['button_open'].connect('clicked', self.on_button_open_clicked)\n        self.view['button_save'].connect('clicked', self.on_button_save_clicked)\n        self.view['button_refresh'].connect('clicked', self.on_button_refresh_clicked)\n        self.view['button_refresh_selected'].connect('clicked', self.on_button_refresh_selected_clicked)\n        self.view['button_refresh_libs'].connect('clicked', self.on_button_refresh_libs_clicked)\n        self.view['button_bake_state_machine'].connect('clicked', self.on_button_bake_state_machine_clicked)", "response": "Called when the View was registered"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ninitializes the library manager.", "response": "def initialize(self):\n        \"\"\"Initializes the library manager\n\n        It searches through all library paths given in the config file for libraries, and loads the states.\n\n        This cannot be done in the __init__ function as the library_manager can be compiled and executed by\n        singleton.py before the state*.pys are loaded\n        \"\"\"\n        logger.debug(\"Initializing LibraryManager: Loading libraries ... \")\n        self._libraries = {}\n        self._library_root_paths = {}\n        self._replaced_libraries = {}\n        self._skipped_states = []\n        self._skipped_library_roots = []\n\n        # 1. Load libraries from config.yaml\n        for library_root_key, library_root_path in config.global_config.get_config_value(\"LIBRARY_PATHS\").items():\n            library_root_path = self._clean_path(library_root_path)\n            if os.path.exists(library_root_path):\n                logger.debug(\"Adding library root key '{0}' from path '{1}'\".format(\n                    library_root_key, library_root_path))\n                self._load_libraries_from_root_path(library_root_key, library_root_path)\n            else:\n                logger.warning(\"Configured path for library root key '{}' does not exist: {}\".format(\n                    library_root_key, library_root_path))\n\n        # 2. Load libraries from RAFCON_LIBRARY_PATH\n        library_path_env = os.environ.get('RAFCON_LIBRARY_PATH', '')\n        library_paths = set(library_path_env.split(os.pathsep))\n        for library_root_path in library_paths:\n            if not library_root_path:\n                continue\n            library_root_path = self._clean_path(library_root_path)\n            if not os.path.exists(library_root_path):\n                logger.warning(\"The library specified in RAFCON_LIBRARY_PATH does not exist: {}\".format(library_root_path))\n                continue\n            _, library_root_key = os.path.split(library_root_path)\n            if library_root_key in self._libraries:\n                if os.path.realpath(self._library_root_paths[library_root_key]) == os.path.realpath(library_root_path):\n                    logger.info(\"The library root key '{}' and root path '{}' exists multiple times in your environment\"\n                                \" and will be skipped.\".format(library_root_key, library_root_path))\n                else:\n                    logger.warning(\"The library '{}' is already existing and will be overridden with '{}'\".format(\n                        library_root_key, library_root_path))\n                    self._load_libraries_from_root_path(library_root_key, library_root_path)\n            else:\n                self._load_libraries_from_root_path(library_root_key, library_root_path)\n            logger.debug(\"Adding library '{1}' from {0}\".format(library_root_path, library_root_key))\n\n        self._libraries = OrderedDict(sorted(self._libraries.items()))\n        logger.debug(\"Initialization of LibraryManager done\")"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _clean_path(path):\n        path = path.replace('\"', '')\n        path = path.replace(\"'\", '')\n        # Replace ~ with /home/user\n        path = os.path.expanduser(path)\n        # Replace environment variables\n        path = os.path.expandvars(path)\n        # If the path is relative, assume it is relative to the config file directory\n        if not os.path.isabs(path):\n            path = os.path.join(config.global_config.path, path)\n        # Clean path, e.g. replace /./ with /\n        path = os.path.abspath(path)\n        # Eliminate symbolic links\n        path = os.path.realpath(path)\n        return path", "response": "Create a fully fissile absolute system path with no symbolic links and environment variables"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nfinds library_os_path of library This function retrieves the file system library_os_path of a library specified by a library_path and a library_name. In case the library does not exist any more at its original location, the user has to specify an alternative location. :param str library_path: The library_path of the library, that must be relative and within a library_root_path given in the config.yaml by LIBRARY_PATHS :param str library_name: The name of the library :param bool allow_user_interaction: Whether the user may be asked to specify library location :return: library_os_path within filesystem, library_path, library_name :rtype: str, str, str :raises rafcon.core.custom_exceptions.LibraryNotFoundException: if the cannot be found", "response": "def get_os_path_to_library(self, library_path, library_name, allow_user_interaction=True):\n        \"\"\"Find library_os_path of library\n\n        This function retrieves the file system library_os_path of a library specified by a library_path and a \n        library_name. In case the library does not exist any more at its original location, the user has to specify \n        an alternative location.\n\n        :param str library_path: The library_path of the library, that must be relative and within a library_root_path \n                             given in the config.yaml by LIBRARY_PATHS\n        :param str library_name: The name of the library\n        :param bool allow_user_interaction: Whether the user may be asked to specify library location\n        :return: library_os_path within filesystem, library_path, library_name\n        :rtype: str, str, str\n        :raises rafcon.core.custom_exceptions.LibraryNotFoundException: if the cannot be found\n        \"\"\"\n        original_path_and_name = os.path.join(library_path, library_name)\n        library_path_root = library_path.split(os.sep)[0]\n\n        if library_path.split(os.sep) and \\\n                (library_path.startswith(os.sep) or library_path.endswith(os.sep) or os.sep + os.sep in library_path):\n            raise LibraryNotFoundException(\"A library_path is not considered to start or end with {2} or to have two \"\n                                           \"path separators {2}{2} in a row like '{0}' with library name {1}\"\n                                           \"\".format(library_path, library_name, os.sep))\n\n        if not self._library_root_paths:\n            raise LibraryNotFoundException(\"There are no libraries registered\")\n\n        # skip already skipped states\n        if original_path_and_name in self._skipped_states or library_path_root in self._skipped_library_roots:\n            # if an already skipped state shall be loaded again, directly raise the exception to jump over this state\n            raise LibraryNotFoundException(\"Library '{0}' not found in subfolder {1}\".format(library_name,\n                                                                                             library_path))\n\n        # replace already replaced states\n        if original_path_and_name in self._replaced_libraries:\n            new_library_os_path = self._replaced_libraries[original_path_and_name][0]\n            new_library_path = self._replaced_libraries[original_path_and_name][1]\n\n            # only show debug message if a state is automatically replaced by the appropriate library state\n            # chosen by the user before\n            if not self._replaced_libraries[original_path_and_name][2]:\n                logger.debug(\"The library with library_path \\\"{0}\\\" and name \\\"{1}\\\" \"\n                             \"is automatically replaced by the library \"\n                             \"with file system library_os_path \\\"{2}\\\" and library_path \\\"{3}\\\"\"\n                             \"\".format(library_path, library_name, new_library_os_path, new_library_path))\n            return new_library_os_path, new_library_path, library_name\n\n        # a boolean to indicate if a state was regularly found or by the help of the user\n        regularly_found = True\n\n        library_os_path = self._get_library_os_path_from_library_dict_tree(library_path, library_name)\n        while library_os_path is None:  # until the library is found or the user aborts\n\n            regularly_found = False\n            new_library_os_path = None\n            if allow_user_interaction:\n                notice = \"Cannot find library '{0}' in library_path '{1}' in any of the library root paths. \" \\\n                         \"Please check your library root paths configuration in config.yaml \" \\\n                         \"LIBRARY_PATHS and environment variable RAFCON_LIBRARY_PATH. \" \\\n                         \"If your library_path is correct and the library was moved, please \" \\\n                         \"select the new root/library_os_path folder of the library which should be situated within a \"\\\n                         \"loaded library_root_path. If not, please abort.\".format(library_name, library_path)\n                interface.show_notice_func(notice)\n                new_library_os_path = interface.open_folder_func(\"Select root folder for library name '{0}'\"\n                                                                 \"\".format(original_path_and_name))\n            if new_library_os_path is None:\n                # User clicked cancel => cancel library search\n                # If the library root path is existent (e.g. \"generic\") and only the specific library state is not (\n                # e.g. \"generic/wait\", then the state is added to the skipped states.\n                # If the library root path is not existing, we ignore the whole library, preventing the user from\n                # endless dialogs for each missing library state.\n                if library_path_root not in self.libraries:\n                    self._skipped_library_roots.append(library_path_root)\n                else:\n                    self._skipped_states.append(original_path_and_name)\n                raise LibraryNotFoundException(\"Library '{0}' not found in sub-folder {1}\".format(library_name,\n                                                                                                  library_path))\n\n            if not os.path.exists(new_library_os_path):\n                logger.error('Specified library_os_path does not exist')\n                continue\n\n            # check if valid library_path and library_name can be created\n            library_path, library_name = self.get_library_path_and_name_for_os_path(new_library_os_path)\n            if library_path is None:\n                logger.error(\"Specified library_os_path not within loaded library_root_path list or your config.yaml \"\n                             \"file LIBRARY_PATHS or in the list of paths in environment variable RAFCON_LIBRARY_PATH\")\n                continue  # Allow the user to change the directory\n\n            # verification if library is also in library tree\n            library_os_path = self._get_library_os_path_from_library_dict_tree(library_path, library_name)\n            if library_os_path is not None:\n                assert library_os_path == new_library_os_path\n\n        # save the replacement in order that for a future occurrence the correct library_os_path can be used,\n        # without asking the user for the correct library_os_path\n        self._replaced_libraries[original_path_and_name] = (library_os_path, library_path, regularly_found)\n        return library_os_path, library_path, library_name"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _get_library_os_path_from_library_dict_tree(self, library_path, library_name):\n        if library_path is None or library_name is None:\n            return None\n        path_list = library_path.split(os.sep)\n        target_lib_dict = self.libraries\n        # go down the path to the correct library\n        for path_element in path_list:\n            if path_element not in target_lib_dict:  # Library cannot be found\n                target_lib_dict = None\n                break\n            target_lib_dict = target_lib_dict[path_element]\n        return None if target_lib_dict is None or library_name not in target_lib_dict else target_lib_dict[library_name]", "response": "Hand verified library os path from libraries dictionary tree."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _get_library_root_key_for_os_path(self, path):\n        path = os.path.realpath(path)\n        library_root_key = None\n        for library_root_key, library_root_path in self._library_root_paths.items():\n            rel_path = os.path.relpath(path, library_root_path)\n            if rel_path.startswith('..'):\n                library_root_key = None\n                continue\n            else:\n                break\n        return library_root_key", "response": "Return library root key if path is within library root paths."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_library_path_and_name_for_os_path(self, path):\n        library_path = None\n        library_name = None\n        library_root_key = self._get_library_root_key_for_os_path(path)\n        if library_root_key is not None:\n            library_root_path = self._library_root_paths[library_root_key]\n            path_elements_without_library_root = path[len(library_root_path)+1:].split(os.sep)\n            library_name = path_elements_without_library_root[-1]\n            sub_library_path = ''\n            if len(path_elements_without_library_root[:-1]):\n                sub_library_path = os.sep + os.sep.join(path_elements_without_library_root[:-1])\n            library_path = library_root_key + sub_library_path\n        return library_path, library_name", "response": "Generate valid library_path and library_name for given os path."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngenerating a Library instance from within libraries dictionary tree.", "response": "def get_library_instance(self, library_path, library_name):\n        \"\"\"Generate a Library instance from within libraries dictionary tree.\"\"\"\n        if self.is_library_in_libraries(library_path, library_name):\n            from rafcon.core.states.library_state import LibraryState\n            return LibraryState(library_path, library_name, \"0.1\")\n        else:\n            logger.warning(\"Library manager will not create a library instance which is not in the mounted libraries.\")"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nremoving library from hard disk.", "response": "def remove_library_from_file_system(self, library_path, library_name):\n        \"\"\"Remove library from hard disk.\"\"\"\n        library_file_system_path = self.get_os_path_to_library(library_path, library_name)[0]\n        shutil.rmtree(library_file_system_path)\n        self.refresh_libraries()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef buses_of_vlvl(network, voltage_level):\n\n    mask = network.buses.v_nom.isin(voltage_level)\n    df = network.buses[mask]\n\n    return df.index", "response": "Get bus - ids of given voltage level."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a list of bus - ids connected to a given voltage level.", "response": "def buses_grid_linked(network, voltage_level):\n    \"\"\" Get bus-ids of a given voltage level connected to the grid.\n\n    Parameters\n    ----------\n    network : :class:`pypsa.Network\n        Overall container of PyPSA\n    voltage_level: list\n\n    Returns\n    -------\n    list\n        List containing bus-ids.\n    \"\"\"\n\n    mask = ((network.buses.index.isin(network.lines.bus0) |\n             (network.buses.index.isin(network.lines.bus1))) &\n            (network.buses.v_nom.isin(voltage_level)))\n\n    df = network.buses[mask]\n\n    return df.index"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef geolocation_buses(network, session):\n    if geopandas:\n        # Start db connetion\n        # get renpassG!S scenario data\n\n        RenpassGISRegion = RenpassGisParameterRegion\n\n        # Define regions\n        region_id = ['DE', 'DK', 'FR', 'BE', 'LU', 'AT',\n                     'NO', 'PL', 'CH', 'CZ', 'SE', 'NL']\n\n        query = session.query(RenpassGISRegion.gid,\n                              RenpassGISRegion.u_region_id,\n                              RenpassGISRegion.stat_level,\n                              RenpassGISRegion.geom,\n                              RenpassGISRegion.geom_point)\n\n        # get regions by query and filter\n        Regions = [(gid, u_region_id, stat_level, geoalchemy2.shape.to_shape(\n                 geom), geoalchemy2.shape.to_shape(geom_point))\n                 for gid, u_region_id, stat_level,\n                geom, geom_point in query.filter(RenpassGISRegion.u_region_id.\n                                                 in_(region_id)).all()]\n\n        crs = {'init': 'epsg:4326'}\n        # transform lon lat to shapely Points and create GeoDataFrame\n        points = [Point(xy) for xy in zip(network.buses.x,  network.buses.y)]\n        bus = gpd.GeoDataFrame(network.buses, crs=crs, geometry=points)\n        # Transform Countries Polygons as Regions\n        region = pd.DataFrame(\n                 Regions, columns=['id', 'country', 'stat_level', 'Polygon',\n                                   'Point'])\n        re = gpd.GeoDataFrame(region, crs=crs, geometry=region['Polygon'])\n        # join regions and buses by geometry which intersects\n        busC = gpd.sjoin(bus, re, how='inner', op='intersects')\n        # busC\n        # Drop non used columns\n        busC = busC.drop(['index_right', 'Point', 'id', 'Polygon',\n                       'stat_level', 'geometry'], axis=1)\n        # add busC to eTraGo.buses\n        network.buses['country_code'] = busC['country']\n        network.buses.country_code[network.buses.country_code.isnull()] = 'DE'\n        # close session \n        session.close()\n\n    else:\n\n        buses_by_country(network)\n\n    transborder_lines_0 = network.lines[network.lines['bus0'].isin(\n            network.buses.index[network.buses['country_code'] != 'DE'])].index\n    transborder_lines_1 = network.lines[network.lines['bus1'].isin(\n            network.buses.index[network.buses['country_code']!= 'DE'])].index\n\n    #set country tag for lines\n    network.lines.loc[transborder_lines_0, 'country'] = \\\n        network.buses.loc[network.lines.loc[transborder_lines_0, 'bus0'].\\\n                          values,'country_code'].values\n\n    network.lines.loc[transborder_lines_1, 'country'] = \\\n        network.buses.loc[network.lines.loc[transborder_lines_1, 'bus1'].\\\n                          values,'country_code'].values\n    network.lines['country'].fillna('DE', inplace=True)\n    doubles = list(set(transborder_lines_0.intersection(transborder_lines_1)))\n    for line in doubles:\n        c_bus0 = network.buses.loc[network.lines.loc[line, 'bus0'],\n                                   'country_code']\n        c_bus1 = network.buses.loc[network.lines.loc[line, 'bus1'],\n                                   'country_code']\n        network.lines.loc[line, 'country'] = '{}{}'.format(c_bus0, c_bus1)\n  \n    transborder_links_0 = network.links[network.links['bus0'].isin(\n            network.buses.index[network.buses['country_code']!= 'DE'])].index\n    transborder_links_1 = network.links[network.links['bus1'].isin(\n            network.buses.index[network.buses['country_code'] != 'DE'])].index\n\n    #set country tag for links\n    network.links.loc[transborder_links_0, 'country'] = \\\n        network.buses.loc[network.links.loc[transborder_links_0, 'bus0'].\\\n                          values, 'country_code'].values\n\n    network.links.loc[transborder_links_1, 'country'] = \\\n        network.buses.loc[network.links.loc[transborder_links_1, 'bus1'].\\\n                          values, 'country_code'].values\n    network.links['country'].fillna('DE', inplace=True)\n    doubles = list(set(transborder_links_0.intersection(transborder_links_1)))\n    for link in doubles:\n        c_bus0 = network.buses.loc[\n                network.links.loc[link, 'bus0'], 'country_code']\n        c_bus1 = network.buses.loc[\n                network.links.loc[link, 'bus1'], 'country_code']\n        network.links.loc[link, 'country'] = '{}{}'.format(c_bus0, c_bus1)\n\n    return network", "response": "Get the list of buses that are located in the OEDB."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nfinds buses of foreign countries using coordinates and return them as Pandas Series", "response": "def buses_by_country(network):\n    \"\"\"\n    Find buses of foreign countries using coordinates\n    and return them as Pandas Series\n\n    Parameters\n    ----------\n    network : :class:`pypsa.Network\n        Overall container of PyPSA\n\n    Returns\n    -------\n    foreign_buses: Series containing buses by country\n    \"\"\"\n\n    poland = pd.Series(index=network.\n                       buses[(network.buses['x'] > 17)].index,\n                       data=\"PL\")\n    czech = pd.Series(index=network.\n                      buses[(network.buses['x'] < 17) &\n                            (network.buses['x'] > 15.1)].index,\n                      data=\"CZ\")\n    denmark = pd.Series(index=network.\n                        buses[((network.buses['y'] < 60) &\n                               (network.buses['y'] > 55.2)) |\n                              ((network.buses['x'] > 11.95) &\n                               (network.buses['x'] < 11.97) &\n                               (network.buses['y'] > 54.5))].\n                        index,\n                        data=\"DK\")\n    sweden = pd.Series(index=network.buses[(network.buses['y'] > 60)].index,\n                       data=\"SE\")\n    austria = pd.Series(index=network.\n                        buses[(network.buses['y'] < 47.33) &\n                              (network.buses['x'] > 9) |\n                              ((network.buses['x'] > 9.65) &\n                               (network.buses['x'] < 9.9) &\n                               (network.buses['y'] < 47.5) &\n                               (network.buses['y'] > 47.3)) |\n                              ((network.buses['x'] > 12.14) &\n                               (network.buses['x'] < 12.15) &\n                               (network.buses['y'] > 47.57) &\n                               (network.buses['y'] < 47.58)) |\n                              (network.buses['y'] < 47.6) &\n                              (network.buses['x'] > 14.1)].index,\n                        data=\"AT\")\n    switzerland = pd.Series(index=network.\n                            buses[((network.buses['x'] > 8.1) &\n                                   (network.buses['x'] < 8.3) &\n                                   (network.buses['y'] < 46.8)) |\n                                  ((network.buses['x'] > 7.82) &\n                                   (network.buses['x'] < 7.88) &\n                                   (network.buses['y'] > 47.54) &\n                                   (network.buses['y'] < 47.57)) |\n                                  ((network.buses['x'] > 10.91) &\n                                   (network.buses['x'] < 10.92) &\n                                   (network.buses['y'] > 49.91) &\n                                   (network.buses['y'] < 49.92))].index,\n                            data=\"CH\")\n    netherlands = pd.Series(index=network.\n                            buses[((network.buses['x'] < 6.96) &\n                                   (network.buses['y'] < 53.15) &\n                                   (network.buses['y'] > 53.1)) |\n                                  ((network.buses['x'] < 5.4) &\n                                   (network.buses['y'] > 52.1))].index,\n                            data=\"NL\")\n    luxembourg = pd.Series(index=network.\n                           buses[((network.buses['x'] < 6.15) &\n                                  (network.buses['y'] < 49.91) &\n                                  (network.buses['y'] > 49.65))].index,\n                           data=\"LU\")\n    france = pd.Series(index=network.\n                       buses[(network.buses['x'] < 4.5) |\n                             ((network.buses['x'] > 7.507) &\n                              (network.buses['x'] < 7.508) &\n                              (network.buses['y'] > 47.64) &\n                              (network.buses['y'] < 47.65)) |\n                             ((network.buses['x'] > 6.2) &\n                              (network.buses['x'] < 6.3) &\n                              (network.buses['y'] > 49.1) &\n                              (network.buses['y'] < 49.2)) |\n                             ((network.buses['x'] > 6.7) &\n                              (network.buses['x'] < 6.76) &\n                              (network.buses['y'] > 49.13) &\n                              (network.buses['y'] < 49.16))].index,\n                       data=\"FR\")\n    foreign_buses = pd.Series()\n    foreign_buses = foreign_buses.append([poland, czech, denmark, sweden,\n                                          austria, switzerland,\n                                          netherlands, luxembourg, france])\n    network.buses['country_code'] = foreign_buses[network.buses.index]\n    network.buses['country_code'].fillna('DE', inplace=True)\n\n    return foreign_buses"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nclips foreign bus and transborder lines.", "response": "def clip_foreign(network):\n    \"\"\"\n    Delete all components and timelines located outside of Germany.\n    Add transborder flows divided by country of origin as\n    network.foreign_trade.\n\n    Parameters\n    ----------\n    network : :class:`pypsa.Network\n        Overall container of PyPSA\n\n    Returns\n    -------\n    network : :class:`pypsa.Network\n        Overall container of PyPSA\n    \"\"\"\n\n    # get foreign buses by country\n\n    foreign_buses = network.buses[network.buses.country_code != 'DE']\n\n    network.buses = network.buses.drop(\n        network.buses.loc[foreign_buses.index].index)\n\n    # identify transborder lines (one bus foreign, one bus not) and the country\n    # it is coming from\n    \"\"\"transborder_lines = pd.DataFrame(index=network.lines[\n        ((network.lines['bus0'].isin(network.buses.index) == False) &\n         (network.lines['bus1'].isin(network.buses.index) == True)) |\n        ((network.lines['bus0'].isin(network.buses.index) == True) &\n         (network.lines['bus1'].isin(network.buses.index) == False))].index)\n    transborder_lines['bus0'] = network.lines['bus0']\n    transborder_lines['bus1'] = network.lines['bus1']\n    transborder_lines['country'] = \"\"\n    for i in range(0, len(transborder_lines)):\n        if transborder_lines.iloc[i, 0] in foreign_buses.index:\n            transborder_lines['country'][i] = foreign_buses[str(\n                transborder_lines.iloc[i, 0])]\n        else:\n            transborder_lines['country'][i] = foreign_buses[str(\n                transborder_lines.iloc[i, 1])]\n\n    # identify amount of flows per line and group to get flow per country\n    transborder_flows = network.lines_t.p0[transborder_lines.index]\n    for i in transborder_flows.columns:\n        if network.lines.loc[str(i)]['bus1'] in foreign_buses.index:\n            transborder_flows.loc[:, str(\n                i)] = transborder_flows.loc[:, str(i)]*-1\n\n    network.foreign_trade = transborder_flows.\\\n        groupby(transborder_lines['country'], axis=1).sum()\"\"\"\n\n    # drop foreign components\n    network.lines = network.lines.drop(network.lines[\n        (network.lines['bus0'].isin(network.buses.index) == False) |\n        (network.lines['bus1'].isin(network.buses.index) == False)].index)\n\n    network.links = network.links.drop(network.links[\n        (network.links['bus0'].isin(network.buses.index) == False) |\n        (network.links['bus1'].isin(network.buses.index) == False)].index)\n\n    network.transformers = network.transformers.drop(network.transformers[\n        (network.transformers['bus0'].isin(network.buses.index) == False) |\n        (network.transformers['bus1'].isin(network.\n                                           buses.index) == False)].index)\n    network.generators = network.generators.drop(network.generators[\n        (network.generators['bus'].isin(network.buses.index) == False)].index)\n    network.loads = network.loads.drop(network.loads[\n        (network.loads['bus'].isin(network.buses.index) == False)].index)\n    network.storage_units = network.storage_units.drop(network.storage_units[\n        (network.storage_units['bus'].isin(network.\n                                           buses.index) == False)].index)\n\n    components = ['loads', 'generators', 'lines', 'buses', 'transformers',\n                  'links']\n    for g in components:  # loads_t\n        h = g + '_t'\n        nw = getattr(network, h)  # network.loads_t\n        for i in nw.keys():  # network.loads_t.p\n            cols = [j for j in getattr(\n                nw, i).columns if j not in getattr(network, g).index]\n            for k in cols:\n                del getattr(nw, i)[k]\n\n    return network"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nchanges transmission technology of foreign lines from AC to DC.", "response": "def foreign_links(network):\n    \"\"\"Change transmission technology of foreign lines from AC to DC (links).\n    \n    Parameters\n    ----------\n    network : :class:`pypsa.Network\n        Overall container of PyPSA\n\n    Returns\n    -------\n    network : :class:`pypsa.Network\n        Overall container of PyPSA\n\n    \"\"\"\n    foreign_buses = network.buses[network.buses.country_code != 'DE']\n\n    foreign_lines = network.lines[network.lines.bus0.astype(str).isin(\n            foreign_buses.index) | network.lines.bus1.astype(str).isin(\n            foreign_buses.index)]\n        \n    foreign_links = network.links[network.links.bus0.astype(str).isin(\n            foreign_buses.index) | network.links.bus1.astype(str).isin(\n            foreign_buses.index)]\n    \n    network.links = network.links.drop(\n            network.links.index[network.links.index.isin(foreign_links.index) \n            & network.links.bus0.isin(network.links.bus1) & \n            (network.links.bus0 > network.links.bus1)])\n        \n    foreign_links = network.links[network.links.bus0.astype(str).isin(\n            foreign_buses.index) | network.links.bus1.astype(str).isin(\n            foreign_buses.index)]\n    \n    network.links.loc[foreign_links.index, 'p_min_pu'] = -1\n\n    network.links.loc[foreign_links.index, 'efficiency'] = 1\n        \n    network.import_components_from_dataframe(\n        foreign_lines.loc[:, ['bus0', 'bus1', 'capital_cost', 'length']]\n        .assign(p_nom=foreign_lines.s_nom).assign(p_min_pu=-1)\n        .set_index('N' + foreign_lines.index),\n        'Link')\n\n    network.lines = network.lines.drop(foreign_lines.index)\n\n    return network"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef set_q_foreign_loads(network, cos_phi=1):\n    foreign_buses = network.buses[network.buses.country_code != 'DE']\n\n    network.loads_t['q_set'][network.loads.index[\n        network.loads.bus.astype(str).isin(foreign_buses.index)]] = \\\n        network.loads_t['p_set'][network.loads.index[\n            network.loads.bus.astype(str).isin(\n                foreign_buses.index)]] * math.tan(math.acos(cos_phi))\n\n    network.generators.control[network.generators.control == 'PQ'] = 'PV'\n\n    return network", "response": "Set reative power timeseries of loads in neighbouring countries."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef connected_grid_lines(network, busids):\n\n    mask = network.lines.bus1.isin(busids) |\\\n        network.lines.bus0.isin(busids)\n\n    return network.lines[mask]", "response": "Returns a DataFrame containing the grid lines connected to given buses."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef connected_transformer(network, busids):\n\n    mask = (network.transformers.bus0.isin(busids))\n\n    return network.transformers[mask]", "response": "Returns a DataFrame containing the transformer connected to the given buses."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nimplementing load shedding in existing network to identify load shedding problem problem.", "response": "def load_shedding(network, **kwargs):\n    \"\"\" Implement load shedding in existing network to identify\n    feasibility problems\n    \n    Parameters\n    ----------\n    network : :class:`pypsa.Network\n        Overall container of PyPSA\n    marginal_cost : int\n        Marginal costs for load shedding\n    p_nom : int\n        Installed capacity of load shedding generator\n    Returns\n    -------\n\n    \"\"\"\n\n    marginal_cost_def = 10000  # network.generators.marginal_cost.max()*2\n    p_nom_def = network.loads_t.p_set.max().max()\n\n    marginal_cost = kwargs.get('marginal_cost', marginal_cost_def)\n    p_nom = kwargs.get('p_nom', p_nom_def)\n\n    network.add(\"Carrier\", \"load\")\n    start = network.generators.index.to_series().str.rsplit(\n        ' ').str[0].astype(int).sort_values().max() + 1\n    index = list(range(start, start + len(network.buses.index)))\n    network.import_components_from_dataframe(\n        pd.DataFrame(\n            dict(marginal_cost=marginal_cost,\n                 p_nom=p_nom,\n                 carrier='load shedding',\n                 bus=network.buses.index),\n            index=index),\n        \"Generator\"\n    )\n    return"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nadds missing components to the network with SH scenarios.", "response": "def data_manipulation_sh(network):\n    \"\"\" Adds missing components to run calculations with SH scenarios.\n\n    Parameters\n    ----------\n    network : :class:`pypsa.Network\n        Overall container of PyPSA\n    \n\n    \n    \"\"\"\n    from shapely.geometry import Point, LineString, MultiLineString\n    from geoalchemy2.shape import from_shape, to_shape\n\n    # add connection from Luebeck to Siems\n    new_bus = str(network.buses.index.astype(np.int64).max() + 1)\n    new_trafo = str(network.transformers.index.astype(np.int64).max() + 1)\n    new_line = str(network.lines.index.astype(np.int64).max() + 1)\n    network.add(\"Bus\", new_bus, carrier='AC',\n                v_nom=220, x=10.760835, y=53.909745)\n    network.add(\"Transformer\", new_trafo, bus0=\"25536\",\n                bus1=new_bus, x=1.29960, tap_ratio=1, s_nom=1600)\n    network.add(\"Line\", new_line, bus0=\"26387\",\n                bus1=new_bus, x=0.0001, s_nom=1600)\n    network.lines.loc[new_line, 'cables'] = 3.0\n\n    # bus geom\n    point_bus1 = Point(10.760835, 53.909745)\n    network.buses.set_value(new_bus, 'geom', from_shape(point_bus1, 4326))\n\n    # line geom/topo\n    network.lines.set_value(new_line, 'geom', from_shape(MultiLineString(\n        [LineString([to_shape(network.\n                              buses.geom['26387']), point_bus1])]), 4326))\n    network.lines.set_value(new_line, 'topo', from_shape(LineString(\n        [to_shape(network.buses.geom['26387']), point_bus1]), 4326))\n\n    # trafo geom/topo\n    network.transformers.set_value(new_trafo,\n                                   'geom', from_shape(MultiLineString(\n                                       [LineString(\n                                           [to_shape(network\n                                                     .buses.geom['25536']),\n                                            point_bus1])]), 4326))\n    network.transformers.set_value(new_trafo, 'topo', from_shape(\n        LineString([to_shape(network.buses.geom['25536']), point_bus1]), 4326))\n\n    return"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef results_to_csv(network, args, pf_solution=None):\n\n    path = args['csv_export']\n\n    if path == False:\n        return None\n\n    if not os.path.exists(path):\n        os.makedirs(path, exist_ok=True)\n\n    network.export_to_csv_folder(path)\n    data = pd.read_csv(os.path.join(path, 'network.csv'))\n    data['time'] = network.results['Solver'].Time\n    data = data.apply(_enumerate_row, axis=1)\n    data.to_csv(os.path.join(path, 'network.csv'), index=False)\n\n    with open(os.path.join(path, 'args.json'), 'w') as fp:\n        json.dump(args, fp)\n\n    if not isinstance(pf_solution, type(None)):\n        pf_solution.to_csv(os.path.join(path, 'pf_solution.csv'), index=True)\n\n    if hasattr(network, 'Z'):\n        file = [i for i in os.listdir(\n            path.strip('0123456789')) if i == 'Z.csv']\n        if file:\n            print('Z already calculated')\n        else:\n            network.Z.to_csv(path.strip('0123456789') + '/Z.csv', index=False)\n\n    return", "response": "Function writes the calaculation results to csv - files in the desired directory."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef parallelisation(network, args, group_size, extra_functionality=None):\n\n    \"\"\"\n    Function that splits problem in selected number of \n    snapshot groups and runs optimization successive for each group. \n        \n    Not useful for calculations with storage untis or extension.  \n\n    Parameters\n    ----------\n    network : :class:`pypsa.Network\n        Overall container of PyPSA\n    args: dict\n        Contains calculation settings of appl.py\n\n    Returns\n    -------\n    network : :class:`pypsa.Network\n        Overall container of PyPSA\n    \"\"\"\n\n    print(\"Performing linear OPF, {} snapshot(s) at a time:\".\n          format(group_size))\n    t = time.time()\n\n    for i in range(int((args['end_snapshot'] - args['start_snapshot'] + 1)\n        / group_size)):\n        if i > 0:\n            network.storage_units.state_of_charge_initial = network.\\\n                storage_units_t.state_of_charge.loc[\n                    network.snapshots[group_size * i - 1]]\n        network.lopf(network.snapshots[\n                     group_size * i:group_size * i + group_size],\n                     solver_name=args['solver_name'],\n                     solver_options=args['solver_options'],\n                     extra_functionality=extra_functionality)\n        network.lines.s_nom = network.lines.s_nom_opt\n\n    print(time.time() - t / 60)\n    return", "response": "Function that splits problem in selected number of \n    snapshot groups and runs optimization successive for each group."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef set_slack(network):\n    \n    \"\"\" Function that chosses the bus with the maximum installed power as slack\n\n    Parameters\n    ----------\n    network : :class:`pypsa.Network\n        Overall container of PyPSA\n\n    Returns\n    -------\n    network : :class:`pypsa.Network\n        Overall container of PyPSA\n\n\n\n    \"\"\"\n    \n    old_slack = network.generators.index[network.\n                                         generators.control == 'Slack'][0]\n    # check if old slack was PV or PQ control:\n    if network.generators.p_nom[old_slack] > 50 and network.generators.\\\n            carrier[old_slack] in ('solar', 'wind'):\n        old_control = 'PQ'\n    elif network.generators.p_nom[old_slack] > 50 and network.generators.\\\n            carrier[old_slack] not in ('solar', 'wind'):\n        old_control = 'PV'\n    elif network.generators.p_nom[old_slack] < 50:\n        old_control = 'PQ'\n\n    old_gens = network.generators\n    gens_summed = network.generators_t.p.sum()\n    old_gens['p_summed'] = gens_summed\n    max_gen_buses_index = old_gens.groupby(['bus']).agg(\n        {'p_summed': np.sum}).p_summed.sort_values().index\n\n    for bus_iter in range(1, len(max_gen_buses_index) - 1):\n        if old_gens[(network.\n                     generators['bus'] == max_gen_buses_index[-bus_iter]) &\n                    (network.generators['control'] == 'PV')].empty:\n            continue\n        else:\n            new_slack_bus = max_gen_buses_index[-bus_iter]\n            break\n\n    network.generators = network.generators.drop('p_summed', 1)\n    new_slack_gen = network.generators.\\\n        p_nom[(network.generators['bus'] == new_slack_bus) & (\n            network.generators['control'] == 'PV')].sort_values().index[-1]\n\n    network.generators = network.generators.set_value(\n        old_slack, 'control', old_control)\n    network.generators = network.generators.set_value(\n        new_slack_gen, 'control', 'Slack')\n    \n    return network", "response": "Function that chosses the bus with the maximum installed power as slack\n   "}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef pf_post_lopf(network, args, extra_functionality, add_foreign_lopf):\n\n    \"\"\" Function that prepares and runs non-linar load flow using PyPSA pf. \n    \n    If network has been extendable, a second lopf with reactances adapted to\n    new s_nom is needed. \n    \n    If crossborder lines are DC-links, pf is only applied on german network. \n    Crossborder flows are still considerd due to the active behavior of links.\n    To return a network containing the whole grid, the optimised solution of the\n    foreign components can be added afterwards. \n\n    Parameters\n    ----------\n    network : :class:`pypsa.Network\n        Overall container of PyPSA\n    args: dict\n        Contains calculation settings of appl.py   \n    extra_fuctionality: function or NoneType\n        Adds constraint to optimization (e.g. when applied snapshot clustering)\n    add_foreign_lopf: boolean\n        Choose if foreign results of lopf should be added to the network when\n        foreign lines are DC\n\n    Returns\n    -------\n    pf_solve: pandas.Dataframe\n        Contains information about convergency and calculation time of pf\n        \n    \"\"\"\n    network_pf = network\n\n    # Update x of extended lines and transformers\n    if network_pf.lines.s_nom_extendable.any() or \\\n            network_pf.transformers.s_nom_extendable.any():\n\n        storages_extendable = network_pf.storage_units.p_nom_extendable.copy()\n        lines_extendable = network_pf.lines.s_nom_extendable.copy()\n        links_extendable = network_pf.links.p_nom_extendable.copy()\n        trafos_extendable = network_pf.transformers.s_nom_extendable.copy()\n        \n        storages_p_nom =  network_pf.storage_units.p_nom.copy()\n        lines_s_nom=  network_pf.lines.s_nom.copy()\n        links_p_nom =  network_pf.links.p_nom.copy()\n        trafos_s_nom =  network_pf.transformers.s_nom.copy()\n        \n        network_pf.lines.x[network.lines.s_nom_extendable] = \\\n            network_pf.lines.x * network.lines.s_nom /\\\n            network_pf.lines.s_nom_opt\n\n        network_pf.lines.r[network.lines.s_nom_extendable] = \\\n            network_pf.lines.r * network.lines.s_nom /\\\n            network_pf.lines.s_nom_opt\n\n        network_pf.lines.b[network.lines.s_nom_extendable] = \\\n            network_pf.lines.b * network.lines.s_nom_opt /\\\n            network_pf.lines.s_nom\n\n        network_pf.lines.g[network.lines.s_nom_extendable] = \\\n            network_pf.lines.g * network.lines.s_nom_opt /\\\n            network_pf.lines.s_nom\n\n        network_pf.transformers.x[network.transformers.s_nom_extendable] = \\\n            network_pf.transformers.x * network.transformers.s_nom / \\\n            network_pf.transformers.s_nom_opt\n\n        network_pf.lines.s_nom_extendable = False\n        network_pf.transformers.s_nom_extendable = False\n        network_pf.storage_units.p_nom_extendable = False\n        network_pf.links.p_nom_extendable = False\n        network_pf.lines.s_nom = network.lines.s_nom_opt\n        network_pf.transformers.s_nom = network.transformers.s_nom_opt\n        network_pf.storage_units.p_nom = network_pf.storage_units.p_nom_opt\n        network_pf.links.p_nom = network_pf.links.p_nom_opt\n\n        network_pf.lopf(network.snapshots,\n            solver_name=args['solver'],\n            solver_options=args['solver_options'],\n            extra_functionality=extra_functionality)\n        \n        network_pf.storage_units.p_nom_extendable = storages_extendable\n        network_pf.lines.s_nom_extendable = lines_extendable \n        network_pf.links.p_nom_extendable = links_extendable\n        network_pf.transformers.s_nom_extendable = trafos_extendable\n        \n        network_pf.storage_units.p_nom = storages_p_nom\n        network_pf.lines.s_nom = lines_s_nom\n        network_pf.links.p_nom = links_p_nom\n        network_pf.transformers.s_nom = trafos_s_nom\n\n    # For the PF, set the P to the optimised P\n    network_pf.generators_t.p_set = network_pf.generators_t.p_set.reindex(\n        columns=network_pf.generators.index)\n    network_pf.generators_t.p_set = network_pf.generators_t.p\n\n    network_pf.storage_units_t.p_set = network_pf.storage_units_t.p_set\\\n        .reindex(columns=network_pf.storage_units.index)\n    network_pf.storage_units_t.p_set = network_pf.storage_units_t.p\n\n    network_pf.links_t.p_set = network_pf.links_t.p_set.reindex(\n        columns=network_pf.links.index)\n    network_pf.links_t.p_set = network_pf.links_t.p0\n\n    # if foreign lines are DC, execute pf only on sub_network in Germany\n    if (args['foreign_lines']['carrier'] == 'DC') or ((args['scn_extension']!=\n       None) and ('BE_NO_NEP 2035' in args['scn_extension'])):\n        n_bus = pd.Series(index=network.sub_networks.index)\n\n        for i in range(0, len(network.sub_networks.index)-1):\n            n_bus[i] = len(network.buses.index[\n                    network.buses.sub_network.astype(int) == i])\n\n        sub_network_DE = n_bus.index[n_bus == n_bus.max()]\n\n        foreign_bus = network.buses[network.buses.sub_network !=\n                                    sub_network_DE.values[0]]\n\n        foreign_comp = {'Bus': network.buses[\n                                    network.buses.sub_network !=\n                                    sub_network_DE.values[0]],\n                        'Generator': network.generators[\n                                network.generators.bus.isin(\n                                        foreign_bus.index)],\n                        'Load': network.loads[\n                                network.loads.bus.isin(foreign_bus.index)],\n                        'Transformer': network.transformers[\n                                network.transformers.bus0.isin(\n                                        foreign_bus.index)],\n                        'StorageUnit': network.storage_units[\n                                network.storage_units.bus.isin(\n                                        foreign_bus.index)]}\n\n        foreign_series = {'Bus': network.buses_t.copy(),\n                          'Generator': network.generators_t.copy(),\n                          'Load': network.loads_t.copy(),\n                          'Transformer':  network.transformers_t.copy(),\n                          'StorageUnit': network.storage_units_t.copy()}\n\n        for comp in sorted(foreign_series):\n            attr = sorted(foreign_series[comp])\n            for a in attr:\n                if not foreign_series[comp][a].empty:\n                    if a != 'p_max_pu':\n                        foreign_series[comp][a] = foreign_series[comp][a][\n                               foreign_comp[comp].index]\n\n                    else:\n                        foreign_series[comp][a] = foreign_series[comp][a][\n                               foreign_comp[comp][foreign_comp[\n                                       comp]['carrier'].isin(\n                                                ['solar', 'wind_onshore',\n                                                 'wind_offshore',\n                                                 'run_of_river'])].index]\n\n        network.buses = network.buses.drop(foreign_bus.index)\n        network.generators = network.generators[\n                network.generators.bus.isin(network.buses.index)]\n        network.loads = network.loads[\n                network.loads.bus.isin(network.buses.index)]\n        network.transformers = network.transformers[\n                 network.transformers.bus0.isin(network.buses.index)]\n        network.storage_units = network.storage_units[\n                network.storage_units.bus.isin(network.buses.index)]\n        \n    # Set slack bus\n    network = set_slack(network)\n\n    # execute non-linear pf\n    pf_solution = network_pf.pf(network.snapshots, use_seed=True)\n\n    # if selected, copy lopf results of neighboring countries to network\n    if ((args['foreign_lines']['carrier'] == 'DC') or ((args['scn_extension']!=\n       None) and ('BE_NO_NEP 2035' in args['scn_extension']))) and add_foreign_lopf:\n        for comp in sorted(foreign_series):\n            network.import_components_from_dataframe(foreign_comp[comp], comp)\n\n            for attr in sorted(foreign_series[comp]):\n                network.import_series_from_dataframe(foreign_series\n                                                     [comp][attr], comp, attr)\n\n    pf_solve = pd.DataFrame(index=pf_solution['converged'].index)\n    pf_solve['converged'] = pf_solution['converged'].values\n    pf_solve['error'] = pf_solution['error'].values\n    pf_solve['n_iter'] = pf_solution['n_iter'].values\n\n    if not pf_solve[~pf_solve.converged].count().max() == 0:\n        logger.warning(\"PF of %d snapshots not converged.\",\n                       pf_solve[~pf_solve.converged].count().max())\n\n    return pf_solve", "response": "Function that prepares and runs a non - linar load flow using PyPSA."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef distribute_q(network, allocation='p_nom'):\n    \n    \"\"\" Function that distributes reactive power at bus to all installed\n    generators and storages. \n\n    Parameters\n    ----------\n    network : :class:`pypsa.Network\n        Overall container of PyPSA\n    allocation: str\n        Choose key to distribute reactive power:\n        'p_nom' to dirstribute via p_nom\n        'p' to distribute via p_set\n\n    Returns\n    -------\n\n        \n    \"\"\"\n    network.allocation = allocation\n    if allocation == 'p':\n        p_sum = network.generators_t['p'].\\\n            groupby(network.generators.bus, axis=1).sum().\\\n            add(network.storage_units_t['p'].abs().groupby(\n                network.storage_units.bus, axis=1).sum(), fill_value=0)\n        q_sum = network.generators_t['q'].\\\n            groupby(network.generators.bus, axis=1).sum()\n\n        q_distributed = network.generators_t.p / \\\n            p_sum[network.generators.bus.sort_index()].values * \\\n            q_sum[network.generators.bus.sort_index()].values\n\n        q_storages = network.storage_units_t.p / \\\n            p_sum[network.storage_units.bus.sort_index()].values *\\\n            q_sum[network.storage_units.bus.sort_index()].values\n\n    if allocation == 'p_nom':\n\n        q_bus = network.generators_t['q'].\\\n            groupby(network.generators.bus, axis=1).sum().add(\n                network.storage_units_t.q.groupby(\n                network.storage_units.bus, axis = 1).sum(), fill_value=0)\n\n        p_nom_dist = network.generators.p_nom_opt.sort_index()\n        p_nom_dist[p_nom_dist.index.isin(network.generators.index\n                                         [network.generators.carrier ==\n                                          'load shedding'])] = 0\n\n        q_distributed = q_bus[\n            network.generators.bus].multiply(p_nom_dist.values) /\\\n            (network.generators.p_nom_opt[network.generators.carrier !=\n                                          'load shedding'].groupby(\n                network.generators.bus).sum().add(\n                network.storage_units.p_nom_opt.groupby\n                (network.storage_units.bus).sum(), fill_value=0))[\n            network.generators.bus.sort_index()].values\n\n        q_distributed.columns = network.generators.index\n\n        q_storages = q_bus[network.storage_units.bus]\\\n            .multiply(network.storage_units.p_nom_opt.values) / \\\n            ((network.generators.p_nom_opt[network.generators.carrier !=\n                                          'load shedding'].groupby(\n                network.generators.bus).sum().add(\n                network.storage_units.p_nom_opt.\n                groupby(network.storage_units.bus).sum(), fill_value=0))[\n            network.storage_units.bus].values)\n\n        q_storages.columns = network.storage_units.index\n\n    q_distributed[q_distributed.isnull()] = 0\n    q_distributed[q_distributed.abs() == np.inf] = 0\n    q_storages[q_storages.isnull()] = 0\n    q_storages[q_storages.abs() == np.inf] = 0\n    network.generators_t.q = q_distributed\n    network.storage_units_t.q = q_storages\n\n    return network", "response": "Function that distributes reactive power at bus to all installed modules and storages."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncalculating the losses per line with PF result data and returns the resulting data.", "response": "def calc_line_losses(network):\n    \"\"\" Calculate losses per line with PF result data\n    \n    Parameters\n    ----------\n    network : :class:`pypsa.Network\n        Overall container of PyPSA\n    s0 : series\n        apparent power of line\n    i0 : series\n        current of line\n    -------\n\n    \"\"\"\n\n    # Line losses\n    # calculate apparent power S = sqrt(p\u00b2 + q\u00b2) [in MW]\n    s0_lines = ((network.lines_t.p0**2 + network.lines_t.q0**2).\n                apply(np.sqrt))\n    # calculate current I = S / U [in A]\n    i0_lines = np.multiply(s0_lines, 1000000) / \\\n        np.multiply(network.lines.v_nom, 1000)\n    # calculate losses per line and timestep network.\\\n    # lines_t.line_losses = I\u00b2 * R [in MW]\n    network.lines_t.losses = np.divide(i0_lines**2 * network.lines.r, 1000000)\n    # calculate total losses per line [in MW]\n    network.lines = network.lines.assign(\n        losses=np.sum(network.lines_t.losses).values)\n\n    # Transformer losses\n    # https://books.google.de/books?id=0glcCgAAQBAJ&pg=PA151&lpg=PA151&dq=\n    # wirkungsgrad+transformator+1000+mva&source=bl&ots=a6TKhNfwrJ&sig=\n    # r2HCpHczRRqdgzX_JDdlJo4hj-k&hl=de&sa=X&ved=\n    # 0ahUKEwib5JTFs6fWAhVJY1AKHa1cAeAQ6AEIXjAI#v=onepage&q=\n    # wirkungsgrad%20transformator%201000%20mva&f=false\n    # Crastan, Elektrische Energieversorgung, p.151\n    # trafo 1000 MVA: 99.8 %\n    network.transformers = network.transformers.assign(\n        losses=np.multiply(network.transformers.s_nom, (1 - 0.998)).values)\n\n    # calculate total losses (possibly enhance with adding these values\n    # to network container)\n    losses_total = sum(network.lines.losses) + sum(network.transformers.losses)\n    print(\"Total lines losses for all snapshots [MW]:\", round(losses_total, 2))\n    losses_costs = losses_total * np.average(network.buses_t.marginal_price)\n    print(\"Total costs for these losses [EUR]:\", round(losses_costs, 2))\n\n    return"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsets capital costs for extendable lines in respect to PyPSA.", "response": "def set_line_costs(network, args, \n                   cost110=230, cost220=290, cost380=85, costDC=375):\n    \"\"\" Set capital costs for extendable lines in respect to PyPSA [\u20ac/MVA]\n    \n    Parameters\n    ----------\n    network : :class:`pypsa.Network\n        Overall container of PyPSA\n    args: dict containing settings from appl.py\n    cost110 : capital costs per km for 110kV lines and cables\n                default: 230\u20ac/MVA/km, source: costs for extra circuit in\n                dena Verteilnetzstudie, p. 146)\n    cost220 : capital costs per km for 220kV lines and cables\n                default: 280\u20ac/MVA/km, source: costs for extra circuit in\n                NEP 2025, capactity from most used 220 kV lines in model\n    cost380 : capital costs per km for 380kV lines and cables\n                default: 85\u20ac/MVA/km, source: costs for extra circuit in\n                NEP 2025, capactity from most used 380 kV lines in NEP\n    costDC : capital costs per km for DC-lines\n                default: 375\u20ac/MVA/km, source: costs for DC transmission line \n                in NEP 2035\n    -------\n\n    \"\"\"\n    network.lines[\"v_nom\"] = network.lines.bus0.map(network.buses.v_nom)\n\n    network.lines.loc[(network.lines.v_nom == 110),\n                      'capital_cost'] = cost110 * network.lines.length /\\\n                          args['branch_capacity_factor']['HV']\n                      \n    network.lines.loc[(network.lines.v_nom == 220),\n                      'capital_cost'] = cost220 * network.lines.length/\\\n                      args['branch_capacity_factor']['eHV']\n                      \n    network.lines.loc[(network.lines.v_nom == 380),\n                      'capital_cost'] = cost380 * network.lines.length/\\\n                      args['branch_capacity_factor']['eHV']\n                      \n    network.links.loc[network.links.p_nom_extendable,\n                      'capital_cost'] = costDC * network.links.length\n\n    return network"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset capital costs for extendable transformers in respect to PyPSA network.", "response": "def set_trafo_costs(network, args,  cost110_220=7500, cost110_380=17333,\n                    cost220_380=14166):\n    \"\"\" Set capital costs for extendable transformers in respect\n    to PyPSA [\u20ac/MVA]\n    \n    Parameters\n    ----------\n    network : :class:`pypsa.Network\n        Overall container of PyPSA\n    cost110_220 : capital costs for 110/220kV transformer\n                    default: 7500\u20ac/MVA, source: costs for extra trafo in\n                    dena Verteilnetzstudie, p. 146; S of trafo used in osmTGmod\n    cost110_380 : capital costs for 110/380kV transformer\n                default: 17333\u20ac/MVA, source: NEP 2025\n    cost220_380 : capital costs for 220/380kV transformer\n                default: 14166\u20ac/MVA, source: NEP 2025\n\n    \"\"\"\n    network.transformers[\"v_nom0\"] = network.transformers.bus0.map(\n        network.buses.v_nom)\n    network.transformers[\"v_nom1\"] = network.transformers.bus1.map(\n        network.buses.v_nom)\n\n    network.transformers.loc[(network.transformers.v_nom0 == 110) & (\n        network.transformers.v_nom1 == 220), 'capital_cost'] = cost110_220/\\\n        args['branch_capacity_factor']['HV']\n    network.transformers.loc[(network.transformers.v_nom0 == 110) & (\n        network.transformers.v_nom1 == 380), 'capital_cost'] = cost110_380/\\\n        args['branch_capacity_factor']['HV']\n    network.transformers.loc[(network.transformers.v_nom0 == 220) & (\n        network.transformers.v_nom1 == 380), 'capital_cost'] = cost220_380/\\\n        args['branch_capacity_factor']['eHV']\n\n    return network"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nadds missing components at Heizkraftwerk Nord in Munich and missing transformer in Stuttgart", "response": "def add_missing_components(network):\n    # Munich\n    \"\"\"Add missing transformer at Heizkraftwerk Nord in Munich and missing\n    transformer in Stuttgart\n    \n    Parameters\n    ----------\n    network : :class:`pypsa.Network\n        Overall container of PyPSA\n\n    Returns\n    -------\n    network : :class:`pypsa.Network\n        Overall container of PyPSA\n        \n    \"\"\"\n    \n    \"\"\"https://www.swm.de/privatkunden/unternehmen/energieerzeugung/heizkraftwerke.html?utm_medium=301\n\n     to bus 25096:\n     25369 (86)\n     28232 (24)\n     25353 to 25356 (79)\n     to bus 23822: (110kV bus  of 380/110-kV-transformer)\n     25355 (90)\n     28212 (98)\n\n     25357 to 665 (85)\n     25354 to 27414 (30)\n     27414 to 28212 (33)\n     25354 to 28294 (32/63)\n     28335 to 28294 (64)\n     28335 to 28139 (28)\n     Overhead lines:\n     16573 to 24182 (part of 4)\n     \"\"\"\n    \"\"\"\n     Installierte Leistung der Umspannungsebene H\u00f6chst- zu Hochspannung\n     (380 kV / 110 kV): 2.750.000 kVA\n     https://www.swm-infrastruktur.de/strom/netzstrukturdaten/strukturmerkmale.html\n    \"\"\"\n    new_trafo = str(network.transformers.index.astype(int).max() + 1)\n\n    network.add(\"Transformer\", new_trafo, bus0=\"16573\", bus1=\"23648\",\n                x=0.135 / (2750 / 2),\n                r=0.0, tap_ratio=1, s_nom=2750 / 2)\n\n    def add_110kv_line(bus0, bus1, overhead=False):\n        new_line = str(network.lines.index.astype(int).max() + 1)\n        if not overhead:\n            network.add(\"Line\", new_line, bus0=bus0, bus1=bus1, s_nom=280)\n        else:\n            network.add(\"Line\", new_line, bus0=bus0, bus1=bus1, s_nom=260)\n        network.lines.loc[new_line, \"scn_name\"] = \"Status Quo\"\n        network.lines.loc[new_line, \"v_nom\"] = 110\n        network.lines.loc[new_line, \"version\"] = \"added_manually\"\n        network.lines.loc[new_line, \"frequency\"] = 50\n        network.lines.loc[new_line, \"cables\"] = 3.0\n        network.lines.loc[new_line, \"country\"] = 'DE'\n        network.lines.loc[new_line, \"length\"] = (\n            pypsa.geo.haversine(network.buses.loc[bus0, [\"x\", \"y\"]],\n                                network.buses.loc[bus1, [\"x\", \"y\"]])\n            [0][0] * 1.2)\n        if not overhead:\n            network.lines.loc[new_line, \"r\"] = (network.lines.\n                                                loc[new_line, \"length\"] *\n                                                0.0177)\n            network.lines.loc[new_line, \"g\"] = 0\n            # or: (network.lines.loc[new_line, \"length\"]*78e-9)\n            network.lines.loc[new_line, \"x\"] = (network.lines.\n                                                loc[new_line, \"length\"] *\n                                                0.3e-3)\n            network.lines.loc[new_line, \"b\"] = (network.lines.\n                                                loc[new_line, \"length\"] *\n                                                250e-9)\n\n        elif overhead:\n            network.lines.loc[new_line, \"r\"] = (network.lines.\n                                                loc[new_line, \"length\"] *\n                                                0.05475)\n            network.lines.loc[new_line, \"g\"] = 0\n            # or: (network.lines.loc[new_line, \"length\"]*40e-9)\n            network.lines.loc[new_line, \"x\"] = (network.lines.\n                                                loc[new_line, \"length\"] *\n                                                1.2e-3)\n            network.lines.loc[new_line, \"b\"] = (network.lines.\n                                                loc[new_line, \"length\"] *\n                                                9.5e-9)\n\n    add_110kv_line(\"16573\", \"28353\")\n    add_110kv_line(\"16573\", \"28092\")\n    add_110kv_line(\"25096\", \"25369\")\n    add_110kv_line(\"25096\", \"28232\")\n    add_110kv_line(\"25353\", \"25356\")\n    add_110kv_line(\"23822\", \"25355\")\n    add_110kv_line(\"23822\", \"28212\")\n    add_110kv_line(\"25357\", \"665\")\n    add_110kv_line(\"25354\", \"27414\")\n    add_110kv_line(\"27414\", \"28212\")\n    add_110kv_line(\"25354\", \"28294\")\n    add_110kv_line(\"28335\", \"28294\")\n    add_110kv_line(\"28335\", \"28139\")\n    add_110kv_line(\"16573\", \"24182\", overhead=True)\n\n    # Stuttgart\n    \"\"\"\n         Stuttgart:\n         Missing transformer, because 110-kV-bus is situated outside\n         Heizkraftwerk Heilbronn:\n    \"\"\"\n    # new_trafo = str(network.transformers.index.astype(int).max()1)\n    network.add(\"Transformer\", '99999', bus0=\"18967\", bus1=\"25766\",\n                x=0.135 / 300, r=0.0, tap_ratio=1, s_nom=300)\n    \"\"\"\n    According to:\n    https://assets.ctfassets.net/xytfb1vrn7of/NZO8x4rKesAcYGGcG4SQg/b780d6a3ca4c2600ab51a30b70950bb1/netzschemaplan-110-kv.pdf\n    the following lines are missing:\n    \"\"\"\n    add_110kv_line(\"18967\", \"22449\", overhead=True)  # visible in OSM & DSO map\n    add_110kv_line(\"21165\", \"24068\", overhead=True)  # visible in OSM & DSO map\n    add_110kv_line(\"23782\", \"24089\", overhead=True)\n    # visible in DSO map & OSM till 1 km from bus1\n    \"\"\"\n    Umspannwerk M\u00f6hringen (bus 23697)\n    https://de.wikipedia.org/wiki/Umspannwerk_M%C3%B6hringen\n    there should be two connections:\n    to Sindelfingen (2*110kV)\n    to Wendingen (former 220kV, now 2*110kV)\n    the line to Sindelfingen is connected, but the connection of Sindelfingen\n    itself to 380kV is missing:\n    \"\"\"\n    add_110kv_line(\"19962\", \"27671\", overhead=True)  # visible in OSM & DSO map\n    add_110kv_line(\"19962\", \"27671\", overhead=True)\n    \"\"\"\n    line to Wendingen is missing, probably because it ends shortly before the\n    way of the substation and is connected via cables:\n    \"\"\"\n    add_110kv_line(\"23697\", \"24090\", overhead=True)  # visible in OSM & DSO map\n    add_110kv_line(\"23697\", \"24090\", overhead=True)\n\n    # Lehrte\n    \"\"\"\n    Lehrte: 220kV Bus located outsinde way of Betriebszentrtum Lehrte and\n    therefore not connected:\n    \"\"\"\n\n    def add_220kv_line(bus0, bus1, overhead=False):\n        new_line = str(network.lines.index.astype(int).max() + 1)\n        if not overhead:\n            network.add(\"Line\", new_line, bus0=bus0, bus1=bus1, s_nom=550)\n        else:\n            network.add(\"Line\", new_line, bus0=bus0, bus1=bus1, s_nom=520)\n        network.lines.loc[new_line, \"scn_name\"] = \"Status Quo\"\n        network.lines.loc[new_line, \"v_nom\"] = 220\n        network.lines.loc[new_line, \"version\"] = \"added_manually\"\n        network.lines.loc[new_line, \"frequency\"] = 50\n        network.lines.loc[new_line, \"cables\"] = 3.0\n        network.lines.loc[new_line, \"country\"] = 'DE'\n        network.lines.loc[new_line, \"length\"] = (\n            pypsa.geo.haversine(network.buses.loc[bus0, [\"x\", \"y\"]],\n                                network.buses.loc[bus1, [\"x\", \"y\"]])[0][0] *\n            1.2)\n        if not overhead:\n            network.lines.loc[new_line, \"r\"] = (network.lines.\n                                                loc[new_line, \"length\"] *\n                                                0.0176)\n            network.lines.loc[new_line, \"g\"] = 0\n            # or: (network.lines.loc[new_line, \"length\"]*67e-9)\n            network.lines.loc[new_line, \"x\"] = (network.lines.\n                                                loc[new_line, \"length\"] *\n                                                0.3e-3)\n            network.lines.loc[new_line, \"b\"] = (network.lines.\n                                                loc[new_line, \"length\"] *\n                                                210e-9)\n\n        elif overhead:\n            network.lines.loc[new_line, \"r\"] = (network.lines.\n                                                loc[new_line, \"length\"] *\n                                                0.05475)\n            network.lines.loc[new_line, \"g\"] = 0\n            # or: (network.lines.loc[new_line, \"length\"]*30e-9)\n            network.lines.loc[new_line, \"x\"] = (network.lines.\n                                                loc[new_line, \"length\"] * 1e-3)\n            network.lines.loc[new_line, \"b\"] = (network.lines.\n                                                loc[new_line, \"length\"] * 11e-9\n                                                )\n\n    add_220kv_line(\"266\", \"24633\", overhead=True)\n\n\n    # temporary turn buses of transformers\n    network.transformers[\"v_nom0\"] = network.transformers.bus0.map(\n        network.buses.v_nom)\n    network.transformers[\"v_nom1\"] = network.transformers.bus1.map(\n        network.buses.v_nom)\n    new_bus0 = network.transformers.bus1[network.transformers.v_nom0>network.transformers.v_nom1]\n    new_bus1 = network.transformers.bus0[network.transformers.v_nom0>network.transformers.v_nom1]\n    network.transformers.bus0[network.transformers.v_nom0>network.transformers.v_nom1] = new_bus0.values\n    network.transformers.bus1[network.transformers.v_nom0>network.transformers.v_nom1] = new_bus1.values\n\n    return network"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nconvert capital_costs to fit to pypsa and caluculated time", "response": "def convert_capital_costs(network, start_snapshot, end_snapshot, p=0.05, T=40):\n    \"\"\" Convert capital_costs to fit to pypsa and caluculated time\n    \n    Parameters\n    ----------\n    network : :class:`pypsa.Network\n        Overall container of PyPSA\n    p : interest rate, default 0.05\n    T : number of periods, default 40 years (source: StromNEV Anlage 1)\n    -------\n\n    \"\"\"\n    # Add costs for DC-converter\n    network.links.capital_cost = network.links.capital_cost + 400000\n\n    # Calculate present value of an annuity (PVA)\n    PVA = (1 / p) - (1 / (p * (1 + p) ** T))\n\n    # Apply function on lines, links, trafos and storages\n    # Storage costs are already annuized yearly\n    network.lines.loc[network.lines.s_nom_extendable == True,\n                      'capital_cost'] = (network.lines.capital_cost /\n                      (PVA * (8760 / (end_snapshot - start_snapshot + 1))))\n    network.links.loc[network.links.p_nom_extendable == True,\n                      'capital_cost'] = network. links.capital_cost /\\\n                      (PVA * (8760 / (end_snapshot - start_snapshot + 1)))\n    network.transformers.loc[network.transformers.s_nom_extendable == True,\n                     'capital_cost'] = network.transformers.capital_cost / \\\n                      (PVA * (8760 / (end_snapshot - start_snapshot + 1)))\n    network.storage_units.loc[network.storage_units.p_nom_extendable == True,\n                      'capital_cost'] = network.storage_units.capital_cost / \\\n                              (8760 / (end_snapshot - start_snapshot + 1))\n\n    return network"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef find_snapshots(network, carrier, maximum = True, minimum = True, n = 3):\n    \n    \"\"\"\n    Function that returns snapshots with maximum and/or minimum feed-in of \n    selected carrier.\n\n    Parameters\n    ----------\n    network : :class:`pypsa.Network\n        Overall container of PyPSA\n    carrier: str\n        Selected carrier of generators\n    maximum: bool\n        Choose if timestep of maximal feed-in is returned.\n    minimum: bool\n        Choose if timestep of minimal feed-in is returned.\n    n: int\n        Number of maximal/minimal snapshots\n\n    Returns\n    -------\n    calc_snapshots : 'pandas.core.indexes.datetimes.DatetimeIndex'\n        List containing snapshots\n    \"\"\"\n    \n    if carrier == 'residual load':\n        power_plants = network.generators[network.generators.carrier.\n                                    isin(['solar', 'wind', 'wind_onshore'])]\n        power_plants_t = network.generators.p_nom[power_plants.index] * \\\n                        network.generators_t.p_max_pu[power_plants.index]\n        load = network.loads_t.p_set.sum(axis=1)\n        all_renew = power_plants_t.sum(axis=1)\n        all_carrier = load - all_renew\n\n    if carrier in ('solar', 'wind', 'wind_onshore', \n                   'wind_offshore', 'run_of_river'):\n        power_plants = network.generators[network.generators.carrier\n                                          == carrier]\n\n        power_plants_t = network.generators.p_nom[power_plants.index] * \\\n                        network.generators_t.p_max_pu[power_plants.index]\n        all_carrier = power_plants_t.sum(axis=1)\n\n    if maximum and not minimum:\n       times = all_carrier.sort_values().head(n=n)\n\n    if minimum and not maximum:\n       times = all_carrier.sort_values().tail(n=n)\n\n    if maximum and minimum:\n        times = all_carrier.sort_values().head(n=n)\n        times = times.append(all_carrier.sort_values().tail(n=n))\n\n    calc_snapshots = all_carrier.index[all_carrier.index.isin(times.index)]\n\n    return calc_snapshots", "response": "Function that returns snapshots with maximum and minimum feed - in of \n    selected carrier."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nadd ramping constraints to thermal power plants.", "response": "def ramp_limits(network):\n    \"\"\" Add ramping constraints to thermal power plants.\n\n    Parameters\n    ----------\n    network : :class:`pypsa.Network\n        Overall container of PyPSA\n\n    Returns\n    -------\n    \n    \"\"\"\n    carrier = ['coal', 'biomass', 'gas', 'oil', 'waste', 'lignite',\n                       'uranium', 'geothermal']\n    data = {'start_up_cost':[77, 57, 42, 57, 57, 77, 50, 57], #\u20ac/MW\n            'start_up_fuel':[4.3, 2.8, 1.45, 2.8, 2.8, 4.3, 16.7, 2.8], #MWh/MW\n            'min_up_time':[5, 2, 3, 2, 2, 5, 12, 2], \n            'min_down_time':[7, 2, 2, 2, 2, 7, 17, 2], \n# =============================================================================\n#             'ramp_limit_start_up':[0.4, 0.4, 0.4, 0.4, 0.4, 0.6, 0.5, 0.4], \n#             'ramp_limit_shut_down':[0.4, 0.4, 0.4, 0.4, 0.4, 0.6, 0.5, 0.4] \n# =============================================================================\n            'p_min_pu':[0.33, 0.38, 0.4, 0.38, 0.38, 0.5, 0.45, 0.38]\n            }\n    df = pd.DataFrame(data, index=carrier)\n    fuel_costs = network.generators.marginal_cost.groupby(\n            network.generators.carrier).mean()[carrier]\n    df['start_up_fuel'] = df['start_up_fuel'] * fuel_costs\n    df['start_up_cost'] = df['start_up_cost'] + df['start_up_fuel']\n    df.drop('start_up_fuel', axis=1, inplace=True)\n    for tech in df.index:\n        for limit in df.columns:\n            network.generators.loc[network.generators.carrier == tech, \n                                   limit] = df.loc[tech, limit]\n    network.generators.start_up_cost = network.generators.start_up_cost\\\n                                        *network.generators.p_nom\n    network.generators.committable = True"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets and open json file with scenaio settings of arguments and eTraGo parameters.", "response": "def get_args_setting(args, jsonpath='scenario_setting.json'):\n    \"\"\"\n    Get and open json file with scenaio settings of eTraGo ``args``.\n    The settings incluedes all eTraGo specific settings of arguments and \n    parameters for a reproducible calculation.\n\n    Parameters\n    ----------\n    json_file : str\n        Default: ``scenario_setting.json``\n        Name of scenario setting json file\n\n    Returns\n    -------\n    args : dict\n        Dictionary of json file \n    \"\"\"\n \n    if not jsonpath == None:\n        with open(jsonpath) as f:\n            args = json.load(f)\n\n\n    return args"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef set_line_country_tags(network):\n\n    transborder_lines_0 = network.lines[network.lines['bus0'].isin(\n            network.buses.index[network.buses['country_code'] != 'DE'])].index\n    transborder_lines_1 = network.lines[network.lines['bus1'].isin(\n            network.buses.index[network.buses['country_code']!= 'DE'])].index\n    #set country tag for lines\n    network.lines.loc[transborder_lines_0, 'country'] = \\\n        network.buses.loc[network.lines.loc[transborder_lines_0, 'bus0']\\\n                          .values, 'country_code'].values\n    \n    network.lines.loc[transborder_lines_1, 'country'] = \\\n        network.buses.loc[network.lines.loc[transborder_lines_1, 'bus1']\\\n                          .values, 'country_code'].values\n    network.lines['country'].fillna('DE', inplace=True)\n    doubles = list(set(transborder_lines_0.intersection(transborder_lines_1)))\n    for line in doubles:\n        c_bus0 = network.buses.loc[network.lines.loc[line, 'bus0'], 'country']\n        c_bus1 = network.buses.loc[network.lines.loc[line, 'bus1'], 'country']\n        network.lines.loc[line, 'country'] = '{}{}'.format(c_bus0, c_bus1)\n    \n    transborder_links_0 = network.links[network.links['bus0'].isin(\n            network.buses.index[network.buses['country_code']!= 'DE'])].index\n    transborder_links_1 = network.links[network.links['bus1'].isin(\n            network.buses.index[network.buses['country_code'] != 'DE'])].index\n\n    #set country tag for links\n    network.links.loc[transborder_links_0, 'country'] = \\\n        network.buses.loc[network.links.loc[transborder_links_0, 'bus0']\\\n                          .values, 'country_code'].values\n\n    network.links.loc[transborder_links_1, 'country'] = \\\n        network.buses.loc[network.links.loc[transborder_links_1, 'bus1']\\\n                          .values, 'country_code'].values\n    network.links['country'].fillna('DE', inplace=True)\n    doubles = list(set(transborder_links_0.intersection(transborder_links_1)))\n    for link in doubles:\n        c_bus0 = network.buses.loc[network.links.loc[link, 'bus0'], 'country']\n        c_bus1 = network.buses.loc[network.links.loc[link, 'bus1'], 'country']\n        network.links.loc[link, 'country'] = '{}{}'.format(c_bus0, c_bus1)", "response": "Sets the country tags for the lines in the current language."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef crossborder_capacity(network, method, capacity_factor):\n    if method == 'ntc_acer':\n        cap_per_country = {'AT': 4900,\n                           'CH': 2695,\n                           'CZ': 1301,\n                           'DK': 913,\n                           'FR': 3593,\n                           'LU': 2912,\n                           'NL': 2811,\n                           'PL': 280,\n                           'SE': 217,\n                           'CZAT': 574,\n                           'ATCZ': 574,\n                           'CZPL': 312,\n                           'PLCZ': 312,\n                           'ATCH': 979,\n                           'CHAT': 979,\n                           'CHFR': 2087,\n                           'FRCH': 2087,\n                           'FRLU': 364,\n                           'LUFR': 364,\n                           'SEDK': 1928,\n                           'DKSE': 1928}\n\n    elif method == 'thermal_acer':\n        cap_per_country = {'CH': 12000,\n                            'DK': 4000,\n                            'SEDK': 3500,\n                            'DKSE': 3500}\n        capacity_factor = {'HV': 1, 'eHV':1}\n    if not network.lines[network.lines.country != 'DE'].empty:\n        weighting = network.lines.loc[network.lines.country!='DE', 's_nom'].\\\n                groupby(network.lines.country).transform(lambda x: x/x.sum())\n\n    weighting_links = network.links.loc[network.links.country!='DE', 'p_nom'].\\\n                groupby(network.links.country).transform(lambda x: x/x.sum())\n    network.lines[\"v_nom\"] = network.lines.bus0.map(network.buses.v_nom)\n    for country in cap_per_country:\n\n        index_HV = network.lines[(network.lines.country == country) &(\n                network.lines.v_nom == 110)].index\n        index_eHV = network.lines[(network.lines.country == country) &(\n                network.lines.v_nom > 110)].index\n        index_links = network.links[network.links.country == country].index\n\n        if not network.lines[network.lines.country == country].empty:\n                network.lines.loc[index_HV, 's_nom'] = weighting[index_HV] * \\\n                    cap_per_country[country] / capacity_factor['HV']\n                    \n                network.lines.loc[index_eHV, 's_nom'] = \\\n                    weighting[index_eHV] * cap_per_country[country] /\\\n                                capacity_factor['eHV']\n\n        if not network.links[network.links.country == country].empty:\n                network.links.loc[index_links, 'p_nom'] = \\\n                                weighting_links[index_links] * cap_per_country\\\n                                [country] \n        if country == 'SE':\n                network.links.loc[network.links.country == country, 'p_nom'] =\\\n                cap_per_country[country]\n\n        if not network.lines[network.lines.country == (country+country)].empty:\n            i_HV =  network.lines[(network.lines.v_nom == 110)&(\n                    network.lines.country ==country+country)].index\n            \n            i_eHV =  network.lines[(network.lines.v_nom == 110)&(\n                    network.lines.country ==country+country)].index\n\n            network.lines.loc[i_HV, 's_nom'] = \\\n                                weighting[i_HV] * cap_per_country[country]/\\\n                                capacity_factor['HV']\n            network.lines.loc[i_eHV, 's_nom'] = \\\n                                weighting[i_eHV] * cap_per_country[country]/\\\n                                capacity_factor['eHV']\n\n        if not network.links[network.links.country == (country+country)].empty:\n            i_links =  network.links[network.links.country ==\n                                     (country+country)].index\n            network.links.loc[i_links, 'p_nom'] = \\\n                weighting_links[i_links] * cap_per_country\\\n                [country]*capacity_factor", "response": "Adjust interconnector capacties for a given set of interconnector nodes."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef set_branch_capacity(network, args):\n\n    \"\"\"\n    Set branch capacity factor of lines and transformers, different factors for\n    HV (110kV) and eHV (220kV, 380kV).\n\n    Parameters\n    ----------\n    network : :class:`pypsa.Network\n        Overall container of PyPSA\n    args: dict\n        Settings in appl.py\n\n    \"\"\"\n\n    network.lines[\"s_nom_total\"] = network.lines.s_nom.copy()\n\n    network.transformers[\"s_nom_total\"] = network.transformers.s_nom.copy()\n\n    network.lines[\"v_nom\"] = network.lines.bus0.map(\n        network.buses.v_nom)\n    network.transformers[\"v_nom0\"] = network.transformers.bus0.map(\n        network.buses.v_nom)\n\n    network.lines.s_nom[network.lines.v_nom == 110] = \\\n        network.lines.s_nom * args['branch_capacity_factor']['HV']\n\n    network.lines.s_nom[network.lines.v_nom > 110] = \\\n        network.lines.s_nom * args['branch_capacity_factor']['eHV']\n\n    network.transformers.s_nom[network.transformers.v_nom0 == 110]\\\n        = network.transformers.s_nom * args['branch_capacity_factor']['HV']\n\n    network.transformers.s_nom[network.transformers.v_nom0 > 110]\\\n        = network.transformers.s_nom * args['branch_capacity_factor']['eHV']", "response": "Sets the branch capacity factor of lines and transformers for the current language."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef max_line_ext(network, snapshots, share=1.01):\n\n    \"\"\"\n    Sets maximal share of overall network extension\n    as extra functionality in LOPF\n\n    Parameters\n    ----------\n    share: float\n        Maximal share of network extension in p.u.\n    \"\"\"\n\n    lines_snom = network.lines.s_nom.sum()\n    links_pnom = network.links.p_nom.sum()\n\n    def _rule(m):\n\n        lines_opt = sum(m.passive_branch_s_nom[index]\n                        for index\n                        in m.passive_branch_s_nom_index)\n\n        links_opt = sum(m.link_p_nom[index]\n                        for index\n                        in m.link_p_nom_index)\n\n        return (lines_opt + links_opt) <= (lines_snom + links_pnom) * share\n    network.model.max_line_ext = Constraint(rule=_rule)", "response": "Sets maximal share of overall network extension in LOPF\n   "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsetting the minimum renewable share of generation in LOPF", "response": "def min_renewable_share(network, snapshots, share=0.72):\n    \"\"\"\n    Sets minimal renewable share of generation as extra functionality in LOPF\n\n    Parameters\n    ----------\n    share: float\n        Minimal share of renewable generation in p.u.\n    \"\"\"\n    renewables = ['wind_onshore', 'wind_offshore',\n                  'biomass', 'solar', 'run_of_river']\n\n    res = list(network.generators.index[\n            network.generators.carrier.isin(renewables)])\n\n    total = list(network.generators.index)\n    snapshots = network.snapshots\n\n    def _rule(m):\n        \"\"\"\n        \"\"\"\n        renewable_production = sum(m.generator_p[gen, sn]\n                                      for gen\n                                      in res\n                                      for sn in snapshots)\n        total_production = sum(m.generator_p[gen, sn]\n                               for gen in total\n                               for sn in snapshots)\n\n        return (renewable_production >= total_production * share)\n    network.model.min_renewable_share = Constraint(rule=_rule)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef max_curtailment(network, snapshots, curtail_max=0.03):\n    \n    \"\"\"\n    each RE can only be curtailed (over all snapshots) \n    with respect to curtail_max\n\n    Parameters\n    ----------\n    curtail_max: float\n        maximal curtailment per power plant in p.u.\n    \"\"\"\n    renewables = ['wind_onshore', 'wind_offshore',\n                  'solar']\n    \n    res = list(network.generators.index[\n        (network.generators.carrier.isin(renewables))\n        & (network.generators.bus.astype(str).isin(network.buses.index[network.buses.country_code == 'DE']))])\n      \n#    network.import_series_from_dataframe(pd.DataFrame(\n#                index=network.generators_t.p_set.index,\n#                columns=network.generators.index[\n#                        network.generators.carrier=='biomass'],\n#                data=1), \"Generator\", \"p_max_pu\")\n    \n    res_potential = (network.generators.p_nom[res]*network.generators_t.p_max_pu[res]).sum()\n    \n    snapshots = network.snapshots\n\n    for gen in res:\n\n        def _rule(m, gen):\n            \"\"\"\n            \"\"\"\n            #import pdb; pdb.set_trace()\n            re_n = sum(m.generator_p[gen, sn]\n                                      for sn in snapshots)\n            potential_n = res_potential[gen]\n\n            return (re_n >= (1-curtail_max) * potential_n)\n        setattr(network.model, \"max_curtailment\"+gen, Constraint(res, rule=_rule))", "response": "This function determines the maximum curtailed power plant in a single resource."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets a node based on a guild ID useful for noding separation.", "response": "def get_node(guild_id: int, ignore_ready_status: bool = False) -> Node:\n    \"\"\"\n    Gets a node based on a guild ID, useful for noding separation. If the\n    guild ID does not already have a node association, the least used\n    node is returned. Skips over nodes that are not yet ready.\n\n    Parameters\n    ----------\n    guild_id : int\n    ignore_ready_status : bool\n\n    Returns\n    -------\n    Node\n    \"\"\"\n    guild_count = 1e10\n    least_used = None\n\n    for node in _nodes:\n        guild_ids = node.player_manager.guild_ids\n\n        if ignore_ready_status is False and not node.ready.is_set():\n            continue\n        elif len(guild_ids) < guild_count:\n            guild_count = len(guild_ids)\n            least_used = node\n\n        if guild_id in guild_ids:\n            return node\n\n    if least_used is None:\n        raise IndexError(\"No nodes found.\")\n\n    return least_used"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\njoin a voice channel by ID s.", "response": "async def join_voice(guild_id: int, channel_id: int):\n    \"\"\"\n    Joins a voice channel by ID's.\n\n    Parameters\n    ----------\n    guild_id : int\n    channel_id : int\n    \"\"\"\n    node = get_node(guild_id)\n    voice_ws = node.get_voice_ws(guild_id)\n    await voice_ws.voice_state(guild_id, channel_id)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\nasync def connect(self, timeout=None):\n        self._is_shutdown = False\n\n        combo_uri = \"ws://{}:{}\".format(self.host, self.rest)\n        uri = \"ws://{}:{}\".format(self.host, self.port)\n\n        log.debug(\n            \"Lavalink WS connecting to %s or %s with headers %s\", combo_uri, uri, self.headers\n        )\n\n        tasks = tuple({self._multi_try_connect(u) for u in (combo_uri, uri)})\n\n        for task in asyncio.as_completed(tasks, timeout=timeout):\n            with contextlib.suppress(Exception):\n                if await cast(Awaitable[Optional[websockets.WebSocketClientProtocol]], task):\n                    break\n        else:\n            raise asyncio.TimeoutError\n\n        log.debug(\"Creating Lavalink WS listener.\")\n        self._listener_task = self.loop.create_task(self.listener())\n\n        for data in self._queue:\n            await self.send(data)\n\n        self.ready.set()\n        self.update_state(NodeState.READY)", "response": "Connects to the Lavalink WS."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\njoining a voice channel.", "response": "async def join_voice_channel(self, guild_id, channel_id):\n        \"\"\"\n        Alternative way to join a voice channel if node is known.\n        \"\"\"\n        voice_ws = self.get_voice_ws(guild_id)\n        await voice_ws.voice_state(guild_id, channel_id)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\nasync def disconnect(self):\n        self._is_shutdown = True\n        self.ready.clear()\n\n        self.update_state(NodeState.DISCONNECTING)\n\n        await self.player_manager.disconnect()\n\n        if self._ws is not None and self._ws.open:\n            await self._ws.close()\n\n        if self._listener_task is not None and not self.loop.is_closed():\n            self._listener_task.cancel()\n\n        self._state_handlers = []\n\n        _nodes.remove(self)\n        log.debug(\"Shutdown Lavalink WS.\")", "response": "Shuts down and disconnects the websocket."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef register_view(self, view):\n        # prepare State Type Change ComboBox\n        super(StateOverviewController, self).register_view(view)\n        self.allowed_state_classes = self.get_allowed_state_classes(self.model.state)\n\n        view['entry_name'].connect('focus-out-event', self.on_focus_out)\n        view['entry_name'].connect('key-press-event', self.check_for_enter)\n        if self.model.state.name:\n            view['entry_name'].set_text(self.model.state.name)\n        view['label_id_value'].set_text(self.model.state.state_id)\n\n        l_store = Gtk.ListStore(GObject.TYPE_STRING)\n        combo = Gtk.ComboBoxText()\n        combo.set_name(\"state_type_combo\")\n        combo.set_focus_on_click(False)\n        combo.set_model(l_store)\n        combo.show_all()\n        view['type_viewport'].add(combo)\n        view['type_viewport'].show()\n\n        # Prepare label for state_name -> Library states cannot be changed\n        if isinstance(self.model, LibraryStateModel):\n            l_store.prepend(['LIBRARY'])\n            combo.set_sensitive(False)\n\n            self.view['library_path'].set_text(self.model.state.library_path + \"/\" + self.model.state.library_name)\n            self.view['library_path'].set_sensitive(True)\n            self.view['library_path'].set_editable(False)\n            view['show_content_checkbutton'].set_active(self.model.meta['gui']['show_content'] is True)\n            view['show_content_checkbutton'].connect('toggled', self.on_toggle_show_content)\n            # self.view['properties_widget'].remove(self.view['show_content_checkbutton'])\n        else:\n            self.view['properties_widget'].remove(self.view['label_library_path'])\n            self.view['properties_widget'].remove(self.view['library_path'])\n            self.view['properties_widget'].remove(self.view['label_show_content'])\n            self.view['properties_widget'].remove(self.view['show_content_checkbutton'])\n            self.view['properties_widget'].resize(2, 5)\n\n            for state_class in self.allowed_state_classes:\n                if isinstance(self.model.state, state_class):\n                    l_store.prepend([state_class.__name__])\n                else:\n                    l_store.append([state_class.__name__])\n\n        combo.set_active(0)\n        view['type_combobox'] = combo\n        view['type_combobox'].connect('changed', self.change_type)\n\n        # Prepare \"is start state check button\"\n        has_no_start_state_state_types = [BarrierConcurrencyState, PreemptiveConcurrencyState]\n        if not self.with_is_start_state_check_box or isinstance(self.model.state, DeciderState) or \\\n                self.model.state.is_root_state or type(self.model.parent.state) in has_no_start_state_state_types:\n            view['is_start_state_checkbutton'].destroy()\n        else:\n            view['is_start_state_checkbutton'].set_active(bool(self.model.is_start))\n            view['is_start_state_checkbutton'].connect('toggled', self.on_toggle_is_start_state)\n\n        if isinstance(self.model.state, DeciderState):\n            combo.set_sensitive(False)\n\n        # in case the state is inside of a library\n        if self.model.state.get_next_upper_library_root_state():\n            view['entry_name'].set_editable(False)\n            combo.set_sensitive(False)\n            view['is_start_state_checkbutton'].set_sensitive(False)\n            if isinstance(self.model, LibraryStateModel):\n                self.view['show_content_checkbutton'].set_sensitive(False)", "response": "Called when the view was registered"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef run(self):\n        logger.debug(\"Starting execution of {0}{1}\".format(self, \" (backwards)\" if self.backward_execution else \"\"))\n        self.setup_run()\n\n        # data to be accessed by the decider state\n        child_errors = {}\n        final_outcomes_dict = {}\n        decider_state = self.states[UNIQUE_DECIDER_STATE_ID]\n\n        try:\n            concurrency_history_item = self.setup_forward_or_backward_execution()\n            self.start_child_states(concurrency_history_item, decider_state)\n\n            # print(\"bcs1\")\n\n            #######################################################\n            # wait for all child threads to finish\n            #######################################################\n            for history_index, state in enumerate(self.states.values()):\n                # skip the decider state\n                if state is not decider_state:\n                    self.join_state(state, history_index, concurrency_history_item)\n                    self.add_state_execution_output_to_scoped_data(state.output_data, state)\n                    self.update_scoped_variables_with_output_dictionary(state.output_data, state)\n                    # save the errors of the child state executions for the decider state\n                    if 'error' in state.output_data:\n                        child_errors[state.state_id] = (state.name, state.output_data['error'])\n                    final_outcomes_dict[state.state_id] = (state.name, state.final_outcome)\n\n            # print(\"bcs2\")\n\n            #######################################################\n            # handle backward execution case\n            #######################################################\n            if self.backward_execution:\n                # print(\"bcs2.1.\")\n                return self.finalize_backward_execution()\n            else:\n                # print(\"bcs2.2.\")\n                self.backward_execution = False\n\n            # print(\"bcs3\")\n\n            #######################################################\n            # execute decider state\n            #######################################################\n            decider_state_error = self.run_decider_state(decider_state, child_errors, final_outcomes_dict)\n\n            # print(\"bcs4\")\n\n            #######################################################\n            # handle no transition\n            #######################################################\n            transition = self.get_transition_for_outcome(decider_state, decider_state.final_outcome)\n            if transition is None:\n                # final outcome is set here\n                transition = self.handle_no_transition(decider_state)\n            # if the transition is still None, then the child_state was preempted or aborted, in this case return\n            decider_state.state_execution_status = StateExecutionStatus.INACTIVE\n\n            # print(\"bcs5\")\n\n            if transition is None:\n                self.output_data[\"error\"] = RuntimeError(\"state aborted\")\n            else:\n                if decider_state_error:\n                    self.output_data[\"error\"] = decider_state_error\n                self.final_outcome = self.outcomes[transition.to_outcome]\n\n            # print(\"bcs6\")\n\n            return self.finalize_concurrency_state(self.final_outcome)\n\n        except Exception as e:\n            logger.error(\"{0} had an internal error: {1}\\n{2}\".format(self, str(e), str(traceback.format_exc())))\n            self.output_data[\"error\"] = e\n            self.state_execution_status = StateExecutionStatus.WAIT_FOR_NEXT_STATE\n            return self.finalize(Outcome(-1, \"aborted\"))", "response": "This method starts the main execution of the main thread."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nrunning the decider state.", "response": "def run_decider_state(self, decider_state, child_errors, final_outcomes_dict):\n        \"\"\" Runs the decider state of the barrier concurrency state. The decider state decides on which outcome the\n        barrier concurrency is left.\n\n        :param decider_state: the decider state of the barrier concurrency state\n        :param child_errors: error of the concurrent branches\n        :param final_outcomes_dict: dictionary of all outcomes of the concurrent branches\n        :return:\n        \"\"\"\n        decider_state.state_execution_status = StateExecutionStatus.ACTIVE\n        # forward the decider specific data\n        decider_state.child_errors = child_errors\n        decider_state.final_outcomes_dict = final_outcomes_dict\n        # standard state execution\n        decider_state.input_data = self.get_inputs_for_state(decider_state)\n        decider_state.output_data = self.create_output_dictionary_for_state(decider_state)\n        decider_state.start(self.execution_history, backward_execution=False)\n        decider_state.join()\n        decider_state_error = None\n        if decider_state.final_outcome.outcome_id == -1:\n            if 'error' in decider_state.output_data:\n                decider_state_error = decider_state.output_data['error']\n        # standard output data processing\n        self.add_state_execution_output_to_scoped_data(decider_state.output_data, decider_state)\n        self.update_scoped_variables_with_output_dictionary(decider_state.output_data, decider_state)\n        return decider_state_error"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nchecks validity of a transition of BarrierConcurrencyState.", "response": "def _check_transition_validity(self, check_transition):\n        \"\"\" Transition of BarrierConcurrencyStates must least fulfill the condition of a ContainerState.\n        Start transitions are forbidden in the ConcurrencyState.\n\n        :param check_transition: the transition to check for validity\n        :return:\n        \"\"\"\n        valid, message = super(BarrierConcurrencyState, self)._check_transition_validity(check_transition)\n        if not valid:\n            return False, message\n\n        # Only the following transitions are allowed in barrier concurrency states:\n        # - Transitions from the decider state to the parent state\\n\"\n        # - Transitions from not-decider states to the decider state\\n\"\n        # - Transitions from not_decider states from aborted/preempted outcomes to the\n        #   aborted/preempted outcome of the parent\n\n        from_state_id = check_transition.from_state\n        to_state_id = check_transition.to_state\n        from_outcome_id = check_transition.from_outcome\n        to_outcome_id = check_transition.to_outcome\n\n        if from_state_id == UNIQUE_DECIDER_STATE_ID:\n            if to_state_id != self.state_id:\n                return False, \"Transition from the decider state must go to the parent state\"\n        else:\n            if to_state_id != UNIQUE_DECIDER_STATE_ID:\n                if from_outcome_id not in [-2, -1] or to_outcome_id not in [-2, -1]:\n                    return False, \"Transition from this state must go to the decider state. The only exception are \" \\\n                                  \"transition from aborted/preempted to the parent aborted/preempted outcomes\"\n\n        return True, message"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef add_state(self, state, storage_load=False):\n        state_id = super(BarrierConcurrencyState, self).add_state(state)\n        if not storage_load and not self.__init_running and not state.state_id == UNIQUE_DECIDER_STATE_ID:\n            # the transitions must only be created for the initial add_state call and not during each load procedure\n            for o_id, o in list(state.outcomes.items()):\n                if not o_id == -1 and not o_id == -2:\n                    self.add_transition(state.state_id, o_id, self.states[UNIQUE_DECIDER_STATE_ID].state_id, None)\n        return state_id", "response": "Override the add_state method to add automatic transitions for the decider_state."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\noverwriting the setter of the container state base class as special handling for the decider state is needed. :param states: the dictionary of new states :raises exceptions.TypeError: if the states parameter is not of type dict", "response": "def states(self, states):\n        \"\"\" Overwrite the setter of the container state base class as special handling for the decider state is needed.\n\n        :param states: the dictionary of new states\n        :raises exceptions.TypeError: if the states parameter is not of type dict\n        \"\"\"\n        # First safely remove all existing states (recursively!), as they will be replaced\n        state_ids = list(self.states.keys())\n        for state_id in state_ids:\n            # Do not remove decider state, if teh new list of states doesn't contain an alternative one\n            if state_id == UNIQUE_DECIDER_STATE_ID and UNIQUE_DECIDER_STATE_ID not in states:\n                continue\n            self.remove_state(state_id)\n        if states is not None:\n            if not isinstance(states, dict):\n                raise TypeError(\"states must be of type dict\")\n            # Ensure that the decider state is added first, as transition to this states will automatically be\n            # created when adding further states\n            decider_state = states.pop(UNIQUE_DECIDER_STATE_ID, None)\n            if decider_state is not None:\n                self.add_state(decider_state)\n            for state in states.values():\n                self.add_state(state)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nover-writes the parent class remove state method by checking if the user tries to delete the decider state :param state_id: the id of the state to remove :param recursive: a flag to indicate a recursive disassembling of all substates :param force: a flag to indicate forcefully deletion of all states (important of the decider state in the barrier concurrency state) :param destroy: a flag which indicates if the state should not only be disconnected from the state but also destroyed, including all its state elements :raises exceptions.AttributeError: if the state_id parameter is the decider state", "response": "def remove_state(self, state_id, recursive=True, force=False, destroy=True):\n        \"\"\" Overwrite the parent class remove state method by checking if the user tries to delete the decider state\n\n        :param state_id: the id of the state to remove\n        :param recursive: a flag to indicate a recursive disassembling of all substates\n        :param force: a flag to indicate forcefully deletion of all states (important of the decider state in the\n                barrier concurrency state)\n        :param destroy: a flag which indicates if the state should not only be disconnected from the state but also\n                destroyed, including all its state elements\n        :raises exceptions.AttributeError: if the state_id parameter is the decider state\n        \"\"\"\n        if state_id == UNIQUE_DECIDER_STATE_ID and force is False:\n            raise AttributeError(\"You are not allowed to delete the decider state.\")\n        else:\n            return ContainerState.remove_state(self, state_id, recursive=recursive, force=force, destroy=destroy)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_outcome_for_state_name(self, name):\n        return_value = None\n        for state_id, name_outcome_tuple in self.final_outcomes_dict.items():\n            if name_outcome_tuple[0] == name:\n                return_value = name_outcome_tuple[1]\n                break\n        return return_value", "response": "Returns the final outcome of the child state specified by name."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_outcome_for_state_id(self, state_id):\n        return_value = None\n        for s_id, name_outcome_tuple in self.final_outcomes_dict.items():\n            if s_id == state_id:\n                return_value = name_outcome_tuple[1]\n                break\n        return return_value", "response": "Returns the final outcome of the child state specified by the state_id."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the error message of the child state specified by name.", "response": "def get_errors_for_state_name(self, name):\n        \"\"\" Returns the error message of the child state specified by name.\n\n        Note: This is utility function that is used by the programmer to make a decision based on the final outcome\n        of its child states. A state is not uniquely specified by the name, but as the programmer normally does not want\n        to use state-ids in his code this utility function was defined.\n\n        :param name: The name of the state to get the error message for\n        :return:\n        \"\"\"\n        return_value = None\n        for state_id, name_outcome_tuple in self.child_errors.items():\n            if name_outcome_tuple[0] == name:\n                return_value = name_outcome_tuple[1]\n                break\n        return return_value"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nadd a child controller to the current object.", "response": "def add_controller(self, key, controller):\n        \"\"\"Add child controller\n\n        The passed controller is registered as child of self. The register_actions method of the child controller is\n        called, allowing the child controller to register shortcut callbacks.\n\n        :param key: Name of the controller (unique within self), to later access it again\n        :param ExtendedController controller: Controller to be added as child\n        \"\"\"\n        assert isinstance(controller, ExtendedController)\n        controller.parent = self\n        self.__child_controllers[key] = controller\n        if self.__shortcut_manager is not None and controller not in self.__action_registered_controllers:\n            controller.register_actions(self.__shortcut_manager)\n            self.__action_registered_controllers.append(controller)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nremoves the specified child controller and destroys it if it is already there.", "response": "def remove_controller(self, controller):\n        \"\"\"Remove child controller and destroy it\n\n        Removes all references to the child controller and calls destroy() on the controller.\n\n        :param str | ExtendedController controller: Either the child controller object itself or its registered name\n        :return: Whether the controller was existing\n        :rtype: bool\n        \"\"\"\n        # Get name of controller\n        if isinstance(controller, ExtendedController):\n            # print(self.__class__.__name__, \" remove \", controller.__class__.__name__)\n            for key, child_controller in self.__child_controllers.items():\n                if controller is child_controller:\n                    break\n            else:\n                return False\n        else:\n            key = controller\n        # print(self.__class__.__name__, \" remove key \", key, self.__child_controllers.keys())\n        if key in self.__child_controllers:\n            if self.__shortcut_manager is not None:\n                self.__action_registered_controllers.remove(self.__child_controllers[key])\n                self.__child_controllers[key].unregister_actions(self.__shortcut_manager)\n            self.__child_controllers[key].destroy()\n            del self.__child_controllers[key]\n            # print(\"removed\", controller.__class__.__name__ if not isinstance(controller, str) else controller)\n            return True\n        # print(\"do not remove\", controller.__class__.__name__)\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef register_actions(self, shortcut_manager):\n        assert isinstance(shortcut_manager, ShortcutManager)\n        self.__shortcut_manager = shortcut_manager\n\n        for controller in list(self.__child_controllers.values()):\n            if controller not in self.__action_registered_controllers:\n                try:\n                    controller.register_actions(shortcut_manager)\n                except Exception as e:\n                    logger.error(\"Error while registering action for {0}: {1}\".format(controller.__class__.__name__, e))\n                self.__action_registered_controllers.append(controller)", "response": "Register callback methods for triggered actions in all child controllers."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef destroy(self):\n        self.disconnect_all_signals()\n        controller_names = [key for key in self.__child_controllers]\n        for controller_name in controller_names:\n            self.remove_controller(controller_name)\n        self.relieve_all_models()\n        if self.parent:\n            self.__parent = None\n        if self._view_initialized:\n            # print(self.__class__.__name__, \"destroy view\", self.view, self)\n            self.view.get_top_widget().destroy()\n            self.view = None\n            self._Observer__PROP_TO_METHS.clear()  # prop name --> set of observing methods\n            self._Observer__METH_TO_PROPS.clear()  # method --> set of observed properties\n            self._Observer__PAT_TO_METHS.clear() # like __PROP_TO_METHS but only for pattern names (to optimize search)\n            self._Observer__METH_TO_PAT.clear()  # method --> pattern\n            self._Observer__PAT_METH_TO_KWARGS.clear()  # (pattern, method) --> info\n            self.observe = None\n        else:\n            logger.warning(\"The controller {0} seems to be destroyed before the view was fully initialized. {1} \"\n                           \"Check if you maybe do not call {2} or there exist most likely threading problems.\"\n                           \"\".format(self.__class__.__name__, self.model, ExtendedController.register_view))", "response": "Recursively destroy all Controllers\n            and all child Controllers\n           ."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nmakes this model observable within the controller", "response": "def observe_model(self, model):\n        \"\"\"Make this model observable within the controller\n\n        The method also keeps track of all observed models, in order to be able to relieve them later on.\n\n        :param gtkmvc3.Model model: The model to be observed\n        \"\"\"\n        self.__registered_models.add(model)\n        return super(ExtendedController, self).observe_model(model)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef relieve_model(self, model):\n        self.__registered_models.remove(model)\n        return super(ExtendedController, self).relieve_model(model)", "response": "Do no longer observe the model\n       "}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef relieve_all_models(self):\n        map(self.relieve_model, list(self.__registered_models))\n        self.__registered_models.clear()", "response": "Relieve all registered models"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef check_default_value(self, default_value, data_type=None):\n        if data_type is None:\n            data_type = self.data_type\n\n        if default_value is not None:\n            # If the default value is passed as string, we have to convert it to the data type\n            if isinstance(default_value, string_types):\n                if len(default_value) > 1 and default_value[0] == '$':\n                    return default_value\n                if default_value == \"None\":\n                    return None\n\n                default_value = type_helpers.convert_string_value_to_type_value(default_value, data_type)\n                if default_value is None:\n                    raise AttributeError(\"Could not convert default value '{0}' to data type '{1}'.\".format(\n                        default_value, data_type))\n            else:\n                if not isinstance(default_value, self.data_type):\n                    if self._no_type_error_exceptions:\n                        logger.warning(\"Handed default value '{0}' is of type '{1}' but data port data type is {2} {3}.\"\n                                       \"\".format(default_value, type(default_value), data_type, self))\n                    else:\n                        raise TypeError(\"Handed default value '{0}' is of type '{1}' but data port data type is {2}\"\n                                        \"{3} of {4}.\".format(default_value, type(default_value), data_type,\n                                                             self,\n                                                             self.parent.get_path() if self.parent is not None else \"\"))\n\n        return default_value", "response": "Checks whether the passed default value suits to the passed data type."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef open_folder_cmd_line(query, default_path=None):\n    user_input = input(query + ': ')\n    if len(user_input) == 0:\n        user_input = default_path\n    if not user_input or not os.path.isdir(user_input):\n        return None\n    return user_input", "response": "Queries the user for a specific folder path to be opened."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nquery the user for a specific folder path to be created", "response": "def create_folder_cmd_line(query, default_name=None, default_path=None):\n    \"\"\"Queries the user for a path to be created\n\n    :param str query: Query that asks the user for a specific folder path  to be created\n    :param str default_name: Default name of the folder to be created\n    :param str default_path: Path in which the folder is created if the user doesn't specify a path\n    :return: Input path from the user or `default_path` if nothing is specified or None if directory could ne be created\n    :rtype: str\n    \"\"\"\n    default = None\n    if default_name and default_path:\n        default = os.path.join(default_path, default_name)\n    user_input = input(query + ' [default {}]: '.format(default))\n    if len(user_input) == 0:\n        user_input = default\n\n    if not user_input:\n        return None\n    if not os.path.isdir(user_input):\n        try:\n            os.makedirs(user_input)\n        except OSError:\n            return None\n    return user_input"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nquerying the user for a path or file to be saved into the folder or file.", "response": "def save_folder_cmd_line(query, default_name=None, default_path=None):\n    \"\"\"Queries the user for a path or file to be saved into\n\n    The folder or file has not to be created already and will not be created by this function. The parent directory\n    of folder and file has to exist otherwise the function will return None.\n\n    :param str query: Query that asks the user for a specific folder/file path to be created\n    :param str default_name: Default name of the folder to be created\n    :param str default_path: Path in which the folder is created if the user doesn't specify a path\n    :return: Input path from the user or `default_path` if nothing is specified and None if directory does not exist\n    :rtype: str\n    \"\"\"\n    default = None\n    if default_name and default_path:\n        default = os.path.join(default_path, default_name)\n    user_input = input(query + ' [default {}]: '.format(default))\n    if len(user_input) == 0:\n        user_input = default\n\n    if not user_input or not os.path.isdir(os.path.dirname(user_input)):\n        return None\n    return user_input"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncall when the View was registered", "response": "def register_view(self, view):\n        \"\"\"Called when the View was registered\n        \"\"\"\n        super(StateTransitionsListController, self).register_view(view)\n\n        def cell_text(column, cell_renderer, model, iter, data):\n            t_id = model.get_value(iter, self.ID_STORAGE_ID)\n            in_external = 'external' if model.get_value(iter, self.IS_EXTERNAL_STORAGE_ID) else 'internal'\n            # print(t_id, in_external, self.combo[in_external])\n            if column.get_title() == 'Source State':\n                cell_renderer.set_property(\"model\", self.combo[in_external][t_id]['from_state'])\n                cell_renderer.set_property(\"text-column\", 0)\n                cell_renderer.set_property(\"has-entry\", False)\n            elif column.get_title() == 'Source Outcome':\n                cell_renderer.set_property(\"model\", self.combo[in_external][t_id]['from_outcome'])\n                cell_renderer.set_property(\"text-column\", 0)\n                cell_renderer.set_property(\"has-entry\", False)\n            elif column.get_title() == 'Target State':\n                cell_renderer.set_property(\"model\", self.combo[in_external][t_id]['to_state'])\n                cell_renderer.set_property(\"text-column\", 0)\n                cell_renderer.set_property(\"has-entry\", False)\n            elif column.get_title() == 'Target Outcome':\n                cell_renderer.set_property(\"model\", self.combo[in_external][t_id]['to_outcome'])\n                cell_renderer.set_property(\"text-column\", 0)\n                cell_renderer.set_property(\"has-entry\", False)\n            else:\n                logger.warning(\"Column has no cell_data_func %s %s\" % (column.get_name(), column.get_title()))\n\n        view['from_state_col'].set_cell_data_func(view['from_state_combo'], cell_text)\n        view['to_state_col'].set_cell_data_func(view['to_state_combo'], cell_text)\n        view['from_outcome_col'].set_cell_data_func(view['from_outcome_combo'], cell_text)\n        view['to_outcome_col'].set_cell_data_func(view['to_outcome_combo'], cell_text)\n\n        if self.model.state.get_next_upper_library_root_state():\n            view['from_state_combo'].set_property(\"editable\", False)\n            view['from_outcome_combo'].set_property(\"editable\", False)\n            view['to_state_combo'].set_property(\"editable\", False)\n            view['to_outcome_combo'].set_property(\"editable\", False)\n        else:\n            self.connect_signal(view['from_state_combo'], \"edited\", self.on_combo_changed_from_state)\n            self.connect_signal(view['from_outcome_combo'], \"edited\", self.on_combo_changed_from_outcome)\n            self.connect_signal(view['to_state_combo'], \"edited\", self.on_combo_changed_to_state)\n            self.connect_signal(view['to_outcome_combo'], \"edited\", self.on_combo_changed_to_outcome)\n\n        view.tree_view.connect(\"grab-focus\", self.on_focus)\n        self.update(initiator='\"register view\"')"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef remove_core_element(self, model):\n        assert model.transition.parent is self.model.state or model.transition.parent is self.model.parent.state\n        gui_helper_state_machine.delete_core_element_of_model(model)", "response": "Removes respective core element of handed transition model"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_possible_combos_for_transition(trans, model, self_model, is_external=False):\n        from_state_combo = Gtk.ListStore(GObject.TYPE_STRING, GObject.TYPE_STRING)\n        from_outcome_combo = Gtk.ListStore(GObject.TYPE_STRING)\n        to_state_combo = Gtk.ListStore(GObject.TYPE_STRING)\n        to_outcome_combo = Gtk.ListStore(GObject.TYPE_STRING)\n\n        trans_dict = model.state.transitions\n\n        # get from state\n        if trans is None:\n            from_state = None\n        elif trans.from_state is not None:\n            from_state = model.state.states[trans.from_state]\n        else:\n            from_state = model.state if is_external else self_model.state\n\n        # collect all free from-outcome-combo and from_state which are still valid -> filter all outcome already in use\n        free_from_outcomes_dict = {}\n        for state in model.state.states.values():\n            from_o_combo = state.outcomes.values()\n            # print([o.outcome_id for o in from_o_combo], state_model.state.state_id)\n            for transition in trans_dict.values():\n                # print(transition, [[o.outcome_id == transition.from_outcome, transition.from_state == state_model.state.state_id] for o in from_o_combo])\n                from_o_combo = [o for o in from_o_combo if not (o.outcome_id == transition.from_outcome and\n                                                     transition.from_state == state.state_id)]\n                # print([o.outcome_id for o in from_o_combo])\n            if len(from_o_combo) > 0:\n                free_from_outcomes_dict[state.state_id] = from_o_combo\n        # check if parent has start_state\n        if model.state.start_state_id is None:\n            free_from_outcomes_dict[model.state.state_id] = [None]\n\n        # for from-state-combo use all states with free outcomes and from_state\n        combined_states = [model.state] if is_external else [self_model.state]\n        combined_states.extend(model.state.states.values())\n        free_from_states = [state for state in combined_states if state.state_id in free_from_outcomes_dict]\n\n        if trans is None:\n            return None, None, None, None, free_from_states, free_from_outcomes_dict\n\n        def append_from_state_combo(possible_state):\n            if possible_state.state_id == self_model.state.state_id:\n                from_state_combo.append(['self.' + possible_state.state_id, possible_state.state_id])\n            elif is_external and from_state.state_id == model.state.state_id:\n                from_state_combo.append(['parent.' + possible_state.state_id, possible_state.state_id])\n            else:\n                from_state_combo.append([possible_state.name + '.' + possible_state.state_id, possible_state.state_id])\n\n        append_from_state_combo(from_state)\n        for state in free_from_states:\n            if from_state is not state:\n                append_from_state_combo(state)\n\n        # for from-outcome-combo collect all combos for actual transition\n        # -> actual outcome + free outcomes of actual from_state.state_id\n        if trans is not None:\n            if trans.from_outcome is None:\n                from_outcome_combo.append([\"None\"])\n            else:\n                outcome = from_state.outcomes[trans.from_outcome]\n                from_outcome_combo.append([outcome.name + \".\" + str(outcome.outcome_id)])\n            for outcome in free_from_outcomes_dict.get(from_state.state_id, []):\n                if outcome is None:\n                    from_outcome_combo.append([\"None\"])\n                else:\n                    from_outcome_combo.append([outcome.name + \".\" + str(outcome.outcome_id)])\n\n        # get to state\n        if trans.to_state == model.state.state_id:\n            to_state = model.state if is_external else self_model.state\n        else:\n            to_state = model.state.states[trans.to_state]\n\n        # for to-state-combo filter from_state -> first actual to_state + other optional states\n        def generate_to_state_combo(possible_state):\n            if possible_state.state_id == self_model.state.state_id:\n                to_state_combo.append([\"self.\" + possible_state.state_id])\n            elif is_external and possible_state.state_id == model.state.state_id:\n                to_state_combo.append(['parent.' + possible_state.state_id])\n            else:\n                to_state_combo.append([possible_state.name + '.' + possible_state.state_id])\n\n        to_states = [model.state] if is_external else [self_model.state]\n        to_states.extend(model.state.states.values())\n        generate_to_state_combo(to_state)\n        for state in to_states:\n            if not to_state.state_id == state.state_id:\n                generate_to_state_combo(state)\n\n        # for to-outcome-combo use parent combos -> first actual outcome + other outcome\n        def append_to_outcome_combo(possible_outcome):\n            if is_external:\n                to_outcome_combo.append(['parent.' + possible_outcome.name + \".\" + str(possible_outcome.outcome_id)])\n            else:\n                to_outcome_combo.append(['self.' + possible_outcome.name + \".\" + str(possible_outcome.outcome_id)])\n\n        if trans.to_outcome is not None:\n            append_to_outcome_combo(model.state.outcomes[trans.to_outcome])\n        for outcome in model.state.outcomes.values():\n            if not (trans.to_outcome == outcome.outcome_id and trans.to_state == model.state.state_id):\n                append_to_outcome_combo(outcome)\n\n        return from_state_combo, from_outcome_combo, to_state_combo, to_outcome_combo, free_from_states, free_from_outcomes_dict", "response": "This function returns a list of possible combos for a transition and its respective state."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _update_internal_data_base(self):\n\n        model = self.model\n\n        # print(\"clean data base\")\n\n        ### FOR COMBOS\n        # internal transitions\n        # - take all internal states\n        # - take all not used internal outcomes of this states\n\n        # external transitions\n        # - take all external states\n        # - take all external outcomes\n        # - take all not used own outcomes\n\n        ### LINKING\n        # internal  -> transition_id -> from_state = outcome combos\n        #           -> ...\n        # external -> state -> outcome combos\n        self.combo['internal'] = {}\n        self.combo['external'] = {}\n        self.combo['free_from_states'] = {}\n        self.combo['free_from_outcomes_dict'] = {}\n        self.combo['free_ext_from_outcomes_dict'] = {}\n        self.combo['free_ext_from_outcomes_dict'] = {}\n\n        if isinstance(model, ContainerStateModel):\n            # check for internal combos\n            for transition_id, transition in model.state.transitions.items():\n                self.combo['internal'][transition_id] = {}\n\n                [from_state_combo, from_outcome_combo,\n                 to_state_combo, to_outcome_combo,\n                 free_from_states, free_from_outcomes_dict] = \\\n                    self.get_possible_combos_for_transition(transition, self.model, self.model)\n\n                self.combo['internal'][transition_id]['from_state'] = from_state_combo\n                self.combo['internal'][transition_id]['from_outcome'] = from_outcome_combo\n                self.combo['internal'][transition_id]['to_state'] = to_state_combo\n                self.combo['internal'][transition_id]['to_outcome'] = to_outcome_combo\n\n                self.combo['free_from_states'] = free_from_states\n                self.combo['free_from_outcomes_dict'] = free_from_outcomes_dict\n\n            if not model.state.transitions:\n                [x, y, z, v, free_from_states, free_from_outcomes_dict] = \\\n                    self.get_possible_combos_for_transition(None, self.model, self.model)\n                self.combo['free_from_states'] = free_from_states\n                self.combo['free_from_outcomes_dict'] = free_from_outcomes_dict\n        # TODO check why the can happen should not be handed always the LibraryStateModel\n        if not (self.model.state.is_root_state or self.model.state.is_root_state_of_library):\n            # check for external combos\n            for transition_id, transition in model.parent.state.transitions.items():\n                if transition.from_state == model.state.state_id or transition.to_state == model.state.state_id:\n                    self.combo['external'][transition_id] = {}\n\n                    [from_state_combo, from_outcome_combo,\n                     to_state_combo, to_outcome_combo,\n                     free_from_states, free_from_outcomes_dict] = \\\n                        self.get_possible_combos_for_transition(transition, self.model.parent, self.model, True)\n\n                    self.combo['external'][transition_id]['from_state'] = from_state_combo\n                    self.combo['external'][transition_id]['from_outcome'] = from_outcome_combo\n                    self.combo['external'][transition_id]['to_state'] = to_state_combo\n                    self.combo['external'][transition_id]['to_outcome'] = to_outcome_combo\n\n                    self.combo['free_ext_from_states'] = free_from_states\n                    self.combo['free_ext_from_outcomes_dict'] = free_from_outcomes_dict\n\n            if not model.parent.state.transitions:\n                [x, y, z, v, free_from_states, free_from_outcomes_dict] = \\\n                    self.get_possible_combos_for_transition(None, self.model.parent, self.model, True)\n                self.combo['free_ext_from_states'] = free_from_states\n                self.combo['free_ext_from_outcomes_dict'] = free_from_outcomes_dict", "response": "Updates internal data base based on the current state and model."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nupdating the TreeStore according internal combo knowledge gained by the internal data base function call.", "response": "def _update_tree_store(self):\n        \"\"\" Updates TreeStore of the Gtk.ListView according internal combo knowledge gained by\n        _update_internal_data_base function call.\n        \"\"\"\n\n        self.list_store.clear()\n        if self.view_dict['transitions_internal'] and isinstance(self.model, ContainerStateModel) and \\\n                len(self.model.state.transitions) > 0:\n            for transition_id in self.combo['internal'].keys():\n                # print(\"TRANSITION_ID: \", transition_id, self.model.state.transitions)\n                t = self.model.state.transitions[transition_id]\n\n                if t.from_state is not None:\n                    from_state = self.model.state.states[t.from_state]\n                    from_state_label = from_state.name\n                    from_outcome_label = from_state.outcomes[t.from_outcome].name\n                else:\n                    from_state_label = \"self (\" + self.model.state.name + \")\"\n                    from_outcome_label = \"\"\n\n                if t.to_state is None:\n                    to_state_label = \"self (\" + self.model.state.name + \")\"\n                    to_outcome = None if t.to_outcome is None else self.model.state.outcomes[t.to_outcome]\n                    to_outcome_label = \"None\" if to_outcome is None else to_outcome.name\n                else:\n                    # print(t.to_state, self.model.states)\n                    if t.to_state == self.model.state.state_id:\n                        to_state_label = \"self (\" + self.model.state.name + \")\"\n                        to_outcome_label = self.model.state.outcomes[t.to_outcome].name\n                    else:\n                        to_state_label = self.model.state.states[t.to_state].name\n                        to_outcome_label = None\n\n                self.list_store.append([transition_id,  # id\n                                        from_state_label,  # from-state\n                                        from_outcome_label,  # from-outcome\n                                        to_state_label,  # to-state\n                                        to_outcome_label,  # to-outcome\n                                        False,  # is_external\n                                        t,\n                                        self.model.state,\n                                        True,\n                                        self.model.get_transition_m(transition_id)])\n\n        if self.view_dict['transitions_external'] and self.model.parent and \\\n                len(self.model.parent.state.transitions) > 0:\n            for transition_id in self.combo['external'].keys():\n                # print(\"TRANSITION_ID: \", transition_id, self.model.parent.state.transitions)\n                try:\n                    t = self.model.parent.state.transitions[transition_id]\n                    # logger.info(str(t))\n                    from_state = None\n                    if t.from_state is not None:\n                        from_state = self.model.parent.states[t.from_state].state\n\n                    if from_state is None:\n                        from_state_label = \"parent (\" + self.model.state.parent.name + \")\"\n                        from_outcome_label = \"\"\n                    elif from_state.state_id == self.model.state.state_id:\n                        from_state_label = \"self (\" + from_state.name + \")\"\n                        from_outcome_label = from_state.outcomes[t.from_outcome].name\n                    else:\n                        from_state_label = from_state.name\n                        from_outcome_label = from_state.outcomes[t.from_outcome].name\n\n                    if t.to_state == self.model.parent.state.state_id:\n                        to_state_label = 'parent (' + self.model.parent.state.name + \")\"\n                        to_outcome_label = self.model.parent.state.outcomes[t.to_outcome].name\n                    else:\n                        if t.to_state == self.model.state.state_id:\n                            to_state_label = \"self (\" + self.model.state.name + \")\"\n                        else:\n                            to_state_label = self.model.parent.state.states[t.to_state].name\n                        to_outcome_label = None\n\n                    self.list_store.append([transition_id,  # id\n                                            from_state_label,  # from-state\n                                            from_outcome_label,  # from-outcome\n                                            to_state_label,  # to-state\n                                            to_outcome_label,  # to-outcome\n                                            True,  # is_external\n                                            t,\n                                            self.model.state,\n                                            True,\n                                            self.model.parent.get_transition_m(transition_id)])\n                except Exception as e:\n                    logger.warning(\"There was a problem while updating the data-flow widget TreeStore. {0}\".format(e))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef register_actions(self, shortcut_manager):\n        shortcut_manager.add_callback_for_action(\"delete\", self.trans_list_ctrl.remove_action_callback)\n        shortcut_manager.add_callback_for_action(\"add\", self.trans_list_ctrl.add_action_callback)", "response": "Register callback methods for triggered actions\n       "}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nmoves the dirt_lock file to the state machine folder", "response": "def move_dirty_lock_file(dirty_lock_file, sm_path):\n    \"\"\" Move the dirt_lock file to the sm_path and thereby is not found by auto recovery of backup anymore \"\"\"\n    if dirty_lock_file is not None \\\n            and not dirty_lock_file == os.path.join(sm_path, dirty_lock_file.split(os.sep)[-1]):\n        logger.debug(\"Move dirty lock from root tmp folder {0} to state machine folder {1}\"\n                     \"\".format(dirty_lock_file, os.path.join(sm_path, dirty_lock_file.split(os.sep)[-1])))\n        os.rename(dirty_lock_file, os.path.join(sm_path, dirty_lock_file.split(os.sep)[-1]))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef write_backup_meta_data(self):\n        auto_backup_meta_file = os.path.join(self._tmp_storage_path, FILE_NAME_AUTO_BACKUP)\n        storage.storage_utils.write_dict_to_json(self.meta, auto_backup_meta_file)", "response": "Write the auto backup meta data into the current tmp - storage path"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nupdates the auto backup meta data with the internal recovery information", "response": "def update_last_backup_meta_data(self):\n        \"\"\"Update the auto backup meta data with internal recovery information\"\"\"\n        self.meta['last_backup']['time'] = get_time_string_for_float(self.last_backup_time)\n        self.meta['last_backup']['file_system_path'] = self._tmp_storage_path\n        self.meta['last_backup']['marked_dirty'] = self.state_machine_model.state_machine.marked_dirty"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef update_last_sm_origin_meta_data(self):\n        # TODO finally maybe remove this when all backup features are integrated into one backup-structure\n        # data also used e.g. to backup tabs\n        self.meta['last_saved']['time'] = self.state_machine_model.state_machine.last_update\n        self.meta['last_saved']['file_system_path'] = self.state_machine_model.state_machine.file_system_path", "response": "Update the auto backup meta data with information of the state machine origin"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _check_for_dyn_timed_auto_backup(self):\n        current_time = time.time()\n        self.timer_request_lock.acquire()\n        # sm = self.state_machine_model.state_machine\n        # TODO check for self._timer_request_time is None to avoid and reset auto-backup in case and fix it better\n        if self._timer_request_time is None:\n            # logger.warning(\"timer_request is None\")\n            return self.timer_request_lock.release()\n        if self.timed_temp_storage_interval < current_time - self._timer_request_time:\n            # logger.info(\"{0} Perform timed auto-backup of state-machine {1}.\".format(time.time(),\n            #                                                                          sm.state_machine_id))\n            self.check_for_auto_backup(force=True)\n        else:\n            duration_to_wait = self.timed_temp_storage_interval - (current_time - self._timer_request_time)\n            hard_limit_duration_to_wait = self.force_temp_storage_interval - (current_time - self.last_backup_time)\n            hard_limit_active = hard_limit_duration_to_wait < duration_to_wait\n            # logger.info('{2} restart_thread {0} time to go {1}, hard limit {3}'.format(sm.state_machine_id,\n            #                                                                            duration_to_wait, time.time(),\n            #                                                                            hard_limit_active))\n            if hard_limit_active:\n                self.set_timed_thread(hard_limit_duration_to_wait, self.check_for_auto_backup, True)\n            else:\n                self.set_timed_thread(duration_to_wait, self._check_for_dyn_timed_auto_backup)\n        self.timer_request_lock.release()", "response": "This method checks if the state - machine is already backupd and if so restarts the thread if it is not already backupd."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef check_for_auto_backup(self, force=False):\n        if not self.timed_temp_storage_enabled:\n            return\n\n        sm = self.state_machine_model.state_machine\n        current_time = time.time()\n\n        if not self.only_fix_interval and not self.marked_dirty:\n            # logger.info(\"adjust last_backup_time \" + str(sm.state_machine_id))\n            self.last_backup_time = current_time         # used as 'last-modification-not-backup-ed' time\n\n        is_not_timed_or_reached_time_to_force = \\\n            current_time - self.last_backup_time > self.force_temp_storage_interval or self.only_fix_interval\n\n        if (sm.marked_dirty and is_not_timed_or_reached_time_to_force) or force:\n            if not self.only_fix_interval or self.marked_dirty:\n                thread = threading.Thread(target=self.perform_temp_storage)\n                thread.start()\n                # self.last_backup_time = current_time  # used as 'last-backup' time\n            if self.only_fix_interval:\n                self.set_timed_thread(self.force_temp_storage_interval, self.check_for_auto_backup)\n        else:\n            if not self.only_fix_interval:\n                self.timer_request_lock.acquire()\n                if self._timer_request_time is None:\n                    # logger.info('{0} start_thread {1}'.format(current_time, sm.state_machine_id))\n                    self._timer_request_time = current_time\n                    self.set_timed_thread(self.timed_temp_storage_interval, self._check_for_dyn_timed_auto_backup)\n                else:\n                    # logger.info('{0} update_thread {1}'.format(current_time, sm.state_machine_id))\n                    self._timer_request_time = current_time\n                self.timer_request_lock.release()\n            else:\n                self.set_timed_thread(self.force_temp_storage_interval, self.check_for_auto_backup)", "response": "Private method to check for possible auto backup of the state - machine according duration till\n       ."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef on_drag_data_get(self, widget, context, data, info, time):\n        import rafcon.gui.helpers.state_machine as gui_helper_state_machine\n        state = self._get_state()\n        gui_helper_state_machine.add_state_by_drag_and_drop(state, data)", "response": "dragged state is inserted and its state_id sent to the receiver"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef on_mouse_click(self, widget, event):\n        import rafcon.gui.helpers.state_machine as gui_helper_state_machine\n        if self.view.get_path_at_pos(int(event.x), int(event.y)) is not None \\\n                and len(self.view.get_selected_items()) > 0:\n            return gui_helper_state_machine.insert_state_into_selected_state(self._get_state(), False)", "response": "state insertion on mouse click"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _get_state(self):\n\n        selected = self.view.get_selected_items()\n        if not selected:\n            return\n        shorthand, state_class = self.view.states[selected[0][0]]\n        return state_class()", "response": "get state instance which was clicked on\n       "}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a string that contains all elements of a notification info - dictionary of gtkmvc3 or Signal and all levels of calls defined by kwargs.", "response": "def get_nice_info_dict_string(self, info, level='\\t', overview=None):\n        \"\"\" Inserts all elements of a notification info-dictionary of gtkmvc3 or a Signal into one string and indicates\n        levels of calls defined by 'kwargs'. Additionally, the elements get structured into a dict that holds all levels\n        of the general notification key-value pairs in faster accessible lists. The dictionary has the element 'type'\n        and the general elements {'model': [], 'prop_name': [], 'instance': [], 'method_name': [], 'args': [],\n        'kwargs': []}) plus specific elements according the type. Type is always one of the following list\n        ['before', 'after', 'signal'].\n        \"\"\"\n        def get_nice_meta_signal_msg_tuple_string(meta_signal_msg_tuple, level, overview):\n            meta_signal_dict = {}\n            # origin\n            s = \"\\n{0}origin={1}\".format(level + \"\\t\", meta_signal_msg_tuple.origin)\n            meta_signal_dict['origin'] = meta_signal_msg_tuple.origin\n            # change\n            s += \"\\n{0}change={1}\".format(level + \"\\t\", meta_signal_msg_tuple.change)\n            meta_signal_dict['change'] = meta_signal_msg_tuple.change\n            # affects_children\n            s += \"\\n{0}affects_children={1}\".format(level + \"\\t\", meta_signal_msg_tuple.affects_children)\n            meta_signal_dict['affects_children'] = meta_signal_msg_tuple.affects_children\n            overview['signal'].append(meta_signal_dict)\n\n            # notification (tuple)\n            notification_dict = {}\n            meta_signal_dict['notification'] = notification_dict\n            if meta_signal_msg_tuple.notification is None:\n                s += \"\\n{0}notification={1}\".format(level + \"\\t\", meta_signal_msg_tuple.notification)\n            else:\n                s += \"\\n{0}notification=Notification(\".format(level + \"\\t\")\n                # model\n                notification_dict['model'] = meta_signal_msg_tuple.notification.model\n                s += \"\\n{0}model={1}\".format(level + \"\\t\\t\", meta_signal_msg_tuple.notification.model)\n                # prop_name\n                notification_dict['prop_name'] = meta_signal_msg_tuple.notification.prop_name\n                s += \"\\n{0}prop_name={1}\".format(level + \"\\t\\t\", meta_signal_msg_tuple.notification.prop_name)\n                # info\n                notification_dict['info'] = meta_signal_msg_tuple.notification.info\n                overview['kwargs'].append(meta_signal_msg_tuple.notification.info)\n                s += \"\\n{0}info=\\n{1}{0}\\n\".format(level + \"\\t\\t\",\n                                               self.get_nice_info_dict_string(meta_signal_msg_tuple.notification.info,\n                                                                              level+'\\t\\t\\t',\n                                                                              overview))\n            return s\n\n        def get_nice_action_signal_msg_tuple_string(meta_signal_msg_tuple, level, overview):\n            meta_signal_dict = {}\n            # after\n            s = \"\\n{0}after={1}\".format(level + \"\\t\", meta_signal_msg_tuple.after)\n            meta_signal_dict['after'] = meta_signal_msg_tuple.after\n            # action\n            s += \"\\n{0}action={1}\".format(level + \"\\t\", meta_signal_msg_tuple.action)\n            meta_signal_dict['action'] = meta_signal_msg_tuple.action\n            # origin\n            s += \"\\n{0}origin={1}\".format(level + \"\\t\", meta_signal_msg_tuple.origin)\n            meta_signal_dict['origin'] = meta_signal_msg_tuple.origin\n            # origin\n            s += \"\\n{0}action_parent_m={1}\".format(level + \"\\t\", meta_signal_msg_tuple.action_parent_m)\n            meta_signal_dict['action_parent_m'] = meta_signal_msg_tuple.origin\n            # change\n            s += \"\\n{0}affected_models={1}\".format(level + \"\\t\", meta_signal_msg_tuple.affected_models)\n            meta_signal_dict['affected_models'] = meta_signal_msg_tuple.affected_models\n            if meta_signal_msg_tuple.after:\n                s += \"\\n{0}result={1}\".format(level + \"\\t\", meta_signal_msg_tuple.result)\n                meta_signal_dict['result'] = meta_signal_msg_tuple.result\n\n            return s\n\n\n        overview_was_none = False\n        if overview is None:\n            overview_was_none = True\n            overview = dict({'model': [], 'prop_name': [], 'instance': [], 'method_name': [], 'args': [], 'kwargs': []})\n            overview['others'] = []\n            overview['info'] = []\n            if 'before' in info:\n                overview['type'] = 'before'\n            elif 'after' in info:\n                overview['type'] = 'after'\n                overview['result'] = []\n            else:  # 'signal' in info:\n                overview['type'] = 'signal'\n                overview['signal'] = []\n\n        if ('after' in info or 'before' in info or 'signal' in info) and 'model' in info:\n            if 'before' in info:\n                s = \"{0}'before': {1}\".format(level, info['before'])\n            elif 'after' in info:\n                s = \"{0}'after': {1}\".format(level, info['after'])\n            else:\n                s = \"{0}'signal': {1}\".format(level, info['signal'])\n        else:\n            return str(info)\n        overview['info'].append(info)\n        # model\n        s += \"\\n{0}'model': {1}\".format(level, info['model'])\n        overview['model'].append(info['model'])\n        # prop_name\n        s += \"\\n{0}'prop_name': {1}\".format(level, info['prop_name'])\n        overview['prop_name'].append(info['prop_name'])\n        if not overview['type'] == 'signal':\n            # instance\n            s += \"\\n{0}'instance': {1}\".format(level, info['instance'])\n            overview['instance'].append(info['instance'])\n            # method_name\n            s += \"\\n{0}'method_name': {1}\".format(level, info['method_name'])\n            overview['method_name'].append(info['method_name'])\n            # args\n            s += \"\\n{0}'args': {1}\".format(level, info['args'])\n            overview['args'].append(info['args'])\n\n            overview['kwargs'].append(info['kwargs'])\n            if overview['type'] == 'after':\n                overview['result'].append(info['result'])\n            # kwargs\n            s += \"\\n{0}'kwargs': {1}\".format(level, self.get_nice_info_dict_string(info['kwargs'],\n                                                                                   level + \"\\t\",\n                                                                                   overview))\n            if overview['type'] == 'after':\n                s += \"\\n{0}'result': {1}\".format(level, info['result'])\n            # additional elements not created by gtkmvc3 or common function calls\n            overview['others'].append({})\n            for key, value in info.items():\n                if key in ['before', 'after', 'model', 'prop_name', 'instance', 'method_name', 'args', 'kwargs', 'result']:\n                    pass\n                else:\n                    s += \"\\n{0}'{2}': {1}\".format(level, info[key], key)\n                    overview['others'][len(overview['others'])-1][key] = info[key]\n        else:\n            overview['kwargs'].append({})\n            # print(info)\n            # print(info['arg'])\n            if isinstance(info['arg'], MetaSignalMsg):\n                overview['signal'].append(info['arg'])\n                s += \"\\n{0}'arg': MetaSignalMsg({1}\".format(level,\n                                                            get_nice_meta_signal_msg_tuple_string(info['arg'],\n                                                                                                  level,\n                                                                                                  overview))\n            elif isinstance(info['arg'], ActionSignalMsg):\n                overview['instance'].append(info['arg'].action_parent_m.core_element)\n                overview['method_name'].append(info['arg'].action)\n                overview['signal'].append(info['arg'])\n                overview['kwargs'].append(info['arg'].kwargs)\n                # TODO check again this stuff\n                args = [info['arg'].action_parent_m.core_element, ]\n                args.extend(info['arg'].kwargs.values())\n                overview['args'].append(args)\n                s += \"\\n{0}'arg': ActionSignalMsg({1}\".format(level,\n                                                              get_nice_action_signal_msg_tuple_string(info['arg'],\n                                                                                                      level,\n                                                                                                      overview))\n            else:\n                raise str(info)\n\n        if overview_was_none:\n            return s, overview\n        else:\n            return s"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef register_view(self, view):\n        super(StateOutcomesListController, self).register_view(view)\n        if isinstance(view, StateOutcomesTreeView):\n            self.connect_signal(view['to_state_combo'], \"edited\", self.on_to_state_edited)\n            self.connect_signal(view['to_outcome_combo'], \"edited\", self.on_to_outcome_edited)\n\n        if isinstance(self.model.state, LibraryState) or self.model.state.get_next_upper_library_root_state():\n            view['id_cell'].set_property('editable', False)\n            view['name_cell'].set_property('editable', False)\n\n        self._apply_value_on_edited_and_focus_out(view['name_cell'], self.apply_new_outcome_name)\n\n        self.update(initiator='\"register view\"')", "response": "Called when the view was registered"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\napplies the newly entered outcome name it is was changed", "response": "def apply_new_outcome_name(self, path, new_name):\n        \"\"\"Apply the newly entered outcome name it is was changed\n\n        :param str path: The path string of the renderer\n        :param str new_name: Newly entered outcome name\n        \"\"\"\n        # Don't do anything if outcome name didn't change\n        if new_name == self.list_store[path][self.NAME_STORAGE_ID]:\n            return\n\n        outcome = self.list_store[path][self.CORE_STORAGE_ID]\n        try:\n            outcome.name = new_name\n            logger.debug(\"Outcome name changed to '{0}'\".format(outcome.name))\n        except (ValueError, TypeError) as e:\n            logger.warning(\"The name of the outcome could not be changed: {0}\".format(e))\n        self.list_store[path][self.NAME_STORAGE_ID] = outcome.name"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef on_to_state_edited(self, renderer, path, new_state_identifier):\n        def do_self_transition_check(t_id, new_state_identifier):\n            # add self transition meta data\n            if 'self' in new_state_identifier.split('.'):\n                insert_self_transition_meta_data(self.model, t_id, 'outcomes_widget', combined_action=True)\n\n        outcome_id = self.list_store[path][self.ID_STORAGE_ID]\n        if outcome_id in self.dict_to_other_state or outcome_id in self.dict_to_other_outcome:\n            transition_parent_state = self.model.parent.state\n            if outcome_id in self.dict_to_other_state:\n                t_id = self.dict_to_other_state[outcome_id][2]\n            else:\n                t_id = self.dict_to_other_outcome[outcome_id][2]\n            if new_state_identifier is not None:\n                to_state_id = new_state_identifier.split('.')[1]\n                if not transition_parent_state.transitions[t_id].to_state == to_state_id:\n                    try:\n                        transition_parent_state.transitions[t_id].modify_target(to_state=to_state_id)\n                        do_self_transition_check(t_id, new_state_identifier)\n                    except ValueError as e:\n                        logger.warning(\"The target of transition couldn't be modified: {0}\".format(e))\n            else:\n                try:\n                    transition_parent_state.remove_transition(t_id)\n                except AttributeError as e:\n                    logger.warning(\"The transition couldn't be removed: {0}\".format(e))\n        else:  # there is no transition till now\n            if new_state_identifier is not None and not self.model.state.is_root_state:\n                transition_parent_state = self.model.parent.state\n                to_state_id = new_state_identifier.split('.')[1]\n                try:\n                    t_id = transition_parent_state.add_transition(from_state_id=self.model.state.state_id,\n                                                                  from_outcome=outcome_id,\n                                                                  to_state_id=to_state_id,\n                                                                  to_outcome=None, transition_id=None)\n                    do_self_transition_check(t_id, new_state_identifier)\n                except (ValueError, TypeError) as e:\n                    logger.warning(\"The transition couldn't be added: {0}\".format(e))\n                    return\n            else:\n                logger.debug(\"outcome-editor got None in to_state-combo-change no transition is added\")", "response": "Connects the outcome with a transition to the newly set state"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nconnect the outcome with a transition to the newly set outcome", "response": "def on_to_outcome_edited(self, renderer, path, new_outcome_identifier):\n        \"\"\"Connects the outcome with a transition to the newly set outcome\n\n        :param Gtk.CellRendererText renderer: The cell renderer that was edited\n        :param str path: The path string of the renderer\n        :param str new_outcome_identifier: An identifier for the new outcome that was selected\n        \"\"\"\n        if self.model.parent is None:\n            return\n        outcome_id = self.list_store[path][self.ID_STORAGE_ID]\n        transition_parent_state = self.model.parent.state\n        if outcome_id in self.dict_to_other_state or outcome_id in self.dict_to_other_outcome:\n            if outcome_id in self.dict_to_other_state:\n                t_id = self.dict_to_other_state[outcome_id][2]\n            else:\n                t_id = self.dict_to_other_outcome[outcome_id][2]\n            if new_outcome_identifier is not None:\n                new_to_outcome_id = int(new_outcome_identifier.split('.')[2])\n                if not transition_parent_state.transitions[t_id].to_outcome == new_to_outcome_id:\n                    to_state_id = self.model.parent.state.state_id\n                    try:\n                        transition_parent_state.transitions[t_id].modify_target(to_state=to_state_id,\n                                                                                to_outcome=new_to_outcome_id)\n                    except ValueError as e:\n                        logger.warning(\"The target of transition couldn't be modified: {0}\".format(e))\n            else:\n\n                transition_parent_state.remove_transition(t_id)\n        else:  # there is no transition till now\n            if new_outcome_identifier is not None:\n                to_outcome = int(new_outcome_identifier.split('.')[2])\n\n                try:\n                    self.model.parent.state.add_transition(from_state_id=self.model.state.state_id,\n                                                           from_outcome=outcome_id,\n                                                           to_state_id=self.model.parent.state.state_id,\n                                                           to_outcome=to_outcome, transition_id=None)\n                except (ValueError, TypeError) as e:\n                    logger.warning(\"The transition couldn't be added: {0}\".format(e))\n            else:\n                logger.debug(\"outcome-editor got None in to_outcome-combo-change no transition is added\")"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nremove respective core element of handed outcome model", "response": "def remove_core_element(self, model):\n        \"\"\"Remove respective core element of handed outcome model\n\n        :param OutcomeModel model: Outcome model which core element should be removed\n        :return:\n        \"\"\"\n        assert model.outcome.parent is self.model.state\n        gui_helper_state_machine.delete_core_element_of_model(model)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef register_view(self, view):\n        super(StateOutcomesEditorController, self).register_view(view)\n        if isinstance(view, StateOutcomesEditorView):\n            self.connect_signal(view['add_button'], \"clicked\", self.oc_list_ctrl.on_add)\n            self.connect_signal(view['remove_button'], \"clicked\", self.oc_list_ctrl.on_remove)\n\n            if isinstance(self.model.state, LibraryState) or self.model.state.get_next_upper_library_root_state():\n                view['add_button'].set_sensitive(False)\n                view['remove_button'].set_sensitive(False)", "response": "Called when the view was registered"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nfind tab with label tab_label in list of notebook s and set it to the current page.", "response": "def bring_tab_to_the_top(self, tab_label):\n        \"\"\"Find tab with label tab_label in list of notebook's and set it to the current page.\n\n        :param tab_label: String containing the label of the tab to be focused\n        \"\"\"\n        page = self.page_dict[tab_label]\n        for notebook in self.notebook_names:\n            page_num = self[notebook].page_num(page)\n            if not page_num == -1:\n                self[notebook].set_current_page(page_num)\n                break"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef compare_variables(tree_model, iter1, iter2, user_data=None):\n        path1 = tree_model.get_path(iter1)[0]\n        path2 = tree_model.get_path(iter2)[0]\n        # get key of first variable\n        name1 = tree_model[path1][0]\n        # get key of second variable\n        name2 = tree_model[path2][0]\n        name1_as_bits = ' '.join(format(ord(x), 'b') for x in name1)\n        name2_as_bits = ' '.join(format(ord(x), 'b') for x in name2)\n        if name1_as_bits == name2_as_bits:\n            return 0\n        elif name1_as_bits > name2_as_bits:\n            return 1\n        else:\n            return -1", "response": "Triggered upon updating the list of global variables alphabetically."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef has_dirty_state_machine(self):\n        for sm in self.state_machines.values():\n            if sm.marked_dirty:\n                return True\n        return False", "response": "Checks if one of the state machines contains the marked_dirty flag set to True."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nresets all marked_dirty flags of all state machines to false.", "response": "def reset_dirty_flags(self):\n        \"\"\"Set all marked_dirty flags of the state machine to false.\"\"\"\n        for sm_id, sm in self.state_machines.items():\n            sm.marked_dirty = False"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nadds a state machine to the list of managed state machines.", "response": "def add_state_machine(self, state_machine):\n        \"\"\"Add a state machine to the list of managed state machines. If there is no active state machine set yet,\n            then set as active state machine.\n\n        :param state_machine: State Machine Object\n        :raises exceptions.AttributeError: if the passed state machine was already added of is of a wrong type\n        \"\"\"\n        if not isinstance(state_machine, StateMachine):\n            raise AttributeError(\"State machine must be of type StateMachine\")\n        if state_machine.file_system_path is not None:\n            if self.is_state_machine_open(state_machine.file_system_path):\n                raise AttributeError(\"The state machine is already open {0}\".format(state_machine.file_system_path))\n        logger.debug(\"Add new state machine with id {0}\".format(state_machine.state_machine_id))\n        self._state_machines[state_machine.state_machine_id] = state_machine\n        return state_machine.state_machine_id"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nremove the state machine with the specified id from the list of registered state machines.", "response": "def remove_state_machine(self, state_machine_id):\n        \"\"\"Remove the state machine for a specified state machine id from the list of registered state machines.\n\n        :param state_machine_id: the id of the state machine to be removed\n        \"\"\"\n        import rafcon.core.singleton as core_singletons\n        removed_state_machine = None\n        if state_machine_id in self._state_machines:\n            logger.debug(\"Remove state machine with id {0}\".format(state_machine_id))\n            removed_state_machine = self._state_machines.pop(state_machine_id)\n        else:\n            logger.error(\"There is no state_machine with state_machine_id: %s\" % state_machine_id)\n            return removed_state_machine\n\n        # destroy execution history\n        removed_state_machine.destroy_execution_histories()\n        return removed_state_machine"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_active_state_machine(self):\n        if self._active_state_machine_id in self._state_machines:\n            return self._state_machines[self._active_state_machine_id]\n        else:\n            return None", "response": "Return a reference to the active state - machine"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a reference to the state machine with the given file system path if open", "response": "def get_open_state_machine_of_file_system_path(self, file_system_path):\n        \"\"\"Return a reference to the state machine with respective path if open\n        \"\"\"\n        for sm in self.state_machines.values():\n            if sm.file_system_path == file_system_path:\n                return sm"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef reset_title(self, title, notebook_identifier):\n        current_title = self.get_top_widget().get_title()\n        upper_title = current_title.split('/')[0].strip()\n        lower_title = current_title.split('/')[1].strip()\n        if notebook_identifier == 'upper':\n            new_title = title + ' / ' + lower_title\n        else:\n            new_title = upper_title + ' / ' + title\n        self['headerbar'].props.title = new_title", "response": "Triggered whenever a notebook tab is switched in the left bar."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nchecks if the expected_future_models list contains still a specific model", "response": "def negative_check_for_model_in_expected_future_models(target_state_m, model, msg, delete=True, with_logger=None):\n    \"\"\" Checks if the expected future models list/set includes still a specific model\n\n    Return False if the handed model is still in and also creates a warning message as feedback.\n\n    :param StateModel target_state_m: The state model which expected_future_models attribute should be checked\n    :param Model model: Model to check for.\n    :param str msg: Message for the logger if a model is still in.\n    :param bool delete: Flag to delete respective model from list/set.\n    :param with_logger: A optional logger to use in case of logging messages\n    :rtype: bool\n    :return: True if empty and False if still model in set/list\n    \"\"\"\n    if with_logger is None:\n        with_logger = logger\n    # check that the model in the list expected_future_model was used\n    if model in target_state_m.expected_future_models:\n        with_logger.warning(\"{0} -> still in is: {1} Please inform the developer how to reproduce this.\"\n                            \"\".format(msg, model))\n        if delete:\n            # TODO think about to destroy this models\n            target_state_m.expected_future_models.remove(model)\n        return False\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nchecking if the list of expected future models is empty.", "response": "def check_expected_future_model_list_is_empty(target_state_m, msg, delete=True, with_logger=None):\n    \"\"\" Checks if the expected future models list/set is empty\n\n    Return False if there are still elements in and also creates a warning message as feedback.\n\n    :param StateModel target_state_m: The state model which expected_future_models attribute should be checked\n    :param str msg: Message for the logger if a model is still in.\n    :param bool delete: Flag to delete respective model from list/set.\n    :param with_logger: A optional logger to use in case of logging messages\n    :rtype: bool\n    :return: True if empty and False if still model in set/list\n    \"\"\"\n    if with_logger is None:\n        with_logger = logger\n    # check that the model in the list expected_future_model was used\n    if target_state_m.expected_future_models:\n        with_logger.warning(\"{0} -> still in are: {1} Please inform the developer how to reproduce this.\"\n                            \"\".format(msg, target_state_m.expected_future_models))\n        if delete:\n            # TODO think about to destroy this models\n            target_state_m.expected_future_models.clear()\n        return False\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef update_models_recursively(state_m, expected=True):\n\n    assert isinstance(state_m, AbstractStateModel)\n\n    if isinstance(state_m, LibraryStateModel):\n        if not state_m.state_copy_initialized:\n            if not expected:\n                logger.warning(\"State {0} generates unexpected missing state copy models.\".format(state_m))\n            state_m.recursive_generate_models(load_meta_data=False)\n            import rafcon.gui.helpers.meta_data as gui_helper_meta_data\n            gui_helper_meta_data.scale_library_content(state_m)\n\n    if isinstance(state_m, ContainerStateModel):\n        for child_state_m in state_m.states.values():\n            update_models_recursively(child_state_m, expected)", "response": "Recursively creates all \n    and all \nModels"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nadd a state to a container state", "response": "def add_state(container_state_m, state_type):\n    \"\"\"Add a state to a container state\n\n    Adds a state of type state_type to the given container_state\n\n    :param rafcon.gui.models.container_state.ContainerState container_state_m: A model of a container state to add\n      the new state to\n    :param rafcon.core.enums.StateType state_type: The type of state that should be added\n    :return: True if successful, False else\n    \"\"\"\n    if container_state_m is None:\n        logger.error(\"Cannot add a state without a parent.\")\n        return False\n\n    if not isinstance(container_state_m, StateModel) or \\\n            (isinstance(container_state_m, StateModel) and not isinstance(container_state_m, ContainerStateModel)):\n        logger.error(\"Parent state must be a container, for example a Hierarchy State.\" + str(container_state_m))\n        return False\n\n    state_class = state_type_to_state_class_dict.get(state_type, None)\n\n    if state_class is None:\n        logger.error(\"Cannot create state of type {0}\".format(state_type))\n        return False\n\n    new_state = state_class()\n    from rafcon.gui.models.abstract_state import get_state_model_class_for_state\n    new_state_m = get_state_model_class_for_state(new_state)(new_state)\n    gui_helper_meta_data.put_default_meta_on_state_m(new_state_m, container_state_m)\n    container_state_m.expected_future_models.add(new_state_m)\n    container_state_m.state.add_state(new_state)\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef create_new_state_from_state_with_type(source_state, target_state_class):\n\n    current_state_is_container = isinstance(source_state, ContainerState)\n    new_state_is_container = issubclass(target_state_class, ContainerState)\n\n    if current_state_is_container and new_state_is_container:  # TRANSFORM from CONTAINER- TO CONTAINER-STATE\n\n        # by default all transitions are left out if the new and original state are container states\n        # -> because switch from Barrier, Preemptive or Hierarchy has always different rules\n        state_transitions = {}\n        state_start_state_id = None\n        logger.info(\"Type change from %s to %s\" % (type(source_state).__name__, target_state_class.__name__))\n\n        # decider state is removed because it is unique for BarrierConcurrencyState\n        if isinstance(source_state, BarrierConcurrencyState):\n            source_state.remove_state(UNIQUE_DECIDER_STATE_ID, force=True)\n            assert UNIQUE_DECIDER_STATE_ID not in source_state.states\n\n        # separate state-elements from source state\n        data_flows = dict(source_state.data_flows)\n        source_state.data_flows = {}\n        input_data_ports = dict(source_state.input_data_ports)\n        output_data_ports = dict(source_state.output_data_ports)\n        scoped_variables = dict(source_state.scoped_variables)\n        income = source_state.income\n        outcomes = dict(source_state.outcomes)\n        source_state.input_data_ports = {}\n        source_state.output_data_ports = {}\n        source_state.scoped_variables = {}\n        source_state.transitions = {}  # before remove of outcomes related transitions should be gone\n        source_state.income = Income()\n        source_state.outcomes = {}\n        states = dict(source_state.states)\n        # TODO check why next line can not be performed\n        # source_state.states = {}\n\n        new_state = target_state_class(name=source_state.name, state_id=source_state.state_id,\n                                       input_data_ports=input_data_ports,\n                                       output_data_ports=output_data_ports,\n                                       scoped_variables=scoped_variables,\n                                       income=income,\n                                       outcomes=outcomes,\n                                       transitions=state_transitions,\n                                       data_flows=data_flows,\n                                       states=states,\n                                       start_state_id=state_start_state_id)\n\n    else:  # TRANSFORM from EXECUTION- TO CONTAINER-STATE or FROM CONTAINER- TO EXECUTION-STATE\n\n        # in case the new state is an execution state remove of child states (for observable notifications)\n        if current_state_is_container and issubclass(target_state_class, ExecutionState):\n            if isinstance(source_state, BarrierConcurrencyState):\n                source_state.remove_state(UNIQUE_DECIDER_STATE_ID, force=True)\n                assert UNIQUE_DECIDER_STATE_ID not in source_state.states\n            for state_id in list(source_state.states.keys()):\n                source_state.remove_state(state_id)\n\n        # separate state-elements from source state\n        input_data_ports = dict(source_state.input_data_ports)\n        output_data_ports = dict(source_state.output_data_ports)\n        income = source_state.income\n        outcomes = dict(source_state.outcomes)\n        source_state.input_data_ports = {}\n        source_state.output_data_ports = {}\n        source_state.income = Income()\n        source_state.outcomes = {}\n\n        new_state = target_state_class(name=source_state.name, state_id=source_state.state_id,\n                                       input_data_ports=input_data_ports,\n                                       output_data_ports=output_data_ports,\n                                       income=income, outcomes=outcomes)\n\n    if source_state.description is not None and len(source_state.description) > 0:\n        new_state.description = source_state.description\n    new_state.semantic_data = Vividict(source_state.semantic_data)\n    return new_state", "response": "This function duplicates a state with a new type and returns a new state that is a new type."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef extract_child_models_of_state(state_m, new_state_class):\n    # check if root state and which type of state\n    assert isinstance(state_m, StateModel)\n    assert issubclass(new_state_class, State)\n    orig_state = state_m.state  # only here to get the input parameter of the Core-function\n\n    current_state_is_container = isinstance(orig_state, ContainerState)\n    new_state_is_container = issubclass(new_state_class, ContainerState)\n\n    # define which model references to hold for new state\n    required_model_properties = ['input_data_ports', 'output_data_ports', 'outcomes', 'income']\n    obsolete_model_properties = []\n    if current_state_is_container and new_state_is_container:  # hold some additional references\n        # transition are removed when changing the state type, thus do not copy them\n        required_model_properties.extend(['states', 'data_flows', 'scoped_variables'])\n        obsolete_model_properties.append('transitions')\n    elif current_state_is_container:\n        obsolete_model_properties.extend(['states', 'transitions', 'data_flows', 'scoped_variables'])\n\n    def get_element_list(state_m, prop_name):\n        if prop_name == 'income':\n            return [state_m.income]\n        wrapper = getattr(state_m, prop_name)\n        # ._obj is needed as gaphas wraps observable lists and dicts into a gaphas.support.ObsWrapper\n        list_or_dict = wrapper._obj\n        if isinstance(list_or_dict, list):\n            return list_or_dict[:]  # copy list\n        return list(list_or_dict.values())  # dict\n\n    required_child_models = {}\n    for prop_name in required_model_properties:\n        required_child_models[prop_name] = get_element_list(state_m, prop_name)\n    obsolete_child_models = {}\n    for prop_name in obsolete_model_properties:\n        obsolete_child_models[prop_name] = get_element_list(state_m, prop_name)\n\n    # Special handling of BarrierState, which includes the DeciderState that always becomes obsolete\n    if isinstance(state_m, ContainerStateModel):\n        decider_state_m = state_m.states.get(UNIQUE_DECIDER_STATE_ID, None)\n        if decider_state_m:\n            if new_state_is_container:\n                required_child_models['states'].remove(decider_state_m)\n                obsolete_child_models['states'] = [decider_state_m]\n\n    return required_child_models, obsolete_child_models", "response": "This function extracts the child models of the given state model into a dict."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef create_state_model_for_state(new_state, meta, state_element_models):\n    from rafcon.gui.models.abstract_state import get_state_model_class_for_state\n    state_m_class = get_state_model_class_for_state(new_state)\n    new_state_m = state_m_class(new_state, meta=meta, load_meta_data=False, expected_future_models=state_element_models)\n    error_msg = \"New state has not re-used all handed expected future models.\"\n    check_expected_future_model_list_is_empty(new_state_m, msg=error_msg)\n\n    return new_state_m", "response": "Create a new state model with the defined properties"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef prepare_state_m_for_insert_as(state_m_to_insert, previous_state_size):\n    # TODO check how much code is duplicated or could be reused for library fit functionality meta data helper\n    # TODO DO REFACTORING !!! and move maybe the hole method to meta data and rename it\n    if isinstance(state_m_to_insert, AbstractStateModel) and \\\n            not gui_helper_meta_data.model_has_empty_meta(state_m_to_insert):\n\n        if isinstance(state_m_to_insert, ContainerStateModel):\n            # print(\"TARGET1\", state_m_to_insert.state.state_element_attrs)\n            models_dict = {'state': state_m_to_insert}\n\n            for state_element_key in state_m_to_insert.state.state_element_attrs:\n                state_element_list = getattr(state_m_to_insert, state_element_key)\n                # Some models are hold in a gtkmvc3.support.wrappers.ObsListWrapper, not a list\n                if hasattr(state_element_list, 'keys'):\n                    state_element_list = state_element_list.values()\n                models_dict[state_element_key] = {elem.core_element.core_element_id: elem for elem in state_element_list}\n\n            resize_factor = gui_helper_meta_data.scale_meta_data_according_state(models_dict, as_template=True)\n            gui_helper_meta_data.resize_income_of_state_m(state_m_to_insert, resize_factor)\n\n        elif isinstance(state_m_to_insert, StateModel):\n            # print(\"TARGET2\", state_m_to_insert.state.state_element_attrs)\n\n            if previous_state_size:\n                current_size = state_m_to_insert.get_meta_data_editor()['size']\n                factor = gui_helper_meta_data.divide_two_vectors(current_size, previous_state_size)\n                state_m_to_insert.set_meta_data_editor('size', previous_state_size)\n                factor = (min(*factor), min(*factor))\n                gui_helper_meta_data.resize_state_meta(state_m_to_insert, factor)\n            else:\n                logger.debug(\"For insert as template of {0} no resize of state meta data is performed because \"\n                             \"the meta data has empty fields.\".format(state_m_to_insert))\n\n        # library state is not resize because its ports became resized indirectly -> see was resized flag\n        elif not isinstance(state_m_to_insert, LibraryStateModel):\n            raise TypeError(\"For insert as template of {0} no resize of state meta data is performed because \"\n                            \"state model type is not ContainerStateModel or StateModel\".format(state_m_to_insert))\n    else:\n        logger.info(\"For insert as template of {0} no resize of state meta data is performed because the meta data has \"\n                    \"empty fields.\".format(state_m_to_insert))", "response": "Prepares and scales the meta data to fit into actual size of the state."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef insert_state_as(target_state_m, state, as_template):\n\n    if not isinstance(target_state_m, ContainerStateModel) or \\\n            not isinstance(target_state_m.state, ContainerState):\n        logger.error(\"States can only be inserted in container states\")\n        return False\n\n    state_m = get_state_model_class_for_state(state)(state)\n    if not as_template:\n        gui_helper_meta_data.put_default_meta_on_state_m(state_m, target_state_m)\n\n    # If inserted as template, we have to extract the state_copy and respective model\n    else:\n        assert isinstance(state, LibraryState)\n        old_lib_state_m = state_m\n        state_m = state_m.state_copy\n\n        previous_state_size = state_m.get_meta_data_editor()['size']\n        gui_helper_meta_data.put_default_meta_on_state_m(state_m, target_state_m)\n        # TODO check if the not as template case maybe has to be run with the prepare call\n        prepare_state_m_for_insert_as(state_m, previous_state_size)\n\n        old_lib_state_m.prepare_destruction(recursive=False)\n\n    # explicit secure that there is no state_id conflict within target state child states\n    while state_m.state.state_id in target_state_m.state.states:\n        state_m.state.change_state_id()\n\n    target_state_m.expected_future_models.add(state_m)\n    target_state_m.state.add_state(state_m.state)\n\n    # secure possible missing models to be generated\n    update_models_recursively(state_m, expected=False)", "response": "Add a state into a target state"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsubstituting the target state with the new state.", "response": "def substitute_state(target_state_m, state_m_to_insert, as_template=False):\n    \"\"\" Substitutes the target state\n\n    Both, the state to be replaced (the target state) and the state to be inserted (the new state) are passed via\n    parameters.\n    The new state adapts the size and position of the target state.\n    State elements of the new state are resized but kepp their proportion.\n\n    :param rafcon.gui.models.container_state.AbstractStateModel target_state_m: State Model of state to be substituted\n    :param rafcon.gui.models.container_state.StateModel state_m_to_insert: State Model of state to be inserted\n    :return:\n    \"\"\"\n    # print(\"substitute_state\")\n\n    state_to_insert = state_m_to_insert.state\n    action_parent_m = target_state_m.parent\n    old_state_m = target_state_m\n    old_state = old_state_m.state\n    state_id = old_state.state_id\n\n    # BEFORE MODEL\n    tmp_meta_data = {'transitions': {}, 'data_flows': {}, 'state': None}\n    old_state_m = action_parent_m.states[state_id]\n    # print(\"EMIT-BEFORE ON OLD_STATE \", state_id)\n    old_state_m.action_signal.emit(ActionSignalMsg(action='substitute_state', origin='model',\n                                                   action_parent_m=action_parent_m,\n                                                   affected_models=[old_state_m, ], after=False,\n                                                   kwargs={'state_id': state_id, 'state': state_to_insert}))\n    related_transitions, related_data_flows = action_parent_m.state.related_linkage_state(state_id)\n    tmp_meta_data['state'] = old_state_m.meta\n    # print(\"old state meta\", old_state_m.meta)\n    for t in related_transitions['external']['ingoing'] + related_transitions['external']['outgoing']:\n        tmp_meta_data['transitions'][t.transition_id] = action_parent_m.get_transition_m(t.transition_id).meta\n    for df in related_data_flows['external']['ingoing'] + related_data_flows['external']['outgoing']:\n        tmp_meta_data['data_flows'][df.data_flow_id] = action_parent_m.get_data_flow_m(df.data_flow_id).meta\n    action_parent_m.substitute_state.__func__.tmp_meta_data_storage = tmp_meta_data\n    action_parent_m.substitute_state.__func__.old_state_m = old_state_m\n\n    # put old state size and rel_pos onto new state\n    previous_state_size = state_m_to_insert.get_meta_data_editor()['size']\n    state_m_to_insert.set_meta_data_editor('size', old_state_m.get_meta_data_editor()['size'])\n    state_m_to_insert.set_meta_data_editor('rel_pos', old_state_m.get_meta_data_editor()['rel_pos'])\n    # scale the meta data according new size\n    prepare_state_m_for_insert_as(state_m_to_insert, previous_state_size)\n\n    # CORE\n    new_state = e = None\n    # print(\"state to insert\", state_to_insert)\n    try:\n        # if as_template:  # TODO remove this work around if the models are loaded correctly\n        #     # the following enforce the creation of a new model (in needed depth) and transfer of meta data\n        #     import rafcon.gui.action\n        #     meta_dict = rafcon.gui.action.get_state_element_meta(state_m_to_insert)\n        #     new_state = action_parent_m.state.substitute_state(state_id, state_to_insert)\n        #     sm_m = action_parent_m.get_state_machine_m()\n        #     rafcon.gui.action.insert_state_meta_data(meta_dict, sm_m.get_state_model_by_path(new_state.get_path()))\n        # else:\n        action_parent_m.expected_future_models.add(state_m_to_insert)\n        new_state = action_parent_m.state.substitute_state(state_id, state_to_insert)\n        # assert new_state.state_id is state_id\n        assert new_state is state_to_insert\n    except Exception as e:\n        logger.exception(\"State substitution failed\")\n\n    if new_state:\n        # AFTER MODEL\n        # print(\"AFTER MODEL\", new_state)\n        new_state_m = action_parent_m.states[new_state.state_id]\n        update_models_recursively(state_m=new_state_m)\n        tmp_meta_data = action_parent_m.substitute_state.__func__.tmp_meta_data_storage\n        old_state_m = action_parent_m.substitute_state.__func__.old_state_m\n        changed_models = []\n        new_state_m.meta = tmp_meta_data['state']\n        changed_models.append(new_state_m)\n        for t_id, t_meta in tmp_meta_data['transitions'].items():\n            if action_parent_m.get_transition_m(t_id) is not None:\n                action_parent_m.get_transition_m(t_id).meta = t_meta\n                changed_models.append(action_parent_m.get_transition_m(t_id))\n            elif t_id in action_parent_m.state.substitute_state.__func__.re_create_io_going_t_ids:\n                logger.warning(\"Transition model with id {0} to set meta data could not be found.\".format(t_id))\n        for df_id, df_meta in tmp_meta_data['data_flows'].items():\n            if action_parent_m.get_data_flow_m(df_id) is not None:\n                action_parent_m.get_data_flow_m(df_id).meta = df_meta\n                changed_models.append(action_parent_m.get_data_flow_m(df_id))\n            elif df_id in action_parent_m.state.substitute_state.__func__.re_create_io_going_df_ids:\n                logger.warning(\"Data flow model with id {0} to set meta data could not be found.\".format(df_id))\n\n        msg = ActionSignalMsg(action='substitute_state', origin='model', action_parent_m=action_parent_m,\n                              affected_models=changed_models, after=True, result=e)\n        # print(\"EMIT-AFTER OLDSTATE\", msg)\n        old_state_m.action_signal.emit(msg)\n\n    del action_parent_m.substitute_state.__func__.tmp_meta_data_storage\n    del action_parent_m.substitute_state.__func__.old_state_m"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nsubstitute a target state with a handed state", "response": "def substitute_state_as(target_state_m, state, as_template, keep_name=False):\n    \"\"\" Substitute a target state with a handed state\n\n    The method generates a state model for the state to be inserted and use function substitute_state to finally\n    substitute the state.\n    In case the state to be inserted is a LibraryState it can be chosen to be inserted as template.\n    It can be chosen that the inserted state keeps the name of the target state.\n\n    :param rafcon.gui.models.state.AbstractStateModel target_state_m: State model of the state to be substituted\n    :param rafcon.core.states.State state: State to be inserted\n    :param bool as_template: The flag determines if a handed state of type LibraryState is insert as template\n    :param bool keep_name: The flag to keep the name of the target state\n    :return:\n    \"\"\"\n\n    state_m = get_state_model_class_for_state(state)(state)\n    # If inserted as template, we have to extract the state_copy and model otherwise keep original name\n    if as_template:\n        assert isinstance(state_m, LibraryStateModel)\n        state_m = state_m.state_copy\n        state_m.state.parent = None\n\n    if keep_name:\n        state_m.state.name = target_state_m.state.name\n\n    assert target_state_m.parent.states[target_state_m.state.state_id] is target_state_m\n    substitute_state(target_state_m, state_m, as_template)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nadd another event to the multi_event", "response": "def orify(e, changed_callback):\n    \"\"\"Add another event to the multi_event\n\n    :param e: the event to be added to the multi_event\n    :param changed_callback: a method to call if the event status changes, this method has access to the multi_event\n    :return:\n    \"\"\"\n    if not hasattr(e, \"callbacks\"):  # Event has not been orified yet\n        e._set = e.set\n        e._clear = e.clear\n        e.set = lambda: or_set(e)\n        e.clear = lambda: or_clear(e)\n        e.callbacks = list()\n    # Keep track of one callback per multi event\n    e.callbacks.append(changed_callback)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates a new multi_event object with all events passed in the events parameter.", "response": "def create(*events):\n    \"\"\"Creates a new multi_event\n\n    The multi_event listens to all events passed in the \"events\" parameter.\n\n    :param events: a list of threading.Events\n    :return: The multi_event\n    :rtype: threading.Event\n    \"\"\"\n    or_event = threading.Event()\n\n    def changed():\n        if any([event.is_set() for event in events]):\n            or_event.set()\n        else:\n            or_event.clear()\n\n    for e in events:\n        orify(e, changed)\n\n    changed()\n    return or_event"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef model_changed(self, model, prop_name, info):\n        current_enables = self._get_config_enables()\n        if not self._enables == current_enables:\n            # check if filtered buffer update needed\n            filtered_buffer_update_needed = True\n            if all(self._enables[key] == current_enables[key] for key in ['VERBOSE', 'DEBUG', 'INFO', 'WARNING', 'ERROR']):\n                follow_mode_key = 'CONSOLE_FOLLOW_LOGGING'\n                only_follow_mode_changed = self._enables[follow_mode_key] != current_enables[follow_mode_key]\n                filtered_buffer_update_needed = not only_follow_mode_changed\n\n            self._enables = current_enables\n            self.view.set_enables(self._enables)\n            if filtered_buffer_update_needed:\n                self.update_filtered_buffer()\n            else:\n                self.view.scroll_to_cursor_onscreen()", "response": "React to configuration changes\n            Update internal hold enable state propagates it to view and refresh the text buffer."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _handle_double_click(self, event):\n        if event.get_button()[1] == 1:  # Left mouse button\n            path_info = self.view.tree_view.get_path_at_pos(int(event.x), int(event.y))\n            if path_info:  # Valid entry was clicked on\n                path = path_info[0]\n                item_iter = self.tree_store.get_iter(path)\n\n                # Toggle collapse status if applicable for this kind of state\n                if self.view.tree_view.row_expanded(path):\n                    self.view.tree_view.collapse_row(path)\n                else:\n                    if self.tree_store.iter_has_child(item_iter):\n                        self.view.tree_view.expand_to_path(path)", "response": "Handle double click event."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncreates a absolute path in the file system.", "response": "def create_path(path):\n    \"\"\"Creates a absolute path in the file system.\n\n    :param path: The path to be created\n    \"\"\"\n    import os\n    if not os.path.exists(path):\n        os.makedirs(path)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_md5_file_hash(filename):\n    import hashlib\n    BLOCKSIZE = 65536\n    hasher = hashlib.md5()\n    with open(filename, 'rb') as afile:\n        buf = afile.read(BLOCKSIZE)\n        while len(buf) > 0:\n            hasher.update(buf)\n            buf = afile.read(BLOCKSIZE)\n    return hasher.hexdigest()", "response": "Calculates the MD5 hash of a file"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nchecking if target_file is not existing or differing from source_file", "response": "def file_needs_update(target_file, source_file):\n    \"\"\"Checks if target_file is not existing or differing from source_file\n\n    :param target_file: File target for a copy action\n    :param source_file: File to be copied\n    :return: True, if target_file not existing or differing from source_file, else False\n    :rtype: False\n    \"\"\"\n    if not os.path.isfile(target_file) or get_md5_file_hash(target_file) != get_md5_file_hash(source_file):\n        return True\n    return False"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef copy_file_if_update_required(source_file, target_file):\n    if file_needs_update(target_file, source_file):\n        shutil.copy(source_file, target_file)", "response": "Copies source_file to target_file if latter one in not existing or outdated"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nopening file by path and optional filename and return content of the file.", "response": "def read_file(file_path, filename=None):\n    \"\"\" Open file by path and optional filename\n\n    If no file name is given the path is interpreted as direct path to the file to be read.\n    If there is no file at location the return value will be None to offer a option for case handling.\n\n    :param str file_path: Path string.\n    :param str filename: File name of the file to be read.\n    :return: None or str\n    \"\"\"\n    file_path = os.path.realpath(file_path)\n    if filename:\n        file_path = os.path.join(file_path, filename)\n\n    file_content = None\n    if os.path.isfile(file_path):\n        with open(file_path, 'r') as file_pointer:\n            file_content = file_pointer.read()\n\n    return file_content"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nclean list of paths from elements that do not exist", "response": "def clean_file_system_paths_from_not_existing_paths(file_system_paths):\n    \"\"\"Cleans list of paths from elements that do not exist\n\n    If a path is no more valid/existing, it is removed from the list.\n\n    :param list[str] file_system_paths: list of file system paths to be checked for existing\n    \"\"\"\n    paths_to_delete = []\n    for path in file_system_paths:\n        if not os.path.exists(path):\n            paths_to_delete.append(path)\n    for path in paths_to_delete:\n        file_system_paths.remove(path)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _load_input_data_port_models(self):\n        self.input_data_ports = []\n        for input_data_port in self.state.input_data_ports.values():\n            self._add_model(self.input_data_ports, input_data_port, DataPortModel)", "response": "Reloads the input data port models from the state"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _load_output_data_port_models(self):\n        self.output_data_ports = []\n        for output_data_port in self.state.output_data_ports.values():\n            self._add_model(self.output_data_ports, output_data_port, DataPortModel)", "response": "Reloads the output data port models from the state"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nloads the income model from the core income", "response": "def _load_income_model(self):\n        \"\"\" Create income model from core income \"\"\"\n        self._add_model(self.income, self.state.income, IncomeModel)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _load_outcome_models(self):\n        self.outcomes = []\n        for outcome in self.state.outcomes.values():\n            self._add_model(self.outcomes, outcome, OutcomeModel)", "response": "Load outcome models from core outcomes"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nrecreating model list The method re-initiate a handed list or dictionary of models with the new dictionary of core-objects. :param model_list_or_dict: could be a list or dictionary of one model type :param core_objects_dict: new dictionary of one type of core-elements (rafcon.core) :param model_name: prop_name for the core-element hold by the model, this core-element is covered by the model :param model_class: model-class of the elements that should be insert :param model_key: if model_list_or_dict is a dictionary the key is the id of the respective element (e.g. 'state_id') :return:", "response": "def re_initiate_model_list(self, model_list_or_dict, core_objects_dict, model_name, model_class, model_key):\n        \"\"\"Recreate model list\n\n        The method re-initiate a handed list or dictionary of models with the new dictionary of core-objects.\n\n        :param model_list_or_dict: could be a list or dictionary of one model type\n        :param core_objects_dict: new dictionary of one type of core-elements (rafcon.core)\n        :param model_name: prop_name for the core-element hold by the model, this core-element is covered by the model\n        :param model_class: model-class of the elements that should be insert\n        :param model_key: if model_list_or_dict is a dictionary the key is the id of the respective element\n                          (e.g. 'state_id')\n        :return:\n        \"\"\"\n        if model_name == \"income\":\n            if self.income.income != self.state.income:\n                self._add_model(self.income, self.state.income, IncomeModel)\n            return\n\n        for _ in range(len(model_list_or_dict)):\n            self.remove_additional_model(model_list_or_dict, core_objects_dict, model_name, model_key)\n\n        if core_objects_dict:\n            for _ in core_objects_dict:\n                self.add_missing_model(model_list_or_dict, core_objects_dict, model_name, model_class, model_key)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _add_model(self, model_list_or_dict, core_element, model_class, model_key=None, load_meta_data=True):\n\n        found_model = self._get_future_expected_model(core_element)\n        if found_model:\n            found_model.parent = self\n\n        if model_class is IncomeModel:\n            self.income = found_model if found_model else IncomeModel(core_element, self)\n            return\n\n        if model_key is None:\n            model_list_or_dict.append(found_model if found_model else model_class(core_element, self))\n        else:\n            model_list_or_dict[model_key] = found_model if found_model else model_class(core_element, self,\n                                                                                        load_meta_data=load_meta_data)", "response": "Adds one model for a given core element."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef add_missing_model(self, model_list_or_dict, core_elements_dict, model_name, model_class, model_key):\n        def core_element_has_model(core_object):\n            for model_or_key in model_list_or_dict:\n                model = model_or_key if model_key is None else model_list_or_dict[model_or_key]\n                if core_object is getattr(model, model_name):\n                    return True\n            return False\n\n        if model_name == \"income\":\n            self._add_model(self.income, self.state.income, IncomeModel)\n            return\n            \n        for core_element in core_elements_dict.values():\n            if core_element_has_model(core_element):\n                continue\n\n            # get expected model and connect it to self or create a new model\n            new_model = self._get_future_expected_model(core_element)\n            if new_model:\n                new_model.parent = self\n            else:\n                if type_helpers.type_inherits_of_type(model_class, StateModel):\n                    new_model = model_class(core_element, self, expected_future_models=self.expected_future_models)\n                    self.expected_future_models = new_model.expected_future_models  # update reused models\n                    new_model.expected_future_models = set()  # clean the field because should not be used further\n                else:\n                    new_model = model_class(core_element, self)\n\n            # insert new model into list or dict\n            if model_key is None:\n                model_list_or_dict.append(new_model)\n            else:\n                model_list_or_dict[getattr(core_element, model_key)] = new_model\n            return True\n        return False", "response": "This method will add one missing model to the state object if it does not exist."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nremoves one unnecessary model The method will search for the first model-object out of model_list_or_dict that represents no core-object in the dictionary of core-objects handed by core_objects_dict, remove it and return without continue to search for more model-objects which maybe are unnecessary, too. :param model_list_or_dict: could be a list or dictionary of one model type :param core_objects_dict: dictionary of one type of core-elements (rafcon.core) :param model_name: prop_name for the core-element hold by the model, this core-element is covered by the model :param model_key: if model_list_or_dict is a dictionary the key is the id of the respective element (e.g. 'state_id') :return:", "response": "def remove_additional_model(self, model_list_or_dict, core_objects_dict, model_name, model_key, destroy=True):\n        \"\"\"Remove one unnecessary model\n\n        The method will search for the first model-object out of\n        model_list_or_dict that represents no core-object in the dictionary of core-objects handed by core_objects_dict,\n        remove it and return without continue to search for more model-objects which maybe are unnecessary, too.\n\n        :param model_list_or_dict: could be a list or dictionary of one model type\n        :param core_objects_dict: dictionary of one type of core-elements (rafcon.core)\n        :param model_name: prop_name for the core-element hold by the model, this core-element is covered by the model\n        :param model_key: if model_list_or_dict is a dictionary the key is the id of the respective element\n                          (e.g. 'state_id')\n        :return:\n        \"\"\"\n        if model_name == \"income\":\n            self.income.prepare_destruction()\n            self.income = None\n            return\n\n        for model_or_key in model_list_or_dict:\n            model = model_or_key if model_key is None else model_list_or_dict[model_or_key]\n            found = False\n            for core_object in core_objects_dict.values():\n                if core_object is getattr(model, model_name):\n                    found = True\n                    break\n            if not found:\n                if model_key is None:\n                    if destroy:\n                        model.prepare_destruction()\n                    model_list_or_dict.remove(model)\n                else:\n                    if destroy:\n                        model_list_or_dict[model_or_key].prepare_destruction()\n                    del model_list_or_dict[model_or_key]\n                return"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nhanding model for an core element from expected model list and remove the model from this list", "response": "def _get_future_expected_model(self, core_element):\n        \"\"\"Hand model for an core element from expected model list and remove the model from this list\"\"\"\n        for model in self.expected_future_models:\n            if model.core_element is core_element:\n                # print(\"expected_future_model found -> remove model:\", model, [model], id(model))\n                self.expected_future_models.remove(model)\n                return model\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate a copy of the config in form of a dict", "response": "def as_dict(self, use_preliminary=False):\n        \"\"\"Create a copy of the config in form of a dict\n\n        :param bool use_preliminary: Whether to include the preliminary config\n        :return: A dict with the copy of the config\n        :rtype: dict\n        \"\"\"\n        config = dict()\n        for key in self.config.keys:\n            if use_preliminary and key in self.preliminary_config:\n                value = self.preliminary_config[key]\n            else:\n                value = self.config.get_config_value(key)\n            config[key] = value\n        return config"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nupdate the content and reference of the config object with the new configuration dictionary.", "response": "def update_config(self, config_dict, config_file):\n        \"\"\"Update the content and reference of the config\n\n        :param dict config_dict: The new configuration\n        :param str config_file: The new file reference\n        \"\"\"\n        config_path = path.dirname(config_file)\n        self.config.config_file_path = config_file\n        self.config.path = config_path\n        for config_key, config_value in config_dict.items():\n            if config_value != self.config.get_config_value(config_key):\n                self.set_preliminary_config_value(config_key, config_value)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the current config value for the given config key", "response": "def get_current_config_value(self, config_key, use_preliminary=True, default=None):\n        \"\"\"Returns the current config value for the given config key\n\n        :param str config_key: Config key who's value is requested\n        :param bool use_preliminary: Whether the preliminary config should be queried first\n        :param default: The value to return if config key does not exist\n        :return: Copy of the config value\n        \"\"\"\n        if use_preliminary and config_key in self.preliminary_config:\n            return copy(self.preliminary_config[config_key])\n        return copy(self.config.get_config_value(config_key, default))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef set_preliminary_config_value(self, config_key, config_value):\n        if config_value != self.config.get_config_value(config_key):\n            self.preliminary_config[config_key] = config_value\n        # If the value was reverted to its original value, we can remove the entry\n        elif config_key in self.preliminary_config:\n            del self.preliminary_config[config_key]", "response": "Stores a config value as preliminary new value\n       "}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\napply the preliminary config to the configuration and returns True if the applied changes require a refresh of the state machines.", "response": "def apply_preliminary_config(self, save=True):\n        \"\"\"Applies the preliminary config to the configuration\n\n        :param bool save: Whether the config file is be be written to the file system\n        :return: Whether the applied changes require a refresh of the state machines\n        :rtype: bool\n        \"\"\"\n        state_machine_refresh_required = False\n        for config_key, config_value in self.preliminary_config.items():\n            self.config.set_config_value(config_key, config_value)\n            if config_key in self.config.keys_requiring_state_machine_refresh:\n                state_machine_refresh_required = True\n            elif config_key in self.config.keys_requiring_restart:\n                self.changed_keys_requiring_restart.add(config_key)\n            if config_key == 'AUTO_RECOVERY_LOCK_ENABLED':\n                import rafcon.gui.models.auto_backup\n                if config_value:\n                    rafcon.gui.models.auto_backup.generate_rafcon_instance_lock_file()\n                else:\n                    rafcon.gui.models.auto_backup.remove_rafcon_instance_lock_file()\n        self.preliminary_config.clear()\n\n        if save:\n            self.config.save_configuration()\n        return state_machine_refresh_required"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef parent(self, parent):\n        if parent is None:\n            self._parent = None\n        else:\n            from rafcon.core.states.state import State\n            assert isinstance(parent, State)\n\n            old_parent = self.parent\n            self._parent = ref(parent)\n\n            valid, message = self._check_validity()\n            if not valid:\n                if not old_parent:\n                    self._parent = None\n                else:\n                    self._parent = ref(old_parent)\n\n                class_name = self.__class__.__name__\n                if global_config.get_config_value(\"LIBRARY_RECOVERY_MODE\") is True:\n                    do_delete_item = True\n                    # In case of just the data type is wrong raise an Exception but keep the data flow\n                    if \"not have matching data types\" in message:\n                        do_delete_item = False\n                        self._parent = ref(parent)\n                    raise RecoveryModeException(\"{0} invalid within state \\\"{1}\\\" (id {2}): {3}\".format(\n                        class_name, parent.name, parent.state_id, message), do_delete_item=do_delete_item)\n                else:\n                    raise ValueError(\"{0} invalid within state \\\"{1}\\\" (id {2}): {3} {4}\".format(\n                        class_name, parent.name, parent.state_id, message, self))", "response": "Setter for the parent state of the state element"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _check_validity(self):\n        from rafcon.core.states.state import State\n\n        if not self.parent:\n            return True, \"no parent\"\n        if not isinstance(self.parent, State):\n            return True, \"no parental check\"\n        return self.parent.check_child_validity(self)", "response": "Checks the validity of the state element s properties\n\n       "}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef register_new_state_machines(self, model, prop_name, info):\n        if info['method_name'] == '__setitem__':\n            self.observe_model(info['args'][1])\n            self.logger.info(NotificationOverview(info))\n        elif info['method_name'] == '__delitem__':\n            pass\n        else:\n            self.logger.warning(NotificationOverview(info))", "response": "The method register self as observer newly added StateMachineModels after those were added to the list of state_machines hold by observable StateMachineMangerModel. state_machines."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef observe_root_state_assignments(self, model, prop_name, info):\n        if info['old']:\n            self.relieve_model(info['old'])\n        if info['new']:\n            self.observe_model(info['new'])\n            self.logger.info(\"Exchange observed old root_state model with newly assigned one. sm_id: {}\"\n                             \"\".format(info['new'].state.parent.state_machine_id))", "response": "The method relies observed root_state models and observes newly assigned root_state models."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef observe_meta_signal_changes(self, changed_model, prop_name, info):\n        self.logger.info(NotificationOverview(info))", "response": "This method prints the structure of all meta_signal - notifications as log - messages.\n       "}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsetting the dictionary of the Vividict COOKIE", "response": "def set_dict(self, new_dict):\n        \"\"\"Sets the dictionary of the Vividict\n\n        The method is able to handle nested dictionaries, by calling the method recursively.\n\n        :param new_dict: The dict that will be added to the own dict\n        \"\"\"\n        for key, value in new_dict.items():\n            if isinstance(value, dict):\n                self[str(key)] = Vividict(value)\n            else:\n                self[str(key)] = value"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef register_view(self, view):\n        super(SemanticDataEditorController, self).register_view(view)\n\n        if isinstance(self.model.state, LibraryState) or self.model.state.get_next_upper_library_root_state():\n            self.set_editor_lock(True)\n\n        view['open_externally'].connect('clicked', self.open_externally_clicked)\n        view['new_entry'].connect('clicked', self.on_add, False)\n        view['new_dict_entry'].connect('clicked', self.on_add, True)\n        view['delete_entry'].connect('clicked', self.on_remove)\n        self._apply_value_on_edited_and_focus_out(self.widget_columns[view.KEY_COLUMN_ID].get_cells()[0],\n                                                  self.key_edited)\n        self._apply_value_on_edited_and_focus_out(self.widget_columns[view.VALUE_COLUMN_ID].get_cells()[0],\n                                                  self.value_edited)\n        self.reload_tree_store_data()", "response": "Called when the view was registered"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef set_editor_lock(self, locked=True):\n        self.view['new_entry'].set_sensitive(not locked)\n        self.view['new_dict_entry'].set_sensitive(not locked)\n        self.view['delete_entry'].set_sensitive(not locked)\n        # self.view['open_externally'].set_sensitive(not locked)\n\n        for current_column in self.view['semantic_data_tree_view'].get_columns():\n            current_column.get_cells()[0].set_property('editable', not locked)", "response": "Sets the locked flag for the external editor."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_selected_object(self):\n        model, paths = self.tree_view.get_selection().get_selected_rows()\n        if len(paths) == 1:\n            return self.tree_store.get_iter(paths[0]), paths[0]\n        else:\n            return None, paths", "response": "Gets the selected object in the treeview"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nadding a new entry to the semantic data of a state.", "response": "def on_add(self, widget, new_dict=False):\n        \"\"\"\" Adds a new entry to the semantic data of a state. Reloads the tree store.\n\n        :param widget: The source widget of the action\n        :param bool new_dict: A flag to indicate if the new value is of type dict\n        :return:\n        \"\"\"\n        self.semantic_data_counter += 1\n        treeiter, path = self.get_selected_object()\n\n        value = dict() if new_dict else \"New Value\"\n\n        # get target dict path\n        if treeiter:\n            target_dict_path_as_list = self.tree_store[path][self.ID_STORAGE_ID]\n            if not self.tree_store[path][self.IS_DICT_STORAGE_ID]:\n                target_dict_path_as_list.pop()\n        else:\n            target_dict_path_as_list = []\n\n        # generate key\n        target_dict = self.model.state.get_semantic_data(target_dict_path_as_list)\n        new_key_string = generate_semantic_data_key(list(target_dict.keys()))\n        self.model.state.add_semantic_data(target_dict_path_as_list, value, new_key_string)\n\n        self.reload_tree_store_data()\n\n        # jump to new element\n        self.select_entry(target_dict_path_as_list + [new_key_string])\n        logger.debug(\"Added new semantic data entry!\")\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef on_remove(self, widget, data=None):\n        treeiter, path = self.get_selected_object()\n        if not treeiter:\n            return\n\n        # check if an element is selected\n        dict_path_as_list = self.tree_store[path][self.ID_STORAGE_ID]\n        logger.debug(\"Deleting semantic data entry with name {}!\".format(dict_path_as_list[-1]))\n        self.model.state.remove_semantic_data(dict_path_as_list)\n        self.reload_tree_store_data()\n\n        # hold cursor position where the last element was removed\n        try:\n            self.select_entry(self.tree_store[path][self.ID_STORAGE_ID])\n        except IndexError:\n            if len(self.tree_store):\n                if len(path) > 1:\n                    possible_before_path = tuple(list(path[:-1]) + [path[-1] - 1])\n                    if possible_before_path[-1] > -1:\n                        self.select_entry(self.tree_store[possible_before_path][self.ID_STORAGE_ID])\n                    else:\n                        self.select_entry(self.tree_store[path[:-1]][self.ID_STORAGE_ID])\n                else:\n                    self.select_entry(self.tree_store[path[0] - 1][self.ID_STORAGE_ID])\n        return True", "response": "Removes an entry of semantic data of a state."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef add_items_to_tree_iter(self, input_dict, treeiter, parent_dict_path=None):\n        if parent_dict_path is None:\n            parent_dict_path = []\n        self.get_view_selection()\n        for key, value in sorted(input_dict.items()):\n            element_dict_path = copy.copy(parent_dict_path) + [key]\n            if isinstance(value, dict):\n                new_iter = self.tree_store.append(treeiter, [key, \"\", True, element_dict_path])\n                self.add_items_to_tree_iter(value, new_iter, element_dict_path)\n            else:\n                self.tree_store.append(treeiter, [key, value, False, element_dict_path])", "response": "Adds all values of the input dictionary to the tree store."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreload the data of the tree store.", "response": "def reload_tree_store_data(self):\n        \"\"\" Reloads the data of the tree store\n\n        :return:\n        \"\"\"\n        model, paths = self.tree_view.get_selection().get_selected_rows()\n\n        self.tree_store.clear()\n        self.add_items_to_tree_iter(self.model.state.semantic_data, None)\n        self.tree_view.expand_all()\n\n        try:\n            for path in paths:\n                self.tree_view.get_selection().select_path(path)\n        except ValueError:\n            pass"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nadds a copy of all selected row dict value pairs to the clipboard", "response": "def copy_action_callback(self, *event):\n        \"\"\"Add a copy of all selected row dict value pairs to the clipboard\"\"\"\n        if react_to_event(self.view, self.tree_view, event) and self.active_entry_widget is None:\n            _, dict_paths = self.get_view_selection()\n            selected_data_list = []\n            for dict_path_as_list in dict_paths:\n                value = self.model.state.semantic_data\n                for path_element in dict_path_as_list:\n                    value = value[path_element]\n                selected_data_list.append((path_element, value))\n            rafcon.gui.clipboard.global_clipboard.set_semantic_dictionary_list(selected_data_list)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef paste_action_callback(self, *event):\n        if react_to_event(self.view, self.tree_view, event) and self.active_entry_widget is None:\n            _, dict_paths = self.get_view_selection()\n            selected_data_list = rafcon.gui.clipboard.global_clipboard.get_semantic_dictionary_list()\n\n            # enforce paste on root level if semantic data empty or nothing is selected\n            if not dict_paths and not self.model.state.semantic_data:\n                dict_paths = [[]]\n\n            for target_dict_path_as_list in dict_paths:\n                prev_value = self.model.state.semantic_data\n                value = self.model.state.semantic_data\n                for path_element in target_dict_path_as_list:\n                    prev_value = value\n                    value = value[path_element]\n                if not isinstance(value, dict) and len(dict_paths) <= 1:  # if one selection take parent\n                    target_dict_path_as_list.pop(-1)\n                    value = prev_value\n                if isinstance(value, dict):\n                    for key_to_paste, value_to_add in selected_data_list:\n                        self.model.state.add_semantic_data(target_dict_path_as_list, value_to_add, key_to_paste)\n            self.reload_tree_store_data()", "response": "Paste the clipboard into all selected sub - dictionary"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef cut_action_callback(self, *event):\n        if react_to_event(self.view, self.tree_view, event) and self.active_entry_widget is None:\n            _, dict_paths = self.get_view_selection()\n            stored_data_list = []\n            for dict_path_as_list in dict_paths:\n                if dict_path_as_list:\n                    value = self.model.state.semantic_data\n                    for path_element in dict_path_as_list:\n                        value = value[path_element]\n                    stored_data_list.append((path_element, value))\n                    self.model.state.remove_semantic_data(dict_path_as_list)\n\n            rafcon.gui.clipboard.global_clipboard.set_semantic_dictionary_list(stored_data_list)\n            self.reload_tree_store_data()", "response": "Add a copy and cut all selected row dict value pairs to the clipboard"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef key_edited(self, path, new_key_str):\n        tree_store_path = self.create_tree_store_path_from_key_string(path) if isinstance(path, string_types) else path\n        if self.tree_store[tree_store_path][self.KEY_STORAGE_ID] == new_key_str:\n            return\n\n        dict_path = self.tree_store[tree_store_path][self.ID_STORAGE_ID]\n        old_value = self.model.state.get_semantic_data(dict_path)\n        self.model.state.remove_semantic_data(dict_path)\n\n        if new_key_str == \"\":\n            target_dict = self.model.state.semantic_data\n            for element in dict_path[0:-1]:\n                target_dict = target_dict[element]\n            new_key_str = generate_semantic_data_key(list(target_dict.keys()))\n\n        new_dict_path = self.model.state.add_semantic_data(dict_path[0:-1], old_value, key=new_key_str)\n        self._changed_id_to = {':'.join(dict_path): new_dict_path}  # use hashable key (workaround for tree view ctrl)\n        self.reload_tree_store_data()", "response": "Edits the key of a semantic data entry"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef value_edited(self, path, new_value_str):\n        tree_store_path = self.create_tree_store_path_from_key_string(path) if isinstance(path, string_types) else path\n        if self.tree_store[tree_store_path][self.VALUE_STORAGE_ID] == new_value_str:\n            return\n\n        dict_path = self.tree_store[tree_store_path][self.ID_STORAGE_ID]\n        self.model.state.add_semantic_data(dict_path[0:-1], new_value_str, key=dict_path[-1])\n        self.reload_tree_store_data()", "response": "Adds the value of the semantic data entry to the model state"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_path_for_core_element(self, core_element_id):\n        def check_function(row_iter, iter_found):\n            row_id = self.tree_store.get_value(row_iter, self.ID_STORAGE_ID)\n            if len(row_id) == len(core_element_id):\n                if row_id == core_element_id:\n                    iter_found.append(self.tree_store.get_path(row_iter))\n\n        found_paths = []\n        self.iter_tree_with_handed_function(check_function, found_paths)\n        return found_paths[0] if found_paths else None", "response": "Get the path to the row representing the core element described by handed core_element_id"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef save_file_data(self, path):\n        try:\n            # just create file with empty text first; this command also creates the whole path to the file\n            filesystem.write_file(os.path.join(path, storage.SCRIPT_FILE), \"\", create_full_path=True)\n            storage_utils.write_dict_to_json(self.model.state.semantic_data, os.path.join(path, storage.SEMANTIC_DATA_FILE))\n        except IOError as e:\n            # Only happens if the file doesnt exist yet and would be written to the temp folder.\n            # The method write_file doesn't create the path\n            logger.error('The operating system raised an error: {}'.format(e))", "response": "Saves the semantic data to a file in the specified path."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef load_and_set_file_content(self, file_system_path):\n        semantic_data = load_data_file(os.path.join(file_system_path, storage.SEMANTIC_DATA_FILE))\n        self.model.state.semantic_data = semantic_data", "response": "Loads the semantic data file and sets the content of the semantic data object in the state."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nstoring the properties of a widget in the configuration file.", "response": "def store_widget_properties(self, widget, widget_name):\n        \"\"\"Sets configuration values for widgets\n\n        If the widget is a window, then the size and position are stored. If the widget is a pane, then only the\n        position is stored. If the window is maximized the last insert position before being maximized is keep in the\n        config and the maximized flag set to True. The maximized state and the last size and position are strictly\n        separated by this.\n\n        :param widget: The widget, for which the position (and possibly the size) will be stored.\n        :param widget_name: The window or widget name of the widget, which constitutes a part of its key in the\n        configuration file.\n        \"\"\"\n        if isinstance(widget, Gtk.Window):\n            maximized = bool(widget.is_maximized())\n            self.set_config_value('{0}_MAXIMIZED'.format(widget_name), maximized)\n            if maximized:\n                return\n            size = widget.get_size()\n            self.set_config_value('{0}_SIZE'.format(widget_name), tuple(size))\n            position = widget.get_position()\n            self.set_config_value('{0}_POS'.format(widget_name), tuple(position))\n        else:  # Gtk.Paned\n            position = widget.get_position()\n            self.set_config_value('{0}_POS'.format(widget_name), position)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef update_recently_opened_state_machines_with(self, state_machine):\n        if state_machine.file_system_path:\n            # check if path is in recent path already\n            # logger.info(\"update recent state machine: {}\".format(sm.file_system_path))\n            recently_opened_state_machines = self.get_config_value('recently_opened_state_machines', [])\n            if state_machine.file_system_path in recently_opened_state_machines:\n                del recently_opened_state_machines[recently_opened_state_machines.index(state_machine.file_system_path)]\n            recently_opened_state_machines.insert(0, state_machine.file_system_path)\n            self.set_config_value('recently_opened_state_machines', recently_opened_state_machines)", "response": "Updates the list of recently opened state machines with the file system path of handed state machine."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef extend_recently_opened_by_current_open_state_machines(self):\n        from rafcon.gui.singleton import state_machine_manager_model as state_machine_manager_m\n        for sm_m in state_machine_manager_m.state_machines.values():\n            self.update_recently_opened_state_machines_with(sm_m.state_machine)", "response": "Updates the list with all in the state machine manager opened state machines"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef prepare_recently_opened_state_machines_list_for_storage(self):\n        from rafcon.gui.singleton import global_gui_config\n        num = global_gui_config.get_config_value('NUMBER_OF_RECENT_OPENED_STATE_MACHINES_STORED')\n        state_machine_paths = self.get_config_value('recently_opened_state_machines', [])\n        self.set_config_value('recently_opened_state_machines', state_machine_paths[:num])", "response": "Reduce number of paths in the recent opened state machines to limit from gui config"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nremove state machines who s file system path does not exist", "response": "def clean_recently_opened_state_machines(self):\n        \"\"\"Remove state machines who's file system path does not exist\"\"\"\n        state_machine_paths = self.get_config_value('recently_opened_state_machines', [])\n        filesystem.clean_file_system_paths_from_not_existing_paths(state_machine_paths)\n        self.set_config_value('recently_opened_state_machines', state_machine_paths)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset the execution mode to paused", "response": "def pause(self):\n        \"\"\"Set the execution mode to paused\n        \"\"\"\n        if self.state_machine_manager.active_state_machine_id is None:\n            logger.info(\"'Pause' is not a valid action to initiate state machine execution.\")\n            return\n        if self.state_machine_manager.get_active_state_machine() is not None:\n            self.state_machine_manager.get_active_state_machine().root_state.recursively_pause_states()\n\n        logger.debug(\"Pause execution ...\")\n        self.set_execution_mode(StateMachineExecutionStatus.PAUSED)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef finished_or_stopped(self):\n        return (self._status.execution_mode is StateMachineExecutionStatus.STOPPED) or \\\n               (self._status.execution_mode is StateMachineExecutionStatus.FINISHED)", "response": "Returns a boolean indicating whether the condition check is finished or stopped."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nstart a specific state machine.", "response": "def start(self, state_machine_id=None, start_state_path=None):\n        \"\"\" Start state machine\n\n        If no state machine is running start a specific state machine.\n        If no state machine is provided the currently active state machine is started.\n        If there is already a state machine running, just resume it without taking the passed state_machine_id argument\n        into account.\n\n        :param state_machine_id: The id if the state machine to be started\n        :param start_state_path: The path of the state in the state machine, from which the execution will start\n        :return:\n        \"\"\"\n\n        if not self.finished_or_stopped():\n            logger.debug(\"Resume execution engine ...\")\n            self.run_to_states = []\n            if self.state_machine_manager.get_active_state_machine() is not None:\n                self.state_machine_manager.get_active_state_machine().root_state.recursively_resume_states()\n                if isinstance(state_machine_id, int) and \\\n                        state_machine_id != self.state_machine_manager.get_active_state_machine().state_machine_id:\n                    logger.info(\"Resumed state machine with id {0} but start of state machine id {1} was requested.\"\n                                \"\".format(self.state_machine_manager.get_active_state_machine().state_machine_id,\n                                          state_machine_id))\n            self.set_execution_mode(StateMachineExecutionStatus.STARTED)\n        else:\n            # do not start another state machine before the old one did not finish its execution\n            if self.state_machine_running:\n                logger.warning(\"An old state machine is still running! Make sure that it terminates,\"\n                               \" before you can start another state machine! {0}\".format(self))\n                return\n\n            logger.debug(\"Start execution engine ...\")\n            if state_machine_id is not None:\n                self.state_machine_manager.active_state_machine_id = state_machine_id\n\n            if not self.state_machine_manager.active_state_machine_id:\n                logger.error(\"There exists no active state machine!\")\n                return\n\n            self.set_execution_mode(StateMachineExecutionStatus.STARTED)\n\n            self.start_state_paths = []\n\n            if start_state_path:\n                path_list = start_state_path.split(\"/\")\n                cur_path = \"\"\n                for path in path_list:\n                    if cur_path == \"\":\n                        cur_path = path\n                    else:\n                        cur_path = cur_path + \"/\" + path\n                    self.start_state_paths.append(cur_path)\n\n            self._run_active_state_machine()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef stop(self):\n        logger.debug(\"Stop the state machine execution ...\")\n        if self.state_machine_manager.get_active_state_machine() is not None:\n            self.state_machine_manager.get_active_state_machine().root_state.recursively_preempt_states()\n        self.__set_execution_mode_to_stopped()\n\n        # Notifies states waiting in step mode or those that are paused about execution stop\n        self._status.execution_condition_variable.acquire()\n        self._status.execution_condition_variable.notify_all()\n        self._status.execution_condition_variable.release()\n        self.__running_state_machine = None", "response": "Stops the execution of the current state machine."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef join(self, timeout=None):\n        if self.__wait_for_finishing_thread:\n            if not timeout:\n                # signal handlers won't work if timeout is None and the thread is joined\n                while True:\n                    self.__wait_for_finishing_thread.join(0.5)\n                    if not self.__wait_for_finishing_thread.isAlive():\n                        break\n            else:\n                self.__wait_for_finishing_thread.join(timeout)\n            return not self.__wait_for_finishing_thread.is_alive()\n        else:\n            logger.warning(\"Cannot join as state machine was not started yet.\")\n            return False", "response": "Blocking wait for the execution to finish"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nruns the active state machine and observe its status", "response": "def _run_active_state_machine(self):\n        \"\"\"Store running state machine and observe its status\n        \"\"\"\n\n        # Create new concurrency queue for root state to be able to synchronize with the execution\n        self.__running_state_machine = self.state_machine_manager.get_active_state_machine()\n        if not self.__running_state_machine:\n            logger.error(\"The running state machine must not be None\")\n        self.__running_state_machine.root_state.concurrency_queue = queue.Queue(maxsize=0)\n\n        if self.__running_state_machine:\n            self.__running_state_machine.start()\n\n            self.__wait_for_finishing_thread = threading.Thread(target=self._wait_for_finishing)\n            self.__wait_for_finishing_thread.start()\n        else:\n            logger.warning(\"Currently no active state machine! Please create a new state machine.\")\n            self.set_execution_mode(StateMachineExecutionStatus.STOPPED)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _wait_for_finishing(self):\n        self.state_machine_running = True\n        self.__running_state_machine.join()\n        self.__set_execution_mode_to_finished()\n        self.state_machine_manager.active_state_machine_id = None\n        plugins.run_on_state_machine_execution_finished()\n        # self.__set_execution_mode_to_stopped()\n        self.state_machine_running = False", "response": "Observe running state machine and stop engine if execution has finished"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ntaking a backward step for all active states in the state machine", "response": "def backward_step(self):\n        \"\"\"Take a backward step for all active states in the state machine\n        \"\"\"\n        logger.debug(\"Executing backward step ...\")\n        self.run_to_states = []\n        self.set_execution_mode(StateMachineExecutionStatus.BACKWARD)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef step_mode(self, state_machine_id=None):\n        logger.debug(\"Activate step mode\")\n\n        if state_machine_id is not None:\n            self.state_machine_manager.active_state_machine_id = state_machine_id\n\n        self.run_to_states = []\n        if self.finished_or_stopped():\n            self.set_execution_mode(StateMachineExecutionStatus.STEP_MODE)\n            self._run_active_state_machine()\n        else:\n            self.set_execution_mode(StateMachineExecutionStatus.STEP_MODE)", "response": "Set the execution mode to stepping mode."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ntake a forward step into for all active states in the state machine.", "response": "def step_into(self):\n        \"\"\"Take a forward step (into) for all active states in the state machine\n        \"\"\"\n        logger.debug(\"Execution step into ...\")\n        self.run_to_states = []\n        if self.finished_or_stopped():\n            self.set_execution_mode(StateMachineExecutionStatus.FORWARD_INTO)\n            self._run_active_state_machine()\n        else:\n            self.set_execution_mode(StateMachineExecutionStatus.FORWARD_INTO)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef step_over(self):\n        logger.debug(\"Execution step over ...\")\n        self.run_to_states = []\n        if self.finished_or_stopped():\n            self.set_execution_mode(StateMachineExecutionStatus.FORWARD_OVER)\n            self._run_active_state_machine()\n        else:\n            self.set_execution_mode(StateMachineExecutionStatus.FORWARD_OVER)", "response": "Take a forward step over for all active states in the state machine."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ntake a forward step for all active states in the state machine and run the active state machine.", "response": "def step_out(self):\n        \"\"\"Take a forward step (out) for all active states in the state machine\n        \"\"\"\n        logger.debug(\"Execution step out ...\")\n        self.run_to_states = []\n        if self.finished_or_stopped():\n            self.set_execution_mode(StateMachineExecutionStatus.FORWARD_OUT)\n            self._run_active_state_machine()\n        else:\n            self.set_execution_mode(StateMachineExecutionStatus.FORWARD_OUT)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nexecuting the state machine until a specific state.", "response": "def run_to_selected_state(self, path, state_machine_id=None):\n        \"\"\"Execute the state machine until a specific state. This state won't be executed. This is an asynchronous task\n        \"\"\"\n        if self.state_machine_manager.get_active_state_machine() is not None:\n            self.state_machine_manager.get_active_state_machine().root_state.recursively_resume_states()\n\n        if not self.finished_or_stopped():\n            logger.debug(\"Resume execution engine and run to selected state!\")\n            self.run_to_states = []\n            self.run_to_states.append(path)\n            self.set_execution_mode(StateMachineExecutionStatus.RUN_TO_SELECTED_STATE)\n        else:\n            logger.debug(\"Start execution engine and run to selected state!\")\n            if state_machine_id is not None:\n                self.state_machine_manager.active_state_machine_id = state_machine_id\n            self.set_execution_mode(StateMachineExecutionStatus.RUN_TO_SELECTED_STATE)\n            self.run_to_states = []\n            self.run_to_states.append(path)\n            self._run_active_state_machine()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nwaiting as long as the execution_mode is in paused or step_mode.", "response": "def _wait_while_in_pause_or_in_step_mode(self):\n        \"\"\" Waits as long as the execution_mode is in paused or step_mode\n        \"\"\"\n        while (self._status.execution_mode is StateMachineExecutionStatus.PAUSED) \\\n                or (self._status.execution_mode is StateMachineExecutionStatus.STEP_MODE):\n            try:\n                self._status.execution_condition_variable.acquire()\n                self.synchronization_counter += 1\n                logger.verbose(\"Increase synchronization_counter: \" + str(self.synchronization_counter))\n                self._status.execution_condition_variable.wait()\n            finally:\n                self._status.execution_condition_variable.release()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncheck if the calling thread is blocking and waits for the execution of the current state.", "response": "def _wait_if_required(self, container_state, next_child_state_to_execute, woke_up_from_pause_or_step_mode):\n        \"\"\" Calls a blocking wait for the calling thread, depending on the execution mode.\n\n        :param container_state: the current hierarhcy state to handle the execution mode for\n        :param next_child_state_to_execute: the next child state for :param container_state to be executed\n        :param woke_up_from_pause_or_step_mode: a flag to check if the execution just woke up from paused- or step-mode\n        \"\"\"\n        wait = True\n        # if there is a state in self.run_to_states then RAFCON was commanded\n        #    a) a step_over\n        #    b) a step_out\n        #    c) a run_until\n        for state_path in copy.deepcopy(self.run_to_states):\n            next_child_state_path = None\n            # can be None in case of no transition given\n            if next_child_state_to_execute:\n                next_child_state_path = next_child_state_to_execute.get_path()\n            if state_path == container_state.get_path():\n                # the execution did a whole step_over inside hierarchy state \"state\" (case a) )\n                # or a whole step_out into the hierarchy state \"state\" (case b) )\n                # thus we delete its state path from self.run_to_states\n                # and wait for another step (of maybe different kind)\n                wait = True\n                self.run_to_states.remove(state_path)\n                break\n            elif state_path == next_child_state_path:\n                # this is the case that execution has reached a specific state explicitly marked via\n                # run_to_selected_state() (case c) )\n                # if this is the case run_to_selected_state() is finished and the execution\n                # has to wait for new execution commands\n                wait = True\n                self.run_to_states.remove(state_path)\n                break\n            # don't wait if its just a normal step\n            else:\n                wait = False\n                # do not break here, the state_path may be of another state machine branch\n                # break\n        # don't wait if the the execution just woke up from step mode or pause\n        if wait and not woke_up_from_pause_or_step_mode:\n            logger.debug(\"Stepping mode: waiting for next step!\")\n            try:\n                self._status.execution_condition_variable.acquire()\n                self.synchronization_counter += 1\n                logger.verbose(\"Increase synchronization_counter: \" + str(self.synchronization_counter))\n                self._status.execution_condition_variable.wait()\n            finally:\n                self._status.execution_condition_variable.release()\n            # if the status was set to PAUSED or STEP_MODE don't wake up!\n            self._wait_while_in_pause_or_in_step_mode()\n            # container_state was notified => thus, a new user command was issued, which has to be handled!\n            container_state.execution_history.new_execution_command_handled = False"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef handle_execution_mode(self, container_state, next_child_state_to_execute=None):\n        self.state_counter_lock.acquire()\n        self.state_counter += 1\n        # logger.verbose(\"Increase state_counter!\" + str(self.state_counter))\n        self.state_counter_lock.release()\n\n        woke_up_from_pause_or_step_mode = False\n\n        if (self._status.execution_mode is StateMachineExecutionStatus.PAUSED) \\\n                or (self._status.execution_mode is StateMachineExecutionStatus.STEP_MODE):\n            self._wait_while_in_pause_or_in_step_mode()\n            # new command was triggered => execution command has to handled\n            container_state.execution_history.new_execution_command_handled = False\n            woke_up_from_pause_or_step_mode = True\n\n        # no elif here: if the execution woke up from e.g. paused mode, it has to check the current execution mode\n        if self._status.execution_mode is StateMachineExecutionStatus.STARTED:\n            # logger.debug(\"Execution engine started!\")\n            pass\n\n        elif self._status.execution_mode is StateMachineExecutionStatus.STOPPED:\n            logger.debug(\"Execution engine stopped. State '{0}' is going to quit in the case of \"\n                         \"no preemption handling has to be done!\".format(container_state.name))\n\n        elif self._status.execution_mode is StateMachineExecutionStatus.FINISHED:\n            # this must never happen during execution of the execution engine\n            raise Exception\n\n        else:  # all other step modes\n            logger.verbose(\"before wait\")\n            self._wait_if_required(container_state, next_child_state_to_execute, woke_up_from_pause_or_step_mode)\n            logger.verbose(\"after wait\")\n\n            # calculate states to which should be run\n            if self._status.execution_mode is StateMachineExecutionStatus.BACKWARD:\n                pass\n            elif self._status.execution_mode is StateMachineExecutionStatus.FORWARD_INTO:\n                pass\n            elif self._status.execution_mode is StateMachineExecutionStatus.FORWARD_OVER:\n                if not container_state.execution_history.new_execution_command_handled:\n                    # the state that called this method is a hierarchy state => thus we save this state and wait until\n                    # thise very state will execute its next state; only then we will wait on the condition variable\n                    self.run_to_states.append(container_state.get_path())\n                else:\n                    pass\n            elif self._status.execution_mode is StateMachineExecutionStatus.FORWARD_OUT:\n                from rafcon.core.states.state import State\n                if isinstance(container_state.parent, State):\n                    if not container_state.execution_history.new_execution_command_handled:\n                        from rafcon.core.states.library_state import LibraryState\n                        if isinstance(container_state.parent, LibraryState):\n                            parent_path = container_state.parent.parent.get_path()\n                        else:\n                            parent_path = container_state.parent.get_path()\n                        self.run_to_states.append(parent_path)\n                    else:\n                        pass\n                else:\n                    # if step_out is called from the highest level just run the state machine to the end\n                    self.run_to_states = []\n                    self.set_execution_mode(StateMachineExecutionStatus.STARTED)\n            elif self._status.execution_mode is StateMachineExecutionStatus.RUN_TO_SELECTED_STATE:\n                # \"run_to_states\" were already updated thus doing nothing\n                pass\n\n        container_state.execution_history.new_execution_command_handled = True\n\n        # in the case that the stop method wakes up the paused or step mode a StateMachineExecutionStatus.STOPPED\n        # will be returned\n        return_value = self._status.execution_mode\n\n        return return_value", "response": "Checks the current execution status and returns it."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nmodify the run_to_states list for the given state.", "response": "def _modify_run_to_states(self, state):\n        \"\"\"\n        This is a special case. Inside a hierarchy state a step_over is triggered and affects the last child.\n        In this case the self.run_to_states has to be modified in order to contain the parent of the hierarchy state.\n        Otherwise the execution won't respect the step_over any more and run until the end of the state machine.\n        The same holds for a step_out.\n        The reason for this is, that handle_execution_mode() can not be called between\n        the last state of a hierarchy state and the termination of the hierarchy state itself.\n        \"\"\"\n        if self._status.execution_mode is StateMachineExecutionStatus.FORWARD_OVER or \\\n                self._status.execution_mode is StateMachineExecutionStatus.FORWARD_OUT:\n            for state_path in copy.deepcopy(self.run_to_states):\n                if state_path == state.get_path():\n                    logger.verbose(\"Modifying run_to_states; triggered by state %s!\", state.name)\n                    self.run_to_states.remove(state_path)\n                    from rafcon.core.states.state import State\n                    if isinstance(state.parent, State):\n                        from rafcon.core.states.library_state import LibraryState\n                        if isinstance(state.parent, LibraryState):\n                            parent_path = state.parent.parent.get_path()\n                        else:\n                            parent_path = state.parent.get_path()\n                        self.run_to_states.append(parent_path)\n                    break"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef set_execution_mode(self, execution_mode, notify=True):\n        if not isinstance(execution_mode, StateMachineExecutionStatus):\n            raise TypeError(\"status must be of type StateMachineExecutionStatus\")\n        self._status.execution_mode = execution_mode\n        if notify:\n            self._status.execution_condition_variable.acquire()\n            self._status.execution_condition_variable.notify_all()\n            self._status.execution_condition_variable.release()", "response": "An observed setter for the execution mode of the state machine status."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\npreempting the state and all of it child states.", "response": "def recursively_preempt_states(self):\n        \"\"\" Preempt the state and all of it child states.\n        \"\"\"\n        super(ContainerState, self).recursively_preempt_states()\n        # notify the transition condition variable to let the state instantaneously stop\n        self._transitions_cv.acquire()\n        self._transitions_cv.notify_all()\n        self._transitions_cv.release()\n        for state in self.states.values():\n            state.recursively_preempt_states()"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\npauses the state and all of it child states.", "response": "def recursively_pause_states(self):\n        \"\"\" Pause the state and all of it child states.\n        \"\"\"\n        super(ContainerState, self).recursively_pause_states()\n        for state in self.states.values():\n            state.recursively_pause_states()"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nresumes the state and all of it child states.", "response": "def recursively_resume_states(self):\n        \"\"\" Resume the state and all of it child states.\n        \"\"\"\n        super(ContainerState, self).recursively_resume_states()\n        for state in self.states.values():\n            state.recursively_resume_states()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsetting up the scoped data for the current state class.", "response": "def setup_run(self):\n        \"\"\" Executes a generic set of actions that has to be called in the run methods of each derived state class.\n\n        :return:\n        \"\"\"\n        super(ContainerState, self).setup_run()\n        # reset the scoped data\n        self._scoped_data = {}\n        self._start_state_modified = False\n        self.add_default_values_of_scoped_variables_to_scoped_data()\n        self.add_input_data_to_scoped_data(self.input_data)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nhandling the situation when no start state exists during execution", "response": "def handle_no_start_state(self):\n        \"\"\"Handles the situation, when no start state exists during execution\n\n        The method waits, until a transition is created. It then checks again for an existing start state and waits\n        again, if this is not the case. It returns the None state if the the state machine was stopped.\n        \"\"\"\n        start_state = self.get_start_state(set_final_outcome=True)\n        while not start_state:\n            # depending on the execution mode pause execution\n            execution_signal = state_machine_execution_engine.handle_execution_mode(self)\n            if execution_signal is StateMachineExecutionStatus.STOPPED:\n                # this will be caught at the end of the run method\n                return None\n\n            self._transitions_cv.acquire()\n            self._transitions_cv.wait(3.0)\n            self._transitions_cv.release()\n            start_state = self.get_start_state(set_final_outcome=True)\n        return start_state"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngroups states and scoped variables into a new hierarchy state.", "response": "def group_states(self, state_ids, scoped_variable_ids=None):\n        \"\"\" Group states and scoped variables into a new hierarchy state and remain internal connections.\n            Interconnecting transitions and data flows to parent and other child states are removed, at the moment.\n\n        :param state_ids: state_id's of all states that are to be grouped.\n        :param scoped_variable_ids: data_port_id's of all scoped variables that are to be grouped, too.\n        :return:\n        \"\"\"\n        # TODO remember changed state or state element ids and provide them for the model functionalities\n        assert all([state_id in self.states.keys() for state_id in state_ids])\n        if scoped_variable_ids is None:\n            scoped_variable_ids = []\n        assert all([p_id in self.scoped_variables.keys() for p_id in scoped_variable_ids])\n        from rafcon.core.states.barrier_concurrency_state import DeciderState\n        if any(isinstance(self.states[child_state_id], DeciderState) for child_state_id in state_ids):\n            raise ValueError(\"State of type DeciderState can not be grouped.\")\n\n        def create_name(name_str, used_names):\n            number_str = \"\"\n            number_of_str = 0\n            while name_str + number_str in used_names:\n                number_str = \"_{}\".format(number_of_str)\n                number_of_str += 1\n            return name_str + number_str\n\n        [related_transitions, related_data_flows] = self.related_linkage_states_and_scoped_variables(state_ids,\n                                                                                                     scoped_variable_ids)\n\n        def assign_ingoing_outgoing(df, going_data_linkage_for_port, ingoing=True):\n            internal = 'internal' if ingoing else 'external'\n            external = 'external' if ingoing else 'internal'\n            if (df.to_state, df.to_key) in going_data_linkage_for_port['to']:\n                going_data_linkage_for_port['to'][(df.to_state, df.to_key)][external].append(df)\n            else:\n                going_data_linkage_for_port['to'][(df.to_state, df.to_key)] = {external: [df], internal: [df]}\n            if (df.from_state, df.from_key) in going_data_linkage_for_port['from']:\n                going_data_linkage_for_port['from'][(df.from_state, df.from_key)][internal].append(df)\n            else:\n                going_data_linkage_for_port['from'][(df.from_state, df.from_key)] = {external: [df], internal: [df]}\n\n        def print_df_from_and_to(going_data_linkage_for_port):\n            logger.verbose('data linkage FROM: ')\n            for port, port_dfs in going_data_linkage_for_port['from'].items():\n                logger.verbose(\"\\tport: {0} {1}\".format(port, '' if 'args' not in port_dfs else port_dfs['args']))\n                logger.verbose(\"\\t\\texternal: \\n\\t\\t\\t\" + \"\\n\\t\\t\\t\".join([str(df) for df in port_dfs['external']]))\n                logger.verbose(\"\\t\\tinternal: \\n\\t\\t\\t\" + \"\\n\\t\\t\\t\".join([str(df) for df in port_dfs['internal']]))\n            logger.verbose('data linkage TO: ')\n            for port, port_dfs in going_data_linkage_for_port['to'].items():\n                logger.verbose(\"\\tport: {0} {1}\".format(port, '' if 'args' not in port_dfs else port_dfs['args']))\n                logger.verbose(\"\\t\\texternal: \\n\\t\\t\\t\" + \"\\n\\t\\t\\t\".join([str(df) for df in port_dfs['external']]))\n                logger.verbose(\"\\t\\tinternal: \\n\\t\\t\\t\" + \"\\n\\t\\t\\t\".join([str(df) for df in port_dfs['internal']]))\n\n        def reduce_dfs(port_data_linkages, df_id):\n            for port_key in list(port_data_linkages.keys()):\n                port_df = port_data_linkages[port_key]\n                port_df['internal'] = [df for df in port_df['internal'] if df.data_flow_id != df_id]\n                port_df['external'] = [df for df in port_df['external'] if df.data_flow_id != df_id]\n                if not port_df['internal'] and not port_df['external']:\n                    del port_data_linkages[port_key]\n\n        def do_prior_in_out_going(going_data_linkage_for_port, prior_port_key, prior_locate_key):\n            # logger.info(\"PRIOR IN OUT {0}, {1}\".format(prior_port_key, prior_locate_key))\n            minor_port_key = 'from' if prior_port_key == 'to' else 'to'\n            minor_locate_key = 'external' if prior_locate_key == 'internal' else 'internal'\n            for port_key in list(going_data_linkage_for_port[prior_port_key].keys()):\n                port_dfs = going_data_linkage_for_port[prior_port_key][port_key]\n                # print(prior_port_key, \": check: \", port_key, \" length: \", len(port_dfs[prior_locate_key]))\n                if len(port_dfs[prior_locate_key]) > 1:\n                    for df in port_dfs[prior_locate_key]:\n                        # print(\"remove: \", df.data_flow_id, prior_locate_key, minor_port_key)\n                        reduce_dfs(going_data_linkage_for_port[minor_port_key], df.data_flow_id)\n            for port_key in list(going_data_linkage_for_port[minor_port_key].keys()):\n                port_dfs = going_data_linkage_for_port[minor_port_key][port_key]\n                # print(minor_port_key, \": check: \", port_key, \" length: \", len(port_dfs[minor_locate_key]))\n                if len(port_dfs[minor_locate_key]) > 1:\n                    for df in port_dfs[minor_locate_key]:\n                        # print(\"remove: \", df.data_flow_id, minor_locate_key, prior_port_key)\n                        reduce_dfs(going_data_linkage_for_port[prior_port_key], df.data_flow_id)\n            for port_key in list(going_data_linkage_for_port[prior_port_key].keys()):\n                port_dfs = going_data_linkage_for_port[prior_port_key][port_key]\n                # print(prior_port_key, \": check: \", port_key, \" length: \", len(port_dfs[prior_locate_key]))\n                if len(port_dfs[prior_locate_key]) == 1:\n                    for df in port_dfs[prior_locate_key]:\n                        # print(\"remove: \", df.data_flow_id, prior_locate_key, minor_port_key)\n                        reduce_dfs(going_data_linkage_for_port[minor_port_key], df.data_flow_id)\n\n        def create_data_port_args(going_data_linkage_for_port):\n            names = []\n            for goal, data_port_linkage in going_data_linkage_for_port['to'].items():\n                state = self.states[goal[0]] if goal[0] != self.state_id else self\n                port = state.get_data_port_by_id(goal[1])\n                data_port_linkage['args'] = port.state_element_to_dict(port)\n                data_port_linkage['args']['name'] = create_name(data_port_linkage['args']['name'], names)\n                names.append(data_port_linkage['args']['name'])\n            for goal, data_port_linkage in going_data_linkage_for_port['from'].items():\n                state = self.states[goal[0]] if goal[0] != self.state_id else self\n                port = state.get_data_port_by_id(goal[1])\n                data_port_linkage['args'] = port.state_element_to_dict(port)\n                data_port_linkage['args']['name'] = create_name(data_port_linkage['args']['name'], names)\n                names.append(data_port_linkage['args']['name'])\n\n        ################## IDENTIFY/PRE-PROCESS INGOING DATA FLOWS ###################\n        # ingoing data linkage to rebuild -> overview of all with duplicates\n        ingoing_data_linkage_for_port = {'from': {}, 'to': {}}\n        for df in related_data_flows['ingoing']:\n            assign_ingoing_outgoing(df, ingoing_data_linkage_for_port)\n\n        # logger.info(\"GROUP DATA INGOING BEFORE\")\n        # print_df_from_and_to(ingoing_data_linkage_for_port)\n\n        # prior to-linkage-merge for ingoing over from-linkage-merge -> less internal ingoing data flows\n        do_prior_in_out_going(ingoing_data_linkage_for_port, prior_port_key='to', prior_locate_key='external')\n\n        # logger.info(\"GROUPED INGOING DATA AFTER\")\n        # print_df_from_and_to(ingoing_data_linkage_for_port)\n\n        # get name and args for ports\n        create_data_port_args(ingoing_data_linkage_for_port)\n        # logger.info(\"GROUPED INGOING DATA PORTS\")\n        # print_df_from_and_to(ingoing_data_linkage_for_port)\n\n        ################## IDENTIFY/PRE-PROCESS OUTGOING DATA FLOWS ###################\n        # outgoing data linkage to rebuild -> overview of all with duplicates\n        outgoing_data_linkage_for_port = {'from': {}, 'to': {}}\n        for df in related_data_flows['outgoing']:\n            assign_ingoing_outgoing(df, outgoing_data_linkage_for_port, ingoing=False)\n\n        # logger.info(\"GROUP DATA OUTGOING BEFORE\")\n        # print_df_from_and_to(outgoing_data_linkage_for_port)\n\n        # prior from-linkage-merge for outgoing over to-linkage-merge -> less outgoing data flows\n        do_prior_in_out_going(outgoing_data_linkage_for_port, prior_port_key='from', prior_locate_key='external')\n\n        # logger.info(\"GROUPED OUTGOING DATA AFTER\")\n        # print_df_from_and_to(outgoing_data_linkage_for_port)\n\n        # get name and args for ports\n        create_data_port_args(outgoing_data_linkage_for_port)\n        # logger.info(\"GROUPED OUTGOING DATA PORTS\")\n        # print_df_from_and_to(outgoing_data_linkage_for_port)\n\n        ############################# CREATE NEW STATE #############################\n        # all internal transitions\n        transitions_internal = {t.transition_id: self.remove_transition(t.transition_id, destroy=False)\n                                for t in related_transitions['enclosed']}\n        # all internal data flows\n        data_flows_internal = {df.data_flow_id: self.remove_data_flow(df.data_flow_id, destroy=False)\n                               for df in related_data_flows['enclosed']}\n        # TODO add warning if a data-flow is connected to scoped variables which has ingoing and outgoing data flows\n        # TODO linked with selected states -> group would change behavior and scoped would need to be selected or\n        # TODO                                local scoped variable need to be introduced in new hierarchy state\n        # all internal scoped variables\n        scoped_variables_to_group = {dp_id: self.remove_scoped_variable(dp_id, destroy=False)\n                                     for dp_id in scoped_variable_ids}\n        # all states\n        states_to_group = {state_id: self.remove_state(state_id, recursive=False, destroy=False)\n                           for state_id in state_ids}\n        from rafcon.core.states.hierarchy_state import HierarchyState\n        # secure state id conflicts for the taken transitions\n        from rafcon.core.id_generator import state_id_generator\n        state_id = state_id_generator(used_state_ids=state_ids + [self.state_id])\n        # if scoped variables are used all data flows have to be checked if those link to those and correct the state_id\n        if scoped_variable_ids:\n            for data_flow in data_flows_internal.values():\n                if data_flow.from_state == self.state_id:\n                    data_flow.from_state = state_id\n                if data_flow.to_state == self.state_id:\n                    data_flow.to_state = state_id\n        s = HierarchyState(states=states_to_group, transitions=transitions_internal, data_flows=data_flows_internal,\n                           scoped_variables=scoped_variables_to_group, state_id=state_id)\n        state_id = self.add_state(s)\n\n        def find_logical_destinations_of_transitions(transitions):\n            destinations = {}\n            for t in transitions:\n                if (t.to_state, t.to_outcome) in destinations:\n                    destinations[(t.to_state, t.to_outcome)].append(t)\n                else:\n                    destinations[(t.to_state, t.to_outcome)] = [t]\n            return destinations\n\n        ################## IDENTIFY TRANSITIONS #####################\n        # transition from ingoing transition\n        ingoing_logical_destinations = find_logical_destinations_of_transitions(related_transitions['ingoing'])\n        if len(ingoing_logical_destinations) > 1:\n            logger.warning(\"There is only one ingoing transition on a state possible. \\n\"\n                           \"The following transitions are removed by 'group_states': \\n{}\"\n                           \"\".format('\\n'.join([str(destination) for destination in ingoing_logical_destinations.items()[1:]])))\n        ingoing_transitions = None\n        if len(ingoing_logical_destinations) > 0:\n            ingoing_transitions = list(ingoing_logical_destinations.items())[0][1]\n        # transitions from outgoing transitions\n        transitions_outgoing = {t.transition_id: t for t in related_transitions['outgoing']}\n        outgoing_logical_destinations = find_logical_destinations_of_transitions(related_transitions['outgoing'])\n\n        ################## DO INGOING TRANSITIONS ###################\n        if ingoing_transitions:\n            t = ingoing_transitions[0]\n            s.add_transition(None, None, t.to_state, t.to_outcome)\n            for t in ingoing_transitions:\n                self.add_transition(t.from_state, t.from_outcome, s.state_id, None)\n\n        ################## DO OUTGOING OUTCOMES ###################\n        # outcomes from outgoing transitions\n        outcomes_outgoing_transitions = {}\n        new_outcome_ids = {}\n        state_outcomes_by_name = {oc.name: oc_id for oc_id, oc in s.outcomes.items()}\n        for goal, transitions in list(outgoing_logical_destinations.items()):\n            t = transitions[0]\n            name = s.states[t.from_state].outcomes[t.from_outcome].name\n            # print((t.to_state, t.to_outcome))\n            # print(outcomes_outgoing_transitions)\n            if goal in outcomes_outgoing_transitions:\n                # logger.info(\"old outcome {}\".format((t.to_state, t.to_outcome)))\n                name = outcomes_outgoing_transitions[goal]\n            else:\n                name = create_name(name, list(new_outcome_ids.keys()))\n                outcomes_outgoing_transitions[goal] = name\n            # print(outcomes_outgoing_transitions, \"\\n\", new_outcome_ids)\n            if name not in new_outcome_ids:\n                if name in state_outcomes_by_name:\n                    new_outcome_ids[name] = state_outcomes_by_name[name]\n                    # logger.info(\"old outcome_id {0}\\n{1}\".format(state_outcomes_by_name[name], new_outcome_ids))\n                else:\n                    new_outcome_ids[name] = s.add_outcome(name=name)\n                    # logger.info(\"new outcome_id {0}\\n{1}\".format(new_outcome_ids[name], new_outcome_ids))\n            # else:\n            #     logger.info(\"name {0} in {1} -> {2}\".format(name, new_outcome_ids, outcomes_outgoing_transitions))\n\n        ################## DO OUTGOING TRANSITIONS ###################\n        # external outgoing transitions\n        # print(\"external transitions to create\", outcomes_outgoing_transitions)\n        for goal, name in outcomes_outgoing_transitions.items():\n            try:\n                # avoid to use a outcome twice\n                if any([t for t in s.parent.transitions.values()\n                        if t.from_state == s.state_id and t.from_outcome == new_outcome_ids[name]]):\n                    continue\n                # add the transition for the outcome\n                self.add_transition(s.state_id, new_outcome_ids[name], goal[0], goal[1])\n            except ValueError:\n                logger.exception(\"Error while recreation of logical linkage.\")\n        # internal outgoing transitions\n        # print(\"internal transitions to create\", transitions_outgoing)\n        for t_id, t in transitions_outgoing.items():\n            name = outcomes_outgoing_transitions[(t.to_state, t.to_outcome)]\n            s.add_transition(t.from_state, t.from_outcome, s.state_id, new_outcome_ids[name], t_id)\n\n        new_state_ids = {self.state_id: s.state_id}\n        ############## REBUILD INGOING DATA LINKAGE ################\n        full_linkage = copy(ingoing_data_linkage_for_port['from'])\n        full_linkage.update(ingoing_data_linkage_for_port['to'])\n        for port, data_port_linkage in full_linkage.items():\n            # input data ports from ingoing data flows\n            args = data_port_linkage['args']\n            args['data_port_id'] = None\n            args['data_port_id'] = s.add_input_data_port(**args)\n            # internal data flows from ingoing data flows\n            # print(\"ingoing internal data flows\")\n            for df in data_port_linkage['internal']:\n                # print(df)\n                s.add_data_flow(from_state_id=s.state_id, from_data_port_id=args['data_port_id'],\n                                to_state_id=new_state_ids.get(df.to_state, df.to_state),\n                                to_data_port_id=df.to_key, data_flow_id=df.data_flow_id)\n            # external data flows from ingoing data flows\n            # print(\"ingoing external data flows\")\n            for df in data_port_linkage['external']:\n                # print(df)\n                self.add_data_flow(from_state_id=df.from_state,\n                                   from_data_port_id=df.from_key, to_state_id=s.state_id,\n                                   to_data_port_id=args['data_port_id'], data_flow_id=df.data_flow_id)\n\n        ############## REBUILD OUTGOING DATA LINKAGE ################\n        full_linkage = copy(outgoing_data_linkage_for_port['from'])\n        full_linkage.update(outgoing_data_linkage_for_port['to'])\n        for port, data_port_linkage in full_linkage.items():\n            # output data ports from outgoing data flows\n            args = data_port_linkage['args']\n            args['data_port_id'] = None\n            args['data_port_id'] = s.add_output_data_port(**args)\n            # internal data flows from outgoing data flows\n            # print(\"outgoing internal data flows\")\n            for df in data_port_linkage['internal']:\n                # print(df)\n                s.add_data_flow(from_state_id=new_state_ids.get(df.from_state, df.from_state),\n                                from_data_port_id=df.from_key, to_state_id=s.state_id,\n                                to_data_port_id=args['data_port_id'], data_flow_id=df.data_flow_id)\n            # external data flows from outgoing data flows\n            # print(\"outgoing external data flows\")\n            for df in data_port_linkage['external']:\n                # print(df)\n                self.add_data_flow(from_state_id=s.state_id, from_data_port_id=args['data_port_id'],\n                                   to_state_id=df.to_state, to_data_port_id=df.to_key, data_flow_id=df.data_flow_id)\n\n        return self.states[state_id]"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef add_state(self, state, storage_load=False):\n        assert isinstance(state, State)\n        # logger.info(\"add state {}\".format(state))\n\n        # handle the case that the child state id is the same as the container state id or future sibling state id\n        while state.state_id == self.state_id or state.state_id in self.states:\n            state.change_state_id()\n\n        # TODO: add validity checks for states and then remove this check => to discuss\n        if state.state_id in self._states.keys():\n            raise AttributeError(\"State id %s already exists in the container state\", state.state_id)\n        else:\n            state.parent = self\n            self._states[state.state_id] = state\n\n        return state.state_id", "response": "Adds a state to the container state."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef remove_state(self, state_id, recursive=True, force=False, destroy=True):\n        if state_id not in self.states:\n            raise AttributeError(\"State_id %s does not exist\" % state_id)\n\n        if state_id == self.start_state_id:\n            self.set_start_state(None)\n\n        # first delete all transitions and data_flows, which are connected to the state to be deleted\n        keys_to_delete = []\n        for key, transition in self.transitions.items():\n            if transition.from_state == state_id or transition.to_state == state_id:\n                keys_to_delete.append(key)\n        for key in keys_to_delete:\n            self.remove_transition(key, True)\n\n        keys_to_delete = []\n        for key, data_flow in self.data_flows.items():\n            if data_flow.from_state == state_id or data_flow.to_state == state_id:\n                keys_to_delete.append(key)\n        for key in keys_to_delete:\n            self.remove_data_flow(key)\n\n        if recursive and not destroy:\n            raise AttributeError(\"The recursive flag requires the destroy flag to be set, too.\")\n\n        if destroy:\n            # Recursively delete all transitions, data flows and states within the state to be deleted\n            self.states[state_id].destroy(recursive)\n\n        # final delete the state it self\n        self.states[state_id].parent = None\n        return self.states.pop(state_id)", "response": "Removes a state from the container state."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef destroy(self, recursive):\n        for transition_id in list(self.transitions.keys()):\n            self.remove_transition(transition_id, destroy=recursive)\n        for data_flow_id in list(self.data_flows.keys()):\n            self.remove_data_flow(data_flow_id, destroy=recursive)\n        for scoped_variable_id in list(self.scoped_variables.keys()):\n            self.remove_scoped_variable(scoped_variable_id, destroy=recursive)\n        for state_id in list(self.states.keys()):\n            if recursive:\n                self.remove_state(state_id, recursive, force=True, destroy=recursive)\n            else:\n                del self.states[state_id]\n        super(ContainerState, self).destroy(recursive)", "response": "Removes all the state elements."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a tuple of related_transitions related_data_flows and related_internal_transitions for the given state_id.", "response": "def related_linkage_state(self, state_id):\n        \"\"\" TODO: document\n        \"\"\"\n\n        related_transitions = {'external': {'ingoing': [], 'outgoing': []},\n                               'internal': {'enclosed': [], 'ingoing': [], 'outgoing': []}}\n        related_data_flows = {'external': {'ingoing': [], 'outgoing': []},\n                              'internal': {'enclosed': [], 'ingoing': [], 'outgoing': []}}\n        # ingoing logical linkage to rebuild\n        related_transitions['external']['ingoing'] = [t for t in self.transitions.values() if t.to_state == state_id]\n        # outgoing logical linkage to rebuild\n        related_transitions['external']['outgoing'] = [t for t in self.transitions.values() if t.from_state == state_id]\n        # ingoing data linkage to rebuild\n        related_data_flows['external']['ingoing'] = [df for df in self.data_flows.values() if df.to_state == state_id]\n        # outgoing outgoing linkage to rebuild\n        related_data_flows['external']['outgoing'] = [df for df in self.data_flows.values() if df.from_state == state_id]\n\n        state = self.states[state_id]\n        if not isinstance(state, ContainerState):\n            return related_transitions, related_data_flows\n\n        for t_id, t in state.transitions.items():\n            # check if internal of new hierarchy state\n            if t.from_state in state.states and t.to_state in state.states:\n                related_transitions['internal']['enclosed'].append(t)\n            elif t.to_state in state.states:\n                related_transitions['internal']['ingoing'].append(t)\n            elif t.from_state in state.states:\n                related_transitions['internal']['outgoing'].append(t)\n            else:\n                raise AttributeError(\"All transition have to be ingoing, outgoing or internal.\")\n\n        for df_id, df in state.data_flows.items():\n            # check if internal of hierarchy state\n            if df.from_state in state.states and df.to_state in state.states or \\\n                    df.from_state in state.states and state.state_id == df.to_state and df.to_key in state.scoped_variables or \\\n                    state.state_id == df.from_state and df.from_key in state.scoped_variables and df.to_state in state.states:\n                related_data_flows['internal']['enclosed'].append(df)\n            elif df.to_state in state.states or \\\n                    state.state_id == df.to_state and df.to_key in state.scoped_variables or \\\n                    df.to_state == df.from_state and df.from_key in state.input_data_ports:\n                related_data_flows['internal']['ingoing'].append(df)\n            elif df.from_state in state.states or \\\n                    state.state_id == df.from_state and df.from_key in state.scoped_variables or \\\n                    df.to_state == df.from_state and df.to_key in state.output_data_ports:\n                related_data_flows['internal']['outgoing'].append(df)\n            else:\n                raise AttributeError(\"All data flow have to be ingoing, outgoing or internal.\")\n\n        return related_transitions, related_data_flows"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef related_linkage_states_and_scoped_variables(self, state_ids, scoped_variables):\n\n        # find all related transitions\n        related_transitions = {'enclosed': [], 'ingoing': [], 'outgoing': []}\n        for t in self.transitions.values():\n            # check if internal of new hierarchy state\n            if t.from_state in state_ids and t.to_state in state_ids:\n                related_transitions['enclosed'].append(t)\n            elif t.to_state in state_ids:\n                related_transitions['ingoing'].append(t)\n            elif t.from_state in state_ids:\n                related_transitions['outgoing'].append(t)\n\n        # find all related data flows\n        related_data_flows = {'enclosed': [], 'ingoing': [], 'outgoing': []}\n        for df in self.data_flows.values():\n            # check if internal of new hierarchy state\n            if df.from_state in state_ids and df.to_state in state_ids or \\\n                    df.from_state in state_ids and self.state_id == df.to_state and df.to_key in scoped_variables or \\\n                    self.state_id == df.from_state and df.from_key in scoped_variables and df.to_state in state_ids:\n                related_data_flows['enclosed'].append(df)\n            elif df.to_state in state_ids or \\\n                    self.state_id == df.to_state and df.to_key in scoped_variables:\n                related_data_flows['ingoing'].append(df)\n            elif df.from_state in state_ids or \\\n                    self.state_id == df.from_state and df.from_key in scoped_variables:\n                related_data_flows['outgoing'].append(df)\n\n        return related_transitions, related_data_flows", "response": "This function returns a list of related linkage states and scoped variables."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef change_state_type(self, state, new_state_class):\n        from rafcon.gui.helpers.state import create_new_state_from_state_with_type\n\n        state_id = state.state_id\n\n        if state_id not in self.states:\n            raise ValueError(\"State '{0}' with id '{1}' does not exist\".format(state.name, state_id))\n\n        new_state = create_new_state_from_state_with_type(state, new_state_class)\n        new_state.parent = self\n\n        assert new_state.state_id == state_id\n\n        self.states[state_id] = new_state\n\n        return new_state", "response": "Changes the type of the state to another type"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset the start state of a container state", "response": "def set_start_state(self, state):\n        \"\"\"Sets the start state of a container state\n\n        :param state: The state_id of a state or a direct reference ot he state (that was already added\n                    to the container) that will be the start state of this container state.\n\n        \"\"\"\n        if state is None:\n            self.start_state_id = None\n        elif isinstance(state, State):\n            self.start_state_id = state.state_id\n        else:\n            self.start_state_id = state"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_start_state(self, set_final_outcome=False):\n\n        # overwrite the start state in the case that a specific start state is specific e.g. by start_from_state\n        if self.get_path() in state_machine_execution_engine.start_state_paths:\n            for state_id, state in self.states.items():\n                if state.get_path() in state_machine_execution_engine.start_state_paths:\n                    state_machine_execution_engine.start_state_paths.remove(self.get_path())\n                    self._start_state_modified = True\n                    return state\n\n        if self.start_state_id is None:\n            return None\n\n        # It is possible to connect the income directly with an outcome\n        if self.start_state_id == self.state_id:\n            if set_final_outcome:\n                for transition_id in self.transitions:\n                    # the transition of which the from state is None is the transition that directly connects the income\n                    if self.transitions[transition_id].from_state is None:\n                        to_outcome_id = self.transitions[transition_id].to_outcome\n                        self.final_outcome = self.outcomes[to_outcome_id]\n                        break\n            return self\n\n        return self.states[self.start_state_id]", "response": "Get the start state of the container state."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nremoves the state element from the container state.", "response": "def remove(self, state_element, recursive=True, force=False, destroy=True):\n        \"\"\"Remove item from state\n\n        :param StateElement state_element: State or state element to be removed\n        :param bool recursive: Only applies to removal of state and decides whether the removal should be called\n            recursively on all child states\n        :param bool force: if the removal should be forced without checking constraints\n        :param bool destroy: a flag that signals that the state element will be fully removed and disassembled\n        \"\"\"\n        if isinstance(state_element, State):\n            return self.remove_state(state_element.state_id, recursive=recursive, force=force, destroy=destroy)\n        elif isinstance(state_element, Transition):\n            return self.remove_transition(state_element.transition_id, destroy=destroy)\n        elif isinstance(state_element, DataFlow):\n            return self.remove_data_flow(state_element.data_flow_id, destroy=destroy)\n        elif isinstance(state_element, ScopedVariable):\n            return self.remove_scoped_variable(state_element.data_port_id, destroy=destroy)\n        else:\n            super(ContainerState, self).remove(state_element, force=force, destroy=destroy)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef check_transition_id(self, transition_id):\n        if transition_id is not None:\n            if transition_id in self._transitions.keys():\n                raise AttributeError(\"The transition id %s already exists. Cannot add transition!\", transition_id)\n        else:\n            transition_id = generate_transition_id()\n            while transition_id in self._transitions.keys():\n                transition_id = generate_transition_id()\n        return transition_id", "response": "Checks the transition id and calculates a new one if it does not exist."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef check_if_outcome_already_connected(self, from_state_id, from_outcome):\n        for trans_key, transition in self.transitions.items():\n            if transition.from_state == from_state_id:\n                if transition.from_outcome == from_outcome:\n                    raise AttributeError(\"Outcome %s of state %s is already connected\" %\n                                         (str(from_outcome), str(from_state_id)))", "response": "check if outcome of from state is not already connected to the transition to"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate a new transition.", "response": "def create_transition(self, from_state_id, from_outcome, to_state_id, to_outcome, transition_id):\n        \"\"\" Creates a new transition.\n\n        Lookout: Check the parameters first before creating a new transition\n\n        :param from_state_id: The source state of the transition\n        :param from_outcome: The outcome of the source state to connect the transition to\n        :param to_state_id: The target state of the transition\n        :param to_outcome: The target outcome of a container state\n        :param transition_id: An optional transition id for the new transition\n        :raises exceptions.AttributeError: if the from or to state is incorrect\n        :return: the id of the new transition\n        \"\"\"\n\n        # get correct states\n        if from_state_id is not None:\n            if from_state_id == self.state_id:\n                from_state = self\n            else:\n                from_state = self.states[from_state_id]\n\n        # finally add transition\n        if from_outcome is not None:\n            if from_outcome in from_state.outcomes:\n                if to_outcome is not None:\n                    if to_outcome in self.outcomes:  # if to_state is None then the to_outcome must be an outcome of self\n                        self.transitions[transition_id] = \\\n                            Transition(from_state_id, from_outcome, to_state_id, to_outcome, transition_id, self)\n                    else:\n                        raise AttributeError(\"to_state does not have outcome %s\", to_outcome)\n                else:  # to outcome is None but to_state is not None, so the transition is valid\n                    self.transitions[transition_id] = \\\n                        Transition(from_state_id, from_outcome, to_state_id, to_outcome, transition_id, self)\n            else:\n                raise AttributeError(\"from_state does not have outcome %s\", from_state)\n        else:\n            self.transitions[transition_id] = \\\n                Transition(None, None, to_state_id, to_outcome, transition_id, self)\n\n        # notify all states waiting for transition to be connected\n        self._transitions_cv.acquire()\n        self._transitions_cv.notify_all()\n        self._transitions_cv.release()\n\n        return transition_id"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef add_transition(self, from_state_id, from_outcome, to_state_id, to_outcome, transition_id=None):\n\n        transition_id = self.check_transition_id(transition_id)\n\n        # Set from_state_id to None for start transitions, as from_state_id and from_outcome should both be None for\n        # these transitions\n        if from_state_id == self.state_id and from_outcome is None:\n            from_state_id = None\n\n        new_transition = Transition(from_state_id, from_outcome, to_state_id, to_outcome, transition_id, self)\n        self.transitions[transition_id] = new_transition\n\n        # notify all states waiting for transition to be connected\n        self._transitions_cv.acquire()\n        self._transitions_cv.notify_all()\n        self._transitions_cv.release()\n        # self.create_transition(from_state_id, from_outcome, to_state_id, to_outcome, transition_id)\n        return transition_id", "response": "Adds a transition to the container state"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_transition_for_outcome(self, state, outcome):\n        if not isinstance(state, State):\n            raise TypeError(\"state must be of type State\")\n        if not isinstance(outcome, Outcome):\n            raise TypeError(\"outcome must be of type Outcome\")\n        result_transition = None\n        for key, transition in self.transitions.items():\n            if transition.from_state == state.state_id and transition.from_outcome == outcome.outcome_id:\n                result_transition = transition\n        return result_transition", "response": "Determines the next transition for the given outcome."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef remove_transition(self, transition_id, destroy=True):\n        if transition_id == -1 or transition_id == -2:\n            raise AttributeError(\"The transition_id must not be -1 (Aborted) or -2 (Preempted)\")\n        if transition_id not in self._transitions:\n            raise AttributeError(\"The transition_id %s does not exist\" % str(transition_id))\n\n        self.transitions[transition_id].parent = None\n        return self.transitions.pop(transition_id)", "response": "Removes a transition from the container state."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef remove_outcome_hook(self, outcome_id):\n        for transition_id in list(self.transitions.keys()):\n            transition = self.transitions[transition_id]\n            if transition.to_outcome == outcome_id and transition.to_state == self.state_id:\n                self.remove_transition(transition_id)", "response": "Removes the outcome from the internal state."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nchecking the data flow id and calculate a new one if it does not exist.", "response": "def check_data_flow_id(self, data_flow_id):\n        \"\"\" Check the data flow id and calculate a new one if its None\n\n        :param data_flow_id: The data flow id to check\n        :return: The new data flow id\n        :raises exceptions.AttributeError: if data_flow.data_flow_id already exists\n        \"\"\"\n        if data_flow_id is not None:\n            if data_flow_id in self._data_flows.keys():\n                raise AttributeError(\"The data_flow id %s already exists. Cannot add data_flow!\", data_flow_id)\n        else:\n            data_flow_id = generate_data_flow_id()\n            while data_flow_id in self._data_flows.keys():\n                data_flow_id = generate_data_flow_id()\n        return data_flow_id"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef add_data_flow(self, from_state_id, from_data_port_id, to_state_id, to_data_port_id, data_flow_id=None):\n        data_flow_id = self.check_data_flow_id(data_flow_id)\n\n        self.data_flows[data_flow_id] = DataFlow(from_state_id, from_data_port_id, to_state_id, to_data_port_id,\n                                                 data_flow_id, self)\n        return data_flow_id", "response": "Adds a data flow to the container state"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef remove_data_flow(self, data_flow_id, destroy=True):\n        if data_flow_id not in self._data_flows:\n            raise AttributeError(\"The data_flow_id %s does not exist\" % str(data_flow_id))\n\n        self._data_flows[data_flow_id].parent = None\n        return self._data_flows.pop(data_flow_id)", "response": "Removes a data flow from the container state"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef remove_data_flows_with_data_port_id(self, data_port_id):\n        # delete all data flows in parent related to data_port_id and self.state_id = external data flows\n        # checking is_root_state_of_library is only necessary in case of scoped variables, as the scoped variables\n        # they are not destroyed by the library state, as the library state does not have a reference to the scoped vars\n        if not self.is_root_state and not self.is_root_state_of_library:\n            data_flow_ids_to_remove = []\n            for data_flow_id, data_flow in self.parent.data_flows.items():\n                if data_flow.from_state == self.state_id and data_flow.from_key == data_port_id or \\\n                                        data_flow.to_state == self.state_id and data_flow.to_key == data_port_id:\n                    data_flow_ids_to_remove.append(data_flow_id)\n\n            for data_flow_id in data_flow_ids_to_remove:\n                self.parent.remove_data_flow(data_flow_id)\n\n        # delete all data flows in self related to data_port_id and self.state_id = internal data flows\n        data_flow_ids_to_remove = []\n        for data_flow_id, data_flow in self.data_flows.items():\n            if data_flow.from_state == self.state_id and data_flow.from_key == data_port_id or \\\n                                    data_flow.to_state == self.state_id and data_flow.to_key == data_port_id:\n                data_flow_ids_to_remove.append(data_flow_id)\n\n        for data_flow_id in data_flow_ids_to_remove:\n            self.remove_data_flow(data_flow_id)", "response": "Removes all data flows with the passed data_port_id from the state."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the scoped variable for a unique name", "response": "def get_scoped_variable_from_name(self, name):\n        \"\"\" Get the scoped variable for a unique name\n\n        :param name: the unique name of the scoped variable\n        :return: the scoped variable specified by the name\n        :raises exceptions.AttributeError: if the name is not in the the scoped_variables dictionary\n        \"\"\"\n        for scoped_variable_id, scoped_variable in self.scoped_variables.items():\n            if scoped_variable.name == name:\n                return scoped_variable_id\n        raise AttributeError(\"Name %s is not in scoped_variables dictionary\", name)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef add_scoped_variable(self, name, data_type=None, default_value=None, scoped_variable_id=None):\n        if scoped_variable_id is None:\n            # All data port ids have to passed to the id generation as the data port id has to be unique inside a state\n            scoped_variable_id = generate_data_port_id(self.get_data_port_ids())\n        self._scoped_variables[scoped_variable_id] = ScopedVariable(name, data_type, default_value,\n                                                                    scoped_variable_id, self)\n\n        # Check for name uniqueness\n        valid, message = self._check_data_port_name(self._scoped_variables[scoped_variable_id])\n        if not valid:\n            self._scoped_variables[scoped_variable_id].parent = None\n            del self._scoped_variables[scoped_variable_id]\n            raise ValueError(message)\n\n        return scoped_variable_id", "response": "Adds a scoped variable to the state."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nremove a scoped variable from the container state.", "response": "def remove_scoped_variable(self, scoped_variable_id, destroy=True):\n        \"\"\"Remove a scoped variable from the container state\n\n        :param scoped_variable_id: the id of the scoped variable to remove\n        :raises exceptions.AttributeError: if the id of the scoped variable already exists\n        \"\"\"\n        if scoped_variable_id not in self._scoped_variables:\n            raise AttributeError(\"A scoped variable with id %s does not exist\" % str(scoped_variable_id))\n\n        # delete all data flows connected to scoped_variable\n        if destroy:\n            self.remove_data_flows_with_data_port_id(scoped_variable_id)\n\n        # delete scoped variable\n        self._scoped_variables[scoped_variable_id].parent = None\n        return self._scoped_variables.pop(scoped_variable_id)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_data_port(self, state_id, port_id):\n        if state_id == self.state_id:\n            return self.get_data_port_by_id(port_id)\n        for child_state_id, child_state in self.states.items():\n            if state_id != child_state_id:\n                continue\n            port = child_state.get_data_port_by_id(port_id)\n            if port:\n                return port\n        return None", "response": "Searches for a data port in the state with the specified id and returns the data port object."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_data_port_by_id(self, data_port_id):\n        data_port = super(ContainerState, self).get_data_port_by_id(data_port_id)\n        if data_port:\n            return data_port\n        if data_port_id in self.scoped_variables:\n            return self.scoped_variables[data_port_id]\n        return None", "response": "Search for the given data port id in the state and return the data port with the searched id or None if not found."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_inputs_for_state(self, state):\n        result_dict = {}\n\n        tmp_dict = self.get_default_input_values_for_state(state)\n        result_dict.update(tmp_dict)\n\n        for input_port_key, value in state.input_data_ports.items():\n            # for all input keys fetch the correct data_flow connection and read data into the result_dict\n            actual_value = None\n            actual_value_time = 0\n            for data_flow_key, data_flow in self.data_flows.items():\n\n                if data_flow.to_key == input_port_key:\n                    if data_flow.to_state == state.state_id:\n                        # fetch data from the scoped_data list: the key is the data_port_key + the state_id\n                        key = str(data_flow.from_key) + data_flow.from_state\n                        if key in self.scoped_data:\n                            if actual_value is None or actual_value_time < self.scoped_data[key].timestamp:\n                                actual_value = deepcopy(self.scoped_data[key].value)\n                                actual_value_time = self.scoped_data[key].timestamp\n\n            if actual_value is not None:\n                result_dict[value.name] = actual_value\n\n        return result_dict", "response": "Retrieves all input data for a state"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nadds a dictionary to the scoped data", "response": "def add_input_data_to_scoped_data(self, dictionary):\n        \"\"\"Add a dictionary to the scoped data\n\n        As the input_data dictionary maps names to values, the functions looks for the proper data_ports keys in the\n        input_data_ports dictionary\n\n        :param dictionary: The dictionary that is added to the scoped data\n        :param state: The state to which the input_data was passed (should be self in most cases)\n        \"\"\"\n        for dict_key, value in dictionary.items():\n            for input_data_port_key, data_port in list(self.input_data_ports.items()):\n                if dict_key == data_port.name:\n                    self.scoped_data[str(input_data_port_key) + self.state_id] = \\\n                        ScopedData(data_port.name, value, type(value), self.state_id, ScopedVariable, parent=self)\n                    # forward the data to scoped variables\n                    for data_flow_key, data_flow in self.data_flows.items():\n                        if data_flow.from_key == input_data_port_key and data_flow.from_state == self.state_id:\n                            if data_flow.to_state == self.state_id and data_flow.to_key in self.scoped_variables:\n                                current_scoped_variable = self.scoped_variables[data_flow.to_key]\n                                self.scoped_data[str(data_flow.to_key) + self.state_id] = \\\n                                    ScopedData(current_scoped_variable.name, value, type(value), self.state_id,\n                                               ScopedVariable, parent=self)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef add_state_execution_output_to_scoped_data(self, dictionary, state):\n        for output_name, value in dictionary.items():\n            for output_data_port_key, data_port in list(state.output_data_ports.items()):\n                if output_name == data_port.name:\n                    if not isinstance(value, data_port.data_type):\n                        if (not ((type(value) is float or type(value) is int) and\n                                     (data_port.data_type is float or data_port.data_type is int)) and\n                                not (isinstance(value, type(None)))):\n                            logger.error(\"The data type of output port {0} should be of type {1}, but is of type {2}\".\n                                         format(output_name, data_port.data_type, type(value)))\n                    self.scoped_data[str(output_data_port_key) + state.state_id] = \\\n                        ScopedData(data_port.name, value, type(value), state.state_id, OutputDataPort, parent=self)", "response": "Adds a state execution output to the scoped data"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef add_default_values_of_scoped_variables_to_scoped_data(self):\n        for key, scoped_var in self.scoped_variables.items():\n            self.scoped_data[str(scoped_var.data_port_id) + self.state_id] = \\\n                ScopedData(scoped_var.name, scoped_var.default_value, scoped_var.data_type, self.state_id,\n                           ScopedVariable, parent=self)", "response": "Add the default values of the scoped variables to the scoped data dictionary"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nupdating the values of the scoped variables with the output dictionary of a specific state.", "response": "def update_scoped_variables_with_output_dictionary(self, dictionary, state):\n        \"\"\"Update the values of the scoped variables with the output dictionary of a specific state.\n\n        :param: the dictionary to update the scoped variables with\n        :param: the state the output dictionary belongs to\n        \"\"\"\n        for key, value in dictionary.items():\n            output_data_port_key = None\n            # search for the correct output data port key of the source state\n            for o_key, o_port in state.output_data_ports.items():\n                if o_port.name == key:\n                    output_data_port_key = o_key\n                    break\n            if output_data_port_key is None:\n                if not key == \"error\":\n                    logger.warning(\"Output variable %s was written during state execution, \"\n                                   \"that has no data port connected to it.\", str(key))\n            for data_flow_key, data_flow in self.data_flows.items():\n                if data_flow.from_key == output_data_port_key and data_flow.from_state == state.state_id:\n                    if data_flow.to_state == self.state_id:  # is target of data flow own state id?\n                        if data_flow.to_key in self.scoped_variables.keys():  # is target data port scoped?\n                            current_scoped_variable = self.scoped_variables[data_flow.to_key]\n                            self.scoped_data[str(data_flow.to_key) + self.state_id] = \\\n                                ScopedData(current_scoped_variable.name, value, type(value), state.state_id,\n                                           ScopedVariable, parent=self)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef change_state_id(self, state_id=None):\n        old_state_id = self.state_id\n        super(ContainerState, self).change_state_id(state_id)\n        # Use private variables to change ids to prevent validity checks\n        # change id in all transitions\n        for transition in self.transitions.values():\n            if transition.from_state == old_state_id:\n                transition._from_state = self.state_id\n            if transition.to_state == old_state_id:\n                transition._to_state = self.state_id\n\n        # change id in all data_flows\n        for data_flow in self.data_flows.values():\n            if data_flow.from_state == old_state_id:\n                data_flow._from_state = self.state_id\n            if data_flow.to_state == old_state_id:\n                data_flow._to_state = self.state_id", "response": "Changes the id of the state of the container state to a new id. This function replaces the old state_id with the new state_id in all the state tables and data flows and transitions."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncalculates the target state of a transition", "response": "def get_state_for_transition(self, transition):\n        \"\"\"Calculate the target state of a transition\n\n        :param transition: The transition of which the target state is determined\n        :return: the to-state of the transition\n        :raises exceptions.TypeError: if the transition parameter is of wrong type\n        \"\"\"\n        if not isinstance(transition, Transition):\n            raise TypeError(\"transition must be of type Transition\")\n        # the to_state is None when the transition connects an outcome of a child state to the outcome of a parent state\n        if transition.to_state == self.state_id or transition.to_state is None:\n            return self\n        else:\n            return self.states[transition.to_state]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef write_output_data(self, specific_output_dictionary=None):\n        if isinstance(specific_output_dictionary, dict):\n            output_dict = specific_output_dictionary\n        else:\n            output_dict = self.output_data\n\n        for output_name, value in self.output_data.items():\n            output_port_id = self.get_io_data_port_id_from_name_and_type(output_name, OutputDataPort)\n            actual_value = None\n            actual_value_was_written = False\n            actual_value_time = 0\n            for data_flow_id, data_flow in self.data_flows.items():\n                if data_flow.to_state == self.state_id:\n                    if data_flow.to_key == output_port_id:\n                        scoped_data_key = str(data_flow.from_key) + data_flow.from_state\n                        if scoped_data_key in self.scoped_data:\n                            # if self.scoped_data[scoped_data_key].timestamp > actual_value_time is True\n                            # the data of a previous execution of the same state is overwritten\n                            if actual_value is None or self.scoped_data[scoped_data_key].timestamp > actual_value_time:\n                                actual_value = deepcopy(self.scoped_data[scoped_data_key].value)\n                                actual_value_time = self.scoped_data[scoped_data_key].timestamp\n                                actual_value_was_written = True\n                        else:\n                            if not self.backward_execution:\n                                logger.debug(\n                                    \"Output data with name {0} of state {1} was not found in the scoped data \"\n                                    \"of state {2}. Thus the state did not write onto this output. \"\n                                    \"This can mean a state machine design error.\".format(\n                                        str(output_name), str(self.states[data_flow.from_state].get_path()),\n                                        self.get_path()))\n            if actual_value_was_written:\n                output_dict[output_name] = actual_value", "response": "Write the scoped data to output of the container state."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef check_child_validity(self, child):\n        # First let the state do validity checks for outcomes and data ports\n        valid, message = super(ContainerState, self).check_child_validity(child)\n        if not valid and not message.startswith(\"Invalid state element\"):\n            return False, message\n        # Continue with checks if previous ones did not fail\n        # Check type of child and call appropriate validity test\n        if isinstance(child, DataFlow):\n            return self._check_data_flow_validity(child)\n        if isinstance(child, Transition):\n            return self._check_transition_validity(child)\n        return valid, message", "response": "Check validity of passed child object"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncheck the validity of a data port", "response": "def check_data_port_connection(self, check_data_port):\n        \"\"\"Checks the connection validity of a data port\n\n        The method is called by a child state to check the validity of a data port in case it is connected with data\n        flows. The data port does not belong to 'self', but to one of self.states.\n        If the data port is connected to a data flow, the method checks, whether these connect consistent data types\n        of ports.\n\n        :param rafcon.core.data_port.DataPort check_data_port: The port to check\n        :return: valid, message\n        \"\"\"\n        for data_flow in self.data_flows.values():\n            # Check whether the data flow connects the given port\n            from_port = self.get_data_port(data_flow.from_state, data_flow.from_key)\n            to_port = self.get_data_port(data_flow.to_state, data_flow.to_key)\n            if check_data_port is from_port or check_data_port is to_port:\n                # check if one of the data_types if type 'object'; in this case the data flow is always valid\n                if not (from_port.data_type is object or to_port.data_type is object):\n                    if not type_inherits_of_type(from_port.data_type, to_port.data_type):\n                        return False, \"Connection of two non-compatible data types\"\n        return True, \"valid\""}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _check_data_port_id(self, data_port):\n        # First check inputs and outputs\n        valid, message = super(ContainerState, self)._check_data_port_id(data_port)\n        if not valid:\n            return False, message\n        # Container state also has scoped variables\n        for scoped_variable_id, scoped_variable in self.scoped_variables.items():\n            if data_port.data_port_id == scoped_variable_id and data_port is not scoped_variable:\n                return False, \"data port id already existing in state\"\n        return True, message", "response": "Checks the validity of a data port id"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nchecks the validity of a data port name", "response": "def _check_data_port_name(self, data_port):\n        \"\"\"Checks the validity of a data port name\n\n        Checks whether the name of the given data port is already used by anther data port within the state. Names\n        must be unique with input data ports, output data ports and scoped variables.\n\n        :param rafcon.core.data_port.DataPort data_port: The data port to be checked\n        :return bool validity, str message: validity is True, when the data port is valid, False else. message gives\n            more information especially if the data port is not valid\n        \"\"\"\n        # First check inputs and outputs\n        valid, message = super(ContainerState, self)._check_data_port_name(data_port)\n        if not valid:\n            return False, message\n\n        if data_port.data_port_id in self.scoped_variables:\n            for scoped_variable in self.scoped_variables.values():\n                if data_port.name == scoped_variable.name and data_port is not scoped_variable:\n                    return False, \"scoped variable name already existing in state's scoped variables\"\n\n        return True, message"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _check_data_flow_validity(self, check_data_flow):\n        valid, message = self._check_data_flow_id(check_data_flow)\n        if not valid:\n            return False, message\n\n        valid, message = self._check_data_flow_ports(check_data_flow)\n        if not valid:\n            return False, message\n\n        return self._check_data_flow_types(check_data_flow)", "response": "Checks the validity of a data flow"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nchecks the validity of a data flow id", "response": "def _check_data_flow_id(self, data_flow):\n        \"\"\"Checks the validity of a data flow id\n\n        Checks whether the id of the given data flow is already by anther data flow used within the state.\n\n        :param rafcon.core.data_flow.DataFlow data_flow: The data flow to be checked\n        :return bool validity, str message: validity is True, when the data flow is valid, False else. message gives\n            more information especially if the data flow is not valid\n        \"\"\"\n        data_flow_id = data_flow.data_flow_id\n        if data_flow_id in self.data_flows and data_flow is not self.data_flows[data_flow_id]:\n            return False, \"data_flow_id already existing\"\n        return True, \"valid\""}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _check_data_flow_ports(self, data_flow):\n        from_state_id = data_flow.from_state\n        to_state_id = data_flow.to_state\n        from_data_port_id = data_flow.from_key\n        to_data_port_id = data_flow.to_key\n\n        # Check whether to and from port are existing\n        from_data_port = self.get_data_port(from_state_id, from_data_port_id)\n        if not from_data_port:\n            return False, \"Data flow origin not existing -> {0}\".format(data_flow)\n        to_data_port = self.get_data_port(to_state_id, to_data_port_id)\n        if not to_data_port:\n            return False, \"Data flow target not existing -> {0}\".format(data_flow)\n\n        # Data_ports without parents are not allowed to be connected twice\n        if not from_data_port.parent:\n            return False, \"Source data port does not have a parent -> {0}\".format(data_flow)\n        if not to_data_port.parent:\n            return False, \"Target data port does not have a parent -> {0}\".format(data_flow)\n\n        # Check if data ports are identical\n        if from_data_port is to_data_port:\n            return False, \"Source and target data ports of data flow must not be identical -> {}\".format(data_flow)\n\n        # Check, whether the origin of the data flow is valid\n        if from_state_id == self.state_id:  # data_flow originates in container state\n            if from_data_port_id not in self.input_data_ports and from_data_port_id not in self.scoped_variables:\n                return False, \"Data flow origin port must be an input port or scoped variable, when the data flow \" \\\n                              \"starts in the parent state -> {0}\".format(data_flow)\n        else:  # data flow originates in child state\n            if from_data_port_id not in from_data_port.parent.output_data_ports:\n                return False, \"Data flow origin port must be an output port, when the data flow \" \\\n                              \"starts in the child state -> {0}\".format(data_flow)\n\n        # Check, whether the target of a data flow is valid\n        if to_state_id == self.state_id:  # data_flow ends in container state\n            if to_data_port_id not in self.output_data_ports and to_data_port_id not in self.scoped_variables:\n                return False, \"Data flow target port must be an output port or scoped variable, when the data flow \" \\\n                              \"goes to the parent state -> {0}\".format(data_flow)\n        else:  # data_flow ends in child state\n            if to_data_port_id not in to_data_port.parent.input_data_ports:\n                return False, \"Data flow target port must be an input port, when the data flow goes to a child state\" \\\n                              \" -> {0}\".format(data_flow)\n\n        # Check if data flow connects two scoped variables\n        if isinstance(from_data_port, ScopedVariable) and isinstance(to_data_port, ScopedVariable):\n            return False, \"Data flows must not connect two scoped variables -> {}\".format(data_flow)\n\n        # Check, whether the target port is already connected\n        for existing_data_flow in self.data_flows.values():\n            to_data_port_existing = self.get_data_port(existing_data_flow.to_state, existing_data_flow.to_key)\n            from_data_port_existing = self.get_data_port(existing_data_flow.from_state, existing_data_flow.from_key)\n            if to_data_port is to_data_port_existing and data_flow is not existing_data_flow:\n                if from_data_port is from_data_port_existing:\n                    return False, \"Exactly the same data flow is already existing -> {0}\".format(data_flow)\n\n        return True, \"valid\"", "response": "Checks the validity of the ports of a data flow"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nchecking the validity of the data flow connection", "response": "def _check_data_flow_types(self, check_data_flow):\n        \"\"\"Checks the validity of the data flow connection\n\n        Checks whether the ports of a data flow have matching data types.\n\n        :param rafcon.core.data_flow.DataFlow check_data_flow: The data flow to be checked\n        :return bool validity, str message: validity is True, when the data flow is valid, False else. message gives\n            more information especially if the data flow is not valid\n        \"\"\"\n        # Check whether the data types or origin and target fit\n        from_data_port = self.get_data_port(check_data_flow.from_state, check_data_flow.from_key)\n        to_data_port = self.get_data_port(check_data_flow.to_state, check_data_flow.to_key)\n        # Connections from the data port type \"object\" are always allowed\n        if from_data_port.data_type is object:\n            return True, \"valid\"\n        if not type_inherits_of_type(from_data_port.data_type, to_data_port.data_type):\n            return False, \"Data flow (id: {0}) with origin state \\\"{1}\\\" (from data port name: {2}) \" \\\n                          \"and target state \\\"{3}\\\" (to data port name: {4}) \" \\\n                          \"do not have matching data types (from '{5}' to '{6}')\".format(\n                              check_data_flow.data_flow_id,\n                              from_data_port.parent.name,\n                              from_data_port.name,\n                              to_data_port.parent.name,\n                              to_data_port.name,\n                              from_data_port.data_type,\n                              to_data_port.data_type)\n        return True, \"valid\""}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _check_transition_validity(self, check_transition):\n        valid, message = self._check_transition_id(check_transition)\n        if not valid:\n            return False, message\n\n        # Separate check for start transitions\n        if check_transition.from_state is None:\n            return self._check_start_transition(check_transition)\n\n        valid, message = self._check_transition_origin(check_transition)\n        if not valid:\n            return False, message\n\n        valid, message = self._check_transition_target(check_transition)\n        if not valid:\n            return False, message\n\n        return self._check_transition_connection(check_transition)", "response": "Checks the validity of a transition."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _check_transition_id(self, transition):\n        transition_id = transition.transition_id\n        if transition_id in self.transitions and transition is not self.transitions[transition_id]:\n            return False, \"transition_id already existing\"\n        return True, \"valid\"", "response": "Checks whether the transition id is already used by another transition within the state"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncheck whether the given transition is a start transition", "response": "def _check_start_transition(self, start_transition):\n        \"\"\"Checks the validity of a start transition\n\n        Checks whether the given transition is a start transition a whether it is the only one within the state.\n\n        :param rafcon.core.transition.Transition start_transition: The transition to be checked\n        :return bool validity, str message: validity is True, when the transition is valid, False else. message gives\n            more information especially if the transition is not valid\n        \"\"\"\n        for transition in self.transitions.values():\n            if transition.from_state is None:\n                if start_transition is not transition:\n                    return False, \"Only one start transition is allowed\"\n\n        if start_transition.from_outcome is not None:\n            return False, \"from_outcome must not be set in start transition\"\n\n        return self._check_transition_target(start_transition)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncheck the validity of a transition target", "response": "def _check_transition_target(self, transition):\n        \"\"\"Checks the validity of a transition target\n\n        Checks whether the transition target is valid.\n\n        :param rafcon.core.transition.Transition transition: The transition to be checked\n        :return bool validity, str message: validity is True, when the transition is valid, False else. message gives\n            more information especially if the transition is not valid\n        \"\"\"\n\n        to_state_id = transition.to_state\n        to_outcome_id = transition.to_outcome\n\n        if to_state_id == self.state_id:\n            if to_outcome_id not in self.outcomes:\n                return False, \"to_outcome is not existing\"\n        else:\n            if to_state_id not in self.states:\n                return False, \"to_state is not existing\"\n            if to_outcome_id is not None:\n                return False, \"to_outcome must be None as transition goes to child state\"\n\n        return True, \"valid\""}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncheck the validity of a transition origin", "response": "def _check_transition_origin(self, transition):\n        \"\"\"Checks the validity of a transition origin\n\n        Checks whether the transition origin is valid.\n\n        :param rafcon.core.transition.Transition transition: The transition to be checked\n        :return bool validity, str message: validity is True, when the transition is valid, False else. message gives\n            more information especially if the transition is not valid\n        \"\"\"\n        from_state_id = transition.from_state\n        from_outcome_id = transition.from_outcome\n\n        if from_state_id == self.state_id:\n            return False, \"from_state_id of transition must not be the container state itself.\" \\\n                          \" In the case of a start transition both the from state and the from_outcome are None.\"\n\n        if from_state_id != self.state_id and from_state_id not in self.states:\n            return False, \"from_state not existing\"\n\n        from_outcome = self.get_outcome(from_state_id, from_outcome_id)\n        if from_outcome is None:\n            return False, \"from_outcome not existing in from_state\"\n\n        return True, \"valid\""}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncheck the validity of a transition connection", "response": "def _check_transition_connection(self, check_transition):\n        \"\"\"Checks the validity of a transition connection\n\n        Checks whether the transition is allowed to connect the origin with the target.\n\n        :param rafcon.core.transition.Transition check_transition: The transition to be checked\n        :return bool validity, str message: validity is True, when the transition is valid, False else. message gives\n            more information especially if the transition is not valid\n        \"\"\"\n        from_state_id = check_transition.from_state\n        from_outcome_id = check_transition.from_outcome\n        to_state_id = check_transition.to_state\n        to_outcome_id = check_transition.to_outcome\n\n        # check for connected origin\n        for transition in self.transitions.values():\n            if transition.from_state == from_state_id:\n                if transition.from_outcome == from_outcome_id:\n                    if check_transition is not transition:\n                        return False, \"transition origin already connected to another transition\"\n\n        if from_state_id in self.states and to_state_id in self.states and to_outcome_id is not None:\n            return False, \"no transition from one outcome to another one on the same hierarchy allowed\"\n\n        return True, \"valid\""}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the numer of child states and the maximal child states.", "response": "def get_states_statistics(self, hierarchy_level):\n        \"\"\"\n        Returns the numer of child states\n        :return:\n        \"\"\"\n        number_of_all_child_states = 0\n        max_child_hierarchy_level = 0\n        for s in self.states.values():\n            child_hierarchy_level = 0\n            number_of_child_states, child_hierarchy_level = s.get_states_statistics(child_hierarchy_level)\n            number_of_all_child_states += number_of_child_states\n            if child_hierarchy_level > max_child_hierarchy_level:\n                max_child_hierarchy_level = child_hierarchy_level\n\n        return number_of_all_child_states + 1, hierarchy_level + max_child_hierarchy_level + 1"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the number of child states that are in the same state.", "response": "def get_number_of_transitions(self):\n        \"\"\"\n        Returns the numer of child states\n        :return:\n        \"\"\"\n        number_of_all_transitions = 0\n        for s in self.states.values():\n            number_of_all_transitions += s.get_number_of_transitions()\n        return number_of_all_transitions + len(self.transitions)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef start_state_id(self):\n        for transition_id in self.transitions:\n            if self.transitions[transition_id].from_state is None:\n                to_state = self.transitions[transition_id].to_state\n                if to_state is not None:\n                    return to_state\n                else:\n                    return self.state_id\n        return None", "response": "Returns the id of the first state in which the first transition goes to."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsets the start state of the container state.", "response": "def start_state_id(self, start_state_id, to_outcome=None):\n        \"\"\"Set the start state of the container state\n\n        See property\n\n        :param start_state_id: The state id of the state which should be executed first in the Container state\n        :raises exceptions.ValueError: if the start_state_id does not exist in\n                                    :py:attr:`rafcon.core.states.container_state.ContainerState.states`\n        \"\"\"\n        if start_state_id is not None and start_state_id not in self.states:\n            raise ValueError(\"start_state_id does not exist\")\n\n        if start_state_id is None and to_outcome is not None:  # this is the case if the start state is the state itself\n            if to_outcome not in self.outcomes:\n                raise ValueError(\"to_outcome does not exist\")\n            if start_state_id != self.state_id:\n                raise ValueError(\"to_outcome defined but start_state_id is not state_id\")\n\n        # First we remove the transition to the start state\n        for transition_id in self.transitions:\n            if self.transitions[transition_id].from_state is None:\n                # If the current start state is the same as the old one, we don't have to do anything\n                if self.transitions[transition_id].to_state == start_state_id:\n                    return\n                self.remove_transition(transition_id)\n                break\n        if start_state_id is not None:\n            self.add_transition(None, None, start_state_id, to_outcome)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef scoped_variables(self, scoped_variables):\n        if not isinstance(scoped_variables, dict):\n            raise TypeError(\"scoped_variables must be of type dict\")\n        if [sv_id for sv_id, sv in scoped_variables.items() if not isinstance(sv, ScopedVariable)]:\n            raise TypeError(\"element of scope variable must be of type ScopedVariable\")\n        if [sv_id for sv_id, sv in scoped_variables.items() if not sv_id == sv.data_port_id]:\n            raise AttributeError(\"The key of the scope variable dictionary and \"\n                                 \"the id of the scope variable do not match\")\n\n        old_scoped_variables = self._scoped_variables\n        self._scoped_variables = scoped_variables\n        for port_id, scoped_variable in scoped_variables.items():\n            try:\n                scoped_variable.parent = self\n            except ValueError:\n                self._scoped_variables = old_scoped_variables\n                raise\n\n        # check that all old_scoped_variables are no more referencing self as there parent\n        for old_scoped_variable in old_scoped_variables.values():\n            if old_scoped_variable not in self._scoped_variables.values() and old_scoped_variable.parent is self:\n                old_scoped_variable.parent = None", "response": "Setter for _scoped_variables field\nMimeType"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncalling the custom execute function of the state object and returns the result of the execution.", "response": "def _execute(self, execute_inputs, execute_outputs, backward_execution=False):\n        \"\"\"Calls the custom execute function of the script.py of the state\n\n        \"\"\"\n        self._script.build_module()\n\n        outcome_item = self._script.execute(self, execute_inputs, execute_outputs, backward_execution)\n\n        # in the case of backward execution the outcome is not relevant\n        if backward_execution:\n            return\n\n        # If the state was preempted, the state must be left on the preempted outcome\n        if self.preempted:\n            return Outcome(-2, \"preempted\")\n\n        # Outcome id was returned\n        if outcome_item in self.outcomes:\n            return self.outcomes[outcome_item]\n\n        # Outcome name was returned\n        for outcome_id, outcome in self.outcomes.items():\n            if outcome.name == outcome_item:\n                return self.outcomes[outcome_id]\n\n        logger.error(\"Returned outcome of {0} not existing: {1}\".format(self, outcome_item))\n        return Outcome(-1, \"aborted\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef run(self):\n        if self.is_root_state:\n            self.execution_history.push_call_history_item(self, CallType.EXECUTE, None, self.input_data)\n\n        logger.debug(\"Running {0}{1}\".format(self, \" (backwards)\" if self.backward_execution else \"\"))\n        if self.backward_execution:\n            self.setup_backward_run()\n        else:\n            self.setup_run()\n\n        try:\n            outcome = self._execute(self.input_data, self.output_data, self.backward_execution)\n            self.state_execution_status = StateExecutionStatus.WAIT_FOR_NEXT_STATE\n\n            if self.backward_execution:\n                # outcome handling is not required as we are in backward mode and the execution order is fixed\n                result = self.finalize()\n            else:\n                # check output data\n                self.check_output_data_type()\n                result = self.finalize(outcome)\n\n            if self.is_root_state:\n                self.execution_history.push_return_history_item(self, CallType.EXECUTE, None, self.output_data)\n            return result\n        except Exception as e:\n            exc_type, exc_value, exc_traceback = sys.exc_info()\n            formatted_exc = traceback.format_exception(exc_type, exc_value, exc_traceback)\n            truncated_exc = []\n            for line in formatted_exc:\n                if os.path.join(\"rafcon\", \"core\") not in line:\n                    truncated_exc.append(line)\n            logger.error(\"{0} had an internal error: {1}: {2}\\n{3}\".format(self, type(e).__name__, e,\n                                                                           ''.join(truncated_exc)))\n            # write error to the output_data of the state\n            self.output_data[\"error\"] = e\n            self.state_execution_status = StateExecutionStatus.WAIT_FOR_NEXT_STATE\n            return self.finalize(Outcome(-1, \"aborted\"))", "response": "This method executes the state and returns the result of the execution."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef register_view(self, view):\n        super(StateMachineTreeController, self).register_view(view)\n        self.view.connect('button_press_event', self.mouse_click)\n        self.view_is_registered = True\n        self.update(with_expand=True)", "response": "Called when the view was registered"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef register_actions(self, shortcut_manager):\n        shortcut_manager.add_callback_for_action(\"delete\", self._delete_selection)\n        shortcut_manager.add_callback_for_action(\"add\", partial(self._add_new_state, state_type=StateType.EXECUTION))\n        shortcut_manager.add_callback_for_action(\"add2\", partial(self._add_new_state, state_type=StateType.HIERARCHY))\n        shortcut_manager.add_callback_for_action(\"copy\", self.copy_action_callback)\n        shortcut_manager.add_callback_for_action(\"cut\", self.cut_action_callback)\n        shortcut_manager.add_callback_for_action(\"paste\", self.paste_action_callback)", "response": "Register callback methods for triggered actions\n           "}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef register(self):\n        self._do_selection_update = True\n        # relieve old model\n        if self.__my_selected_sm_id is not None:  # no old models available\n            self.relieve_model(self._selected_sm_model)\n        # set own selected state machine id\n        self.__my_selected_sm_id = self.model.selected_state_machine_id\n        if self.__my_selected_sm_id is not None:\n            # observe new model\n            self._selected_sm_model = self.model.state_machines[self.__my_selected_sm_id]\n            self.observe_model(self._selected_sm_model)  # for selection\n            self.update()\n        else:\n            self._selected_sm_model = None\n            self.state_row_iter_dict_by_state_path.clear()\n            self.tree_store.clear()\n        self._do_selection_update = False", "response": "Change the state machine that is observed for new selected states to the selected state machine."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef paste_action_callback(self, *event):\n        if react_to_event(self.view, self.tree_view, event):\n            sm_selection, _ = self.get_state_machine_selection()\n            # only list specific elements are cut by widget\n            if len(sm_selection.states) == 1:\n                global_clipboard.paste(sm_selection.get_selected_state(), limited=['states', 'transitions', 'data_flows'])\n            else:\n                logger.warning(\"Please select only one state to paste.\")\n            return True", "response": "Callback method for paste action"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ntriggering when the add new state is clicked.", "response": "def _add_new_state(self, *event, **kwargs):\n        \"\"\"Triggered when shortcut keys for adding a new state are pressed, or Menu Bar \"Edit, Add State\" is clicked.\n\n        Adds a new state only if the the state machine tree is in focus.\n        \"\"\"\n        if react_to_event(self.view, self.view['state_machine_tree_view'], event):\n            state_type = StateType.EXECUTION if 'state_type' not in kwargs else kwargs['state_type']\n            gui_helper_state_machine.add_new_state(self._selected_sm_model, state_type)\n            return True"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef selection_changed(self, widget, event=None):\n        # do not forward cursor selection updates if state update is running\n        # TODO maybe make this generic for respective abstract controller\n        if self._state_which_is_updated:\n            return\n        super(StateMachineTreeController, self).selection_changed(widget, event)", "response": "Notify state machine about tree view selection"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nconsidering the tree to be collapsed and expand into all tree items with the flag set True", "response": "def redo_expansion_state(self, ignore_not_existing_rows=False):\n        \"\"\" Considers the tree to be collapsed and expand into all tree item with the flag set True \"\"\"\n\n        def set_expansion_state(state_path):\n            state_row_iter = self.state_row_iter_dict_by_state_path[state_path]\n            if state_row_iter:  # may elements are missing afterwards\n                state_row_path = self.tree_store.get_path(state_row_iter)\n                self.view.expand_to_path(state_row_path)\n\n        if self.__my_selected_sm_id is not None and self.__my_selected_sm_id in self.__expansion_state:\n            expansion_state = self.__expansion_state[self.__my_selected_sm_id]\n            try:\n                for state_path, state_row_expanded in expansion_state.items():\n                    if state_path in self.state_row_iter_dict_by_state_path:\n                        if state_row_expanded:\n                            set_expansion_state(state_path)\n                    else:\n                        if not ignore_not_existing_rows and self._selected_sm_model and \\\n                                self._selected_sm_model.state_machine.get_state_by_path(state_path, as_check=True):\n                            state = self._selected_sm_model.state_machine.get_state_by_path(state_path)\n                            if isinstance(state, LibraryState) or state.is_root_state_of_library or \\\n                                    state.get_next_upper_library_root_state():\n                                continue\n                            logger.error(\"State not in StateMachineTree but in StateMachine, {0}.\".format(state_path))\n\n            except (TypeError, KeyError):\n                logger.error(\"Expansion state of state machine {0} could not be restored\"\n                             \"\".format(self.__my_selected_sm_id))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef update(self, changed_state_model=None, with_expand=False):\n        if not self.view_is_registered:\n            return\n\n        # define initial state-model for update\n        if changed_state_model is None:\n            # reset all\n            parent_row_iter = None\n            self.state_row_iter_dict_by_state_path.clear()\n            self.tree_store.clear()\n            if self._selected_sm_model:\n                changed_state_model = self._selected_sm_model.root_state\n            else:\n                return\n        else:  # pick\n            if changed_state_model.state.is_root_state:\n                parent_row_iter = self.state_row_iter_dict_by_state_path[changed_state_model.state.get_path()]\n            else:\n                if changed_state_model.state.is_root_state_of_library:\n                    # because either lib-state or lib-state-root is in tree the next higher hierarchy state is updated\n                    changed_upper_state_m = changed_state_model.parent.parent\n                else:\n                    changed_upper_state_m = changed_state_model.parent\n                # TODO check the work around of the next 2 lines while refactoring -> it is a check to be more robust\n                while changed_upper_state_m.state.get_path() not in self.state_row_iter_dict_by_state_path:\n                    # show Warning because because avoided method states_update\n                    logger.warning(\"Take a parent state because this is not in.\")\n                    changed_upper_state_m = changed_upper_state_m.parent\n                parent_row_iter = self.state_row_iter_dict_by_state_path[changed_upper_state_m.state.get_path()]\n\n        # do recursive update\n        self.insert_and_update_recursively(parent_row_iter, changed_state_model, with_expand)", "response": "Updates the state - model of the current state - model with the new state - model of the current state - model."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef show_content(self, state_model):\n        upper_most_lib_state_m = None\n        if isinstance(state_model, LibraryStateModel):\n            uppermost_library_root_state = state_model.state.get_uppermost_library_root_state()\n            if uppermost_library_root_state is None:\n                upper_most_lib_state_m = state_model\n            else:\n                upper_lib_state = uppermost_library_root_state.parent\n                upper_most_lib_state_m = self._selected_sm_model.get_state_model_by_path(upper_lib_state.get_path())\n        if upper_most_lib_state_m:\n            return upper_most_lib_state_m.show_content()\n        else:\n            return True", "response": "Check if the state machine tree specific show content flag is set."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ninserts and update the handed state model in the tree store element iteratorparent_iter.", "response": "def insert_and_update_recursively(self, parent_iter, state_model, with_expand=False):\n        \"\"\" Insert and/or update the handed state model in parent tree store element iterator\n\n        :param parent_iter: Parent tree store iterator the insert should be performed in\n        :param StateModel state_model: Model of state that has to be insert and/or updated\n        :param bool with_expand: Trigger to expand tree\n        :return:\n        \"\"\"\n        # the case handling of this method\n        # 0 - create - common state\n        # 0.1 - modify attributes of common state which is already in the list\n        # 1 - create - library with show content -> add library root state\n        # 2 - create - library without show content -> add library state\n        # 3 - in as library with show content -> switch library without show content, remove children + LibRootState\n        # 3.1 - in as library with show content -> nothing to do\n        # 4 - in as library without show content -> switch library with show content, add children + remove LibState\n        # 4.1 - in as library without show content -> nothing to do\n\n        # if state model is LibraryStateModel with enabled show content state_model becomes the library root state model\n        if isinstance(state_model, LibraryStateModel) and self.show_content(state_model) and state_model.state_copy_initialized:\n            _state_model = state_model\n            state_model = state_model.state_copy\n        else:\n            _state_model = state_model\n\n        if self._state_which_is_updated is None:\n            self._state_which_is_updated = _state_model\n\n        # TODO remove this workaround for removing LibraryStateModel or there root states by default\n        if isinstance(_state_model, LibraryStateModel) and _state_model.state_copy_initialized:\n            state_row_iter = None\n            if _state_model.state.get_path() in self.state_row_iter_dict_by_state_path:\n                state_row_iter = self.state_row_iter_dict_by_state_path[_state_model.state.get_path()]\n            if state_model.state.get_path() in self.state_row_iter_dict_by_state_path:\n                state_row_iter = self.state_row_iter_dict_by_state_path[state_model.state.get_path()]\n\n            if state_row_iter:\n                self.remove_tree_children(state_row_iter)\n                del self.state_row_iter_dict_by_state_path[self.tree_store.get_value(state_row_iter, self.STATE_PATH_STORAGE_ID)]\n                self.tree_store.remove(state_row_iter)\n\n        # if library root state is used instate of library state show both in type and state id\n        _state_id = _state_model.state.state_id\n        # _state_id += '' if _state_model is state_model else '/' + state_model.state.state_id  TODO enable this line\n        _state_type = type(_state_model.state).__name__\n        _state_type += '' if _state_model is state_model else '/' + type(state_model.state).__name__\n\n        # check if in\n        state_path = state_model.state.get_path()\n        if state_path not in self.state_row_iter_dict_by_state_path:\n            # if not in -> insert it\n            state_row_iter = self.tree_store.insert_before(parent=parent_iter, sibling=None,\n                                                           row=(state_model.state.name,\n                                                                _state_id,\n                                                                _state_type,\n                                                                _state_model,\n                                                                state_model.state.get_path()))\n            self.state_row_iter_dict_by_state_path[state_path] = state_row_iter\n            if with_expand:\n                parent_path = self.tree_store.get_path(state_row_iter)\n                self.view.expand_to_path(parent_path)\n        else:\n            # if in -> check if up to date\n            state_row_iter = self.state_row_iter_dict_by_state_path[state_model.state.get_path()]\n            self.update_tree_store_row(state_model)\n\n        # check children\n        # - check if ALL children are in\n        if isinstance(state_model, ContainerStateModel):\n            for child_state_id, child_state_model in state_model.states.items():\n                self.insert_and_update_recursively(state_row_iter, child_state_model, with_expand=False)\n\n        # - check if TOO MUCH children are in\n        # if state_model.state.get_library_root_state() is not None or isinstance(state_model, LibraryStateModel):\n        for n in reversed(range(self.tree_store.iter_n_children(state_row_iter))):\n            child_iter = self.tree_store.iter_nth_child(state_row_iter, n)\n            child_state_path = self.tree_store.get_value(child_iter, self.STATE_PATH_STORAGE_ID)\n            child_model = None\n            if self._selected_sm_model.state_machine.get_state_by_path(child_state_path, as_check=True):\n                child_model = self._selected_sm_model.get_state_model_by_path(child_state_path)\n            child_id = self.tree_store.get_value(child_iter, self.ID_STORAGE_ID)\n\n            # check if there are left over rows of old states (switch from HS or CS to S and so on)\n            show_content_flag = isinstance(child_model, LibraryStateModel) and self.show_content(child_model) and \\\n                                child_model.state_copy_initialized\n            child_is_lib_with_show_content = isinstance(child_model, LibraryStateModel) and show_content_flag\n            child_is_lib_without_show_content = isinstance(child_model, LibraryStateModel) and not show_content_flag\n\n            if not isinstance(state_model, ContainerStateModel) or child_model is None or \\\n                    child_id not in state_model.states and not child_is_lib_with_show_content \\\n                    and isinstance(child_model, LibraryStateModel) and child_id == child_model.state.state_copy.state_id \\\n                    or child_is_lib_without_show_content and child_id == child_model.state.state_copy.state_id or \\\n                    isinstance(_state_model, LibraryStateModel) and not self.show_content(_state_model) or \\\n                    child_model.state.is_root_state_of_library and not self.show_content(child_model.parent):\n\n                self.remove_tree_children(child_iter)\n                del self.state_row_iter_dict_by_state_path[self.tree_store.get_value(child_iter, self.STATE_PATH_STORAGE_ID)]\n                self.tree_store.remove(child_iter)\n\n        if self._state_which_is_updated is _state_model:\n            self._state_which_is_updated = None"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_state_machine_selection(self):\n        if self._selected_sm_model:\n            return self._selected_sm_model.selection, self._selected_sm_model.selection.states\n        else:\n            return None, set()", "response": "Getter state machine selection"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndouble click event handler", "response": "def _handle_double_click(self, event):\n        \"\"\" Double click with left mouse button focuses the state and toggles the collapse status\"\"\"\n        if event.get_button()[1] == 1:  # Left mouse button\n            path_info = self.tree_view.get_path_at_pos(int(event.x), int(event.y))\n            if path_info:  # Valid entry was clicked on\n                path = path_info[0]\n                iter = self.tree_store.get_iter(path)\n                state_model = self.tree_store.get_value(iter, self.MODEL_STORAGE_ID)\n\n                # Set focus to StateModel\n                selection = self._selected_sm_model.selection\n                selection.focus = state_model\n\n                # Toggle collapse status if applicable for this kind of state\n                if self.view.row_expanded(path):\n                    self.view.collapse_row(path)\n                else:\n                    if isinstance(state_model, ContainerStateModel) or \\\n                                    isinstance(state_model, LibraryStateModel) and self.show_content(state_model):\n                        self.view.expand_to_path(path)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nexecuting the user execute function specified in the script", "response": "def execute(self, state, inputs=None, outputs=None, backward_execution=False):\n        \"\"\"Execute the user 'execute' function specified in the script\n\n        :param ExecutionState state: the state belonging to the execute function, refers to 'self'\n        :param dict inputs: the input data of the script\n        :param dict outputs: the output data of the script\n        :param bool backward_execution: Flag whether to run the script in backwards mode\n        :return: Return value of the execute script\n        :rtype: str | int\n        \"\"\"\n        if not outputs:\n            outputs = {}\n        if not inputs:\n            inputs = {}\n        if backward_execution:\n            if hasattr(self._compiled_module, \"backward_execute\"):\n                return self._compiled_module.backward_execute(\n                    state, inputs, outputs, rafcon.core.singleton.global_variable_manager\n                )\n            else:\n                logger.debug(\"No backward execution method found for state %s\" % state.name)\n                return None\n        else:\n            return self._compiled_module.execute(state, inputs, outputs,\n                                                 rafcon.core.singleton.global_variable_manager)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nloading the script from the filesystem", "response": "def _load_script(self):\n        \"\"\"Loads the script from the filesystem\n\n        :raises exceptions.IOError: if the script file could not be opened\n        \"\"\"\n        script_text = filesystem.read_file(self.path, self.filename)\n\n        if not script_text:\n            raise IOError(\"Script file could not be opened or was empty: {0}\"\n                          \"\".format(os.path.join(self.path, self.filename)))\n        self.script = script_text"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nbuilding a temporary module from the script file and returns the module object.", "response": "def build_module(self):\n        \"\"\"Builds a temporary module from the script file\n\n        :raises exceptions.IOError: if the compilation of the script module failed\n        \"\"\"\n        try:\n            imp.acquire_lock()\n            module_name = os.path.splitext(self.filename)[0] + str(self._script_id)\n\n            # load module\n            tmp_module = imp.new_module(module_name)\n\n            code = compile(self.script, '%s (%s)' % (self.filename, self._script_id), 'exec')\n\n            try:\n                exec(code, tmp_module.__dict__)\n            except RuntimeError as e:\n                raise IOError(\"The compilation of the script module failed - error message: %s\" % str(e))\n\n            # return the module\n            self.compiled_module = tmp_module\n        finally:\n            imp.release_lock()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncall when the View was registered", "response": "def register_view(self, view):\n        \"\"\"Called when the View was registered\"\"\"\n        super(MenuBarController, self).register_view(view)\n        data_flow_mode = global_runtime_config.get_config_value(\"DATA_FLOW_MODE\", False)\n        view[\"data_flow_mode\"].set_active(data_flow_mode)\n\n        show_data_flows = global_runtime_config.get_config_value(\"SHOW_DATA_FLOWS\", True)\n        view[\"show_data_flows\"].set_active(show_data_flows)\n\n        show_data_values = global_runtime_config.get_config_value(\"SHOW_DATA_FLOW_VALUE_LABELS\", True)\n        view[\"show_data_values\"].set_active(show_data_values)\n\n        show_aborted_preempted = global_runtime_config.get_config_value(\"SHOW_ABORTED_PREEMPTED\", False)\n        view[\"show_aborted_preempted\"].set_active(show_aborted_preempted)\n\n        view[\"expert_view\"].hide()\n        view[\"grid\"].hide()\n\n        # use dedicated function to connect the buttons to be able to access the handler id later on\n        self.connect_button_to_function('new', 'activate', self.on_new_activate)\n        self.connect_button_to_function('open', 'activate', self.on_open_activate)\n        self.connect_button_to_function('save', 'activate', self.on_save_activate)\n        self.connect_button_to_function('save_as', 'activate', self.on_save_as_activate)\n        self.connect_button_to_function('save_as_copy', 'activate', self.on_save_as_copy_activate)\n        self.connect_button_to_function('menu_preferences', 'activate', self.on_menu_preferences_activate)\n        self.connect_button_to_function('refresh_all', 'activate', self.on_refresh_all_activate)\n        self.connect_button_to_function('refresh_libraries', 'activate', self.on_refresh_libraries_activate)\n        self.connect_button_to_function('bake_state_machine', 'activate', self.on_bake_state_machine_activate)\n        self.connect_button_to_function('quit', 'activate', self.on_quit_activate)\n\n        self.connect_button_to_function('cut', 'activate', self.on_cut_selection_activate)\n        self.connect_button_to_function('copy', 'activate', self.on_copy_selection_activate)\n        self.connect_button_to_function('paste', 'activate', self.on_paste_clipboard_activate)\n        self.connect_button_to_function('delete', 'activate', self.on_delete_activate)\n        self.connect_button_to_function('is_start_state', 'activate', self.on_toggle_is_start_state_active)\n        self.connect_button_to_function('add', 'activate', self.on_add_state_activate)\n        self.connect_button_to_function('group', 'activate', self.on_group_states_activate)\n        self.connect_button_to_function('ungroup', 'activate', self.on_ungroup_state_activate)\n        self.connect_button_to_function('substitute_state', 'activate', self.on_substitute_selected_state_activate)\n        self.connect_button_to_function('save_state_as', 'activate', self.on_save_selected_state_as_activate)\n        self.connect_button_to_function('undo', 'activate', self.on_undo_activate)\n        self.connect_button_to_function('redo', 'activate', self.on_redo_activate)\n        self.connect_button_to_function('grid', 'activate', self.on_grid_toggled)\n\n        self.connect_button_to_function('data_flow_mode', 'toggled', self.on_data_flow_mode_toggled)\n        self.connect_button_to_function('show_data_flows', 'toggled', self.on_show_data_flows_toggled)\n        self.connect_button_to_function('show_data_values', 'toggled', self.on_show_data_values_toggled)\n        self.connect_button_to_function('show_aborted_preempted', 'toggled', self.on_show_aborted_preempted_toggled)\n        self.connect_button_to_function('expert_view', 'activate', self.on_expert_view_activate)\n        self.connect_button_to_function('full_screen', 'toggled', self.on_full_screen_mode_toggled)\n\n        self.connect_button_to_function('start', 'activate', self.on_start_activate)\n        self.connect_button_to_function('start_from_selected', 'activate', self.on_start_from_selected_state_activate)\n        self.connect_button_to_function('run_to_selected', 'activate', self.on_run_to_selected_state_activate)\n        self.connect_button_to_function('pause', 'activate', self.on_pause_activate)\n        self.connect_button_to_function('stop', 'activate', self.on_stop_activate)\n        self.connect_button_to_function('step_mode', 'activate', self.on_step_mode_activate)\n        self.connect_button_to_function('step_into', 'activate', self.on_step_into_activate)\n        self.connect_button_to_function('step_over', 'activate', self.on_step_over_activate)\n        self.connect_button_to_function('step_out', 'activate', self.on_step_out_activate)\n        self.connect_button_to_function('backward_step', 'activate', self.on_backward_step_activate)\n        self.connect_button_to_function('about', 'activate', self.on_about_activate)\n        self.full_screen_window.connect('key_press_event', self.on_escape_key_press_event_leave_full_screen)\n        self.view['menu_edit'].connect('select', self.check_edit_menu_items_status)\n        self.registered_view = True\n        self._update_recently_opened_state_machines()\n        # do not move next line - here to show warning in GUI debug console\n        self.create_logger_warning_if_shortcuts_are_overwritten_by_menu_bar()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef on_config_value_changed(self, config_m, prop_name, info):\n        config_key = info['args'][1]\n        # config_value = info['args'][2]\n\n        if config_key == \"LIBRARY_PATHS\":\n            library_manager.refresh_libraries()\n        elif config_key == \"SHORTCUTS\":\n            self.refresh_shortcuts()\n        elif config_key == \"recently_opened_state_machines\":\n            self._update_recently_opened_state_machines()", "response": "Callback when a config value has been changed"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _update_recently_opened_state_machines(self):\n        if not self.registered_view:\n            return\n\n        for item in self.view.sub_menu_open_recently.get_children():\n            self.view.sub_menu_open_recently.remove(item)\n\n        menu_item = gui_helper_label.create_menu_item(\"remove invalid paths\", constants.ICON_ERASE,\n                                                      global_runtime_config.clean_recently_opened_state_machines)\n        self.view.sub_menu_open_recently.append(menu_item)\n        self.view.sub_menu_open_recently.append(Gtk.SeparatorMenuItem())\n\n        for sm_path in global_runtime_config.get_config_value(\"recently_opened_state_machines\", []):\n            # define label string\n            root_state_name = gui_helper_state_machine.get_root_state_name_of_sm_file_system_path(sm_path)\n            if root_state_name is None and not os.path.isdir(sm_path):\n                root_state_name = 'NOT_ACCESSIBLE'\n            label_string = \"'{0}' in {1}\".format(root_state_name, sm_path) if root_state_name is not None else sm_path\n\n            # define icon of menu item\n            is_in_libs = library_manager.is_os_path_within_library_root_paths(sm_path)\n            button_image = constants.SIGN_LIB if is_in_libs else constants.BUTTON_OPEN\n\n            # prepare state machine open call_back function\n            sm_open_function = partial(self.on_open_activate, path=sm_path)\n\n            # create and insert new menu item\n            menu_item = gui_helper_label.create_menu_item(label_string, button_image, sm_open_function)\n            self.view.sub_menu_open_recently.append(menu_item)\n\n        self.view.sub_menu_open_recently.show_all()", "response": "Method update the recent opened state machines list."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef on_full_screen_activate(self, *args):\n        self.sm_notebook.set_show_tabs(False)\n        self.main_window_view['graphical_editor_vbox'].remove(self.sm_notebook)\n        self.full_screen_window.add(self.sm_notebook)\n        position = self.main_window_view.get_top_widget().get_position()\n        self.full_screen_window.show()\n        self.full_screen_window.move(position[0], position[1])\n        self.full_screen_window.set_decorated(False)\n        self.full_screen_window.fullscreen()\n        self.main_window_view.get_top_widget().iconify()", "response": "Function to display the currently selected state machine in full screen mode"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef unregister_view(self):\n        for handler_id in self.handler_ids.keys():\n            self.view[handler_id].disconnect(self.handler_ids[handler_id])", "response": "Unregister all registered functions to a view element\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nregisters callback methods for triggered actions in the given shortcuts.", "response": "def register_actions(self, shortcut_manager):\n        \"\"\"Register callback methods for triggered actions\n\n        :param rafcon.gui.shortcut_manager.ShortcutManager shortcut_manager: Shortcut Manager Object holding mappings\n            between shortcuts and actions.\n        \"\"\"\n        self.add_callback_to_shortcut_manager('save', partial(self.call_action_callback, \"on_save_activate\"))\n        self.add_callback_to_shortcut_manager('save_as', partial(self.call_action_callback, \"on_save_as_activate\"))\n        self.add_callback_to_shortcut_manager('save_as_copy', partial(self.call_action_callback,\n                                                                      \"on_save_as_copy_activate\"))\n        self.add_callback_to_shortcut_manager('save_state_as', partial(self.call_action_callback,\n                                                                       \"on_save_selected_state_as_activate\"))\n        self.add_callback_to_shortcut_manager('substitute_state', partial(self.call_action_callback,\n                                                                          \"on_substitute_selected_state_activate\"))\n        self.add_callback_to_shortcut_manager('substitute_library_with_template',\n                                              partial(self.call_action_callback,\n                                                      \"on_substitute_library_with_template_activate\"))\n        self.add_callback_to_shortcut_manager('open', partial(self.call_action_callback, \"on_open_activate\"))\n        self.add_callback_to_shortcut_manager('open_library_state_separately',\n                                              self.on_open_library_state_separately_activate)\n        self.add_callback_to_shortcut_manager('new', partial(self.call_action_callback, \"on_new_activate\"))\n        self.add_callback_to_shortcut_manager('quit', partial(self.call_action_callback, \"on_quit_activate\"))\n\n        self.add_callback_to_shortcut_manager('is_start_state', partial(self.call_action_callback,\n                                                                        \"on_toggle_is_start_state_active\"))\n        callback_function = partial(self.call_action_callback, \"on_add_transitions_from_closest_sibling_state_active\")\n        self.add_callback_to_shortcut_manager('transition_from_closest_sibling_state', callback_function)\n        callback_function = partial(self.call_action_callback, \"on_add_transitions_to_closest_sibling_state_active\")\n        self.add_callback_to_shortcut_manager('transition_to_closest_sibling_state', callback_function)\n        callback_function = partial(self.call_action_callback, \"on_add_transitions_to_parent_state_active\")\n        self.add_callback_to_shortcut_manager('transition_to_parent_state', callback_function)\n        self.add_callback_to_shortcut_manager('group', partial(self.call_action_callback, \"on_group_states_activate\"))\n        self.add_callback_to_shortcut_manager('ungroup', partial(self.call_action_callback,\n                                                                 \"on_ungroup_state_activate\"))\n\n        self.add_callback_to_shortcut_manager('start', partial(self.call_action_callback, \"on_start_activate\"))\n        self.add_callback_to_shortcut_manager('start_from_selected', partial(self.call_action_callback,\n                                                                             \"on_start_from_selected_state_activate\"))\n        self.add_callback_to_shortcut_manager('run_to_selected', partial(self.call_action_callback,\n                                                                         \"on_run_to_selected_state_activate\"))\n\n        self.add_callback_to_shortcut_manager('stop', partial(self.call_action_callback, \"on_stop_activate\"))\n        self.add_callback_to_shortcut_manager('pause', partial(self.call_action_callback, \"on_pause_activate\"))\n        self.add_callback_to_shortcut_manager('step_mode', partial(self.call_action_callback, \"on_step_mode_activate\"))\n        self.add_callback_to_shortcut_manager('step', partial(self.call_action_callback, \"on_step_into_activate\"))\n        self.add_callback_to_shortcut_manager('backward_step', partial(self.call_action_callback,\n                                                                       \"on_backward_step_activate\"))\n\n        self.add_callback_to_shortcut_manager('reload', partial(self.call_action_callback, \"on_refresh_all_activate\"))\n\n        self.add_callback_to_shortcut_manager('show_data_flows', self.show_data_flows_toggled_shortcut)\n        self.add_callback_to_shortcut_manager('show_data_values', self.show_data_values_toggled_shortcut)\n        self.add_callback_to_shortcut_manager('data_flow_mode', self.data_flow_mode_toggled_shortcut)\n        self.add_callback_to_shortcut_manager('show_aborted_preempted', self.show_aborted_preempted)\n\n        self.add_callback_to_shortcut_manager('fullscreen', self.on_toggle_full_screen_mode)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef add_callback_to_shortcut_manager(self, action, callback):\n        if action not in self.registered_shortcut_callbacks:\n            self.registered_shortcut_callbacks[action] = []\n        self.registered_shortcut_callbacks[action].append(callback)\n        self.shortcut_manager.add_callback_for_action(action, callback)", "response": "Helper function to add a callback to the shortcut manager."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nremoves all callbacks registered to the shortcut manager.", "response": "def remove_all_callbacks(self):\n        \"\"\"\n        Remove all callbacks registered to the shortcut manager\n        :return:\n        \"\"\"\n        for action in self.registered_shortcut_callbacks.keys():\n            for callback in self.registered_shortcut_callbacks[action]:\n                self.shortcut_manager.remove_callback_for_action(action, callback)\n        # delete all registered shortcut callbacks\n        self.registered_shortcut_callbacks = {}"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef point_left_of_line(point, line_start, line_end):\n    # determine sign of determinant\n    # ((b.x - a.x)*(c.y - a.y) - (b.y - a.y)*(c.x - a.x)) > 0\n    return ((line_end[0] - line_start[0]) * (point[1] - line_start[1]) -\n            (line_end[1] - line_start[1]) * (point[0] - line_start[0])) < 0", "response": "Determines if a point is left of a line in a line in a Knockout system."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nchecks whether a point lies on a line in a", "response": "def point_on_line(point, line_start, line_end, accuracy=50.):\n    \"\"\"Checks whether a point lies on a line\n\n    The function checks whether the point \"point\" (P) lies on the line defined by its starting point line_start (A) and\n    its end point line_end (B).\n    This is done by comparing the distance of [AB] with the sum of the distances [AP] and [PB]. If the difference is\n    smaller than [AB] / accuracy, the point P is assumed to be on the line. By increasing the value of accuracy (the\n    default is 50), the tolerance is decreased.\n    :param point: Point to be checked (tuple with x any y coordinate)\n    :param line_start: Starting point of the line (tuple with x any y coordinate)\n    :param line_end: End point of the line (tuple with x any y coordinate)\n    :param accuracy: The higher this value, the less distance is tolerated\n    :return: True if the point is one the line, False if not\n    \"\"\"\n    length = dist(line_start, line_end)\n    ds = length / float(accuracy)\n    if -ds < (dist(line_start, point) + dist(point, line_end) - length) < ds:\n        return True\n\n    return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nchecks whether a point p is within the given triangle", "response": "def point_in_triangle(p, v1, v2, v3):\n    \"\"\"Checks whether a point is within the given triangle\n\n    The function checks, whether the given point p is within the triangle defined by the the three corner point v1,\n    v2 and v3.\n    This is done by checking whether the point is on all three half-planes defined by the three edges of the triangle.\n    :param p: The point to be checked (tuple with x any y coordinate)\n    :param v1: First vertex of the triangle (tuple with x any y coordinate)\n    :param v2: Second vertex of the triangle (tuple with x any y coordinate)\n    :param v3: Third vertex of the triangle (tuple with x any y coordinate)\n    :return: True if the point is within the triangle, False if not\n    \"\"\"\n    def _test(p1, p2, p3):\n        return (p1[0] - p3[0]) * (p2[1] - p3[1]) - (p2[0] - p3[0]) * (p1[1] - p3[1])\n\n    b1 = _test(p, v1, v2) < 0.0\n    b2 = _test(p, v2, v3) < 0.0\n    b3 = _test(p, v3, v1) < 0.0\n\n    return (b1 == b2) and (b2 == b3)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef equal(t1, t2, digit=None):\n\n    if not len(t1) == len(t2):\n        return False\n\n\n    for idx in range(len(t1)):\n        if digit is not None:\n            if not round(t1[idx], digit) == round(t2[idx], digit):\n                return False\n        else:\n            if not t1[idx] == t2[idx]:\n                return False\n\n    return True", "response": "Compare two iterators and their elements on specific digit precision\n\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef cal_dist_between_2_coord_frame_aligned_boxes(box1_pos, box1_size, box2_pos, box2_size):\n    box1_x_min, box1_y_min = box1_pos\n    box1_x_max, box1_y_max = (box1_pos[0] + box1_size[0], box1_pos[1] + box1_size[1])\n    box2_x_min, box2_y_min = box2_pos\n    box2_x_max, box2_y_max = (box2_pos[0] + box2_size[0], box2_pos[1] + box2_size[1])\n\n    # 1|2|3                              +-> x    => works also for opengl - both boxes described in same coordinates\n    # 4|5|6  -> 5 is covered by  box1    |\n    # 7|8|9                             \\/ y\n    # - case 1 the right lower corner of box2 is above and left to box1 upper left corner\n    # - case 5 is when the boxes are overlapping so the distance is 0\n    # - in case 1, 3, 7, 9 respective corners of box1 to box2 are the minimal distance\n    # - 2, 4, 6, 8 can be covered by either simply calculation via either x or y axis\n    if box2_x_max < box1_x_min and box2_y_max < box1_y_min:  # case 1 -> box2 is fully in sector 1\n        distance = sqrt((box1_x_min - box2_x_max)**2 + (box1_y_min - box2_y_max)**2)\n    elif box2_x_min > box1_x_max and box2_y_max < box1_y_min:  # case 3 -> box2 is fully in sector 3\n        distance = sqrt((box2_x_min - box1_x_max)**2 + (box1_y_min - box2_y_max)**2)\n    elif box2_x_max < box1_x_min and box2_y_min > box1_y_max:  # case 7 -> box2 is fully in sector 7\n        distance = sqrt((box1_x_min - box2_x_max)**2 + (box2_y_min - box1_y_max)**2)\n    elif box2_x_min > box1_x_max and box2_y_min > box1_y_max:  # case 9 -> box2 is fully in sector 9\n        distance = sqrt((box2_x_min - box1_x_max)**2 + (box2_y_min - box1_y_max)**2)\n    elif box2_y_max < box1_y_min:  # case 2 -> box2 is party in sector 2 and in 1 or 3\n        distance = box1_y_min - box2_y_max\n    elif box2_x_max < box1_x_min:  # case 4 -> box2 is party in sector 4 and in 1 or 7\n        distance = box1_x_min - box2_x_max\n    elif box2_x_min > box1_x_max:  # case 6 -> box2 is party in sector 6 and in 3 or 9\n        distance = box2_x_min - box1_x_max\n    elif box2_y_min > box1_y_max:  # case 8 -> box2 is party in sector 8 and in 7 or 9\n        distance = box2_y_min - box1_y_max\n    else:  # case 5 box2 reach into area of box1\n        distance = 0.\n\n    return distance", "response": "Calculates the Euclidean distance between two boxes that are parallel to the coordinate axis."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ntriggers when mouse click is pressed in the history tree.", "response": "def mouse_click(self, widget, event=None):\n        \"\"\"Triggered when mouse click is pressed in the history tree. The method shows all scoped data for an execution\n        step as tooltip or fold and unfold the tree by double-click and select respective state for double clicked\n        element.\n        \"\"\"\n        if event.type == Gdk.EventType._2BUTTON_PRESS and event.get_button()[1] == 1:\n\n            (model, row) = self.history_tree.get_selection().get_selected()\n            if row is not None:\n                histroy_item_path = self.history_tree_store.get_path(row)\n                histroy_item_iter = self.history_tree_store.get_iter(histroy_item_path)\n                # logger.info(history_item.state_reference)\n                # TODO generalize double-click folding and unfolding -> also used in states tree of state machine\n                if histroy_item_path is not None and self.history_tree_store.iter_n_children(histroy_item_iter):\n                    if self.history_tree.row_expanded(histroy_item_path):\n                        self.history_tree.collapse_row(histroy_item_path)\n                    else:\n                        self.history_tree.expand_to_path(histroy_item_path)\n                sm = self.get_history_item_for_tree_iter(histroy_item_iter).state_reference.get_state_machine()\n                if sm:\n                    if sm.state_machine_id != self.model.selected_state_machine_id:\n                        self.model.selected_state_machine_id = sm.state_machine_id\n                else:\n                    logger.info(\"No state machine could be found for selected item's state reference and \"\n                                \"therefore no selection is performed.\")\n                    return\n                active_sm_m = self.model.get_selected_state_machine_model()\n                assert active_sm_m.state_machine is sm\n                state_path = self.get_history_item_for_tree_iter(histroy_item_iter).state_reference.get_path()\n                ref_state_m = active_sm_m.get_state_model_by_path(state_path)\n                if ref_state_m and active_sm_m:\n                    active_sm_m.selection.set(ref_state_m)\n\n            return True\n\n        if event.type == Gdk.EventType.BUTTON_PRESS and event.get_button()[1] == 2:\n            x = int(event.x)\n            y = int(event.y)\n            pthinfo = self.history_tree.get_path_at_pos(x, y)\n            if pthinfo is not None:\n                path, col, cellx, celly = pthinfo\n                self.history_tree.grab_focus()\n                self.history_tree.set_cursor(path, col, 0)\n                self.open_selected_history_separately(None)\n\n        if event.type == Gdk.EventType.BUTTON_PRESS and event.get_button()[1] == 3:\n            x = int(event.x)\n            y = int(event.y)\n            time = event.time\n            pthinfo = self.history_tree.get_path_at_pos(x, y)\n            if pthinfo is not None:\n                path, col, cellx, celly = pthinfo\n                self.history_tree.grab_focus()\n                self.history_tree.set_cursor(path, col, 0)\n\n                popup_menu = Gtk.Menu()\n\n                model, row = self.history_tree.get_selection().get_selected()\n                history_item = model[row][self.HISTORY_ITEM_STORAGE_ID]\n                if not isinstance(history_item, ScopedDataItem) or history_item.scoped_data is None:\n                    return\n                scoped_data = history_item.scoped_data\n                input_output_data = history_item.child_state_input_output_data\n                state_reference = history_item.state_reference\n\n                self.append_string_to_menu(popup_menu, \"------------------------\")\n                self.append_string_to_menu(popup_menu, \"Scoped Data: \")\n                self.append_string_to_menu(popup_menu, \"------------------------\")\n                for key, data in scoped_data.items():\n                    menu_item_string = \"    %s (%s - %s):\\t%s\" % (\n                        data.name.replace(\"_\", \"__\"), key, data.value_type, data.value)\n                    self.append_string_to_menu(popup_menu, menu_item_string)\n\n                if input_output_data:\n                    if isinstance(history_item, CallItem):\n                        self.append_string_to_menu(popup_menu, \"------------------------\")\n                        self.append_string_to_menu(popup_menu, \"Input Data:\")\n                        self.append_string_to_menu(popup_menu, \"------------------------\")\n                    else:\n                        self.append_string_to_menu(popup_menu, \"------------------------\")\n                        self.append_string_to_menu(popup_menu, \"Output Data:\")\n                        self.append_string_to_menu(popup_menu, \"------------------------\")\n\n                    for key, data in input_output_data.items():\n                        menu_item_string = \"    %s :\\t%s\" % (key.replace(\"_\", \"__\"), data)\n                        self.append_string_to_menu(popup_menu, menu_item_string)\n\n                if state_reference:\n                    if history_item.outcome:\n                        self.append_string_to_menu(popup_menu, \"------------------------\")\n                        final_outcome_menu_item_string = \"Final outcome: \" + str(history_item.outcome)\n                        self.append_string_to_menu(popup_menu, final_outcome_menu_item_string)\n                        self.append_string_to_menu(popup_menu, \"------------------------\")\n\n                popup_menu.show()\n                popup_menu.popup(None, None, None, None, event.get_button()[1], time)\n\n            return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nhands history item for tree iter and compensate if tree item is a dummy item", "response": "def get_history_item_for_tree_iter(self, child_tree_iter):\n        \"\"\"Hands history item for tree iter and compensate if tree item is a dummy item\n\n        :param Gtk.TreeIter child_tree_iter: Tree iter of row\n        :rtype rafcon.core.execution.execution_history.HistoryItem:\n        :return history tree item:\n        \"\"\"\n        history_item = self.history_tree_store[child_tree_iter][self.HISTORY_ITEM_STORAGE_ID]\n        if history_item is None:  # is dummy item\n            if self.history_tree_store.iter_n_children(child_tree_iter) > 0:\n                child_iter = self.history_tree_store.iter_nth_child(child_tree_iter, 0)\n                history_item = self.history_tree_store[child_iter][self.HISTORY_ITEM_STORAGE_ID]\n            else:\n                logger.debug(\"In a dummy history should be respective real call element.\")\n        return history_item"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _store_expansion_state(self):\n\n        def store_tree_expansion(child_tree_iter, expansion_state):\n\n            tree_item_path = self.history_tree_store.get_path(child_tree_iter)\n            history_item = self.get_history_item_for_tree_iter(child_tree_iter)\n\n            # store expansion state if tree item path is valid and expansion state was not stored already\n            if tree_item_path is not None:\n                # if first element of sub-tree has same history_item as the parent ignore it's expansion state\n                if history_item not in expansion_state:\n                    expansion_state[history_item] = self.history_tree.row_expanded(tree_item_path)\n\n            for n in range(self.history_tree_store.iter_n_children(child_tree_iter)):\n                child_iter = self.history_tree_store.iter_nth_child(child_tree_iter, n)\n                store_tree_expansion(child_iter, expansion_state)\n\n        root_iter = self.history_tree_store.get_iter_first()\n        if not root_iter:\n            return\n        current_expansion_state = {}\n        # this can be the case when the execution history tree is currently being deleted\n        if not self.get_history_item_for_tree_iter(root_iter).state_reference:\n            return\n        state_machine = self.get_history_item_for_tree_iter(root_iter).state_reference.get_state_machine()\n        self._expansion_state[state_machine.state_machine_id] = current_expansion_state\n        while root_iter:\n            store_tree_expansion(root_iter, current_expansion_state)\n            root_iter = self.history_tree_store.iter_next(root_iter)", "response": "Iterate recursively all tree items and store expansion state"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _restore_expansion_state(self):\n\n        def restore_tree_expansion(child_tree_iter, expansion_state):\n            tree_item_path = self.history_tree_store.get_path(child_tree_iter)\n            history_item = self.get_history_item_for_tree_iter(child_tree_iter)\n\n            # restore expansion state if tree item path is valid and expansion state was not stored already\n            if tree_item_path and history_item in expansion_state:\n                if expansion_state[history_item]:\n                    self.history_tree.expand_to_path(tree_item_path)\n\n            for n in range(self.history_tree_store.iter_n_children(child_tree_iter)):\n                child_iter = self.history_tree_store.iter_nth_child(child_tree_iter, n)\n                restore_tree_expansion(child_iter, expansion_state)\n\n        root_iter = self.history_tree_store.get_iter_first()\n        if not root_iter:\n            return\n        state_machine = self.get_history_item_for_tree_iter(root_iter).state_reference.get_state_machine()\n        if state_machine.state_machine_id not in self._expansion_state:\n            return\n        while root_iter:\n            restore_tree_expansion(root_iter, self._expansion_state[state_machine.state_machine_id])\n            root_iter = self.history_tree_store.iter_next(root_iter)", "response": "Iterate recursively all tree items and restore expansion state"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef notification_selected_sm_changed(self, model, prop_name, info):\n        selected_state_machine_id = self.model.selected_state_machine_id\n        if selected_state_machine_id is None:\n            return\n        self.update()", "response": "If a new state machine is selected make sure expansion state is stored and tree updated"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef notification_sm_changed(self, model, prop_name, info):\n        for state_machine_id in list(self._expansion_state.keys()):\n            if state_machine_id not in self.model.state_machines:\n                del self._expansion_state[state_machine_id]", "response": "Remove references to non - existing state machines"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef execution_history_focus(self, model, prop_name, info):\n        if state_machine_execution_engine.status.execution_mode in \\\n                [StateMachineExecutionStatus.STARTED, StateMachineExecutionStatus.STOPPED,\n                 StateMachineExecutionStatus.FINISHED]:\n            if self.parent is not None and hasattr(self.parent, \"focus_notebook_page_of_controller\"):\n                # request focus -> which has not have to be satisfied\n                self.parent.focus_notebook_page_of_controller(self)\n\n        if state_machine_execution_engine.status.execution_mode is not StateMachineExecutionStatus.STARTED:\n            if not self.model.selected_state_machine_id == self.model.state_machine_manager.active_state_machine_id:\n                pass\n            else:\n                self.update()", "response": "Arranges to put execution - history widget page to become top page in notebook when execution starts and stops and resets modification_history_was_focused to False each time this notification are observed."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef clean_history(self, widget, event=None):\n        self.history_tree_store.clear()\n        selected_sm_m = self.model.get_selected_state_machine_model()\n        if selected_sm_m:\n            # the core may continue running without the GUI and for this it needs its execution histories\n            if state_machine_execution_engine.finished_or_stopped():\n                selected_sm_m.state_machine.destroy_execution_histories()\n                self.update()", "response": "Triggered when the Clean History button is clicked."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nrebuild the tree view of the history item tree store", "response": "def update(self):\n        \"\"\"\n        rebuild the tree view of the history item tree store\n        :return:\n        \"\"\"\n        # with self._update_lock:\n        self._update_lock.acquire()\n        self._store_expansion_state()\n        self.history_tree_store.clear()\n        selected_sm_m = self.model.get_selected_state_machine_model()\n        if not selected_sm_m:\n            return\n\n        for execution_number, execution_history in enumerate(selected_sm_m.state_machine.execution_histories):\n            if len(execution_history) > 0:\n                first_history_item = execution_history[0]\n                # the next lines filter out the StateMachineStartItem, which is not intended to\n                # be displayed, but merely as convenient entry point in the saved log file\n                if isinstance(first_history_item, StateMachineStartItem):\n                    if len(execution_history) > 1:\n                        first_history_item = execution_history[1]\n                        tree_item = self.history_tree_store.insert_after(\n                            None,\n                            None,\n                            (first_history_item.state_reference.name + \" - Run \" + str(execution_number + 1),\n                             first_history_item, self.TOOL_TIP_TEXT))\n                        self.insert_execution_history(tree_item, execution_history[1:], is_root=True)\n                    else:\n                        pass  # there was only the Start item in the history\n                else:\n                    tree_item = self.history_tree_store.insert_after(\n                        None,\n                        None,\n                        (first_history_item.state_reference.name + \" - Run \" + str(execution_number + 1),\n                         first_history_item, self.TOOL_TIP_TEXT))\n                    self.insert_execution_history(tree_item, execution_history, is_root=True)\n\n        self._restore_expansion_state()\n        self._update_lock.release()"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ninserts a single history item into the tree store.", "response": "def insert_history_item(self, parent, history_item, description, dummy=False):\n        \"\"\"Enters a single history item into the tree store\n\n        :param Gtk.TreeItem parent: Parent tree item\n        :param HistoryItem history_item: History item to be inserted\n        :param str description: A description to be added to the entry\n        :param None dummy: Whether this is just a dummy entry (wrapper for concurrency items)\n        :return: Inserted tree item\n        :rtype: Gtk.TreeItem\n        \"\"\"\n        if not history_item.state_reference:\n            logger.error(\"This must never happen! Current history_item is {}\".format(history_item))\n            return None\n        content = None\n\n        if global_gui_config.get_config_value(\"SHOW_PATH_NAMES_IN_EXECUTION_HISTORY\", False):\n            content = (history_item.state_reference.name + \" - \" +\n                           history_item.state_reference.get_path() + \" - \" +\n                           description, None if dummy else history_item,\n                           None if dummy else self.TOOL_TIP_TEXT)\n        else:\n            content = (history_item.state_reference.name + \" - \" +\n                           description, None if dummy else history_item,\n                           None if dummy else self.TOOL_TIP_TEXT)\n\n        tree_item = self.history_tree_store.insert_before(\n            parent, None, content)\n        return tree_item"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef insert_execution_history(self, parent, execution_history, is_root=False):\n        current_parent = parent\n        execution_history_iterator = iter(execution_history)\n        for history_item in execution_history_iterator:\n            if isinstance(history_item, ConcurrencyItem):\n                self.insert_concurrent_execution_histories(current_parent, history_item.execution_histories)\n\n            elif isinstance(history_item, CallItem):\n                tree_item = self.insert_history_item(current_parent, history_item, \"Enter\" if is_root else \"Call\")\n                if not tree_item:\n                    return\n                if history_item.call_type is CallType.EXECUTE:\n                    # this is necessary that already the CallType.EXECUTE item opens a new hierarchy in the\n                    # tree view and not the CallType.CONTAINER item\n                    next_history_item = history_item.next\n                    if next_history_item and next_history_item.call_type is CallType.CONTAINER:\n                        current_parent = tree_item\n                        self.insert_history_item(current_parent, next_history_item, \"Enter\")\n                        try:\n                            next(execution_history_iterator)  # skips the next history item in the iterator\n                        except StopIteration as e:\n                            # the execution engine does not have another item\n                            return\n\n            else:  # history_item is ReturnItem\n                if current_parent is None:\n                    # The reasons here can be: missing history items, items in the wrong order etc.\n                    # Does not happen when using RAFCON without plugins\n                    logger.error(\"Invalid execution history: current_parent is None\")\n                    return\n                if history_item.call_type is CallType.EXECUTE:\n                    self.insert_history_item(current_parent, history_item, \"Return\")\n                else:  # CONTAINER\n                    self.insert_history_item(current_parent, history_item, \"Exit\")\n                    current_parent = self.history_tree_store.iter_parent(current_parent)\n\n            is_root = False", "response": "This method inserts a list of execution history items into a tree store."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nadds the child execution histories of a concurrency state.", "response": "def insert_concurrent_execution_histories(self, parent, concurrent_execution_histories):\n        \"\"\"Adds the child execution histories of a concurrency state.\n\n        :param Gtk.TreeItem parent: the parent to add the next history item to\n        :param list[ExecutionHistory] concurrent_execution_histories: a list of all child execution histories\n        :return:\n        \"\"\"\n        for execution_history in concurrent_execution_histories:\n            if len(execution_history) >= 1:\n                first_history_item = execution_history[0]\n                # this is just a dummy item to have an extra parent for each branch\n                # gives better overview in case that one of the child state is a simple execution state\n                tree_item = self.insert_history_item(parent, first_history_item, \"Concurrency Branch\", dummy=True)\n                self.insert_execution_history(tree_item, execution_history)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef on_drag_data_get(self, widget, context, data, info, time):\n        library_state = self._get_selected_library_state()\n        import rafcon.gui.helpers.state_machine as gui_helper_state_machine\n        gui_helper_state_machine.add_state_by_drag_and_drop(library_state, data)", "response": "dragged state is inserted and its state_id sent to the receiver"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nselect respective state machine of selected library in state machine manager if already open", "response": "def select_open_state_machine_of_selected_library_element(self):\n        \"\"\"Select respective state machine of selected library in state machine manager if already open \"\"\"\n        (model, row_path) = self.view.get_selection().get_selected()\n        if row_path:\n            physical_library_path = model[row_path][self.ITEM_STORAGE_ID]\n            smm = gui_singletons.state_machine_manager_model.state_machine_manager\n            sm = smm.get_open_state_machine_of_file_system_path(physical_library_path)\n            if sm:\n                gui_singletons.state_machine_manager_model.selected_state_machine_id = sm.state_machine_id"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nremoving libraries from hard drive after second confirmation", "response": "def menu_item_remove_libraries_or_root_clicked(self, menu_item):\n        \"\"\"Removes library from hard drive after request second confirmation\"\"\"\n\n        menu_item_text = self.get_menu_item_text(menu_item)\n\n        logger.info(\"Delete item '{0}' pressed.\".format(menu_item_text))\n        model, path = self.view.get_selection().get_selected()\n        if path:\n            # Second confirmation to delete library\n            tree_m_row = self.tree_store[path]\n            library_os_path, library_path, library_name, item_key = self.extract_library_properties_from_selected_row()\n            # assert isinstance(tree_m_row[self.ITEM_STORAGE_ID], str)\n            library_file_system_path = library_os_path\n\n            if \"root\" in menu_item_text:\n                button_texts = [menu_item_text + \"from tree and config\", \"Cancel\"]\n                partial_message = \"This will remove the library root from your configuration (config.yaml).\"\n            else:\n                button_texts = [menu_item_text, \"Cancel\"]\n                partial_message = \"This folder will be removed from hard drive! You really wanna do that?\"\n\n            message_string = \"You choose to {2} with \" \\\n                             \"\\n\\nlibrary tree path:   {0}\" \\\n                             \"\\n\\nphysical path:        {1}.\\n\\n\\n\"\\\n                             \"{3}\" \\\n                             \"\".format(os.path.join(self.convert_if_human_readable(tree_m_row[self.LIB_PATH_STORAGE_ID]),\n                                                    item_key),\n                                       library_file_system_path,\n                                       menu_item_text.lower(),\n                                       partial_message)\n\n            width = 8*len(\"physical path:        \" + library_file_system_path)\n            dialog = RAFCONButtonDialog(message_string, button_texts, message_type=Gtk.MessageType.QUESTION,\n                                        parent=self.get_root_window(), width=min(width, 1400))\n            response_id = dialog.run()\n            dialog.destroy()\n            if response_id == 1:\n                if \"root\" in menu_item_text:\n                    logger.info(\"Remove library root key '{0}' from config.\".format(item_key))\n                    from rafcon.gui.singleton import global_config\n                    library_paths = global_config.get_config_value('LIBRARY_PATHS')\n                    del library_paths[tree_m_row[self.LIB_KEY_STORAGE_ID]]\n                    global_config.save_configuration()\n                    self.model.library_manager.refresh_libraries()\n                elif \"libraries\" in menu_item_text:\n                    logger.debug(\"Remove of all libraries in {} is triggered.\".format(library_os_path))\n                    import shutil\n                    shutil.rmtree(library_os_path)\n                    self.model.library_manager.refresh_libraries()\n                else:\n\n                    logger.debug(\"Remove of Library {} is triggered.\".format(library_os_path))\n                    self.model.library_manager.remove_library_from_file_system(library_path,\n                                                                               library_name)\n            elif response_id in [2, -4]:\n                pass\n            else:\n                logger.warning(\"Response id: {} is not considered\".format(response_id))\n\n            return True\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nextract properties library_os_path library_path library_name and tree_item_key from selected row", "response": "def extract_library_properties_from_selected_row(self):\n        \"\"\" Extracts properties library_os_path, library_path, library_name and tree_item_key from tree store row \"\"\"\n        (model, row) = self.view.get_selection().get_selected()\n        tree_item_key = model[row][self.ID_STORAGE_ID]\n        library_item = model[row][self.ITEM_STORAGE_ID]\n        library_path = model[row][self.LIB_PATH_STORAGE_ID]\n        if isinstance(library_item, dict):  # sub-tree\n            os_path = model[row][self.OS_PATH_STORAGE_ID]\n            return os_path, None, None, tree_item_key  # relevant elements of sub-tree\n        assert isinstance(library_item, string_types)\n        library_os_path = library_item\n\n        library_name = library_os_path.split(os.path.sep)[-1]\n\n        return library_os_path, library_path, library_name, tree_item_key"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _get_selected_library_state(self):\n        library_os_path, library_path, library_name, item_key = self.extract_library_properties_from_selected_row()\n        if library_path is None:\n            return None\n\n        logger.debug(\"Link library state '{0}' (with library tree path: {2} and file system path: {1}) into state \"\n                     \"machine.\".format(str(item_key), library_os_path,\n                                       self.convert_if_human_readable(str(library_path)) + \"/\" + str(item_key)))\n        library_name = library_os_path.split(os.path.sep)[-1]\n        return LibraryState(library_path, library_name, \"0.1\", format_folder_name_human_readable(library_name))", "response": "Returns the LibraryState which was selected in the LibraryTree\n       "}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef start(self, execution_history, backward_execution=False, generate_run_id=True):\n        self.execution_history = execution_history\n        if generate_run_id:\n            self._run_id = run_id_generator()\n        self.backward_execution = copy.copy(backward_execution)\n        self.thread = threading.Thread(target=self.run)\n        self.thread.start()", "response": "Starts the execution of the state in a new thread."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef join(self):\n        if self.thread:\n            self.thread.join()\n            self.thread = None\n        else:\n            logger.debug(\"Cannot join {0}, as the state hasn't been started, yet or is already finished!\".format(self))", "response": "Waits until the state finished execution."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef setup_run(self):\n        self.state_execution_status = StateExecutionStatus.ACTIVE\n        self.preempted = False\n        if not isinstance(self.input_data, dict):\n            raise TypeError(\"input_data must be of type dict\")\n        if not isinstance(self.output_data, dict):\n            raise TypeError(\"output_data must be of type dict\")\n        self.check_input_data_type()", "response": "Sets up the state execution status and preempted state"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\npreempts the state of the current object.", "response": "def recursively_preempt_states(self):\n        \"\"\"Preempt the state\n        \"\"\"\n        self.preempted = True\n        self.paused = False\n        self.started = False"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_default_input_values_for_state(self, state):\n        from rafcon.core.states.library_state import LibraryState\n        result_dict = {}\n        for input_port_key, value in state.input_data_ports.items():\n            if isinstance(state, LibraryState):\n                if state.use_runtime_value_input_data_ports[input_port_key]:\n                    default = state.input_data_port_runtime_values[input_port_key]\n                else:\n                    default = value.default_value\n            else:\n                default = value.default_value\n            # if the user sets the default value to a string starting with $, try to retrieve the value\n            # from the global variable manager\n            if isinstance(default, string_types) and len(default) > 0 and default[0] == '$':\n                from rafcon.core.singleton import global_variable_manager as gvm\n                var_name = default[1:]\n                if not gvm.variable_exist(var_name):\n                    logger.error(\"The global variable '{0}' does not exist\".format(var_name))\n                    global_value = None\n                else:\n                    global_value = gvm.get_variable(var_name)\n                result_dict[value.name] = global_value\n            else:\n                # set input to its default value\n                result_dict[value.name] = copy.copy(default)\n        return result_dict", "response": "Returns the default input values for a state"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating a dictionary of output data for a state", "response": "def create_output_dictionary_for_state(state):\n        \"\"\"Return empty output dictionary for a state\n\n        :param state: the state of which the output data is determined\n        :return: the output data of the target state\n        \"\"\"\n        from rafcon.core.states.library_state import LibraryState\n        result_dict = {}\n        for key, data_port in state.output_data_ports.items():\n            if isinstance(state, LibraryState) and state.use_runtime_value_output_data_ports[key]:\n                result_dict[data_port.name] = copy.copy(state.output_data_port_runtime_values[key])\n            else:\n                result_dict[data_port.name] = copy.copy(data_port.default_value)\n        return result_dict"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nadding a new input data port to the state.", "response": "def add_input_data_port(self, name, data_type=None, default_value=None, data_port_id=None):\n        \"\"\"Add a new input data port to the state.\n\n        :param str name: the name of the new input data port\n        :param data_type: the type of the new output data port considered of class :class:`type` or\n                          :class:`str` which has to be convertible to :class:`type`\n        :param default_value: the default value of the data port\n        :param int data_port_id: the data_port_id of the new data port\n        :return: data_port_id of new input data port\n        :rtype: int\n        :raises exceptions.ValueError: if name of the input port is not unique\n        \"\"\"\n        if data_port_id is None:\n            # All data port ids have to passed to the id generation as the data port id has to be unique inside a state\n            data_port_id = generate_data_port_id(self.get_data_port_ids())\n        self._input_data_ports[data_port_id] = InputDataPort(name, data_type, default_value, data_port_id, self)\n\n        # Check for name uniqueness\n        valid, message = self._check_data_port_name(self._input_data_ports[data_port_id])\n        if not valid:\n            self._input_data_ports[data_port_id].parent = None\n            del self._input_data_ports[data_port_id]\n            raise ValueError(message)\n\n        return data_port_id"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nremove an input data port from the state.", "response": "def remove_input_data_port(self, data_port_id, force=False, destroy=True):\n        \"\"\"Remove an input data port from the state\n\n        :param int data_port_id: the id or the output data port to remove\n        :param bool force: if the removal should be forced without checking constraints\n        :raises exceptions.AttributeError: if the specified input data port does not exist\n        \"\"\"\n        if data_port_id in self._input_data_ports:\n            if destroy:\n                self.remove_data_flows_with_data_port_id(data_port_id)\n            self._input_data_ports[data_port_id].parent = None\n            return self._input_data_ports.pop(data_port_id)\n        else:\n            raise AttributeError(\"input data port with name %s does not exit\", data_port_id)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nremove all data flows whose from_key or to_key equals the passed data_port_id.", "response": "def remove_data_flows_with_data_port_id(self, data_port_id):\n        \"\"\"Remove all data flows whose from_key or to_key equals the passed data_port_id\n\n        :param data_port_id: the id of a data_port of which all data_flows should be removed, the id can be a input or\n                            output data port id\n\n        \"\"\"\n        if not self.is_root_state:\n            # delete all data flows in parent related to data_port_id and self.state_id\n            data_flow_ids_to_remove = []\n            for data_flow_id, data_flow in self.parent.data_flows.items():\n                if data_flow.from_state == self.state_id and data_flow.from_key == data_port_id or \\\n                        data_flow.to_state == self.state_id and data_flow.to_key == data_port_id:\n                    data_flow_ids_to_remove.append(data_flow_id)\n\n            for data_flow_id in data_flow_ids_to_remove:\n                self.parent.remove_data_flow(data_flow_id)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nadding a new output data port to the state", "response": "def add_output_data_port(self, name, data_type, default_value=None, data_port_id=None):\n        \"\"\"Add a new output data port to the state\n\n        :param str name: the name of the new output data port\n        :param data_type: the type of the new output data port considered of class :class:`type` or\n                          :class:`str` which has to be convertible to :class:`type`\n        :param default_value: the default value of the data port\n        :param int data_port_id: the data_port_id of the new data port\n        :return: data_port_id of new output data port\n        :rtype: int\n        :raises exceptions.ValueError: if name of the output port is not unique\n        \"\"\"\n        if data_port_id is None:\n            # All data port ids have to passed to the id generation as the data port id has to be unique inside a state\n            data_port_id = generate_data_port_id(self.get_data_port_ids())\n        self._output_data_ports[data_port_id] = OutputDataPort(name, data_type, default_value, data_port_id, self)\n\n        # Check for name uniqueness\n        valid, message = self._check_data_port_name(self._output_data_ports[data_port_id])\n        if not valid:\n            self._output_data_ports[data_port_id].parent = None\n            del self._output_data_ports[data_port_id]\n            raise ValueError(message)\n\n        return data_port_id"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef remove_output_data_port(self, data_port_id, force=False, destroy=True):\n        if data_port_id in self._output_data_ports:\n            if destroy:\n                self.remove_data_flows_with_data_port_id(data_port_id)\n            self._output_data_ports[data_port_id].parent = None\n            return self._output_data_ports.pop(data_port_id)\n        else:\n            raise AttributeError(\"output data port with name %s does not exit\", data_port_id)", "response": "Removes an output data port from the state."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_io_data_port_id_from_name_and_type(self, name, data_port_type):\n        if data_port_type is InputDataPort:\n            for ip_id, output_port in self.input_data_ports.items():\n                if output_port.name == name:\n                    return ip_id\n            raise AttributeError(\"Name '{0}' is not in input_data_ports\".format(name))\n        elif data_port_type is OutputDataPort:\n            for op_id, output_port in self.output_data_ports.items():\n                if output_port.name == name:\n                    return op_id\n            # 'error' is an automatically generated output port in case of errors and exception and doesn't have an id\n            if name == \"error\":\n                return\n            raise AttributeError(\"Name '{0}' is not in output_data_ports\".format(name))", "response": "Returns the data_port_id of a data port with a certain name and data port type"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_data_port_by_id(self, data_port_id):\n        if data_port_id in self.input_data_ports:\n            return self.input_data_ports[data_port_id]\n        elif data_port_id in self.output_data_ports:\n            return self.output_data_ports[data_port_id]\n        return None", "response": "This method searches for the given data port id in the input and output data ports of the state and returns the data port with the searched id or None if it is not found."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_path(self, appendix=None, by_name=False):\n        if by_name:\n            state_identifier = self.name\n        else:\n            state_identifier = self.state_id\n\n        if not self.is_root_state:\n            if appendix is None:\n                return self.parent.get_path(state_identifier, by_name)\n            else:\n                return self.parent.get_path(state_identifier + PATH_SEPARATOR + appendix, by_name)\n        else:\n            if appendix is None:\n                return state_identifier\n            else:\n                return state_identifier + PATH_SEPARATOR + appendix", "response": "Recursively generates the path of the state."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_storage_path(self, appendix=None):\n        state_identifier = storage.get_storage_id_for_state(self)\n\n        if not self.is_root_state:\n            if appendix is None:\n                return self.parent.get_storage_path(state_identifier)\n            else:\n                return self.parent.get_storage_path(state_identifier + PATH_SEPARATOR + appendix)\n        else:\n            if appendix is None:\n                return state_identifier\n            else:\n                return state_identifier + PATH_SEPARATOR + appendix", "response": "Recursively creates the storage path of the state."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets a reference of the state_machine the state belongs to", "response": "def get_state_machine(self):\n        \"\"\"Get a reference of the state_machine the state belongs to\n\n        :rtype rafcon.core.state_machine.StateMachine\n        :return: respective state machine\n        \"\"\"\n        if self.parent:\n            if self.is_root_state:\n                return self.parent\n            else:\n                return self.parent.get_state_machine()\n\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef add_outcome(self, name, outcome_id=None):\n        if outcome_id is None:\n            outcome_id = generate_outcome_id(list(self.outcomes.keys()))\n        if name in self._outcomes:\n            logger.error(\"Two outcomes cannot have the same names\")\n            return\n        if outcome_id in self.outcomes:\n            logger.error(\"Two outcomes cannot have the same outcome_ids\")\n            return\n        outcome = Outcome(outcome_id, name, self)\n        self._outcomes[outcome_id] = outcome\n        return outcome_id", "response": "Add a new outcome to the state"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef remove(self, state_element, recursive=True, force=False, destroy=True):\n        if isinstance(state_element, Income):\n            self.remove_income(force, destroy=destroy)\n        if isinstance(state_element, Outcome):\n            return self.remove_outcome(state_element.outcome_id, force=force, destroy=destroy)\n        elif isinstance(state_element, InputDataPort):\n            return self.remove_input_data_port(state_element.data_port_id, force, destroy=destroy)\n        elif isinstance(state_element, OutputDataPort):\n            return self.remove_output_data_port(state_element.data_port_id, force, destroy=destroy)\n        else:\n            raise ValueError(\"Cannot remove state_element with invalid type\")", "response": "Removes the state element from the state store."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef remove_outcome(self, outcome_id, force=False, destroy=True):\n        if outcome_id not in self.outcomes:\n            raise AttributeError(\"There is no outcome_id %s\" % str(outcome_id))\n\n        if not force:\n            if outcome_id == -1 or outcome_id == -2:\n                raise AttributeError(\"You cannot remove the outcomes with id -1 or -2 as a state must always be able\"\n                                     \"to return aborted or preempted\")\n        # Remove internal transitions to this outcome\n        self.remove_outcome_hook(outcome_id)\n\n        # delete possible transition connected to this outcome\n        if destroy and not self.is_root_state:\n            for transition_id, transition in self.parent.transitions.items():\n                if transition.from_outcome == outcome_id and transition.from_state == self.state_id:\n                    self.parent.remove_transition(transition_id)\n                    break  # found the one outgoing transition\n\n        # delete outcome it self\n        self._outcomes[outcome_id].parent = None\n        return self._outcomes.pop(outcome_id)", "response": "Removes an outcome from the state."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef check_child_validity(self, child):\n        # Check type of child and call appropriate validity test\n        if isinstance(child, Income):\n            return self._check_income_validity(child)\n        if isinstance(child, Outcome):\n            return self._check_outcome_validity(child)\n        if isinstance(child, DataPort):\n            return self._check_data_port_validity(child)\n        if isinstance(child, ScopedData):\n            return self._check_scoped_data_validity(child)\n        return False, \"Invalid state element for state of type {}\".format(self.__class__.__name__)", "response": "Checks validity of passed child object and returns a boolean indicating if the child is valid."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncheck the validity of an outcome", "response": "def _check_outcome_validity(self, check_outcome):\n        \"\"\"Checks the validity of an outcome\n\n        Checks whether the id or the name of the outcome is already used by another outcome within the state.\n\n        :param rafcon.core.logical_port.Outcome check_outcome: The outcome to be checked\n        :return bool validity, str message: validity is True, when the outcome is valid, False else. message gives more\n            information especially if the outcome is not valid\n        \"\"\"\n        for outcome_id, outcome in self.outcomes.items():\n            # Do not compare outcome with itself when checking for existing name/id\n            if check_outcome is not outcome:\n                if check_outcome.outcome_id == outcome_id:\n                    return False, \"outcome id '{0}' existing in state\".format(check_outcome.outcome_id)\n                if check_outcome.name == outcome.name:\n                    return False, \"outcome name '{0}' existing in state\".format(check_outcome.name)\n        return True, \"valid\""}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nchecks the validity of a data port", "response": "def _check_data_port_validity(self, check_data_port):\n        \"\"\"Checks the validity of a data port\n\n        Checks whether the data flows connected to the port do not conflict with the data types.\n\n        :param rafcon.core.data_port.DataPort check_data_port: The data port to be checked\n        :return bool validity, str message: validity is True, when the data port is valid, False else. message gives\n            more information especially if the data port is not valid\n        \"\"\"\n        valid, message = self._check_data_port_id(check_data_port)\n        if not valid:\n            return False, message\n\n        valid, message = self._check_data_port_name(check_data_port)\n        if not valid:\n            return False, message\n\n        # Check whether the type matches any connected data port type\n        # Only relevant, if there is a parent state, otherwise the port cannot be connected to data flows\n        # TODO: check of internal connections\n        if not self.is_root_state:\n            # Call the check in the parent state, where the data flows are stored\n            return self.parent.check_data_port_connection(check_data_port)\n        else:\n            from rafcon.core.states.container_state import ContainerState\n            if isinstance(self, ContainerState):\n                return self.check_data_port_connection(check_data_port)\n\n        return True, \"valid\""}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _check_data_port_id(self, data_port):\n        for input_data_port_id, input_data_port in self.input_data_ports.items():\n            if data_port.data_port_id == input_data_port_id and data_port is not input_data_port:\n                return False, \"data port id already existing in state\"\n        for output_data_port_id, output_data_port in self.output_data_ports.items():\n            if data_port.data_port_id == output_data_port_id and data_port is not output_data_port:\n                return False, \"data port id already existing in state\"\n        return True, \"valid\"", "response": "Checks the validity of a data port id"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nchecking the validity of a data port name", "response": "def _check_data_port_name(self, data_port):\n        \"\"\"Checks the validity of a data port name\n\n        Checks whether the name of the given data port is already used by anther data port within the state. Names\n        must be unique with input data ports and output data ports.\n\n        :param rafcon.core.data_port.DataPort data_port: The data port to be checked\n        :return bool validity, str message: validity is True, when the data port is valid, False else. message gives\n            more information especially if the data port is not valid\n        \"\"\"\n        if data_port.data_port_id in self.input_data_ports:\n            for input_data_port in self.input_data_ports.values():\n                if data_port.name == input_data_port.name and data_port is not input_data_port:\n                    return False, \"data port name already existing in state's input data ports\"\n\n        elif data_port.data_port_id in self.output_data_ports:\n            for output_data_port in self.output_data_ports.values():\n                if data_port.name == output_data_port.name and data_port is not output_data_port:\n                    return False, \"data port name already existing in state's output data ports\"\n\n        return True, \"valid\""}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncheck the input data types of the state and generates an error message if they are not of the specified type.", "response": "def check_input_data_type(self):\n        \"\"\"Check the input data types of the state\n\n        Checks all input data ports if the handed data is not of the specified type and generate an error logger message\n        with details of the found type conflict.\n        \"\"\"\n        for data_port in self.input_data_ports.values():\n            if data_port.name in self.input_data and self.input_data[data_port.name] is not None:\n                #check for class\n                if not isinstance(self.input_data[data_port.name], data_port.data_type):\n                    logger.error(\"{0} had an data port error: Input of execute function must be of type '{1}' not '{2}'\"\n                                 \" as current value '{3}'\".format(self, data_port.data_type.__name__,\n                                                               type(self.input_data[data_port.name]).__name__,\n                                                               self.input_data[data_port.name]))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nchecking the output data types of the state and generates an error if they are not of the specified type", "response": "def check_output_data_type(self):\n        \"\"\"Check the output data types of the state\n\n        Checks all output data ports if the handed data is not of the specified type and generate an error logger\n        message with details of the found type conflict.\n        \"\"\"\n        for data_port in self.output_data_ports.values():\n            if data_port.name in self.output_data and self.output_data[data_port.name] is not None:\n                # check for class\n                if not isinstance(self.output_data[data_port.name], data_port.data_type):\n                    logger.error(\"{0} had an data port error: Output of execute function must be of type '{1}' not \"\n                                 \"'{2}' as current value {3}\".format(self, data_port.data_type.__name__,\n                                                               type(self.output_data[data_port.name]).__name__,\n                                                               self.output_data[data_port.name]))"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nchanges the id of the state to a new id.", "response": "def change_state_id(self, state_id=None):\n        \"\"\"Changes the id of the state to a new id\n\n        If no state_id is passed as parameter, a new state id is generated.\n\n        :param str state_id: The new state id of the state\n        :return:\n        \"\"\"\n        if state_id is None:\n            state_id = state_id_generator(used_state_ids=[self.state_id])\n        if not self.is_root_state and not self.is_root_state_of_library:\n            used_ids = list(self.parent.states.keys()) + [self.parent.state_id, self.state_id]\n            if state_id in used_ids:\n                state_id = state_id_generator(used_state_ids=used_ids)\n\n        self._state_id = state_id"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nretrieves an entry of the semantic data.", "response": "def get_semantic_data(self, path_as_list):\n        \"\"\" Retrieves an entry of the semantic data.\n\n        :param list path_as_list: The path in the vividict to retrieve the value from\n        :return:\n        \"\"\"\n        target_dict = self.semantic_data\n        for path_element in path_as_list:\n            if path_element in target_dict:\n                target_dict = target_dict[path_element]\n            else:\n                raise KeyError(\"The state with name {1} and id {2} holds no semantic data with path {0}.\"\n                               \"\".format(path_as_list[:path_as_list.index(path_element) + 1], self.name, self.state_id))\n\n        return target_dict"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nadds a semantic data entry.", "response": "def add_semantic_data(self, path_as_list, value, key):\n        \"\"\" Adds a semantic data entry.\n\n        :param list path_as_list: The path in the vividict to enter the value\n        :param value: The value of the new entry.\n        :param key: The key of the new entry.\n        :return:\n        \"\"\"\n        assert isinstance(key, string_types)\n        target_dict = self.get_semantic_data(path_as_list)\n        target_dict[key] = value\n        return path_as_list + [key]"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nremoves an entry from the semantic data vividict.", "response": "def remove_semantic_data(self, path_as_list):\n        \"\"\" Removes a entry from the semantic data vividict.\n\n        :param list path_as_list: The path of the vividict to delete.\n        :return: removed value or dict\n        \"\"\"\n        if len(path_as_list) == 0:\n            raise AttributeError(\"The argument path_as_list is empty but but the method remove_semantic_data needs a \"\n                                 \"valid path to remove a vividict item.\")\n        target_dict = self.get_semantic_data(path_as_list[0:-1])\n        removed_element = target_dict[path_as_list[-1]]\n        del target_dict[path_as_list[-1]]\n        return removed_element"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nremove all the state elements.", "response": "def destroy(self, recursive):\n        \"\"\" Removes all the state elements.\n\n        :param recursive: Flag wether to destroy all state elements which are removed\n        \"\"\"\n        for in_key in list(self.input_data_ports.keys()):\n            self.remove_input_data_port(in_key, force=True, destroy=recursive)\n\n        for out_key in list(self.output_data_ports.keys()):\n            self.remove_output_data_port(out_key, force=True, destroy=recursive)\n\n        if self._income:\n            self.remove_income(force=True, destroy=recursive)\n\n        for outcome_key in list(self.outcomes.keys()):\n            self.remove_outcome(outcome_key, force=True, destroy=recursive)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef input_data_ports(self, input_data_ports):\n        if not isinstance(input_data_ports, dict):\n            raise TypeError(\"input_data_ports must be of type dict\")\n        if [port_id for port_id, port in input_data_ports.items() if not port_id == port.data_port_id]:\n            raise AttributeError(\"The key of the input dictionary and the id of the data port do not match\")\n\n        # This is a fix for older state machines, which didn't distinguish between input and output ports\n        for port_id, port in input_data_ports.items():\n            if not isinstance(port, InputDataPort):\n                if isinstance(port, DataPort):\n                    port = InputDataPort(port.name, port.data_type, port.default_value, port.data_port_id)\n                    input_data_ports[port_id] = port\n                else:\n                    raise TypeError(\"Elements of input_data_ports must be of type InputDataPort, given: {0}\".format(\n                        type(port).__name__))\n\n        old_input_data_ports = self._input_data_ports\n        self._input_data_ports = input_data_ports\n        for port_id, port in input_data_ports.items():\n            try:\n                port.parent = self\n            except ValueError:\n                self._input_data_ports = old_input_data_ports\n                raise\n\n        # check that all old_input_data_ports are no more referencing self as there parent\n        for old_input_data_port in old_input_data_ports.values():\n            if old_input_data_port not in self._input_data_ports.values() and old_input_data_port.parent is self:\n                old_input_data_port.parent = None", "response": "Property for the _input_data_ports field"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef outcomes(self, outcomes):\n        if not isinstance(outcomes, dict):\n            raise TypeError(\"outcomes must be of type dict\")\n        if [outcome_id for outcome_id, outcome in outcomes.items() if not isinstance(outcome, Outcome)]:\n            raise TypeError(\"element of outcomes must be of type Outcome\")\n        if [outcome_id for outcome_id, outcome in outcomes.items() if not outcome_id == outcome.outcome_id]:\n            raise AttributeError(\"The key of the outcomes dictionary and the id of the outcome do not match\")\n\n        old_outcomes = self.outcomes\n        self._outcomes = outcomes\n        for outcome_id, outcome in outcomes.items():\n            try:\n                outcome.parent = self\n            except ValueError:\n                self._outcomes = old_outcomes\n                raise\n\n        # aborted and preempted must always exist\n        if -1 not in outcomes:\n            self._outcomes[-1] = Outcome(outcome_id=-1, name=\"aborted\", parent=self)\n        if -2 not in outcomes:\n            self._outcomes[-2] = Outcome(outcome_id=-2, name=\"preempted\", parent=self)\n\n        # check that all old_outcomes are no more referencing self as there parent\n        for old_outcome in old_outcomes.values():\n            if old_outcome not in iter(list(self._outcomes.values())) and old_outcome.parent is self:\n                old_outcome.parent = None", "response": "Setters for _outcomes field\n       "}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef is_root_state_of_library(self):\n        from rafcon.core.states.library_state import LibraryState\n        return isinstance(self.parent, LibraryState)", "response": "Returns True if the state is the root state of a library state and False otherwise"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the next upper library root state in the state_copy.", "response": "def get_next_upper_library_root_state(self):\n        \"\"\" Get next upper library root state\n\n        The method recursively checks state parent states till finding a StateMachine as parent or a library root state.\n        If self is a LibraryState the next upper library root state is searched and it is not handed self.state_copy.\n\n        :return library root state (Execution or ContainerState) or None if self is not a library root state or\n        inside of such\n        :rtype rafcon.core.states.library_state.State:\n        \"\"\"\n        from rafcon.core.state_machine import StateMachine\n\n        if self.is_root_state_of_library:\n            return self\n\n        state = self\n        while state.parent is not None and not isinstance(state.parent, StateMachine):\n            if state.parent.is_root_state_of_library:\n                return state.parent\n            state = state.parent\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nfind state_copy of uppermost LibraryState Method checks if there is a parent library root state and assigns it to the current library root state till there is no further parent library root state till there is no further parent library root state.", "response": "def get_uppermost_library_root_state(self):\n        \"\"\"Find state_copy of uppermost LibraryState\n\n        Method checks if there is a parent library root state and assigns it to be the current library root state till\n        there is no further parent library root state.\n        \"\"\"\n\n        library_root_state = self.get_next_upper_library_root_state()\n        parent_library_root_state = library_root_state\n        # initial a library root state has to be found and if there is no further parent root state\n        # parent_library_root_state and library_root_state are no more identical\n        while parent_library_root_state and library_root_state is parent_library_root_state:\n            if library_root_state:\n                parent_library_root_state = library_root_state.parent.get_next_upper_library_root_state()\n\n            if parent_library_root_state:\n                library_root_state = parent_library_root_state\n\n        return library_root_state"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nfinalizing state This method is called when the run method finishes :param rafcon.core.logical_port.Outcome outcome: final outcome of the state :return: Nothing for the moment", "response": "def finalize(self, outcome=None):\n        \"\"\"Finalize state\n\n        This method is called when the run method finishes\n\n        :param rafcon.core.logical_port.Outcome outcome: final outcome of the state\n        :return: Nothing for the moment\n        \"\"\"\n\n        # Set the final outcome of the state\n        if outcome is not None:\n            self.final_outcome = outcome\n\n        # If we are within a concurrency state, we have to notify it about our finalization\n        if self.concurrency_queue:\n            self.concurrency_queue.put(self.state_id)\n\n        logger.debug(\"Finished execution of {0}: {1}\".format(self, self.final_outcome))\n\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nconstructing an undirected multigraph from a list containing data on weighted edges.", "response": "def graph_from_edges(edges):\n    \"\"\" Constructs an undirected multigraph from a list containing data on\n    weighted edges.\n\n    Parameters\n    ----------\n    edges : list\n        List of tuples each containing first node, second node, weight, key.\n\n    Returns\n    -------\n    M : :class:`networkx.classes.multigraph.MultiGraph\n    \"\"\"\n\n    M = nx.MultiGraph()\n\n    for e in edges:\n\n        n0, n1, weight, key = e\n\n        M.add_edge(n0, n1, weight=weight, key=key)\n\n    return M"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef busmap_from_psql(network, session, scn_name):\n\n    def fetch():\n\n        query = session.query(EgoGridPfHvBusmap.bus0, EgoGridPfHvBusmap.bus1).\\\n            filter(EgoGridPfHvBusmap.scn_name == scn_name)\n\n        return dict(query.all())\n\n    busmap = fetch()\n\n    # TODO: Or better try/except/finally\n    if not busmap:\n        print('Busmap does not exist and will be created.\\n')\n\n        cpu_cores = input('cpu_cores (default 4): ') or '4'\n\n        busmap_by_shortest_path(network, session, scn_name,\n                                fromlvl=[110], tolvl=[220, 380, 400, 450],\n                                cpu_cores=int(cpu_cores))\n        busmap = fetch()\n\n    return busmap", "response": "Returns a dict containing all the bus_ids of all network components in a given scenario."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef kmean_clustering(network, n_clusters=10, load_cluster=False,\n                     line_length_factor=1.25,\n                     remove_stubs=False, use_reduced_coordinates=False,\n                     bus_weight_tocsv=None, bus_weight_fromcsv=None,\n                     n_init=10, max_iter=300, tol=1e-4,\n                     n_jobs=1):\n    \"\"\" Main function of the k-mean clustering approach. Maps an original\n    network to a new one with adjustable number of nodes and new coordinates.\n\n    Parameters\n    ----------\n    network : :class:`pypsa.Network\n        Container for all network components.\n\n    n_clusters : int\n        Desired number of clusters.\n\n    load_cluster : boolean\n        Loads cluster coordinates from a former calculation.\n\n    line_length_factor : float\n        Factor to multiply the crow-flies distance between new buses in order\n        to get new line lengths.\n\n    remove_stubs: boolean\n        Removes stubs and stubby trees (i.e. sequentially reducing dead-ends).\n\n    use_reduced_coordinates: boolean\n        If True, do not average cluster coordinates, but take from busmap.\n\n    bus_weight_tocsv : str\n        Creates a bus weighting based on conventional generation and load\n        and save it to a csv file.\n\n    bus_weight_fromcsv : str\n        Loads a bus weighting from a csv file to apply it to the clustering\n        algorithm.\n\n    Returns\n    -------\n    network : pypsa.Network object\n        Container for all network components.\n    \"\"\"\n    def weighting_for_scenario(x, save=None):\n        \"\"\"\n        \"\"\"\n        b_i = x.index\n        g = normed(gen.reindex(b_i, fill_value=0))\n        l = normed(load.reindex(b_i, fill_value=0))\n\n        w = g + l\n        weight = ((w * (100000. / w.max())).astype(int)\n                  ).reindex(network.buses.index, fill_value=1)\n\n        if save:\n            weight.to_csv(save)\n\n        return weight\n\n    def normed(x):\n        return (x / x.sum()).fillna(0.)\n\n    print('start k-mean clustering')\n    # prepare k-mean\n    # k-means clustering (first try)\n    network.generators.control = \"PV\"\n    network.storage_units.control[network.storage_units.carrier == \\\n                                  'extendable_storage'] = \"PV\"\n    network.buses['v_nom'] = 380.\n    # problem our lines have no v_nom. this is implicitly defined by the\n    # connected buses:\n    network.lines[\"v_nom\"] = network.lines.bus0.map(network.buses.v_nom)\n\n    # adjust the x of the lines which are not 380.\n    lines_v_nom_b = network.lines.v_nom != 380\n    network.lines.loc[lines_v_nom_b, 'x'] *= \\\n        (380. / network.lines.loc[lines_v_nom_b, 'v_nom'])**2\n    network.lines.loc[lines_v_nom_b, 'v_nom'] = 380.\n\n    trafo_index = network.transformers.index\n    transformer_voltages = \\\n        pd.concat([network.transformers.bus0.map(network.buses.v_nom),\n                   network.transformers.bus1.map(network.buses.v_nom)], axis=1)\n\n    network.import_components_from_dataframe(\n        network.transformers.loc[:, [\n                'bus0', 'bus1', 'x', 's_nom', 'capital_cost', 'sub_network', 's_nom_total']]\n        .assign(x=network.transformers.x * (380. /\n                transformer_voltages.max(axis=1))**2, length = 1)\n        .set_index('T' + trafo_index),\n        'Line')\n    network.transformers.drop(trafo_index, inplace=True)\n\n    for attr in network.transformers_t:\n        network.transformers_t[attr] = network.transformers_t[attr]\\\n            .reindex(columns=[])\n\n    # remove stubs\n    if remove_stubs:\n        network.determine_network_topology()\n        busmap = busmap_by_stubs(network)\n        network.generators['weight'] = network.generators['p_nom']\n        aggregate_one_ports = components.one_port_components.copy()\n        aggregate_one_ports.discard('Generator')\n        # reset coordinates to the new reduced guys, rather than taking an\n        # average (copied from pypsa.networkclustering)\n        if use_reduced_coordinates:\n            # TODO : FIX THIS HACK THAT HAS UNEXPECTED SIDE-EFFECTS,\n            # i.e. network is changed in place!!\n            network.buses.loc[busmap.index, ['x', 'y']\n                              ] = network.buses.loc[busmap, ['x', 'y']].values\n\n        clustering = get_clustering_from_busmap(\n            network,\n            busmap,\n            aggregate_generators_weighted=True,\n            aggregate_one_ports=aggregate_one_ports,\n            line_length_factor=line_length_factor)\n        network = clustering.network\n\n    # define weighting based on conventional 'old' generator spatial\n    # distribution\n    non_conv_types = {\n        'biomass',\n        'wind_onshore',\n        'wind_offshore',\n        'solar',\n        'geothermal',\n        'load shedding',\n        'extendable_storage'}\n    # Attention: network.generators.carrier.unique()\n    gen = (network.generators.loc[(network.generators.carrier\n                                   .isin(non_conv_types) == False)]\n           .groupby('bus').p_nom.sum()\n                                .reindex(network.buses.index, fill_value=0.) +\n           network.storage_units\n                                .loc[(network.storage_units.carrier\n                                      .isin(non_conv_types) == False)]\n                  .groupby('bus').p_nom.sum()\n                  .reindex(network.buses.index, fill_value=0.))\n\n    load = network.loads_t.p_set.mean().groupby(network.loads.bus).sum()\n\n    # k-mean clustering\n\n    # busmap = busmap_by_kmeans(network, bus_weightings=pd.Series(np.repeat(1,\n    #       len(network.buses)), index=network.buses.index) , n_clusters= 10)\n    # State whether to create a bus weighting and save it, create or not save\n    # it, or use a bus weighting from a csv file\n    if bus_weight_tocsv is not None:\n        weight = weighting_for_scenario(x=network.buses, save=bus_weight_tocsv)\n    elif bus_weight_fromcsv is not None:\n        weight = pd.Series.from_csv(bus_weight_fromcsv)\n        weight.index = weight.index.astype(str)\n    else:\n        weight = weighting_for_scenario(x=network.buses, save=False)\n\n    busmap = busmap_by_kmeans(\n        network,\n        bus_weightings=pd.Series(weight),\n        n_clusters=n_clusters,\n        load_cluster=load_cluster,\n        n_init=n_init,\n        max_iter=max_iter,\n        tol=tol,\n        n_jobs=n_jobs)\n\n    # ToDo change function in order to use bus_strategies or similar\n    network.generators['weight'] = network.generators['p_nom']\n    aggregate_one_ports = components.one_port_components.copy()\n    aggregate_one_ports.discard('Generator')\n    clustering = get_clustering_from_busmap(\n        network,\n        busmap,\n        aggregate_generators_weighted=True,\n        aggregate_one_ports=aggregate_one_ports)\n\n    return clustering", "response": "K - mean clustering algorithm."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef register_actions(self, shortcut_manager):\n        super(DescriptionEditorController, self).register_actions(shortcut_manager)\n        shortcut_manager.add_callback_for_action(\"abort\", self._abort)", "response": "Register callback methods for triggered actions\n           "}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef register_view(self, view):\n        super(GraphicalEditorController, self).register_view(view)\n\n        self.view.connect('meta_data_changed', self._meta_data_changed)\n        self.focus_changed_handler_id = self.view.editor.connect('focus-changed', self._move_focused_item_into_viewport)\n        self.view.editor.connect(\"drag-data-received\", self.on_drag_data_received)\n        self.drag_motion_handler_id = self.view.editor.connect(\"drag-motion\", self.on_drag_motion)\n\n        self.setup_canvas()", "response": "Called when the View was registered"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nregisters callback methods for triggered actions.", "response": "def register_actions(self, shortcut_manager):\n        \"\"\"Register callback methods for triggered actions\n\n        :param rafcon.gui.shortcut_manager.ShortcutManager shortcut_manager: Shortcut Manager Object holding mappings\n            between shortcuts and actions.\n        \"\"\"\n        shortcut_manager.add_callback_for_action(\"add\", partial(self._add_new_state, state_type=StateType.EXECUTION))\n        shortcut_manager.add_callback_for_action(\"add_execution_state\", partial(self._add_new_state,\n                                                                                state_type=StateType.EXECUTION))\n        shortcut_manager.add_callback_for_action(\"add_hierarchy_state\", partial(self._add_new_state,\n                                                                                state_type=StateType.HIERARCHY))\n        shortcut_manager.add_callback_for_action(\"add_barrier_state\", partial(self._add_new_state,\n                                                                              state_type=StateType.BARRIER_CONCURRENCY))\n        shortcut_manager.add_callback_for_action(\"add_preemptive_state\", partial(self._add_new_state,\n                                                                                 state_type=StateType.PREEMPTION_CONCURRENCY))\n\n        shortcut_manager.add_callback_for_action(\"add_output\", partial(self._add_data_port_to_selected_state,\n                                                                       data_port_type='OUTPUT'))\n        shortcut_manager.add_callback_for_action(\"add_input\", partial(self._add_data_port_to_selected_state,\n                                                                      data_port_type='INPUT'))\n        shortcut_manager.add_callback_for_action(\"add_scoped_variable\", self._add_scoped_variable_to_selected_state)\n        shortcut_manager.add_callback_for_action(\"add_outcome\", self._add_outcome_to_selected_state)\n\n        shortcut_manager.add_callback_for_action(\"delete\", self._remove_selected_elements)\n\n        shortcut_manager.add_callback_for_action(\"copy\", self._copy_selection)\n        shortcut_manager.add_callback_for_action(\"paste\", self._paste_clipboard)\n        shortcut_manager.add_callback_for_action(\"cut\", self._cut_selection)\n\n        shortcut_manager.add_callback_for_action('show_data_flows', self.update_view)\n        shortcut_manager.add_callback_for_action('show_data_values', self.update_view)\n        shortcut_manager.add_callback_for_action('data_flow_mode', self.data_flow_mode)\n        shortcut_manager.add_callback_for_action('show_aborted_preempted', self.update_view)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef on_drag_data_received(self, widget, context, x, y, data, info, time):\n        state_id_insert = data.get_text()\n        parent_m = self.model.selection.get_selected_state()\n        if not isinstance(parent_m, ContainerStateModel):\n            return\n        state_v = self.canvas.get_view_for_model(parent_m.states[state_id_insert])\n        pos_start = state_v.model.get_meta_data_editor()['rel_pos']\n        motion = InMotion(state_v, self.view.editor)\n        motion.start_move(self.view.editor.get_matrix_i2v(state_v).transform_point(pos_start[0], pos_start[1]))\n        motion.move((x, y))\n        motion.stop_move()\n        state_v.model.set_meta_data_editor('rel_pos', motion.item.position)\n        self.canvas.wait_for_update(trigger_update=True)\n        self._meta_data_changed(None, state_v.model, 'append_to_last_change', True)", "response": "Handles the drag data received from the LibraryTree and moves the state to the position of the mouse."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef on_drag_motion(self, widget, context, x, y, time):\n        hovered_item = ItemFinder(self.view.editor).get_item_at_point((x, y))\n        if isinstance(hovered_item, NameView):\n            hovered_item = hovered_item.parent\n        if hovered_item is None:\n            self.view.editor.unselect_all()\n        elif isinstance(hovered_item.model, ContainerStateModel):\n            if len(self.view.editor.selected_items) == 1 and hovered_item in self.view.editor.selected_items:\n                return\n            if len(self.view.editor.selected_items) > 0:\n                self.view.editor.unselect_all()\n\n            if not rafcon.gui.singleton.global_gui_config.get_config_value('DRAG_N_DROP_WITH_FOCUS'):\n                self.view.editor.handler_block(self.focus_changed_handler_id)\n            self.view.editor.focused_item = hovered_item\n            if not rafcon.gui.singleton.global_gui_config.get_config_value('DRAG_N_DROP_WITH_FOCUS'):\n                self.view.editor.handler_unblock(self.focus_changed_handler_id)", "response": "Changes the selection on mouse over during drag motion"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _add_new_state(self, *event, **kwargs):\n        if react_to_event(self.view, self.view.editor, event):\n            state_type = StateType.EXECUTION if 'state_type' not in kwargs else kwargs['state_type']\n            return gui_helper_state_machine.add_new_state(self.model, state_type)", "response": "Triggered when the add new state is clicked."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _copy_selection(self, *event):\n        if react_to_event(self.view, self.view.editor, event):\n            logger.debug(\"copy selection\")\n            global_clipboard.copy(self.model.selection)\n            return True", "response": "Copies the current selection to the clipboard."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncut the current selection and copies it to the clipboard.", "response": "def _cut_selection(self, *event):\n        \"\"\"Cuts the current selection and copys it to the clipboard.\n        \"\"\"\n        if react_to_event(self.view, self.view.editor, event):\n            logger.debug(\"cut selection\")\n            global_clipboard.cut(self.model.selection)\n            return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _paste_clipboard(self, *event):\n        if react_to_event(self.view, self.view.editor, event):\n            logger.debug(\"Paste\")\n            gui_helper_state_machine.paste_into_selected_state(self.model)\n            return True", "response": "Paste the current clipboard into the current selection if the current selection is a container state."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _move_focused_item_into_viewport(self, view, focused_item):\n        self.view.editor.handler_block(self.drag_motion_handler_id)\n        self.move_item_into_viewport(focused_item)\n        self.view.editor.handler_unblock(self.drag_motion_handler_id)", "response": "Called when an item is focused moves the item into the viewport"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nmoving the item into the viewport.", "response": "def move_item_into_viewport(self, item):\n        \"\"\"Causes the `item` to be moved into the viewport\n\n        The zoom factor and the position of the viewport are updated to move the `item` into the viewport. If `item`\n        is not a `StateView`, the parental `StateView` is moved into the viewport.\n\n        :param StateView | ConnectionView | PortView item: The item to be moved into the viewport\n        \"\"\"\n        if not item:\n            return\n        HORIZONTAL = 0\n        VERTICAL = 1\n        if not isinstance(item, Item):\n            state_v = item.parent\n        elif not isinstance(item, StateView):\n            state_v = self.canvas.get_parent(item)\n        else:\n            state_v = item\n        viewport_size = self.view.editor.get_allocation().width, self.view.editor.get_allocation().height\n        state_size = self.view.editor.get_matrix_i2v(state_v).transform_distance(state_v.width, state_v.height)\n        min_relative_size = min(viewport_size[i] / state_size[i] for i in [HORIZONTAL, VERTICAL])\n\n        if min_relative_size != 1:\n            # Allow margin around state\n            margin_relative = 1. / gui_constants.BORDER_WIDTH_STATE_SIZE_FACTOR\n            zoom_factor = min_relative_size * (1 - margin_relative)\n            if zoom_factor > 1:\n                zoom_base = 4\n                zoom_factor = max(1, math.log(zoom_factor*zoom_base, zoom_base))\n            self.view.editor.zoom(zoom_factor)\n            # The zoom operation must be performed before the pan operation to work on updated GtkAdjustments (scroll\n            # bars)\n            self.canvas.wait_for_update()\n\n        state_pos = self.view.editor.get_matrix_i2v(state_v).transform_point(0, 0)\n        state_size = self.view.editor.get_matrix_i2v(state_v).transform_distance(state_v.width, state_v.height)\n        viewport_size = self.view.editor.get_allocation().width, self.view.editor.get_allocation().height\n\n        # Calculate offset around state so that the state is centered in the viewport\n        padding_offset_horizontal = (viewport_size[HORIZONTAL] - state_size[HORIZONTAL]) / 2.\n        padding_offset_vertical = (viewport_size[VERTICAL] - state_size[VERTICAL]) / 2.\n        self.view.editor.hadjustment.set_value(state_pos[HORIZONTAL] - padding_offset_horizontal)\n        self.view.editor.vadjustment.set_value(state_pos[VERTICAL] - padding_offset_vertical)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncleaning up when state machine is being destructed", "response": "def state_machine_destruction(self, model, prop_name, info):\n        \"\"\" Clean up when state machine is being destructed \"\"\"\n        if self.model is model:  # only used for the state machine destruction case\n            self.canvas.get_view_for_model(self.root_state_m).remove()"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nhandles the meta data of the affected state", "response": "def meta_changed_notify_after(self, state_machine_m, _, info):\n        \"\"\"Handle notification about the change of a state's meta data\n\n        The meta data of the affected state(s) are read and the view updated accordingly.\n        :param StateMachineModel state_machine_m: Always the state machine model belonging to this editor\n        :param str _: Always \"state_meta_signal\"\n        :param dict info: Information about the change, contains the MetaSignalMessage in the 'arg' key value\n        \"\"\"\n        meta_signal_message = info['arg']\n        if meta_signal_message.origin == \"graphical_editor_gaphas\":  # Ignore changes caused by ourself\n            return\n        if meta_signal_message.origin == \"load_meta_data\":  # Meta data can't be applied, as the view has not yet\n            return                                          # been created\n        notification = meta_signal_message.notification\n        if not notification:    # For changes applied to the root state, there are always two notifications\n            return              # Ignore the one with less information\n        if self.model.ongoing_complex_actions:\n            return\n\n        model = notification.model\n        view = self.canvas.get_view_for_model(model)\n\n        if meta_signal_message.change == 'show_content':\n            library_state_m = model\n            library_state_v = view\n            if library_state_m.meta['gui']['show_content'] is not library_state_m.show_content():\n                logger.warning(\"The content of the LibraryState won't be shown, because \"\n                               \"MAX_VISIBLE_LIBRARY_HIERARCHY is 1.\")\n            if library_state_m.show_content():\n                if not library_state_m.state_copy_initialized:\n                    logger.warning(\"Show library content without initialized state copy does not work {0}\"\n                                   \"\".format(library_state_m))\n                logger.debug(\"Show content of {}\".format(library_state_m.state))\n                gui_helper_meta_data.scale_library_content(library_state_m)\n                self.add_state_view_for_model(library_state_m.state_copy, view,\n                                              hierarchy_level=library_state_v.hierarchy_level + 1)\n            else:\n                logger.debug(\"Hide content of {}\".format(library_state_m.state))\n                state_copy_v = self.canvas.get_view_for_model(library_state_m.state_copy)\n                if state_copy_v:\n                    state_copy_v.remove()\n        else:\n            if isinstance(view, StateView):\n                view.apply_meta_data(recursive=meta_signal_message.affects_children)\n            else:\n                view.apply_meta_data()\n\n        self.canvas.request_update(view, matrix=True)\n        self.canvas.wait_for_update()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef state_machine_change_after(self, model, prop_name, info):\n\n        if 'method_name' in info and info['method_name'] == 'root_state_change':\n            method_name, model, result, arguments, instance = self._extract_info_data(info['kwargs'])\n\n            if self.model.ongoing_complex_actions:\n                return\n\n            # The method causing the change raised an exception, thus nothing was changed\n            if (isinstance(result, string_types) and \"CRASH\" in result) or isinstance(result, Exception):\n                return\n\n            # avoid to remove views of elements of states which parent state is destroyed recursively\n            if 'remove' in method_name:\n                # for remove the model is always a state and in case of remove_state it is the container_state\n                # that performs the operation therefore if is_about_to_be_destroyed_recursively is False\n                # the child state can be removed and for True ignored because its parent will create a notification\n                if model.is_about_to_be_destroyed_recursively:\n                    return\n\n            # only react to the notification if the model is a model, which has to be drawn\n            # if it is a model inside a library state, this is eventually not the case\n            if isinstance(model, AbstractStateModel):\n                library_root_state = model.state.get_next_upper_library_root_state()\n                if library_root_state:\n                    parent_library_root_state_m = self.model.get_state_model_by_path(library_root_state.get_path())\n                    if not parent_library_root_state_m.parent.show_content():\n                        return\n\n            if method_name == 'state_execution_status':\n                state_v = self.canvas.get_view_for_model(model)\n                if state_v:  # Children of LibraryStates are not modeled, yet\n                    self.canvas.request_update(state_v, matrix=False)\n            elif method_name == 'add_state':\n                new_state = arguments[1]\n                new_state_m = model.states[new_state.state_id]\n                self.add_state_view_with_meta_data_for_model(new_state_m, model)\n                if not self.perform_drag_and_drop:\n                    self.canvas.wait_for_update()\n            elif method_name == 'remove_state':\n                state_v = self.canvas.get_view_for_core_element(result)\n                if state_v:\n                    parent_v = self.canvas.get_parent(state_v)\n                    state_v.remove()\n                    if parent_v:\n                        self.canvas.request_update(parent_v)\n                    self.canvas.wait_for_update()\n\n            # ----------------------------------\n            #           TRANSITIONS\n            # ----------------------------------\n            elif method_name == 'add_transition':\n                transitions_models = model.transitions\n                transition_id = result\n                for transition_m in transitions_models:\n                    if transition_m.transition.transition_id == transition_id:\n                        self.add_transition_view_for_model(transition_m, model)\n                        self.canvas.wait_for_update()\n                        break\n            elif method_name == 'remove_transition':\n                transition_v = self.canvas.get_view_for_core_element(result)\n                if transition_v:\n                    state_m = model\n                    state_v = self.canvas.get_view_for_model(state_m)\n                    transition_v.remove()\n                    self.canvas.request_update(state_v, matrix=False)\n                    self.canvas.wait_for_update()\n            elif method_name == 'transition_change':\n                transition_m = model\n                transition_v = self.canvas.get_view_for_model(transition_m)\n                self._reconnect_transition(transition_v, transition_m, transition_m.parent)\n                self.canvas.wait_for_update()\n\n            # ----------------------------------\n            #           DATA FLOW\n            # ----------------------------------\n            elif method_name == 'add_data_flow':\n                data_flow_models = model.data_flows\n                data_flow_id = result\n                for data_flow_m in data_flow_models:\n                    if data_flow_m.data_flow.data_flow_id == data_flow_id:\n                        self.add_data_flow_view_for_model(data_flow_m, model)\n                        self.canvas.wait_for_update()\n                        break\n            elif method_name == 'remove_data_flow':\n                data_flow_v = self.canvas.get_view_for_core_element(result)\n                if data_flow_v:\n                    state_m = model\n                    state_v = self.canvas.get_view_for_model(state_m)\n                    self.canvas.request_update(state_v, matrix=False)\n                    data_flow_v.remove()\n                    self.canvas.wait_for_update()\n            elif method_name == 'data_flow_change':\n                data_flow_m = model\n                data_flow_v = self.canvas.get_view_for_model(data_flow_m)\n                self._reconnect_data_flow(data_flow_v, data_flow_m, data_flow_m.parent)\n                self.canvas.wait_for_update()\n\n            # ----------------------------------\n            #           OUTCOMES\n            # ----------------------------------\n            elif method_name == 'add_outcome':\n                state_m = model\n                state_v = self.canvas.get_view_for_model(state_m)\n                for outcome_m in state_m.outcomes:\n                    if outcome_m.outcome.outcome_id == result:\n                        state_v.add_outcome(outcome_m)\n                        self.canvas.request_update(state_v, matrix=False)\n                        self.canvas.wait_for_update()\n                        break\n            elif method_name == 'remove_outcome':\n                state_m = model\n                state_v = self.canvas.get_view_for_model(state_m)\n                if state_v is None:\n                    logger.debug(\"no state_v found for method_name '{}'\".format(method_name))\n                else:\n                    outcome_v = self.canvas.get_view_for_core_element(result)\n                    if outcome_v:\n                        state_v.remove_outcome(outcome_v)\n                        self.canvas.request_update(state_v, matrix=False)\n                        self.canvas.wait_for_update()\n\n            # ----------------------------------\n            #           DATA PORTS\n            # ----------------------------------\n            elif method_name == 'add_input_data_port':\n                state_m = model\n                state_v = self.canvas.get_view_for_model(state_m)\n                for input_data_port_m in state_m.input_data_ports:\n                    if input_data_port_m.data_port.data_port_id == result:\n                        state_v.add_input_port(input_data_port_m)\n                        self.canvas.request_update(state_v, matrix=False)\n                        self.canvas.wait_for_update()\n                        break\n            elif method_name == 'add_output_data_port':\n                state_m = model\n                state_v = self.canvas.get_view_for_model(state_m)\n                for output_data_port_m in state_m.output_data_ports:\n                    if output_data_port_m.data_port.data_port_id == result:\n                        state_v.add_output_port(output_data_port_m)\n                        self.canvas.request_update(state_v, matrix=False)\n                        self.canvas.wait_for_update()\n                        break\n            elif method_name == 'remove_input_data_port':\n                state_m = model\n                state_v = self.canvas.get_view_for_model(state_m)\n                if state_v is None:\n                    logger.debug(\"no state_v found for method_name '{}'\".format(method_name))\n                else:\n                    input_port_v = self.canvas.get_view_for_core_element(result)\n                    if input_port_v:\n                        state_v.remove_input_port(input_port_v)\n                        self.canvas.request_update(state_v, matrix=False)\n                        self.canvas.wait_for_update()\n            elif method_name == 'remove_output_data_port':\n                state_m = model\n                state_v = self.canvas.get_view_for_model(state_m)\n                if state_v is None:\n                    logger.debug(\"no state_v found for method_name '{}'\".format(method_name))\n                else:\n                    output_port_v = self.canvas.get_view_for_core_element(result)\n                    if output_port_v:\n                        state_v.remove_output_port(output_port_v)\n                        self.canvas.request_update(state_v, matrix=False)\n                        self.canvas.wait_for_update()\n            elif method_name in ['data_type', 'change_data_type']:\n                pass\n            elif method_name == 'default_value':\n                pass\n\n            # ----------------------------------\n            #         SCOPED VARIABLES\n            # ----------------------------------\n            elif method_name == 'add_scoped_variable':\n                state_m = model\n                state_v = self.canvas.get_view_for_model(state_m)\n                for scoped_variable_m in state_m.scoped_variables:\n                    if scoped_variable_m.scoped_variable.data_port_id == result:\n                        state_v.add_scoped_variable(scoped_variable_m)\n                        self.canvas.request_update(state_v, matrix=False)\n                        self.canvas.wait_for_update()\n                        break\n            elif method_name == 'remove_scoped_variable':\n                state_m = model\n                state_v = self.canvas.get_view_for_model(state_m)\n                if state_v is None:\n                    logger.debug(\"no state_v found for method_name '{}'\".format(method_name))\n                else:\n                    scoped_variable_v = self.canvas.get_view_for_core_element(result)\n                    if scoped_variable_v:\n                        state_v.remove_scoped_variable(scoped_variable_v)\n                        self.canvas.request_update(state_v, matrix=False)\n                        self.canvas.wait_for_update()\n\n            # ----------------------------------\n            #        STATE MISCELLANEOUS\n            # ----------------------------------\n            elif method_name == 'name':\n                # The name of a state was changed\n                if not isinstance(model, AbstractStateModel):\n                    parent_model = model.parent\n                # The name of a port (input, output, scoped var, outcome) was changed\n                else:\n                    parent_model = model\n                state_v = self.canvas.get_view_for_model(parent_model)\n                if parent_model is model:\n                    state_v.name_view.name = arguments[1]\n                    self.canvas.request_update(state_v.name_view, matrix=False)\n                else:\n                    self.canvas.request_update(state_v, matrix=False)\n                self.canvas.wait_for_update()\n            elif method_name == 'parent':\n                pass\n            elif method_name == 'description':\n                pass\n            elif method_name == 'script_text':\n                pass\n            # TODO handle the following method calls -> for now those are explicit (in the past implicit) ignored\n            # TODO -> correct the complex actions which are used in some test (by test calls or by adapting the model)\n            elif method_name in ['input_data_ports', 'output_data_ports', 'outcomes',\n                                 'change_root_state_type', 'change_state_type',\n                                 'group_states', 'ungroup_state', 'substitute_state']:\n                pass\n            else:\n                known_ignore_list = ['set_input_runtime_value', 'set_use_input_runtime_value',  # from library State\n                                     'set_output_runtime_value', 'set_use_output_runtime_value',\n                                     'input_data_port_runtime_values', 'use_runtime_value_input_data_ports',\n                                     'output_data_port_runtime_values', 'use_runtime_value_output_data_ports',\n                                     'semantic_data', 'add_semantic_data', 'remove_semantic_data',\n                                     'remove_income']\n                if method_name not in known_ignore_list:\n                    logger.warning(\"Method {0} not caught in GraphicalViewer, details: {1}\".format(method_name, info))\n\n            if method_name in ['add_state', 'add_transition', 'add_data_flow', 'add_outcome', 'add_input_data_port',\n                               'add_output_data_port', 'add_scoped_variable', 'data_flow_change', 'transition_change']:\n                try:\n                    self._meta_data_changed(None, model, 'append_to_last_change', True)\n                except Exception as e:\n                    logger.exception('Error while trying to emit meta data signal {0} {1}'.format(e, model))", "response": "Called when any state machine changes within the state machine"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nfocusing a state view of respective state model", "response": "def set_focus_to_state_model(self, state_m, ratio_requested=0.8):\n        \"\"\" Focus a state view of respective state model\n        :param rafcon.gui.model.state state_m: Respective state model of state view to be focused\n        :param ratio_requested: Minimum ratio of the screen which is requested, so can be more\n        :return:\n        \"\"\"\n        state_machine_m = self.model\n        state_v = self.canvas.get_view_for_model(state_m)\n        if state_v is None:\n            logger.warning('There is no view for state model {0}'.format(state_m))\n        self.move_item_into_viewport(state_v)\n        # check_relative size in view and call it again if the state is still very small\n        state_v = self.canvas.get_view_for_model(state_machine_m.root_state)\n        state_size = self.view.editor.get_matrix_i2v(state_v).transform_distance(state_v.width, state_v.height)\n        viewport_size = self.view.editor.get_allocation().width, self.view.editor.get_allocation().height\n        if state_size[0] < ratio_requested*viewport_size[0] and state_size[1] < ratio_requested*viewport_size[1]:\n            self.set_focus_to_state_model(state_m, ratio_requested)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef add_state_view_for_model(self, state_m, parent_v=None, rel_pos=(0, 0), size=(100, 100), hierarchy_level=1):\n        assert isinstance(state_m, AbstractStateModel)\n        state_meta = state_m.get_meta_data_editor()\n\n        # Use default values if no size information is stored\n        if not gui_helper_meta_data.contains_geometric_info(state_meta['size']):\n            state_meta = state_m.set_meta_data_editor('size', size)\n\n        size = state_meta['size']\n\n        # Use default values if no position information is stored\n        if not gui_helper_meta_data.contains_geometric_info(state_meta['rel_pos']):\n            state_meta = state_m.set_meta_data_editor('rel_pos', rel_pos)\n\n        rel_pos = state_meta['rel_pos']\n\n        if isinstance(state_m, LibraryStateModel):\n            if not state_m.meta_data_was_scaled:\n                gui_helper_meta_data.scale_library_ports_meta_data(state_m, gaphas_editor=True)\n\n        state_v = StateView(state_m, size, hierarchy_level)\n\n        # Draw state above data flows and NameView but beneath transitions\n        num_data_flows = len(state_m.state.parent.data_flows) if isinstance(state_m.parent, ContainerStateModel) else 0\n        index = 1 if not parent_v else num_data_flows + 1\n        # if self.model.root_state is state_m:\n        #     print(\"init root_state\", state_m, state_v)\n        # else:\n        #     print(\"init state\", state_m, state_v)\n        # print([hash(elem) for elem in state_m.state.outcomes.values()])\n        self.canvas.add(state_v, parent_v, index=index)\n        state_v.matrix.translate(*rel_pos)\n\n        state_v.add_income(state_m.income)\n\n        for outcome_m in state_m.outcomes:\n            state_v.add_outcome(outcome_m)\n\n        for input_port_m in state_m.input_data_ports:\n            state_v.add_input_port(input_port_m)\n\n        for output_port_m in state_m.output_data_ports:\n            state_v.add_output_port(output_port_m)\n\n        if parent_v is not None:\n            # Keep state within parent\n            pass\n\n        if isinstance(state_m, LibraryStateModel) and state_m.show_content() and state_m.state_copy_initialized:\n            gui_helper_meta_data.scale_library_content(state_m)\n            self.add_state_view_for_model(state_m.state_copy, state_v, hierarchy_level=hierarchy_level + 1)\n\n        elif isinstance(state_m, ContainerStateModel):\n            num_child_state = 0\n\n            for scoped_variable_m in state_m.scoped_variables:\n                state_v.add_scoped_variable(scoped_variable_m)\n\n            for child_state_m in state_m.states.values():\n                # generate optional meta data for child state - not used if valid meta data already in child state model\n                child_rel_pos, child_size = gui_helper_meta_data.generate_default_state_meta_data(state_m, self.canvas,\n                                                                                                  num_child_state)\n                num_child_state += 1\n\n                self.add_state_view_for_model(child_state_m, state_v, child_rel_pos, child_size, hierarchy_level + 1)\n\n            for transition_m in state_m.transitions:\n                self.add_transition_view_for_model(transition_m, state_m)\n\n            for data_flow_m in state_m.data_flows:\n                self.add_data_flow_view_for_model(data_flow_m, state_m)\n\n        return state_v", "response": "Adds a new state view for the given state model."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef add_transition_view_for_model(self, transition_m, parent_state_m):\n        parent_state_v = self.canvas.get_view_for_model(parent_state_m)\n\n        hierarchy_level = parent_state_v.hierarchy_level\n        transition_v = TransitionView(transition_m, hierarchy_level)\n\n        # Draw transition above all other state elements\n        self.canvas.add(transition_v, parent_state_v, index=None)\n\n        self._connect_transition_to_ports(transition_m, transition_v, parent_state_m, parent_state_v)\n\n        return transition_v", "response": "Creates a TransitionView from the given transition_m and adds it to the canvas."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef add_data_flow_view_for_model(self, data_flow_m, parent_state_m):\n        parent_state_v = self.canvas.get_view_for_model(parent_state_m)\n\n        hierarchy_level = parent_state_v.hierarchy_level\n        data_flow_v = DataFlowView(data_flow_m, hierarchy_level)\n\n        # Draw data flow above NameView but beneath all other state elements\n        self.canvas.add(data_flow_v, parent_state_v, index=1)\n        self._connect_data_flow_to_ports(data_flow_m, data_flow_v, parent_state_m)", "response": "Adds a data flow view to the canvas"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef react_to_event(self, event):\n        if not react_to_event(self.view, self.view.editor, event):\n            return False\n        if not rafcon.gui.singleton.state_machine_manager_model.selected_state_machine_id == \\\n                self.model.state_machine.state_machine_id:\n            return False\n        return True", "response": "Checks whether the given event should be handled by the state machine manager"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ninitialize the Lavalink node.", "response": "async def initialize(bot: Bot, host, password, rest_port, ws_port, timeout=30):\n    \"\"\"\n    Initializes the websocket connection to the lavalink player.\n\n    .. important::\n\n        This function must only be called AFTER the bot has received its\n        \"on_ready\" event!\n\n    Parameters\n    ----------\n    bot : Bot\n        An instance of a discord.py `Bot` object.\n    host : str\n        The hostname or IP address of the Lavalink node.\n    password : str\n        The password of the Lavalink node.\n    rest_port : int\n        The port of the REST API on the Lavalink node.\n    ws_port : int\n        The websocket port on the Lavalink Node.\n    timeout : int\n        Amount of time to allow retries to occur, ``None`` is considered forever.\n    \"\"\"\n    global _loop\n    _loop = bot.loop\n\n    player_manager.user_id = bot.user.id\n    player_manager.channel_finder_func = bot.get_channel\n    register_event_listener(_handle_event)\n    register_update_listener(_handle_update)\n\n    lavalink_node = node.Node(\n        _loop,\n        dispatch,\n        bot._connection._get_websocket,\n        host,\n        password,\n        port=ws_port,\n        rest=rest_port,\n        user_id=player_manager.user_id,\n        num_shards=bot.shard_count if bot.shard_count is not None else 1,\n    )\n\n    await lavalink_node.connect(timeout=timeout)\n\n    bot.add_listener(node.on_socket_response)\n    bot.add_listener(_on_guild_remove, name=\"on_guild_remove\")\n\n    return lavalink_node"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nconnecting to a discord voice channel.", "response": "async def connect(channel: discord.VoiceChannel):\n    \"\"\"\n    Connects to a discord voice channel.\n\n    This is the publicly exposed way to connect to a discord voice channel.\n    The :py:func:`initialize` function must be called first!\n\n    Parameters\n    ----------\n    channel\n\n    Returns\n    -------\n    Player\n        The created Player object.\n\n    Raises\n    ------\n    IndexError\n        If there are no available lavalink nodes ready to connect to discord.\n    \"\"\"\n    node_ = node.get_node(channel.guild.id)\n    p = await node_.player_manager.create_player(channel)\n    return p"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef register_event_listener(coro):\n    if not asyncio.iscoroutinefunction(coro):\n        raise TypeError(\"Function is not a coroutine.\")\n\n    if coro not in _event_listeners:\n        _event_listeners.append(coro)", "response": "Registers a coroutine function that will receive lavalink event information."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nregister a coroutine to receive lavalink player update information.", "response": "def register_update_listener(coro):\n    \"\"\"\n    Registers a coroutine to receive lavalink player update information.\n\n    This coroutine will accept a two arguments: an instance of :py:class:`Player`\n    and an instance of :py:class:`PlayerState`.\n\n    Parameters\n    ----------\n    coro\n\n    Raises\n    ------\n    TypeError\n        If ``coro`` is not a coroutine.\n    \"\"\"\n    if not asyncio.iscoroutinefunction(coro):\n        raise TypeError(\"Function is not a coroutine.\")\n\n    if coro not in _update_listeners:\n        _update_listeners.append(coro)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nregister a coroutine to receive lavalink server stats information.", "response": "def register_stats_listener(coro):\n    \"\"\"\n    Registers a coroutine to receive lavalink server stats information.\n\n    This coroutine will accept a single argument which will be an instance\n    of :py:class:`Stats`.\n\n    Parameters\n    ----------\n    coro\n\n    Raises\n    ------\n    TypeError\n        If ``coro`` is not a coroutine.\n    \"\"\"\n    if not asyncio.iscoroutinefunction(coro):\n        raise TypeError(\"Function is not a coroutine.\")\n\n    if coro not in _stats_listeners:\n        _stats_listeners.append(coro)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nremove all references to the current model and the current selection and clear the attribute cache.", "response": "def prepare_destruction(self):\n        \"\"\"Get rid of circular references\"\"\"\n        self._tool = None\n        self._painter = None\n        self.relieve_model(self._selection)\n        self._selection = None\n        # clear observer class attributes, also see ExtendenController.destroy()\n        self._Observer__PROP_TO_METHS.clear()\n        self._Observer__METH_TO_PROPS.clear()\n        self._Observer__PAT_TO_METHS.clear()\n        self._Observer__METH_TO_PAT.clear()\n        self._Observer__PAT_METH_TO_KWARGS.clear()"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nfinds item with port closest to specified position. List of items to be ignored can be specified with `exclude` parameter. Tuple is returned - found item - closest, connectable port - closest point on found port (in view coordinates) :Parameters: vpos Position specified in view coordinates. distance Max distance from point to a port (default 10) exclude Set of items to ignore.", "response": "def get_port_at_point(self, vpos, distance=10, exclude=None, exclude_port_fun=None):\n        \"\"\"\n        Find item with port closest to specified position.\n\n        List of items to be ignored can be specified with `exclude`\n        parameter.\n\n        Tuple is returned\n\n        - found item\n        - closest, connectable port\n        - closest point on found port (in view coordinates)\n\n        :Parameters:\n         vpos\n            Position specified in view coordinates.\n         distance\n            Max distance from point to a port (default 10)\n         exclude\n            Set of items to ignore.\n        \"\"\"\n        # Method had to be inherited, as the base method has a bug:\n        # It misses the statement max_dist = d\n        v2i = self.get_matrix_v2i\n        vx, vy = vpos\n\n        max_dist = distance\n        port = None\n        glue_pos = None\n        item = None\n\n        rect = (vx - distance, vy - distance, distance * 2, distance * 2)\n        items = self.get_items_in_rectangle(rect, reverse=True)\n        for i in items:\n            if exclude and i in exclude:\n                continue\n            for p in i.ports():\n                if not p.connectable:\n                    continue\n                if exclude_port_fun and exclude_port_fun(p):\n                    continue\n\n                ix, iy = v2i(i).transform_point(vx, vy)\n                pg, d = p.glue((ix, iy))\n                if d > max_dist:\n                    continue\n\n                max_dist = d\n                item = i\n                port = p\n\n                # transform coordinates from connectable item space to view\n                # space\n                i2v = self.get_matrix_i2v(i).transform_point\n                glue_pos = i2v(*pg)\n\n        return item, port, glue_pos"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the item at the given position.", "response": "def get_item_at_point_exclude(self, pos, selected=True, exclude=None):\n        \"\"\"\n        Return the topmost item located at ``pos`` (x, y).\n\n        Parameters:\n         - selected: if False returns first non-selected item\n         - exclude: if specified don't check for these items\n        \"\"\"\n        items = self._qtree.find_intersect((pos[0], pos[1], 1, 1))\n        for item in self._canvas.sort(items, reverse=True):\n            if not selected and item in self.selected_items:\n                continue  # skip selected items\n            if item in exclude:\n                continue\n\n            v2i = self.get_matrix_v2i(item)\n            ix, iy = v2i.transform_point(*pos)\n            if item.point((ix, iy)) < 0.5:\n                return item\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef queue_draw_item(self, *items):\n        gaphas_items = []\n        for item in items:\n            if isinstance(item, Element):\n                gaphas_items.append(item)\n            else:\n                try:\n                    gaphas_items.append(item.parent)\n                except AttributeError:\n                    pass\n        super(ExtendedGtkView, self).queue_draw_item(*gaphas_items)", "response": "Extends the base class method to allow Ports to be passed as item\n\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_items_at_point(self, pos, selected=True, distance=0):\n        items = self._qtree.find_intersect((pos[0] - distance, pos[1] - distance, 2 * distance, 2 * distance))\n        filtered_items = []\n        for item in self._canvas.sort(items, reverse=True):\n            if not selected and item in self.selected_items:\n                continue  # skip selected items\n\n            v2i = self.get_matrix_v2i(item)\n            i2v = self.get_matrix_i2v(item)\n            ix, iy = v2i.transform_point(*pos)\n            distance_i = item.point((ix, iy))\n            distance_v = i2v.transform_distance(distance_i, 0)[0]\n            if distance_v <= distance:\n                filtered_items.append(item)\n        return filtered_items", "response": "Return the items located at the given point."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nselect an item. This adds items to the set of selected items.", "response": "def select_item(self, items):\n        \"\"\" Select an items. This adds `items` to the set of selected items. \"\"\"\n        if not items:\n            return\n        elif not hasattr(items, \"__iter__\"):\n            items = (items,)\n        selection_changed = False\n        with self._suppress_selection_events():\n            for item in items:\n                self.queue_draw_item(item)\n                if item is not None and item.model not in self._selection:\n                    self._selection.add(item.model)\n                    selection_changed = True\n        if selection_changed:\n            self.emit('selection-changed', self._get_selected_items())"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nclear the selected_item also clears the focused_item.", "response": "def unselect_all(self):\n        \"\"\" Clearing the selected_item also clears the focused_item. \"\"\"\n        items = self._get_selected_items()\n        with self._suppress_selection_events():\n            self._selection.clear()\n        self.queue_draw_item(*items)\n        self.emit('selection-changed', self._get_selected_items())"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a set of items for each model in the current selection", "response": "def _get_selected_items(self):\n        \"\"\" Return an Item (e.g. StateView) for each model (e.g. StateModel) in the current selection \"\"\"\n        return set(self.canvas.get_view_for_model(model) for model in self._selection)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ndetermine the selection The selection is based on the previous selection, the currently pressed keys and the passes newly selected items :param items: The newly selected item(s)", "response": "def handle_new_selection(self, items):\n        \"\"\" Determines the selection\n\n        The selection is based on the previous selection, the currently pressed keys and the passes newly selected items\n\n        :param items: The newly selected item(s)\n        \"\"\"\n        if items is None:\n            items = ()\n        elif not hasattr(items, \"__iter__\"):\n            items = (items,)\n        models = set(item.model for item in items)\n        self._selection.handle_new_selection(models)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _get_focused_item(self):\n        focused_model = self._selection.focus\n        if not focused_model:\n            return None\n        return self.canvas.get_view_for_model(focused_model)", "response": "Returns the currently focused item"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _set_focused_item(self, item):\n        if not item:\n            return self._del_focused_item()\n\n        if item.model is not self._selection.focus:\n            self.queue_draw_item(self._focused_item, item)\n            self._selection.focus = item.model\n            self.emit('focus-changed', item)", "response": "Sets the focus to the passed item"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef log_to_raw_structure(execution_history_items):\n    previous = {}\n    next_ = {}\n    concurrent = {}\n    grouped_by_run_id = {}\n    start_item = None\n\n    for k,v in execution_history_items.items():\n        if v['item_type'] == 'StateMachineStartItem':\n            start_item = v\n        else:\n            # connect the item to its predecessor\n            prev_item_id = native_str(v['prev_history_item_id'])\n\n            if prev_item_id in execution_history_items:\n                ## should always be the case except if shelve is broken/missing data\n\n                previous[k] = prev_item_id\n                if execution_history_items[prev_item_id]['item_type'] == 'ConcurrencyItem' and \\\n                   execution_history_items[k]['item_type'] != 'ReturnItem':\n                    # this is not a return  item, thus this 'previous' relationship of this\n                    # item must be a call item of one of the concurrent branches of\n                    # the concurrency state\n                    if prev_item_id in concurrent:\n                        concurrent[prev_item_id].append(k)\n                    else:\n                        concurrent[prev_item_id] = [k]\n                else:\n                    # this is a logical 'next' relationship\n                    next_[prev_item_id] = k\n            else:\n                logger.warning('HistoryItem is referring to a non-existing previous history item, HistoryItem was %s' % str(v))\n\n        rid = v['run_id']\n        if rid in grouped_by_run_id:\n            grouped_by_run_id[rid].append(v)\n        else:\n            grouped_by_run_id[rid] = [v]\n\n    return start_item, previous, next_, concurrent, grouped_by_run_id", "response": "converts the history items in the simplest case\n    to the raw structure of the log file"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncollapsing structure means that all history items belonging to the same state execution are merged together into one object (e.g. CallItem and ReturnItem of an ExecutionState). This is based on the log structure in which all Items which belong together have the same run_id. The collapsed items hold input as well as output data (direct and scoped), and the outcome the state execution. :param dict execution_history_items: history items, in the simplest case directly the opened shelve log file :param bool throw_on_pickle_error: flag if an error is thrown if an object cannot be un-pickled :param bool include_erroneous_data_ports: flag if to include erroneous data ports :param bool full_next: flag to indicate if the next relationship has also to be created at the end of container states :return: start_item, the StateMachineStartItem of the log file next_, a dict mapping run_id --> run_id of the next executed state on the same hierarchy level concurrent, a dict mapping run_id --> []list of run_ids of the concurrent next executed states (if present) hierarchy, a dict mapping run_id --> run_id of the next executed state on the deeper hierarchy level (the start state within that HierarchyState) items, a dict mapping run_id --> collapsed representation of the execution of the state with that run_id :rtype: tuple", "response": "def log_to_collapsed_structure(execution_history_items, throw_on_pickle_error=True,\n                               include_erroneous_data_ports=False, full_next=False):\n    \"\"\"\n    Collapsed structure means that all history items belonging to the same state execution are\n    merged together into one object (e.g. CallItem and ReturnItem of an ExecutionState). This\n    is based on the log structure in which all Items which belong together have the same run_id.\n    The collapsed items hold input as well as output data (direct and scoped), and the outcome\n    the state execution.\n    :param dict execution_history_items: history items, in the simplest case\n           directly the opened shelve log file\n    :param bool throw_on_pickle_error: flag if an error is thrown if an object cannot be un-pickled\n    :param bool include_erroneous_data_ports: flag if to include erroneous data ports\n    :param bool full_next: flag to indicate if the next relationship has also to be created at the end\n           of container states\n    :return: start_item, the StateMachineStartItem of the log file\n             next_, a dict mapping run_id --> run_id of the next executed state on the same\n                    hierarchy level\n             concurrent, a dict mapping run_id --> []list of run_ids of the concurrent next\n                         executed states (if present)\n             hierarchy, a dict mapping run_id --> run_id of the next executed state on the\n                        deeper hierarchy level (the start state within that HierarchyState)\n             items, a dict mapping run_id --> collapsed representation of the execution of\n                    the state with that run_id\n    :rtype: tuple\n    \"\"\"\n\n    # for debugging purposes\n    # execution_history_items_dict = dict()\n    # for k, v in execution_history_items.items():\n    #     execution_history_items_dict[k] = v\n\n    start_item, previous, next_, concurrent, grouped = log_to_raw_structure(execution_history_items)\n\n    start_item = None\n    collapsed_next = {}\n    collapsed_concurrent ={}\n    collapsed_hierarchy = {}\n    collapsed_items = {}\n\n    # single state executions are not supported\n    if len(next_) == 0 or len(next_) == 1:\n        for rid, gitems in grouped.items():\n            if gitems[0]['item_type'] == 'StateMachineStartItem':\n                item = gitems[0]\n                execution_item = {}\n                ## add base properties will throw if not existing\n                for l in ['description', 'path_by_name', 'state_name', 'run_id', 'state_type',\n                          'path', 'timestamp', 'root_state_storage_id', 'state_machine_version',\n                          'used_rafcon_version', 'creation_time', 'last_update', 'os_environment']:\n                    try:\n                        execution_item[l] = item[l]\n                    except KeyError:\n                        logger.warning(\"Key {} not in history start item\".format(str(l)))\n\n                ## add extended properties (added in later rafcon versions),\n                ## will add default value if not existing instead\n                for l, default in [('semantic_data', {}),\n                                     ('is_library', None),\n                                     ('library_state_name', None),\n                                     ('library_name', None),\n                                     ('library_path', None)]:\n                    execution_item[l] = item.get(l, default)\n\n                start_item = execution_item\n        return start_item, collapsed_next, collapsed_concurrent, collapsed_hierarchy, collapsed_items\n\n    # build collapsed items\n    for rid, gitems in grouped.items():\n        if gitems[0]['item_type'] == 'StateMachineStartItem':\n            item = gitems[0]\n            execution_item = {}\n            ## add base properties will throw if not existing\n            for l in ['description', 'path_by_name', 'state_name', 'run_id', 'state_type',\n                      'path', 'timestamp', 'root_state_storage_id', 'state_machine_version',\n                      'used_rafcon_version', 'creation_time', 'last_update', 'os_environment']:\n                try:\n                    execution_item[l] = item[l]\n                except KeyError:\n                    logger.warning(\"Key {} not in history start item\".format(str(l)))\n\n            ## add extended properties (added in later rafcon versions),\n            ## will add default value if not existing instead\n            for l, default in [('semantic_data', {}),\n                                 ('is_library', None),\n                                 ('library_state_name', None),\n                                 ('library_name', None),\n                                 ('library_path', None)]:\n                execution_item[l] = item.get(l, default)\n\n            start_item = execution_item\n\n            collapsed_next[rid] = execution_history_items[next_[gitems[0]['history_item_id']]]['run_id']\n            collapsed_items[rid] = execution_item\n        elif gitems[0]['state_type'] == 'ExecutionState' or \\\n             gitems[0]['state_type'] == 'HierarchyState' or \\\n             gitems[0]['state_type'] == 'LibraryState' or \\\n             'Concurrency' in gitems[0]['state_type']:\n\n            # for item in gitems:\n            #     if item[\"description\"] is not None:\n            #         print(item[\"item_type\"], item[\"call_type\"], item[\"state_type\"], item[\"state_name\"])\n            #     print(item[\"description\"])\n\n            # select call and return items for this state\n            try:\n                call_item = gitems[[gitems[i]['item_type'] == 'CallItem' and \\\n                                    gitems[i]['call_type'] == 'EXECUTE' \\\n                                    for i in range(len(gitems))].index(True)]\n            except ValueError:\n                # fall back to container call, should only happen for root state\n                try:\n                    call_item = gitems[[gitems[i]['item_type'] == 'CallItem' and \\\n                                        gitems[i]['call_type'] == 'CONTAINER' \\\n                                        for i in range(len(gitems))].index(True)]\n                except ValueError:\n                    logger.warning('Could not find a CallItem in run_id group %s\\nThere will probably be log information missing on this execution branch!' % str(rid))\n                    ## create dummy returnitem with the properties referenced later in this code\n                    call_item = dict(description=None,\n                                     history_item_id=None,\n                                     path_by_name=None,\n                                     state_name=None,\n                                     run_id=None,\n                                     state_type=None,\n                                     path=None,\n                                     timestamp=None,\n                                     input_output_data={},\n                                     scoped_data={})\n\n            try:\n                return_item = gitems[[gitems[i]['item_type'] == 'ReturnItem' and \\\n                                      gitems[i]['call_type'] == 'EXECUTE' \\\n                                      for i in range(len(gitems))].index(True)]\n            except ValueError:\n                # fall back to container call, should only happen for root state\n                try:\n                    return_item = gitems[[gitems[i]['item_type'] == 'ReturnItem' and \\\n                                          gitems[i]['call_type'] == 'CONTAINER' \\\n                                          for i in range(len(gitems))].index(True)]\n                except ValueError:\n                    logger.warning('Could not find a ReturnItem in run_id group %s\\nThere will probably be log information missing on this execution branch!' % str(rid))\n                    ## create dummy returnitem with the properties referenced later in this code\n                    return_item = dict(history_item_id=None,\n                                       outcome_name=None,\n                                       outcome_id=None,\n                                       timestamp=None,\n                                       input_output_data={},\n                                       scoped_data={})\n\n            # next item (on same hierarchy level) is always after return item\n            if return_item['history_item_id'] in next_:\n                # no next relationship at the end of containers\n                if execution_history_items[next_[return_item['history_item_id']]]['state_type'] == 'HierarchyState' and execution_history_items[next_[return_item['history_item_id']]]['item_type'] == 'ReturnItem' and execution_history_items[next_[return_item['history_item_id']]]['call_type'] == 'CONTAINER':\n                    if full_next:\n                        collapsed_next[rid] = execution_history_items[next_[return_item['history_item_id']]]['run_id']\n                    else:\n                        pass\n                else:\n                    collapsed_next[rid] = execution_history_items[next_[return_item['history_item_id']]]['run_id']\n\n            # treat hierarchy level\n            if call_item['history_item_id'] in previous:\n                if execution_history_items[previous[call_item['history_item_id']]]['state_type'] == 'HierarchyState' and execution_history_items[previous[call_item['history_item_id']]]['item_type'] == 'CallItem':\n                    prev_rid = execution_history_items[previous[call_item['history_item_id']]]['run_id']\n                    collapsed_hierarchy[prev_rid] = rid\n\n                # treat concurrency level\n                if execution_history_items[previous[call_item['history_item_id']]]['item_type'] == 'ConcurrencyItem':\n                    prev_rid = execution_history_items[previous[call_item['history_item_id']]]['run_id']\n                    if prev_rid in collapsed_concurrent:\n                        collapsed_concurrent[prev_rid].append(rid)\n                    else:\n                        collapsed_concurrent[prev_rid] = [rid]\n\n            # assemble grouped item\n            execution_item = {}\n            ## add base properties will throw if not existing\n            for l in ['description', 'path_by_name', 'state_name', 'run_id', 'state_type', 'path']:\n                execution_item[l] = call_item[l]\n\n            ## add extended properties (added in later rafcon versions),\n            ## will add default value if not existing instead\n            for l, default in [('semantic_data', {}),\n                                 ('is_library', None),\n                                 ('library_state_name', None),\n                                 ('library_name', None),\n                                 ('library_path', None)]:\n                execution_item[l] = return_item.get(l, default)\n\n            for l in ['outcome_name', 'outcome_id']:\n                execution_item[l] = return_item[l]\n            for l in ['timestamp']:\n                execution_item[l+'_call'] = call_item[l]\n                execution_item[l+'_return'] = return_item[l]\n\n            def unpickle_data(data_dict):\n                r = dict()\n                # support backward compatibility\n                if isinstance(data_dict, string_types):  # formerly data dict was a json string\n                    r = json.loads(data_dict)\n                else:\n                    for k, v in data_dict.items():\n                        if not k.startswith('!'): # ! indicates storage error\n                            try:\n                                r[k] = pickle.loads(v)\n                            except Exception as e:\n                                if throw_on_pickle_error:\n                                    raise\n                                elif include_erroneous_data_ports:\n                                    r['!' + k] = (str(e), v)\n                                else:\n                                    pass # ignore\n                        elif include_erroneous_data_ports:\n                            r[k] = v\n\n                return r\n\n            execution_item['data_ins'] = unpickle_data(call_item['input_output_data'])\n            execution_item['data_outs'] = unpickle_data(return_item['input_output_data'])\n            execution_item['scoped_data_ins'] = unpickle_data(call_item['scoped_data'])\n            execution_item['scoped_data_outs'] = unpickle_data(return_item['scoped_data'])\n            execution_item['semantic_data'] = unpickle_data(execution_item['semantic_data'])\n\n            collapsed_items[rid] = execution_item\n\n    return start_item, collapsed_next, collapsed_concurrent, collapsed_hierarchy, collapsed_items"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a pandas. DataFrame containing all the data flow items in the execution history.", "response": "def log_to_DataFrame(execution_history_items, data_in_columns=[], data_out_columns=[], scoped_in_columns=[],\n                     scoped_out_columns=[], semantic_data_columns=[], throw_on_pickle_error=True):\n    \"\"\"\n    Returns all collapsed items in a table-like structure (pandas.DataFrame) with one row per executed \n    state and a set of properties resp. columns (e.g. state_name, outcome, run_id) for this state.\n    The data flow (data_in/out, scoped_data_in/out, semantic_data) is omitted from this table\n    representation by default, as the different states have different data in-/out-port, scoped_data-\n    ports and semantic_data defined. However, you can ask specific data-/scoped_data-ports and semantic\n    data to be exported as table column, given they are primitive-valued, by including the port / key\n    names in the *_selected-parameters. These table-columns will obviously only be well-defined for\n    states having this kind of port-name-/semantic-key and otherwise will contain a None-like value,\n    indicating missing data.\n\n    The available data per execution item (row in the table) can be printed using pandas.DataFrame.columns.\n    \"\"\"\n    try:\n        import pandas as pd\n    except ImportError:\n        raise ImportError(\"The Python package 'pandas' is required for log_to_DataFrame.\")\n\n    start, next_, concurrency, hierarchy, gitems = log_to_collapsed_structure(\n        execution_history_items, throw_on_pickle_error=throw_on_pickle_error)\n    gitems.pop(start['run_id'])\n    if len(gitems) == 0:\n        return pd.DataFrame()\n\n    # remove columns which are not generic over all states (basically the\n    # data flow stuff)\n    df_keys = list(list(gitems.values())[0].keys())\n    df_keys.remove('data_ins')\n    df_keys.remove('data_outs')\n    df_keys.remove('scoped_data_ins')\n    df_keys.remove('scoped_data_outs')\n    df_keys.remove('semantic_data')\n    df_keys.sort()\n\n    df_items = []\n\n    for rid, item in gitems.items():\n        row_data = [item[k] for k in df_keys]\n\n        for key, selected_columns in [('data_ins', data_in_columns),\n                                      ('data_outs', data_out_columns),\n                                      ('scoped_data_ins', scoped_in_columns),\n                                      ('scoped_data_outs', scoped_out_columns),\n                                      ('semantic_data', semantic_data_columns)]:\n            for column_key in selected_columns:\n                row_data.append(item[key].get(column_key, None))\n        df_items.append(row_data)\n\n    for key, selected_columns in [('data_ins', data_in_columns),\n                                  ('data_outs', data_out_columns),\n                                  ('scoped_data_ins', scoped_in_columns),\n                                  ('scoped_data_outs', scoped_out_columns),\n                                  ('semantic_data', semantic_data_columns)]:\n        df_keys.extend([key + '__' + s for s in selected_columns])\n    df = pd.DataFrame(df_items, columns=df_keys)\n    # convert epoch to datetime\n    df.timestamp_call = pd.to_datetime(df.timestamp_call, unit='s')\n    df.timestamp_return = pd.to_datetime(df.timestamp_return, unit='s')\n\n    # use call timestamp as index\n    df_timed = df.set_index(df.timestamp_call)\n    df_timed.sort_index(inplace=True)\n\n    return df_timed"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef log_to_ganttplot(execution_history_items):\n    import matplotlib.pyplot as plt\n    import matplotlib.dates as dates\n    import numpy as np\n\n    d = log_to_DataFrame(execution_history_items)\n\n    # de-duplicate states and make mapping from state to idx\n    unique_states, idx = np.unique(d.path_by_name, return_index=True)\n    ordered_unique_states = np.array(d.path_by_name)[np.sort(idx)]\n    name2idx = {k: i for i, k in enumerate(ordered_unique_states)}\n\n    calldate = dates.date2num(d.timestamp_call.dt.to_pydatetime())\n    returndate = dates.date2num(d.timestamp_return.dt.to_pydatetime())\n\n    state2color = {'HierarchyState': 'k',\n                   'ExecutionState': 'g',\n                   'BarrierConcurrencyState': 'y',\n                   'PreemptiveConcurrencyState': 'y'}\n\n    fig, ax = plt.subplots(1, 1)\n    ax.barh(bottom=[name2idx[k] for k in d.path_by_name], width=returndate-calldate,\n            left=calldate, align='center', color=[state2color[s] for s in d.state_type], lw=0.0)\n    plt.yticks(list(range(len(ordered_unique_states))), ordered_unique_states)", "response": "Example how to use the DataFrame representation\n   "}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nwrapping method for GLib. idle_add", "response": "def call_gui_callback(callback, *args, **kwargs):\n    \"\"\"Wrapper method for GLib.idle_add\n\n    This method is intended as replacement for idle_add. It wraps the method with a callback option. The advantage is\n    that this way, the call is blocking. The method return, when the callback method has been called and executed.\n\n    :param callback: The callback method, e.g. on_open_activate\n    :param args: The parameters to be passed to the callback method\n    \"\"\"\n    from future.utils import raise_\n    from threading import Condition\n    import sys\n    from rafcon.utils import log\n    global exception_info, result\n    from gi.repository import GLib\n    condition = Condition()\n    exception_info = None\n\n    @log.log_exceptions()\n    def fun():\n        \"\"\"Call callback and notify condition variable\n        \"\"\"\n        global exception_info, result\n        result = None\n        try:\n            result = callback(*args)\n        except:\n            # Exception within this asynchronously called function won't reach pytest. This is why we have to store\n            # the information about the exception to re-raise it at the end of the synchronous call.\n            exception_info = sys.exc_info()\n        finally:  # Finally is also executed in the case of exceptions\n            condition.acquire()\n            condition.notify()\n            condition.release()\n\n    if \"priority\" in kwargs:\n        priority = kwargs[\"priority\"]\n    else:\n        priority = GLib.PRIORITY_LOW\n\n    condition.acquire()\n    GLib.idle_add(fun, priority=priority)\n    # Wait for the condition to be notified\n    # TODO: implement timeout that raises an exception\n    condition.wait()\n    condition.release()\n    if exception_info:\n        e_type, e_value, e_traceback = exception_info\n        raise_(e_type, e_value, e_traceback)\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef create_tab_header_label(tab_name, icons):\n    tooltip_event_box = Gtk.EventBox()\n    tooltip_event_box.set_tooltip_text(tab_name)\n    tab_label = Gtk.Label()\n    if global_gui_config.get_config_value('USE_ICONS_AS_TAB_LABELS', True):\n        tab_label.set_markup('<span font_desc=\"%s %s\">&#x%s;</span>' %\n                            (constants.ICON_FONT,\n                            constants.FONT_SIZE_BIG,\n                            icons[tab_name]))\n    else:\n        tab_label.set_text(get_widget_title(tab_name))\n        tab_label.set_angle(90)\n    tab_label.show()\n    tooltip_event_box.add(tab_label)\n    tooltip_event_box.set_visible_window(False)\n    tooltip_event_box.show()\n    return tooltip_event_box", "response": "Create the tab header label for notebook tabs."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef create_button_label(icon, font_size=constants.FONT_SIZE_NORMAL):\n    label = Gtk.Label()\n    set_label_markup(label, '&#x' + icon + ';', constants.ICON_FONT, font_size)\n    label.show()\n    return label", "response": "Create a button label with a chosen icon."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ntransforms Notebook tab label to title by replacing underscores with white spaces and capitalizing the first letter of each word.", "response": "def get_widget_title(tab_label_text):\n    \"\"\"Transform Notebook tab label to title by replacing underscores with white spaces and capitalizing the first\n    letter of each word.\n\n    :param tab_label_text: The string of the tab label to be transformed\n    :return: The transformed title as a string\n    \"\"\"\n    title = ''\n    title_list = tab_label_text.split('_')\n    for word in title_list:\n        title += word.upper() + ' '\n    title.strip()\n    return title"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set_notebook_title(notebook, page_num, title_label):\n    text = get_notebook_tab_title(notebook, page_num)\n    set_label_markup(title_label, text, constants.INTERFACE_FONT, constants.FONT_SIZE_BIG, constants.LETTER_SPACING_1PT)\n    return text", "response": "Set the title of a GTK notebook to one of its tab s titles."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef create_menu_box_with_icon_and_label(label_text):\n    box = Gtk.Box.new(Gtk.Orientation.HORIZONTAL, 10)\n    box.set_border_width(0)\n    icon_label = Gtk.Label()\n    text_label = Gtk.AccelLabel.new(label_text)\n    text_label.set_xalign(0)\n\n    box.pack_start(icon_label, False, False, 0)\n    box.pack_start(text_label, True, True, 0)\n    return box, icon_label, text_label", "response": "Creates a MenuItem box with icon and label."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef set_window_size_and_position(window, window_key):\n    size = global_runtime_config.get_config_value(window_key + '_WINDOW_SIZE')\n    position = global_runtime_config.get_config_value(window_key + '_WINDOW_POS')\n    maximized = global_runtime_config.get_config_value(window_key + '_WINDOW_MAXIMIZED')\n\n    # un-maximize here on purpose otherwise resize and reposition fails\n    if not maximized:\n        window.unmaximize()\n\n    if not size:\n        size = constants.WINDOW_SIZE[window_key + '_WINDOW']\n    window.resize(*size)\n    if position:\n        position = (max(0, position[0]), max(0, position[1]))\n        screen_width = Gdk.Screen.width()\n        screen_height = Gdk.Screen.height()\n        if position[0] < screen_width and position[1] < screen_height:\n            window.move(*position)\n    else:\n        window.set_position(Gtk.WindowPosition.MOUSE)\n    if maximized:\n        window.maximize()\n    window.show()", "response": "Adjust GTK Window s size and position according to the corresponding values in the runtime_config file."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncheck whether the widget is supposed to react to the event.", "response": "def react_to_event(view, widget, event):\n    \"\"\"Checks whether the widget is supposed to react to passed event\n\n    The function is intended for callback methods registering to shortcut actions. As several widgets can register to\n    the same shortcut, only the one having the focus should react to it.\n\n    :param gtkmvc3.View view: The view in which the widget is registered\n    :param Gtk.Widget widget: The widget that subscribed to the shortcut action, should be the top widget of the view\n    :param event: The event that caused the callback\n    :return: Whether the widget is supposed to react to the event or not\n    :rtype: bool\n    \"\"\"\n    # See\n    # http://pyGtk.org/pygtk2reference/class-gtkwidget.html#method-gtkwidget--is-focus and\n    # http://pyGtk.org/pygtk2reference/class-gtkwidget.html#method-gtkwidget--has-focus\n    # for detailed information about the difference between is_focus() and has_focus()\n    if not view:  # view needs to be initialized\n        return False\n    # widget parameter must be set and a Gtk.Widget\n    if not isinstance(widget, Gtk.Widget):\n        return False\n    # Either the widget itself or one of its children must be the focus widget within their toplevel\n    child_is_focus = False if not isinstance(widget, Gtk.Container) else bool(widget.get_focus_child())\n    if not child_is_focus and not widget.is_focus():\n        return False\n\n    def has_focus(widget):\n        \"\"\"Checks whether `widget` or one of its children ``has_focus()`` is ``True``\n\n        :param Gtk.Widget widget: The widget to be checked\n        :return: If any (child) widget has the global input focus\n        \"\"\"\n        if widget.has_focus():\n            return True\n        if not isinstance(widget, Gtk.Container):\n            return False\n        return any(has_focus(child) for child in widget.get_children())\n    # Either, for any of widget or its children, has_focus must be True, in this case the widget has the global focus.\n    if has_focus(widget):\n        return True\n    # Or the callback was not triggered by a shortcut, but e.g. a mouse click or a call from a test.\n    # If the callback was triggered by a shortcut action, the event has at least a length of two and the second\n    # element is a Gdk.ModifierType\n    if len(event) < 2 or (len(event) >= 2 and not isinstance(event[1], Gdk.ModifierType)):\n        return True\n    return False"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nchecking if the event is of right type", "response": "def is_event_of_key_string(event, key_string):\n    \"\"\"Condition check if key string represent the key value of handed event and whether the event is of right type\n\n    The function checks for constructed event tuple that are generated by the rafcon.gui.shortcut_manager.ShortcutManager.\n    :param tuple event: Event tuple generated by the ShortcutManager\n    :param str key_string: Key string parsed to a key value and for condition check\n    \"\"\"\n    return len(event) >= 2 and not isinstance(event[1], Gdk.ModifierType) and event[0] == Gtk.accelerator_parse(key_string)[0]"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncalls when the View was registered", "response": "def register_view(self, view):\n        \"\"\"Called when the View was registered\"\"\"\n        super(TopToolBarController, self).register_view(view)\n        view['maximize_button'].connect('clicked', self.on_maximize_button_clicked)\n        self.update_maximize_button()"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncalls when the View was registered", "response": "def register_view(self, view):\n        \"\"\"Called when the View was registered\"\"\"\n        super(TopToolBarUndockedWindowController, self).register_view(view)\n        view['redock_button'].connect('clicked', self.on_redock_button_clicked)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef register_view(self, view):\n        super(SingleWidgetWindowController, self).register_view(view)\n        self.shortcut_manager = ShortcutManager(self.view['main_window'])\n        self.register_actions(self.shortcut_manager)\n\n        view['main_window'].connect('destroy', Gtk.main_quit)", "response": "Called when the View was registered"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef remove_outcome(self, outcome_id, force=False, destroy=True):\n        if force:\n            return State.remove_outcome(self, outcome_id, force, destroy)\n        else:\n            raise NotImplementedError(\"Remove outcome is not implemented for library state {}\".format(self))", "response": "Overwrites the remove_outcome method of the State class. Removes the outcome from the library state."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef remove_output_data_port(self, data_port_id, force=False, destroy=True):\n        if force:\n            return State.remove_output_data_port(self, data_port_id, force, destroy)\n        else:\n            raise NotImplementedError(\"Remove output data port is not implemented for library state {}\".format(self))", "response": "Overwrites the remove_output_data_port method of the State class to allow the user to remove an output data port from the library state."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncalculate the library hierarchy depth of the current library state.", "response": "def library_hierarchy_depth(self):\n        \"\"\" Calculates the library hierarchy depth\n\n        Counting starts at the current library state. So if the there is no upper library state the depth is one.\n        \n        :return: library hierarchy depth\n        :rtype: int\n        \"\"\"\n        current_library_hierarchy_depth = 1\n        library_root_state = self.get_next_upper_library_root_state()\n        while library_root_state is not None:\n            current_library_hierarchy_depth += 1\n            library_root_state = library_root_state.parent.get_next_upper_library_root_state()\n        return current_library_hierarchy_depth"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef load(self, config_file=None, path=None):\n        if config_file is None:\n            if path is None:\n                path, config_file = split(resource_filename(__name__, CONFIG_FILE))\n            else:\n                config_file = CONFIG_FILE\n        super(Config, self).load(config_file, path)", "response": "Loads the configuration from a specific file"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncall when the view was registered", "response": "def register_view(self, view):\n        \"\"\"Called when the View was registered\n\n        Can be used e.g. to connect signals. Here, the destroy signal is connected to close the application\n        \"\"\"\n        super(StateEditorController, self).register_view(view)\n        view.prepare_the_labels()  # the preparation of the labels is done here to take into account plugin hook changes\n        view['add_input_port_button'].connect('clicked', self.inputs_ctrl.on_add)\n        view['add_output_port_button'].connect('clicked', self.outputs_ctrl.on_add)\n        if isinstance(self.model, ContainerStateModel):\n            view['add_scoped_variable_button'].connect('clicked', self.scopes_ctrl.on_add)\n\n        view['remove_input_port_button'].connect('clicked', self.inputs_ctrl.on_remove)\n        view['remove_output_port_button'].connect('clicked', self.outputs_ctrl.on_remove)\n        if isinstance(self.model, ContainerStateModel):\n            view['remove_scoped_variable_button'].connect('clicked', self.scopes_ctrl.on_remove)\n\n        if isinstance(self.model, LibraryStateModel) or self.model.state.get_next_upper_library_root_state():\n            view['add_input_port_button'].set_sensitive(False)\n            view['remove_input_port_button'].set_sensitive(False)\n            view['add_output_port_button'].set_sensitive(False)\n            view['remove_output_port_button'].set_sensitive(False)\n            view['add_scoped_variable_button'].set_sensitive(False)\n            view['remove_scoped_variable_button'].set_sensitive(False)\n\n        view.inputs_view.show()\n        view.outputs_view.show()\n        view.scopes_view.show()\n        view.outcomes_view.show()\n        view.transitions_view.show()\n        view.data_flows_view.show()\n\n        # show scoped variables if show content is enabled -> if disabled the tab stays and indicates a container state\n        if isinstance(self.model, LibraryStateModel) and not self.model.show_content():\n            view.scopes_view.hide()\n            view.linkage_overview.scope_view.hide()\n\n        # Container states do not have a source editor and library states does not show there source code\n        # Thus, for those states we do not have to add the source controller and can hide the source code tab\n        # logger.info(\"init state: {0}\".format(model))\n        lib_with_and_ES_as_root = isinstance(self.model, LibraryStateModel) and \\\n                                  not isinstance(self.model.state_copy, ContainerStateModel)\n        if not isinstance(self.model, ContainerStateModel) and not isinstance(self.model, LibraryStateModel) or \\\n                lib_with_and_ES_as_root:\n            view.source_view.show()\n            if isinstance(self.model, LibraryStateModel) and not self.model.show_content():\n                view.remove_source_tab()\n            view.remove_scoped_variables_tab()\n        else:\n            view.scopes_view.show()\n            if isinstance(self.model, LibraryStateModel) and \\\n                    (not self.model.show_content() or not isinstance(self.model.state_copy, ContainerStateModel)):\n                view.remove_scoped_variables_tab()\n            view.remove_source_tab()\n\n        if global_gui_config.get_config_value(\"SEMANTIC_DATA_MODE\", False):\n            view.bring_tab_to_the_top('Semantic Data')\n        else:\n            if isinstance(self.model.state, LibraryState):\n                view.bring_tab_to_the_top('Description')\n            else:\n                view.bring_tab_to_the_top('Linkage Overview')\n\n        if isinstance(self.model, ContainerStateModel):\n            self.scopes_ctrl.reload_scoped_variables_list_store()\n\n        plugins.run_hook(\"post_state_editor_register_view\", self)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef state_type_changed(self, model, prop_name, info):\n        msg = info['arg']\n        # print(self.__class__.__name__, \"state_type_changed check\", info)\n        if msg.action in ['change_state_type', 'change_root_state_type'] and msg.after:\n            # print(self.__class__.__name__, \"state_type_changed\")\n            import rafcon.gui.singleton as gui_singletons\n            msg = info['arg']\n            new_state_m = msg.affected_models[-1]\n            states_editor_ctrl = gui_singletons.main_window_controller.get_controller('states_editor_ctrl')\n            states_editor_ctrl.recreate_state_editor(self.model, new_state_m)", "response": "Reopen state editor when state type is changed"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef state_destruction(self, model, prop_name, info):\n        import rafcon.gui.singleton as gui_singletons\n        states_editor_ctrl = gui_singletons.main_window_controller.get_controller('states_editor_ctrl')\n        state_identifier = states_editor_ctrl.get_state_identifier(self.model)\n        states_editor_ctrl.close_page(state_identifier, delete=True)", "response": "Close state editor when state is being destructed"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nprepare the model for destruction", "response": "def prepare_destruction(self):\n        \"\"\"Prepares the model for destruction\n\n        Unregister itself as observer from the state machine and the root state\n        \"\"\"\n        if self.state_machine is None:\n            logger.verbose(\"Multiple calls of prepare destruction for {0}\".format(self))\n        self.destruction_signal.emit()\n        if self.history is not None:\n            self.history.prepare_destruction()\n        if self.auto_backup is not None:\n            self.auto_backup.prepare_destruction()\n        try:\n            self.unregister_observer(self)\n            self.root_state.unregister_observer(self)\n        except KeyError:  # Might happen if the observer was already unregistered\n            pass\n        with self.state_machine.modification_lock():\n            self.root_state.prepare_destruction()\n        self.root_state = None\n        self.state_machine = None\n        super(StateMachineModel, self).prepare_destruction()"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncalls when a state machine action was triggered.", "response": "def action_signal_triggered(self, model, prop_name, info):\n        \"\"\"When the action was performed, we have to set the dirty flag, as the changes are unsaved\"\"\"\n        # print(\"ACTION_signal_triggered state machine: \", model, prop_name, info)\n        self.state_machine.marked_dirty = True\n        msg = info.arg\n        if model is not self and msg.action.startswith('sm_notification_'):  # Signal was caused by the root state\n            # Emit state_action_signal to inform observing controllers about changes made to the state within the\n            # state machine\n            # print(\"DONE1 S\", self.state_machine.state_machine_id, msg, model)\n            # -> removes mark of \"sm_notification_\"-prepend to mark root-state msg forwarded to state machine label\n            msg = msg._replace(action=msg.action.replace('sm_notification_', '', 1))\n            self.state_action_signal.emit(msg)\n            # print(\"FINISH DONE1 S\", self.state_machine.state_machine_id, msg)\n        else:\n            # print(\"DONE2 S\", self.state_machine.state_machine_id, msg)\n            pass"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the StateModel for the given path.", "response": "def get_state_model_by_path(self, path):\n        \"\"\"Returns the `StateModel` for the given `path` \n        \n        Searches a `StateModel` in the state machine, who's path is given by `path`.\n        \n        :param str path: Path of the searched state \n        :return: The state with that path\n        :rtype: StateModel\n        :raises: ValueError, if path is invalid/not existing with this state machine  \n        \"\"\"\n        path_elements = path.split('/')\n        path_elements.pop(0)\n        current_state_model = self.root_state\n        for state_id in path_elements:\n            if isinstance(current_state_model, ContainerStateModel):\n                if state_id in current_state_model.states:\n                    current_state_model = current_state_model.states[state_id]\n                else:\n                    raise ValueError(\"Invalid path: State with id '{}' not found in state with id {}\".format(\n                        state_id, current_state_model.state.state_id))\n            elif isinstance(current_state_model, LibraryStateModel):\n                if state_id == current_state_model.state_copy.state.state_id:\n                    current_state_model = current_state_model.state_copy\n                else:\n                    raise ValueError(\"Invalid path: state id '{}' does not coincide with state id '{}' of state_copy \"\n                                     \"of library state with id '{}'\".format(\n                                        state_id, current_state_model.state_copy.state.state_id,\n                                        current_state_model.state.state_id))\n            else:\n                raise ValueError(\"Invalid path: State with id '{}' has no children\".format(\n                    current_state_model.state.state_id))\n        return current_state_model"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef load_meta_data(self, path=None, recursively=True):\n        meta_data_path = path if path is not None else self.state_machine.file_system_path\n\n        if meta_data_path:\n            path_meta_data = os.path.join(meta_data_path, storage.FILE_NAME_META_DATA)\n\n            try:\n                tmp_meta = storage.load_data_file(path_meta_data)\n            except ValueError:\n                tmp_meta = {}\n        else:\n            tmp_meta = {}\n\n        # JSON returns a dict, which must be converted to a Vividict\n        tmp_meta = Vividict(tmp_meta)\n\n        if recursively:\n            root_state_path = None if not path else os.path.join(path, self.root_state.state.state_id)\n            self.root_state.load_meta_data(root_state_path)\n\n        if tmp_meta:\n            # assign the meta data to the state\n            self.meta = tmp_meta\n            self.meta_signal.emit(MetaSignalMsg(\"load_meta_data\", \"all\", True))", "response": "Loads the meta data of the state machine model from the file system."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef store_meta_data(self, copy_path=None):\n        if copy_path:\n            meta_file_json = os.path.join(copy_path, storage.FILE_NAME_META_DATA)\n        else:\n            meta_file_json = os.path.join(self.state_machine.file_system_path, storage.FILE_NAME_META_DATA)\n\n        storage_utils.write_dict_to_json(self.meta, meta_file_json)\n\n        self.root_state.store_meta_data(copy_path)", "response": "Save the meta data of the state machine model to the file system"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef convert_trees(self, ptb_trees, representation='basic', universal=True,\n                      include_punct=True, include_erased=False, **kwargs):\n        \"\"\"Convert a list of Penn Treebank formatted strings (ptb_trees)\n        into Stanford Dependencies. The dependencies are represented\n        as a list of sentences (CoNLL.Corpus), where each sentence\n        (CoNLL.Sentence) is itself a list of CoNLL.Token objects.\n\n        Currently supported representations are 'basic', 'collapsed',\n        'CCprocessed', and 'collapsedTree' which behave the same as they\n        in the CoreNLP command line tools. (note that in the online\n        CoreNLP demo, 'collapsed' is called 'enhanced')\n\n        Additional arguments: universal (if True, use universal\n        dependencies if they're available), include_punct (if False,\n        punctuation tokens will not be included), and include_erased\n        (if False and your representation might erase tokens, those\n        tokens will be omitted from the output).\n\n        See documentation on your backend to see if it supports\n        further options.\"\"\"\n        kwargs.update(representation=representation, universal=universal,\n                      include_punct=include_punct,\n                      include_erased=include_erased)\n        return Corpus(self.convert_tree(ptb_tree, **kwargs)\n                      for ptb_tree in ptb_trees)", "response": "Convert a list of Penn Treebank formatted strings into Stanford Dependencies."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef setup_and_get_default_path(self, jar_base_filename):\n        import os\n        import errno\n        install_dir = os.path.expanduser(INSTALL_DIR)\n        try:\n            os.makedirs(install_dir)\n        except OSError as ose:\n            if ose.errno != errno.EEXIST:\n                raise ose\n        jar_filename = os.path.join(install_dir, jar_base_filename)\n        return jar_filename", "response": "Setup the user - specific install path for the Stanford\n        Dependencies jar if the jar_url is not specified and ensure that the directory exists and return the full path for the jar file."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ndownloading the jar for version into the jar_filename specified by the constructor. Will not overwrite jar_filename if it already exists.", "response": "def download_if_missing(self, version=None, verbose=True):\n        \"\"\"Download the jar for version into the jar_filename specified\n        in the constructor. Will not overwrite jar_filename if it already\n        exists. version defaults to DEFAULT_CORENLP_VERSION (ideally the\n        latest but we can't guarantee that since PyStanfordDependencies\n        is distributed separately).\"\"\"\n        if os.path.exists(self.jar_filename):\n            return\n\n        jar_url = self.get_jar_url(version)\n        if verbose:\n            print(\"Downloading %r -> %r\" % (jar_url, self.jar_filename))\n        opener = ErrorAwareURLOpener()\n        opener.retrieve(jar_url, filename=self.jar_filename)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nensures that the given representation is a known Stanford Dependency representation.", "response": "def _raise_on_bad_representation(representation):\n        \"\"\"Ensure that representation is a known Stanford Dependency\n        representation (raises a ValueError if the representation is\n        invalid).\"\"\"\n        if representation not in REPRESENTATIONS:\n            repr_desc = ', '.join(map(repr, REPRESENTATIONS))\n            raise ValueError(\"Unknown representation: %r (should be one \"\n                             \"of %s)\" % (representation, repr_desc))"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nensures that jar_filename is a valid path to a jar file.", "response": "def _raise_on_bad_jar_filename(jar_filename):\n        \"\"\"Ensure that jar_filename is a valid path to a jar file.\"\"\"\n        if jar_filename is None:\n            return\n\n        if not isinstance(jar_filename, string_type):\n            raise TypeError(\"jar_filename is not a string: %r\" % jar_filename)\n\n        if not os.path.exists(jar_filename):\n            raise ValueError(\"jar_filename does not exist: %r\" % jar_filename)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the URL to a Stanford CoreNLP jar file with a specific version.", "response": "def get_jar_url(version=None):\n        \"\"\"Get the URL to a Stanford CoreNLP jar file with a specific\n        version. These jars come from Maven since the Maven version is\n        smaller than the full CoreNLP distributions. Defaults to\n        DEFAULT_CORENLP_VERSION.\"\"\"\n        if version is None:\n            version = DEFAULT_CORENLP_VERSION\n\n        try:\n            string_type = basestring\n        except NameError:\n            string_type = str\n\n        if not isinstance(version, string_type):\n            raise TypeError(\"Version must be a string or None (got %r).\" %\n                            version)\n        jar_filename = 'stanford-corenlp-%s.jar' % version\n        return 'http://search.maven.org/remotecontent?filepath=' + \\\n               'edu/stanford/nlp/stanford-corenlp/%s/%s' % (version,\n                                                            jar_filename)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef convert_tree(self, ptb_tree, representation='basic',\n                     include_punct=True, include_erased=False,\n                     add_lemmas=False, universal=True):\n        \"\"\"Arguments are as in StanfordDependencies.convert_trees but with\n        the addition of add_lemmas. If add_lemmas=True, we will run the\n        Stanford CoreNLP lemmatizer and fill in the lemma field.\"\"\"\n        self._raise_on_bad_input(ptb_tree)\n        self._raise_on_bad_representation(representation)\n        tree = self.treeReader(ptb_tree)\n        if tree is None:\n            raise ValueError(\"Invalid Penn Treebank tree: %r\" % ptb_tree)\n        deps = self._get_deps(tree, include_punct, representation,\n                              universal=universal)\n\n        tagged_yield = self._listify(tree.taggedYield())\n        indices_to_words = dict(enumerate(tagged_yield, 1))\n        sentence = Sentence()\n        covered_indices = set()\n\n        def add_token(index, form, head, deprel, extra):\n            tag = indices_to_words[index].tag()\n            if add_lemmas:\n                lemma = self.stem(form, tag)\n            else:\n                lemma = None\n            token = Token(index=index, form=form, lemma=lemma, cpos=tag,\n                          pos=tag, feats=None, head=head, deprel=deprel,\n                          phead=None, pdeprel=None, extra=extra)\n            sentence.append(token)\n\n        # add token for each dependency\n        for dep in deps:\n            index = dep.dep().index()\n            head = dep.gov().index()\n            deprel = dep.reln().toString()\n            form = indices_to_words[index].value()\n\n            dep_is_copy = dep.dep().copyCount()\n            gov_is_copy = dep.gov().copyCount()\n            if dep_is_copy or gov_is_copy:\n                extra = {}\n                if dep_is_copy:\n                    extra['dep_is_copy'] = dep_is_copy\n                if gov_is_copy:\n                    extra['gov_is_copy'] = gov_is_copy\n            else:\n                extra = None\n            add_token(index, form, head, deprel, extra)\n            covered_indices.add(index)\n        if include_erased:\n            # see if there are any tokens that were erased\n            # and add them as well\n            all_indices = set(indices_to_words.keys())\n            for index in all_indices - covered_indices:\n                form = indices_to_words[index].value()\n                if not include_punct and not self.puncFilter(form):\n                    continue\n                add_token(index, form, head=0, deprel='erased', extra=None)\n            # erased generally disrupt the ordering of the sentence\n            sentence.sort()\n\n        if representation == 'basic':\n            sentence.renumber()\n        return sentence", "response": "Converts a Penn Treebank tree into a Stanford Information object."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the stem of word with specific form and part - of - speech tag according to the Stanford lemmatizer. Lemmas are cached if necessary.", "response": "def stem(self, form, tag):\n        \"\"\"Returns the stem of word with specific form and part-of-speech\n        tag according to the Stanford lemmatizer. Lemmas are cached.\"\"\"\n        key = (form, tag)\n        if key not in self.lemma_cache:\n            lemma = self.stemmer(*key).word()\n            self.lemma_cache[key] = lemma\n        return self.lemma_cache[key]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _get_deps(self, tree, include_punct, representation, universal):\n        if universal:\n            converter = self.universal_converter\n\n            if self.universal_converter == self.converter:\n                import warnings\n                warnings.warn(\"This jar doesn't support universal \"\n                              \"dependencies, falling back to Stanford \"\n                              \"Dependencies. To suppress this message, \"\n                              \"call with universal=False\")\n        else:\n            converter = self.converter\n\n        if include_punct:\n            egs = converter(tree, self.acceptFilter)\n        else:\n            egs = converter(tree)\n\n        if representation == 'basic':\n            deps = egs.typedDependencies()\n        elif representation == 'collapsed':\n            deps = egs.typedDependenciesCollapsed(True)\n        elif representation == 'CCprocessed':\n            deps = egs.typedDependenciesCCprocessed(True)\n        else:\n            # _raise_on_bad_representation should ensure that this\n            # assertion doesn't fail\n            assert representation == 'collapsedTree'\n            deps = egs.typedDependenciesCollapsedTree()\n        return self._listify(deps)", "response": "Get a list of dependencies from a Stanford Tree for a specific Universal Dependencies representation."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nrepresenting this Token as a string in CoNLL - X format.", "response": "def as_conll(self):\n        \"\"\"Represent this Token as a line as a string in CoNLL-X format.\"\"\"\n        def get(field):\n            value = getattr(self, field)\n            if value is None:\n                value = '_'\n            elif field == 'feats':\n                value = '|'.join(value)\n            return str(value)\n        return '\\t'.join([get(field) for field in FIELD_NAMES])"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nconstruct a Token from a line in CoNLL - X format.", "response": "def from_conll(this_class, text):\n        \"\"\"Construct a Token from a line in CoNLL-X format.\"\"\"\n        fields = text.split('\\t')\n        fields[0] = int(fields[0]) # index\n        fields[6] = int(fields[6]) # head index\n        if fields[5] != '_': # feats\n            fields[5] = tuple(fields[5].split('|'))\n        fields = [value if value != '_' else None for value in fields]\n        fields.append(None) # for extra\n        return this_class(**dict(zip(FIELD_NAMES_PLUS, fields)))"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nrepresents this Sentence as an ASCII tree string. Requires a str_func which should take a single Token and return a string.", "response": "def as_asciitree(self, str_func=None):\n        \"\"\"Represent this Sentence as an ASCII tree string. Requires\n        the asciitree package. A default token stringifier is provided\n        but for custom formatting, specify a str_func which should take\n        a single Token and return a string.\"\"\"\n        import asciitree\n        from collections import defaultdict\n        children = defaultdict(list)\n        # since erased nodes may be missing, multiple tokens may have same\n        # index (CCprocessed), etc.\n        token_to_index = {}\n        roots = []\n        for token in self:\n            children[token.head].append(token)\n            token_to_index[token] = token.index\n            if token.head == 0:\n                roots.append(token)\n        assert roots, \"Couldn't find root Token(s)\"\n\n        if len(roots) > 1:\n            # multiple roots so we make a fake one to be their parent\n            root = Token(0, 'ROOT', 'ROOT-LEMMA', 'ROOT-CPOS', 'ROOT-POS',\n                         None, None, 'ROOT-DEPREL', None, None, None)\n            token_to_index[root] = 0\n            children[0] = roots\n        else:\n            root = roots[0]\n\n        def child_func(token):\n            index = token_to_index[token]\n            return children[index]\n        if not str_func:\n            def str_func(token):\n                return ' %s [%s]' % (token.form, token.deprel)\n\n        return asciitree.draw_tree(root, child_func, str_func)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning this sentence as a graphviz. Digraph.", "response": "def as_dotgraph(self, digraph_kwargs=None, id_prefix=None,\n                    node_formatter=None, edge_formatter=None):\n        \"\"\"Returns this sentence as a graphviz.Digraph. Requires the\n        graphviz Python package and graphviz itself. There are several\n        ways to customize. Graph level keyword arguments can be passed\n        as a dictionary to digraph_kwargs. If you're viewing multiple\n        Sentences in the same graph, you'll need to set a unique prefix\n        string in id_prefix. Lastly, you can change the formatting of\n        nodes and edges with node_formatter and edge_formatter. Both\n        take a single Token as an argument (for edge_formatter, the\n        Token represents the child token) and return a dictionary of\n        keyword arguments which are passed to the node and edge creation\n        functions in graphviz. The node_formatter will also be called\n        with None as its token when adding the root.\"\"\"\n        digraph_kwargs = digraph_kwargs or {}\n        id_prefix = id_prefix or ''\n\n        node_formatter = node_formatter or (lambda token: {})\n        edge_formatter = edge_formatter or (lambda token: {})\n\n        import graphviz\n        graph = graphviz.Digraph(**digraph_kwargs)\n        # add root node\n        graph.node(id_prefix + '0', 'root', **node_formatter(None))\n\n        # add remaining nodes and edges\n        already_added = set()\n        for token in self:\n            token_id = id_prefix + str(token.index)\n            parent_id = id_prefix + str(token.head)\n            if token_id not in already_added:\n                graph.node(token_id, token.form, **node_formatter(token))\n            graph.edge(parent_id, token_id, label=token.deprel,\n                       **edge_formatter(token))\n            already_added.add(token_id)\n        return graph"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nconstructing a Sentence. stream is an iterable over strings where each string is a line in CoNLL - X format.", "response": "def from_conll(this_class, stream):\n        \"\"\"Construct a Sentence. stream is an iterable over strings where\n        each string is a line in CoNLL-X format. If there are multiple\n        sentences in this stream, we only return the first one.\"\"\"\n        stream = iter(stream)\n        sentence = this_class()\n        for line in stream:\n            line = line.strip()\n            if line:\n                sentence.append(Token.from_conll(line))\n            elif sentence:\n                return sentence\n        return sentence"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nconstructs a Sentence from a Stanford Dependency file.", "response": "def from_stanford_dependencies(this_class, stream, tree,\n                                   include_erased=False, include_punct=True):\n        \"\"\"Construct a Sentence. stream is an iterable over strings\n        where each string is a line representing a Stanford Dependency\n        as in the output of the command line Stanford Dependency tool:\n\n            deprel(gov-index, dep-depindex)\n\n        The corresponding Penn Treebank formatted tree must be provided\n        as well.\"\"\"\n        stream = iter(stream)\n        sentence = this_class()\n        covered_indices = set()\n        tags_and_words = ptb_tags_and_words_re.findall(tree)\n        # perform some basic cleanups\n        tags_and_words = [(tag, word.replace(r'\\/', '/'))\n                          for (tag, word) in tags_and_words if tag != '-NONE-']\n        for line in stream:\n            if not line.strip():\n                if sentence:\n                    # empty line means the sentence is over\n                    break\n                else:\n                    continue\n            line = line.replace(r'\\/', '/')\n            matches = deps_re.findall(line)\n            assert len(matches) == 1\n            (deprel, gov_form, head, gov_is_copy, form, index,\n             dep_is_copy) = matches[0]\n            index = int(index)\n            tag, word = tags_and_words[index - 1]\n            assert form == word\n            covered_indices.add(index)\n\n            if not include_punct and deprel == 'punct':\n                continue\n            if gov_is_copy or dep_is_copy:\n                extra = {}\n                if gov_is_copy:\n                    extra['gov_is_copy'] = len(gov_is_copy)\n                if dep_is_copy:\n                    extra['dep_is_copy'] = len(dep_is_copy)\n            else:\n                extra = None\n            token = Token(index, form, None, tag, tag, None, int(head),\n                          deprel, None, None, extra)\n            sentence.append(token)\n\n        if include_erased:\n            # look through words in the tree to see if any of them\n            # were erased\n            for index, (tag, word) in enumerate(tags_and_words, 1):\n                if index in covered_indices:\n                    continue\n                token = Token(index, word, None, tag, tag, None, 0,\n                              'erased', None, None, None)\n                sentence.append(token)\n\n        sentence.sort()\n        return sentence"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef from_conll(this_class, stream):\n        stream = iter(stream)\n        corpus = this_class()\n        while 1:\n            # read until we get an empty sentence\n            sentence = Sentence.from_conll(stream)\n            if sentence:\n                corpus.append(sentence)\n            else:\n                break\n        return corpus", "response": "Construct a Corpus. stream is an iterable over strings where\n        each string is a line in CoNLL - X format."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef from_stanford_dependencies(this_class, stream, trees,\n                                   include_erased=False, include_punct=True):\n        \"\"\"Construct a Corpus. stream is an iterable over strings where\n        each string is a line representing a Stanford Dependency as in\n        the output of the command line Stanford Dependency tool:\n\n            deprel(gov-index, dep-depindex)\n\n        Sentences are separated by blank lines. A corresponding list of\n        Penn Treebank formatted trees must be provided as well.\"\"\"\n        stream = iter(stream)\n        corpus = this_class()\n        for tree in trees:\n            sentence = Sentence.from_stanford_dependencies(stream,\n                                                           tree,\n                                                           include_erased,\n                                                           include_punct)\n            corpus.append(sentence)\n        return corpus", "response": "Construct a Corpus from a list of trees and a list of UnifiedTrees."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nconvert a list of Penn Treebank formatted trees into Stanford Dependencies.", "response": "def convert_trees(self, ptb_trees, representation='basic',\n                      include_punct=True, include_erased=False, universal=True,\n                      debug=False):\n        \"\"\"Convert a list of Penn Treebank formatted trees (ptb_trees)\n        into Stanford Dependencies. The dependencies are represented\n        as a list of sentences, where each sentence is itself a list of\n        Token objects.\n\n        Currently supported representations are 'basic', 'collapsed',\n        'CCprocessed', and 'collapsedTree' which behave the same as they\n        in the CoreNLP command line tools. (note that in the online\n        CoreNLP demo, 'collapsed' is called 'enhanced')\n\n        Setting debug=True will cause debugging information (including\n        the java command run to be printed.\"\"\"\n        self._raise_on_bad_representation(representation)\n        input_file = tempfile.NamedTemporaryFile(delete=False)\n        try:\n            for ptb_tree in ptb_trees:\n                self._raise_on_bad_input(ptb_tree)\n                tree_with_line_break = ptb_tree + \"\\n\"\n                input_file.write(tree_with_line_break.encode(\"utf-8\"))\n            input_file.flush()\n            input_file.close()\n\n            command = [self.java_command,\n                       '-ea',\n                       '-cp', self.jar_filename,\n                       JAVA_CLASS_NAME,\n                       '-' + representation,\n                       '-treeFile', input_file.name]\n            # if we're including erased, we want to include punctuation\n            # since otherwise we won't know what SD considers punctuation\n            if include_punct or include_erased:\n                command.append('-keepPunct')\n            if not universal:\n                command.append('-originalDependencies')\n            if debug:\n                print('Command:', ' '.join(command))\n            sd_process = subprocess.Popen(command, stdout=subprocess.PIPE,\n                                          stderr=subprocess.PIPE,\n                                          universal_newlines=True)\n            return_code = sd_process.wait()\n            stderr = sd_process.stderr.read()\n            stdout = sd_process.stdout.read()\n\n            if debug:\n                print(\"stdout: {%s}\" % stdout)\n                print(\"stderr: {%s}\" % stderr)\n                print('Exit code:', return_code)\n\n            self._raise_on_bad_exit_or_output(return_code, stderr)\n        finally:\n            os.remove(input_file.name)\n\n        try:\n            sentences = Corpus.from_stanford_dependencies(stdout.splitlines(),\n                                                          ptb_trees,\n                                                          include_erased,\n                                                          include_punct)\n            for sentence, ptb_tree in zip(sentences, ptb_trees):\n                if len(sentence) == 0:\n                    raise ValueError(\"Invalid PTB tree: %r\" % ptb_tree)\n        except:\n            print(\"Error during conversion\")\n            if not debug:\n                print(\"stdout: {%s}\" % stdout)\n                print(\"stderr: {%s}\" % stderr)\n            raise\n\n        assert len(sentences) == len(ptb_trees), \\\n            \"Only got %d sentences from Stanford Dependencies when \" \\\n            \"given %d trees.\" % (len(sentences), len(ptb_trees))\n        return sentences"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns an endpoint object from a name.", "response": "def endpoint_from_name(endpoint_name):\n    \"\"\"The object used for interacting with the named relations, or None.\n    \"\"\"\n    if endpoint_name is None:\n        return None\n    factory = relation_factory(endpoint_name)\n    if factory:\n        return factory.from_name(endpoint_name)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the Endpoint object used for interacting with relations tied to a flag.", "response": "def endpoint_from_flag(flag):\n    \"\"\"The object used for interacting with relations tied to a flag, or None.\n    \"\"\"\n    relation_name = None\n    value = _get_flag_value(flag)\n    if isinstance(value, dict) and 'relation' in value:\n        # old-style RelationBase\n        relation_name = value['relation']\n    elif flag.startswith('endpoint.'):\n        # new-style Endpoint\n        relation_name = flag.split('.')[1]\n    elif '.' in flag:\n        # might be an unprefixed new-style Endpoint\n        relation_name = flag.split('.')[0]\n        if relation_name not in hookenv.relation_types():\n            return None\n    if relation_name:\n        factory = relation_factory(relation_name)\n        if factory:\n            return factory.from_flag(flag)\n    return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the RelationFactory for the given relation name.", "response": "def relation_factory(relation_name):\n    \"\"\"Get the RelationFactory for the given relation name.\n\n    Looks for a RelationFactory in the first file matching:\n    ``$CHARM_DIR/hooks/relations/{interface}/{provides,requires,peer}.py``\n    \"\"\"\n    role, interface = hookenv.relation_to_role_and_interface(relation_name)\n    if not (role and interface):\n        hookenv.log('Unable to determine role and interface for relation '\n                    '{}'.format(relation_name), hookenv.ERROR)\n        return None\n    return _find_relation_factory(_relation_module(role, interface))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _relation_module(role, interface):\n    _append_path(hookenv.charm_dir())\n    _append_path(os.path.join(hookenv.charm_dir(), 'hooks'))\n    base_module = 'relations.{}.{}'.format(interface, role)\n    for module in ('reactive.{}'.format(base_module), base_module):\n        if module in sys.modules:\n            break\n        try:\n            importlib.import_module(module)\n            break\n        except ImportError:\n            continue\n    else:\n        hookenv.log('Unable to find implementation for relation: '\n                    '{} of {}'.format(role, interface), hookenv.ERROR)\n        return None\n    return sys.modules[module]", "response": "Return module for relation based on its role and interface."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _find_relation_factory(module):\n    if not module:\n        return None\n\n    # All the RelationFactory subclasses\n    candidates = [o for o in (getattr(module, attr) for attr in dir(module))\n                  if (o is not RelationFactory and\n                      o is not RelationBase and\n                      isclass(o) and\n                      issubclass(o, RelationFactory))]\n\n    # Filter out any factories that are superclasses of another factory\n    # (none of the other factories subclass it). This usually makes\n    # the explict check for RelationBase and RelationFactory unnecessary.\n    candidates = [c1 for c1 in candidates\n                  if not any(issubclass(c2, c1) for c2 in candidates\n                             if c1 is not c2)]\n\n    if not candidates:\n        hookenv.log('No RelationFactory found in {}'.format(module.__name__),\n                    hookenv.WARNING)\n        return None\n\n    if len(candidates) > 1:\n        raise RuntimeError('Too many RelationFactory found in {}'\n                           ''.format(module.__name__))\n\n    return candidates[0]", "response": "Attempt to find a RelationFactory subclass in the module."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _migrate_conversations():  # noqa\n    for key, data in unitdata.kv().getrange('reactive.conversations.').items():\n        if 'local-data' in key:\n            continue\n        if 'namespace' in data:\n            continue\n        relation_name = data.pop('relation_name')\n        if data['scope'] == scopes.GLOBAL:\n            data['namespace'] = relation_name\n            unitdata.kv().set(key, data)\n        else:\n            # split the conv based on the relation ID\n            new_keys = []\n            for rel_id in hookenv.relation_ids(relation_name):\n                new_key = Conversation._key(rel_id, data['scope'])\n                new_units = set(hookenv.related_units(rel_id)) & set(data['units'])\n                if new_units:\n                    unitdata.kv().set(new_key, {\n                        'namespace': rel_id,\n                        'scope': data['scope'],\n                        'units': sorted(new_units),\n                    })\n                    new_keys.append(new_key)\n            unitdata.kv().unset(key)\n            # update the states pointing to the old conv key to point to the\n            # (potentially multiple) new key(s)\n            for flag in get_flags():\n                value = _get_flag_value(flag)\n                if not value:\n                    continue\n                if key not in value['conversations']:\n                    continue\n                value['conversations'].remove(key)\n                value['conversations'].extend(new_keys)\n                set_flag(flag, value)", "response": "Migrate all conversations in the SERVICE\n    to the new format."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ninvoke a method on the class implementing a relation via the CLI", "response": "def relation_call(method, relation_name=None, flag=None, state=None, *args):\n    \"\"\"Invoke a method on the class implementing a relation via the CLI\"\"\"\n    if relation_name:\n        relation = relation_from_name(relation_name)\n        if relation is None:\n            raise ValueError('Relation not found: %s' % relation_name)\n    elif flag or state:\n        relation = relation_from_flag(flag or state)\n        if relation is None:\n            raise ValueError('Relation not found: %s' % (flag or state))\n    else:\n        raise ValueError('Must specify either relation_name or flag')\n    result = getattr(relation, method)(*args)\n    if isinstance(relation, RelationBase) and method == 'conversations':\n        # special case for conversations to make them work from CLI\n        result = [c.scope for c in result]\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns an Endpoint from a flag.", "response": "def from_flag(cls, flag):\n        \"\"\"\n        Find relation implementation in the current charm, based on the\n        name of an active flag.\n\n        You should not use this method directly.\n        Use :func:`endpoint_from_flag` instead.\n        \"\"\"\n        value = _get_flag_value(flag)\n        if value is None:\n            return None\n        relation_name = value['relation']\n        conversations = Conversation.load(value['conversations'])\n        return cls.from_name(relation_name, conversations)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef from_name(cls, relation_name, conversations=None):\n        if relation_name is None:\n            return None\n        relation_class = cls._cache.get(relation_name)\n        if relation_class:\n            return relation_class(relation_name, conversations)\n        role, interface = hookenv.relation_to_role_and_interface(relation_name)\n        if role and interface:\n            relation_class = cls._find_impl(role, interface)\n            if relation_class:\n                cls._cache[relation_name] = relation_class\n                return relation_class(relation_name, conversations)\n        return None", "response": "Find a relation implementation in the current charm based on the relation name."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nfind the implementation based on its role and interface.", "response": "def _find_impl(cls, role, interface):\n        \"\"\"\n        Find relation implementation based on its role and interface.\n        \"\"\"\n        module = _relation_module(role, interface)\n        if not module:\n            return None\n        return cls._find_subclass(module)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _find_subclass(cls, module):\n        for attr in dir(module):\n            candidate = getattr(module, attr)\n            if (isclass(candidate) and issubclass(candidate, cls) and\n                    candidate is not RelationBase):\n                return candidate\n        return None", "response": "Attempt to find a subclass of cls in the given module."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget a single conversation by scope", "response": "def conversation(self, scope=None):\n        \"\"\"\n        Get a single conversation, by scope, that this relation is currently handling.\n\n        If the scope is not given, the correct scope is inferred by the current\n        hook execution context.  If there is no current hook execution context, it\n        is assume that there is only a single global conversation scope for this\n        relation.  If this relation's scope is not global and there is no current\n        hook execution context, then an error is raised.\n        \"\"\"\n        if scope is None:\n            if self.scope is scopes.UNIT:\n                scope = hookenv.remote_unit()\n            elif self.scope is scopes.SERVICE:\n                scope = hookenv.remote_service_name()\n            else:\n                scope = self.scope\n        if scope is None:\n            raise ValueError('Unable to determine default scope: no current hook or global scope')\n        for conversation in self._conversations:\n            if conversation.scope == scope:\n                return conversation\n        else:\n            raise ValueError(\"Conversation with scope '%s' not found\" % scope)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ntoggles the state of the related conversation with the given scope.", "response": "def toggle_state(self, state, active=TOGGLE, scope=None):\n        \"\"\"\n        Toggle the state for the :class:`Conversation` with the given scope.\n\n        In Python, this is equivalent to::\n\n            relation.conversation(scope).toggle_state(state, active)\n\n        See :meth:`conversation` and :meth:`Conversation.toggle_state`.\n        \"\"\"\n        self.conversation(scope).toggle_state(state, active)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsets data for the remote end of the current conversation with the given scope.", "response": "def set_remote(self, key=None, value=None, data=None, scope=None, **kwdata):\n        \"\"\"\n        Set data for the remote end(s) of the :class:`Conversation` with the given scope.\n\n        In Python, this is equivalent to::\n\n            relation.conversation(scope).set_remote(key, value, data, scope, **kwdata)\n\n        See :meth:`conversation` and :meth:`Conversation.set_remote`.\n        \"\"\"\n        self.conversation(scope).set_remote(key, value, data, **kwdata)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_remote(self, key, default=None, scope=None):\n        return self.conversation(scope).get_remote(key, default)", "response": "Get data from the remote end of the conversation with the given key."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef set_local(self, key=None, value=None, data=None, scope=None, **kwdata):\n        self.conversation(scope).set_local(key, value, data, **kwdata)", "response": "Locally store some data namespaced by the current or given conversation scope."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_local(self, key, default=None, scope=None):\n        return self.conversation(scope).get_local(key, default)", "response": "Retrieve some data previously set via set_local."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the set of relation IDs that this conversation is communicating with.", "response": "def relation_ids(self):\n        \"\"\"\n        The set of IDs of the specific relation instances that this conversation\n        is communicating with.\n        \"\"\"\n        if self.scope == scopes.GLOBAL:\n            # the namespace is the relation name and this conv speaks for all\n            # connected instances of that relation\n            return hookenv.relation_ids(self.namespace)\n        else:\n            # the namespace is the relation ID\n            return [self.namespace]"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef join(cls, scope):\n        relation_name = hookenv.relation_type()\n        relation_id = hookenv.relation_id()\n        unit = hookenv.remote_unit()\n        service = hookenv.remote_service_name()\n        if scope is scopes.UNIT:\n            scope = unit\n            namespace = relation_id\n        elif scope is scopes.SERVICE:\n            scope = service\n            namespace = relation_id\n        else:\n            namespace = relation_name\n        key = cls._key(namespace, scope)\n        data = unitdata.kv().get(key, {'namespace': namespace, 'scope': scope, 'units': []})\n        conversation = cls.deserialize(data)\n        conversation.units.add(unit)\n        unitdata.kv().set(key, cls.serialize(conversation))\n        return conversation", "response": "Get or create a conversation for the given scope and active hook context."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef depart(self):\n        unit = hookenv.remote_unit()\n        self.units.remove(unit)\n        if self.units:\n            unitdata.kv().set(self.key, self.serialize(self))\n        else:\n            unitdata.kv().unset(self.key)", "response": "Removes the current remote unit from the current conversation context."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nserialize a conversation instance for storage.", "response": "def serialize(cls, conversation):\n        \"\"\"\n        Serialize a conversation instance for storage.\n        \"\"\"\n        return {\n            'namespace': conversation.namespace,\n            'units': sorted(conversation.units),\n            'scope': conversation.scope,\n        }"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef load(cls, keys):\n        conversations = []\n        for key in keys:\n            conversation = unitdata.kv().get(key)\n            if conversation:\n                conversations.append(cls.deserialize(conversation))\n        return conversations", "response": "Load a set of conversations by their keys."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nactivate and put this conversation into the given state.", "response": "def set_state(self, state):\n        \"\"\"\n        Activate and put this conversation into the given state.\n\n        The relation name will be interpolated in the state name, and it is\n        recommended that it be included to avoid conflicts with states from\n        other relations.  For example::\n\n            conversation.set_state('{relation_name}.state')\n\n        If called from a converation handling the relation \"foo\", this will\n        activate the \"foo.state\" state, and will add this conversation to\n        that state.\n\n        Note: This uses :mod:`charmhelpers.core.unitdata` and requires that\n        :meth:`~charmhelpers.core.unitdata.Storage.flush` be called.\n        \"\"\"\n        state = state.format(relation_name=self.relation_name)\n        value = _get_flag_value(state, {\n            'relation': self.relation_name,\n            'conversations': [],\n        })\n        if self.key not in value['conversations']:\n            value['conversations'].append(self.key)\n        set_flag(state, value)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef remove_state(self, state):\n        state = state.format(relation_name=self.relation_name)\n        value = _get_flag_value(state)\n        if not value:\n            return\n        if self.key in value['conversations']:\n            value['conversations'].remove(self.key)\n        if value['conversations']:\n            set_flag(state, value)\n        else:\n            clear_flag(state)", "response": "Removes this conversation from the given state and potentially\n            deactivate the state if no more conversations are in it."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ntesting if this conversation is in the given state.", "response": "def is_state(self, state):\n        \"\"\"\n        Test if this conversation is in the given state.\n        \"\"\"\n        state = state.format(relation_name=self.relation_name)\n        value = _get_flag_value(state)\n        if not value:\n            return False\n        return self.key in value['conversations']"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef toggle_state(self, state, active=TOGGLE):\n        if active is TOGGLE:\n            active = not self.is_state(state)\n        if active:\n            self.set_state(state)\n        else:\n            self.remove_state(state)", "response": "Toggle the given state for this conversation."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsetting data for the remote end of this conversation.", "response": "def set_remote(self, key=None, value=None, data=None, **kwdata):\n        \"\"\"\n        Set data for the remote end(s) of this conversation.\n\n        Data can be passed in either as a single dict, or as key-word args.\n\n        Note that, in Juju, setting relation data is inherently service scoped.\n        That is, if the conversation only includes a single unit, the data will\n        still be set for that unit's entire service.\n\n        However, if this conversation's scope encompasses multiple services,\n        the data will be set for all of those services.\n\n        :param str key: The name of a field to set.\n        :param value: A value to set. This value must be json serializable.\n        :param dict data: A mapping of keys to values.\n        :param **kwdata: A mapping of keys to values, as keyword arguments.\n        \"\"\"\n        if data is None:\n            data = {}\n        if key is not None:\n            data[key] = value\n        data.update(kwdata)\n        if not data:\n            return\n        for relation_id in self.relation_ids:\n            hookenv.relation_set(relation_id, data)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting a value from the remote end of this conversation.", "response": "def get_remote(self, key, default=None):\n        \"\"\"\n        Get a value from the remote end(s) of this conversation.\n\n        Note that if a conversation's scope encompasses multiple units, then\n        those units are expected to agree on their data, whether that is through\n        relying on a single leader to set the data or by all units eventually\n        converging to identical data.  Thus, this method returns the first\n        value that it finds set by any of its units.\n        \"\"\"\n        cur_rid = hookenv.relation_id()\n        departing = hookenv.hook_name().endswith('-relation-departed')\n        for relation_id in self.relation_ids:\n            units = hookenv.related_units(relation_id)\n            if departing and cur_rid == relation_id:\n                # Work around the fact that Juju 2.0 doesn't include the\n                # departing unit in relation-list during the -departed hook,\n                # by adding it back in ourselves.\n                units.append(hookenv.remote_unit())\n            for unit in units:\n                if unit not in self.units:\n                    continue\n                value = hookenv.relation_get(key, unit, relation_id)\n                if value:\n                    return value\n        return default"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef set_local(self, key=None, value=None, data=None, **kwdata):\n        if data is None:\n            data = {}\n        if key is not None:\n            data[key] = value\n        data.update(kwdata)\n        if not data:\n            return\n        unitdata.kv().update(data, prefix='%s.%s.' % (self.key, 'local-data'))", "response": "Set the local data associated with this conversation."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_local(self, key, default=None):\n        key = '%s.%s.%s' % (self.key, 'local-data', key)\n        return unitdata.kv().get(key, default)", "response": "Retrieve some data from the local - data store for this conversation."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset the given flag as active.", "response": "def set_flag(flag, value=None):\n    \"\"\"set_flag(flag)\n    Set the given flag as active.\n\n    :param str flag: Name of flag to set.\n\n    .. note:: **Changes to flags are reset when a handler crashes.** Changes to\n       flags happen immediately, but they are only persisted at the end of a\n       complete and successful run of the reactive framework. All unpersisted\n       changes are discarded when a hook crashes.\n    \"\"\"\n    old_flags = get_flags()\n    unitdata.kv().update({flag: value}, prefix='reactive.states.')\n    if flag not in old_flags:\n        tracer().set_flag(flag)\n        FlagWatch.change(flag)\n        trigger = _get_trigger(flag, None)\n        for flag_name in trigger['set_flag']:\n            set_flag(flag_name)\n        for flag_name in trigger['clear_flag']:\n            clear_flag(flag_name)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nclears the flag in the specified node.", "response": "def clear_flag(flag):\n    \"\"\"\n    Clear / deactivate a flag.\n\n    :param str flag: Name of flag to set.\n\n    .. note:: **Changes to flags are reset when a handler crashes.** Changes to\n       flags happen immediately, but they are only persisted at the end of a\n       complete and successful run of the reactive framework. All unpersisted\n       changes are discarded when a hook crashes.\n    \"\"\"\n    old_flags = get_flags()\n    unitdata.kv().unset('reactive.states.%s' % flag)\n    unitdata.kv().set('reactive.dispatch.removed_state', True)\n    if flag in old_flags:\n        tracer().clear_flag(flag)\n        FlagWatch.change(flag)\n        trigger = _get_trigger(None, flag)\n        for flag_name in trigger['set_flag']:\n            set_flag(flag_name)\n        for flag_name in trigger['clear_flag']:\n            clear_flag(flag_name)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nregister a trigger to set or clear a flag when a given flag is set.", "response": "def register_trigger(when=None, when_not=None, set_flag=None, clear_flag=None):\n    \"\"\"\n    Register a trigger to set or clear a flag when a given flag is set.\n\n    Note: Flag triggers are handled at the same time that the given flag is set.\n\n    :param str when: Flag to trigger on when it is set.\n    :param str when_not: Flag to trigger on when it is cleared.\n    :param str set_flag: If given, this flag will be set when `when` is set.\n    :param str clear_flag: If given, this flag will be cleared when `when` is set.\n\n    Note: Exactly one of either `when` or `when_not`, and at least one of\n    `set_flag` or `clear_flag` must be provided.\n    \"\"\"\n    if not any((when, when_not)):\n        raise ValueError('Must provide one of when or when_not')\n    if all((when, when_not)):\n        raise ValueError('Only one of when or when_not can be provided')\n    if not any((set_flag, clear_flag)):\n        raise ValueError('Must provide at least one of set_flag or clear_flag')\n    trigger = _get_trigger(when, when_not)\n    if set_flag and set_flag not in trigger['set_flag']:\n        trigger['set_flag'].append(set_flag)\n    if clear_flag and clear_flag not in trigger['clear_flag']:\n        trigger['clear_flag'].append(clear_flag)\n    _save_trigger(when, when_not, trigger)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_flags():\n    flags = unitdata.kv().getrange('reactive.states.', strip=True) or {}\n    return sorted(flags.keys())", "response": "Return a list of all flags which are set."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef dispatch(restricted=False):\n    FlagWatch.reset()\n\n    def _test(to_test):\n        return list(filter(lambda h: h.test(), to_test))\n\n    def _invoke(to_invoke):\n        while to_invoke:\n            unitdata.kv().set('reactive.dispatch.removed_state', False)\n            for handler in list(to_invoke):\n                to_invoke.remove(handler)\n                hookenv.log('Invoking reactive handler: %s' % handler.id(), level=hookenv.INFO)\n                handler.invoke()\n                if unitdata.kv().get('reactive.dispatch.removed_state'):\n                    # re-test remaining handlers\n                    to_invoke = _test(to_invoke)\n                    break\n        FlagWatch.commit()\n\n    tracer().start_dispatch()\n\n    # When in restricted context, only run hooks for that context.\n    if restricted:\n        unitdata.kv().set('reactive.dispatch.phase', 'restricted')\n        hook_handlers = _test(Handler.get_handlers())\n        tracer().start_dispatch_phase('restricted', hook_handlers)\n        _invoke(hook_handlers)\n        return\n\n    unitdata.kv().set('reactive.dispatch.phase', 'hooks')\n    hook_handlers = _test(Handler.get_handlers())\n    tracer().start_dispatch_phase('hooks', hook_handlers)\n    _invoke(hook_handlers)\n\n    unitdata.kv().set('reactive.dispatch.phase', 'other')\n    for i in range(100):\n        FlagWatch.iteration(i)\n        other_handlers = _test(Handler.get_handlers())\n        if i == 0:\n            tracer().start_dispatch_phase('other', other_handlers)\n        tracer().start_dispatch_iteration(i, other_handlers)\n        if not other_handlers:\n            break\n        _invoke(other_handlers)\n\n    FlagWatch.reset()", "response": "Dispatch registered handlers.\n\n    When dispatching in restricted mode, only matching hook handlers are executed.\n\n    Handlers are dispatched according to the following rules:\n\n    * Handlers are repeatedly tested and invoked in iterations, until the system\n      settles into quiescence (that is, until no new handlers match to be invoked).\n\n    * In the first iteration, :func:`@hook <charms.reactive.decorators.hook>`\n      and :func:`@action <charms.reactive.decorators.action>` handlers will\n      be invoked, if they match.\n\n    * In subsequent iterations, other handlers are invoked, if they match.\n\n    * Added flags will not trigger new handlers until the next iteration,\n      to ensure that chained flags are invoked in a predictable order.\n\n    * Removed flags will cause the current set of matched handlers to be\n      re-tested, to ensure that no handler is invoked after its matching\n      flag has been removed.\n\n    * Other than the guarantees mentioned above, the order in which matching\n      handlers are invoked is undefined.\n\n    * Flags are preserved between hook and action invocations, and all matching\n      handlers are re-invoked for every hook and action.  There are\n      :doc:`decorators <charms.reactive.decorators>` and\n      :doc:`helpers <charms.reactive.helpers>`\n      to prevent unnecessary reinvocations, such as\n      :func:`~charms.reactive.decorators.only_once`."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ndiscover handlers based on convention.", "response": "def discover():\n    \"\"\"\n    Discover handlers based on convention.\n\n    Handlers will be loaded from the following directories and their subdirectories:\n\n      * ``$CHARM_DIR/reactive/``\n      * ``$CHARM_DIR/hooks/reactive/``\n      * ``$CHARM_DIR/hooks/relations/``\n\n    They can be Python files, in which case they will be imported and decorated\n    functions registered.  Or they can be executables, in which case they must\n    adhere to the :class:`ExternalHandler` protocol.\n    \"\"\"\n    # Add $CHARM_DIR and $CHARM_DIR/hooks to sys.path so\n    # 'import reactive.leadership', 'import relations.pgsql' works\n    # as expected, as well as relative imports like 'import ..leadership'\n    # or 'from . import leadership'. Without this, it becomes difficult\n    # for layers to access APIs provided by other layers. This addition\n    # needs to remain in effect, in case discovered modules are doing\n    # late imports.\n    _append_path(hookenv.charm_dir())\n    _append_path(os.path.join(hookenv.charm_dir(), 'hooks'))\n\n    for search_dir in ('reactive', 'hooks/reactive', 'hooks/relations'):\n        search_path = os.path.join(hookenv.charm_dir(), search_dir)\n        for dirpath, dirnames, filenames in os.walk(search_path):\n            for filename in filenames:\n                filepath = os.path.join(dirpath, filename)\n                _register_handlers_from_file(search_path, filepath)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget or register a handler for the given action.", "response": "def get(cls, action, suffix=None):\n        \"\"\"\n        Get or register a handler for the given action.\n\n        :param func action: Callback that is called when invoking the Handler\n        :param func suffix: Optional suffix for the handler's ID\n        \"\"\"\n        action_id = _action_id(action, suffix)\n        if action_id not in cls._HANDLERS:\n            if LOG_OPTS['register']:\n                hookenv.log('Registering reactive handler for %s' % _short_action_id(action, suffix),\n                            level=hookenv.DEBUG)\n            cls._HANDLERS[action_id] = cls(action, suffix)\n        return cls._HANDLERS[action_id]"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef add_predicate(self, predicate):\n        _predicate = predicate\n        if isinstance(predicate, partial):\n            _predicate = 'partial(%s, %s, %s)' % (predicate.func, predicate.args, predicate.keywords)\n        if LOG_OPTS['register']:\n            hookenv.log('  Adding predicate for %s: %s' % (self.id(), _predicate), level=hookenv.DEBUG)\n        self._predicates.append(predicate)", "response": "Add a new predicate callback to this handler."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _get_args(self):\n        if not hasattr(self, '_args_evaled'):\n            # cache the args in case handler is re-invoked due to flags change\n            self._args_evaled = list(chain.from_iterable(self._args))\n        return self._args_evaled", "response": "Lazily evaluate the args.\n           "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef register_flags(self, flags):\n        self._CONSUMED_FLAGS.update(flags)\n        self._flags.update(flags)", "response": "Register flags as being relevant to this handler."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ninvokes the external handler.", "response": "def invoke(self):\n        \"\"\"\n        Call the external handler to be invoked.\n        \"\"\"\n        # flush to ensure external process can see flags as they currently\n        # are, and write flags (flush releases lock)\n        unitdata.kv().flush()\n        subprocess.check_call([self._filepath, '--invoke', self._test_output], env=os.environ)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nregisters the decorated function to run when the current hook matches any of the hook_patterns.", "response": "def hook(*hook_patterns):\n    \"\"\"\n    Register the decorated function to run when the current hook matches any of\n    the ``hook_patterns``.\n\n    This decorator is generally deprecated and should only be used when\n    absolutely necessary.\n\n    The hook patterns can use the ``{interface:...}`` and ``{A,B,...}`` syntax\n    supported by :func:`~charms.reactive.bus.any_hook`.\n\n    Note that hook decorators **cannot** be combined with :func:`when` or\n    :func:`when_not` decorators.\n    \"\"\"\n    def _register(action):\n        def arg_gen():\n            # use a generator to defer calling of hookenv.relation_type, for tests\n            rel = endpoint_from_name(hookenv.relation_type())\n            if rel:\n                yield rel\n\n        handler = Handler.get(action)\n        handler.add_predicate(partial(_hook, hook_patterns))\n        handler.add_args(arg_gen())\n        return action\n    return _register"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nregister the decorated function to run when one or more files have changed. :param list filenames: The names of one or more files to check for changes (a callable returning the name is also accepted). :param str hash_type: The type of hash to use for determining if a file has changed. Defaults to 'md5'. Must be given as a kwarg.", "response": "def when_file_changed(*filenames, **kwargs):\n    \"\"\"\n    Register the decorated function to run when one or more files have changed.\n\n    :param list filenames: The names of one or more files to check for changes\n        (a callable returning the name is also accepted).\n    :param str hash_type: The type of hash to use for determining if a file has\n        changed.  Defaults to 'md5'.  Must be given as a kwarg.\n    \"\"\"\n    def _register(action):\n        handler = Handler.get(action)\n        handler.add_predicate(partial(any_file_changed, filenames, **kwargs))\n        return action\n    return _register"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef not_unless(*desired_flags):\n    def _decorator(func):\n        action_id = _action_id(func)\n        short_action_id = _short_action_id(func)\n\n        @wraps(func)\n        def _wrapped(*args, **kwargs):\n            active_flags = get_flags()\n            missing_flags = [flag for flag in desired_flags if flag not in active_flags]\n            if missing_flags:\n                hookenv.log('%s called before flag%s: %s' % (\n                    short_action_id,\n                    's' if len(missing_flags) > 1 else '',\n                    ', '.join(missing_flags)), hookenv.WARNING)\n            return func(*args, **kwargs)\n        _wrapped._action_id = action_id\n        _wrapped._short_action_id = short_action_id\n        return _wrapped\n    return _decorator", "response": "Decorator that ensures that the decorated function is not called if the desired_flags are active."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef collect_metrics():\n    def _register(action):\n        handler = Handler.get(action)\n        handler.add_predicate(partial(_restricted_hook, 'collect-metrics'))\n        return action\n    return _register", "response": "Decorator to register the decorated function to run for the collect_metrics hook."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nexpands any endpoint name tags in the given flags.", "response": "def _expand_endpoint_name(endpoint_name, flags):\n    \"\"\"\n    Populate any ``{endpoint_name}`` tags in the flag names for the given\n    handler, based on the handlers module / file name.\n    \"\"\"\n    return tuple(flag.format(endpoint_name=endpoint_name) for flag in flags)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _is_endpoint_method(handler):\n    params = signature(handler).parameters\n    has_self = len(params) == 1 and list(params.keys())[0] == 'self'\n    has_endpoint_class = any(isclass(g) and issubclass(g, Endpoint)\n                             for g in handler.__globals__.values())\n    return has_self and has_endpoint_class", "response": "Returns True if the given handler is an Endpoint method."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nasserts that the currently executing hook matches one of the given patterns.", "response": "def any_hook(*hook_patterns):\n    \"\"\"\n    Assert that the currently executing hook matches one of the given patterns.\n\n    Each pattern will match one or more hooks, and can use the following\n    special syntax:\n\n      * ``db-relation-{joined,changed}`` can be used to match multiple hooks\n        (in this case, ``db-relation-joined`` and ``db-relation-changed``).\n      * ``{provides:mysql}-relation-joined`` can be used to match a relation\n        hook by the role and interface instead of the relation name.  The role\n        must be one of ``provides``, ``requires``, or ``peer``.\n      * The previous two can be combined, of course: ``{provides:mysql}-relation-{joined,changed}``\n    \"\"\"\n    current_hook = hookenv.hook_name()\n\n    # expand {role:interface} patterns\n    i_pat = re.compile(r'{([^:}]+):([^}]+)}')\n    hook_patterns = _expand_replacements(i_pat, hookenv.role_and_interface_to_relations, hook_patterns)\n\n    # expand {A,B,C,...} patterns\n    c_pat = re.compile(r'{((?:[^:,}]+,?)+)}')\n    hook_patterns = _expand_replacements(c_pat, lambda v: v.split(','), hook_patterns)\n\n    return current_hook in hook_patterns"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef any_file_changed(filenames, hash_type='md5'):\n    changed = False\n    for filename in filenames:\n        if callable(filename):\n            filename = str(filename())\n        else:\n            filename = str(filename)\n        old_hash = unitdata.kv().get('reactive.files_changed.%s' % filename)\n        new_hash = host.file_hash(filename, hash_type=hash_type)\n        if old_hash != new_hash:\n            unitdata.kv().set('reactive.files_changed.%s' % filename, new_hash)\n            changed = True  # mark as changed, but keep updating hashes\n    return changed", "response": "Check if any of the given files have changed since the last time this\n    was called."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef load_hook_files(pathname):\n    global hooks\n\n    if sys.version_info[0] > 2 and sys.version_info[1] > 4:\n        fsglob = sorted(glob.iglob(pathname, recursive=True))\n    else:\n        fsglob = sorted(glob.iglob(pathname))\n\n    for path in fsglob:\n        real_path = os.path.realpath(path)\n        # Append hooks file directory to the sys.path so submodules can be\n        # loaded too.\n        if os.path.dirname(real_path) not in sys.path:\n            sys.path.append(os.path.dirname(real_path))\n        module = imp.load_source(os.path.basename(path), real_path)\n        for name in dir(module):\n            obj = getattr(module, name)\n            if hasattr(obj, 'dredd_hooks') and callable(obj):\n                func_hooks = getattr(obj, 'dredd_hooks')\n                for hook, name in func_hooks:\n                    if hook == BEFORE_ALL:\n                        hooks._before_all.append(obj)\n                    if hook == AFTER_ALL:\n                        hooks._after_all.append(obj)\n                    if hook == BEFORE_EACH:\n                        hooks._before_each.append(obj)\n                    if hook == AFTER_EACH:\n                        hooks._after_each.append(obj)\n                    if hook == BEFORE_EACH_VALIDATION:\n                        hooks._before_each_validation.append(obj)\n                    if hook == BEFORE_VALIDATION:\n                        add_named_hook(hooks._before_validation, obj, name)\n                    if hook == BEFORE:\n                        add_named_hook(hooks._before, obj, name)\n                    if hook == AFTER:\n                        add_named_hook(hooks._after, obj, name)", "response": "Loads the files defined as a glob or a single file path and adds them to the internal list of hooks."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning an Endpoint subclass instance based on the given flag.", "response": "def from_flag(cls, flag):\n        \"\"\"\n        Return an Endpoint subclass instance based on the given flag.\n\n        The instance that is returned depends on the endpoint name embedded\n        in the flag.  Flags should be of the form ``endpoint.{name}.extra...``,\n        though for legacy purposes, the ``endpoint.`` prefix can be omitted.\n        The ``{name}}`` portion will be passed to\n        :meth:`~charms.reactive.endpoints.Endpoint.from_name`.\n\n        If the flag is not set, an appropriate Endpoint subclass cannot be\n        found, or the flag name can't be parsed, ``None`` will be returned.\n        \"\"\"\n        if not is_flag_set(flag) or '.' not in flag:\n            return None\n        parts = flag.split('.')\n        if parts[0] == 'endpoint':\n            return cls.from_name(parts[1])\n        else:\n            # some older handlers might not use the 'endpoint' prefix\n            return cls.from_name(parts[0])"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _startup(cls):\n        for endpoint_name in sorted(hookenv.relation_types()):\n            # populate context based on attached relations\n            relf = relation_factory(endpoint_name)\n            if not relf or not issubclass(relf, cls):\n                continue\n\n            rids = sorted(hookenv.relation_ids(endpoint_name))\n            # ensure that relation IDs have the endpoint name prefix, in case\n            # juju decides to drop it at some point\n            rids = ['{}:{}'.format(endpoint_name, rid) if ':' not in rid\n                    else rid for rid in rids]\n            endpoint = relf(endpoint_name, rids)\n            cls._endpoints[endpoint_name] = endpoint\n            endpoint.register_triggers()\n            endpoint._manage_departed()\n            endpoint._manage_flags()\n            for relation in endpoint.relations:\n                hookenv.atexit(relation._flush_data)", "response": "Create Endpoint instances and manage automatic flags."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nexpands the flag for this endpoint by expanding the endpoint name.", "response": "def expand_name(self, flag):\n        \"\"\"\n        Complete a flag for this endpoint by expanding the endpoint name.\n\n        If the flag does not already contain ``{endpoint_name}``, it will be\n        prefixed with ``endpoint.{endpoint_name}.``. Then, any occurance of\n        ``{endpoint_name}`` will be replaced with ``self.endpoint_name``.\n        \"\"\"\n        if '{endpoint_name}' not in flag:\n            flag = 'endpoint.{endpoint_name}.' + flag\n        # use replace rather than format to prevent any other braces or braced\n        # strings from being touched\n        return flag.replace('{endpoint_name}', self.endpoint_name)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nmanages automatic relation flags.", "response": "def _manage_flags(self):\n        \"\"\"\n        Manage automatic relation flags.\n        \"\"\"\n        already_joined = is_flag_set(self.expand_name('joined'))\n        hook_name = hookenv.hook_name()\n        rel_hook = hook_name.startswith(self.endpoint_name + '-relation-')\n        departed_hook = rel_hook and hook_name.endswith('-departed')\n\n        toggle_flag(self.expand_name('joined'), self.is_joined)\n\n        if departed_hook:\n            set_flag(self.expand_name('departed'))\n        elif self.is_joined:\n            clear_flag(self.expand_name('departed'))\n\n        if already_joined and not rel_hook:\n            # skip checking relation data outside hooks for this relation\n            # to save on API calls to the controller (unless we didn't have\n            # the joined flag before, since then we might migrating to Endpoints)\n            return\n\n        for unit in self.all_units:\n            for key, value in unit.received.items():\n                data_key = 'endpoint.{}.{}.{}.{}'.format(self.endpoint_name,\n                                                         unit.relation.relation_id,\n                                                         unit.unit_name,\n                                                         key)\n                if data_changed(data_key, value):\n                    set_flag(self.expand_name('changed'))\n                    set_flag(self.expand_name('changed.{}'.format(key)))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef all_joined_units(self):\n        if self._all_joined_units is None:\n            units = chain.from_iterable(rel.units for rel in self.relations)\n            self._all_joined_units = CombinedUnitsView(units)\n        return self._all_joined_units", "response": "A list view of all the units of all relations attached to this Endpoint."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a collection of all departed units.", "response": "def all_departed_units(self):\n        \"\"\"\n        Collection of all units that were previously part of any relation on\n        this endpoint but which have since departed.\n\n        This collection is persistent and mutable.  The departed units will\n        be kept until they are explicitly removed, to allow for reasonable\n        cleanup of units that have left.\n\n        Example: You need to run a command each time a unit departs the relation.\n\n        .. code-block:: python\n\n            @when('endpoint.{endpoint_name}.departed')\n            def handle_departed_unit(self):\n                for name, unit in self.all_departed_units.items():\n                    # run the command to remove `unit` from the cluster\n                    #  ..\n                self.all_departed_units.clear()\n                clear_flag(self.expand_name('departed'))\n\n        Once a unit is departed, it will no longer show up in\n        :attr:`all_joined_units`.  Note that units are considered departed as\n        soon as the departed hook is entered, which differs slightly from how\n        the Juju primitives behave (departing units are still returned from\n        ``related-units`` until after the departed hook is complete).\n\n        This collection is a :class:`KeyList`, so can be used as a mapping to\n        look up units by their unit name, or iterated or accessed by index.\n        \"\"\"\n        if self._all_departed_units is None:\n            self._all_departed_units = CachedKeyList.load(\n                'reactive.endpoints.departed.{}'.format(self.endpoint_name),\n                RelatedUnit._deserialize,\n                'unit_name')\n        return self._all_departed_units"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef application_name(self):\n        if self._application_name is None and self.units:\n            self._application_name = self.units[0].unit_name.split('/')[0]\n        return self._application_name", "response": "Returns the name of the remote application for this relation or None if the relation is not in the remote application."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef to_publish(self):\n        if self._data is None:\n            self._data = JSONUnitDataView(\n                hookenv.relation_get(unit=hookenv.local_unit(),\n                                     rid=self.relation_id),\n                writeable=True)\n        return self._data", "response": "Returns the relation data that the local unit publishes so it is visible to all related units."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _flush_data(self):\n        if self._data and self._data.modified:\n            hookenv.relation_set(self.relation_id, dict(self.to_publish.data))", "response": "Flushes the local unit data to the relation."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef load(cls, cache_key, deserializer, key_attr):\n        items = unitdata.kv().get(cache_key) or []\n        return cls(cache_key,\n                   [deserializer(item) for item in items],\n                   key_attr)", "response": "Load the persisted cache and return a new instance of this class."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef received(self):\n        if not hasattr(self, '_data'):\n            # NB: units are reversed so that lowest numbered unit takes precedence\n            self._data = JSONUnitDataView({key: value\n                                           for unit in reversed(self)\n                                           for key, value in unit.received_raw.items()})\n\n        return self._data", "response": "Returns the JSONUnitDataView of all received units in this list."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncreate a Podio client using an auth object.", "response": "def AuthorizingClient(domain, auth, user_agent=None):\n    \"\"\"Creates a Podio client using an auth object.\"\"\"\n    http_transport = transport.HttpTransport(domain, build_headers(auth, user_agent))\n    return client.Client(http_transport)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef from_image(cls, image):\n        (w, h) = image.size\n\n        # Thermal paper is 512 pixels wide\n        if w > 512:\n            ratio = 512. / w\n            h = int(h * ratio)\n            image = image.resize((512, h), Image.ANTIALIAS)\n        if image.mode != '1':\n            image = image.convert('1')\n\n        pixels = np.array(list(image.getdata())).reshape(h, w)\n\n        # Add white pixels so that image fits into bytes\n        extra_rows = int(math.ceil(h / 24)) * 24 - h\n        extra_pixels = np.ones((extra_rows, w), dtype=bool)\n        pixels = np.vstack((pixels, extra_pixels))\n        h += extra_rows\n        nb_stripes = h / 24\n        pixels = pixels.reshape(nb_stripes, 24, w).swapaxes(1, 2).reshape(-1, 8)\n\n        nh = int(w / 256)\n        nl = w % 256\n        data = []\n\n        pixels = np.invert(np.packbits(pixels))\n        stripes = np.split(pixels, nb_stripes)\n\n        for stripe in stripes:\n\n            data.extend([\n                ESC,\n                42,  # *\n                33,  # double density mode\n                nl,\n                nh])\n\n            data.extend(stripe)\n            data.extend([\n                27,   # ESC\n                74,   # J\n                48])\n\n        # account for double density mode\n        height = h * 2\n        return cls(data, height)", "response": "Create a PrintableImage from a PIL Image."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef append(self, other):\n        self.data.extend(other.data)\n        self.height = self.height + other.height\n        return self", "response": "Append a Printable Image at the end of the current instance."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef print_images(self, *printable_images):\n        printable_image = reduce(lambda x, y: x.append(y), list(printable_images))\n        self.print_image(printable_image)", "response": "This method allows printing multiple images in one shot."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef encode_and_quote(data):\n    if data is None:\n        return None\n\n    if isinstance(data, unicode):\n        data = data.encode(\"utf-8\")\n    return urllib.quote_plus(data)", "response": "Encodes and quotes the given data."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nconverting a unicode string to a string and return the results.", "response": "def _strify(s):\n    \"\"\"If s is a unicode string, encode it to UTF-8 and return the results,\n    otherwise return str(s), or None if s is None\"\"\"\n    if s is None:\n        return None\n    if isinstance(s, unicode):\n        return s.encode(\"utf-8\")\n    return str(s)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nencoding a file header into a multipart - form - data field.", "response": "def encode_file_header(boundary, paramname, filesize, filename=None,\n                       filetype=None):\n    \"\"\"Returns the leading data for a multipart/form-data field that contains\n    file data.\n\n    ``boundary`` is the boundary string used throughout a single request to\n    separate variables.\n\n    ``paramname`` is the name of the variable in this request.\n\n    ``filesize`` is the size of the file data.\n\n    ``filename`` if specified is the filename to give to this field.  This\n    field is only useful to the server for determining the original filename.\n\n    ``filetype`` if specified is the MIME type of this file.\n\n    The actual file data should be sent after this header has been sent.\n    \"\"\"\n\n    return MultipartParam(paramname, filesize=filesize, filename=filename,\n                          filetype=filetype).encode_hdr(boundary)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_body_size(params, boundary):\n    size = sum(p.get_size(boundary) for p in MultipartParam.from_params(params))\n    return size + len(boundary) + 6", "response": "Returns the number of bytes that the multipart - form - data encoding\n    of params will be."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_headers(params, boundary):\n    headers = {}\n    boundary = urllib.quote_plus(boundary)\n    headers['Content-Type'] = \"multipart/form-data; boundary=%s\" % boundary\n    headers['Content-Length'] = str(get_body_size(params, boundary))\n    return headers", "response": "Returns a dictionary with Content - Type and Content - Length headers\n    for the multipart form - data encoding of params."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nencodes parameters as multipart / form - data.", "response": "def multipart_encode(params, boundary=None, cb=None):\n    \"\"\"Encode ``params`` as multipart/form-data.\n\n    ``params`` should be a sequence of (name, value) pairs or MultipartParam\n    objects, or a mapping of names to values.\n    Values are either strings parameter values, or file-like objects to use as\n    the parameter value.  The file-like objects must support .read() and either\n    .fileno() or both .seek() and .tell().\n\n    If ``boundary`` is set, then it as used as the MIME boundary.  Otherwise\n    a randomly generated boundary will be used.  In either case, if the\n    boundary string appears in the parameter values a ValueError will be\n    raised.\n\n    If ``cb`` is set, it should be a callback which will get called as blocks\n    of data are encoded.  It will be called with (param, current, total),\n    indicating the current parameter being encoded, the current amount encoded,\n    and the total amount to encode.\n\n    Returns a tuple of `datagen`, `headers`, where `datagen` is a\n    generator that will yield blocks of data that make up the encoded\n    parameters, and `headers` is a dictionary with the assoicated\n    Content-Type and Content-Length headers.\n\n    Examples:\n\n    >>> datagen, headers = multipart_encode( [(\"key\", \"value1\"), (\"key\", \"value2\")] )\n    >>> s = \"\".join(datagen)\n    >>> assert \"value2\" in s and \"value1\" in s\n\n    >>> p = MultipartParam(\"key\", \"value2\")\n    >>> datagen, headers = multipart_encode( [(\"key\", \"value1\"), p] )\n    >>> s = \"\".join(datagen)\n    >>> assert \"value2\" in s and \"value1\" in s\n\n    >>> datagen, headers = multipart_encode( {\"key\": \"value1\"} )\n    >>> s = \"\".join(datagen)\n    >>> assert \"value2\" not in s and \"value1\" in s\n\n    \"\"\"\n    if boundary is None:\n        boundary = gen_boundary()\n    else:\n        boundary = urllib.quote_plus(boundary)\n\n    headers = get_headers(params, boundary)\n    params = MultipartParam.from_params(params)\n\n    return MultipartYielder(params, boundary, cb), headers"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a new MultipartParam object constructed from the local file at filename.", "response": "def from_file(cls, paramname, filename):\n        \"\"\"Returns a new MultipartParam object constructed from the local\n        file at ``filename``.\n\n        ``filesize`` is determined by os.path.getsize(``filename``)\n\n        ``filetype`` is determined by mimetypes.guess_type(``filename``)[0]\n\n        ``filename`` is set to os.path.basename(``filename``)\n        \"\"\"\n\n        return cls(paramname, filename=os.path.basename(filename),\n                   filetype=mimetypes.guess_type(filename)[0],\n                   filesize=os.path.getsize(filename),\n                   fileobj=open(filename, \"rb\"))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a list of MultipartParam objects from a sequence of name value pairs or file objects.", "response": "def from_params(cls, params):\n        \"\"\"Returns a list of MultipartParam objects from a sequence of\n        name, value pairs, MultipartParam instances,\n        or from a mapping of names to values\n\n        The values may be strings or file objects, or MultipartParam objects.\n        MultipartParam object names must match the given names in the\n        name,value pairs or mapping, if applicable.\"\"\"\n        if hasattr(params, 'items'):\n            params = params.items()\n\n        retval = []\n        for item in params:\n            if isinstance(item, cls):\n                retval.append(item)\n                continue\n            name, value = item\n            if isinstance(value, cls):\n                assert value.name == name\n                retval.append(value)\n                continue\n            if hasattr(value, 'read'):\n                # Looks like a file object\n                filename = getattr(value, 'name', None)\n                if filename is not None:\n                    filetype = mimetypes.guess_type(filename)[0]\n                else:\n                    filetype = None\n\n                retval.append(cls(name=name, filename=filename,\n                                  filetype=filetype, fileobj=value))\n            else:\n                retval.append(cls(name, value))\n        return retval"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef encode_hdr(self, boundary):\n        boundary = encode_and_quote(boundary)\n\n        headers = [\"--%s\" % boundary]\n\n        if self.filename:\n            disposition = 'form-data; name=\"%s\"; filename=\"%s\"' % (self.name,\n                                                                   self.filename)\n        else:\n            disposition = 'form-data; name=\"%s\"' % self.name\n\n        headers.append(\"Content-Disposition: %s\" % disposition)\n\n        if self.filetype:\n            filetype = self.filetype\n        else:\n            filetype = \"text/plain; charset=utf-8\"\n\n        headers.append(\"Content-Type: %s\" % filetype)\n\n        headers.append(\"\")\n        headers.append(\"\")\n\n        return \"\\r\\n\".join(headers)", "response": "Returns the header of the encoding of this parameter"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the string encoding of this parameter", "response": "def encode(self, boundary):\n        \"\"\"Returns the string encoding of this parameter\"\"\"\n        if self.value is None:\n            value = self.fileobj.read()\n        else:\n            value = self.value\n\n        if re.search(\"^--%s$\" % re.escape(boundary), value, re.M):\n            raise ValueError(\"boundary found in encoded string\")\n\n        return \"%s%s\\r\\n\" % (self.encode_hdr(boundary), value)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef iter_encode(self, boundary, blocksize=4096):\n        total = self.get_size(boundary)\n        current = 0\n        if self.value is not None:\n            block = self.encode(boundary)\n            current += len(block)\n            yield block\n            if self.cb:\n                self.cb(self, current, total)\n        else:\n            block = self.encode_hdr(boundary)\n            current += len(block)\n            yield block\n            if self.cb:\n                self.cb(self, current, total)\n            last_block = \"\"\n            encoded_boundary = \"--%s\" % encode_and_quote(boundary)\n            boundary_exp = re.compile(\"^%s$\" % re.escape(encoded_boundary),\n                                      re.M)\n            while True:\n                block = self.fileobj.read(blocksize)\n                if not block:\n                    current += 2\n                    yield \"\\r\\n\"\n                    if self.cb:\n                        self.cb(self, current, total)\n                    break\n                last_block += block\n                if boundary_exp.search(last_block):\n                    raise ValueError(\"boundary found in file data\")\n                last_block = last_block[-len(encoded_boundary) - 2:]\n                current += len(block)\n                yield block\n                if self.cb:\n                    self.cb(self, current, total)", "response": "Yields the encoding of this parameter\n           "}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the size in bytes that this param will be encoded with the given boundary.", "response": "def get_size(self, boundary):\n        \"\"\"Returns the size in bytes that this param will be when encoded\n        with the given boundary.\"\"\"\n        if self.filesize is not None:\n            valuesize = self.filesize\n        else:\n            valuesize = len(self.value)\n\n        return len(self.encode_hdr(boundary)) + 2 + valuesize"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef next(self):\n        if self.param_iter is not None:\n            try:\n                block = self.param_iter.next()\n                self.current += len(block)\n                if self.cb:\n                    self.cb(self.p, self.current, self.total)\n                return block\n            except StopIteration:\n                self.p = None\n                self.param_iter = None\n\n        if self.i is None:\n            raise StopIteration\n        elif self.i >= len(self.params):\n            self.param_iter = None\n            self.p = None\n            self.i = None\n            block = \"--%s--\\r\\n\" % self.boundary\n            self.current += len(block)\n            if self.cb:\n                self.cb(self.p, self.current, self.total)\n            return block\n\n        self.p = self.params[self.i]\n        self.param_iter = self.p.iter_encode(self.boundary)\n        self.i += 1\n        return self.next()", "response": "generator function to yield multipart / form - data representation of parameters"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_options(silent=False, hook=True):\n        options_ = {}\n        if silent:\n            options_['silent'] = silent\n        if not hook:\n            options_['hook'] = hook\n        if options_:\n            return '?' + urlencode(options_).lower()\n        else:\n            return ''", "response": "Generates a query string with the appropriate options."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef find(self, item_id, basic=False, **kwargs):\n        if basic:\n            return self.transport.GET(url='/item/%d/basic' % item_id)\n        return self.transport.GET(kwargs, url='/item/%d' % item_id)", "response": "Get item info by ID."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nupdating the item with the supplied attributes.", "response": "def update(self, item_id, attributes, silent=False, hook=True):\n        \"\"\"\n        Updates the item using the supplied attributes. If 'silent' is true, Podio will send\n        no notifications to subscribed users and not post updates to the stream.\n        \n        Important: webhooks will still be called.\n        \"\"\"\n        if not isinstance(attributes, dict):\n            raise TypeError('Must be of type dict')\n        attributes = json.dumps(attributes)\n        return self.transport.PUT(body=attributes,\n                                  type='application/json',\n                                  url='/item/%d%s' % (item_id, self.get_options(silent=silent,\n                                                                                hook=hook)))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate a new task using the supplied attributes.", "response": "def create(self, attributes, silent=False, hook=True):\n        \"\"\"\n        https://developers.podio.com/doc/tasks/create-task-22419\n        Creates the task using the supplied attributes. If 'silent' is true,\n        Podio will send no notifications to subscribed users and not post\n        updates to the stream. If 'hook' is false webhooks will not be called.\n        \"\"\"\n        # if not isinstance(attributes, dict):\n        #    raise TypeError('Must be of type dict')\n        attributes = json.dumps(attributes)\n        return self.transport.POST(url='/task/%s' % self.get_options(silent=silent, hook=hook),\n                                   body=attributes,\n                                   type='application/json')"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef create_for(self, ref_type, ref_id, attributes, silent=False, hook=True):\n        # if not isinstance(attributes, dict):\n        #    raise TypeError('Must be of type dict')\n        attributes = json.dumps(attributes)\n        return self.transport.POST(body=attributes,\n                                   type='application/json',\n                                   url='/task/%s/%s/%s' % (ref_type, ref_id,\n                                                           self.get_options(silent=silent,\n                                                                            hook=hook)))", "response": "Create a new task with the given attributes."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a space ID given the URL of the space.", "response": "def find_by_url(self, space_url, id_only=True):\n        \"\"\"\n        Returns a space ID given the URL of the space.\n\n        :param space_url: URL of the Space\n        :param id_only: ?\n        :return: space_id: Space url\n        :rtype: str\n        \"\"\"\n        resp = self.transport.GET(url='/space/url?%s' % urlencode({'url': space_url}))\n        if id_only:\n            return resp['space_id']\n        return resp"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef create(self, attributes):\n        if not isinstance(attributes, dict):\n            raise TypeError('Dictionary of values expected')\n        attributes = json.dumps(attributes)\n        return self.transport.POST(url='/space/', body=attributes, type='application/json')", "response": "Create a new space with the given attributes."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn an object of type item status or task as a stream object.", "response": "def find_by_ref(self, ref_type, ref_id):\n        \"\"\"\n        Returns an object of type \"item\", \"status\" or \"task\" as a\n        stream object. This is useful when a new status has been\n        posted and should be rendered directly in the stream without\n        reloading the entire stream.\n\n        For details, see: https://developers.podio.com/doc/stream/get-stream-object-80054\n        \"\"\"\n        return self.transport.GET(url='/stream/%s/%s' % (ref_type, ref_id))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef find_raw(self, file_id):\n        raw_handler = lambda resp, data: data\n        return self.transport.GET(url='/file/%d/raw' % file_id, handler=raw_handler)", "response": "Returns raw file as string. Pass to a file object"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncreates a file from raw data", "response": "def create(self, filename, filedata):\n        \"\"\"Create a file from raw data\"\"\"\n        attributes = {'filename': filename,\n                      'source': filedata}\n        return self.transport.POST(url='/file/v2/', body=attributes, type='multipart/form-data')"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nretrieve the definition of a given view.", "response": "def get(self, app_id, view_specifier):\n        \"\"\"\n        Retrieve the definition of a given view, provided the app_id and the view_id\n\n        :param app_id: the app id\n        :param view_specifier:\n            Can be one of the following:\n            1. The view ID\n            2. The view's name\n            3. \"last\" to look up the last view used\n        \"\"\"\n        return self.transport.GET(url='/view/app/{}/{}'.format(app_id, view_specifier))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_views(self, app_id, include_standard_views=False):\n        include_standard = \"true\" if include_standard_views is True else \"false\"\n        return self.transport.GET(url='/view/app/{}/?include_standard_views={}'.format(app_id, include_standard))", "response": "Get all of the views for the app with the specified app_id."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef update_last_view(self, app_id, attributes):\n        if not isinstance(attributes, dict):\n            raise TypeError('Must be of type dict')\n        attribute_data = json.dumps(attributes)\n        return self.transport.PUT(url='/view/app/{}/last'.format(app_id),\n                                  body=attribute_data, type='application/json')", "response": "Updates the last view for the active user."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nupdate an existing view with the attributes supplied via the attributes parameter.", "response": "def update_view(self, view_id, attributes):\n        \"\"\"\n        Update an existing view using the details supplied via the attributes parameter\n\n        :param view_id: the view's id\n        :param attributes: a dictionary containing the modifications to be made to the view\n        :return:\n        \"\"\"\n        if not isinstance(attributes, dict):\n            raise TypeError('Must be of type dict')\n        attribute_data = json.dumps(attributes)\n        return self.transport.PUT(url='/view/{}'.format(view_id),\n                                  body=attribute_data, type='application/json')"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nchecking if a user is active on the current system.", "response": "def is_active(self, timeout=2):\n        \"\"\"\n        :param timeout: int\n        :return: boolean\n        \"\"\"\n        try:\n            result = Result(*self.perform_request('HEAD', '/', params={'request_timeout': timeout}))\n        except ConnectionError:\n            return False\n        except TransportError:\n            return False\n\n        if result.response.status_code == 200:\n            return True\n\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef query(self, sql, timeout=10):\n        if not sql:\n            raise QueryError('No query passed to drill.')\n\n        result = ResultQuery(*self.perform_request(**{\n            'method': 'POST',\n            'url': '/query.json',\n            'body': {\n                \"queryType\": \"SQL\",\n                \"query\": sql\n            },\n            'params': {\n                'request_timeout': timeout\n            }\n        }))\n\n        return result", "response": "Submit a query and return results."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef plan(self, sql, timeout=10):\n        sql = 'explain plan for ' + sql\n        return self.query(sql, timeout)", "response": "Execute an explain plan query."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef storage_detail(self, name, timeout=10):\n        result = Result(*self.perform_request(**{\n            'method': 'GET',\n            'url': '/storage/{0}.json'.format(name),\n            'params': {\n                'request_timeout': timeout\n            }\n        }))\n        return result", "response": "Get the definition of the named storage plugin."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef storage_enable(self, name, value=True, timeout=10):\n        value = 'true' if value else 'false'\n        result = Result(*self.perform_request(**{\n            'method': 'GET',\n            'url': '/storage/{0}/enable/{1}'.format(name, value),\n            'params': {\n                'request_timeout': timeout\n            }\n        }))\n        return result", "response": "Enable or disable the named storage plugin."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating or update a storage plugin configuration.", "response": "def storage_update(self, name, config, timeout=10):\n        \"\"\"\n        Create or update a storage plugin configuration.\n\n        :param name: The name of the storage plugin configuration to create or update.\n        :param config: Overwrites the existing configuration if there is any, and therefore, must include all\n        required attributes and definitions.\n        :param timeout: int\n        :return: pydrill.client.Result\n        \"\"\"\n        result = Result(*self.perform_request(**{\n            'method': 'POST',\n            'url': '/storage/{0}.json'.format(name),\n            'body': config,\n            'params': {\n                'request_timeout': timeout\n            }\n        }))\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef storage_delete(self, name, timeout=10):\n        result = Result(*self.perform_request(**{\n            'method': 'DELETE',\n            'url': '/storage/{0}.json'.format(name),\n            'params': {\n                'request_timeout': timeout\n            }\n        }))\n        return result", "response": "Delete a storage plugin configuration."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef profile(self, query_id, timeout=10):\n        result = Result(*self.perform_request(**{\n            'method': 'GET',\n            'url': '/profiles/{0}.json'.format(query_id),\n            'params': {\n                'request_timeout': timeout\n            }\n        }))\n        return result", "response": "Get the profile of the query that has the given queryid."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef profile_cancel(self, query_id, timeout=10):\n        result = Result(*self.perform_request(**{\n            'method': 'GET',\n            'url': '/profiles/cancel/{0}'.format(query_id),\n            'params': {\n                'request_timeout': timeout\n            }\n        }))\n        return result", "response": "Cancel the query that has the given queryid."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nlogs a successful API call.", "response": "def log_request_success(self, method, full_url, path, body, status_code, response, duration):\n        \"\"\" Log a successful API call.  \"\"\"\n\n        if body and not isinstance(body, dict):\n            body = body.decode('utf-8')\n\n        logger.info(\n            '%s %s [status:%s request:%.3fs]', method, full_url,\n            status_code, duration\n        )\n        logger.debug('> %s', body)\n        logger.debug('< %s', response)\n\n        if tracer.isEnabledFor(logging.INFO):\n            if self.url_prefix:\n                path = path.replace(self.url_prefix, '', 1)\n            tracer.info(\"curl -X%s 'http://localhost:8047%s' -d '%s'\", method, path,\n                        self._pretty_json(body) if body else '')\n\n        if tracer.isEnabledFor(logging.DEBUG):\n            tracer.debug('#[%s] (%.3fs)\\n#%s', status_code, duration,\n                         self._pretty_json(response).replace('\\n', '\\n#') if response else '')"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nlog an unsuccessful API call.", "response": "def log_request_fail(self, method, full_url, body, duration, status_code=None, exception=None):\n        \"\"\"\n        Log an unsuccessful API call.\n        \"\"\"\n        logger.warning(\n            '%s %s [status:%s request:%.3fs]', method, full_url,\n            status_code or 'N/A', duration, exc_info=exception is not None\n        )\n\n        if body and not isinstance(body, dict):\n            body = body.decode('utf-8')\n\n        logger.debug('> %s', body)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nraising an exception if it exists.", "response": "def _raise_error(self, status_code, raw_data):\n        \"\"\"\n        Locate appropriate exception and raise it.\n        \"\"\"\n        error_message = raw_data\n        additional_info = None\n        try:\n            additional_info = json.loads(raw_data)\n            error_message = additional_info.get('error', error_message)\n            if isinstance(error_message, dict) and 'type' in error_message:\n                error_message = error_message['type']\n        except:\n            pass\n\n        raise HTTP_EXCEPTIONS.get(status_code, TransportError)(status_code, error_message, additional_info)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef perform_request(self, method, url, params=None, body=None):\n        if body is not None:\n            body = self.serializer.dumps(body)\n\n            # some clients or environments don't support sending GET with body\n            if method in ('HEAD', 'GET') and self.send_get_body_as != 'GET':\n                # send it as post instead\n                if self.send_get_body_as == 'POST':\n                    method = 'POST'\n\n                # or as source parameter\n                elif self.send_get_body_as == 'source':\n                    if params is None:\n                        params = {}\n                    params['source'] = body\n                    body = None\n\n        if body is not None:\n            try:\n                body = body.encode('utf-8')\n            except (UnicodeDecodeError, AttributeError):\n                # bytes/str - no need to re-encode\n                pass\n\n        ignore = ()\n        timeout = None\n        if params:\n            timeout = params.pop('request_timeout', None)\n            ignore = params.pop('ignore', ())\n            if isinstance(ignore, int):\n                ignore = (ignore,)\n\n        for attempt in range(self.max_retries + 1):\n            connection = self.get_connection()\n\n            try:\n                response, data, duration = connection.perform_request(method, url, params, body, ignore=ignore,\n                                                                      timeout=timeout)\n            except TransportError as e:\n                retry = False\n                if isinstance(e, ConnectionTimeout):\n                    retry = self.retry_on_timeout\n                elif isinstance(e, ConnectionError):\n                    retry = True\n                elif e.status_code in self.retry_on_status:\n                    retry = True\n\n                if retry:\n                    if attempt == self.max_retries:\n                        raise\n                else:\n                    raise\n            else:\n                if data:\n                    data = self.deserializer.loads(data, mimetype=response.headers.get('Content-Type'))\n                else:\n                    data = {}\n                return response, data, duration", "response": "Perform a request to the specified url and return the response."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating a new release.", "response": "def release(ctx, type_, repo, prebump=PREBUMP, config_file=None, commit=True, yes=False):\n    \"\"\"Make a new release.\n    \"\"\"\n    if prebump not in REL_TYPES:\n        raise ValueError(f\"{type_} not in {REL_TYPES}\")\n    prebump = REL_TYPES.index(prebump)\n\n    version = _read_version()\n    version = _bump_release(version, type_)\n    _write_version(version)\n\n    # Needs to happen before Towncrier deletes fragment files.\n    tag_content = _render_log()\n\n    ctx.run(\"towncrier\")\n\n    if commit:\n        ctx.run(f'git commit -am \"Release {version}\"')\n\n        tag_content = tag_content.replace('\"', '\\\\\"')\n        ctx.run(f'git tag -a {version} -m \"Version {version}\\n\\n{tag_content}\"')\n\n    ctx.run(f\"python setup.py sdist bdist_wheel\")\n\n    dist_pattern = f'{PACKAGE_NAME.replace(\"-\", \"[-_]\")}-*'\n    artifacts = list(ROOT.joinpath(\"dist\").glob(dist_pattern))\n    filename_display = \"\\n\".join(f\"  {a}\" for a in artifacts)\n    print(f\"[release] Will upload:\\n{filename_display}\")\n    if not yes:\n        try:\n            input(\"[release] Release ready. ENTER to upload, CTRL-C to abort: \")\n        except KeyboardInterrupt:\n            print(\"\\nAborted!\")\n            return\n\n    arg_display = \" \".join(f'\"{n}\"' for n in artifacts)\n    cmd = f'twine upload --repository=\"{repo}\"'\n    if config_file:\n        cmd = f'{cmd} --config-file=\"{config_file}\"'\n    cmd = f\"{cmd} {arg_display}\"\n    ctx.run(cmd)\n\n    version = _prebump(version, prebump)\n    _write_version(version)\n    if commit:\n        ctx.run(f'git commit -am \"Prebump to {version}\"')"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ninitialize menu before first request.", "response": "def init_menu():\n    \"\"\"Initialize menu before first request.\"\"\"\n    # Register breadcrumb root\n    item = current_menu.submenu('breadcrumbs.settings')\n    item.register('', _('Account'))\n    item = current_menu.submenu('breadcrumbs.{0}'.format(\n        current_app.config['SECURITY_BLUEPRINT_NAME']))\n\n    if current_app.config.get('SECURITY_CHANGEABLE', True):\n        item.register('', _('Change password'))\n\n        # Register settings menu\n        item = current_menu.submenu('settings.change_password')\n        item.register(\n            \"{0}.change_password\".format(\n                current_app.config['SECURITY_BLUEPRINT_NAME']),\n            # NOTE: Menu item text (icon replaced by a user icon).\n            _('%(icon)s Change password',\n                icon='<i class=\"fa fa-key fa-fw\"></i>'),\n            order=1)\n\n        # Register breadcrumb\n        item = current_menu.submenu('breadcrumbs.{0}.change_password'.format(\n            current_app.config['SECURITY_BLUEPRINT_NAME']))\n        item.register(\n            \"{0}.change_password\".format(\n                current_app.config['SECURITY_BLUEPRINT_NAME']),\n            _(\"Change password\"),\n            order=0,\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nwarns if session cookie is not secure in production.", "response": "def check_security_settings():\n    \"\"\"Warn if session cookie is not secure in production.\"\"\"\n    in_production = not (current_app.debug or current_app.testing)\n    secure = current_app.config.get('SESSION_COOKIE_SECURE')\n    if in_production and not secure:\n        current_app.logger.warning(\n            \"SESSION_COOKIE_SECURE setting must be set to True to prevent the \"\n            \"session cookie from being leaked over an insecure channel.\"\n        )"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef jwt_proccessor():\n    def jwt():\n        \"\"\"Context processor function to generate jwt.\"\"\"\n        token = current_accounts.jwt_creation_factory()\n        return Markup(\n            render_template(\n                current_app.config['ACCOUNTS_JWT_DOM_TOKEN_TEMPLATE'],\n                token=token\n            )\n        )\n\n    def jwt_token():\n        \"\"\"Context processor function to generate jwt.\"\"\"\n        return current_accounts.jwt_creation_factory()\n\n    return {\n        'jwt': jwt,\n        'jwt_token': jwt_token,\n    }", "response": "Context processor for jwt."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _mysql_aes_key(key):\n    final_key = bytearray(16)\n    for i, c in enumerate(key):\n        final_key[i % 16] ^= key[i] if PY3 else ord(key[i])\n    return bytes(final_key)", "response": "Format key for MySQL AES."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\npad a string to 16 bytes.", "response": "def _mysql_aes_pad(val):\n    \"\"\"Padding.\"\"\"\n    val = _to_string(val)\n    pad_value = 16 - (len(val) % 16)\n    return _to_binary('{0}{1}'.format(val, chr(pad_value) * pad_value))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef from_string(cls, hash, **context):\n        salt, checksum = parse_mc2(hash, cls.ident, handler=cls)\n\n        return cls(salt=salt, checksum=checksum)", "response": "Parse an instance from a string in Modular Crypt Format."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncalculates string. :param secret: The secret key. :returns: The checksum.", "response": "def _calc_checksum(self, secret):\n        \"\"\"Calculate string.\n\n        :param secret: The secret key.\n        :returns: The checksum.\n        \"\"\"\n        return str_to_uascii(\n            hashlib.sha256(mysql_aes_encrypt(self.salt, secret)).hexdigest()\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nextract extra informations from user agent.", "response": "def _extract_info_from_useragent(user_agent):\n    \"\"\"Extract extra informations from user.\"\"\"\n    parsed_string = user_agent_parser.Parse(user_agent)\n    return {\n        'os': parsed_string.get('os', {}).get('family'),\n        'browser': parsed_string.get('user_agent', {}).get('family'),\n        'browser_version': parsed_string.get('user_agent', {}).get('major'),\n        'device': parsed_string.get('device', {}).get('family'),\n    }"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef add_session(session=None):\n    user_id, sid_s = session['user_id'], session.sid_s\n    with db.session.begin_nested():\n        session_activity = SessionActivity(\n            user_id=user_id,\n            sid_s=sid_s,\n            ip=request.remote_addr,\n            country=_ip2country(request.remote_addr),\n            **_extract_info_from_useragent(\n                request.headers.get('User-Agent', '')\n            )\n        )\n        db.session.merge(session_activity)", "response": "r Add a session to the SessionActivity table."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef login_listener(app, user):\n    @after_this_request\n    def add_user_session(response):\n        \"\"\"Regenerate current session and add to the SessionActivity table.\n\n        .. note:: `flask.session.regenerate()` actually calls Flask-KVSession's\n            `flask_kvsession.KVSession.regenerate`.\n        \"\"\"\n        # Regenerate the session to avoid session fixation vulnerabilities.\n        session.regenerate()\n        # Save the session first so that the sid_s gets generated.\n        app.session_interface.save_session(app, session, response)\n        add_session(session)\n        current_accounts.datastore.commit()\n        return response", "response": "Connect to the user_logged_in signal for table population."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef logout_listener(app, user):\n    @after_this_request\n    def _commit(response=None):\n        if hasattr(session, 'sid_s'):\n            delete_session(session.sid_s)\n        # Regenerate the session to avoid session fixation vulnerabilities.\n        session.regenerate()\n        current_accounts.datastore.commit()\n        return response", "response": "Connect to the user_logged_out signal."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef delete_session(sid_s):\n    # Remove entries from sessionstore\n    _sessionstore.delete(sid_s)\n    # Find and remove the corresponding SessionActivity entry\n    with db.session.begin_nested():\n        SessionActivity.query.filter_by(sid_s=sid_s).delete()\n    return 1", "response": "Delete the session with the given sid_s."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ndeleting all active user sessions.", "response": "def delete_user_sessions(user):\n    \"\"\"Delete all active user sessions.\n\n    :param user: User instance.\n    :returns: If ``True`` then the session is successfully deleted.\n    \"\"\"\n    with db.session.begin_nested():\n        for s in user.active_sessions:\n            _sessionstore.delete(s.sid_s)\n\n        SessionActivity.query.filter_by(user=user).delete()\n\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns confirmation for extended registration form.", "response": "def confirm_register_form_factory(Form, app):\n    \"\"\"Return confirmation for extended registration form.\"\"\"\n    if app.config.get('RECAPTCHA_PUBLIC_KEY') and \\\n            app.config.get('RECAPTCHA_PRIVATE_KEY'):\n        class ConfirmRegisterForm(Form):\n            recaptcha = FormField(RegistrationFormRecaptcha, separator='.')\n\n        return ConfirmRegisterForm\n\n    return Form"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef register_form_factory(Form, app):\n    if app.config.get('RECAPTCHA_PUBLIC_KEY') and \\\n            app.config.get('RECAPTCHA_PRIVATE_KEY'):\n        class RegisterForm(Form):\n            recaptcha = FormField(RegistrationFormRecaptcha, separator='.')\n\n        return RegisterForm\n\n    return Form", "response": "Return extended registration form."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning extended login form.", "response": "def login_form_factory(Form, app):\n    \"\"\"Return extended login form.\"\"\"\n    class LoginForm(Form):\n\n        def __init__(self, *args, **kwargs):\n            \"\"\"Init the login form.\n\n            .. note::\n\n                The ``remember me`` option will be completely disabled.\n            \"\"\"\n            super(LoginForm, self).__init__(*args, **kwargs)\n            self.remember.data = False\n\n    return LoginForm"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nhashes password when saving.", "response": "def on_model_change(self, form, User, is_created):\n        \"\"\"Hash password when saving.\"\"\"\n        if form.password.data is not None:\n            pwd_ctx = current_app.extensions['security'].pwd_context\n            if pwd_ctx.identify(form.password.data) is None:\n                User.password = hash_password(form.password.data)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsends password instructions if desired.", "response": "def after_model_change(self, form, User, is_created):\n        \"\"\"Send password instructions if desired.\"\"\"\n        if is_created and form.notification.data is True:\n            send_reset_password_instructions(User)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef delete_model(self, model):\n        if SessionActivity.is_current(sid_s=model.sid_s):\n            flash('You could not remove your current session', 'error')\n            return\n        delete_session(sid_s=model.sid_s)\n        db.session.commit()", "response": "Delete a specific session."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef send_security_email(data):\n    msg = Message()\n    msg.__dict__.update(data)\n    current_app.extensions['mail'].send(msg)", "response": "Celery task to send security email."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef clean_session_table():\n    sessions = SessionActivity.query_by_expired().all()\n    for session in sessions:\n        delete_session(sid_s=session.sid_s)\n    db.session.commit()", "response": "Automatically clean the session table."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef jwt_create_token(user_id=None, additional_data=None):\n    # Create an ID\n    uid = str(uuid.uuid4())\n    # The time in UTC now\n    now = datetime.utcnow()\n    # Build the token data\n    token_data = {\n        'exp': now + current_app.config['ACCOUNTS_JWT_EXPIRATION_DELTA'],\n        'sub': user_id or current_user.get_id(),\n        'jti': uid,\n    }\n    # Add any additional data to the token\n    if additional_data is not None:\n        token_data.update(additional_data)\n\n    # Encode the token and send it back\n    encoded_token = encode(\n        token_data,\n        current_app.config['ACCOUNTS_JWT_SECRET_KEY'],\n        current_app.config['ACCOUNTS_JWT_ALOGORITHM']\n    ).decode('utf-8')\n    return encoded_token", "response": "Encode the JWT token."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef jwt_decode_token(token):\n    try:\n        return decode(\n            token,\n            current_app.config['ACCOUNTS_JWT_SECRET_KEY'],\n            algorithms=[\n                current_app.config['ACCOUNTS_JWT_ALOGORITHM']\n            ]\n        )\n    except DecodeError as exc:\n        raise_from(JWTDecodeError(), exc)\n    except ExpiredSignatureError as exc:\n        raise_from(JWTExpiredToken(), exc)", "response": "Decode the JWT token."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nadding X - Session - ID and X - User - ID to http response.", "response": "def set_session_info(app, response, **extra):\n    \"\"\"Add X-Session-ID and X-User-ID to http response.\"\"\"\n    session_id = getattr(session, 'sid_s', None)\n    if session_id:\n        response.headers['X-Session-ID'] = session_id\n    if current_user.is_authenticated:\n        response.headers['X-User-ID'] = current_user.get_id()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef security():\n    sessions = SessionActivity.query_by_user(\n        user_id=current_user.get_id()\n    ).all()\n    master_session = None\n    for index, session in enumerate(sessions):\n        if SessionActivity.is_current(session.sid_s):\n            master_session = session\n            del sessions[index]\n    return render_template(\n        current_app.config['ACCOUNTS_SETTINGS_SECURITY_TEMPLATE'],\n        formclass=RevokeForm,\n        sessions=[master_session] + sessions,\n        is_current=SessionActivity.is_current\n    )", "response": "View for security page."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nupgrade database to version 80.", "response": "def upgrade():\n    \"\"\"Upgrade database.\"\"\"\n    with op.batch_alter_table('accounts_user_session_activity') as batch_op:\n        batch_op.add_column(sa.Column('browser', sa.String(80), nullable=True))\n        batch_op.add_column(\n            sa.Column('browser_version', sa.String(30), nullable=True))\n        batch_op.add_column(\n            sa.Column('country', sa.String(3), nullable=True))\n        batch_op.add_column(\n            sa.Column('device', sa.String(80), nullable=True))\n        batch_op.add_column(\n            sa.Column('ip', sa.String(80), nullable=True))\n        batch_op.add_column(\n            sa.Column('os', sa.String(80), nullable=True))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nquery to select all expired sessions.", "response": "def query_by_expired(cls):\n        \"\"\"Query to select all expired sessions.\"\"\"\n        lifetime = current_app.permanent_session_lifetime\n        expired_moment = datetime.utcnow() - lifetime\n        return cls.query.filter(cls.created < expired_moment)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nmonkeys - patch Flask - Security.", "response": "def monkey_patch_flask_security():\n        \"\"\"Monkey-patch Flask-Security.\"\"\"\n        if utils.get_hmac != get_hmac:\n            utils.get_hmac = get_hmac\n        if utils.hash_password != hash_password:\n            utils.hash_password = hash_password\n            changeable.hash_password = hash_password\n            recoverable.hash_password = hash_password\n            registerable.hash_password = hash_password\n\n        # Disable remember me cookie generation as it does not work with\n        # session activity tracking (a remember me token will bypass revoking\n        # of  a session).\n        def patch_do_nothing(*args, **kwargs):\n            pass\n        LoginManager._set_cookie = patch_do_nothing\n\n        # Disable loading user from headers and object because we want to be\n        # sure we can load user only through the login form.\n        def patch_reload_anonym(self, *args, **kwargs):\n            self.reload_user()\n        LoginManager._load_from_header = patch_reload_anonym\n        LoginManager._load_from_request = patch_reload_anonym"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef init_app(self, app, sessionstore=None, register_blueprint=True):\n        self.init_config(app)\n\n        # Monkey-patch Flask-Security\n        InvenioAccounts.monkey_patch_flask_security()\n\n        # Create user datastore\n        if not self.datastore:\n            self.datastore = SessionAwareSQLAlchemyUserDatastore(\n                db, User, Role)\n\n        if app.config['ACCOUNTS_SESSION_ACTIVITY_ENABLED']:\n            self._enable_session_activity(app=app)\n\n        # Initialize extension.\n        _register_blueprint = app.config.get('ACCOUNTS_REGISTER_BLUEPRINT')\n        if _register_blueprint is not None:\n            register_blueprint = _register_blueprint\n\n        state = self.security.init_app(app, datastore=self.datastore,\n                                       register_blueprint=register_blueprint)\n\n        self.register_anonymous_identity_loader(state)\n\n        app.extensions['security'].register_form = register_form_factory(\n            app.extensions['security'].register_form, app)\n\n        app.extensions['security'].confirm_register_form = \\\n            confirm_register_form_factory(\n                app.extensions['security'].confirm_register_form, app\n            )\n\n        app.extensions['security'].login_form = login_form_factory(\n            app.extensions['security'].login_form, app)\n\n        if app.config['ACCOUNTS_USE_CELERY']:\n            from invenio_accounts.tasks import send_security_email\n\n            @state.send_mail_task\n            def delay_security_email(msg):\n                send_security_email.delay(msg.__dict__)\n\n        # Register context processor\n        if app.config['ACCOUNTS_JWT_DOM_TOKEN']:\n            from invenio_accounts.context_processors.jwt import \\\n                jwt_proccessor\n            app.context_processor(jwt_proccessor)\n\n        # Register signal receiver\n        if app.config.get('ACCOUNTS_USERINFO_HEADERS'):\n            request_finished.connect(set_session_info, app)\n\n        app.extensions['invenio-accounts'] = self", "response": "Flask application initialization.\n\n        The following actions are executed:\n\n        #. Initialize the configuration.\n\n        #. Monkey-patch Flask-Security.\n\n        #. Create the user datastore.\n\n        #. Create the sessionstore.\n\n        #. Initialize the extension, the forms to register users and\n           confirms their emails, the CLI and, if ``ACCOUNTS_USE_CELERY`` is\n           ``True``, register a celery task to send emails.\n\n        :param app: The Flask application.\n        :param sessionstore: store for sessions. Passed to\n            ``flask-kvsession``. If ``None`` then Redis is configured.\n            (Default: ``None``)\n        :param register_blueprint: If ``True``, the application registers the\n            blueprints. (Default: ``True``)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ninitialize configuration. :param app: The Flask application.", "response": "def init_config(self, app):\n        \"\"\"Initialize configuration.\n\n        :param app: The Flask application.\n        \"\"\"\n        try:\n            pkg_resources.get_distribution('celery')\n            app.config.setdefault(\n                \"ACCOUNTS_USE_CELERY\", not (app.debug or app.testing))\n        except pkg_resources.DistributionNotFound:  # pragma: no cover\n            app.config.setdefault(\"ACCOUNTS_USE_CELERY\", False)\n\n        # Register Invenio legacy password hashing\n        register_crypt_handler(InvenioAesEncryptedEmail)\n\n        # Change Flask defaults\n        app.config.setdefault(\n            'SESSION_COOKIE_SECURE',\n            not app.debug\n        )\n\n        # Change Flask-Security defaults\n        app.config.setdefault(\n            'SECURITY_PASSWORD_SALT',\n            app.config['SECRET_KEY']\n        )\n\n        # Set JWT secret key\n        app.config.setdefault(\n            'ACCOUNTS_JWT_SECRET_KEY',\n            app.config.get(\n                'ACCOUNTS_JWT_SECRET_KEY',\n                app.config.get('SECRET_KEY')\n            )\n        )\n\n        config_apps = ['ACCOUNTS', 'SECURITY_']\n        for k in dir(config):\n            if any([k.startswith(prefix) for prefix in config_apps]):\n                app.config.setdefault(k, getattr(config, k))\n\n        # Set Session KV store\n        if app.config.get('ACCOUNTS_SESSION_REDIS_URL'):\n            import redis\n            from simplekv.memory.redisstore import RedisStore\n\n            session_kvstore = RedisStore(redis.StrictRedis.from_url(\n                app.config['ACCOUNTS_SESSION_REDIS_URL']))\n        else:\n            from simplekv.memory import DictStore\n\n            session_kvstore = DictStore()\n\n        self.kvsession_extension = KVSessionExtension(\n            session_kvstore, app)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef init_app(self, app, sessionstore=None, register_blueprint=False):\n        return super(InvenioAccountsREST, self).init_app(\n            app, sessionstore=sessionstore,\n            register_blueprint=register_blueprint,\n        )", "response": "Flask application initialization.\n\n        :param app: The Flask application.\n        :param sessionstore: store for sessions. Passed to\n            ``flask-kvsession``. If ``None`` then Redis is configured.\n            (Default: ``None``)\n        :param register_blueprint: If ``True``, the application registers the\n            blueprints. (Default: ``True``)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nflasks application initialization. :param app: The Flask application. :param sessionstore: store for sessions. Passed to ``flask-kvsession``. If ``None`` then Redis is configured. (Default: ``None``) :param register_blueprint: If ``True``, the application registers the blueprints. (Default: ``True``)", "response": "def init_app(self, app, sessionstore=None, register_blueprint=True):\n        \"\"\"Flask application initialization.\n\n        :param app: The Flask application.\n        :param sessionstore: store for sessions. Passed to\n            ``flask-kvsession``. If ``None`` then Redis is configured.\n            (Default: ``None``)\n        :param register_blueprint: If ``True``, the application registers the\n            blueprints. (Default: ``True``)\n        \"\"\"\n        self.make_session_permanent(app)\n        return super(InvenioAccountsUI, self).init_app(\n            app, sessionstore=sessionstore,\n            register_blueprint=register_blueprint\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef deactivate_user(self, user):\n        res = super(SessionAwareSQLAlchemyUserDatastore, self).deactivate_user(\n            user)\n        if res:\n            delete_user_sessions(user)\n        return res", "response": "Deactivate a  user.\n\n        :param user: A :class:`invenio_accounts.models.User` instance.\n        :returns: The datastore instance."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _initialize_attributes(model_class, name, bases, attrs):\n    model_class._attributes = {}\n    for k, v in attrs.iteritems():\n        if isinstance(v, Attribute):\n            model_class._attributes[k] = v\n            v.name = v.name or k", "response": "Initialize the attributes of the model class."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _initialize_referenced(model_class, attribute):\n    # this should be a descriptor\n    def _related_objects(self):\n        return (model_class.objects\n                .filter(**{attribute.attname: self.id}))\n\n    klass = attribute._target_type\n    if isinstance(klass, basestring):\n        return (klass, model_class, attribute)\n    else:\n        related_name = (attribute.related_name or\n                model_class.__name__.lower() + '_set')\n        setattr(klass, related_name,\n                property(_related_objects))", "response": "Adds a property to the target of a reference field that returns the list of associated objects."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nstore the list fields descriptors of a model.", "response": "def _initialize_lists(model_class, name, bases, attrs):\n    \"\"\"Stores the list fields descriptors of a model.\"\"\"\n    model_class._lists = {}\n    for k, v in attrs.iteritems():\n        if isinstance(v, ListField):\n            model_class._lists[k] = v\n            v.name = v.name or k"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nstore the list of reference field descriptors of a model.", "response": "def _initialize_references(model_class, name, bases, attrs):\n    \"\"\"Stores the list of reference field descriptors of a model.\"\"\"\n    model_class._references = {}\n    h = {}\n    deferred = []\n    for k, v in attrs.iteritems():\n        if isinstance(v, ReferenceField):\n            model_class._references[k] = v\n            v.name = v.name or k\n            att = Attribute(name=v.attname)\n            h[v.attname] = att\n            setattr(model_class, v.attname, att)\n            refd = _initialize_referenced(model_class, v)\n            if refd:\n                deferred.append(refd)\n    attrs.update(h)\n    return deferred"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nstore the list of indexed attributes.", "response": "def _initialize_indices(model_class, name, bases, attrs):\n    \"\"\"Stores the list of indexed attributes.\"\"\"\n    model_class._indices = []\n    for k, v in attrs.iteritems():\n        if isinstance(v, (Attribute, ListField)) and v.indexed:\n            model_class._indices.append(k)\n    if model_class._meta['indices']:\n        model_class._indices.extend(model_class._meta['indices'])"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _initialize_counters(model_class, name, bases, attrs):\n    model_class._counters = []\n    for k, v in attrs.iteritems():\n        if isinstance(v, Counter):\n            model_class._counters.append(k)", "response": "Stores the list of counter fields."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the model from a given key.", "response": "def get_model_from_key(key):\n    \"\"\"Gets the model from a given key.\"\"\"\n    _known_models = {}\n    model_name = key.split(':', 2)[0]\n    # populate\n    for klass in Model.__subclasses__():\n        _known_models[klass.__name__] = klass\n    return _known_models.get(model_name, None)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef from_key(key):\n    model = get_model_from_key(key)\n    if model is None:\n        raise BadKeyError\n    try:\n        _, id = key.split(':', 2)\n        id = int(id)\n    except ValueError, TypeError:\n        raise BadKeyError\n    return model.objects.get_by_id(id)", "response": "Returns the model instance based on the key."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef is_valid(self):\n        self._errors = []\n        for field in self.fields:\n            try:\n                field.validate(self)\n            except FieldValidationError, e:\n                self._errors.extend(e.errors)\n        self.validate()\n        return not bool(self._errors)", "response": "Returns True if all the fields are valid."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef update_attributes(self, **kwargs):\n        attrs = self.attributes.values() + self.lists.values() \\\n                + self.references.values()\n        for att in attrs:\n            if att.name in kwargs:\n                att.__set__(self, kwargs[att.name])", "response": "Updates the attributes of the model."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nsave the instance to the datastore.", "response": "def save(self):\n        \"\"\"Saves the instance to the datastore.\"\"\"\n        if not self.is_valid():\n            return self._errors\n        _new = self.is_new()\n        if _new:\n            self._initialize_id()\n        with Mutex(self):\n            self._write(_new)\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef key(self, att=None):\n        if att is not None:\n            return self._key[self.id][att]\n        else:\n            return self._key[self.id]", "response": "Returns the Redis key where the values are stored."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef delete(self):\n        pipeline = self.db.pipeline()\n        self._delete_from_indices(pipeline)\n        self._delete_membership(pipeline)\n        pipeline.delete(self.key())\n        pipeline.execute()", "response": "Deletes the object from the datastore."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef attributes_dict(self):\n        h = {}\n        for k in self.attributes.keys():\n            h[k] = getattr(self, k)\n        for k in self.lists.keys():\n            h[k] = getattr(self, k)\n        for k in self.references.keys():\n            h[k] = getattr(self, k)\n        return h", "response": "Returns the mapping of the model attributes and their\n        values."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the list of field names of the model.", "response": "def fields(self):\n        \"\"\"Returns the list of field names of the model.\"\"\"\n        return (self.attributes.values() + self.lists.values()\n                + self.references.values())"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncheck if the model with id exists.", "response": "def exists(cls, id):\n        \"\"\"Checks if the model with id exists.\"\"\"\n        return bool(redisco.get_client().exists(cls._key[str(id)]) or\n                    redisco.get_client().sismember(cls._key['all'], str(id)))"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ninitializes the id of the instance.", "response": "def _initialize_id(self):\n        \"\"\"Initializes the id of the instance.\"\"\"\n        self.id = str(self.db.incr(self._key['id']))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nwriting the values of the attributes and the lists of the object to the datastore.", "response": "def _write(self, _new=False):\n        \"\"\"Writes the values of the attributes to the datastore.\n\n        This method also creates the indices and saves the lists\n        associated to the object.\n        \"\"\"\n        pipeline = self.db.pipeline()\n        self._create_membership(pipeline)\n        self._update_indices(pipeline)\n        h = {}\n        # attributes\n        for k, v in self.attributes.iteritems():\n            if isinstance(v, DateTimeField):\n                if v.auto_now:\n                    setattr(self, k, datetime.now())\n                if v.auto_now_add and _new:\n                    setattr(self, k, datetime.now())\n            elif isinstance(v, DateField):\n                if v.auto_now:\n                    setattr(self, k, date.today())\n                if v.auto_now_add and _new:\n                    setattr(self, k, date.today())\n            for_storage = getattr(self, k)\n            if for_storage is not None:\n                h[k] = v.typecast_for_storage(for_storage)\n        # indices\n        for index in self.indices:\n            if index not in self.lists and index not in self.attributes:\n                v = getattr(self, index)\n                if callable(v):\n                    v = v()\n                if v:\n                    try:\n                        h[index] = unicode(v)\n                    except UnicodeError:\n                        h[index] = unicode(v.decode('utf-8'))\n        pipeline.delete(self.key())\n        if h:\n            pipeline.hmset(self.key(), h)\n\n        # lists\n        for k, v in self.lists.iteritems():\n            l = List(self.key()[k], pipeline=pipeline)\n            l.clear()\n            values = getattr(self, k)\n            if values:\n                if v._redisco_model:\n                    l.extend([item.id for item in values])\n                else:\n                    l.extend(values)\n        pipeline.execute()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _create_membership(self, pipeline=None):\n        Set(self._key['all'], pipeline=pipeline).add(self.id)", "response": "Adds the id of the object to the set of all objects of the same\n        class."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _delete_membership(self, pipeline=None):\n        Set(self._key['all'], pipeline=pipeline).remove(self.id)", "response": "Removes the id of the object from the set of all objects of the\n        same class."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _add_to_indices(self, pipeline):\n        for att in self.indices:\n            self._add_to_index(att, pipeline=pipeline)", "response": "Adds the base64 encoded values of the indices to the index."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nadd the id to the index.", "response": "def _add_to_index(self, att, val=None, pipeline=None):\n        \"\"\"\n        Adds the id to the index.\n\n        This also adds to the _indices set of the object.\n        \"\"\"\n        index = self._index_key_for(att)\n        if index is None:\n            return\n        t, index = index\n        if t == 'attribute':\n            pipeline.sadd(index, self.id)\n            pipeline.sadd(self.key()['_indices'], index)\n        elif t == 'list':\n            for i in index:\n                pipeline.sadd(i, self.id)\n                pipeline.sadd(self.key()['_indices'], i)\n        elif t == 'sortedset':\n            zindex, index = index\n            pipeline.sadd(index, self.id)\n            pipeline.sadd(self.key()['_indices'], index)\n            descriptor = self.attributes[att]\n            score = descriptor.typecast_for_storage(getattr(self, att))\n            pipeline.zadd(zindex, self.id, score)\n            pipeline.sadd(self.key()['_zindices'], zindex)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _delete_from_indices(self, pipeline):\n        s = Set(self.key()['_indices'])\n        z = Set(self.key()['_zindices'])\n        for index in s.members:\n            pipeline.srem(index, self.id)\n        for index in z.members:\n            pipeline.zrem(index, self.id)\n        pipeline.delete(s.key)\n        pipeline.delete(z.key)", "response": "Deletes the object s id from the sets ( indices ) it has been added\n        to and removes its list of indices."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _index_key_for(self, att, value=None):\n        if value is None:\n            value = getattr(self, att)\n            if callable(value):\n                value = value()\n        if value is None:\n            return None\n        if att not in self.lists:\n            return self._get_index_key_for_non_list_attr(att, value)\n        else:\n            return self._tuple_for_index_key_attr_list(att, value)", "response": "Returns a key based on the attribute and its value."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning True if the set has no elements in common with other.", "response": "def isdisjoint(self, other):\n        \"\"\"Return True if the set has no elements in common with other.\"\"\"\n        return not bool(self.db.sinter([self.key, other.key]))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a new set with elements from the set and all others.", "response": "def union(self, key, *others):\n        \"\"\"Return a new set with elements from the set and all others.\"\"\"\n        if not isinstance(key, str):\n            raise ValueError(\"String expected.\")\n        self.db.sunionstore(key, [self.key] + [o.key for o in others])\n        return Set(key)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef intersection(self, key, *others):\n        if not isinstance(key, str):\n            raise ValueError(\"String expected.\")\n        self.db.sinterstore(key, [self.key] + [o.key for o in others])\n        return Set(key)", "response": "Return a new set with elements common to the set and all others."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a new set with elements in the set that are not in the others.", "response": "def difference(self, key, *others):\n        \"\"\"Return a new set with elements in the set that are not in the others.\"\"\"\n        if not isinstance(key, str):\n            raise ValueError(\"String expected.\")\n        self.db.sdiffstore(key, [self.key] + [o.key for o in others])\n        return Set(key)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef update(self, *others):\n        self.db.sunionstore(self.key, [self.key] + [o.key for o in others])", "response": "Update the set with the elements from all others."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef intersection_update(self, *others):\n        self.db.sinterstore(self.key, [o.key for o in [self.key] + others])", "response": "Update the set keeping only elements found in it and all others."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef difference_update(self, *others):\n        self.db.sdiffstore(self.key, [o.key for o in [self.key] + others])", "response": "Update the set removing elements found in others."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef copy(self, key):\n        copy = Set(key=key, db=self.db)\n        copy.clear()\n        copy |= self\n        return copy", "response": "Copy the set to another key and return the new Set."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef sinter(self, *other_sets):\n        return self.db.sinter([self.key] + [s.key for s in other_sets])", "response": "Performs an intersection between this set and the given set of common members. Uses Redis. sinter."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef sdiff(self, *other_sets):\n        return self.db.sdiff([self.key] + [s.key for s in other_sets])", "response": "Union between Sets.\n\n        Returns a set of common members. Uses Redis. sdiff."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef copy(self, key):\n        copy = List(key, self.db)\n        copy.clear()\n        copy.extend(self)\n        return copy", "response": "Copy the list to a new list."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef lt(self, v, limit=None, offset=None):\n        if limit is not None and offset is None:\n            offset = 0\n        return self.zrangebyscore(self._min_score, \"(%f\" % v,\n                start=offset, num=limit)", "response": "Returns the list of the members of the set that have scores\n            less than v."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the list of members of the set that have scores greater than v.", "response": "def gt(self, v, limit=None, offset=None):\n        \"\"\"Returns the list of the members of the set that have scores\n        greater than v.\n        \"\"\"\n        if limit is not None and offset is None:\n            offset = 0\n        return self.zrangebyscore(\"(%f\" % v, self._max_score,\n                start=offset, num=limit)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the members of the set that have scores between min and max.", "response": "def between(self, min, max, limit=None, offset=None):\n        \"\"\"Returns the list of the members of the set that have scores\n        between min and max.\n        \"\"\"\n        if limit is not None and offset is None:\n            offset = 0\n        return self.zrangebyscore(min, max,\n                start=offset, num=limit)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef hex_to_bytes(s):\n    if len(s) % 2:\n        s = b'0' + s\n    ia = [int(s[i:i+2], 16) for i in range(0, len(s), 2)]   # int array\n    return bs(ia) if PYTHON_MAJOR_VER == 3 else b''.join([chr(c) for c in ia])", "response": "convert hex string to bytes"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef client_seed(a=random.randrange(0, 1 << SRP_KEY_SIZE)):\n    if DEBUG:\n        a = DEBUG_PRIVATE_KEY\n    N, g, k = get_prime()\n    A = pow(g, a, N)\n    if DEBUG_PRINT:\n        print('a=', binascii.b2a_hex(long2bytes(a)), end='\\n')\n        print('A=', binascii.b2a_hex(long2bytes(A)), end='\\n')\n    return A, a", "response": "Random seed for the client public key and private key."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef server_seed(v, b=random.randrange(0, 1 << SRP_KEY_SIZE)):\n    N, g, k = get_prime()\n    if DEBUG:\n        b = DEBUG_PRIVATE_KEY\n    gb = pow(g, b, N)\n    kv = (k * v) % N\n    B = (kv + gb) % N\n    if DEBUG_PRINT:\n        print(\"v\", binascii.b2a_hex(long2bytes(v)), end='\\n')\n        print('b=', binascii.b2a_hex(long2bytes(b)), end='\\n')\n        print(\"gb\", binascii.b2a_hex(long2bytes(gb)), end='\\n')\n        print(\"k\", binascii.b2a_hex(long2bytes(k)), end='\\n')\n        print(\"v\", binascii.b2a_hex(long2bytes(v)), end='\\n')\n        print(\"kv\", binascii.b2a_hex(long2bytes(kv)), end='\\n')\n        print('B=', binascii.b2a_hex(long2bytes(B)), end='\\n')\n    return B, b", "response": "Random seed for server public key and private key."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef client_session(user, password, salt, A, B, a):\n    N, g, k = get_prime()\n    u = get_scramble(A, B)\n    x = getUserHash(salt, user, password)   # x\n    gx = pow(g, x, N)                       # g^x\n    kgx = (k * gx) % N                      # kg^x\n    diff = (B - kgx) % N                    # B - kg^x\n    ux = (u * x) % N\n    aux = (a + ux) % N\n    session_secret = pow(diff, aux, N)      # (B - kg^x) ^ (a + ux)\n    K = hash_digest(hashlib.sha1, session_secret)\n    if DEBUG_PRINT:\n        print('B=', binascii.b2a_hex(long2bytes(B)), end='\\n')\n        print('u=', binascii.b2a_hex(long2bytes(u)), end='\\n')\n        print('x=', binascii.b2a_hex(long2bytes(x)), end='\\n')\n        print('gx=', binascii.b2a_hex(long2bytes(gx)), end='\\n')\n        print('kgx=', binascii.b2a_hex(long2bytes(kgx)), end='\\n')\n        print('diff=', binascii.b2a_hex(long2bytes(diff)), end='\\n')\n        print('ux=', binascii.b2a_hex(long2bytes(ux)), end='\\n')\n        print('aux=', binascii.b2a_hex(long2bytes(aux)), end='\\n')\n        print('session_secret=', binascii.b2a_hex(long2bytes(session_secret)), end='\\n')\n        print('session_key:K=', binascii.b2a_hex(K))\n\n    return K", "response": "Client session secret\n        Both:  u = H(A, B)\n\n        User:  x = H(s, p)                 (user enters password)\n        User:  S = (B - kg^x) ^ (a + ux)   (computes session key)\n        User:  K = H(S)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncomputes the server session secret", "response": "def server_session(user, password, salt, A, B, b):\n    \"\"\"\n    Server session secret\n        Both:  u = H(A, B)\n\n        Host:  S = (Av^u) ^ b              (computes session key)\n        Host:  K = H(S)\n    \"\"\"\n    N, g, k = get_prime()\n    u = get_scramble(A, B)\n    v = get_verifier(user, password, salt)\n    vu = pow(v, u, N)                       # v^u\n    Avu = (A * vu) % N                      # Av^u\n    session_secret = pow(Avu, b, N)         # (Av^u) ^ b\n    K = hash_digest(hashlib.sha1, session_secret)\n    if DEBUG_PRINT:\n        print('server session_secret=', binascii.b2a_hex(long2bytes(session_secret)), end='\\n')\n        print('server session hash K=', binascii.b2a_hex(K))\n\n    return K"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef dpd_to_int(dpd):\n    b = [None] * 10\n    b[9] = 1 if dpd & 0b1000000000 else 0\n    b[8] = 1 if dpd & 0b0100000000 else 0\n    b[7] = 1 if dpd & 0b0010000000 else 0\n    b[6] = 1 if dpd & 0b0001000000 else 0\n    b[5] = 1 if dpd & 0b0000100000 else 0\n    b[4] = 1 if dpd & 0b0000010000 else 0\n    b[3] = 1 if dpd & 0b0000001000 else 0\n    b[2] = 1 if dpd & 0b0000000100 else 0\n    b[1] = 1 if dpd & 0b0000000010 else 0\n    b[0] = 1 if dpd & 0b0000000001 else 0\n\n    d = [None] * 3\n    if b[3] == 0:\n        d[2] = b[9] * 4 + b[8] * 2 + b[7]\n        d[1] = b[6] * 4 + b[5] * 2 + b[4]\n        d[0] = b[2] * 4 + b[1] * 2 + b[0]\n    elif (b[3], b[2], b[1]) == (1, 0, 0):\n        d[2] = b[9] * 4 + b[8] * 2 + b[7]\n        d[1] = b[6] * 4 + b[5] * 2 + b[4]\n        d[0] = 8 + b[0]\n    elif (b[3], b[2], b[1]) == (1, 0, 1):\n        d[2] = b[9] * 4 + b[8] * 2 + b[7]\n        d[1] = 8 + b[4]\n        d[0] = b[6] * 4 + b[5] * 2 + b[0]\n    elif (b[3], b[2], b[1]) == (1, 1, 0):\n        d[2] = 8 + b[7]\n        d[1] = b[6] * 4 + b[5] * 2 + b[4]\n        d[0] = b[9] * 4 + b[8] * 2 + b[0]\n    elif (b[6], b[5], b[3], b[2], b[1]) == (0, 0, 1, 1, 1):\n        d[2] = 8 + b[7]\n        d[1] = 8 + b[4]\n        d[0] = b[9] * 4 + b[8] * 2 + b[0]\n    elif (b[6], b[5], b[3], b[2], b[1]) == (0, 1, 1, 1, 1):\n        d[2] = 8 + b[7]\n        d[1] = b[9] * 4 + b[8] * 2 + b[4]\n        d[0] = 8 + b[0]\n    elif (b[6], b[5], b[3], b[2], b[1]) == (1, 0, 1, 1, 1):\n        d[2] = b[9] * 4 + b[8] * 2 + b[7]\n        d[1] = 8 + b[4]\n        d[0] = 8 + b[0]\n    elif (b[6], b[5], b[3], b[2], b[1]) == (1, 1, 1, 1, 1):\n        d[2] = 8 + b[7]\n        d[1] = 8 + b[4]\n        d[0] = 8 + b[0]\n    else:\n        raise ValueError('Invalid DPD encoding')\n\n    return d[2] * 100 + d[1] * 10 + d[0]", "response": "Convert a DPD encoded value to an integer."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncalculating the significand of a given number of bits.", "response": "def calc_significand(prefix, dpd_bits, num_bits):\n    \"\"\"\n    prefix: High bits integer value\n    dpd_bits: dpd encoded bits\n    num_bits: bit length of dpd_bits\n    \"\"\"\n    # https://en.wikipedia.org/wiki/Decimal128_floating-point_format#Densely_packed_decimal_significand_field\n    num_segments = num_bits // 10\n    segments = []\n    for i in range(num_segments):\n        segments.append(dpd_bits & 0b1111111111)\n        dpd_bits >>= 10\n    segments.reverse()\n\n    v = prefix\n    for dpd in segments:\n        v = v * 1000 + dpd_to_int(dpd)\n\n    return v"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef decimal128_to_decimal(b):\n    \"decimal128 bytes to Decimal\"\n    v = decimal128_to_sign_digits_exponent(b)\n    if isinstance(v, Decimal):\n        return v\n    sign, digits, exponent = v\n    return Decimal((sign, Decimal(digits).as_tuple()[1], exponent))", "response": "decimal128 bytes to Decimal"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef error_response(response):\n    if response.status_code >= 500:\n        raise exceptions.GeocodioServerError\n\n    elif response.status_code == 403:\n        raise exceptions.GeocodioAuthError\n\n    elif response.status_code == 422:\n        raise exceptions.GeocodioDataError(response.json()[\"error\"])\n\n    else:\n        raise exceptions.GeocodioError(\n            \"Unknown service error (HTTP {0})\".format(response.status_code)\n        )", "response": "Raises an exception if the response code is not a valid service error."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _req(self, method=\"get\", verb=None, headers={}, params={}, data={}):\n        url = self.BASE_URL.format(verb=verb)\n        request_headers = {\"content-type\": \"application/json\"}\n        request_params = {\"api_key\": self.API_KEY}\n        request_headers.update(headers)\n        request_params.update(params)\n        return getattr(requests, method)(\n            url, params=request_params, headers=request_headers, data=data\n        )", "response": "Wrap all request building\n           "}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef parse(self, address):\n        response = self._req(verb=\"parse\", params={\"q\": address})\n        if response.status_code != 200:\n            return error_response(response)\n\n        return Address(response.json())", "response": "Returns an Address dictionary with the components of the queried\n        address."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a dictionary with the components of the queried address.", "response": "def batch_geocode(self, addresses, **kwargs):\n        \"\"\"\n        Returns an Address dictionary with the components of the queried\n        address.\n        \"\"\"\n        fields = \",\".join(kwargs.pop(\"fields\", []))\n        response = self._req(\n            \"post\",\n            verb=\"geocode\",\n            params={\"fields\": fields},\n            data=json.dumps(addresses),\n        )\n        if response.status_code != 200:\n            return error_response(response)\n\n        return LocationCollection(response.json()[\"results\"])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a Location dictionary with the components of the queried address and the geocoded location.", "response": "def geocode_address(self, address, **kwargs):\n        \"\"\"\n        Returns a Location dictionary with the components of the queried\n        address and the geocoded location.\n\n        >>> client = GeocodioClient('some_api_key')\n        >>> client.geocode(\"1600 Pennsylvania Ave, Washington DC\")\n        {\n        \"input\": {\n            \"address_components\": {\n                \"number\": \"1600\",\n                \"street\": \"Pennsylvania\",\n                \"suffix\": \"Ave\",\n                \"city\": \"Washington\",\n                \"state\": \"DC\"\n            },\n            \"formatted_address\": \"1600 Pennsylvania Ave, Washington DC\"\n        },\n        \"results\": [\n            {\n                \"address_components\": {\n                    \"number\": \"1600\",\n                    \"street\": \"Pennsylvania\",\n                    \"suffix\": \"Ave\",\n                    \"city\": \"Washington\",\n                    \"state\": \"DC\",\n                    \"zip\": \"20500\"\n                },\n                \"formatted_address\": \"1600 Pennsylvania Ave, Washington DC, 20500\",\n                \"location\": {\n                    \"lat\": 38.897700000000,\n                    \"lng\": -77.03650000000,\n                },\n                \"accuracy\": 1\n            },\n            {\n                \"address_components\": {\n                    \"number\": \"1600\",\n                    \"street\": \"Pennsylvania\",\n                    \"suffix\": \"Ave\",\n                    \"city\": \"Washington\",\n                    \"state\": \"DC\",\n                    \"zip\": \"20500\"\n                },\n                \"formatted_address\": \"1600 Pennsylvania Ave, Washington DC, 20500\",\n                \"location\": {\n                    \"lat\": 38.897700000000,\n                    \"lng\": -77.03650000000,\n                },\n                \"accuracy\": 0.8\n                }\n            ]\n        }\n        \"\"\"\n        fields = \",\".join(kwargs.pop(\"fields\", []))\n        response = self._req(verb=\"geocode\", params={\"q\": address, \"fields\": fields})\n        if response.status_code != 200:\n            return error_response(response)\n\n        return Location(response.json())"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef geocode(self, address_data, **kwargs):\n        if isinstance(address_data, list):\n            return self.batch_geocode(address_data, **kwargs)\n\n        return self.geocode_address(address_data, **kwargs)", "response": "Returns a geocoding data for the given address data."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef reverse_point(self, latitude, longitude, **kwargs):\n        fields = \",\".join(kwargs.pop(\"fields\", []))\n        point_param = \"{0},{1}\".format(latitude, longitude)\n        response = self._req(\n            verb=\"reverse\", params={\"q\": point_param, \"fields\": fields}\n        )\n        if response.status_code != 200:\n            return error_response(response)\n\n        return Location(response.json())", "response": "This method is used to identify an address from a geographic point"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef batch_reverse(self, points, **kwargs):\n        fields = \",\".join(kwargs.pop(\"fields\", []))\n        response = self._req(\n            \"post\", verb=\"reverse\", params={\"fields\": fields}, data=json_points(points)\n        )\n        if response.status_code != 200:\n            return error_response(response)\n\n        logger.debug(response)\n        return LocationCollection(response.json()[\"results\"])", "response": "Method for identifying the addresses from a list of lat / lng tuples"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nconvert str to bytes", "response": "def str_to_bytes(self, s):\n        \"convert str to bytes\"\n        if (PYTHON_MAJOR_VER == 3 or\n                (PYTHON_MAJOR_VER == 2 and type(s) == unicode)):\n            return s.encode(charset_map.get(self.charset, self.charset))\n        return s"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nconvert bytes array to raw string", "response": "def bytes_to_str(self, b):\n        \"convert bytes array to raw string\"\n        if PYTHON_MAJOR_VER == 3:\n            return b.decode(charset_map.get(self.charset, self.charset))\n        return b"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nconverting bytes array to unicode string", "response": "def bytes_to_ustr(self, b):\n        \"convert bytes array to unicode string\"\n        return b.decode(charset_map.get(self.charset, self.charset))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nconverting parameter array to BLR and values format.", "response": "def params_to_blr(self, trans_handle, params):\n        \"Convert parameter array to BLR and values format.\"\n        ln = len(params) * 2\n        blr = bs([5, 2, 4, 0, ln & 255, ln >> 8])\n        if self.accept_version < PROTOCOL_VERSION13:\n            values = bs([])\n        else:\n            # start with null indicator bitmap\n            null_indicator = 0\n            for i, p in enumerate(params):\n                if p is None:\n                    null_indicator |= (1 << i)\n            n = len(params) // 8\n            if len(params) % 8 != 0:\n                n += 1\n            if n % 4:   # padding\n                n += 4 - n % 4\n            null_indicator_bytes = []\n            for i in range(n):\n                null_indicator_bytes.append(null_indicator & 255)\n                null_indicator >>= 8\n            values = bs(null_indicator_bytes)\n        for p in params:\n            if (\n                (PYTHON_MAJOR_VER == 2 and type(p) == unicode) or\n                (PYTHON_MAJOR_VER == 3 and type(p) == str)\n            ):\n                p = self.str_to_bytes(p)\n            t = type(p)\n            if p is None:\n                v = bs([])\n                blr += bs([14, 0, 0])\n            elif (\n                (PYTHON_MAJOR_VER == 2 and t == str) or\n                (PYTHON_MAJOR_VER == 3 and t == bytes)\n            ):\n                if len(p) > MAX_CHAR_LENGTH:\n                    v = self._create_blob(trans_handle, p)\n                    blr += bs([9, 0])\n                else:\n                    v = p\n                    nbytes = len(v)\n                    pad_length = ((4-nbytes) & 3)\n                    v += bs([0]) * pad_length\n                    blr += bs([14, nbytes & 255, nbytes >> 8])\n            elif t == int:\n                v = bint_to_bytes(p, 4)\n                blr += bs([8, 0])    # blr_long\n            elif t == float and p == float(\"inf\"):\n                v = b'\\x7f\\x80\\x00\\x00'\n                blr += bs([10])\n            elif t == decimal.Decimal or t == float:\n                if t == float:\n                    p = decimal.Decimal(str(p))\n                (sign, digits, exponent) = p.as_tuple()\n                v = 0\n                ln = len(digits)\n                for i in range(ln):\n                    v += digits[i] * (10 ** (ln - i - 1))\n                if sign:\n                    v *= -1\n                v = bint_to_bytes(v, 8)\n                if exponent < 0:\n                    exponent += 256\n                blr += bs([16, exponent])\n            elif t == datetime.date:\n                v = convert_date(p)\n                blr += bs([12])\n            elif t == datetime.time:\n                if p.tzinfo:\n                    v = convert_time_tz(p)\n                    blr += bs([28])\n                else:\n                    v = convert_time(p)\n                    blr += bs([13])\n            elif t == datetime.datetime:\n                if p.tzinfo:\n                    v = convert_timestamp_tz(p)\n                    blr += bs([29])\n                else:\n                    v = convert_timestamp(p)\n                    blr += bs([35])\n            elif t == bool:\n                v = bs([1, 0, 0, 0]) if p else bs([0, 0, 0, 0])\n                blr += bs([23])\n            else:   # fallback, convert to string\n                p = p.__repr__()\n                if PYTHON_MAJOR_VER == 3 or (PYTHON_MAJOR_VER == 2 and type(p) == unicode):\n                    p = self.str_to_bytes(p)\n                v = p\n                nbytes = len(v)\n                pad_length = ((4-nbytes) & 3)\n                v += bs([0]) * pad_length\n                blr += bs([14, nbytes & 255, nbytes >> 8])\n            blr += bs([7, 0])\n            values += v\n            if self.accept_version < PROTOCOL_VERSION13:\n                values += bs([0]) * 4 if not p is None else bs([0xff, 0xff, 0xff, 0xff])\n        blr += bs([255, 76])    # [blr_end, blr_eoc]\n        return blr, values"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a tuple representing the location of the address in GIS coords format i. e. longitude latitude.", "response": "def coords(self):\n        \"\"\"\n        Returns a tuple representing the location of the address in a\n        GIS coords format, i.e. (longitude, latitude).\n        \"\"\"\n        x, y = (\"lat\", \"lng\") if self.order == \"lat\" else (\"lng\", \"lat\")\n        try:\n            return (self[\"location\"][x], self[\"location\"][y])\n\n        except KeyError:\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning an individual Location by query lookup e. g. address or point.", "response": "def get(self, key):\n        \"\"\"\n        Returns an individual Location by query lookup, e.g. address or point.\n        \"\"\"\n\n        if isinstance(key, tuple):\n            # TODO handle different ordering\n            try:\n                x, y = float(key[0]), float(key[1])\n            except IndexError:\n                raise ValueError(\"Two values are required for a coordinate pair\")\n\n            except ValueError:\n                raise ValueError(\"Only float or float-coercable values can be passed\")\n\n            key = \"{0},{1}\".format(x, y)\n\n        return self[self.lookups[key]]"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncalculate BLR from XSQLVAR array.", "response": "def calc_blr(xsqlda):\n    \"Calculate  BLR from XSQLVAR array.\"\n    ln = len(xsqlda) * 2\n    blr = [5, 2, 4, 0, ln & 255, ln >> 8]\n    for x in xsqlda:\n        sqltype = x.sqltype\n        if sqltype == SQL_TYPE_VARYING:\n            blr += [37, x.sqllen & 255, x.sqllen >> 8]\n        elif sqltype == SQL_TYPE_TEXT:\n            blr += [14, x.sqllen & 255, x.sqllen >> 8]\n        elif sqltype == SQL_TYPE_LONG:\n            blr += [8, x.sqlscale]\n        elif sqltype == SQL_TYPE_SHORT:\n            blr += [7, x.sqlscale]\n        elif sqltype == SQL_TYPE_INT64:\n            blr += [16, x.sqlscale]\n        elif sqltype == SQL_TYPE_QUAD:\n            blr += [9, x.sqlscale]\n        elif sqltype == SQL_TYPE_DEC_FIXED:\n            blr += [26, x.sqlscale]\n        else:\n            blr += sqltype2blr[sqltype]\n        blr += [7, 0]   # [blr_short, 0]\n    blr += [255, 76]    # [blr_end, blr_eoc]\n\n    # x.sqlscale value shoud be negative, so b convert to range(0, 256)\n    return bs(256 + b if b < 0 else b for b in blr)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nconvert raw data to datetime. date", "response": "def _parse_date(self, raw_value):\n        \"Convert raw data to datetime.date\"\n        nday = bytes_to_bint(raw_value) + 678882\n        century = (4 * nday - 1) // 146097\n        nday = 4 * nday - 1 - 146097 * century\n        day = nday // 4\n\n        nday = (4 * day + 3) // 1461\n        day = 4 * day + 3 - 1461 * nday\n        day = (day + 4) // 4\n\n        month = (5 * day - 3) // 153\n        day = 5 * day - 3 - 153 * month\n        day = (day + 5) // 5\n        year = 100 * century + nday\n        if month < 10:\n            month += 3\n        else:\n            month -= 9\n            year += 1\n        return year, month, day"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nconverts raw data to datetime. time", "response": "def _parse_time(self, raw_value):\n        \"Convert raw data to datetime.time\"\n        n = bytes_to_bint(raw_value)\n        s = n // 10000\n        m = s // 60\n        h = m // 60\n        m = m % 60\n        s = s % 60\n        return (h, m, s, (n % 10000) * 100)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef execute_update(args):\n\n    provider_class = getattr(dnsupdater,\n                             dnsupdater.AVAILABLE_PLUGINS.get(args.provider))\n    updater_options = {}\n    process_message = None\n    auth = None\n\n    if args.store:  # --store argument\n        if provider_class.auth_type == 'T':\n            user_arg = args.usertoken or utils.read_input(\n                \"Paste your auth token: \")\n            auth = authinfo.ApiAuth(usertoken=user_arg)\n        else:\n            user_arg = args.usertoken or utils.read_input(\n                \"Type your username: \")\n            pass_arg = args.password or getpass.getpass(\"Type your password: \")\n            auth = authinfo.ApiAuth(user_arg, pass_arg)\n\n        authinfo.store(auth, args.provider, args.config)\n        exec_result = EXECUTION_RESULT_OK\n        if not args.hostname:\n            update_ddns = False\n            process_message = \"Auth info stored.\"\n        else:\n            update_ddns = True\n\n    # informations arguments\n    elif args.usertoken and args.hostname:\n        if provider_class.auth_type == 'T':\n            auth = authinfo.ApiAuth(args.usertoken)\n        else:\n            auth = authinfo.ApiAuth(args.usertoken, args.password)\n        update_ddns = True\n        exec_result = EXECUTION_RESULT_OK\n    elif args.hostname:\n        if authinfo.exists(args.provider, args.config):\n            auth = authinfo.load(args.provider, args.config)\n            update_ddns = True\n            exec_result = EXECUTION_RESULT_OK\n        else:\n            update_ddns = False\n            exec_result = EXECUTION_RESULT_NOK\n            process_message = \"No stored auth information found for \" \\\n                              \"provider: '%s'\" % args.provider\n    else:  # no arguments\n        update_ddns = False\n        exec_result = EXECUTION_RESULT_NOK\n        process_message = \"Warning: The hostname to be updated must be \" \\\n                          \"provided.\\nUsertoken and password can be either \" \\\n                          \"provided via command line or stored with --store \" \\\n                          \"option.\\nExecute noipy --help for more details.\"\n\n    if update_ddns and args.provider == 'generic':\n        if args.url:\n            if not URL_RE.match(args.url):\n                process_message = \"Malformed URL.\"\n                exec_result = EXECUTION_RESULT_NOK\n                update_ddns = False\n            else:\n                updater_options['url'] = args.url\n        else:\n            process_message = \"Must use --url if --provider is 'generic' \" \\\n                              \"(default)\"\n            exec_result = EXECUTION_RESULT_NOK\n            update_ddns = False\n\n    response_code = None\n    response_text = None\n    if update_ddns:\n        ip_address = args.ip if args.ip else utils.get_ip()\n        if not ip_address:\n            process_message = \"Unable to get IP address. Check connection.\"\n            exec_result = EXECUTION_RESULT_NOK\n        elif ip_address == utils.get_dns_ip(args.hostname):\n            process_message = \"No update required.\"\n        else:\n            updater = provider_class(auth, args.hostname, updater_options)\n            print(\"Updating hostname '%s' with IP address %s \"\n                  \"[provider: '%s']...\"\n                  % (args.hostname, ip_address, args.provider))\n            response_code, response_text = updater.update_dns(ip_address)\n            process_message = updater.status_message\n\n    proc_result = {\n        'exec_result': exec_result,\n        'response_code': response_code,\n        'response_text': response_text,\n        'process_message': process_message,\n    }\n\n    return proc_result", "response": "Execute the update based on command line args and returns a dictionary\n    with execution result response code response info and process friendly message."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncalling No - IP API based on dict login_info and return the status code and the text of the response.", "response": "def update_dns(self, new_ip):\n        \"\"\"Call No-IP API based on dict login_info and return the status code.\n        \"\"\"\n\n        headers = None\n        if self.auth_type == 'T':\n            api_call_url = self._base_url.format(hostname=self.hostname,\n                                                 token=self.auth.token,\n                                                 ip=new_ip)\n        else:\n            api_call_url = self._base_url.format(hostname=self.hostname,\n                                                 ip=new_ip)\n            headers = {\n                'Authorization': \"Basic %s\" %\n                                 self.auth.base64key.decode('utf-8'),\n                'User-Agent': \"%s/%s %s\" % (__title__, __version__, __email__)\n            }\n\n        r = requests.get(api_call_url, headers=headers)\n        self.last_ddns_response = str(r.text).strip()\n\n        return r.status_code, r.text"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns friendly response from API based on response code.", "response": "def status_message(self):\n        \"\"\"Return friendly response from API based on response code. \"\"\"\n\n        msg = None\n        if self.last_ddns_response in response_messages.keys():\n            return response_messages.get(self.last_ddns_response)\n\n        if 'good' in self.last_ddns_response:\n            ip = re.search(r'(\\d{1,3}\\.?){4}', self.last_ddns_response).group()\n            msg = \"SUCCESS: DNS hostname IP (%s) successfully updated.\" % ip\n        elif 'nochg' in self.last_ddns_response:\n            ip = re.search(r'(\\d{1,3}\\.?){4}', self.last_ddns_response).group()\n            msg = \"SUCCESS: IP address (%s) is up to date, nothing was changed. \" \\\n                  \"Additional 'nochg' updates may be considered abusive.\" % ip\n        else:\n            msg = \"ERROR: Ooops! Something went wrong !!!\"\n\n        return msg"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_ip():\n    try:\n        r = requests.get(HTTPBIN_URL)\n        ip, _ = r.json()['origin'].split(',')\n        return ip if r.status_code == 200 else None\n    except requests.exceptions.ConnectionError:\n        return None", "response": "Return machine s origin IP address."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nstores auth info in file for specified provider", "response": "def store(auth, provider, config_location=DEFAULT_CONFIG_DIR):\n    \"\"\"Store auth info in file for specified provider \"\"\"\n\n    auth_file = None\n    try:\n        # only for custom locations\n        _create_config_dir(config_location,\n                           \"Creating custom config directory [%s]... \")\n\n        config_dir = os.path.join(config_location, NOIPY_CONFIG)\n        _create_config_dir(config_dir, \"Creating directory [%s]... \")\n\n        auth_file = os.path.join(config_dir, provider)\n        print(\"Creating auth info file [%s]... \" % auth_file, end=\"\")\n        with open(auth_file, 'w') as f:\n            buff = auth.base64key.decode('utf-8')\n            f.write(buff)\n        print(\"OK.\")\n\n    except IOError as e:\n        print('{0}: \"{1}\"'.format(e.strerror, auth_file))\n        raise e"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nload provider specific auth info from file", "response": "def load(provider, config_location=DEFAULT_CONFIG_DIR):\n    \"\"\"Load provider specific auth info from file \"\"\"\n\n    auth = None\n    auth_file = None\n    try:\n        config_dir = os.path.join(config_location, NOIPY_CONFIG)\n        print(\"Loading stored auth info [%s]... \" % config_dir, end=\"\")\n        auth_file = os.path.join(config_dir, provider)\n        with open(auth_file) as f:\n            auth_key = f.read()\n            auth = ApiAuth.get_instance(auth_key.encode('utf-8'))\n        print(\"OK.\")\n    except IOError as e:\n        print('{0}: \"{1}\"'.format(e.strerror, auth_file))\n        raise e\n\n    return auth"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncheck whether provider info is already stored", "response": "def exists(provider, config_location=DEFAULT_CONFIG_DIR):\n    \"\"\"Check whether provider info is already stored \"\"\"\n\n    config_dir = os.path.join(config_location, NOIPY_CONFIG)\n    auth_file = os.path.join(config_dir, provider)\n    return os.path.exists(auth_file)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_instance(cls, encoded_key):\n\n        login_str = base64.b64decode(encoded_key).decode('utf-8')\n        usertoken, password = login_str.strip().split(':', 1)\n\n        instance = cls(usertoken, password)\n\n        return instance", "response": "Return an ApiAuth instance from an encoded key"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nupdates the index for the provided list of models.", "response": "def update_index(model_items, model_name, action='index', bulk_size=100, num_docs=-1, start_date=None, end_date=None, refresh=True):\n    '''\n    Updates the index for the provided model_items.\n    :param model_items: a list of model_items (django Model instances, or proxy instances) which are to be indexed/updated or deleted.\n    If action is 'index', the model_items must be serializable objects. If action is 'delete', the model_items must be primary keys\n    corresponding to obects in the index.\n    :param model_name: doctype, which must also be the model name.\n    :param action: the action that you'd like to perform on this group of data. Must be in ('index', 'delete') and defaults to 'index.'\n    :param bulk_size: bulk size for indexing. Defaults to 100.\n    :param num_docs: maximum number of model_items from the provided list to be indexed.\n    :param start_date: start date for indexing. Must be as YYYY-MM-DD.\n    :param end_date: end date for indexing. Must be as YYYY-MM-DD.\n    :param refresh: a boolean that determines whether to refresh the index, making all operations performed since the last refresh\n    immediately available for search, instead of needing to wait for the scheduled Elasticsearch execution. Defaults to True.\n    :note: If model_items contain multiple models, then num_docs is applied to *each* model. For example, if bulk_size is set to 5,\n    and item contains models Article and Article2, then 5 model_items of Article *and* 5 model_items of Article2 will be indexed.\n    '''\n    src = Bungiesearch()\n\n    if action == 'delete' and not hasattr(model_items, '__iter__'):\n        raise ValueError(\"If action is 'delete', model_items must be an iterable of primary keys.\")\n\n    logger.info('Getting index for model {}.'.format(model_name))\n    for index_name in src.get_index(model_name):\n        index_instance = src.get_model_index(model_name)\n        model = index_instance.get_model()\n\n        if num_docs == -1:\n            if isinstance(model_items, (list, tuple)):\n                num_docs = len(model_items)\n            else:\n                model_items = filter_model_items(index_instance, model_items, model_name, start_date, end_date)\n                num_docs = model_items.count()\n\n                if not model_items.ordered:\n                    model_items = model_items.order_by('pk')\n        else:\n            logger.warning('Limiting the number of model_items to {} to {}.'.format(action, num_docs))\n\n        logger.info('{} {} documents on index {}'.format(action, num_docs, index_name))\n        prev_step = 0\n        max_docs = num_docs + bulk_size if num_docs > bulk_size else bulk_size + 1\n        for next_step in range(bulk_size, max_docs, bulk_size):\n            logger.info('{}: documents {} to {} of {} total on index {}.'.format(action.capitalize(), prev_step, next_step, num_docs, index_name))\n            data = create_indexed_document(index_instance, model_items[prev_step:next_step], action)\n            bulk_index(src.get_es_instance(), data, index=index_name, doc_type=model.__name__, raise_on_error=True)\n            prev_step = next_step\n\n        if refresh:\n            src.get_es_instance().indices.refresh(index=index_name)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef delete_index_item(item, model_name, refresh=True):\n    '''\n    Deletes an item from the index.\n    :param item: must be a serializable object.\n    :param model_name: doctype, which must also be the model name.\n    :param refresh: a boolean that determines whether to refresh the index, making all operations performed since the last refresh\n    immediately available for search, instead of needing to wait for the scheduled Elasticsearch execution. Defaults to True.\n    '''\n    src = Bungiesearch()\n\n    logger.info('Getting index for model {}.'.format(model_name))\n    for index_name in src.get_index(model_name):\n        index_instance = src.get_model_index(model_name)\n        item_es_id = index_instance.fields['_id'].value(item)\n        try:\n            src.get_es_instance().delete(index_name, model_name, item_es_id)\n        except NotFoundError as e:\n            logger.warning('NotFoundError: could not delete {}.{} from index {}: {}.'.format(model_name, item_es_id, index_name, str(e)))\n\n        if refresh:\n            src.get_es_instance().indices.refresh(index=index_name)", "response": "Delete an item from the index."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef create_indexed_document(index_instance, model_items, action):\n    '''\n    Creates the document that will be passed into the bulk index function.\n    Either a list of serialized objects to index, or a a dictionary specifying the primary keys of items to be delete.\n    '''\n    data = []\n    if action == 'delete':\n        for pk in model_items:\n            data.append({'_id': pk, '_op_type': action})\n    else:\n        for doc in model_items:\n            if index_instance.matches_indexing_condition(doc):\n                data.append(index_instance.serialize_object(doc))\n    return data", "response": "Creates the document that will be passed into the bulk index function."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nfilter the model items queryset based on start and end date.", "response": "def filter_model_items(index_instance, model_items, model_name, start_date, end_date):\n    ''' Filters the model items queryset based on start and end date.'''\n    if index_instance.updated_field is None:\n        logger.warning(\"No updated date field found for {} - not restricting with start and end date\".format(model_name))\n    else:\n        if start_date:\n            model_items = model_items.filter(**{'{}__gte'.format(index_instance.updated_field): __str_to_tzdate__(start_date)})\n        if end_date:\n            model_items = model_items.filter(**{'{}__lte'.format(index_instance.updated_field): __str_to_tzdate__(end_date)})\n\n    return model_items"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef extract_version(txt):\n    words = txt.replace(',', ' ').split()\n    version = None\n    for x in reversed(words):\n        if len(x) > 2:\n            if x[0].lower() == 'v':\n                x = x[1:]\n            if '.' in x and x[0].isdigit():\n                version = x\n                break\n    return version", "response": "This function tries to extract the version from the help text of any\n    program."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef check(self, return_code=0):\n        ret = self.call().return_code\n        ok = ret == return_code\n        if not ok:\n            raise EasyProcessError(\n                self, 'check error, return code is not {0}!'.format(return_code))\n        return self", "response": "Run command with arguments. Wait for command to complete."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nwait for command to complete.", "response": "def call(self, timeout=None):\n        \"\"\"Run command with arguments. Wait for command to complete.\n\n        same as:\n         1. :meth:`start`\n         2. :meth:`wait`\n         3. :meth:`stop`\n\n        :rtype: self\n\n        \"\"\"\n        self.start().wait(timeout=timeout)\n        if self.is_alive():\n            self.stop()\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef start(self):\n        if self.is_started:\n            raise EasyProcessError(self, 'process was started twice!')\n\n        if self.use_temp_files:\n            self._stdout_file = tempfile.TemporaryFile(prefix='stdout_')\n            self._stderr_file = tempfile.TemporaryFile(prefix='stderr_')\n            stdout = self._stdout_file\n            stderr = self._stderr_file\n\n        else:\n            stdout = subprocess.PIPE\n            stderr = subprocess.PIPE\n\n        cmd = list(map(uniencode, self.cmd))\n\n        try:\n            self.popen = subprocess.Popen(cmd,\n                                          stdout=stdout,\n                                          stderr=stderr,\n                                          cwd=self.cwd,\n                                          env=self.env,\n                                          )\n        except OSError as oserror:\n            log.debug('OSError exception: %s', oserror)\n            self.oserror = oserror\n            raise EasyProcessError(self, 'start error')\n        self.is_started = True\n        log.debug('process was started (pid=%s)', self.pid)\n        return self", "response": "start command in background and does not wait for it."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nwaiting for command to complete.", "response": "def wait(self, timeout=None):\n        \"\"\"Wait for command to complete.\n\n        Timeout:\n         - discussion: http://stackoverflow.com/questions/1191374/subprocess-with-timeout\n         - implementation: threading\n\n        :rtype: self\n\n        \"\"\"\n\n        if timeout is not None:\n            if not self._thread:\n                self._thread = threading.Thread(target=self._wait4process)\n                self._thread.daemon = 1\n                self._thread.start()\n\n        if self._thread:\n            self._thread.join(timeout=timeout)\n            self.timeout_happened = self.timeout_happened or self._thread.isAlive()\n        else:\n            # no timeout and no existing thread\n            self._wait4process()\n\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef sendstop(self):\n        '''\n        Kill process (:meth:`subprocess.Popen.terminate`).\n        Do not wait for command to complete.\n\n        :rtype: self\n        '''\n        if not self.is_started:\n            raise EasyProcessError(self, 'process was not started!')\n\n        log.debug('stopping process (pid=%s cmd=\"%s\")', self.pid, self.cmd)\n        if self.popen:\n            if self.is_alive():\n                log.debug('process is active -> sending SIGTERM')\n\n                try:\n                    try:\n                        self.popen.terminate()\n                    except AttributeError:\n                        os.kill(self.popen.pid, signal.SIGKILL)\n                except OSError as oserror:\n                    log.debug('exception in terminate:%s', oserror)\n\n            else:\n                log.debug('process was already stopped')\n        else:\n            log.debug('process was not started')\n\n        return self", "response": "Send SIGTERM to the process."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef wrap(self, func, delay=0):\n        '''\n        returns a function which:\n         1. start process\n         2. call func, save result\n         3. stop process\n         4. returns result\n\n        similar to :keyword:`with` statement\n\n        :rtype:\n        '''\n        def wrapped():\n            self.start()\n            if delay:\n                self.sleep(delay)\n            x = None\n            try:\n                x = func()\n            except OSError as oserror:\n                log.debug('OSError exception:%s', oserror)\n                self.oserror = oserror\n                raise EasyProcessError(self, 'wrap error!')\n            finally:\n                self.stop()\n            return x\n        return wrapped", "response": "A decorator that wraps a function which returns a function which starts process\nAttributeNames 2. call func save result\nAttributeNames 3. stop process\nAttributeNames 4. return a function which returns a function which returns None"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef send_message(self, message, room_id, **kwargs):\n        return SendMessage(settings=self.settings, **kwargs).call(\n            message=message,\n            room_id=room_id,\n            **kwargs\n        )", "response": "Send a message to a given room"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets a listing of all private rooms with their names and IDs.", "response": "def get_private_rooms(self, **kwargs):\n        \"\"\"\n        Get a listing of all private rooms with their names and IDs\n        \"\"\"\n        return GetPrivateRooms(settings=self.settings, **kwargs).call(**kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget various history of specific private group in this case", "response": "def get_private_room_history(self, room_id, oldest=None, **kwargs):\n        \"\"\"\n        Get various history of specific private group in this case private\n\n        :param room_id:\n        :param kwargs:\n        :return:\n        \"\"\"\n        return GetPrivateRoomHistory(settings=self.settings, **kwargs).call(\n            room_id=room_id,\n            oldest=oldest,\n            **kwargs\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_public_rooms(self, **kwargs):\n        return GetPublicRooms(settings=self.settings, **kwargs).call(**kwargs)", "response": "Get a listing of all public rooms with their names and IDs."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting various information about a specific channel or room.", "response": "def get_room_info(self, room_id, **kwargs):\n        \"\"\"\n        Get various information about a specific channel/room\n\n        :param room_id:\n        :param kwargs:\n        :return:\n        \"\"\"\n        return GetRoomInfo(settings=self.settings, **kwargs).call(\n            room_id=room_id,\n            **kwargs\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nuploads file to a specific room", "response": "def upload_file(self, room_id, description, file, message, **kwargs):\n        \"\"\"\n        Upload file to room\n        :param room_id:\n        :param description:\n        :param file:\n        :param kwargs:\n        :return:\n        \"\"\"\n        return UploadFile(settings=self.settings, **kwargs).call(\n            room_id=room_id,\n            description=description,\n            file=file,\n            message=message,\n            **kwargs\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting various information about a specific private group.", "response": "def get_private_room_info(self, room_id, **kwargs):\n        \"\"\"\n        Get various information about a specific private group\n\n        :param room_id:\n        :param kwargs:\n        :return:\n        \"\"\"\n        return GetPrivateRoomInfo(settings=self.settings, **kwargs).call(\n            room_id=room_id,\n            **kwargs\n        )"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets room ID :param room_name: :param kwargs: :return:", "response": "def get_room_id(self, room_name, **kwargs):\n        \"\"\"\n        Get room ID\n        :param room_name:\n        :param kwargs:\n        :return:\n        \"\"\"\n        return GetRoomId(settings=self.settings, **kwargs).call(\n            room_name=room_name,\n            **kwargs\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_room_history(\n                         self,\n                         room_id,\n                         oldest=None,\n                         latest=datetime.now(),\n                         inclusive=False,\n                         count=20,\n                         unreads=False,\n                         **kwargs\n                        ):\n        \"\"\"\n        Get various history of specific channel/room\n\n        :param room_id:\n        :param kwargs:\n        :return:\n        \"\"\"\n        return GetRoomHistory(settings=self.settings, **kwargs).call(\n            room_id=room_id,\n            oldest=oldest,\n            latest=latest,\n            inclusive=inclusive,\n            count=count,\n            unreads=unreads,\n            **kwargs\n        )", "response": "Get various history of specific channel and room."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef create_public_room(self, name, **kwargs):\n        return CreatePublicRoom(settings=self.settings, **kwargs).call(name=name, **kwargs)", "response": "Create public room with given name."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef delete_public_room(self, room_id, **kwargs):\n        return DeletePublicRoom(settings=self.settings, **kwargs).call(room_id=room_id, **kwargs)", "response": "Delete public room with given ID\n       "}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting all of the users in the system and their information", "response": "def get_users(self, **kwargs):\n        \"\"\"\n        Gets all of the users in the system and their information\n        :param kwargs:\n        :return:\n        \"\"\"\n        return GetUsers(settings=self.settings, **kwargs).call(**kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nretrieves information about a user", "response": "def get_user_info(self, user_id, **kwargs):\n        \"\"\"\n        Retrieves information about a user,\n        the result is only limited to what the callee has access to view.\n        :param user_id:\n        :param kwargs:\n        :return:\n        \"\"\"\n        return GetUserInfo(settings=self.settings, **kwargs).call(\n            user_id=user_id,\n            **kwargs\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef create_user(self, email, name, password, username, **kwargs):\n        return CreateUser(settings=self.settings, **kwargs).call(\n            email=email,\n            name=name,\n            password=password,\n            username=username,\n            **kwargs\n        )", "response": "Create user in nagios user store"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef delete_user(self, user_id, **kwargs):\n        return DeleteUser(settings=self.settings, **kwargs).call(user_id=user_id, **kwargs)", "response": "Delete user from cache"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the index name for the given model.", "response": "def get_index(cls, model, via_class=False):\n        '''\n        Returns the index name (as a string) for the given model as a class or a string.\n        :param model: model name or model class if via_class set to True.\n        :param via_class: set to True if parameter model is a class.\n        :raise KeyError: If the provided model does not have any index associated.\n        '''\n        try:\n            return cls._model_to_index[model] if via_class else cls._model_name_to_index[model]\n        except KeyError:\n            raise KeyError('Could not find any index defined for model {}. Is the model in one of the model index modules of BUNGIESEARCH[\"INDICES\"]?'.format(model))"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the model index for the given model.", "response": "def get_model_index(cls, model, default=True):\n        '''\n        Returns the default model index for the given model, or the list of indices if default is False.\n        :param model: model name as a string.\n        :raise KeyError: If the provided model does not have any index associated.\n        '''\n        try:\n            if default:\n                return cls._model_name_to_default_index[model]\n            return cls._model_name_to_model_idx[model]\n        except KeyError:\n            raise KeyError('Could not find any model index defined for model {}.'.format(model))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the list of models defined for this index.", "response": "def get_models(cls, index, as_class=False):\n        '''\n        Returns the list of models defined for this index.\n        :param index: index name.\n        :param as_class: set to True to return the model as a model object instead of as a string.\n        '''\n        try:\n            return cls._index_to_model[index] if as_class else cls._idx_name_to_mdl_to_mdlidx[index].keys()\n        except KeyError:\n            raise KeyError('Could not find any index named {}. Is this index defined in BUNGIESEARCH[\"INDICES\"]?'.format(index))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the list of model indices defined for this index.", "response": "def get_model_indices(cls, index):\n        '''\n        Returns the list of model indices (i.e. ModelIndex objects) defined for this index.\n        :param index: index name.\n        '''\n        try:\n            return cls._idx_name_to_mdl_to_mdlidx[index].values()\n        except KeyError:\n            raise KeyError('Could not find any index named {}. Is this index defined in BUNGIESEARCH[\"INDICES\"]?'.format(index))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef map_raw_results(cls, raw_results, instance=None):\n        '''\n        Maps raw results to database model objects.\n        :param raw_results: list raw results as returned from elasticsearch-dsl-py.\n        :param instance: Bungiesearch instance if you want to make use of `.only()` or `optmize_queries` as defined in the ModelIndex.\n        :return: list of mapped results in the *same* order as returned by elasticsearch.\n        '''\n        # Let's iterate over the results and determine the appropriate mapping.\n        model_results = defaultdict(list)\n        # Initializing the list to the number of returned results. This allows us to restore each item in its position.\n        if hasattr(raw_results, 'hits'):\n            results = [None] * len(raw_results.hits)\n        else:\n            results = [None] * len(raw_results)\n        found_results = {}\n        for pos, result in enumerate(raw_results):\n            model_name = result.meta.doc_type\n            if model_name not in Bungiesearch._model_name_to_index or result.meta.index not in Bungiesearch._model_name_to_index[model_name]:\n                logger.warning('Returned object of type {} ({}) is not defined in the settings, or is not associated to the same index as in the settings.'.format(model_name, result))\n                results[pos] = result\n            else:\n                meta = Bungiesearch.get_model_index(model_name).Meta\n                model_results['{}.{}'.format(result.meta.index, model_name)].append(result.meta.id)\n                found_results['{1.meta.index}.{0}.{1.meta.id}'.format(model_name, result)] = (pos, result.meta)\n\n        # Now that we have model ids per model name, let's fetch everything at once.\n        for ref_name, ids in iteritems(model_results):\n            index_name, model_name = ref_name.split('.')\n            model_idx = Bungiesearch._idx_name_to_mdl_to_mdlidx[index_name][model_name]\n            model_obj = model_idx.get_model()\n            items = model_obj.objects.filter(pk__in=ids)\n            if instance:\n                if instance._only == '__model' or model_idx.optimize_queries:\n                    desired_fields = model_idx.fields_to_fetch\n                elif instance._only == '__fields':\n                    desired_fields = instance._fields\n                else:\n                    desired_fields = instance._only\n\n                if desired_fields: # Prevents setting the database fetch to __fields but not having specified any field to elasticsearch.\n                    items = items.only(\n                        *[field.name\n                          for field in model_obj._meta.get_fields()\n                          # For complete backwards compatibility, you may want to exclude\n                          # GenericForeignKey from the results.\n                          if field.name in desired_fields and \\\n                             not (field.many_to_one and field.related_model is None)\n                         ]\n                    )\n            # Let's reposition each item in the results and set the _searchmeta meta information.\n            for item in items:\n                pos, meta = found_results['{}.{}.{}'.format(index_name, model_name, item.pk)]\n                item._searchmeta = meta\n                results[pos] = item\n\n        return results", "response": "Maps raw results to database model objects."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _clone(self):\n        '''\n        Must clone additional fields to those cloned by elasticsearch-dsl-py.\n        '''\n        instance = super(Bungiesearch, self)._clone()\n        instance._raw_results_only = self._raw_results_only\n        return instance", "response": "Must clone additional fields to those cloned by elasticsearch-dsl-py."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nexecute the query and attempts to create model objects from results.", "response": "def execute(self, return_results=True):\n        '''\n        Executes the query and attempts to create model objects from results.\n        '''\n        if self.results:\n            return self.results if return_results else None\n\n        self.execute_raw()\n\n        if self._raw_results_only:\n            self.results = self.raw_results\n        else:\n            self.map_results()\n\n        if return_results:\n            return self.results"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef only(self, *fields):\n        '''\n        Restricts the fields to be fetched when mapping. Set to `__model` to fetch all fields define in the ModelIndex.\n        '''\n        s = self._clone()\n        if len(fields) == 1 and fields[0] == '__model':\n            s._only = '__model'\n        else:\n            s._only = fields\n        return s", "response": "Restrict the fields to be fetched when mapping."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the function that will be called when an alias is applied to this model.", "response": "def hook_alias(self, alias, model_obj=None):\n        '''\n        Returns the alias function, if it exists and if it can be applied to this model.\n        '''\n        try:\n            search_alias = self._alias_hooks[alias]\n        except KeyError:\n            raise AttributeError('Could not find search alias named {}. Is this alias defined in BUNGIESEARCH[\"ALIASES\"]?'.format(alias))\n        else:\n            if search_alias._applicable_models and \\\n                ((model_obj and model_obj not in search_alias._applicable_models) or \\\n                 not any([app_model_obj.__name__ in self._doc_type for app_model_obj in search_alias._applicable_models])):\n                    raise ValueError('Search alias {} is not applicable to model/doc_types {}.'.format(alias, model_obj if model_obj else self._doc_type))\n            return search_alias.prepare(self, model_obj).alias_for"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nperform a custom elasticsearch search on a custom index and mapping. Will not attempt to map result objects.", "response": "def custom_search(self, index, doc_type):\n        '''\n        Performs a search on a custom elasticsearch index and mapping. Will not attempt to map result objects.\n        '''\n        from bungiesearch import Bungiesearch\n        return Bungiesearch(raw_results=True).index(index).doc_type(doc_type)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef contribute_to_class(self, cls, name):\n        '''\n        Sets up the signal processor. Since self.model is not available\n        in the constructor, we perform this operation here.\n        '''\n        super(BungiesearchManager, self).contribute_to_class(cls, name)\n\n        from . import Bungiesearch\n        from .signals import get_signal_processor\n        settings = Bungiesearch.BUNGIE\n        if 'SIGNALS' in settings:\n            self.signal_processor = get_signal_processor()\n            self.signal_processor.setup(self.model)", "response": "Sets up the signal processor."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the index field type that would likely be associated with each Django type.", "response": "def django_field_to_index(field, **attr):\n    '''\n    Returns the index field type that would likely be associated with each Django type.\n    '''\n\n    dj_type = field.get_internal_type()\n\n    if dj_type in ('DateField', 'DateTimeField'):\n        return DateField(**attr)\n    elif dj_type in ('BooleanField', 'NullBooleanField'):\n        return BooleanField(**attr)\n    elif dj_type in ('DecimalField', 'FloatField'):\n        return NumberField(coretype='float', **attr)\n    elif dj_type in ('PositiveSmallIntegerField', 'SmallIntegerField'):\n        return NumberField(coretype='short', **attr)\n    elif dj_type in ('IntegerField', 'PositiveIntegerField', 'AutoField'):\n        return NumberField(coretype='integer', **attr)\n    elif dj_type in ('BigIntegerField'):\n        return NumberField(coretype='long', **attr)\n\n    return StringField(**attr)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncomputes the value of this field to update the index.", "response": "def value(self, obj):\n        '''\n        Computes the value of this field to update the index.\n        :param obj: object instance, as a dictionary or as a model instance.\n        '''\n        if self.template_name:\n            t = loader.select_template([self.template_name])\n            return t.render(Context({'object': obj}))\n\n        if self.eval_func:\n            try:\n                return eval(self.eval_func)\n            except Exception as e:\n                raise type(e)('Could not compute value of {} field (eval_as=`{}`): {}.'.format(unicode(self), self.eval_func, unicode(e)))\n\n        elif self.model_attr:\n            if isinstance(obj, dict):\n                return obj[self.model_attr]\n            current_obj = getattr(obj, self.model_attr)\n\n            if callable(current_obj):\n                return current_obj()\n            else:\n                return current_obj\n\n        else:\n            raise KeyError('{0} gets its value via a model attribute, an eval function, a template, or is prepared in a method '\n                           'call but none of `model_attr`, `eval_as,` `template,` `prepare_{0}` is provided.'.format(unicode(self)))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef split_command(cmd, posix=None):\n    '''\n     - cmd is string list -> nothing to do\n     - cmd is string -> split it using shlex\n\n    :param cmd: string ('ls -l') or list of strings (['ls','-l'])\n    :rtype: string list\n    '''\n    if not isinstance(cmd, string_types):\n        # cmd is string list\n        pass\n    else:\n        if not PY3:\n            # cmd is string\n            # The shlex module currently does not support Unicode input (in\n            # 2.x)!\n            if isinstance(cmd, unicode):\n                try:\n                    cmd = unicodedata.normalize(\n                        'NFKD', cmd).encode('ascii', 'strict')\n                except UnicodeEncodeError:\n                    raise EasyProcessUnicodeError('unicode command \"%s\" can not be processed.' % cmd +\n                                                  'Use string list instead of string')\n                log.debug('unicode is normalized')\n        if posix is None:\n            posix = 'win' not in sys.platform\n        cmd = shlex.split(cmd, posix=posix)\n    return cmd", "response": "split command into list of strings"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the mapping for the index as a dictionary.", "response": "def get_mapping(self, meta_fields=True):\n        '''\n        Returns the mapping for the index as a dictionary.\n\n        :param meta_fields: Also include elasticsearch meta fields in the dictionary.\n        :return: a dictionary which can be used to generate the elasticsearch index mapping for this doctype.\n        '''\n        return {'properties': dict((name, field.json()) for name, field in iteritems(self.fields) if meta_fields or name not in AbstractField.meta_fields)}"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef collect_analysis(self):\n        '''\n        :return: a dictionary which is used to get the serialized analyzer definition from the analyzer class.\n        '''\n        analysis = {}\n        for field in self.fields.values():\n            for analyzer_name in ('analyzer', 'index_analyzer', 'search_analyzer'):\n                if not hasattr(field, analyzer_name):\n                    continue\n\n                analyzer = getattr(field, analyzer_name)\n\n                if not isinstance(analyzer, Analyzer):\n                    continue\n\n                definition = analyzer.get_analysis_definition()\n                if definition is None:\n                    continue\n\n                for key in definition:\n                    analysis.setdefault(key, {}).update(definition[key])\n\n        return analysis", "response": "collects the analysis definition from the analyzer class"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nserializing an object for it to be added to the index.", "response": "def serialize_object(self, obj, obj_pk=None):\n        '''\n        Serializes an object for it to be added to the index.\n\n        :param obj: Object to be serialized. Optional if obj_pk is passed.\n        :param obj_pk: Object primary key. Superseded by `obj` if available.\n        :return: A dictionary representing the object as defined in the mapping.\n        '''\n        if not obj:\n            try:\n                # We're using `filter` followed by `values` in order to only fetch the required fields.\n                obj = self.model.objects.filter(pk=obj_pk).values(*self.fields_to_fetch)[0]\n            except Exception as e:\n                raise ValueError('Could not find object of primary key = {} in model {} (model index class {}). (Original exception: {}.)'.format(obj_pk, self.model, self.__class__.__name__, e))\n\n        serialized_object = {}\n\n        for name, field in iteritems(self.fields):\n            if hasattr(self, \"prepare_%s\" % name):\n                value = getattr(self, \"prepare_%s\" % name)(obj)\n            else:\n                value = field.value(obj)\n\n            serialized_object[name] = value\n\n        return serialized_object"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngiving any explicit fields to include and fields to exclude add additional fields based on the associated model.", "response": "def _get_fields(self, fields, excludes, hotfixes):\n        '''\n        Given any explicit fields to include and fields to exclude, add\n        additional fields based on the associated model. If the field needs a hotfix, apply it.\n        '''\n        final_fields = {}\n        fields = fields or []\n        excludes = excludes or []\n\n        for f in self.model._meta.fields:\n            # If the field name is already present, skip\n            if f.name in self.fields:\n                continue\n\n            # If field is not present in explicit field listing, skip\n            if fields and f.name not in fields:\n                continue\n\n            # If field is in exclude list, skip\n            if excludes and f.name in excludes:\n                continue\n\n            # If field is a relation, skip.\n            if getattr(f, 'rel'):\n                continue\n\n            attr = {'model_attr': f.name}\n            if f.has_default():\n                attr['null_value'] = f.default\n\n            if f.name in hotfixes:\n                attr.update(hotfixes[f.name])\n\n            final_fields[f.name] = django_field_to_index(f, **attr)\n\n        return final_fields"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef validate_items(self):\n        logger.debug(fmt(\"Validating {}\", self))\n        from python_jsonschema_objects import classbuilder\n\n        if self.__itemtype__ is None:\n            return\n\n        type_checks = self.__itemtype__\n        if not isinstance(type_checks, (tuple, list)):\n            # we were given items = {'type': 'blah'} ; thus ensure the type for all data.\n            type_checks = [type_checks] * len(self.data)\n        elif len(type_checks) > len(self.data):\n            raise ValidationError(\n                \"{1} does not have sufficient elements to validate against {0}\"\n                .format(self.__itemtype__, self.data))\n\n        typed_elems = []\n        for elem, typ in zip(self.data, type_checks):\n            if isinstance(typ, dict):\n                for param, paramval in six.iteritems(typ):\n                    validator = registry(param)\n                    if validator is not None:\n                        validator(paramval, elem, typ)\n                typed_elems.append(elem)\n\n            elif util.safe_issubclass(typ, classbuilder.LiteralValue):\n                val = typ(elem)\n                val.validate()\n                typed_elems.append(val)\n            elif util.safe_issubclass(typ, classbuilder.ProtocolBase):\n                if not isinstance(elem, typ):\n                    try:\n                        if isinstance(elem, (six.string_types, six.integer_types, float)):\n                            val = typ(elem)\n                        else:\n                            val = typ(**util.coerce_for_expansion(elem))\n                    except TypeError as e:\n                        raise ValidationError(\"'{0}' is not a valid value for '{1}': {2}\"\n                                              .format(elem, typ, e))\n                else:\n                    val = elem\n                val.validate()\n                typed_elems.append(val)\n\n            elif util.safe_issubclass(typ, ArrayWrapper):\n                val = typ(elem)\n                val.validate()\n                typed_elems.append(val)\n\n            elif isinstance(typ, (classbuilder.TypeProxy, classbuilder.TypeRef)):\n                try:\n                    if isinstance(elem, (six.string_types, six.integer_types, float)):\n                        val = typ(elem)\n                    else:\n                        val = typ(**util.coerce_for_expansion(elem))\n                except TypeError as e:\n                    raise ValidationError(\"'{0}' is not a valid value for '{1}': {2}\"\n                                          .format(elem, typ, e))\n                else:\n                    val.validate()\n                    typed_elems.append(val)\n\n        self._dirty = False\n        self._typed = typed_elems\n        return typed_elems", "response": "Validates the items in the backing array including the items in the backing array including the _typed property and clears the dirty flag as a side effect\n        Sets the dirty flag as a side effect\n        clears the dirty flag as a side effect\n       "}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef create(name, item_constraint=None, **addl_constraints):\n        logger.debug(fmt(\"Constructing ArrayValidator with {} and {}\", item_constraint, addl_constraints))\n        from python_jsonschema_objects import classbuilder\n        klassbuilder = addl_constraints.pop(\"classbuilder\", None)\n        props = {}\n\n        if item_constraint is not None:\n            if isinstance(item_constraint, (tuple, list)):\n                for i, elem in enumerate(item_constraint):\n                    isdict = isinstance(elem, (dict,))\n                    isklass = isinstance( elem, type) and util.safe_issubclass(\n                        elem, (classbuilder.ProtocolBase, classbuilder.LiteralValue))\n\n                    if not any([isdict, isklass]):\n                        raise TypeError(\n                            \"Item constraint (position {0}) is not a schema\".format(i))\n            elif isinstance(item_constraint, (classbuilder.TypeProxy, classbuilder.TypeRef)):\n                pass\n            elif util.safe_issubclass(item_constraint, ArrayWrapper):\n                pass\n            else:\n                isdict = isinstance(item_constraint, (dict,))\n                isklass = isinstance( item_constraint, type) and util.safe_issubclass(\n                    item_constraint, (classbuilder.ProtocolBase, classbuilder.LiteralValue))\n\n                if not any([isdict, isklass]):\n                    raise TypeError(\"Item constraint is not a schema\")\n\n                if isdict and '$ref' in item_constraint:\n                    if klassbuilder is None:\n                        raise TypeError(\"Cannot resolve {0} without classbuilder\"\n                                        .format(item_constraint['$ref']))\n\n                    uri = item_constraint['$ref']\n                    if uri in klassbuilder.resolved:\n                        logger.debug(util.lazy_format(\n                            \"Using previously resolved object for {0}\", uri))\n                    else:\n                        logger.debug(util.lazy_format(\"Resolving object for {0}\", uri))\n\n                        with klassbuilder.resolver.resolving(uri) as resolved:\n                            # Set incase there is a circular reference in schema definition\n                            klassbuilder.resolved[uri] = None\n                            klassbuilder.resolved[uri] = klassbuilder.construct(\n                                uri,\n                                resolved,\n                                (classbuilder.ProtocolBase,))\n\n                    item_constraint = klassbuilder.resolved[uri]\n\n                elif isdict and item_constraint.get('type') == 'array':\n                    # We need to create a sub-array validator.\n                    item_constraint = ArrayWrapper.create(name + \"#sub\",\n                                                          item_constraint=item_constraint[\n                                                                'items'],\n                                                          addl_constraints=item_constraint)\n                elif isdict and 'oneOf' in item_constraint:\n                    # We need to create a TypeProxy validator\n                    uri = \"{0}_{1}\".format(name, \"<anonymous_list_type>\")\n                    type_array = []\n                    for i, item_detail in enumerate(item_constraint['oneOf']):\n                        if '$ref' in item_detail:\n                            subtype = klassbuilder.construct(\n                                util.resolve_ref_uri(\n                                    klassbuilder.resolver.resolution_scope,\n                                    item_detail['$ref']),\n                                item_detail)\n                        else:\n                            subtype = klassbuilder.construct(\n                                uri + \"_%s\" % i, item_detail)\n\n                        type_array.append(subtype)\n\n                    item_constraint = classbuilder.TypeProxy(type_array)\n\n                elif isdict and item_constraint.get('type') == 'object':\n                    \"\"\" We need to create a ProtocolBase object for this anonymous definition\"\"\"\n                    uri = \"{0}_{1}\".format(name, \"<anonymous_list_type>\")\n                    item_constraint = klassbuilder.construct(\n                        uri, item_constraint)\n\n        props['__itemtype__'] = item_constraint\n\n        strict = addl_constraints.pop('strict', False)\n        props['_strict_'] = strict\n        props.update(addl_constraints)\n\n        validator = type(str(name), (ArrayWrapper,), props)\n\n        return validator", "response": "Create an array validator based on the passed in constraints."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nadding the FencedBlockPreprocessor to the Markdown instance.", "response": "def extendMarkdown(self, md, md_globals):\n        \"\"\" Add FencedBlockPreprocessor to the Markdown instance. \"\"\"\n        md.registerExtension(self)\n\n        md.preprocessors.add('fenced_code_block',\n                             SpecialFencePreprocessor(md),\n                             \">normalize_whitespace\")"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nmerge JSON schema requirements into a dictionary.", "response": "def propmerge(into, data_from):\n    \"\"\" Merge JSON schema requirements into a dictionary \"\"\"\n    newprops = copy.deepcopy(into)\n\n    for prop, propval in six.iteritems(data_from):\n        if prop not in newprops:\n            newprops[prop] = propval\n            continue\n\n        new_sp = newprops[prop]\n        for subprop, spval in six.iteritems(propval):\n            if subprop not in new_sp:\n                new_sp[subprop] = spval\n\n            elif subprop == 'enum':\n                new_sp[subprop] = set(spval) & set(new_sp[subprop])\n\n            elif subprop == 'type':\n                if spval != new_sp[subprop]:\n                    raise TypeError(\"Type cannot conflict in allOf'\")\n\n            elif subprop in ('minLength', 'minimum'):\n                new_sp[subprop] = (new_sp[subprop] if\n                                   new_sp[subprop] > spval else spval)\n            elif subprop in ('maxLength', 'maximum'):\n                new_sp[subprop] = (new_sp[subprop] if\n                                   new_sp[subprop] < spval else spval)\n            elif subprop == 'multipleOf':\n                if new_sp[subprop] % spval == 0:\n                    new_sp[subprop] = spval\n                else:\n                    raise AttributeError(\n                        \"Cannot set conflicting multipleOf values\")\n            else:\n                new_sp[subprop] = spval\n\n        newprops[prop] = new_sp\n\n    return newprops"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a dictionary containing the current values of the object.", "response": "def as_dict(self):\n        \"\"\" Return a dictionary containing the current values\n        of the object.\n\n        Returns:\n            (dict): The object represented as a dictionary\n        \"\"\"\n        out = {}\n        for prop in self:\n            propval = getattr(self, prop)\n\n            if hasattr(propval, 'for_json'):\n                out[prop] = propval.for_json()\n            elif isinstance(propval, list):\n                out[prop] = [getattr(x, 'for_json', lambda:x)() for x in propval]\n            elif isinstance(propval, (ProtocolBase, LiteralValue)):\n                out[prop] = propval.as_dict()\n            elif propval is not None:\n                out[prop] = propval\n\n        return out"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef from_json(cls, jsonmsg):\n        import json\n        msg = json.loads(jsonmsg)\n        obj = cls(**msg)\n        obj.validate()\n        return obj", "response": "Create an object from a JSON string."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\napplying all defined validations to the current state of the object and raises an error if they are not met.", "response": "def validate(self):\n        \"\"\" Applies all defined validation to the current\n        state of the object, and raises an error if\n        they are not all met.\n\n        Raises:\n            ValidationError: if validations do not pass\n        \"\"\"\n\n        missing = self.missing_property_names()\n\n        if len(missing) > 0:\n            raise validators.ValidationError(\n                \"'{0}' are required attributes for {1}\"\n                            .format(missing, self.__class__.__name__))\n\n        for prop, val in six.iteritems(self._properties):\n            if val is None:\n                continue\n\n            if isinstance(val, ProtocolBase):\n                val.validate()\n            elif getattr(val, 'isLiteralClass', None) is True:\n                val.validate()\n            elif isinstance(val, list):\n                for subval in val:\n                  subval.validate()\n            else:\n                # This object is of the wrong type, but just try setting it\n                # The property setter will enforce its correctness\n                # and handily coerce its type at the same time\n                setattr(self, prop, val)\n\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef missing_property_names(self):\n\n        propname = lambda x: self.__prop_names__[x]\n        missing = []\n        for x in self.__required__:\n\n            # Allow the null type\n            propinfo = self.propinfo(propname(x))\n            null_type = False\n            if 'type' in propinfo:\n                type_info = propinfo['type']\n                null_type = (type_info == 'null'\n                             or isinstance(type_info, (list, tuple))\n                             and 'null' in type_info)\n            elif 'oneOf' in propinfo:\n                for o in propinfo['oneOf']:\n                    type_info = o.get('type')\n                    if type_info and type_info == 'null' \\\n                            or isinstance(type_info, (list, tuple)) \\\n                            and 'null' in type_info:\n                        null_type = True\n                        break\n\n            if (propname(x) not in self._properties and null_type) or \\\n                    (self._properties[propname(x)] is None and not null_type):\n                missing.append(x)\n\n        return missing", "response": "Returns a list of properties which are required and missing."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef construct(self, uri, *args, **kw):\n        logger.debug(util.lazy_format(\"Constructing {0}\", uri))\n        if ('override' not in kw or kw['override'] is False) \\\n                and uri in self.resolved:\n            logger.debug(util.lazy_format(\"Using existing {0}\", uri))\n            return self.resolved[uri]\n        else:\n            ret = self._construct(uri, *args, **kw)\n        logger.debug(util.lazy_format(\"Constructed {0}\", ret))\n\n        return ret", "response": "Wrapper to debug things"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nbuilds a LiteralValue class.", "response": "def _build_literal(self, nm, clsdata):\n      \"\"\"@todo: Docstring for _build_literal\n\n      :nm: @todo\n      :clsdata: @todo\n      :returns: @todo\n\n      \"\"\"\n      cls = type(str(nm), tuple((LiteralValue,)), {\n        '__propinfo__': {\n            '__literal__': clsdata,\n            '__title__': clsdata.get('title'),\n            '__default__': clsdata.get('default')}\n        })\n\n      return cls"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _build_object(self, nm, clsdata, parents,**kw):\n        logger.debug(util.lazy_format(\"Building object {0}\", nm))\n\n        # To support circular references, we tag objects that we're\n        # currently building as \"under construction\"\n        self.under_construction.add(nm)\n\n        props = {}\n        defaults = set()\n\n        properties = {}\n        for p in parents:\n            properties = util.propmerge(properties, p.__propinfo__)\n\n        if 'properties' in clsdata:\n            properties = util.propmerge(properties, clsdata['properties'])\n\n        name_translation = {}\n\n        for prop, detail in properties.items():\n            logger.debug(util.lazy_format(\"Handling property {0}.{1}\",nm, prop))\n            properties[prop]['raw_name'] = prop\n            name_translation[prop] = prop.replace('@', '')\n            prop = name_translation[prop]\n\n            if detail.get('default', None) is not None:\n                defaults.add(prop)\n\n            if detail.get('type', None) == 'object':\n                uri = \"{0}/{1}_{2}\".format(nm,\n                                           prop, \"<anonymous>\")\n                self.resolved[uri] = self.construct(\n                    uri,\n                    detail,\n                    (ProtocolBase,))\n\n                props[prop] = make_property(prop,\n                                            {'type': self.resolved[uri]},\n                                            self.resolved[uri].__doc__)\n                properties[prop]['type'] = self.resolved[uri]\n\n            elif 'type' not in detail and '$ref' in detail:\n                ref = detail['$ref']\n                uri = util.resolve_ref_uri(self.resolver.resolution_scope, ref)\n                logger.debug(util.lazy_format(\n                    \"Resolving reference {0} for {1}.{2}\",\n                    ref, nm, prop\n                ))\n                if uri in self.resolved:\n                    typ = self.resolved[uri]\n                else:\n                    typ = self.construct(uri, detail, (ProtocolBase,))\n\n                props[prop] = make_property(prop,\n                                            {'type': typ},\n                                            typ.__doc__)\n                properties[prop]['$ref'] = uri\n                properties[prop]['type'] = typ\n\n            elif 'oneOf' in detail:\n                potential = self.resolve_classes(detail['oneOf'])\n                logger.debug(util.lazy_format(\"Designating {0} as oneOf {1}\", prop, potential))\n                desc = detail[\n                    'description'] if 'description' in detail else \"\"\n                props[prop] = make_property(prop,\n                                            {'type': potential}, desc\n                                            )\n\n            elif 'type' in detail and detail['type'] == 'array':\n                if 'items' in detail and isinstance(detail['items'], dict):\n                    if '$ref' in detail['items']:\n                        uri = util.resolve_ref_uri(\n                            self.resolver.resolution_scope,\n                            detail['items']['$ref'])\n                        typ = self.construct(uri, detail['items'])\n                        constraints = copy.copy(detail)\n                        constraints['strict'] = kw.get('strict')\n                        propdata = {\n                            'type': 'array',\n                            'validator': python_jsonschema_objects.wrapper_types.ArrayWrapper.create(\n                                uri,\n                                item_constraint=typ,\n                                **constraints)}\n\n                    else:\n                        uri = \"{0}/{1}_{2}\".format(nm,\n                                                   prop, \"<anonymous_field>\")\n                        try:\n                            if 'oneOf' in detail['items']:\n                                typ = TypeProxy([\n                                    self.construct(uri + \"_%s\" % i, item_detail)\n                                    if '$ref' not in item_detail else\n                                    self.construct(util.resolve_ref_uri(\n                                        self.resolver.resolution_scope,\n                                        item_detail['$ref']),\n                                        item_detail)\n\n                                    for i, item_detail in enumerate(detail['items']['oneOf'])]\n                                    )\n                            else:\n                                typ = self.construct(uri, detail['items'])\n\n                            constraints = copy.copy(detail)\n                            constraints['strict'] = kw.get('strict')\n                            propdata = {'type': 'array',\n                                        'validator': python_jsonschema_objects.wrapper_types.ArrayWrapper.create(\n                                            uri,\n                                            item_constraint=typ,\n                                            **constraints)}\n\n                        except NotImplementedError:\n                            typ = detail['items']\n                            constraints = copy.copy(detail)\n                            constraints['strict'] = kw.get('strict')\n                            propdata = {'type': 'array',\n                                        'validator': python_jsonschema_objects.wrapper_types.ArrayWrapper.create(\n                                            uri,\n                                            item_constraint=typ,\n                                            **constraints)}\n\n                    props[prop] = make_property(prop,\n                                                propdata,\n                                                typ.__doc__)\n                elif 'items' in detail:\n                    typs = []\n                    for i, elem in enumerate(detail['items']):\n                        uri = \"{0}/{1}/<anonymous_{2}>\".format(nm, prop, i)\n                        typ = self.construct(uri, elem)\n                        typs.append(typ)\n\n                    props[prop] = make_property(prop,\n                                                {'type': typs},\n                                                )\n\n            else:\n                desc = detail[\n                    'description'] if 'description' in detail else \"\"\n                uri = \"{0}/{1}\".format(nm, prop)\n                typ = self.construct(uri, detail)\n\n                props[prop] = make_property(prop, {'type': typ}, desc)\n\n        \"\"\" If this object itself has a 'oneOf' designation, then\n        make the validation 'type' the list of potential objects.\n        \"\"\"\n        if 'oneOf' in clsdata:\n            klasses = self.resolve_classes(clsdata['oneOf'])\n            # Need a validation to check that it meets one of them\n            props['__validation__'] = {'type': klasses}\n\n        props['__extensible__'] = pattern_properties.ExtensibleValidator(\n            nm,\n            clsdata,\n            self)\n\n        props['__prop_names__'] = name_translation\n\n        props['__propinfo__'] = properties\n        required = set.union(*[p.__required__ for p in parents])\n\n        if 'required' in clsdata:\n            for prop in clsdata['required']:\n                required.add(prop)\n\n        invalid_requires = [req for req in required if req not in props['__propinfo__']]\n        if len(invalid_requires) > 0:\n          raise validators.ValidationError(\"Schema Definition Error: {0} schema requires \"\n                                           \"'{1}', but properties are not defined\"\n                                           .format(nm, invalid_requires))\n\n        props['__required__'] = required\n        props['__has_default__'] = defaults\n        if required and kw.get(\"strict\"):\n            props['__strict__'] = True\n\n        props['__title__'] = clsdata.get('title')\n        cls = type(str(nm.split('/')[-1]), tuple(parents), props)\n        self.under_construction.remove(nm)\n\n        return cls", "response": "Builds the object with the given name."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nbuilds all of the classes in the JSONSchema.", "response": "def build_classes(self,strict=False, named_only=False, standardize_names=True):\n        \"\"\"\n        Build all of the classes named in the JSONSchema.\n\n        Class names will be transformed using inflection by default, so names\n        with spaces in the schema will be camelcased, while names without\n        spaces will have internal capitalization dropped. Thus \"Home Address\"\n        becomes \"HomeAddress\", while \"HomeAddress\" becomes \"Homeaddress\" To\n        disable this behavior, pass standardize_names=False, but be aware\n        that accessing names with spaces from the namespace can be\n        problematic.\n\n        Args:\n            strict: (bool) use this to validate required fields while creating the class\n            named_only: (bool) If true, only properties with an actual title attribute will\n                be included in the resulting namespace (although all will be generated).\n            standardize_names: (bool) If true (the default), class names will be tranformed\n                by camel casing\n\n        Returns:\n            A namespace containing all the generated classes\n\n        \"\"\"\n        kw = {\"strict\": strict}\n        builder = classbuilder.ClassBuilder(self.resolver)\n        for nm, defn in iteritems(self.schema.get('definitions', {})):\n            uri = python_jsonschema_objects.util.resolve_ref_uri(\n                self.resolver.resolution_scope,\n                \"#/definitions/\" + nm)\n            builder.construct(uri, defn, **kw)\n\n        if standardize_names:\n            name_transform = lambda t: inflection.camelize(inflection.parameterize(six.text_type(t), '_'))\n        else:\n            name_transform = lambda t: t\n\n        nm = self.schema['title'] if 'title' in self.schema else self.schema['id']\n        nm = inflection.parameterize(six.text_type(nm), '_')\n\n        builder.construct(nm, self.schema,**kw)\n        self._resolved = builder.resolved\n\n        classes = {}\n        for uri, klass in six.iteritems(builder.resolved):\n            title = getattr(klass, '__title__', None)\n            if title is not None:\n                classes[name_transform(title)] = klass\n            elif not named_only:\n                classes[name_transform(uri.split('/')[-1])] = klass\n\n        return python_jsonschema_objects.util.Namespace.from_mapping(classes)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _interp(self, data):\n        row_interpol_data = self._interp_axis(data, 0)\n        interpol_data = self._interp_axis(row_interpol_data, 1)\n\n        return interpol_data", "response": "Interpolate the data field of the n - th entry table into a single column of the n - th entry table."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ninterpolate data along a given axis.", "response": "def _interp_axis(self, data, axis):\n        \"\"\"The *data* field contains the data to be interpolated. It is\n        expected that values reach out to the *data* boundaries.\n        With *axis*=0 this method interpolates along rows and *axis*=1 it\n        interpolates along colums.\n\n        For column mode the *data* input is transposed before interpolation\n        and subsequently transposed back.\n        \"\"\"\n        if axis == 0:\n            return self._pandas_interp(data, self.row_indices)\n        \n        if axis == 1:\n            data_transposed = data.as_matrix().T\n            data_interpol_transposed = self._pandas_interp(data_transposed, \n                                                            self.col_indices)\n            data_interpol = data_interpol_transposed.as_matrix().T\n\n            return data_interpol"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ndo the interpolation and return resulting longitudes and latitudes.", "response": "def interpolate(self):\n        \"\"\"Do the interpolation and return resulting longitudes and latitudes.\n        \"\"\"\n        self.latitude = self._interp(self.lat_tiepoint)\n        self.longitude = self._interp(self.lon_tiepoint)\n\n        return self.latitude, self.longitude"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nexecute a query on the store.", "response": "def _execute(self, query, model, adapter, raw=False):\n        \"\"\"\n        We have to override this because in some situation\n        (such as with Filebackend, or any dummy backend)\n        we have to parse / adapt results *before* when can execute the query\n        \"\"\"\n        values = self.load(model, adapter)\n        return IterableStore(values=values)._execute(query, model=model, adapter=None, raw=raw)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get(self, key, default=None, reraise=False):\n        if not self.enabled:\n            if reraise:\n                raise exceptions.DisabledCache()\n            return default\n\n        try:\n            return self._get(key)\n        except exceptions.NotInCache:\n            if reraise:\n                raise\n            return default", "response": "Get the given key from the cache if present."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsets the given key to the given value in the cache.", "response": "def set(self, key, value, timeout=NotSet):\n        \"\"\"\n        Set the given key to the given value in the cache.\n        A timeout may be provided, otherwise, the :py:attr:`Cache.default_timeout`\n        will be used.\n\n        :param key: the key to which the value will be bound\n        :type key: str\n        :param value: the value to store in the cache\n        :param timeout: the expiration delay for the value. None means it will never expire.\n        :type timeout: integer or None\n\n        Example usage:\n\n        .. code-block:: python\n\n            # this cached value will expire after half an hour\n            cache.set('my_key', 'value', 1800)\n        \"\"\"\n        if not self.enabled:\n            return\n\n        if hasattr(value, '__call__'):\n            value = value()\n        if timeout == NotSet:\n            timeout = self.default_timeout\n        self._set(key, value, timeout)\n        return value"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a list of unique elements in the given sequence.", "response": "def unique_everseen(seq):\n    \"\"\"Solution found here : http://stackoverflow.com/questions/480214/how-do-you-remove-duplicates-from-a-list-in-python-whilst-preserving-order\"\"\"\n    seen = set()\n    seen_add = seen.add\n    return [x for x in seq if not (x in seen or seen_add(x))]"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef hints(self, **kwargs):\n        new_query = self.query.clone()\n        new_query.hints.update(kwargs)\n\n        return self._clone(query=new_query)", "response": "Update the hints of the underlying queryset"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nconverts django - s like lookup to SQLAlchemy ones", "response": "def build_filter_from_kwargs(self, **kwargs):\n        \"\"\"Convert django-s like lookup to SQLAlchemy ones\"\"\"\n        query = None\n        for path_to_convert, value in kwargs.items():\n\n            path_parts = path_to_convert.split('__')\n            lookup_class = None\n            try:\n                # We check if the path ends with something such as __gte, __lte...\n                lookup_class = lookups.registry[path_parts[-1]]\n                path_to_convert = '__'.join(path_parts[:-1])\n            except KeyError:\n                pass\n            path = lookup_to_path(path_to_convert)\n\n            if lookup_class:\n                q = QueryNode(path, lookup=lookup_class(value))\n            else:\n                q = path == value\n\n            if query:\n                query = query & q\n            else:\n                query = q\n        return query"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef locally(self):\n\n        from .backends import python\n        from . import models\n\n        store = python.IterableStore(values=self)\n        return store.query(self.manager.model).all()", "response": "Returns a list of all the items in the local dataset"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_scene_splits(nlines_swath, nlines_scan, n_cpus):\n\n    nscans = nlines_swath // nlines_scan\n    if nscans < n_cpus:\n        nscans_subscene = 1\n    else:\n        nscans_subscene = nscans // n_cpus\n    nlines_subscene = nscans_subscene * nlines_scan\n\n    return range(nlines_subscene, nlines_swath, nlines_subscene)", "response": "Calculate the line numbers where the swath will be split in smaller\n    granules for parallel processing"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef metop20kmto1km(lons20km, lats20km):\n    cols20km = np.array([0] + list(range(4, 2048, 20)) + [2047])\n    cols1km = np.arange(2048)\n    lines = lons20km.shape[0]\n    rows20km = np.arange(lines)\n    rows1km = np.arange(lines)\n\n    along_track_order = 1\n    cross_track_order = 3\n\n    satint = SatelliteInterpolator((lons20km, lats20km),\n                                   (rows20km, cols20km),\n                                   (rows1km, cols1km),\n                                   along_track_order,\n                                   cross_track_order)\n    return satint.interpolate()", "response": "Get 1km geolocation from 20km tiepoints."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef modis5kmto1km(lons5km, lats5km):\n    cols5km = np.arange(2, 1354, 5) / 5.0\n    cols1km = np.arange(1354) / 5.0\n    lines = lons5km.shape[0] * 5\n    rows5km = np.arange(2, lines, 5) / 5.0\n    rows1km = np.arange(lines) / 5.0\n\n    along_track_order = 1\n    cross_track_order = 3\n\n    satint = SatelliteInterpolator((lons5km, lats5km),\n                                   (rows5km, cols5km),\n                                   (rows1km, cols1km),\n                                   along_track_order,\n                                   cross_track_order,\n                                   chunk_size=10)\n    satint.fill_borders(\"y\", \"x\")\n    lons1km, lats1km = satint.interpolate()\n    return lons1km, lats1km", "response": "Get 1km geolocation for modis from 5km tiepoints."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nworks on multiple cores.", "response": "def _multi(fun, lons, lats, chunk_size, cores=1):\n    \"\"\"Work on multiple cores.\n    \"\"\"\n    pool = Pool(processes=cores)\n\n    splits = get_scene_splits(lons.shape[0], chunk_size, cores)\n\n    lons_parts = np.vsplit(lons, splits)\n    lats_parts = np.vsplit(lats, splits)\n\n    results = [pool.apply_async(fun,\n                                (lons_parts[i],\n                                 lats_parts[i]))\n               for i in range(len(lons_parts))]\n\n    pool.close()\n    pool.join()\n\n    lons, lats = zip(*(res.get() for res in results))\n\n    return np.vstack(lons), np.vstack(lats)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting 500m geolocation for modis from 1km tiepoints.", "response": "def modis1kmto500m(lons1km, lats1km, cores=1):\n    \"\"\"Getting 500m geolocation for modis from 1km tiepoints.\n\n    http://www.icare.univ-lille1.fr/tutorials/MODIS_geolocation\n    \"\"\"\n    if cores > 1:\n        return _multi(modis1kmto500m, lons1km, lats1km, 10, cores)\n\n    cols1km = np.arange(1354)\n    cols500m = np.arange(1354 * 2) / 2.0\n    lines = lons1km.shape[0]\n    rows1km = np.arange(lines)\n    rows500m = (np.arange(lines * 2) - 0.5) / 2.\n\n    along_track_order = 1\n    cross_track_order = 3\n\n    satint = SatelliteInterpolator((lons1km, lats1km),\n                                   (rows1km, cols1km),\n                                   (rows500m, cols500m),\n                                   along_track_order,\n                                   cross_track_order,\n                                   chunk_size=20)\n    satint.fill_borders(\"y\", \"x\")\n    lons500m, lats500m = satint.interpolate()\n    return lons500m, lats500m"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef modis1kmto250m(lons1km, lats1km, cores=1):\n    if cores > 1:\n        return _multi(modis1kmto250m, lons1km, lats1km, 10, cores)\n\n    cols1km = np.arange(1354)\n    cols250m = np.arange(1354 * 4) / 4.0\n\n    along_track_order = 1\n    cross_track_order = 3\n\n    lines = lons1km.shape[0]\n    rows1km = np.arange(lines)\n    rows250m = (np.arange(lines * 4) - 1.5) / 4.0\n\n    satint = SatelliteInterpolator((lons1km, lats1km),\n                                   (rows1km, cols1km),\n                                   (rows250m, cols250m),\n                                   along_track_order,\n                                   cross_track_order,\n                                   chunk_size=40)\n    satint.fill_borders(\"y\", \"x\")\n    lons250m, lats250m = satint.interpolate()\n\n    return lons250m, lats250m", "response": "Get 250m geolocation for modis from 1km tiepoints."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef generic_modis5kmto1km(*data5km):\n    cols5km = np.arange(2, 1354, 5)\n    cols1km = np.arange(1354)\n    lines = data5km[0].shape[0] * 5\n    rows5km = np.arange(2, lines, 5)\n    rows1km = np.arange(lines)\n\n    along_track_order = 1\n    cross_track_order = 3\n\n    satint = Interpolator(list(data5km),\n                          (rows5km, cols5km),\n                          (rows1km, cols1km),\n                          along_track_order,\n                          cross_track_order,\n                          chunk_size=10)\n    satint.fill_borders(\"y\", \"x\")\n    return satint.interpolate()", "response": "Generic function for modis5km to 1km tiepoints."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nextrapolate tiepoint lons and lats to fill in the border of the chunks.", "response": "def fill_borders(self, *args):\n        \"\"\"Extrapolate tiepoint lons and lats to fill in the border of the\n        chunks.\n        \"\"\"\n\n        to_run = []\n        cases = {\"y\": self._fill_row_borders,\n                 \"x\": self._fill_col_borders}\n        for dim in args:\n            try:\n                to_run.append(cases[dim])\n            except KeyError:\n                raise NameError(\"Unrecognized dimension: \" + str(dim))\n\n        for fun in to_run:\n            fun()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _extrapolate_cols(self, data, first=True, last=True):\n\n        if first:\n            pos = self.col_indices[:2]\n            first_column = _linear_extrapolate(pos,\n                                               (data[:, 0], data[:, 1]),\n                                               self.hcol_indices[0])\n        if last:\n            pos = self.col_indices[-2:]\n            last_column = _linear_extrapolate(pos,\n                                              (data[:, -2], data[:, -1]),\n                                              self.hcol_indices[-1])\n\n        if first and last:\n            return np.hstack((np.expand_dims(first_column, 1),\n                              data,\n                              np.expand_dims(last_column, 1)))\n        elif first:\n            return np.hstack((np.expand_dims(first_column, 1),\n                              data))\n        elif last:\n            return np.hstack((data,\n                              np.expand_dims(last_column, 1)))\n        else:\n            return data", "response": "Extrapolate the column of data to get the first and last together\n            with the data."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _fill_col_borders(self):\n\n        first = True\n        last = True\n        if self.col_indices[0] == self.hcol_indices[0]:\n            first = False\n        if self.col_indices[-1] == self.hcol_indices[-1]:\n            last = False\n        for num, data in enumerate(self.tie_data):\n            self.tie_data[num] = self._extrapolate_cols(data, first, last)\n\n        if first and last:\n            self.col_indices = np.concatenate((np.array([self.hcol_indices[0]]),\n                                               self.col_indices,\n                                               np.array([self.hcol_indices[-1]])))\n        elif first:\n            self.col_indices = np.concatenate((np.array([self.hcol_indices[0]]),\n                                               self.col_indices))\n        elif last:\n            self.col_indices = np.concatenate((self.col_indices,\n                                               np.array([self.hcol_indices[-1]])))", "response": "Fill the first and last column of the data by extrapolation."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nextrapolating the rows of data to get the first and last together with the data.", "response": "def _extrapolate_rows(self, data, row_indices, first_index, last_index):\n        \"\"\"Extrapolate the rows of data, to get the first and last together\n        with the data.\n        \"\"\"\n\n        pos = row_indices[:2]\n        first_row = _linear_extrapolate(pos,\n                                        (data[0, :], data[1, :]),\n                                        first_index)\n        pos = row_indices[-2:]\n        last_row = _linear_extrapolate(pos,\n                                       (data[-2, :], data[-1, :]),\n                                       last_index)\n        return np.vstack((np.expand_dims(first_row, 0),\n                          data,\n                          np.expand_dims(last_row, 0)))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nfill the first and last rows of the tables.", "response": "def _fill_row_borders(self):\n        \"\"\"Add the first and last rows to the data by extrapolation.\n        \"\"\"\n        lines = len(self.hrow_indices)\n        chunk_size = self.chunk_size or lines\n        factor = len(self.hrow_indices) / len(self.row_indices)\n\n        tmp_data = []\n        for num in range(len(self.tie_data)):\n            tmp_data.append([])\n        row_indices = []\n\n        for index in range(0, lines, chunk_size):\n            indices = np.logical_and(self.row_indices >= index / factor,\n                                     self.row_indices < (index\n                                                         + chunk_size) / factor)\n            ties = np.argwhere(indices).squeeze()\n            tiepos = self.row_indices[indices].squeeze()\n\n            for num, data in enumerate(self.tie_data):\n                to_extrapolate = data[ties, :]\n                if len(to_extrapolate) > 0:\n                    extrapolated = self._extrapolate_rows(to_extrapolate,\n                                                          tiepos,\n                                                          self.hrow_indices[\n                                                              index],\n                                                          self.hrow_indices[index + chunk_size - 1])\n                    tmp_data[num].append(extrapolated)\n\n            row_indices.append(np.array([self.hrow_indices[index]]))\n            row_indices.append(tiepos)\n            row_indices.append(np.array([self.hrow_indices[index\n                                                           + chunk_size - 1]]))\n\n        for num in range(len(self.tie_data)):\n            self.tie_data[num] = np.vstack(tmp_data[num])\n        self.row_indices = np.concatenate(row_indices)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _interp(self):\n        if np.all(self.hrow_indices == self.row_indices):\n            return self._interp1d()\n\n        xpoints, ypoints = np.meshgrid(self.hrow_indices,\n                                       self.hcol_indices)\n\n        for num, data in enumerate(self.tie_data):\n            spl = RectBivariateSpline(self.row_indices,\n                                      self.col_indices,\n                                      data,\n                                      s=0,\n                                      kx=self.kx_,\n                                      ky=self.ky_)\n\n            new_data_ = spl.ev(xpoints.ravel(), ypoints.ravel())\n            self.new_data[num] = new_data_.reshape(xpoints.shape).T.copy(order='C')", "response": "Interpolate the cartesian coordinates."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ninterpolating in one dimension.", "response": "def _interp1d(self):\n        \"\"\"Interpolate in one dimension.\n        \"\"\"\n        lines = len(self.hrow_indices)\n\n        for num, data in enumerate(self.tie_data):\n            self.new_data[num] = np.empty((len(self.hrow_indices),\n                                           len(self.hcol_indices)),\n                                          data.dtype)\n\n            for cnt in range(lines):\n                tck = splrep(self.col_indices, data[cnt, :], k=self.ky_, s=0)\n                self.new_data[num][cnt, :] = splev(\n                    self.hcol_indices, tck, der=0)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets longitudes from cartesian coordinates.", "response": "def get_lons_from_cartesian(x__, y__):\n    \"\"\"Get longitudes from cartesian coordinates.\n    \"\"\"\n    return rad2deg(arccos(x__ / sqrt(x__ ** 2 + y__ ** 2))) * sign(y__)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_lats_from_cartesian(x__, y__, z__, thr=0.8):\n    # if we are at low latitudes - small z, then get the\n    # latitudes only from z. If we are at high latitudes (close to the poles)\n    # then derive the latitude using x and y:\n\n    lats = np.where(np.logical_and(np.less(z__, thr * EARTH_RADIUS), \n                                   np.greater(z__, -1. * thr * EARTH_RADIUS)),\n                    90 - rad2deg(arccos(z__/EARTH_RADIUS)),\n                    sign(z__) *\n                    (90 - rad2deg(arcsin(sqrt(x__ ** 2 + y__ ** 2)\n                                         / EARTH_RADIUS))))\n    return lats", "response": "Get latitudes from cartesian coordinates."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ndefining the lon lat tie points.", "response": "def set_tiepoints(self, lon, lat):\n        \"\"\"Defines the lon,lat tie points.\n        \"\"\"\n        self.lon_tiepoint = lon\n        self.lat_tiepoint = lat"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncomputing expansion and alignment for a single node.", "response": "def compute_expansion_alignment(satz_a, satz_b, satz_c, satz_d):\n    \"\"\"All angles in radians.\"\"\"\n    zeta_a = satz_a\n    zeta_b = satz_b\n\n    phi_a = compute_phi(zeta_a)\n    phi_b = compute_phi(zeta_b)\n    theta_a = compute_theta(zeta_a, phi_a)\n    theta_b = compute_theta(zeta_b, phi_b)\n    phi = (phi_a + phi_b) / 2\n    zeta = compute_zeta(phi)\n    theta = compute_theta(zeta, phi)\n\n    c_expansion = 4 * (((theta_a + theta_b) / 2 - theta) / (theta_a - theta_b))\n\n    sin_beta_2 = scan_width / (2 * H)\n\n    d = ((R + H) / R * np.cos(phi) - np.cos(zeta)) * sin_beta_2\n    e = np.cos(zeta) - np.sqrt(np.cos(zeta) ** 2 - d ** 2)\n\n    c_alignment = 4 * e * np.sin(zeta) / (theta_a - theta_b)\n\n    return c_expansion, c_alignment"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef lonlat2xyz(lons, lats):\n    R = 6370997.0\n    x_coords = R * da.cos(da.deg2rad(lats)) * da.cos(da.deg2rad(lons))\n    y_coords = R * da.cos(da.deg2rad(lats)) * da.sin(da.deg2rad(lons))\n    z_coords = R * da.sin(da.deg2rad(lats))\n    return x_coords, y_coords, z_coords", "response": "Convert lon latitudes to cartesian coordinates."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef xyz2lonlat(x__, y__, z__):\n    R = 6370997.0\n    lons = da.rad2deg(da.arccos(x__ / da.sqrt(x__ ** 2 + y__ ** 2))) * da.sign(y__)\n    lats = da.sign(z__) * (90 - da.rad2deg(da.arcsin(da.sqrt(x__ ** 2 + y__ ** 2) / R)))\n\n    return lons, lats", "response": "Get longitudes from cartesian coordinates."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef setup_fields(attrs):\n    fields = {}\n    iterator = list(attrs.items())\n    for key, value in iterator:\n        if not isinstance(value, Field):\n            continue\n        fields[key] = value\n        del attrs[key]\n    return fields", "response": "Collect all fields declared on the class and remove them from attrs\n   "}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _parse_jing_line(line):\n    parts = line.split(':', 4)\n    filename, line, column, type_, message = [x.strip() for x in parts]\n    if type_ == 'fatal':\n        if message in KNOWN_FATAL_MESSAGES_MAPPING:\n            message = KNOWN_FATAL_MESSAGES_MAPPING[message]\n    return ErrorLine(filename, line, column, type_, message)", "response": "Parse a line of jing output to a list of line column type_ and message."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _parse_jing_output(output):\n    output = output.strip()\n    values = [_parse_jing_line(l) for l in output.split('\\n') if l]\n    return tuple(values)", "response": "Parse the jing output into a tuple of line column type and message."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nruns jing. jar using the RNG file against the given XML file.", "response": "def jing(rng_filepath, *xml_filepaths):\n    \"\"\"Run jing.jar using the RNG file against the given XML file.\"\"\"\n    cmd = ['java', '-jar']\n    cmd.extend([str(JING_JAR), str(rng_filepath)])\n    for xml_filepath in xml_filepaths:\n        cmd.append(str(xml_filepath))\n    proc = subprocess.Popen(cmd,\n                            stdin=subprocess.PIPE,\n                            stdout=subprocess.PIPE,\n                            stderr=subprocess.PIPE,\n                            close_fds=True)\n    out, err = proc.communicate()\n    return _parse_jing_output(out.decode('utf-8'))"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns an import object from text.", "response": "def import_obj_from_str(s):\n    \"\"\"Returns an import object (either ImportImport or FromImport) from text.\n    \"\"\"\n    ast_obj = ast.parse(s).body[0]\n    return ast_type_to_import_type[type(ast_obj)](ast_obj)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nconstructs an import object from a string.", "response": "def from_str(cls, s):\n        \"\"\"Construct an import object from a string.\"\"\"\n        ast_obj = ast.parse(s).body[0]\n        if not isinstance(ast_obj, cls._expected_ast_type):\n            raise AssertionError(\n                'Expected ast of type {!r} but got {!r}'.format(\n                    cls._expected_ast_type,\n                    ast_obj\n                )\n            )\n        return cls(ast_obj)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsorting the list of imports into a single segment list.", "response": "def sort(imports, separate=True, import_before_from=True, **classify_kwargs):\n    \"\"\"Sort import objects into groups.\n\n    :param list imports: FromImport / ImportImport objects\n    :param bool separate: Whether to classify and return separate segments\n        of imports based on classification.\n    :param bool import_before_from: Whether to sort `import ...` imports before\n        `from ...` imports.\n\n    For example:\n        from os import path\n        from aspy import refactor_imports\n        import sys\n        import pyramid\n\n    separate = True, import_before_from = True\n\n        import sys\n        from os import path\n\n        import pyramid\n\n        from aspy import refactor_imports\n\n    separate = True, import_before_from = False\n\n        from os import path\n        import sys\n\n        import pyramid\n\n        from aspy import refactor_imports\n\n    separate = False, import_before_from = True\n\n        import pyramid\n        import sys\n        from aspy import refactor_imports\n        from os import path\n\n    separate = False, import_before_from = False\n\n        from aspy import refactor_imports\n        from os import path\n        import pyramid\n        import sys\n    \"\"\"\n    if separate:\n        def classify_func(obj):\n            return classify_import(\n                obj.import_statement.module, **classify_kwargs\n            )\n        types = ImportType.__all__\n    else:\n        # A little cheaty, this allows future imports to sort before others\n        def classify_func(obj):\n            return classify_import(\n                obj.import_statement.module, **classify_kwargs\n            ) == ImportType.FUTURE\n        types = [True, False]\n\n    if import_before_from:\n        def sort_within(obj):\n            return (CLS_TO_INDEX[type(obj)],) + obj.sort_key\n    else:\n        def sort_within(obj):\n            return tuple(obj.sort_key)\n\n    # Partition the imports\n    imports_partitioned = collections.defaultdict(list)\n    for import_obj in imports:\n        imports_partitioned[classify_func(import_obj)].append(import_obj)\n\n    # sort each of the segments\n    for segment_key, val in imports_partitioned.items():\n        imports_partitioned[segment_key] = sorted(val, key=sort_within)\n\n    return tuple(\n        tuple(imports_partitioned[key])\n        for key in types if key in imports_partitioned\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef classify_import(module_name, application_directories=('.',)):\n    # Only really care about the first part of the path\n    base, _, _ = module_name.partition('.')\n    found, module_path, is_builtin = _get_module_info(\n        base, application_directories,\n    )\n    if base == '__future__':\n        return ImportType.FUTURE\n    # Relative imports: `from .foo import bar`\n    elif base == '':\n        return ImportType.APPLICATION\n    # If imp tells us it is builtin, it is builtin\n    elif is_builtin:\n        return ImportType.BUILTIN\n    # If the module path exists in the project directories\n    elif _module_path_is_local_and_is_not_symlinked(\n            module_path, application_directories,\n    ):\n        return ImportType.APPLICATION\n    # Otherwise we assume it is a system module or a third party module\n    elif (\n            found and\n            PACKAGES_PATH not in module_path and\n            not _due_to_pythonpath(module_path)\n    ):\n        return ImportType.BUILTIN\n    else:\n        return ImportType.THIRD_PARTY", "response": "Classifies an import by its package."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngives an element - like object containing a root xml element return the common metadata properties.", "response": "def parse_metadata(elm_tree):\n    \"\"\"Given an element-like object (:mod:`lxml.etree`)\n    lookup the metadata and return the found elements\n\n    :param elm_tree: the root xml element\n    :type elm_tree: an element-like object from :mod:`lxml.etree`\n    :returns: common metadata properties\n    :rtype: dict\n\n    \"\"\"\n    xpath = make_cnx_xpath(elm_tree)\n    role_xpath = lambda xp: tuple(xpath(xp)[0].split())  # noqa: E731\n\n    props = {\n        'id': _maybe(xpath('//md:content-id/text()')),\n        'version': xpath('//md:version/text()')[0],\n        'created': xpath('//md:created/text()')[0],\n        'revised': xpath('//md:revised/text()')[0],\n        'title': xpath('//md:title/text()')[0],\n        'license_url': xpath('//md:license/@url')[0],\n        'language': xpath('//md:language/text()')[0],\n        'authors': role_xpath('//md:role[@type=\"author\"]/text()'),\n        'maintainers': role_xpath('//md:role[@type=\"maintainer\"]/text()'),\n        'licensors': role_xpath('//md:role[@type=\"licensor\"]/text()'),\n        'keywords': tuple(xpath('//md:keywordlist/md:keyword/text()')),\n        'subjects': tuple(xpath('//md:subjectlist/md:subject/text()')),\n        'abstract': _squash_to_text(\n            _maybe(xpath('//md:abstract')),\n            remove_namespaces=True,\n        ),\n        'print_style': _maybe(\n            xpath('//col:param[@name=\"print-style\"]/@value'),\n        ),\n        'derived_from': {\n            'uri': _maybe(xpath('//md:derived-from/@url')),\n            'title': _maybe(xpath('//md:derived-from/md:title/text()')),\n        },\n    }\n    return props"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef validate_cnxml(*content_filepaths):\n    content_filepaths = [Path(path).resolve() for path in content_filepaths]\n    return jing(CNXML_JING_RNG, *content_filepaths)", "response": "Validates the given CNXML file against the CNXML - JING RNG."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nvalidating the given COLLXML file against the collxml - jing. rng RNG.", "response": "def validate_collxml(*content_filepaths):\n    \"\"\"Validates the given COLLXML file against the collxml-jing.rng RNG.\"\"\"\n    content_filepaths = [Path(path).resolve() for path in content_filepaths]\n    return jing(COLLXML_JING_RNG, *content_filepaths)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef action(args):\n    log.info('loading reference package')\n\n    r = refpkg.Refpkg(args.refpkg, create=False)\n\n    # First check if we can do n rollbacks\n    q = r.contents\n    for i in range(args.n):\n        if q['rollback'] is None:\n            log.error('Cannot rollback {} changes; '\n                      'refpkg only records {} changes.'.format(args.n, i))\n            return 1\n        else:\n            q = q['rollback']\n\n    for i in range(args.n):\n        r.rollback()\n\n    return 0", "response": "Roll back a refpkg."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef set_targets(x, delta=10):\n    data = [] # Keep track of targets\n    for row, _ in x.iterrows():\n        if row == x.shape[0] - 1: # Can't predict yet, done.\n            break\n\n        # Get closing prices\n        curr_close = x.close[row]\n        next_close = x.close[row + 1]\n        high_close = next_close + (delta / 2) # Pos. neutral zone threshold\n        low_close = next_close - (delta / 2)  # Neg. neutral zone threshold\n\n        # Get target\n        if curr_close < low_close:\n            target = TARGET_CODES['bearish']\n        elif curr_close > high_close:\n            target = TARGET_CODES['bullish']\n        else:\n            target = TARGET_CODES['neutral']\n        data.append(target)\n\n    return pd.Series(data=data, dtype=np.int32, name='target')", "response": "Sets the target market trend for a date - based dataset."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef eval_features(json):\n    return {'close'    : json[-1]['close'],\n            'sma'      : SMA.eval_from_json(json),\n            'rsi'      : RSI.eval_from_json(json),\n            'so'       : SO.eval_from_json(json),\n            'obv'      : OBV.eval_from_json(json)}", "response": "Evaluates technical analysis features from JSON data."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nconvert an int target code to a target name.", "response": "def target_code_to_name(code):\n    \"\"\" Converts an int target code to a target name\n\n    Since self.TARGET_CODES is a 1:1 mapping, perform a reverse lookup\n    to get the more readable name.\n\n    Args:\n        code: Value from self.TARGET_CODES\n\n    Returns:\n        String target name corresponding to the given code.\n    \"\"\"\n    TARGET_NAMES = {v: k for k, v in TARGET_CODES.items()}\n    return TARGET_NAMES[code]"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef setup_model(x, y, model_type='random_forest', seed=None, **kwargs):\n    assert len(x) > 1 and len(y) > 1, 'Not enough data objects to train on (minimum is at least two, you have (x: {0}) and (y: {1}))'.format(len(x), len(y))\n\n    sets = namedtuple('Datasets', ['train', 'test'])\n    x_train, x_test, y_train, y_test = train_test_split(x,\n                                                        y,\n                                                        random_state=seed,\n                                                        shuffle=False)\n    x = sets(x_train, x_test)\n    y = sets(y_train, y_test)\n\n    if model_type == 'random_forest' or model_type == 'rf':\n        model = rf.RandomForest(x, y, random_state=seed, **kwargs)\n    elif model_type == 'deep_neural_network' or model_type == 'dnn':\n        model = dnn.DeepNeuralNetwork(x, y, **kwargs)\n    else:\n        raise ValueError('Invalid model type kwarg')\n    return model", "response": "Initializes a machine learning model for the given data set."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets market chart data from today to a previous date", "response": "def get_json(self):\n        \"\"\" Gets market chart data from today to a previous date \"\"\"\n        today = dt.now()\n        DIRECTION = 'last'\n        epochs = date.get_end_start_epochs(today.year, today.month, today.day,\n                                           DIRECTION, self.unit, self.count)\n        return poloniex.chart_json(epochs['shifted'], epochs['initial'],\n                                   self.period, self.symbol)[0]"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef set_features(self, partition=1):\n        if len(self.json) < partition + 1:\n            raise ValueError('Not enough dates for the specified partition size: {0}.  Try a smaller partition.'.format(partition))\n\n        data = []\n        for offset in range(len(self.json) - partition):\n            json = self.json[offset : offset + partition]\n            data.append(eval_features(json))\n        return pd.DataFrame(data=data, dtype=np.float32)", "response": "Parses market data JSON for technical analysis indicators and sets the features of the technical analysis indicators."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsets the long features of double the duration of the entry.", "response": "def set_long_features(self, features, columns_to_set=[], partition=2):\n        \"\"\" Sets features of double the duration\n\n        Example: Setting 14 day RSIs to longer will create add a\n            feature column of a 28 day RSIs.\n\n        Args:\n            features: Pandas DataFrame instance with columns as numpy.float32 features.\n            columns_to_set: List of strings of feature names to make longer\n            partition: Int of how many dates to take into consideration\n                when evaluating technical analysis indicators.\n\n        Returns:\n            Pandas DataFrame instance with columns as numpy.float32 features.\n        \"\"\"\n        # Create long features DataFrame\n        features_long = self.set_features(partition=2 * partition)\n\n        # Remove features not specified by args.long\n        unwanted_features = [f for f in features.columns if f not in columns_to_set]\n        features_long = features_long.drop(unwanted_features, axis=1)\n\n        # Prefix long columns with 'long_' to fix naming conflicts\n        features_long.columns = ['long_{0}'.format(f) for f in features_long.columns]\n\n        # Merge the two DataFrames\n        skip = partition\n        return pd.concat([features[skip:].reset_index(drop=True),\n                         features_long],\n                         axis=1)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef feature_importances(self):\n        feature_names = [feature for feature in self.features.train]\n        return list(zip(feature_names, self.feature_importances_))", "response": "Return list of features and their importances in classification"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef exitcode(self):\n        if self._process is None:\n            raise ProcessError(\n                \"Process '%s' has not been started yet\" % self.name)\n        return self._process.exitcode", "response": "Return the exit code of the process."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ninitializing the instance attributes.", "response": "def initialize(self):\n        \"\"\"\n        Initialize instance attributes. You can override this method in\n        the subclasses.\n        \"\"\"\n        self.main_pid = os.getpid()\n        self.processes.extend(self.init_service_processes())\n        self.processes.extend(self.init_tornado_workers())"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nhandle SIGUSR1 signal. Call function which is defined in the cfg file.", "response": "def sigusr1_handler(self, unused_signum, unused_frame):\n        \"\"\"\n        Handle SIGUSR1 signal. Call function which is defined in the\n        **settings.SIGUSR1_HANDLER**. If main process, forward the\n        signal to all child processes.\n        \"\"\"\n        for process in self.processes:\n            if process.pid and os.getpid() == self.main_pid:\n                try:\n                    os.kill(process.pid, signal.SIGUSR1)\n                except ProcessLookupError:\n                    pass\n        if self._sigusr1_handler_func is not None:\n            self._sigusr1_handler_func(self.context)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ninitializes the service processes.", "response": "def init_service_processes(self):\n        \"\"\"\n        Prepare processes defined in the **settings.SERVICE_PROCESSES**.\n        Return :class:`list` of the :class:`ProcessWrapper` instances.\n        \"\"\"\n        processes = []\n\n        for process_struct in getattr(\n                self.context.config.settings, 'SERVICE_PROCESSES', ()):\n            process_cls = import_object(process_struct[0])\n            wait_unless_ready, timeout = process_struct[1], process_struct[2]\n\n            self.logger.info(\"Init service process '%s'\", process_cls.__name__)\n\n            processes.append(\n                ProcessWrapper(\n                    process_cls, (self.context,),\n                    wait_unless_ready=wait_unless_ready,\n                    timeout=timeout\n                )\n            )\n\n        return processes"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef init_tornado_workers(self):\n        workers = []\n\n        for tornado_app in get_tornado_apps(self.context, debug=False):\n            interface = tornado_app.settings['interface']\n\n            if not interface.port and not interface.unix_socket:\n                raise ValueError(\n                    'Interface MUST listen either on TCP '\n                    'or UNIX socket or both')\n\n            name, processes, host, port, unix_socket = (\n                interface.name, interface.processes,\n                interface.host, interface.port, interface.unix_socket)\n            if processes <= 0:\n                processes = tornado.process.cpu_count()\n            sockets = []\n            listen_on = []\n\n            if port:\n                sockets.extend(tornado.netutil.bind_sockets(port, host))\n                listen_on.append(\"{:s}:{:d}\".format(host, port))\n            if unix_socket:\n                sockets.append(tornado.netutil.bind_unix_socket(unix_socket))\n                listen_on.append(\"{:s}\".format(interface.unix_socket))\n\n            self.logger.info(\n                \"Init %d worker(s) for interface '%s' (%s)\",\n                processes, name, \", \".join(listen_on))\n\n            for dummy_i in six.moves.range(processes):\n                worker = ProcessWrapper(\n                    TornadoProcess, (tornado_app, sockets),\n                    wait_unless_ready=True, timeout=5.0,\n                    name=name\n                )\n                workers.append(worker)\n\n        return workers", "response": "Prepare worker instances for all Tornado applications. Return a list of the ProcessWrapper instances."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef start_processes(self, max_restarts=-1):\n        while 1:\n            for process in self.processes:\n                if not process:\n                    # When process has not been started, start it\n                    if not process.has_started:\n                        process.start()\n                        continue\n                    # When process has stopped, start it again\n                    exitcode = process.exitcode\n                    if exitcode != 0:\n                        # Process has been signaled or crashed\n                        if exitcode > 0:\n                            self.logger.error(\n                                \"Process '%s' with pid %d died with exitcode \"\n                                \"%d\", process.name, process.pid, exitcode\n                            )\n                        else:\n                            self.logger.error(\n                                \"Process '%s' with pid %d died due to %s\",\n                                process.name, process.pid,\n                                SIGNALS_TO_NAMES_DICT[abs(exitcode)]\n                            )\n                        # Max restarts has been reached, exit\n                        if not max_restarts:\n                            self.logger.fatal(\"Too many child restarts\")\n                            break\n                        # Start process again\n                        process.start()\n                        # Decrement max_restarts counter\n                        if max_restarts > 0:\n                            max_restarts -= 1\n                    else:\n                        # Process has stopped without error\n                        self.logger.info(\n                            \"Process '%s' with pid %d has stopped\",\n                            process.name, process.pid\n                        )\n                        # Start process again\n                        process.start()\n                        self.logger.info(\n                            \"Process '%s' has been started with pid %d\",\n                            process.name, process.pid\n                        )\n            else:\n                time.sleep(0.25)\n                continue\n            break", "response": "Start processes and check their status. When some processes crashes start it again."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreading a CSV taxonomy from handle into a Tree.", "response": "def taxtable_to_tree(handle):\n    \"\"\"Read a CSV taxonomy from *handle* into a Tree.\"\"\"\n    c = csv.reader(handle, quoting=csv.QUOTE_NONNUMERIC)\n    header = next(c)\n    rootdict = dict(list(zip(header, next(c))))\n    t = Tree(rootdict['tax_id'], rank=rootdict[\n             'rank'], tax_name=rootdict['tax_name'])\n    for l in c:\n        d = dict(list(zip(header, l)))\n        target = t.descendents[d['parent_id']]\n        target(Tree(d['tax_id'], rank=d['rank'], tax_name=d['tax_name']))\n    return t"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a set of species tax_ids which will make those in tax_ids not lonely.", "response": "def lonely_company(taxonomy, tax_ids):\n    \"\"\"Return a set of species tax_ids which will makes those in *tax_ids* not lonely.\n\n    The returned species will probably themselves be lonely.\n    \"\"\"\n    return [taxonomy.species_below(taxonomy.sibling_of(t)) for t in tax_ids]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a set of non - lonely species tax_ids that will make those in tax_ids not lonely.", "response": "def solid_company(taxonomy, tax_ids):\n    \"\"\"Return a set of non-lonely species tax_ids that will make those in *tax_ids* not lonely.\"\"\"\n    res = []\n    for t in tax_ids:\n        res.extend(taxonomy.nary_subtree(taxonomy.sibling_of(t), 2) or [])\n    return res"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nevaluate the algorithm of the OBV .", "response": "def eval_algorithm(curr, prev):\n        \"\"\" Evaluates OBV\n\n        Args:\n            curr: Dict of current volume and close\n            prev: Dict of previous OBV and close\n\n        Returns:\n            Float of OBV\n        \"\"\"\n        if curr['close'] > prev['close']:\n            v = curr['volume']\n        elif curr['close'] < prev['close']:\n            v = curr['volume'] * -1\n        else:\n            v = 0\n        return prev['obv'] + v"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nevaluates the OBV from a JSON object.", "response": "def eval_from_json(json):\n        \"\"\" Evaluates OBV from JSON (typically Poloniex API response)\n\n        Args:\n            json: List of dates where each entry is a dict of raw market data.\n\n        Returns:\n            Float of OBV\n        \"\"\"\n        closes = poloniex.get_attribute(json, 'close')\n        volumes = poloniex.get_attribute(json, 'volume')\n        obv = 0\n        for date in range(1, len(json)):\n            curr = {'close': closes[date], 'volume': volumes[date]}\n            prev = {'close': closes[date - 1], 'obv': obv}\n            obv = OBV.eval_algorithm(curr, prev)\n        return obv"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating a temporary file and return its name.", "response": "def scratch_file(unlink=True, **kwargs):\n    \"\"\"Create a temporary file and return its name.\n\n    Additional arguments are passed to :class:`tempfile.NamedTemporaryFile`\n\n    At the start of the with block a secure, temporary file is created\n    and its name returned.  At the end of the with block it is\n    deleted.\n    \"\"\"\n    kwargs['delete'] = False\n    tf = tempfile.NamedTemporaryFile(**kwargs)\n    tf.close()\n    try:\n        yield tf.name\n    finally:\n        if unlink:\n            os.unlink(tf.name)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn an open file object for a file in the reference package.", "response": "def open(self, name, *mode):\n        \"\"\"\n        Return an open file object for a file in the reference package.\n        \"\"\"\n        return self.file_factory(self.file_path(name), *mode)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn an open file object for a particular resource in this reference package.", "response": "def open_resource(self, resource, *mode):\n        \"\"\"\n        Return an open file object for a particular named resource in this\n        reference package.\n        \"\"\"\n        return self.open(self.resource_name(resource), *mode)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef resource_name(self, resource):\n        if not(resource in self.contents['files']):\n            raise ValueError(\"No such resource %r in refpkg\" % (resource,))\n        return self.contents['files'][resource]", "response": "Return the name of the file within the reference package for a particular named resource."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the stored MD5 sum for a particular resource.", "response": "def resource_md5(self, resource):\n        \"\"\"Return the stored MD5 sum for a particular named resource.\"\"\"\n        if not(resource in self.contents['md5']):\n            raise ValueError(\"No such resource %r in refpkg\" % (resource,))\n        return self.contents['md5'][resource]"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset some default values in the manifest.", "response": "def _set_defaults(self):\n        \"\"\"\n        Set some default values in the manifest.\n\n        This method should be called after loading from disk, but before\n        checking the integrity of the reference package.\n        \"\"\"\n        self.contents.setdefault('log', [])\n        self.contents.setdefault('rollback', None)\n        self.contents.setdefault('rollforward', None)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nwrites any changes made on Refpkg to disk.", "response": "def _sync_to_disk(self):\n        \"\"\"Write any changes made on Refpkg to disk.\n\n        Other methods of Refpkg that alter the contents of the package\n        will call this method themselves.  Generally you should never\n        have to call it by hand.  The only exception would be if\n        another program has changed the Refpkg on disk while your\n        program is running and you want to force your version over it.\n        Otherwise it should only be called by other methods of refpkg.\n        \"\"\"\n        with self.open_manifest('w') as h:\n            json.dump(self.contents, h, indent=4)\n            h.write('\\n')"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _sync_from_disk(self):\n\n        try:\n            fobj = self.open_manifest('r')\n        except IOError as e:\n            if e.errno == errno.ENOENT:\n                raise ValueError(\n                    \"couldn't find manifest file in %s\" % (self.path,))\n            elif e.errno == errno.ENOTDIR:\n                raise ValueError(\"%s is not a directory\" % (self.path,))\n            else:\n                raise\n        with fobj:\n            self.contents = json.load(fobj)\n\n        self._set_defaults()\n        self._check_refpkg()", "response": "Read any changes made on disk to this Refpkg."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncopying a file into the reference package.", "response": "def _add_file(self, key, path):\n        \"\"\"Copy a file into the reference package.\"\"\"\n        filename = os.path.basename(path)\n        base, ext = os.path.splitext(filename)\n        if os.path.exists(self.file_path(filename)):\n            with tempfile.NamedTemporaryFile(\n                    dir=self.path, prefix=base, suffix=ext) as tf:\n                filename = os.path.basename(tf.name)\n        shutil.copyfile(path, self.file_path(filename))\n        self.contents['files'][key] = filename"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef is_invalid(self):\n        # Manifest file contains the proper keys\n        for k in ['metadata', 'files', 'md5']:\n            if not(k in self.contents):\n                return \"Manifest file missing key %s\" % k\n            if not(isinstance(self.contents[k], dict)):\n                return \"Key %s in manifest did not refer to a dictionary\" % k\n\n        if not('rollback' in self.contents):\n            return \"Manifest file missing key rollback\"\n        if not(isinstance(self.contents['rollback'], dict)) and self.contents[\n                \"rollback\"] is not None:\n            return (\"Key rollback in manifest did not refer to a \"\n                    \"dictionary or None, found %s\") % str(self.contents['rollback'])\n\n        if not('rollforward' in self.contents):\n            return \"Manifest file missing key rollforward\"\n\n        if self.contents['rollforward'] is not None:\n            if not(isinstance(self.contents['rollforward'], list)):\n                return \"Key rollforward was not a list, found %s\" % str(\n                    self.contents['rollforward'])\n            elif len(self.contents['rollforward']) != 2:\n                return \"Key rollforward had wrong length, found %d\" % \\\n                    len(self.contents['rollforward'])\n            elif not is_string(self.contents['rollforward'][0]):\n                print(type(self.contents['rollforward'][0]))\n                return \"Key rollforward's first entry was not a string, found %s\" % \\\n                    str(self.contents['rollforward'][0])\n            elif not(isinstance(self.contents['rollforward'][1], dict)):\n                return \"Key rollforward's second entry was not a dict, found %s\" % \\\n                    str(self.contents['rollforward'][1])\n\n        if not(\"log\" in self.contents):\n            return \"Manifest file missing key 'log'\"\n\n        if not(isinstance(self.contents['log'], list)):\n            return \"Key 'log' in manifest did not refer to a list\"\n\n        # MD5 keys and filenames are in one to one correspondence\n        if self.contents['files'].keys() != self.contents[\n                'md5'].keys():\n            return (\"Files and MD5 sums in manifest do not \"\n                    \"match (files: %s, MD5 sums: %s)\") % \\\n                (list(self.contents['files'].keys()),\n                 list(self.contents['md5'].keys()))\n\n        # All files in the manifest exist and match the MD5 sums\n        for key, filename in self.contents['files'].items():\n            # we don't need to explicitly check for existence;\n            # calculate_resource_md5 will open the file for us.\n            expected_md5 = self.resource_md5(key)\n            found_md5 = self.calculate_resource_md5(key)\n            if found_md5 != expected_md5:\n                return (\"File %s referred to by key %s did \"\n                        \"not match its MD5 sum (found: %s, expected %s)\") % \\\n                    (filename, key, found_md5, expected_md5)\n        return False", "response": "Checks if this RefPkg is invalid."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nupdating the metadata for the specified key. Returns the previous value of key.", "response": "def update_metadata(self, key, value):\n        \"\"\"Set *key* in the metadata to *value*.\n\n        Returns the previous value of *key*, or None if the key was\n        not previously set.\n        \"\"\"\n        old_value = self.contents['metadata'].get(key)\n        self.contents['metadata'][key] = value\n        self._log('Updated metadata: %s=%s' % (key, value))\n        return old_value"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nupdate the file with the given key.", "response": "def update_file(self, key, new_path):\n        \"\"\"Insert file *new_path* into the refpkg under *key*.\n\n        The filename of *new_path* will be preserved in the refpkg\n        unless it would conflict with a previously existing file, in\n        which case a suffix is appended which makes it unique.  The\n        previous file, if there was one, is left in the refpkg.  If\n        you wish to delete it, see the ``strip`` method.\n\n        The full path to the previous file referred to by *key* is\n        returned, or ``None`` if *key* was not previously defined in\n        the refpkg.\n        \"\"\"\n        if key in self.contents['files']:\n            old_path = self.resource_path(key)\n        else:\n            old_path = None\n        self._add_file(key, new_path)\n        with open(new_path, 'rb') as f:\n            md5_value = md5file(f)\n        self.contents['md5'][key] = md5_value\n        self._log('Updated file: %s=%s' % (key, new_path))\n        if key == 'tree_stats' and old_path:\n            warnings.warn('Updating tree_stats, but not phylo_model.',\n                          DerivedFileNotUpdatedWarning, stacklevel=2)\n        return old_path"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef reroot(self, rppr=None, pretend=False):\n        with scratch_file(prefix='tree', suffix='.tre') as name:\n            # Use a specific path to rppr, otherwise rely on $PATH\n            subprocess.check_call([rppr or 'rppr', 'reroot',\n                                   '-c', self.path, '-o', name])\n            if not(pretend):\n                self.update_file('tree', name)\n        self._log('Rerooting refpkg')", "response": "Reroot the phylogenetic tree."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nparse a stats log and use it to update the phylo model.", "response": "def update_phylo_model(self, stats_type, stats_file, frequency_type=None):\n        \"\"\"Parse a stats log and use it to update ``phylo_model``.\n\n        ``pplacer`` expects its input to include the deatils of the\n        phylogenetic model used for creating a tree in JSON format\n        under the key ``phylo_model``, but no program actually outputs\n        that format.\n\n        This function takes a log generated by RAxML or FastTree, parses it,\n        and inserts an appropriate JSON file into the refpkg. The first\n        parameter must be 'RAxML', 'PhyML' or 'FastTree', depending on which\n        program generated the log. It may also be None to attempt to guess\n        which program generated the log.\n\n        :param stats_type: Statistics file type. One of 'RAxML', 'FastTree', 'PhyML'\n        :param stats_file: path to statistics/log file\n        :param frequency_type: For ``stats_type == 'PhyML'``, amino acid\n         alignments only: was the alignment inferred with ``model`` or\n         ``empirical`` frequencies?\n\n        \"\"\"\n\n        if frequency_type not in (None, 'model', 'empirical'):\n            raise ValueError(\n                'Unknown frequency type: \"{0}\"'.format(frequency_type))\n        if frequency_type and stats_type not in (None, 'PhyML'):\n            raise ValueError('Frequency type should only be specified for '\n                             'PhyML alignments.')\n\n        if stats_type is None:\n            with open(stats_file) as fobj:\n                for line in fobj:\n                    if line.startswith('FastTree'):\n                        stats_type = 'FastTree'\n                        break\n                    elif (line.startswith('This is RAxML') or\n                          line.startswith('You are using RAxML')):\n                        stats_type = 'RAxML'\n                        break\n                    elif 'PhyML' in line:\n                        stats_type = 'PhyML'\n                        break\n                else:\n                    raise ValueError(\n                        \"couldn't guess log type for %r\" % (stats_file,))\n\n        if stats_type == 'RAxML':\n            parser = utils.parse_raxml\n        elif stats_type == 'FastTree':\n            parser = utils.parse_fasttree\n        elif stats_type == 'PhyML':\n            parser = functools.partial(utils.parse_phyml,\n                                       frequency_type=frequency_type)\n        else:\n            raise ValueError('invalid log type: %r' % (stats_type,))\n\n        with scratch_file(prefix='phylo_model', suffix='.json') as name:\n            with open(name, 'w') as phylo_model, open(stats_file) as h:\n                json.dump(parser(h), phylo_model, indent=4)\n            self.update_file('phylo_model', name)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef rollback(self):\n        # This is slightly complicated because of Python's freakish\n        # assignment semantics and because we don't store multiple\n        # copies of the log.\n        if self.contents['rollback'] is None:\n            raise ValueError(\"No operation to roll back on refpkg\")\n        future_msg = self.contents['log'][0]\n        rolledback_log = self.contents['log'][1:]\n        rollforward = copy.deepcopy(self.contents)\n        rollforward.pop('rollback')\n        self.contents = self.contents['rollback']\n        self.contents['log'] = rolledback_log\n        self.contents['rollforward'] = [future_msg, rollforward]\n        self._sync_to_disk()", "response": "Revert the previous modification to the refpkg."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nrestore a reverted modification to the refpkg.", "response": "def rollforward(self):\n        \"\"\"Restore a reverted modification to the refpkg.\n        \"\"\"\n        if self.contents['rollforward'] is None:\n            raise ValueError(\"No operation to roll forward on refpkg\")\n        new_log_message = self.contents['rollforward'][0]\n        new_contents = self.contents['rollforward'][1]\n        new_contents['log'] = [new_log_message] + self.contents.pop('log')\n        self.contents['rollforward'] = None\n        new_contents['rollback'] = copy.deepcopy(self.contents)\n        new_contents['rollback'].pop('rollforward')\n        self.contents = new_contents\n        self._sync_to_disk()"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nremoves rollbacks rollforwards and all non - current files.", "response": "def strip(self):\n        \"\"\"Remove rollbacks, rollforwards, and all non-current files.\n\n        When distributing a refpkg, you probably want to distribute as\n        small a one as possible.  strip removes everything from the\n        refpkg which is not relevant to its current state.\n        \"\"\"\n        self._sync_from_disk()\n        current_filenames = set(self.contents['files'].values())\n        all_filenames = set(os.listdir(self.path))\n        to_delete = all_filenames.difference(current_filenames)\n        to_delete.discard('CONTENTS.json')\n        for f in to_delete:\n            self._delete_file(f)\n        self.contents['rollback'] = None\n        self.contents['rollforward'] = None\n        self.contents['log'].insert(\n            0, 'Stripped refpkg (removed %d files)' % len(to_delete))\n        self._sync_to_disk()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nbegin a transaction to group operations on the refpkg.", "response": "def start_transaction(self):\n        \"\"\"Begin a transaction to group operations on the refpkg.\n\n        All the operations until the next call to\n        ``commit_transaction`` will be recorded as a single operation\n        for rollback and rollforward, and recorded with a single line\n        in the log.\n        \"\"\"\n        if self.current_transaction:\n            raise ValueError(\"There is already a transaction going\")\n        else:\n            initial_state = copy.deepcopy(self.contents)\n            self.current_transaction = {'rollback': initial_state,\n                                        'log': '(Transaction left no log message)'}"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncommit a transaction with a given log entry.", "response": "def commit_transaction(self, log=None):\n        \"\"\"Commit a transaction, with *log* as the log entry.\"\"\"\n        self.current_transaction['rollback'].pop('log')\n        self.current_transaction['rollback'].pop('rollforward')\n        self.contents['log'].insert(\n            0, log and log or self.current_transaction['log'])\n        self.contents['rollback'] = self.current_transaction['rollback']\n        self.contents['rollforward'] = None  # We can't roll forward anymore\n        self.current_transaction = None\n        self._sync_to_disk()"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nloads the taxonomy into a sqlite3 database.", "response": "def load_db(self):\n        \"\"\"Load the taxonomy into a sqlite3 database.\n\n        This will set ``self.db`` to a sqlite3 database which contains all of\n        the taxonomic information in the reference package.\n        \"\"\"\n\n        db = taxdb.Taxdb()\n        db.create_tables()\n        reader = csv.DictReader(self.open_resource('taxonomy', 'rU'))\n        db.insert_from_taxtable(lambda: reader._fieldnames, reader)\n\n        curs = db.cursor()\n        reader = csv.DictReader(self.open_resource('seq_info', 'rU'))\n        curs.executemany(\"INSERT INTO sequences VALUES (?, ?)\",\n                         ((row['seqname'], row['tax_id']) for row in reader))\n\n        db.commit()\n        self.db = db"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nfinds the most recent common ancestor of the specified tax_ids.", "response": "def most_recent_common_ancestor(self, *ts):\n        \"\"\"Find the MRCA of some tax_ids.\n\n        Returns the MRCA of the specified tax_ids, or raises ``NoAncestor`` if\n        no ancestor of the specified tax_ids could be found.\n        \"\"\"\n        if len(ts) > 200:\n            res = self._large_mrca(ts)\n        else:\n            res = self._small_mrca(ts)\n\n        if res:\n            (res,), = res\n        else:\n            raise NoAncestor()\n        return res"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _large_mrca(self, ts):\n        cursor = self.db.cursor()\n\n        cursor.execute(\"\"\"\n            DROP TABLE IF EXISTS _mrca_temp\n        \"\"\")\n\n        cursor.execute(\"\"\"\n            CREATE TEMPORARY TABLE _mrca_temp(\n                child TEXT PRIMARY KEY REFERENCES taxa (tax_id) NOT NULL\n            )\n        \"\"\")\n\n        cursor.executemany(\"\"\"\n            INSERT INTO _mrca_temp\n            VALUES (?)\n        \"\"\", ((tid,) for tid in ts))\n        cursor.execute(\"\"\"\n            SELECT parent\n            FROM   _mrca_temp\n                   JOIN parents USING (child)\n                   JOIN taxa\n                     ON parent = taxa.tax_id\n                   JOIN ranks USING (rank)\n            GROUP  BY parent\n            HAVING COUNT(*) = ?\n            ORDER  BY rank_order DESC\n            LIMIT  1\n        \"\"\", (len(ts),))\n\n        return cursor.fetchall()", "response": "Find the MRCA using a temporary table."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _small_mrca(self, ts):\n        cursor = self.db.cursor()\n        qmarks = ', '.join('?' * len(ts))\n        cursor.execute(\"\"\"\n            SELECT parent\n            FROM   parents\n                   JOIN taxa\n                     ON parent = taxa.tax_id\n                   JOIN ranks USING (rank)\n            WHERE  child IN (%s)\n            GROUP  BY parent\n            HAVING COUNT(*) = ?\n            ORDER  BY rank_order DESC\n            LIMIT  1\n        \"\"\" % qmarks, ts + (len(ts),))\n\n        return cursor.fetchall()", "response": "Find a small MRCA using query parameters."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef file_abspath(self, resource):\n        warnings.warn(\n            \"file_abspath is deprecated; use resource_path instead\",\n            DeprecationWarning, stacklevel=2)\n        return self.resource_path(resource)", "response": "Deprecated alias for resource_path *."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef file_name(self, resource):\n        warnings.warn(\n            \"file_name is deprecated; use resource_name instead\",\n            DeprecationWarning, stacklevel=2)\n        return self.resource_name(resource)", "response": "Deprecated alias for resource_name."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ndeprecate alias for resource_md5. Use resource_md5 instead.", "response": "def file_md5(self, resource):\n        \"\"\"Deprecated alias for *resource_md5*.\"\"\"\n        warnings.warn(\n            \"file_md5 is deprecated; use resource_md5 instead\",\n            DeprecationWarning, stacklevel=2)\n        return self.resource_md5(resource)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the settings module of the application according to the command line argument or the SHELTER_SETTINGS_MODULE environment variable.", "response": "def get_app_settings(parser, known_args):\n    \"\"\"\n    Return **settings** module of the application according to\n    either command line argument or **SHELTER_SETTINGS_MODULE**\n    environment variable.\n    \"\"\"\n    args, dummy_remaining = parser.parse_known_args(known_args)\n    settings_module_path = (\n        args.settings or os.environ.get('SHELTER_SETTINGS_MODULE', ''))\n    if not settings_module_path:\n        return None\n    return importlib.import_module(settings_module_path)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a dictionary of all management commands registered in the settings.", "response": "def get_management_commands(settings):\n    \"\"\"\n    Find registered managemend commands and return their classes\n    as a :class:`dict`. Keys are names of the management command\n    and values are classes of the management command.\n    \"\"\"\n    app_commands = getattr(settings, 'MANAGEMENT_COMMANDS', ())\n    commands = {}\n    for name in itertools.chain(SHELTER_MANAGEMENT_COMMANDS, app_commands):\n        command_obj = import_object(name)\n        if not issubclass(command_obj, BaseCommand):\n            raise ValueError(\"'%s' is not subclass of the BaseCommand\" % name)\n        commands[command_obj.name] = command_obj\n    return commands"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning either config class or default.", "response": "def get_config_class(settings):\n    \"\"\"\n    According to **settings.CONFIG_CLASS** return either config class\n    defined by user or default :class:`shelter.core.config.Config`.\n    \"\"\"\n    config_cls_name = getattr(settings, 'CONFIG_CLASS', '')\n    if config_cls_name:\n        config_cls = import_object(config_cls_name)\n    else:\n        config_cls = Config\n    return config_cls"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef main(args=None):\n    # Base command line parser. Help is not allowed because command\n    # line is parsed in two stages - in the first stage is found setting\n    # module of the application, in the second stage are found management\n    # command's arguments.\n    parser = ArgumentParser(add_help=False)\n    parser.add_argument(\n        '-s', '--settings',\n        dest='settings', action='store', type=str, default=None,\n        help=_('application settings module')\n    )\n\n    # Get settings module\n    try:\n        settings = get_app_settings(parser, args)\n    except ImportError as exc:\n        parser.error(_(\"Invalid application settings module: {}\").format(exc))\n\n    # Get management commands and add their arguments into command\n    # line parser\n    commands = get_management_commands(settings)\n    subparsers = parser.add_subparsers(\n        dest='action', help=_('specify action')\n    )\n    for command_cls in six.itervalues(commands):\n        subparser = subparsers.add_parser(\n            command_cls.name, help=command_cls.help)\n        for command_args, kwargs in command_cls.arguments:\n            subparser.add_argument(*command_args, **kwargs)\n\n    # Get config class and add its arguments into command line parser\n    if settings:\n        config_cls = get_config_class(settings)\n        if not issubclass(config_cls, Config):\n            raise TypeError(\n                \"Config class must be subclass of the \"\n                \"shelter.core.config.Config\")\n        for config_args, kwargs in config_cls.arguments:\n            parser.add_argument(*config_args, **kwargs)\n    else:\n        config_cls = Config\n\n    # Add help argument and parse command line\n    parser.add_argument(\n        '-h', '--help', action='help',\n        help=_('show this help message and exit')\n    )\n    cmdline_args = parser.parse_args(args)\n    if not cmdline_args.action:\n        parser.error(_('No action'))\n\n    # Run management command\n    command_cls = commands[cmdline_args.action]\n    if command_cls.settings_required and not settings:\n        parser.error(_(\n            \"Settings module is not defined. You must either set \"\n            \"'SHELTER_SETTINGS_MODULE' environment variable or \"\n            \"'-s/--settings' command line argument.\"\n        ))\n    try:\n        config = config_cls(settings, cmdline_args)\n    except ImproperlyConfiguredError as exc:\n        parser.error(str(exc))\n    command = command_cls(config)\n    try:\n        command()\n    except Exception:\n        traceback.print_exc(file=sys.stderr)\n        sys.stderr.flush()\n        if multiprocessing.active_children():\n            # If main process has children processes, exit immediately without\n            # cleaning. It is a workaround, because parent process waits for\n            # non-daemon children.\n            os._exit(1)\n        sys.exit(1)\n    sys.exit(0)", "response": "Main function for the management command line."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef as_length(self, value):\n        new_vec = self.copy()\n        new_vec.length = value\n        return new_vec", "response": "Return a new vector scaled to given length"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef as_percent(self, value):\n        new_vec = self.copy()\n        new_vec.length = value * self.length\n        return new_vec", "response": "Return a new vector scaled by given decimal percent"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ndotting product with another vector", "response": "def dot(self, vec):\n        \"\"\"Dot product with another vector\"\"\"\n        if not isinstance(vec, self.__class__):\n            raise TypeError('Dot product operand must be a vector')\n        return np.dot(self, vec)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef cross(self, vec):\n        if not isinstance(vec, self.__class__):\n            raise TypeError('Cross product operand must be a vector')\n        return self.__class__(np.cross(self, vec))", "response": "Cross product with another vector"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef angle(self, vec, unit='rad'):\n        if not isinstance(vec, self.__class__):\n            raise TypeError('Angle operand must be of class {}'\n                            .format(self.__class__.__name__))\n        if unit not in ['deg', 'rad']:\n            raise ValueError('Only units of rad or deg are supported')\n\n        denom = self.length * vec.length\n        if denom == 0:\n            raise ZeroDivisionError('Cannot calculate angle between '\n                                    'zero-length vector(s)')\n\n        ang = np.arccos(self.dot(vec) / denom)\n        if unit == 'deg':\n            ang = ang * 180 / np.pi\n        return ang", "response": "Calculate the angle between two Vectors\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the polar angle of this vector in radians", "response": "def phi(self):\n        \"\"\"Polar angle / inclination of this vector in radians\n\n        Based on sperical coordinate space\n        returns angle between this vector and the positive z-azis\n        range: (0 <= phi <= pi)\n        \"\"\"\n        return np.arctan2(np.sqrt(self.x**2 + self.y**2), self.z)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef cross(self, vec):\n        if not isinstance(vec, self.__class__):\n            raise TypeError('Cross product operand must be a vector')\n        return Vector3(0, 0, np.asscalar(np.cross(self, vec)))", "response": "Cross product with another vector"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef length(self):\n        return np.sqrt(np.sum(self**2, axis=1)).view(np.ndarray)", "response": "Array of vector lengths"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ndots product with another vector.", "response": "def dot(self, vec):\n        \"\"\"Dot product with another vector\"\"\"\n        if not isinstance(vec, self.__class__):\n            raise TypeError('Dot product operand must be a VectorArray')\n        if self.nV != 1 and vec.nV != 1 and self.nV != vec.nV:\n            raise ValueError('Dot product operands must have the same '\n                             'number of elements.')\n        return np.sum((getattr(self, d)*getattr(vec, d) for d in self.dims), 1)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncross product with another Vector3Array.", "response": "def cross(self, vec):\n        \"\"\"Cross product with another Vector3Array\"\"\"\n        if not isinstance(vec, Vector3Array):\n            raise TypeError('Cross product operand must be a Vector3Array')\n        if self.nV != 1 and vec.nV != 1 and self.nV != vec.nV:\n            raise ValueError('Cross product operands must have the same '\n                             'number of elements.')\n        return Vector3Array(np.cross(self, vec))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef eval_rs(gains, losses):\n        # Number of days that the data was collected through\n        count = len(gains) + len(losses)\n\n        avg_gains = stats.avg(gains, count=count) if gains else 1\n        avg_losses = stats.avg(losses,count=count) if losses else 1\n        if avg_losses == 0:\n            return avg_gains\n        else:\n            return avg_gains / avg_losses", "response": "Evaluates the RS variable in the RSI algorithm\n           "}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef eval_from_json(json):\n        changes = poloniex.get_gains_losses(poloniex.parse_changes(json))\n        return RSI.eval_algorithm(changes['gains'], changes['losses'])", "response": "Evaluates RSI from JSON"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nhandles SIGUSR1 signal. Call function which is defined in the CONFIG_SYS_SIGUSR1_HANDLER.", "response": "def sigusr1_handler(self, unused_signum, unused_frame):\n        \"\"\"\n        Handle SIGUSR1 signal. Call function which is defined in the\n        **settings.SIGUSR1_HANDLER**.\n        \"\"\"\n        if self._sigusr1_handler_func is not None:\n            self._sigusr1_handler_func(self.context)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef sigusr2_handler(self, unused_signum, unused_frame):\n        if self._sigusr1_handler_func is not None:\n            self._sigusr2_handler_func(self.context)", "response": "Handle SIGUSR2 signal. Call function which is defined in the CONFIG_SYS_SIGUSR2_HANDLER."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nshowing information about reference packages.", "response": "def action(args):\n    \"\"\"\n    Show information about reference packages.\n    \"\"\"\n    log.info('loading reference package')\n\n    pkg = refpkg.Refpkg(args.refpkg, create=False)\n\n    with open(pkg.file_abspath('seq_info'), 'rU') as seq_info:\n        seqinfo = list(csv.DictReader(seq_info))\n        snames = [row['seqname'] for row in seqinfo]\n\n    if args.seq_names:\n        print('\\n'.join(snames))\n    elif args.tally:\n        tally_taxa(pkg)\n    elif args.lengths:\n        print_lengths(pkg)\n    else:\n        print('number of sequences:', len(snames))\n        print('package components\\n', '\\n'.join(sorted(pkg.file_keys())))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nconverting a JSON to a URL by the Poloniex API representing the given JSON.", "response": "def json_to_url(json, symbol):\n    \"\"\" Converts a JSON to a URL by the Poloniex API \n\n    Args:\n        json: JSON data as a list of dict dates, where the keys are\n            the raw market statistics.\n        symbol: String of currency pair, like a ticker symbol.\n\n    Returns:\n        String URL to Poloniex API representing the given JSON.\n    \"\"\"\n    start = json[0]['date']\n    end = json[-1]['date']\n    diff = end - start\n\n    # Get period by a ratio from calculated period to valid periods\n    # Ratio closest to 1 is the period\n    # Valid values: 300, 900, 1800, 7200, 14400, 86400\n    periods = [300, 900, 1800, 7200, 14400, 86400]\n\n    diffs = {}\n    for p in periods:\n        diffs[p] = abs(1 - (p / (diff / len(json)))) # Get ratio\n\n    period = min(diffs, key=diffs.get) # Find closest period\n    \n    url = ('https://poloniex.com/public?command'\n           '=returnChartData&currencyPair={0}&start={1}'\n           '&end={2}&period={3}').format(symbol, start, end, period) \n    return url"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nrequest and returns the JSON data from Poloniex API for a given market pair.", "response": "def chart_json(start, end, period, symbol):\n    \"\"\" Requests chart data from Poloniex API\n    \n    Args:\n        start: Int epoch date to START getting market stats from.\n            Note that this epoch is FURTHER from the current date.\n        end: Int epoch date to STOP getting market stats from.\n            Note that this epoch is CLOSER to the current date.\n        period: Int defining width of each chart candlestick in seconds.\n            Valid values: 300, 900, 1800, 7200, 14400, 86400\n        symbol: String of currency pair, like a ticker symbol.\n\n    Returns:\n        Tuple of (JSON data, URL to JSON).\n        JSON data as a list of dict dates, where the keys are\n        the raw market statistics.\n        String URL to Poloniex API representing the given JSON.\n    \"\"\"\n    url = ('https://poloniex.com/public?command'\n           '=returnChartData&currencyPair={0}&start={1}'\n           '&end={2}&period={3}').format(symbol, start, end, period) \n    logger.debug(' HTTP Request URL:\\n{0}'.format(url))\n    json = requests.get(url).json()\n    logger.debug(' JSON:\\n{0}'.format(json))\n\n    if 'error' in json:\n        logger.error(' Invalid parameters in URL for HTTP response')\n        raise SystemExit\n    elif all(val == 0 for val in json[0]):\n        logger.error(' Bad HTTP response.  Time unit too short?')\n        raise SystemExit\n    elif len(json) < 1: # time to short\n        logger.error(' Not enough dates to calculate changes')\n        raise SystemExit\n\n    return json, url"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef parse_changes(json):\n    changes = []\n    dates = len(json)\n    for date in range(1, dates): \n        last_close = json[date - 1]['close']\n        now_close = json[date]['close']\n        changes.append(now_close - last_close)\n    logger.debug('Market Changes (from JSON):\\n{0}'.format(changes))\n    return changes", "response": "Parses the JSON data into a list of floats of price changes between entries in the JSON."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncategorizing changes into gains and losses.", "response": "def get_gains_losses(changes):\n    \"\"\" Categorizes changes into gains and losses\n\n    Args:\n        changes: List of floats of price changes between entries in JSON.\n\n    Returns:\n        Dict of changes with keys 'gains' and 'losses'.\n        All values are positive.\n    \"\"\"\n    res = {'gains': [], 'losses': []}\n    for change in changes:\n        if change > 0:\n            res['gains'].append(change)\n        else:\n            res['losses'].append(change * -1)\n    logger.debug('Gains: {0}'.format(res['gains']))\n    logger.debug('Losses: {0}'.format(res['losses']))\n    return res"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget the values of an attribute from JSON data", "response": "def get_attribute(json, attr):\n    \"\"\" Gets the values of an attribute from JSON\n\n    Args:\n        json: JSON data as a list of dict dates, where the keys are\n            the raw market statistics.\n        attr: String of attribute in JSON file to collect.\n\n    Returns:\n        List of values of specified attribute from JSON\n    \"\"\"\n    res = [json[entry][attr] for entry, _ in enumerate(json)]\n    logger.debug('{0}s (from JSON):\\n{1}'.format(attr, res))\n    return res"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget JSON from shifted date by Poloniex API.", "response": "def get_json_shift(year, month, day, unit, count, period, symbol):\n    \"\"\" Gets JSON from shifted date by the Poloniex API\n\n    Args:\n        year: Int between 1 and 9999.\n        month: Int between 1 and 12.\n        day: Int between 1 and 31.\n        unit: String of time period unit for count argument.\n            How far back to check historical market data.\n            Valid values: 'hour', 'day', 'week', 'month', 'year'\n        count: Int of units.\n            How far back to check historical market data.\n        period: Int defining width of each chart candlestick in seconds.\n        symbol: String of currency pair, like a ticker symbol.\n\n    Returns: JSON, list of dates where each entry is a dict of raw market data.\n    \"\"\"\n    epochs = date.get_end_start_epochs(year, month, day, 'last', unit, count)\n    return chart_json(epochs['shifted'], epochs['initial'],\n                      period, symbol)[0]"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef filter_ranks(results):\n    for _, group in itertools.groupby(results, operator.itemgetter(0)):\n        yield next(group)", "response": "Yields all the ranks for all the results for a given tax_id."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef eval_algorithm(closing, low, high):\n        if high - low == 0: # High and low are the same, zero division error\n            return 100 * (closing - low)\n        else:\n            return 100 * (closing - low) / (high - low)", "response": "Evaluates the SO algorithm for the current closing price."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef eval_from_json(json):\n        close  = json[-1]['close'] # Latest closing price\n        low    = min(poloniex.get_attribute(json, 'low')) # Lowest low\n        high   = max(poloniex.get_attribute(json, 'high')) # Highest high\n        return SO.eval_algorithm(close, low, high)", "response": "Evaluates the SO from a JSON dict."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the average value of a list of numbers.", "response": "def avg(vals, count=None):\n    \"\"\" Returns the average value\n\n    Args:\n        vals: List of numbers to calculate average from.\n        count: Int of total count that vals was part of.\n\n    Returns:\n        Float average value throughout a count.\n    \"\"\" \n    sum = 0\n    for v in vals:\n        sum += v\n    if count is None:\n        count = len(vals)\n    return float(sum) / count"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates a connection object to a database.", "response": "def db_connect(engine, schema=None, clobber=False):\n    \"\"\"Create a connection object to a database. Attempt to establish a\n    schema. If there are existing tables, delete them if clobber is\n    True and return otherwise. Returns a sqlalchemy engine object.\n\n    \"\"\"\n\n    if schema is None:\n        base = declarative_base()\n    else:\n        try:\n            engine.execute(sqlalchemy.schema.CreateSchema(schema))\n        except sqlalchemy.exc.ProgrammingError as err:\n            logging.warn(err)\n        base = declarative_base(metadata=MetaData(schema=schema))\n\n    define_schema(base)\n\n    if clobber:\n        logging.info('Clobbering database tables')\n        base.metadata.drop_all(bind=engine)\n\n    logging.info('Creating database tables')\n    base.metadata.create_all(bind=engine)\n\n    return base"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef read_nodes(rows, source_id=1):\n\n    ncbi_keys = ['tax_id', 'parent_id', 'rank', 'embl_code', 'division_id']\n    extra_keys = ['source_id', 'is_valid']\n    is_valid = True\n\n    ncbi_cols = len(ncbi_keys)\n\n    rank = ncbi_keys.index('rank')\n    parent_id = ncbi_keys.index('parent_id')\n\n    # assumes the first row is the root\n    row = next(rows)\n    row[rank] = 'root'\n    # parent must be None for termination of recursive CTE for\n    # calculating lineages\n    row[parent_id] = None\n    rows = itertools.chain([row], rows)\n\n    yield ncbi_keys + extra_keys\n\n    for row in rows:\n        # replace whitespace in \"rank\" with underscore\n        row[rank] = '_'.join(row[rank].split())\n        # provide default values for source_id and is_valid\n        yield row[:ncbi_cols] + [source_id, is_valid]", "response": "Yields a generator of rows ready to insert into table nodes."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef read_names(rows, source_id=1):\n\n    ncbi_keys = ['tax_id', 'tax_name', 'unique_name', 'name_class']\n    extra_keys = ['source_id', 'is_primary', 'is_classified']\n\n    # is_classified applies to species only; we will set this value\n    # later\n    is_classified = None\n\n    tax_id = ncbi_keys.index('tax_id')\n    tax_name = ncbi_keys.index('tax_name')\n    unique_name = ncbi_keys.index('unique_name')\n    name_class = ncbi_keys.index('name_class')\n\n    yield ncbi_keys + extra_keys\n\n    for tid, grp in itertools.groupby(rows, itemgetter(tax_id)):\n        # confirm that each tax_id has exactly one scientific name\n        num_primary = 0\n        for r in grp:\n            is_primary = r[name_class] == 'scientific name'\n            # fix primary key uniqueness violation\n            if r[unique_name]:\n                r[tax_name] = r[unique_name]\n            num_primary += is_primary\n            yield (r + [source_id, is_primary, is_classified])\n\n        assert num_primary == 1", "response": "Return an iterator of rows ready to insert into table\n    names."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef fetch_data(dest_dir='.', clobber=False, url=DATA_URL):\n\n    dest_dir = os.path.abspath(dest_dir)\n    try:\n        os.mkdir(dest_dir)\n    except OSError:\n        pass\n\n    fout = os.path.join(dest_dir, os.path.split(url)[-1])\n\n    if os.access(fout, os.F_OK) and not clobber:\n        downloaded = False\n        logging.info(fout + ' exists; not downloading')\n    else:\n        downloaded = True\n        logging.info('downloading {} to {}'.format(url, fout))\n        request.urlretrieve(url, fout)\n\n    return (fout, downloaded)", "response": "Download data from NCBI required to generate local taxonomy\n    database."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn an iterator of unique rows from a zip file.", "response": "def read_archive(archive, fname):\n    \"\"\"Return an iterator of unique rows from a zip archive.\n\n    * archive - path to the zip archive.\n    * fname - name of the compressed file within the archive.\n\n    \"\"\"\n\n    # Note that deduplication here is equivalent to an upsert/ignore,\n    # but avoids requirement for a database-specific implementation.\n\n    zfile = zipfile.ZipFile(archive)\n    contents = zfile.open(fname, 'r')\n    fobj = io.TextIOWrapper(contents)\n\n    seen = set()\n    for line in fobj:\n        line = line.rstrip('\\t|\\n')\n        if line not in seen:\n            yield line.split('\\t|\\t')\n            seen.add(line)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef prepend_schema(self, name):\n        return '.'.join([self.schema, name]) if self.schema else name", "response": "Prepend schema name to name when a schema is specified\n       "}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nload rows into table table.", "response": "def load_table(self, table, rows, colnames=None, limit=None):\n        \"\"\"Load 'rows' into table 'table'. If 'colnames' is not provided, the\n        first element of 'rows' must provide column names.\n\n        \"\"\"\n\n        conn = self.engine.raw_connection()\n        cur = conn.cursor()\n\n        colnames = colnames or next(rows)\n\n        cmd = 'INSERT INTO {table} ({colnames}) VALUES ({placeholders})'.format(\n            table=self.tables[table],\n            colnames=', '.join(colnames),\n            placeholders=', '.join([self.placeholder] * len(colnames)))\n\n        cur.executemany(cmd, itertools.islice(rows, limit))\n        conn.commit()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nloading data from the zip archive of the NCBI taxonomy.", "response": "def load_archive(self, archive):\n        \"\"\"Load data from the zip archive of the NCBI taxonomy.\n\n        \"\"\"\n\n        # source\n        self.load_table(\n            'source',\n            rows=[('ncbi', DATA_URL)],\n            colnames=['name', 'description'],\n        )\n\n        conn = self.engine.raw_connection()\n        cur = conn.cursor()\n        cmd = \"select id from {source} where name = 'ncbi'\".format(**self.tables)\n        cur.execute(cmd)\n        source_id = cur.fetchone()[0]\n\n        # ranks\n        log.info('loading ranks')\n        self.load_table(\n            'ranks',\n            rows=((rank, i) for i, rank in enumerate(RANKS)),\n            colnames=['rank', 'height'],\n        )\n\n        # nodes\n        logging.info('loading nodes')\n        nodes_rows = read_nodes(\n            read_archive(archive, 'nodes.dmp'), source_id=source_id)\n        self.load_table('nodes', rows=nodes_rows)\n\n        # names\n        logging.info('loading names')\n        names_rows = read_names(\n            read_archive(archive, 'names.dmp'), source_id=source_id)\n        self.load_table('names', rows=names_rows)\n\n        # merged\n        logging.info('loading merged')\n        merged_rows = read_merged(read_archive(archive, 'merged.dmp'))\n        self.load_table('merged', rows=merged_rows)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef date_to_delorean(year, month, day):\n    return Delorean(datetime=dt(year, month, day), timezone='UTC')", "response": "Converts a date object to a Delorean instance in UTC"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef date_to_epoch(year, month, day):\n    return int(date_to_delorean(year, month, day).epoch)", "response": "Converts a date to epoch in UTC"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef shift_epoch(delorean, direction, unit, count):\n    return int(delorean._shift_date(direction, unit, count).epoch)", "response": "Gets the resulting epoch after a time shift of a Delorean object."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef generate_epochs(delorean, direction, unit, count):\n    for shift in range(count):\n        yield int(delorean._shift_date(direction, unit, shift).epoch)", "response": "Generates count epochs in UTC from a shifted Delorean instance."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_end_start_epochs(year, month, day, direction, unit, count):\n    if year or month or day: # Date is specified\n        if not year:\n            year = 2017\n        if not month:\n            month = 1\n        if not day:\n            day = 1\n        initial_delorean = date_to_delorean(year, month, day)\n    else: # Date is not specified, get current date\n        count += 1 # Get another date because market is still open\n        initial_delorean = now_delorean()\n    \n    initial_epoch = int(initial_delorean.epoch)\n    shifted_epoch = shift_epoch(initial_delorean, direction, unit, count)\n    return { 'initial': initial_epoch, 'shifted': shifted_epoch }", "response": "Gets epoch from a start date and epoch from a shifted date"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef add_child(self, child):\n        assert child != self\n        child.parent = self\n        child.ranks = self.ranks\n        child.index = self.index\n        assert child.tax_id not in self.index\n        self.index[child.tax_id] = child\n        self.children.add(child)", "response": "Add a child to this node."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nremove a child from this node.", "response": "def remove_child(self, child):\n        \"\"\"\n        Remove a child from this node.\n        \"\"\"\n        assert child in self.children\n        self.children.remove(child)\n        self.index.pop(child.tax_id)\n        if child.parent is self:\n            child.parent = None\n        if child.index is self.index:\n            child.index = None\n\n        # Remove child subtree from index\n        for n in child:\n            if n is child:\n                continue\n            self.index.pop(n.tax_id)\n            if n.index is self.index:\n                n.index = None"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ndrops this node from the taxonomy.", "response": "def drop(self):\n        \"\"\"\n        Remove this node from the taxonomy, maintaining child subtrees by\n        adding them to the node's parent, and moving sequences at this node\n        to the parent.\n\n        Not valid for root node.\n        \"\"\"\n        if self.is_root:\n            raise ValueError(\"Cannot drop root node!\")\n\n        parent = self.parent\n        for child in self.children:\n            child.parent = parent\n            parent.children.add(child)\n        self.children = set()\n\n        parent.sequence_ids.update(self.sequence_ids)\n        self.sequence_ids = set()\n\n        parent.remove_child(self)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef prune_unrepresented(self):\n        for node in self.depth_first_iter(self_first=False):\n            if (not node.children and\n                    not node.sequence_ids and\n                    node is not self):\n                node.parent.remove_child(node)", "response": "Remove nodes with sequences or children below this node."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef at_rank(self, rank):\n        s = self\n        while s:\n            if s.rank == rank:\n                return s\n            s = s.parent\n        raise ValueError(\"No node at rank {0} for {1}\".format(\n            rank, self.tax_id))", "response": "Find the node above this node at the given rank."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\niterating over nodes below this node optionally yielding children before this node.", "response": "def depth_first_iter(self, self_first=True):\n        \"\"\"\n        Iterate over nodes below this node, optionally yielding children before\n        self.\n        \"\"\"\n        if self_first:\n            yield self\n        for child in list(self.children):\n            for i in child.depth_first_iter(self_first):\n                yield i\n        if not self_first:\n            yield self"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets the node at the end of the path described by tax_ids.", "response": "def path(self, tax_ids):\n        \"\"\"Get the node at the end of the path described by tax_ids.\"\"\"\n        assert tax_ids[0] == self.tax_id\n        if len(tax_ids) == 1:\n            return self\n\n        n = tax_ids[1]\n        try:\n            child = next(i for i in self.children if i.tax_id == n)\n        except StopIteration:\n            raise ValueError(n)\n\n        return child.path(tax_ids[1:])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning all nodes between this node and the root including this one.", "response": "def lineage(self):\n        \"\"\"\n        Return all nodes between this node and the root, including this one.\n        \"\"\"\n        if not self.parent:\n            return [self]\n        else:\n            L = self.parent.lineage()\n            L.append(self)\n            return L"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nwrite a taxtable for this node and all descendants including the lineage leading to this node.", "response": "def write_taxtable(self, out_fp, **kwargs):\n        \"\"\"\n        Write a taxtable for this node and all descendants,\n        including the lineage leading to this node.\n        \"\"\"\n        ranks_represented = frozenset(i.rank for i in self) | \\\n            frozenset(i.rank for i in self.lineage())\n        ranks = [i for i in self.ranks if i in ranks_represented]\n        assert len(ranks_represented) == len(ranks)\n\n        def node_record(node):\n            parent_id = node.parent.tax_id if node.parent else node.tax_id\n            d = {'tax_id': node.tax_id,\n                 'tax_name': node.name,\n                 'parent_id': parent_id,\n                 'rank': node.rank}\n            L = {i.rank: i.tax_id for i in node.lineage()}\n            d.update(L)\n            return d\n\n        header = ['tax_id', 'parent_id', 'rank', 'tax_name'] + ranks\n        w = csv.DictWriter(out_fp, header, quoting=csv.QUOTE_NONNUMERIC,\n                           lineterminator='\\n')\n        w.writeheader()\n        # All nodes leading to this one\n        for i in self.lineage()[:-1]:\n            w.writerow(node_record(i))\n        w.writerows(node_record(i) for i in self)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\npopulate sequence_ids below this node from a seqinfo file object.", "response": "def populate_from_seqinfo(self, seqinfo):\n        \"\"\"Populate sequence_ids below this node from a seqinfo file object.\"\"\"\n        for row in csv.DictReader(seqinfo):\n            node = self.index.get(row['tax_id'])\n            if node:\n                node.sequence_ids.add(row['seqname'])"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef collapse(self, remove=False):\n        descendants = iter(self)\n        # Skip this node\n        assert next(descendants) is self\n        for descendant in descendants:\n            self.sequence_ids.update(descendant.sequence_ids)\n            descendant.sequence_ids.clear()\n\n        if remove:\n            for node in self.children:\n                self.remove_child(node)", "response": "Collapse all sequence_ids in the subtree below this node to this node."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef write_seqinfo(self, out_fp, include_name=True):\n        header = ['seqname', 'tax_id']\n\n        if include_name:\n            header.append('tax_name')\n\n        w = csv.DictWriter(out_fp, header, quoting=csv.QUOTE_NONNUMERIC,\n                           lineterminator='\\n', extrasaction='ignore')\n        w.writeheader()\n\n        rows = ({'seqname': seq_id,\n                 'tax_id': node.tax_id,\n                 'tax_name': node.name}\n                for node in self\n                for seq_id in node.sequence_ids)\n\n        w.writerows(rows)", "response": "Write a simple seq_info file suitable for use in taxtastic."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef from_taxtable(cls, taxtable_fp):\n        r = csv.reader(taxtable_fp)\n        headers = next(r)\n        rows = (collections.OrderedDict(list(zip(headers, i))) for i in r)\n\n        row = next(rows)\n        root = cls(rank=row['rank'], tax_id=row[\n                   'tax_id'], name=row['tax_name'])\n        path_root = headers.index('root')\n        root.ranks = headers[path_root:]\n        for row in rows:\n            rank, tax_id, name = [\n                row[i] for i in ('rank', 'tax_id', 'tax_name')]\n            path = [_f for _f in list(row.values())[path_root:] if _f]\n            parent = root.path(path[:-1])\n            parent.add_child(cls(rank, tax_id, name=name))\n\n        return root", "response": "Generate a node from an open handle to a taxtable"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef from_taxdb(cls, con, root=None):\n        cursor = con.cursor()\n        if root is None:\n            cursor.execute(\n                \"SELECT tax_id, rank FROM nodes WHERE tax_id = parent_id\")\n        else:\n            cursor.execute(\n                \"SELECT tax_id, rank FROM nodes WHERE tax_id = ?\", [root])\n\n        tax_id, rank = cursor.fetchone()\n        root = cls(rank=rank, tax_id=tax_id)\n\n        def add_lineage(parent):\n            cursor.execute(\"\"\"SELECT tax_id, rank, tax_name\n                    FROM nodes INNER JOIN names USING (tax_id)\n                    WHERE parent_id = :1 and tax_id <> :1\n                        AND names.is_primary = 1\n                    \"\"\", [parent.tax_id])\n            for tax_id, rank, name in cursor:\n                node = cls(rank=rank, tax_id=tax_id, name=name)\n                parent.add_child(node)\n            for child in parent.children:\n                add_lineage(child)\n\n        add_lineage(root)\n        return root", "response": "Generate a TaxNode from a taxonomy database."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nparse a host string and return a tuple containing the address and port.", "response": "def parse_host(host):\n    \"\"\"\n    Parse *host* in format ``\"[hostname:]port\"`` and return :class:`tuple`\n    ``(address, port)``.\n\n        >>> parse_host('localhost:4444')\n        ('localhost', 4444)\n        >>> parse_host(':4444')\n        ('', 4444)\n        >>> parse_host('4444')\n        ('', 4444)\n        >>> parse_host('2001:db8::1428:57ab:4444')\n        ('2001:db8::1428:57ab', 4444)\n        >>> parse_host('localhost')\n        ValueError: Invalid port number 'localhost'\n    \"\"\"\n    parts = host.split(':')\n    address = ':'.join(parts[:-1])\n    try:\n        port = int(parts[-1])\n    except ValueError:\n        port = None\n    if not port or port < 1 or port > 65535:\n        raise ValueError(\"Invalid port number '%s'\" % port)\n    return address, port"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_children(engine, parent_ids, rank='species', schema=None):\n\n    if not parent_ids:\n        return []\n\n    nodes = schema + '.nodes' if schema else 'nodes'\n    names = schema + '.names' if schema else 'names'\n\n    cmd = ('select tax_id, tax_name, rank '\n           'from {} join {} using (tax_id) '\n           'where parent_id = :tax_id and is_primary').format(nodes, names)\n\n    species = []\n    for parent_id in parent_ids:\n        result = engine.execute(sqlalchemy.sql.text(cmd), tax_id=parent_id)\n        keys = list(result.keys())\n        rows = [dict(list(zip(keys, row))) for row in result.fetchall()]\n        for r in rows:\n            if r['rank'] == rank and 'sp.' not in r['tax_name']:\n                species.append(r)\n        others = [r for r in rows if r['rank'] not in (rank, 'no_rank')]\n        if others:\n            _, s = get_children(engine, [r['tax_id'] for r in others])\n            species.extend(s)\n\n    return keys, species", "response": "Recursively fetch children of tax_ids in parent_ids until the rank of rank of rank of rank"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_config_items(self):\n        return (\n            ('settings', self.settings),\n            ('context_class', self.context_class),\n            ('interfaces', self.interfaces),\n            ('logging', self.logging),\n            ('name', self.name),\n            ('init_handler', self.init_handler),\n            ('sigusr1_handler', self.sigusr1_handler),\n            ('sigusr2_handler', self.sigusr2_handler),\n        )", "response": "Return a list of items from the current configuration."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef context_class(self):\n        if 'context_class' not in self._cached_values:\n            context_cls_name = getattr(self.settings, 'CONTEXT_CLASS', '')\n            if context_cls_name:\n                context_class = import_object(context_cls_name)\n            else:\n                context_class = Context\n            self._cached_values['context_class'] = context_class\n        return self._cached_values['context_class']", "response": "Return the class object that represents the current context."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a list of all interfaces in the current session.", "response": "def interfaces(self):\n        \"\"\"\n        Interfaces as a :class:`list`of the\n        :class:`shelter.core.config.Config.Interface` instances.\n        \"\"\"\n        if 'interfaces' not in self._cached_values:\n            self._cached_values['interfaces'] = []\n            for name, interface in six.iteritems(self.settings.INTERFACES):\n                listen = interface.get('LISTEN')\n                unix_socket = interface.get('UNIX_SOCKET')\n                if not listen and not unix_socket:\n                    raise ValueError(\n                        'Interface MUST listen either on TCP '\n                        'or UNIX socket or both')\n                host, port = parse_host(listen) if listen else (None, None)\n                processes = int(interface.get('PROCESSES', 1))\n                urls_obj_name = interface.get('URLS', '')\n                if urls_obj_name:\n                    urls = import_object(urls_obj_name)\n                else:\n                    urls = ()\n                self._cached_values['interfaces'].append(\n                    self.Interface(\n                        name, host, port, unix_socket, processes, urls)\n                )\n        return self._cached_values['interfaces']"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef action(args):\n    log.info('loading reference package')\n\n    pairs = [p.split('=', 1) for p in args.changes]\n    if args.metadata:\n        rp = refpkg.Refpkg(args.refpkg, create=False)\n        rp.start_transaction()\n        for key, value in pairs:\n            rp.update_metadata(key, value)\n        rp.commit_transaction('Updated metadata: ' +\n                              ', '.join(['%s=%s' % (a, b)\n                                         for a, b in pairs]))\n    else:\n        for key, filename in pairs:\n            if not(os.path.exists(filename)):\n                print(\"No such file: %s\" % filename)\n                exit(1)\n\n        rp = refpkg.Refpkg(args.refpkg, create=False)\n        rp.start_transaction()\n        for key, filename in pairs:\n            if key == 'tree_stats':\n                with warnings.catch_warnings():\n                    warnings.simplefilter(\n                        \"ignore\", refpkg.DerivedFileNotUpdatedWarning)\n                    rp.update_file(key, os.path.abspath(filename))\n                # Trigger model update\n                log.info('Updating phylo_model to match tree_stats')\n                rp.update_phylo_model(args.stats_type, filename,\n                                      args.frequency_type)\n            else:\n                rp.update_file(key, os.path.abspath(filename))\n\n        rp.commit_transaction('Updates files: ' +\n                              ', '.join(['%s=%s' % (a, b)\n                                         for a, b in pairs]))\n    return 0", "response": "Updates a Refpkg with new files."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef import_object(name):\n    parts = name.split('.')\n    if len(parts) < 2:\n        raise ValueError(\"Invalid name '%s'\" % name)\n    module_name = \".\".join(parts[:-1])\n    obj_name = parts[-1]\n    module = importlib.import_module(module_name)\n    return getattr(module, obj_name)", "response": "Imports object from module and returns object from it."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef parse_arguments(argv):\n    parser = argparse.ArgumentParser(description=DESCRIPTION)\n    base_parser = argparse.ArgumentParser(add_help=False)\n\n    parser.add_argument('-V', '--version', action='version',\n                        version='taxit v' + version,\n                        help='Print the version number and exit')\n\n    parser.add_argument('-v', '--verbose',\n                        action='count', dest='verbosity', default=1,\n                        help='Increase verbosity of screen output (eg, -v is verbose, '\n                        '-vv more so)')\n    parser.add_argument('-q', '--quiet',\n                        action='store_const', dest='verbosity', const=0,\n                        help='Suppress output')\n\n    ##########################\n    # Setup all sub-commands #\n    ##########################\n\n    subparsers = parser.add_subparsers(dest='subparser_name')\n\n    # Begin help sub-command\n    parser_help = subparsers.add_parser(\n        'help', help='Detailed help for actions using `help <action>`')\n    parser_help.add_argument('action', nargs=1)\n    # End help sub-command\n\n    actions = {}\n\n    for name, mod in subcommands.itermodules(\n            os.path.split(subcommands.__file__)[0]):\n        # set up subcommand help text. The first line of the dosctring\n        # in the module is displayed as the help text in the\n        # script-level help message (`script -h`). The entire\n        # docstring is displayed in the help message for the\n        # individual subcommand ((`script action -h`)).\n        subparser = subparsers.add_parser(\n            name,\n            prog='taxit {}'.format(name),\n            help=mod.__doc__.lstrip().split('\\n', 1)[0],\n            description=mod.__doc__,\n            formatter_class=RawDescriptionHelpFormatter,\n            parents=[base_parser])\n\n        mod.build_parser(subparser)\n        actions[name] = mod.action\n\n    # Determine we have called ourself (e.g. \"help <action>\")\n    # Set arguments to display help if parameter is set\n    #           *or*\n    # Set arguments to perform an action with any specified options.\n    arguments = parser.parse_args(argv)\n    # Determine which action is in play.\n    action = arguments.subparser_name\n\n    # Support help <action> by simply having this function call itself and\n    # translate the arguments into something that argparse can work with.\n    if action == 'help':\n        return parse_arguments([str(arguments.action[0]), '-h'])\n\n    return actions[action], arguments", "response": "Create the argument parser for the base argument parser."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef execute(self, statements, exc=IntegrityError, rasie_as=ValueError):\n\n        Session = sessionmaker(bind=self.engine)\n        session = Session()\n\n        try:\n            for statement in statements:\n                session.execute(statement)\n        except exc as err:\n            session.rollback()\n            raise rasie_as(str(err))\n        else:\n            session.commit()\n        finally:\n            session.close()", "response": "Execute a list of statements in a session and perform a rollback on\n        error."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the node id and rank of a tax_id", "response": "def _node(self, tax_id):\n        \"\"\"\n        Returns parent_id, rank\n\n        FIXME: expand return rank to include custom 'below' ranks built when\n               get_lineage is caled\n        \"\"\"\n        s = select([self.nodes.c.parent_id, self.nodes.c.rank],\n                   self.nodes.c.tax_id == tax_id)\n        res = s.execute()\n        output = res.fetchone()\n        if not output:\n            msg = 'value \"{}\" not found in nodes.tax_id'.format(tax_id)\n            raise ValueError(msg)\n        else:\n            return output"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the primary taxonomic name associated with tax_id", "response": "def primary_from_id(self, tax_id):\n        \"\"\"\n        Returns primary taxonomic name associated with tax_id\n        \"\"\"\n        s = select([self.names.c.tax_name],\n                   and_(self.names.c.tax_id == tax_id,\n                        self.names.c.is_primary))\n        res = s.execute()\n        output = res.fetchone()\n\n        if not output:\n            msg = 'value \"{}\" not found in names.tax_id'.format(tax_id)\n            raise ValueError(msg)\n        else:\n            return output[0]"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns tax_id and primary tax_name corresponding to tax_name.", "response": "def primary_from_name(self, tax_name):\n        \"\"\"\n        Return tax_id and primary tax_name corresponding to tax_name.\n        \"\"\"\n        names = self.names\n\n        s1 = select([names.c.tax_id, names.c.is_primary],\n                    names.c.tax_name == tax_name)\n\n        log.debug(str(s1))\n\n        res = s1.execute().fetchone()\n        if res:\n            tax_id, is_primary = res\n        else:\n            msg = '\"{}\" not found in names.tax_names'.format(tax_name)\n            raise ValueError(msg)\n\n        if not is_primary:\n            s2 = select([names.c.tax_name],\n                        and_(names.c.tax_id == tax_id,\n                             names.c.is_primary))\n            tax_name = s2.execute().fetchone()[0]\n\n        return tax_id, tax_name, bool(is_primary)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning tax_id into which tax_id has been merged or tax_id of not obsolete.", "response": "def _get_merged(self, tax_id):\n        \"\"\"Returns tax_id into which `tax_id` has been merged or `tax_id` of\n        not obsolete.\n\n        \"\"\"\n\n        cmd = \"\"\"\n        SELECT COALESCE(\n        (SELECT new_tax_id FROM {merged}\n         WHERE old_tax_id = {x}), {x})\n        \"\"\".format(x=self.placeholder, merged=self.merged)\n\n        with self.engine.connect() as con:\n            result = con.execute(cmd, (tax_id, tax_id))\n            return result.fetchone()[0]"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _get_lineage(self, tax_id, merge_obsolete=True):\n\n        # Be sure we aren't working with an obsolete tax_id\n        if merge_obsolete:\n            tax_id = self._get_merged(tax_id)\n\n        # Note: joining with ranks seems like a no-op, but for some\n        # reason it results in a faster query using sqlite, as well as\n        # an ordering from leaf --> root. Might be a better idea to\n        # sort explicitly if this is the expected behavior, but it\n        # seems like for the most part, the lineage is converted to a\n        # dict and the order is irrelevant.\n        cmd = \"\"\"\n        WITH RECURSIVE a AS (\n         SELECT tax_id, parent_id, rank\n          FROM {nodes}\n          WHERE tax_id = {}\n        UNION ALL\n         SELECT p.tax_id, p.parent_id, p.rank\n          FROM a JOIN {nodes} p ON a.parent_id = p.tax_id\n        )\n        SELECT a.rank, a.tax_id FROM a\n        JOIN {ranks} using(rank)\n        \"\"\".format(self.placeholder, nodes=self.nodes, ranks=self.ranks_table)\n\n        # with some versions of sqlite3, an error is raised when no\n        # rows are returned; with others, an empty list is returned.\n        try:\n            with self.engine.connect() as con:\n                result = con.execute(cmd, (tax_id,))\n                # reorder so that root is first\n                lineage = result.fetchall()[::-1]\n        except sqlalchemy.exc.ResourceClosedError:\n            lineage = []\n\n        if not lineage:\n            raise ValueError('tax id \"{}\" not found'.format(tax_id))\n\n        return lineage", "response": "Return a list of tuples describing the lineage of a specific tax_id."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _get_lineage_table(self, tax_ids, merge_obsolete=True):\n\n        try:\n            with self.engine.connect() as con:\n                # insert tax_ids into a temporary table\n\n                temptab = self.prepend_schema(random_name(12))\n\n                cmd = 'CREATE TEMPORARY TABLE \"{tab}\" (old_tax_id text)'.format(\n                    tab=temptab)\n                con.execute(cmd)\n\n                log.info('inserting tax_ids into temporary table')\n                # TODO: couldn't find an equivalent of \"executemany\" - does one exist?\n                cmd = 'INSERT INTO \"{tab}\" VALUES ({x})'.format(\n                    tab=temptab, x=self.placeholder)\n                for tax_id in tax_ids:\n                    con.execute(cmd, tax_id)\n\n                log.info('executing recursive CTE')\n                cmd = Template(\"\"\"\n                WITH RECURSIVE a AS (\n                 SELECT tax_id as tid, 1 AS ord, tax_id, parent_id, rank\n                  FROM {{ nodes }}\n                  WHERE tax_id in (\n                  {% if merge_obsolete %}\n                  SELECT COALESCE(m.new_tax_id, \"{{ temptab }}\".old_tax_id)\n                    FROM \"{{ temptab }}\" LEFT JOIN {{ merged }} m USING(old_tax_id)\n                  {% else %}\n                  SELECT * from \"{{ temptab }}\"\n                  {% endif %}\n                  )\n                UNION ALL\n                 SELECT a.tid, a.ord + 1, p.tax_id, p.parent_id, p.rank\n                  FROM a JOIN {{ nodes }} p ON a.parent_id = p.tax_id\n                )\n                SELECT a.tid, a.tax_id, a.parent_id, a.rank, tax_name FROM a\n                JOIN {{ names }} using(tax_id)\n                WHERE names.is_primary\n                ORDER BY tid, ord desc\n                \"\"\").render(\n                    temptab=temptab,\n                    merge_obsolete=merge_obsolete,\n                    merged=self.merged,\n                    nodes=self.nodes,\n                    names=self.names,\n                )\n\n                result = con.execute(cmd)\n                rows = result.fetchall()\n\n                con.execute('DROP TABLE \"{}\"'.format(temptab))\n                log.info('returning lineages')\n                if not rows:\n                    raise ValueError('no tax_ids were found')\n                else:\n                    returned = {row[0] for row in rows}\n                    # TODO: compare set membership, not lengths\n                    if len(returned) < len(tax_ids):\n                        msg = ('{} tax_ids were provided '\n                               'but only {} were returned').format(\n                                   len(tax_ids), len(returned))\n                        log.error('Input tax_ids not represented in output:')\n                        log.error(sorted(set(tax_ids) - returned))\n                        raise ValueError(msg)\n\n                return rows\n\n        except sqlalchemy.exc.ResourceClosedError:\n            raise ValueError('tax id \"{}\" not found'.format(tax_id))", "response": "Return a list of tuples describing the lineage of tax_id and tax_name of tax_id."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nadding a row to table source if name does not exist. Returns a tuple of source_id and True if a new row is created.", "response": "def add_source(self, source_name, description=None):\n        \"\"\"Adds a row to table \"source\" if \"name\" does not\n        exist. Returns (source_id, True) if a new row is created,\n        (source_id, False) otherwise.\n\n        \"\"\"\n\n        # TODO: shoud be able to do this inside a transaction\n\n        if not source_name:\n            raise ValueError('\"source_name\" may not be None or an empty string')\n\n        sel = select([self.source.c.id], self.source.c.name == source_name).execute()\n        result = sel.fetchone()\n        if result:\n            return result[0], False\n        else:\n            ins = self.source.insert().execute(\n                name=source_name, description=description)\n            return ins.inserted_primary_key[0], True"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a dict with keys id name description", "response": "def get_source(self, source_id=None, source_name=None):\n        \"\"\"Returns a dict with keys ['id', 'name', 'description'] or None if\n        no match. The ``id`` field is guaranteed to be an int that\n        exists in table source. Requires exactly one of ``source_id``\n        or ``source_name``. A new source corresponding to\n        ``source_name`` is created if necessary.\n\n        \"\"\"\n\n        if not (bool(source_id) ^ bool(source_name)):\n            raise ValueError('exactly one of source_id or source_name is required')\n\n        if source_id:\n            try:\n                source_id = int(source_id)\n            except (ValueError, TypeError):\n                raise ValueError(\n                    'source_id must be an int or a string representing one')\n\n            sel = select([self.source], self.source.c.id == source_id).execute()\n        else:\n            sel = select([self.source], self.source.c.name == source_name).execute()\n\n        result = sel.fetchone()\n        if not result:\n            raise ValueError(\n                'there is no source with id {} or name {}'.format(\n                    source_id, source_name))\n\n        return dict(list(zip(list(sel.keys()), result)))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef verify_rank_integrity(self, tax_id, rank, parent_id, children):\n        def _lower(n1, n2):\n            return self.ranks.index(n1) < self.ranks.index(n2)\n\n        if rank not in self.ranks:\n            raise TaxonIntegrityError('rank \"{}\" is undefined'.format(rank))\n\n        parent_rank = self.rank(parent_id)\n        # undefined ranks can be placed anywhere in a lineage\n        if not _lower(rank, parent_rank) and rank != self.NO_RANK:\n            msg = ('New node \"{}\", rank \"{}\" has same or '\n                   'higher rank than parent node \"{}\", rank \"{}\"')\n            msg = msg.format(tax_id, rank, parent_id, parent_rank)\n            raise TaxonIntegrityError(msg)\n\n        for child in children:\n            if not _lower(self.rank(child), rank):\n                msg = 'Child node {} has same or lower rank as new node {}'\n                msg = msg.format(tax_id, child)\n                raise TaxonIntegrityError(msg)\n        return True", "response": "Confirm that the rank of a node is consistent with the parent and children ranks."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef add_node(self, tax_id, parent_id, rank, names, source_name, children=None,\n                 is_valid=True, execute=True, **ignored):\n        \"\"\"Add a node to the taxonomy.\n\n        ``source_name`` is added to table \"source\" if necessary.\n\n        \"\"\"\n\n        if ignored:\n            log.info('some arguments were ignored: {} '.format(str(ignored)))\n\n        children = children or []\n        self.verify_rank_integrity(tax_id, rank, parent_id, children)\n        source_id, __ = self.add_source(source_name)\n        assert isinstance(is_valid, bool)\n\n        statements = []\n\n        # add node\n        statements.append(\n            self.nodes.insert().values(\n                tax_id=tax_id,\n                parent_id=parent_id,\n                rank=rank,\n                source_id=source_id))\n\n        # add names. Since this is a new node, at least one name must\n        # be provided; if only one is provided, it is the primary\n        # name. If more than one is primary, an error will be raised\n        # from add_names()\n        if len(names) == 1:\n            names[0]['is_primary'] = True\n        else:\n            primary_names = [n['tax_name'] for n in names if n.get('is_primary')]\n            if len(primary_names) != 1:\n                raise ValueError(\n                    '`is_primary` must be True for exactly one name in `names`')\n\n        for namedict in names:\n            namedict['source_id'] = source_id\n            if 'source_name' in namedict:\n                del namedict['source_name']\n\n        statements.extend(self.add_names(tax_id, names, execute=False))\n\n        # add children and update source_id\n        for child in children:\n            statements.append(self.nodes.update(\n                whereclause=self.nodes.c.tax_id == child,\n                values={'parent_id': tax_id, 'source_id': source_id}))\n\n        if execute:\n            self.execute(statements)\n        else:\n            return statements", "response": "Add a node to the taxonomy."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nadd a record to the names table corresponding to the tax_id.", "response": "def add_name(self, tax_id, tax_name, source_name=None, source_id=None,\n                 name_class='synonym', is_primary=False, is_classified=None,\n                 execute=True, **ignored):\n\n        \"\"\"Add a record to the names table corresponding to\n        ``tax_id``. Arguments are as follows:\n\n        - tax_id (string, required)\n        - tax_name (string, required)\n\n        *one* of the following are required:\n\n        - source_id (int or string coercable to int)\n        - source_name (string)\n\n        ``source_id`` or ``source_name`` must identify an existing\n        record in table \"source\".\n\n        The following are optional:\n\n        - name_class (string, default 'synonym')\n        - is_primary (bool, see below)\n        - is_classified (bool or None, default None)\n\n        ``is_primary`` is optional and defaults to True if only one\n        name is provided; otherwise is_primary must be True for\n        exactly one name (and is optional in others).\n\n        \"\"\"\n\n        assert isinstance(is_primary, bool)\n        assert is_classified in {None, True, False}\n        if ignored:\n            log.info('some arguments were ignored: {} '.format(str(ignored)))\n\n        source_id = self.get_source(source_id, source_name)['id']\n\n        statements = []\n\n        if is_primary:\n            statements.append(self.names.update(\n                whereclause=self.names.c.tax_id == tax_id,\n                values={'is_primary': False}))\n\n        statements.append(self.names.insert().values(\n            tax_id=tax_id,\n            tax_name=tax_name,\n            source_id=source_id,\n            is_primary=is_primary,\n            name_class=name_class,\n            is_classified=is_classified))\n\n        if execute:\n            self.execute(statements)\n        else:\n            return statements"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nassociating one or more names with tax_id.", "response": "def add_names(self, tax_id, names, execute=True):\n        \"\"\"Associate one or more names with ``tax_id``.\n\n        ``names`` is a list of one or more dicts, with keys\n        corresponding to the signature of ``self.add_name()``\n        (excluding ``execute``).\n\n        \"\"\"\n\n        primary_names = [n['tax_name'] for n in names if n.get('is_primary')]\n        if len(primary_names) > 1:\n            raise ValueError(\n                '`is_primary` may be True for no more than one name in `names`')\n\n        statements = []\n\n        for namevals in names:\n            if 'tax_id' in namevals:\n                del namevals['tax_id']\n            statements.extend(\n                self.add_name(tax_id=tax_id, execute=False, **namevals))\n\n        if execute:\n            self.execute(statements)\n        else:\n            return statements"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef sibling_of(self, tax_id):\n        if tax_id is None:\n            return None\n        parent_id, rank = self._node(tax_id)\n        s = select([self.nodes.c.tax_id],\n                   and_(self.nodes.c.parent_id == parent_id,\n                        self.nodes.c.tax_id != tax_id,\n                        self.nodes.c.rank == rank))\n        res = s.execute()\n        output = res.fetchone()\n        if not output:\n            msg = 'No sibling of tax_id {} with rank {} found in taxonomy'\n            msg = msg.format(tax_id, rank)\n            log.warning(msg)\n            return None\n        else:\n            return output[0]", "response": "Return None or a tax_id of a sibling of tax_id."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning all tax_ids in node table", "response": "def tax_ids(self):\n        '''\n        Return all tax_ids in node table\n        '''\n        fetch = select([self.nodes.c.tax_id]).execute().fetchall()\n        ids = [t[0] for t in fetch]\n        return ids"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef child_of(self, tax_id):\n        if tax_id is None:\n            return None\n        parent_id, rank = self._node(tax_id)\n        s = select([self.nodes.c.tax_id],\n                   and_(self.nodes.c.parent_id == tax_id,\n                        or_(*[self.nodes.c.rank == r\n                              for r in self.ranks_below(rank)])))\n        res = s.execute()\n        output = res.fetchone()\n        if not output:\n            msg = ('No children of tax_id {} with '\n                   'rank below {} found in database')\n            msg = msg.format(tax_id, rank)\n            log.warning(msg)\n            return None\n        else:\n            r = output[0]\n            assert self.is_ancestor_of(r, tax_id)\n            return r", "response": "Return None or a tax id of a child of tax_id."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef nary_subtree(self, tax_id, n=2):\n        if tax_id is None:\n            return None\n        parent_id, rank = self._node(tax_id)\n        if rank == 'species':\n            return [tax_id]\n        else:\n            children = self.children_of(tax_id, 2)\n            species_taxids = []\n            for t in children:\n                species_taxids.extend(self.nary_subtree(t, n))\n            return species_taxids", "response": "Return a list of species tax_ids under tax_id such that the node under tax_id is above the species and that the node under tax_id has two children."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncheck if a DB is authorized and responding before executing the function", "response": "def validate_db(sqlalchemy_bind, is_enabled=ENABLE_DB):\n    \"\"\" Checks if a DB is authorized and responding before executing the function \"\"\"\n    def decorator(func):\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            def is_db_responsive():\n                try:\n                    sqlalchemy_bind.session.query('1').first_or_404()\n                except:\n                    return False\n                else:\n                    return True\n            if is_enabled and is_db_responsive():\n                return func(*args, **kwargs)\n            else:\n                abort(HTTP_CODES.UNAUTHORIZED)\n        return wrapper\n    return decorator"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef substitute(template, mapping=None):\n    if mapping is None:\n        mapping = {}\n    templ = Template(template)\n    return templ.substitute(mapping)", "response": "Render the template with the given mapping."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nfinds recursively and return all files and directories from the path * path*.", "response": "def dirtree(path):\n    \"\"\"\n    Find recursively and return all files and directories from\n    the path *path*.\n    \"\"\"\n    results = []\n    for name in glob.glob(os.path.join(path, '*')):\n        results.append(name)\n        if os.path.isdir(name):\n            results.extend(dirtree(name))\n    return results"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_tornado_apps(context, debug=False):\n    if context.config.app_settings_handler:\n        app_settings_handler = import_object(\n            context.config.app_settings_handler)\n        settings = app_settings_handler(context)\n    else:\n        settings = {}\n\n    apps = []\n    for interface in context.config.interfaces:\n        urls = interface.urls\n        if not urls:\n            urls = [tornado.web.URLSpec('/', NullHandler)]\n        apps.append(\n            tornado.web.Application(\n                urls, debug=debug, context=context,\n                interface=interface, **settings\n            )\n        )\n    return apps", "response": "Create Tornado s application for all interfaces which are defined\n    in the configuration."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns an iterator of dicts given a. csv - format file.", "response": "def get_new_nodes(fname):\n    \"\"\"\n    Return an iterator of dicts given a .csv-format file.\n    \"\"\"\n\n    with open(fname, 'rU') as infile:\n        infile = (line for line in infile if not line.startswith('#'))\n        reader = list(csv.DictReader(infile))\n        rows = (d for d in reader if d['tax_id'])\n\n    # for now, children are provided as a semicolon-delimited list\n    # within a cell (yes, yuck). We need to convert thit into a list\n    # if present.\n    for d in rows:\n        if 'children' in d:\n            if d['children']:\n                d['children'] = [x.strip() for x in d['children'].split(';')]\n            else:\n                del d['children']\n        yield d"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef getlines(fname):\n\n    with open(fname, 'rU') as f:\n        for line in f:\n            if line.strip() and not line.startswith('#'):\n                yield line.split('#', 1)[0].strip()", "response": "Returns iterator of whitespace - stripped lines in file fname omitting\nTaxonomy blank lines beginning with '#' character."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef parse_raxml(handle):\n    s = ''.join(handle.readlines())\n    result = {}\n    try_set_fields(result, r'(?P<program>RAxML version [0-9.]+)', s)\n    try_set_fields(result, r'(?P<datatype>DNA|RNA|AA)', s)\n    result['empirical_frequencies'] = (\n        result['datatype'] != 'AA' or\n        re.search('empirical base frequencies', s, re.IGNORECASE) is not None)\n    try_set_fields(result, r'Substitution Matrix: (?P<subs_model>\\w+)', s)\n    rates = {}\n    if result['datatype'] != 'AA':\n        try_set_fields(rates,\n                       (r\"rates\\[0\\] ac ag at cg ct gt: \"\n                        r\"(?P<ac>[0-9.]+) (?P<ag>[0-9.]+) (?P<at>[0-9.]+) \"\n                        r\"(?P<cg>[0-9.]+) (?P<ct>[0-9.]+) (?P<gt>[0-9.]+)\"),\n                       s, hook=float)\n        try_set_fields(rates, r'rate A <-> C: (?P<ac>[0-9.]+)', s, hook=float)\n        try_set_fields(rates, r'rate A <-> G: (?P<ag>[0-9.]+)', s, hook=float)\n        try_set_fields(rates, r'rate A <-> T: (?P<at>[0-9.]+)', s, hook=float)\n        try_set_fields(rates, r'rate C <-> G: (?P<cg>[0-9.]+)', s, hook=float)\n        try_set_fields(rates, r'rate C <-> T: (?P<ct>[0-9.]+)', s, hook=float)\n        try_set_fields(rates, r'rate G <-> T: (?P<gt>[0-9.]+)', s, hook=float)\n        if len(rates) > 0:\n            result['subs_rates'] = rates\n    result['gamma'] = {'n_cats': 4}\n    try_set_fields(result['gamma'],\n                   r\"alpha[\\[\\]0-9]*: (?P<alpha>[0-9.]+)\", s, hook=float)\n    result['ras_model'] = 'gamma'\n    return result", "response": "Parse the RAxML summary output."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nparse an alignment a file.", "response": "def parse_stockholm(fobj):\n    \"\"\"Return a list of names from an Stockholm-format sequence alignment\n    file. ``fobj`` is an open file or another object representing a\n    sequence of lines.\n\n    \"\"\"\n\n    names = OrderedDict()\n\n    found_eof = False\n    for line in fobj:\n        line = line.strip()\n        if line == '//':\n            found_eof = True\n        elif line.startswith('#') or not line.strip():\n            continue\n        else:\n            name, __ = line.split(None, 1)\n            names[name] = None\n\n    if not found_eof:\n        raise ValueError('Invalid Stockholm format: no file terminator')\n\n    return list(names.keys())"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncheck if rppr binary exists in path", "response": "def has_rppr(rppr_name='rppr'):\n    \"\"\"\n    Check for rppr binary in path\n    \"\"\"\n    with open(os.devnull) as dn:\n        try:\n            subprocess.check_call([rppr_name], stdout=dn, stderr=dn)\n        except OSError as e:\n            if e.errno == os.errno.ENOENT:\n                return False\n            else:\n                raise\n        except subprocess.CalledProcessError as e:\n            # rppr returns non-zero exit status with no arguments\n            pass\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef add_database_args(parser):\n    '''\n    Add a standard set of database arguments for argparse\n    '''\n    parser.add_argument(\n        'url',\n        nargs='?',\n        default='sqlite:///ncbi_taxonomy.db',\n        type=sqlite_default(),\n        help=('Database string URI or filename.  If no database scheme '\n              'specified \\\"sqlite:///\\\" will be prepended. [%(default)s]'))\n    db_parser = parser.add_argument_group(title='database options')\n\n    # TODO: better description of what --schema does\n    db_parser.add_argument(\n        '--schema',\n        help=('Name of SQL schema in database to query '\n              '(if database flavor supports this).'))\n\n    return parser", "response": "Add a standard set of database arguments for argparse parser"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a function that parses a sqlite database and returns the url of the database.", "response": "def sqlite_default():\n    '''\n    Prepend default scheme if none is specified. This helps provides backwards\n    compatibility with old versions of taxtastic where sqlite was the automatic\n    default database.\n    '''\n    def parse_url(url):\n        # TODO: need separate option for a config file\n        if url.endswith('.db') or url.endswith('.sqlite'):\n            if not url.startswith('sqlite:///'):\n                url = 'sqlite:///' + url\n        elif url.endswith('.cfg') or url.endswith('.conf'):\n            conf = configparser.SafeConfigParser(allow_no_value=True)\n            conf.optionxform = str  # options are case-sensitive\n            conf.read(url)\n            url = conf.get('sqlalchemy', 'url')\n\n        return url\n    return parse_url"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nstrips non - current files and rollback information from a refpkg.", "response": "def action(args):\n    \"\"\"Strips non-current files and rollback information from a refpkg.\n\n    *args* should be an argparse object with fields refpkg (giving the\n    path to the refpkg to operate on).\n    \"\"\"\n    log.info('loading reference package')\n\n    refpkg.Refpkg(args.refpkg, create=False).strip()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_conf_d_files(path):\n    if not os.path.isdir(path):\n        raise ValueError(\"'%s' is not a directory\" % path)\n    files_mask = os.path.join(path, \"*.conf\")\n    return [f for f in sorted(glob.glob(files_mask)) if os.path.isfile(f)]", "response": "Return alphabetical ordered list of the. conf files placed in the path."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a list of all configuration files.", "response": "def get_conf_files(filename):\n    \"\"\"\n    Return :class:`list` of the all configuration files. *filename* is a\n    path of the main configuration file.\n\n    ::\n\n        >>> get_conf_files('exampleapp.conf')\n        ['exampleapp.conf', 'exampleapp.conf.d/10-database.conf']\n    \"\"\"\n    if not os.path.isfile(filename):\n        raise ValueError(\"'%s' is not a file\" % filename)\n    conf_d_path = \"%s.d\" % filename\n    if not os.path.exists(conf_d_path):\n        return [filename]\n    return [filename] + get_conf_d_files(conf_d_path)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_configparser(filename=''):\n    filename = filename or os.environ.get('SHELTER_CONFIG_FILENAME', '')\n    if not filename:\n        raise ImproperlyConfiguredError(_(\n            \"Configuration file is not defined. You must either \"\n            \"set 'SHELTER_CONFIG_FILENAME' environment variable or \"\n            \"'-f/--config-file' command line argument.\"\n        ))\n\n    parser = six.moves.configparser.RawConfigParser()\n    for conf_file in get_conf_files(filename):\n        logger.info(\"Found config '%s'\", conf_file)\n        if not parser.read(conf_file):\n            logger.warning(\"Error while parsing config '%s'\", conf_file)\n    return parser", "response": "Read main configuration file and all files from * conf. d * subdirectory\n    and return parsed configuration as a ConfigParser instance."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef name(self):\n        try:\n            return self.config_parser.get('application', 'name')\n        except CONFIGPARSER_EXC:\n            return super(IniConfig, self).name", "response": "Return the name of the application."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef interfaces(self):\n        if 'interfaces' not in self._cached_values:\n            self._cached_values['interfaces'] = []\n            for name, interface in six.iteritems(self.settings.INTERFACES):\n                interface_name = 'interface_%s' % name\n                # Hostname:port + unix socket\n                try:\n                    listen = self.config_parser.get(interface_name, 'Listen')\n                except CONFIGPARSER_EXC:\n                    listen = interface.get('LISTEN')\n                try:\n                    unix_socket = self.config_parser.get(\n                        interface_name, 'UnixSocket')\n                except CONFIGPARSER_EXC:\n                    unix_socket = interface.get('UNIX_SOCKET')\n                if not listen and not unix_socket:\n                    raise ValueError(\n                        'Interface MUST listen either on TCP '\n                        'or UNIX socket or both')\n                host, port = parse_host(listen) if listen else (None, None)\n                # Processes\n                try:\n                    processes = self.config_parser.getint(\n                        interface_name, 'Processes')\n                except CONFIGPARSER_EXC:\n                    processes = int(interface.get('PROCESSES', 1))\n                # Urls\n                try:\n                    urls_obj_name = self.config_parser.get(\n                        interface_name, 'Urls')\n                except CONFIGPARSER_EXC:\n                    urls_obj_name = interface.get('URLS', '')\n                if urls_obj_name:\n                    urls = import_object(urls_obj_name)\n                else:\n                    urls = ()\n\n                self._cached_values['interfaces'].append(\n                    self.Interface(\n                        name, host, port, unix_socket, processes, urls)\n                )\n        return self._cached_values['interfaces']", "response": "Return a list of all interfaces in the config file."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nopens a file from the zoneinfo subdir for reading.", "response": "def tz_file(name):\n    \"\"\"\n    Open a timezone file from the zoneinfo subdir for reading.\n\n    :param name: The name of the timezone.\n    :type name: str\n\n    :rtype: file\n    \"\"\"\n    try:\n        filepath = tz_path(name)\n\n        return open(filepath, 'rb')\n    except TimezoneNotFound:\n        # http://bugs.launchpad.net/bugs/383171 - we avoid using this\n        # unless absolutely necessary to help when a broken version of\n        # pkg_resources is installed.\n        try:\n            from pkg_resources import resource_stream\n        except ImportError:\n            resource_stream = None\n\n        if resource_stream is not None:\n            try:\n                return resource_stream(__name__, 'zoneinfo/' + name)\n            except FileNotFoundError:\n                return tz_path(name)\n\n        raise"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef tz_path(name):\n    if not name:\n        raise ValueError('Invalid timezone')\n\n    name_parts = name.lstrip('/').split('/')\n\n    for part in name_parts:\n        if part == os.path.pardir or os.path.sep in part:\n            raise ValueError('Bad path segment: %r' % part)\n\n    filepath = os.path.join(_DIRECTORY, *name_parts)\n\n    if not os.path.exists(filepath):\n        raise TimezoneNotFound('Timezone {} not found at {}'.format(name, filepath))\n\n    return filepath", "response": "Return the path to a timezone file."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the supported timezones.", "response": "def get_timezones():\n    \"\"\"\n    Get the supported timezones.\n\n    The list will be cached unless you set the \"fresh\" attribute to True.\n\n    :param fresh: Whether to get a fresh list or not\n    :type fresh: bool\n\n    :rtype: tuple\n    \"\"\"\n    base_dir = _DIRECTORY\n    zones = ()\n\n    for root, dirs, files in os.walk(base_dir):\n        for basename in files:\n            zone = os.path.join(root, basename)\n            if os.path.isdir(zone):\n                continue\n\n            zone = os.path.relpath(zone, base_dir)\n\n            with open(os.path.join(root, basename), 'rb') as fd:\n                if fd.read(4) == b'TZif' and zone not in INVALID_ZONES:\n                    zones = zones + (zone,)\n\n    return tuple(sorted(zones))"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nawards target the point value for key.", "response": "def award_points(target, key, reason=\"\", source=None):\n    \"\"\"\n    Awards target the point value for key.  If key is an integer then it's a\n    one off assignment and should be interpreted as the actual point value.\n    \"\"\"\n    point_value, points = get_points(key)\n\n    if not ALLOW_NEGATIVE_TOTALS:\n        total = points_awarded(target)\n        if total + points < 0:\n            reason = reason + \"(floored from {0} to 0)\".format(points)\n            points = -total\n\n    apv = AwardedPointValue(points=points, value=point_value, reason=reason)\n    if isinstance(target, get_user_model()):\n        apv.target_user = target\n        lookup_params = {\n            \"target_user\": target\n        }\n    else:\n        apv.target_object = target\n        lookup_params = {\n            \"target_content_type\": apv.target_content_type,\n            \"target_object_id\": apv.target_object_id,\n        }\n\n    if source is not None:\n        if isinstance(source, get_user_model()):\n            apv.source_user = source\n        else:\n            apv.source_object = source\n\n    apv.save()\n\n    if not TargetStat.update_points(points, lookup_params):\n        try:\n            sid = transaction.savepoint()\n            TargetStat._default_manager.create(\n                **dict(lookup_params, points=points)\n            )\n            transaction.savepoint_commit(sid)\n        except IntegrityError:\n            transaction.savepoint_rollback(sid)\n            TargetStat.update_points(points, lookup_params)\n\n    signals.points_awarded.send(\n        sender=target.__class__,\n        target=target,\n        key=key,\n        points=points,\n        source=source\n    )\n\n    new_points = points_awarded(target)\n    old_points = new_points - points\n\n    TargetStat.update_positions((old_points, new_points))\n\n    return apv"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef points_awarded(target=None, source=None, since=None):\n\n    lookup_params = {}\n\n    if target is not None:\n        if isinstance(target, get_user_model()):\n            lookup_params[\"target_user\"] = target\n        else:\n            lookup_params.update({\n                \"target_content_type\": ContentType.objects.get_for_model(target),\n                \"target_object_id\": target.pk,\n            })\n    if source is not None:\n        if isinstance(source, get_user_model()):\n            lookup_params[\"source_user\"] = source\n        else:\n            lookup_params.update({\n                \"source_content_type\": ContentType.objects.get_for_model(source),\n                \"source_object_id\": source.pk,\n            })\n\n    if since is None:\n        if target is not None and source is None:\n            try:\n                return TargetStat.objects.get(**lookup_params).points\n            except TargetStat.DoesNotExist:\n                return 0\n        else:\n            return AwardedPointValue.points_awarded(**lookup_params)\n    else:\n        lookup_params[\"timestamp__gte\"] = since\n        return AwardedPointValue.points_awarded(**lookup_params)", "response": "Determines how many points the given target has received."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef __validate_dates(start_date, end_date):\n    try:\n        start_date = datetime.datetime.strptime(start_date, '%Y-%m-%d')\n        end_date = datetime.datetime.strptime(end_date, '%Y-%m-%d')\n    except ValueError:\n        raise ValueError(\"Incorrect data format, should be yyyy-mm-dd\")\n    if (end_date - start_date).days > 366:\n        raise ValueError(\"The difference between start and end date \" +\n                         \"should be less than or equal to 366 days.\")\n    if (end_date - start_date).days < 0:\n        raise ValueError(\"End date cannot be before start date.\")", "response": "Validate if a date string is a date on yyyy - mm - dd format and it is less than or equal to a year."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef __yahoo_request(query):\n    query = quote(query)\n    url = 'https://query.yahooapis.com/v1/public/yql?q=' + query + \\\n        '&format=json&env=store://datatables.org/alltableswithkeys'\n\n    response = urlopen(url).read()\n\n    return json.loads(response.decode('utf-8'))['query']['results']", "response": "Request Yahoo Finance information from YQL."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef request_quotes(tickers_list, selected_columns=['*']):\n    __validate_list(tickers_list)\n    __validate_list(selected_columns)\n    query = 'select {cols} from yahoo.finance.quotes where symbol in ({vals})'\n    query = query.format(\n        cols=', '.join(selected_columns),\n        vals=', '.join('\"{0}\"'.format(s) for s in tickers_list)\n    )\n\n    response = __yahoo_request(query)\n\n    if not response:\n        raise RequestError('Unable to process the request. Check if the ' +\n                           'columns selected are valid.')\n\n    if not type(response['quote']) is list:\n        return [response['quote']]\n    return response['quote']", "response": "Request Yahoo Finance recent quotes."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef request_historical(ticker, start_date, end_date):\n    __validate_dates(start_date, end_date)\n\n    cols = ['Date', 'Open', 'High', 'Low', 'Close', 'Volume', 'Adj_Close']\n    query = 'select {cols} from yahoo.finance.historicaldata ' + \\\n        'where symbol in (\"{ticker}\") and startDate = \"{start_date}\" ' + \\\n        'and endDate = \"{end_date}\"'\n    query = query.format(\n        cols=', '.join(cols),\n        ticker=ticker,\n        start_date=start_date,\n        end_date=end_date\n    )\n\n    response = __yahoo_request(query)\n    if not response:\n        raise RequestError('Unable to process the request. Check if the ' +\n                           'stock ticker used is a valid one.')\n\n    if not type(response['quote']) is list:\n        return [response['quote']]\n    return response['quote']", "response": "Request daily historical information for a given date range."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ndownload historical data from Yahoo Finance as CSV.", "response": "def download_historical(tickers_list, output_folder):\n    \"\"\"Download historical data from Yahoo Finance.\n\n    Downloads full historical data from Yahoo Finance as CSV. The following\n    fields are available: Adj Close, Close, High, Low, Open and Volume. Files\n    will be saved to output_folder as <ticker>.csv.\n\n    :param tickers_list: List of tickers that will be returned.\n    :type tickers_list: list of strings\n    :param output_folder: Output folder path\n    :type output_folder: string\n    \"\"\"\n    __validate_list(tickers_list)\n    for ticker in tickers_list:\n        file_name = os.path.join(output_folder, ticker + '.csv')\n        with open(file_name, 'wb') as f:\n            base_url = 'http://real-chart.finance.yahoo.com/table.csv?s='\n            try:\n                urlopen(base_url + ticker)\n                urlretrieve(base_url + ticker, f.name)\n            except:\n                os.remove(file_name)\n                raise RequestError('Unable to process the request. Check if ' +\n                                   ticker + ' is a valid stock ticker')"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsearching for files in the run - file directory and cellpy - files.", "response": "def search_for_files(run_name, raw_extension=None, cellpy_file_extension=None,\n                     raw_file_dir=None, cellpy_file_dir=None, prm_filename=None,\n                     file_name_format=None, cache=None):\n    \"\"\"Searches for files (raw-data files and cellpy-files).\n\n\n    Args:\n        run_name(str): run-file identification.\n        raw_extension(str): optional, extension of run-files (without the '.').\n        cellpy_file_extension(str): optional, extension for cellpy files\n            (without the '.').\n        raw_file_dir(path): optional, directory where to look for run-files\n            (default: read prm-file)\n        cellpy_file_dir(path): optional, directory where to look for\n            cellpy-files (default: read prm-file)\n        prm_filename(path): optional parameter file can be given.\n        file_name_format(str): format of raw-file names or a glob pattern\n            (default: YYYYMMDD_[name]EEE_CC_TT_RR).\n        cache(list): list of cached file names to search through\n\n    Returns:\n        run-file names (list) and cellpy-file-name (path).\n    \"\"\"\n\n    time_00 = time.time()\n    cellpy_file_extension = \"h5\"\n    res_extension = \"res\"\n    version = 0.1\n    # might include searching and removing \".\" in extensions\n    # should include extension definitions in prm file (version 0.6)\n    logger.debug(f\"searching for {run_name}\")\n    if raw_extension is None:\n        raw_extension = res_extension\n\n    if cellpy_file_extension is None:\n        cellpy_file_extension = cellpy_file_extension\n\n    if prm_filename is not None:\n        logging.debug(\"reading prm file disabled\")\n\n    if not all([raw_file_dir, cellpy_file_dir, file_name_format]):\n        # import cellpy.parameters.prms as prms\n        # prms = prmreader.read()\n        logger.debug(\"using prms already set\")\n\n    if raw_file_dir is None:\n        raw_file_dir = prms.Paths[\"rawdatadir\"]\n\n    if cellpy_file_dir is None:\n        cellpy_file_dir = prms.Paths[\"cellpydatadir\"]\n\n    if file_name_format is None:\n        try:\n            # To be implemented in version 0.5:\n            file_name_format = prms.file_name_format\n        except AttributeError:\n            file_name_format = \"YYYYMMDD_[name]EEE_CC_TT_RR\"\n            if version >= 0.5:\n                print(\"Could not read file_name_format \"\n                      \"from _cellpy_prms_xxx.conf.\")\n                print(\"Using:\")\n                print(\"file_name_format:\", file_name_format)\n                file_format_explanation = \"YYYYMMDD is date,\"\n                file_format_explanation += \" EEE is electrode number\"\n                file_format_explanation += \" CC is cell number,\"\n                file_format_explanation += \" TT is cell_type, RR is run number.\"\n                print(file_format_explanation)\n\n    # check if raw_file_dir exists\n    if not os.path.isdir(raw_file_dir):\n        warnings.warn(\"your raw file directory cannot be accessed!\")\n\n    if file_name_format.upper() == \"YYYYMMDD_[NAME]EEE_CC_TT_RR\":\n        glob_text_raw = \"%s_*.%s\" % (os.path.basename(run_name), raw_extension)\n        reg_exp_raw = \"xxx\"\n    else:\n        glob_text_raw = file_name_format\n\n    cellpy_file = \"{0}.{1}\".format(run_name, cellpy_file_extension)\n    cellpy_file = os.path.join(cellpy_file_dir, cellpy_file)\n\n    # TODO: @jepe - use pathlib\n\n    if cache is None:\n\n        use_pathlib_path = False\n        return_as_str_list = True\n\n        if use_pathlib_path:\n            logger.debug(\"using pathlib.Path\")\n            if os.path.isdir(raw_file_dir):\n                run_files = pathlib.Path(raw_file_dir).glob(glob_text_raw)\n                if return_as_str_list:\n                    run_files = [str(f.resolve()) for f in run_files]\n                    run_files.sort()\n            else:\n                run_files = []\n\n        else:\n            if os.path.isdir(raw_file_dir):\n                glob_text_raw_full = os.path.join(raw_file_dir, glob_text_raw)\n                run_files = glob.glob(glob_text_raw_full)\n                run_files.sort()\n            else:\n                run_files = []\n\n        logger.debug(f\"(dt: {(time.time() - time_00):4.2f}s)\")\n        return run_files, cellpy_file\n\n    else:\n        logger.debug(\"using cache in filefinder\")\n        if os.path.isdir(raw_file_dir):\n            if len(cache) == 0:\n                cache = os.listdir(raw_file_dir)\n            run_files = [\n                os.path.join(\n                    raw_file_dir, x\n                ) for x in cache if fnmatch.fnmatch(\n                    x, glob_text_raw\n                )\n            ]\n            run_files.sort()\n        else:\n            run_files = []\n\n        logger.debug(f\"(dt: {(time.time() - time_00):4.2f}s)\")\n        return run_files, cellpy_file, cache"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef squash_xml_to_text(elm, remove_namespaces=False):\n    leading_text = elm.text and elm.text or ''\n    result = [leading_text]\n\n    for child in elm.getchildren():\n        # Encoding is set to utf-8 because otherwise `\u00f3` would\n        # become `&#243;`\n        child_value = etree.tostring(child, encoding='utf-8')\n        # Decode to a string for later regexp and whitespace stripping\n        child_value = child_value.decode('utf-8')\n        result.append(child_value)\n\n    if remove_namespaces:\n        # Best way to remove the namespaces without having the parser complain\n        # about producing invalid XML.\n        result = [re.sub(' xmlns:?[^=]*=\"[^\"]*\"', '', v) for v in result]\n\n    # Join the results and strip any surrounding whitespace\n    result = u''.join(result).strip()\n    return result", "response": "Squash the given XML element as elm to a text containing XML."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nload a raw data - file and inspect it", "response": "def load(self, file_name):\n        \"\"\"Load a raw data-file\n\n        Args:\n            file_name (path)\n\n        Returns:\n            loaded test\n        \"\"\"\n\n        new_rundata = self.loader(file_name)\n        new_rundata = self.inspect(new_rundata)\n        return new_rundata"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef datetime2ole(dt):\n    delta = dt - OLE_TIME_ZERO\n    delta_float = delta / datetime.timedelta(days=1)  # trick from SO\n    return delta_float", "response": "converts from datetime object to ole datetime float"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_raw_limits():\n        raw_limits = dict()\n        raw_limits[\"current_hard\"] = 0.0000000000001\n        raw_limits[\"current_soft\"] = 0.00001\n        raw_limits[\"stable_current_hard\"] = 2.0\n        raw_limits[\"stable_current_soft\"] = 4.0\n        raw_limits[\"stable_voltage_hard\"] = 2.0\n        raw_limits[\"stable_voltage_soft\"] = 4.0\n        raw_limits[\"stable_charge_hard\"] = 2.0\n        raw_limits[\"stable_charge_soft\"] = 5.0\n        raw_limits[\"ir_change\"] = 0.00001\n        return raw_limits", "response": "Include the settings for how to decide what kind of\n        step you are examining here."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nload data from biologics. res files.", "response": "def loader(self, file_name, bad_steps=None, **kwargs):\n        \"\"\"Loads data from biologics .mpr files.\n\n        Args:\n            file_name (str): path to .res file.\n            bad_steps (list of tuples): (c, s) tuples of steps s\n             (in cycle c) to skip loading.\n\n        Returns:\n            new_tests (list of data objects)\n        \"\"\"\n        new_tests = []\n        if not os.path.isfile(file_name):\n            self.logger.info(\"Missing file_\\n   %s\" % file_name)\n            return None\n\n        filesize = os.path.getsize(file_name)\n        hfilesize = humanize_bytes(filesize)\n        txt = \"Filesize: %i (%s)\" % (filesize, hfilesize)\n        self.logger.debug(txt)\n\n        # creating temporary file and connection\n        temp_dir = tempfile.gettempdir()\n        temp_filename = os.path.join(temp_dir, os.path.basename(file_name))\n        shutil.copy2(file_name, temp_dir)\n\n        self.logger.debug(\"tmp file: %s\" % temp_filename)\n        self.logger.debug(\"HERE WE LOAD THE DATA\")\n\n        data = DataSet()\n        fid = FileID(file_name)\n\n        # div parameters and information (probably load this last)\n        test_no = 1\n        data.test_no = test_no\n        data.loaded_from = file_name\n\n        # some overall prms\n        data.channel_index = None\n        data.channel_number = None\n        data.creator = None\n        data.item_ID = None\n        data.schedule_file_name = None\n        data.start_datetime = None\n        data.test_ID = None\n        data.test_name = None\n        data.raw_data_files.append(fid)\n\n        # --------- read raw-data (normal-data) -------------------------\n        self.logger.debug(\"reading raw-data\")\n        self.mpr_data = None\n        self.mpr_log = None\n        self.mpr_settings = None\n\n        self._load_mpr_data(temp_filename, bad_steps)\n        length_of_test = self.mpr_data.shape[0]\n        self.logger.debug(f\"length of test: {length_of_test}\")\n\n        self.logger.debug(\"renaming columns\")\n        self._rename_headers()\n        # ---------  stats-data (summary-data) -------------------------\n        summary_df = self._create_summary_data()\n\n        if summary_df.empty:\n            txt = \"\\nCould not find any summary (stats-file)!\"\n            txt += \" (summary_df.empty = True)\"\n            txt += \"\\n -> issue make_summary(use_cellpy_stat_file=False)\"\n            warnings.warn(txt)\n\n        data.dfsummary = summary_df\n        data.dfdata = self.mpr_data\n\n        data.raw_data_files_length.append(length_of_test)\n        new_tests.append(data)\n\n        self._clean_up(temp_filename)\n        return new_tests"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ndumps data to csv", "response": "def csv_dumper(**kwargs):\n    \"\"\"dump data to csv\"\"\"\n    logging.info(\"dumping to csv\")\n    barn = kwargs[\"barn\"]\n    farms = kwargs[\"farms\"]\n    experiments = kwargs[\"experiments\"]\n    for experiment, farm in zip(experiments, farms):\n        name = experiment.journal.name\n        project = experiment.journal.project\n        project_dir, batch_dir, raw_dir = \\\n            experiment.journal.paginate()\n        if batch_dir is None:\n            logging.info(\"have to generate folder-name on the fly\")\n            out_data_dir, project_dir, batch_dir, raw_dir = \\\n                generate_folder_names(name, project)\n\n        if barn == \"batch_dir\":\n            out_dir = batch_dir\n        elif barn == \"project_dir\":\n            out_dir = project_dir\n        elif barn == \"raw_dir\":\n            out_dir = raw_dir\n        else:\n            out_dir = barn\n\n        for animal in farm:\n            file_name = os.path.join(\n                out_dir, \"summary_%s_%s.csv\" % (\n                    animal.name,\n                    name\n                )\n            )\n            logging.info(f\"> {file_name}\")\n            animal.to_csv(file_name, sep=prms.Reader.sep)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef ram_dumper(**kwargs):\n    logging.debug(\"trying to save stuff in memory\")\n    farms = kwargs[\"farms\"]\n    experiments = kwargs[\"experiments\"]\n    engine = kwargs[\"engine\"]\n\n    try:\n        engine_name = engine.__name__\n    except AttributeError:\n        engine_name = engine.__dict__.__name__\n\n    accepted_engines = [\"summary_engine\",]\n    if engine_name in accepted_engines:\n        logging.debug(\"found the engine that I will try to dump from: \"\n                      f\"{engine_name}\")\n\n        for experiment, farm in zip(experiments, farms):\n            name = experiment.journal.name\n            project = experiment.journal.project\n            experiment.memory_dumped[engine_name] = farm\n            logging.debug(f\"farm put into memory_dumped ({project}::{name})\")", "response": "Dump data to memory for later usage."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef screen_dumper(**kwargs):\n    farms = kwargs[\"farms\"]\n    engine = kwargs[\"engine\"]\n    logging.info(\"dumping to screen\")\n\n    print(f\"\\n[Screen dumper] ({engine})\")\n    try:\n        if len(farms) == 1:\n            print(f\"You have one farm with little pandas.\")\n\n        else:\n            print(f\"You have {len(farms)} farms with little pandas.\")\n    except TypeError:\n        print(\" - your farm has burned to the ground.\")\n    else:\n        for number, farm in enumerate(farms):\n            print(f\"[#{number+1}]You have {len(farm)} \"\n                  f\"little pandas in this farm.\")\n            for animal in farm:\n                print(80*\"=\")\n                try:\n                    print(animal.name)\n                except AttributeError:\n                    print(\"no-name\")\n                print(80*\"-\")\n                print(animal.head(5))\n                print()", "response": "Dump data to screen."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating more informative legends", "response": "def create_legend(info, c, option=\"clean\", use_index=False):\n    \"\"\"creating more informative legends\"\"\"\n\n    logging.debug(\"    - creating legends\")\n    mass, loading, label = info.loc[c, [\"masses\", \"loadings\", \"labels\"]]\n\n    if use_index or not label:\n        label = c.split(\"_\")\n        label = \"_\".join(label[1:])\n\n    if option == \"clean\":\n        return label\n\n    if option == \"mass\":\n        label = f\"{label} ({mass:.2f} mg)\"\n    elif option == \"loading\":\n        label = f\"{label} ({loading:.2f} mg/cm2)\"\n    elif option == \"all\":\n        label = f\"{label} ({mass:.2f} mg) ({loading:.2f} mg/cm2)\"\n\n    return label"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef create_plot_option_dicts(info, marker_types=None, colors=None,\n                             line_dash=None, size=None):\n    \"\"\"Create two dictionaries with plot-options.\n\n    The first iterates colors (based on group-number), the second iterates\n    through marker types.\n\n    Returns: group_styles (dict), sub_group_styles (dict)\n    \"\"\"\n\n    logging.debug(\"    - creating plot-options-dict (for bokeh)\")\n\n    # Current only works for bokeh\n\n    if marker_types is None:\n        marker_types = [\"circle\", \"square\", \"triangle\", \"invertedtriangle\",\n                        \"diamond\", \"cross\", \"asterix\"]\n\n    if line_dash is None:\n        line_dash = [0, 0]\n\n    if size is None:\n        size = 10\n\n    groups = info.groups.unique()\n    number_of_groups = len(groups)\n    if colors is None:\n        if number_of_groups < 4:\n            # print(\"using 3\")\n            colors = bokeh.palettes.brewer['YlGnBu'][3]\n        else:\n            # print(f\"using {min(9, number_of_groups)}\")\n            colors = bokeh.palettes.brewer['YlGnBu'][min(9, number_of_groups)]\n\n    sub_groups = info.sub_groups.unique()\n\n    marker_it = itertools.cycle(marker_types)\n    colors_it = itertools.cycle(colors)\n\n    group_styles = dict()\n    sub_group_styles = dict()\n\n    for j in groups:\n        color = next(colors_it)\n        marker_options = {\n            \"line_color\": color,\n            \"fill_color\": color,\n        }\n\n        line_options = {\n            \"line_color\": color,\n        }\n        group_styles[j] = {\n            \"marker\": marker_options,\n            \"line\": line_options,\n        }\n\n    for j in sub_groups:\n        marker_type = next(marker_it)\n        marker_options = {\n            \"marker\": marker_type,\n            \"size\": size,\n        }\n\n        line_options = {\n            \"line_dash\": line_dash,\n        }\n        sub_group_styles[j] = {\n            \"marker\": marker_options,\n            \"line\": line_options,\n        }\n    return group_styles, sub_group_styles", "response": "Create two dictionaries with plot - options."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating plots of summary data.", "response": "def summary_plotting_engine(**kwargs):\n    \"\"\"creates plots of summary data.\"\"\"\n\n    logging.debug(f\"Using {prms.Batch.backend} for plotting\")\n    experiments = kwargs[\"experiments\"]\n    farms = kwargs[\"farms\"]\n    barn = None\n\n    logging.debug(\"    - summary_plot_engine\")\n    farms = _preparing_data_and_plotting(\n        experiments=experiments,\n        farms=farms\n    )\n\n    return farms, barn"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef run_dumper(self, dumper):\n\n        logging.debug(\"start dumper::\")\n        dumper(\n            experiments=self.experiments,\n            farms=self.farms,\n            barn=self.barn,\n            engine=self.current_engine,\n        )\n        logging.debug(\"::dumper ended\")", "response": "run dumper once pr. engine"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a pandas. DataFrame containing the descriptor and hardware ID of each available COM port.", "response": "def _comports():\n    '''\n    Returns\n    -------\n    pandas.DataFrame\n        Table containing descriptor, and hardware ID of each available COM\n        port, indexed by port (e.g., \"COM4\").\n    '''\n    return (pd.DataFrame(list(map(list, serial.tools.list_ports.comports())),\n                         columns=['port', 'descriptor', 'hardware_id'])\n            .set_index('port'))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef comports(vid_pid=None, include_all=False, check_available=True,\n             only_available=False):\n    '''\n    .. versionchanged:: 0.9\n        Add :data:`check_available` keyword argument to optionally check if\n        each port is actually available by attempting to open a temporary\n        connection.\n\n        Add :data:`only_available` keyword argument to only include ports that\n        are actually available for connection.\n\n    Parameters\n    ----------\n    vid_pid : str or list, optional\n        One or more USB vendor/product IDs to match.\n\n        Each USB vendor/product must be in the form ``'<vid>:<pid>'``.\n        For example, ``'2341:0010'``.\n    include_all : bool, optional\n        If ``True``, include all available serial ports, but sort rows such\n        that ports matching specified USB vendor/product IDs come first.\n\n        If ``False``, only include ports that match specified USB\n        vendor/product IDs.\n    check_available : bool, optional\n        If ``True``, check if each port is actually available by attempting to\n        open a temporary connection.\n    only_available : bool, optional\n        If ``True``, only include ports that are available.\n\n    Returns\n    -------\n    pandas.DataFrame\n        Table containing descriptor and hardware ID of each COM port, indexed\n        by port (e.g., \"COM4\").\n\n        .. versionchanged:: 0.9\n            If :data:`check_available` is ``True``, add an ``available`` column\n            to the table indicating whether each port accepted a connection.\n    '''\n    df_comports = _comports()\n\n    # Extract USB product and vendor IDs from `hwid` entries of the form:\n    #\n    #     FTDIBUS\\VID_0403+PID_6001+A60081GEA\\0000\n    df_hwid = (df_comports.hardware_id.str.lower().str\n               .extract('vid_(?P<vid>[0-9a-f]+)\\+pid_(?P<pid>[0-9a-f]+)',\n                        expand=True))\n    # Extract USB product and vendor IDs from `hwid` entries of the form:\n    #\n    #     USB VID:PID=16C0:0483 SNR=2145930\n    no_id_mask = df_hwid.vid.isnull()\n    df_hwid.loc[no_id_mask] = (df_comports.loc[no_id_mask, 'hardware_id']\n                               .str.lower().str\n                               .extract('vid:pid=(?P<vid>[0-9a-f]+):'\n                                        '(?P<pid>[0-9a-f]+)', expand=True))\n    df_comports = df_comports.join(df_hwid)\n\n    if vid_pid is not None:\n        if isinstance(vid_pid, six.string_types):\n            # Single USB vendor/product ID specified.\n            vid_pid = [vid_pid]\n\n        # Mark ports that match specified USB vendor/product IDs.\n        df_comports['include'] = (df_comports.vid + ':' +\n                                  df_comports.pid).isin(map(str.lower,\n                                                            vid_pid))\n\n        if include_all:\n            # All ports should be included, but sort rows such that ports\n            # matching specified USB vendor/product IDs come first.\n            df_comports = (df_comports.sort_values('include', ascending=False)\n                           .drop('include', axis=1))\n        else:\n            # Only include ports that match specified USB vendor/product IDs.\n            df_comports = (df_comports.loc[df_comports.include]\n                           .drop('include', axis=1))\n\n    if check_available or only_available:\n        # Add `available` column indicating whether each port accepted a\n        # connection.  A port may not, for example, accept a connection if the\n        # port is already open.\n        available = []\n\n        for name_i, port_info_i in df_comports.iterrows():\n            try:\n                connection = serial.Serial(port=name_i)\n                connection.close()\n                available.append(True)\n            except serial.SerialException:\n                available.append(False)\n        df_comports['available'] = available\n        if only_available:\n            df_comports = df_comports.loc[df_comports.available]\n        if not check_available:\n            del df_comports['available']\n    return df_comports", "response": "Return a table containing the descriptor and hardware ID of each COM port."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the serial ports available on Windows.", "response": "def _get_serial_ports_windows():\n    '''\n    Uses the Win32 registry to return a iterator of serial (COM) ports existing\n    on this computer.\n\n    See http://stackoverflow.com/questions/1205383/listing-serial-com-ports-on-windows\n    '''\n    import six.moves.winreg as winreg\n\n    reg_path = 'HARDWARE\\\\DEVICEMAP\\\\SERIALCOMM'\n    try:\n        key = winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, reg_path)\n    except WindowsError:\n        # No serial ports. Return empty generator.\n        return\n\n    for i in itertools.count():\n        try:\n            val = winreg.EnumValue(key, i)\n            yield str(val[1])\n        except EnvironmentError:\n            break"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_port(self, baud_rate):\n        '''\n        Using the specified baud-rate, attempt to connect to each available\n        serial port.  If the `test_connection()` method returns `True` for a\n        port, update the `port` attribute and return the port.\n\n        In the case where the `test_connection()` does not return `True` for\n        any of the evaluated ports, raise a `ConnectionError`.\n        '''\n        self.port = None\n\n        for test_port in get_serial_ports():\n            if self.test_connection(test_port, baud_rate):\n                self.port = test_port\n                break\n            sleep(0.1)\n\n        if self.port is None:\n            raise ConnectionError('Could not connect to serial device.')\n\n        return self.port", "response": "Attempts to connect to each available ArcGIS serial port. If the test_connection method returns True for the port and update the port attribute. If the test_connection method returns False for the port and raise a ConnectionError."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreads the yml file", "response": "def _read(name):\n    \"\"\"read the yml file\"\"\"\n    logging.debug(\"Reading config-file: %s\" % name)\n    try:\n        with open(name, \"r\") as config_file:\n            prm_dict = yaml.load(config_file)\n    except yaml.YAMLError:\n        raise yaml.YAMLErrorr\n    else:\n        return prm_dict"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef simple_db_engine(reader=None, srnos=None):\n\n    if reader is None:\n        reader = dbreader.Reader()\n        logger.debug(\"No reader provided. Creating one myself.\")\n\n    info_dict = dict()\n    info_dict[\"filenames\"] = [reader.get_cell_name(srno) for srno in srnos]\n    info_dict[\"masses\"] = [reader.get_mass(srno) for srno in srnos]\n    info_dict[\"total_masses\"] = [reader.get_total_mass(srno) for srno in srnos]\n    info_dict[\"loadings\"] = [reader.get_loading(srno) for srno in srnos]\n    info_dict[\"fixed\"] = [reader.inspect_hd5f_fixed(srno) for srno in srnos]\n    info_dict[\"labels\"] = [reader.get_label(srno) for srno in srnos]\n    info_dict[\"cell_type\"] = [reader.get_cell_type(srno) for srno in srnos]\n    info_dict[\"raw_file_names\"] = []\n    info_dict[\"cellpy_file_names\"] = []\n\n    logger.debug(\"created info-dict\")\n\n    for key in list(info_dict.keys()):\n        logger.debug(\"%s: %s\" % (key, str(info_dict[key])))\n\n    _groups = [reader.get_group(srno) for srno in srnos]\n    logger.debug(\">\\ngroups: %s\" % str(_groups))\n    groups = helper.fix_groups(_groups)\n    info_dict[\"groups\"] = groups\n\n    my_timer_start = time.time()\n    filename_cache = []\n    info_dict = helper.find_files(info_dict, filename_cache)\n    my_timer_end = time.time()\n    if (my_timer_end - my_timer_start) > 5.0:\n        logger.info(\n            \"The function _find_files was very slow. \"\n            \"Save your info_df so you don't have to run it again!\"\n        )\n\n    info_df = pd.DataFrame(info_dict)\n    info_df = info_df.sort_values([\"groups\", \"filenames\"])\n    info_df = helper.make_unique_groups(info_df)\n\n    info_df[\"labels\"] = info_df[\"filenames\"].apply(helper.create_labels)\n    info_df.set_index(\"filenames\", inplace=True)\n    return info_df", "response": "engine that gets values from the simple excel db"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\noverrides set and clear methods on event to call specified callback function after performing default behaviour.", "response": "def orify(event, changed_callback):\n    '''\n    Override ``set`` and ``clear`` methods on event to call specified callback\n    function after performing default behaviour.\n\n    Parameters\n    ----------\n\n    '''\n    event.changed = changed_callback\n    if not hasattr(event, '_set'):\n        # `set`/`clear` methods have not been overridden on event yet.\n        # Override methods to call `changed_callback` after performing default\n        # action.\n        event._set = event.set\n        event._clear = event.clear\n        event.set = lambda: or_set(event)\n        event.clear = lambda: or_clear(event)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a new event that is set when any of the specified events have been set.", "response": "def OrEvent(*events):\n    '''\n    Parameters\n    ----------\n    events : list(threading.Event)\n        List of events.\n\n    Returns\n    -------\n    threading.Event\n        Event that is set when **at least one** of the events in :data:`events`\n        is set.\n    '''\n    or_event = threading.Event()\n\n    def changed():\n        '''\n        Set ``or_event`` if any of the specified events have been set.\n        '''\n        bools = [event_i.is_set() for event_i in events]\n        if any(bools):\n            or_event.set()\n        else:\n            or_event.clear()\n    for event_i in events:\n        # Override ``set`` and ``clear`` methods on event to update state of\n        # `or_event` after performing default behaviour.\n        orify(event_i, changed)\n\n    # Set initial state of `or_event`.\n    changed()\n    return or_event"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef request(device, response_queue, payload, timeout_s=None, poll=POLL_QUEUES):\n    '''\n    Send payload to serial device and wait for response.\n\n    Parameters\n    ----------\n    device : serial.Serial\n        Serial instance.\n    response_queue : Queue.Queue\n        Queue to wait for response on.\n    payload : str or bytes\n        Payload to send.\n    timeout_s : float, optional\n        Maximum time to wait (in seconds) for response.\n\n        By default, block until response is ready.\n    poll : bool, optional\n        If ``True``, poll response queue in a busy loop until response is\n        ready (or timeout occurs).\n\n        Polling is much more processor intensive, but (at least on Windows)\n        results in faster response processing.  On Windows, polling is\n        enabled by default.\n    '''\n    device.write(payload)\n    if poll:\n        # Polling enabled.  Wait for response in busy loop.\n        start = dt.datetime.now()\n        while not response_queue.qsize():\n            if (dt.datetime.now() - start).total_seconds() > timeout_s:\n                raise queue.Empty('No response received.')\n        return response_queue.get()\n    else:\n        # Polling disabled.  Use blocking `Queue.get()` method to wait for\n        # response.\n        return response_queue.get(timeout=timeout_s)", "response": "Send payload to serial device and wait for response."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef connection_made(self, transport):\n        self.port = transport.serial.port\n        logger.debug('connection_made: `%s` `%s`', self.port, transport)\n        self.transport = transport\n        self.connected.set()\n        self.disconnected.clear()", "response": "Called when the connection is made"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef connection_lost(self, exception):\n        if isinstance(exception, Exception):\n            logger.debug('Connection to port `%s` lost: %s', self.port,\n                         exception)\n        else:\n            logger.debug('Connection to port `%s` closed', self.port)\n        self.connected.clear()\n        self.disconnected.set()", "response": "Called when the serial port is closed or the reader loop terminated."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nwriting data to the serial port.", "response": "def write(self, data, timeout_s=None):\n        '''\n        Write to serial port.\n\n        Waits for serial connection to be established before writing.\n\n        Parameters\n        ----------\n        data : str or bytes\n            Data to write to serial port.\n        timeout_s : float, optional\n            Maximum number of seconds to wait for serial connection to be\n            established.\n\n            By default, block until serial connection is ready.\n        '''\n        self.connected.wait(timeout_s)\n        self.protocol.transport.write(data)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef request(self, response_queue, payload, timeout_s=None,\n                poll=POLL_QUEUES):\n        '''\n        Send\n\n        Parameters\n        ----------\n        device : serial.Serial\n            Serial instance.\n        response_queue : Queue.Queue\n            Queue to wait for response on.\n        payload : str or bytes\n            Payload to send.\n        timeout_s : float, optional\n            Maximum time to wait (in seconds) for response.\n\n            By default, block until response is ready.\n        poll : bool, optional\n            If ``True``, poll response queue in a busy loop until response is\n            ready (or timeout occurs).\n\n            Polling is much more processor intensive, but (at least on Windows)\n            results in faster response processing.  On Windows, polling is\n            enabled by default.\n        '''\n        self.connected.wait(timeout_s)\n        return request(self, response_queue, payload, timeout_s=timeout_s,\n                       poll=poll)", "response": "Sends a message to the specified device."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nconvert a column header from the MPT file into a tuple of canonical name and numpy dtype", "response": "def fieldname_to_dtype(fieldname):\n    \"\"\"Converts a column header from the MPT file into a tuple of\n    canonical name and appropriate numpy dtype\"\"\"\n\n    if fieldname == 'mode':\n        return ('mode', np.uint8)\n    elif fieldname in (\"ox/red\", \"error\", \"control changes\", \"Ns changes\",\n                       \"counter inc.\"):\n        return (fieldname, np.bool_)\n    elif fieldname in (\"time/s\", \"P/W\", \"(Q-Qo)/mA.h\", \"x\", \"control/V\",\n                       \"control/V/mA\", \"(Q-Qo)/C\", \"dQ/C\", \"freq/Hz\",\n                       \"|Ewe|/V\", \"|I|/A\", \"Phase(Z)/deg\", \"|Z|/Ohm\",\n                       \"Re(Z)/Ohm\", \"-Im(Z)/Ohm\"):\n        return (fieldname, np.float_)\n    elif fieldname in (\"cycle number\", \"I Range\", \"Ns\", \"half cycle\"):\n        return (fieldname, np.int_)\n    elif fieldname in (\"dq/mA.h\", \"dQ/mA.h\"):\n        return (\"dQ/mA.h\", np.float_)\n    elif fieldname in (\"I/mA\", \"<I>/mA\"):\n        return (\"I/mA\", np.float_)\n    elif fieldname in (\"Ewe/V\", \"<Ewe>/V\"):\n        return (\"Ewe/V\", np.float_)\n    else:\n        raise ValueError(\"Invalid column header: %s\" % fieldname)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef comma_converter(float_string):\n    trans_table = maketrans(b',', b'.')\n    return float(float_string.translate(trans_table))", "response": "Convert numbers to floats whether the decimal point is. or."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef MPTfile(file_or_path):\n\n    if isinstance(file_or_path, str):\n        mpt_file = open(file_or_path, 'rb')\n    else:\n        mpt_file = file_or_path\n\n    magic = next(mpt_file)\n    if magic != b'EC-Lab ASCII FILE\\r\\n':\n        raise ValueError(\"Bad first line for EC-Lab file: '%s'\" % magic)\n\n    nb_headers_match = re.match(b'Nb header lines : (\\d+)\\s*$', next(mpt_file))\n    nb_headers = int(nb_headers_match.group(1))\n    if nb_headers < 3:\n        raise ValueError(\"Too few header lines: %d\" % nb_headers)\n\n    ## The 'magic number' line, the 'Nb headers' line and the column headers\n    ## make three lines. Every additional line is a comment line.\n    comments = [next(mpt_file) for i in range(nb_headers - 3)]\n\n    fieldnames = str3(next(mpt_file)).strip().split('\\t')\n    record_type = np.dtype(list(map(fieldname_to_dtype, fieldnames)))\n\n    ## Must be able to parse files where commas are used for decimal points\n    converter_dict = dict(((i, comma_converter)\n                           for i in range(len(fieldnames))))\n    mpt_array = np.loadtxt(mpt_file, dtype=record_type,\n                           converters=converter_dict)\n\n    return mpt_array, comments", "response": "Opens. mpt files as numpy record arrays and returns a numpy record array object and a list of comments"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nread in the VMP module headers in the VMPmodule_hdr format. Yields a dict with the headers and offset for each module.", "response": "def read_VMP_modules(fileobj, read_module_data=True):\n    \"\"\"Reads in module headers in the VMPmodule_hdr format. Yields a dict with\n    the headers and offset for each module.\n\n    N.B. the offset yielded is the offset to the start of the data i.e. after\n    the end of the header. The data runs from (offset) to (offset+length)\"\"\"\n    while True:\n        module_magic = fileobj.read(len(b'MODULE'))\n        if len(module_magic) == 0:  # end of file\n            raise StopIteration\n        elif module_magic != b'MODULE':\n            raise ValueError(\n                \"Found %r, expecting start of new VMP MODULE\" % module_magic)\n\n        hdr_bytes = fileobj.read(VMPmodule_hdr.itemsize)\n        if len(hdr_bytes) < VMPmodule_hdr.itemsize:\n            raise IOError(\"Unexpected end of file while reading module header\")\n\n        hdr = np.fromstring(hdr_bytes, dtype=VMPmodule_hdr, count=1)\n        hdr_dict = dict(((n, hdr[n][0]) for n in VMPmodule_hdr.names))\n        print(\"---hdr-dict---\")\n        pprint(hdr_dict)\n        hdr_dict['offset'] = fileobj.tell()\n        if read_module_data:\n            hdr_dict['data'] = fileobj.read(hdr_dict['length'])\n            if len(hdr_dict['data']) != hdr_dict['length']:\n                raise IOError(\"\"\"Unexpected end of file while reading data\n                    current module: %s\n                    length read: %d\n                    length expected: %d\"\"\" % (hdr_dict['longname'],\n                                              len(hdr_dict['data']),\n                                              hdr_dict['length']))\n            yield hdr_dict\n        else:\n            yield hdr_dict\n            fileobj.seek(hdr_dict['offset'] + hdr_dict['length'], SEEK_SET)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_headers_global():\n        headers = dict()\n        # - global column headings (specific for Arbin)\n        headers[\"applications_path_txt\"] = 'Applications_Path'\n        headers[\"channel_index_txt\"] = 'Channel_Index'\n        headers[\"channel_number_txt\"] = 'Channel_Number'\n        headers[\"channel_type_txt\"] = 'Channel_Type'\n        headers[\"comments_txt\"] = 'Comments'\n        headers[\"creator_txt\"] = 'Creator'\n        headers[\"daq_index_txt\"] = 'DAQ_Index'\n        headers[\"item_id_txt\"] = 'Item_ID'\n        headers[\"log_aux_data_flag_txt\"] = 'Log_Aux_Data_Flag'\n        headers[\"log_chanstat_data_flag_txt\"] = 'Log_ChanStat_Data_Flag'\n        headers[\"log_event_data_flag_txt\"] = 'Log_Event_Data_Flag'\n        headers[\"log_smart_battery_data_flag_txt\"] = 'Log_Smart_Battery_Data_Flag'\n        headers[\"mapped_aux_conc_cnumber_txt\"] = 'Mapped_Aux_Conc_CNumber'\n        headers[\"mapped_aux_di_cnumber_txt\"] = 'Mapped_Aux_DI_CNumber'\n        headers[\"mapped_aux_do_cnumber_txt\"] = 'Mapped_Aux_DO_CNumber'\n        headers[\"mapped_aux_flow_rate_cnumber_txt\"] = 'Mapped_Aux_Flow_Rate_CNumber'\n        headers[\"mapped_aux_ph_number_txt\"] = 'Mapped_Aux_PH_Number'\n        headers[\"mapped_aux_pressure_number_txt\"] = 'Mapped_Aux_Pressure_Number'\n        headers[\"mapped_aux_temperature_number_txt\"] = 'Mapped_Aux_Temperature_Number'\n        headers[\"mapped_aux_voltage_number_txt\"] = 'Mapped_Aux_Voltage_Number'\n        headers[\"schedule_file_name_txt\"] = 'Schedule_File_Name'  # KEEP FOR CELLPY FILE FORMAT\n        headers[\"start_datetime_txt\"] = 'Start_DateTime'\n        headers[\"test_id_txt\"] = 'Test_ID'  # KEEP FOR CELLPY FILE FORMAT\n        headers[\"test_name_txt\"] = 'Test_Name'  # KEEP FOR CELLPY FILE FORMAT\n        return headers", "response": "Defines the so - called global column headings for Arbin. res - files"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ninspect the file - > reports to log ( debug", "response": "def inspect(self, run_data):\n        \"\"\"Inspect the file -> reports to log (debug)\"\"\"\n\n        # TODO: type checking\n        if DEBUG_MODE:\n            checked_rundata = []\n            for data in run_data:\n                new_cols = data.dfdata.columns\n                for col in self.headers_normal:\n                    if col not in new_cols:\n                        logging.debug(f\"Missing col: {col}\")\n                        # data.dfdata[col] = np.nan\n                checked_rundata.append(data)\n        else:\n            checked_rundata = run_data\n\n        return checked_rundata"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _iterdump(self, file_name, headers=None):\n        if headers is None:\n            headers = [\"Discharge_Capacity\", \"Charge_Capacity\"]\n\n        step_txt = self.headers_normal['step_index_txt']\n        point_txt = self.headers_normal['data_point_txt']\n        cycle_txt = self.headers_normal['cycle_index_txt']\n\n        self.logger.debug(\"iterating through file: %s\" % file_name)\n        if not os.path.isfile(file_name):\n            print(\"Missing file_\\n   %s\" % file_name)\n\n        filesize = os.path.getsize(file_name)\n        hfilesize = humanize_bytes(filesize)\n        txt = \"Filesize: %i (%s)\" % (filesize, hfilesize)\n        self.logger.info(txt)\n\n        table_name_global = TABLE_NAMES[\"global\"]\n        table_name_stats = TABLE_NAMES[\"statistic\"]\n        table_name_normal = TABLE_NAMES[\"normal\"]\n\n        # creating temporary file and connection\n\n        temp_dir = tempfile.gettempdir()\n        temp_filename = os.path.join(temp_dir, os.path.basename(file_name))\n        shutil.copy2(file_name, temp_dir)\n        constr = self.__get_res_connector(temp_filename)\n\n        if use_ado:\n            conn = dbloader.connect(constr)\n        else:\n            conn = dbloader.connect(constr, autocommit=True)\n\n        self.logger.debug(\"tmp file: %s\" % temp_filename)\n        self.logger.debug(\"constr str: %s\" % constr)\n\n        # --------- read global-data ------------------------------------\n        self.logger.debug(\"reading global data table\")\n        sql = \"select * from %s\" % table_name_global\n        global_data_df = pd.read_sql_query(sql, conn)\n        # col_names = list(global_data_df.columns.values)\n        self.logger.debug(\"sql statement: %s\" % sql)\n\n        tests = global_data_df[self.headers_normal['test_id_txt']]\n        number_of_sets = len(tests)\n        self.logger.debug(\"number of datasets: %i\" % number_of_sets)\n        self.logger.debug(\"only selecting first test\")\n        test_no = 0\n        self.logger.debug(\"setting data for test number %i\" % test_no)\n        loaded_from = file_name\n        # fid = FileID(file_name)\n        start_datetime = global_data_df[self.headers_global['start_datetime_txt']][test_no]\n        test_ID = int(global_data_df[self.headers_normal['test_id_txt']][test_no])  # OBS\n        test_name = global_data_df[self.headers_global['test_name_txt']][test_no]\n\n        # --------- read raw-data (normal-data) -------------------------\n        self.logger.debug(\"reading raw-data\")\n\n        columns = [\"Data_Point\", \"Step_Index\", \"Cycle_Index\"]\n        columns.extend(headers)\n        columns_txt = \", \".join([\"%s\"] * len(columns)) % tuple(columns)\n\n        sql_1 = \"select %s \" % columns_txt\n        sql_2 = \"from %s \" % table_name_normal\n        sql_3 = \"where %s=%s \" % (self.headers_normal['test_id_txt'], test_ID)\n        sql_5 = \"order by %s\" % self.headers_normal['data_point_txt']\n        import time\n        info_list = []\n        info_header = [\"cycle\", \"row_count\", \"start_point\", \"end_point\"]\n        info_header.extend(headers)\n        self.logger.info(\" \".join(info_header))\n        self.logger.info(\"-------------------------------------------------\")\n\n        for cycle_number in range(1, 2000):\n            t1 = time.time()\n            self.logger.debug(\"picking cycle %i\" % cycle_number)\n            sql_4 = \"AND %s=%i \" % (cycle_txt, cycle_number)\n            sql = sql_1 + sql_2 + sql_3 + sql_4 + sql_5\n            self.logger.debug(\"sql statement: %s\" % sql)\n            normal_df = pd.read_sql_query(sql, conn)\n            t2 = time.time()\n            dt = t2 - t1\n            self.logger.debug(\"time: %f\" % dt)\n            if normal_df.empty:\n                self.logger.debug(\"reached the end\")\n                break\n            row_count, _ = normal_df.shape\n            start_point = normal_df[point_txt].min()\n            end_point = normal_df[point_txt].max()\n            last = normal_df.iloc[-1, :]\n\n            step_list = [cycle_number, row_count, start_point, end_point]\n            step_list.extend([last[x] for x in headers])\n            info_list.append(step_list)\n\n        self._clean_up_loadres(None, conn, temp_filename)\n        info_dict = pd.DataFrame(info_list, columns=info_header)\n        return info_dict", "response": "Function for dumping values from a file."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nloading data from arbin. res files.", "response": "def loader(self, file_name, bad_steps=None, **kwargs):\n        \"\"\"Loads data from arbin .res files.\n\n        Args:\n            file_name (str): path to .res file.\n            bad_steps (list of tuples): (c, s) tuples of steps s (in cycle c) to skip loading.\n\n        Returns:\n            new_tests (list of data objects)\n        \"\"\"\n        # TODO: @jepe - insert kwargs - current chunk, only normal data, etc\n\n        new_tests = []\n        if not os.path.isfile(file_name):\n            self.logger.info(\"Missing file_\\n   %s\" % file_name)\n            return None\n\n        self.logger.debug(\"in loader\")\n        self.logger.debug(\"filename: %s\" % file_name)\n\n        filesize = os.path.getsize(file_name)\n        hfilesize = humanize_bytes(filesize)\n        txt = \"Filesize: %i (%s)\" % (filesize, hfilesize)\n        self.logger.debug(txt)\n        if filesize > prms.Instruments[\"max_res_filesize\"] and not prms.Reader[\"load_only_summary\"]:\n            error_message = \"\\nERROR (loader):\\n\"\n            error_message += \"%s > %s - File is too big!\\n\" % (\n                hfilesize, humanize_bytes(prms.Instruments[\"max_res_filesize\"]))\n            error_message += \"(edit prms.Instruments['max_res_filesize'])\\n\"\n            print(error_message)\n            return None\n\n        table_name_global = TABLE_NAMES[\"global\"]\n        table_name_stats = TABLE_NAMES[\"statistic\"]\n        table_name_normal = TABLE_NAMES[\"normal\"]\n\n        # creating temporary file and connection\n\n        temp_dir = tempfile.gettempdir()\n        temp_filename = os.path.join(temp_dir, os.path.basename(file_name))\n        shutil.copy2(file_name, temp_dir)\n        self.logger.debug(\"tmp file: %s\" % temp_filename)\n\n        use_mdbtools = False\n        if use_subprocess:\n            use_mdbtools = True\n        if is_posix:\n            use_mdbtools = True\n\n        # windows with same python bit as windows bit (the ideal case)\n        if not use_mdbtools:\n            constr = self.__get_res_connector(temp_filename)\n\n            if use_ado:\n                conn = dbloader.connect(constr)\n            else:\n                conn = dbloader.connect(constr, autocommit=True)\n            self.logger.debug(\"constr str: %s\" % constr)\n\n            self.logger.debug(\"reading global data table\")\n            sql = \"select * from %s\" % table_name_global\n            self.logger.debug(\"sql statement: %s\" % sql)\n            global_data_df = pd.read_sql_query(sql, conn)\n            # col_names = list(global_data_df.columns.values)\n\n        else:\n            import subprocess\n            if is_posix:\n                if is_macos:\n                    self.logger.debug(\"\\nMAC OSX USING MDBTOOLS\")\n                else:\n                    self.logger.debug(\"\\nPOSIX USING MDBTOOLS\")\n            else:\n                self.logger.debug(\"\\nWINDOWS USING MDBTOOLS-WIN\")\n\n            # creating tmp-filenames\n            temp_csv_filename_global = os.path.join(temp_dir, \"global_tmp.csv\")\n            temp_csv_filename_normal = os.path.join(temp_dir, \"normal_tmp.csv\")\n            temp_csv_filename_stats = os.path.join(temp_dir, \"stats_tmp.csv\")\n\n            # making the cmds\n            mdb_prms = [(table_name_global, temp_csv_filename_global), (table_name_normal, temp_csv_filename_normal),\n                        (table_name_stats, temp_csv_filename_stats)]\n\n            # executing cmds\n            for table_name, tmp_file in mdb_prms:\n                with open(tmp_file, \"w\") as f:\n                    subprocess.call([sub_process_path, temp_filename, table_name], stdout=f)\n                    self.logger.debug(f\"ran mdb-export {str(f)} {table_name}\")\n\n            # use pandas to load in the data\n            global_data_df = pd.read_csv(temp_csv_filename_global)\n\n        tests = global_data_df[self.headers_normal['test_id_txt']]  # OBS\n        number_of_sets = len(tests)\n        self.logger.debug(\"number of datasets: %i\" % number_of_sets)\n\n        for counter, test_no in enumerate(range(number_of_sets)):\n            if counter > 0:\n                self.logger.warning(\"***MULTITEST-FILE (not recommended)\")\n                if not ALLOW_MULTI_TEST_FILE:\n                    break\n            data = DataSet()\n            data.test_no = test_no\n            data.loaded_from = file_name\n            fid = FileID(file_name)\n            # data.parent_filename = os.path.basename(file_name)# name of the .res file it is loaded from\n            data.channel_index = int(global_data_df[self.headers_global['channel_index_txt']][test_no])\n            data.channel_number = int(global_data_df[self.headers_global['channel_number_txt']][test_no])\n            data.creator = global_data_df[self.headers_global['creator_txt']][test_no]\n            data.item_ID = global_data_df[self.headers_global['item_id_txt']][test_no]\n            data.schedule_file_name = global_data_df[self.headers_global['schedule_file_name_txt']][test_no]\n            data.start_datetime = global_data_df[self.headers_global['start_datetime_txt']][test_no]\n            data.test_ID = int(global_data_df[self.headers_normal['test_id_txt']][test_no])  # OBS\n            data.test_name = global_data_df[self.headers_global['test_name_txt']][test_no]\n            data.raw_data_files.append(fid)\n\n            self.logger.debug(\"reading raw-data\")\n            if not use_mdbtools:\n                # --------- read raw-data (normal-data) -------------------------\n                length_of_test, normal_df = self._load_res_normal_table(conn, data.test_ID, bad_steps)\n                # --------- read stats-data (summary-data) ----------------------\n                sql = \"select * from %s where %s=%s order by %s\" % (table_name_stats,\n                                                                    self.headers_normal['test_id_txt'],\n                                                                    data.test_ID,\n                                                                    self.headers_normal['data_point_txt'])\n                summary_df = pd.read_sql_query(sql, conn)\n                if counter > number_of_sets:\n                    self._clean_up_loadres(None, conn, temp_filename)\n            else:\n                normal_df = pd.read_csv(temp_csv_filename_normal)\n                # filter on test ID\n                normal_df = normal_df[normal_df[self.headers_normal['test_id_txt']] == data.test_ID]\n                # sort on data point\n                if prms._sort_if_subprocess:\n                    normal_df = normal_df.sort_values(self.headers_normal['data_point_txt'])\n                length_of_test = normal_df.shape[0]\n                summary_df = pd.read_csv(temp_csv_filename_stats)\n                # clean up\n                for f in [temp_filename, temp_csv_filename_stats, temp_csv_filename_normal,\n                          temp_csv_filename_global]:\n                    if os.path.isfile(f):\n                        try:\n                            os.remove(f)\n                        except WindowsError as e:\n                            self.logger.warning(\n                                f\"could not remove tmp-file\\n{f} {e}\"\n                            )\n\n            if summary_df.empty and prms.Reader.use_cellpy_stat_file:\n                txt = \"\\nCould not find any summary (stats-file)!\"\n                txt += \"\\n -> issue make_summary(use_cellpy_stat_file=False)\"\n                logging.debug(txt)\n            # normal_df = normal_df.set_index(\"Data_Point\")\n            data.dfsummary = summary_df\n            data.dfdata = normal_df\n            data.raw_data_files_length.append(length_of_test)\n            new_tests.append(data)\n        return new_tests"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef make_df_from_batch(batch_name, batch_col=\"b01\", reader=None, reader_label=None):\n\n    batch_name = batch_name\n    batch_col = batch_col\n    logger.debug(f\"batch_name, batch_col: {batch_name}, {batch_col}\")\n    if reader is None:\n        reader_obj = get_db_reader(reader_label)\n        reader = reader_obj()\n\n    srnos = reader.select_batch(batch_name, batch_col)\n    logger.debug(\"srnos:\" + str(srnos))\n    info_dict = _create_info_dict(reader, srnos)\n    info_df = pd.DataFrame(info_dict)\n    info_df = info_df.sort_values([\"groups\", \"filenames\"])\n    info_df = _make_unique_groups(info_df)\n    info_df[\"labels\"] = info_df[\"filenames\"].apply(create_labels)\n    info_df.set_index(\"filenames\", inplace=True)\n\n    return info_df", "response": "Create a pandas DataFrame with the info needed for load\n            the runs."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreading and saves cellpy data from the given pandas. DataFrame.", "response": "def read_and_save_data(info_df, raw_dir, sep=\";\", force_raw=False,\n                       force_cellpy=False,\n                       export_cycles=False, shifted_cycles=False,\n                       export_raw=True,\n                       export_ica=False, save=True, use_cellpy_stat_file=False,\n                       parent_level=\"CellpyData\",\n                       last_cycle=None,\n                       ):\n    \"\"\"Reads and saves cell data defined by the info-DataFrame.\n\n    The function iterates through the ``info_df`` and loads data from the runs.\n    It saves individual data for each run (if selected), as well as returns a\n    list of ``cellpy`` summary DataFrames, a list of the indexes (one for each\n    run; same as used as index in the ``info_df``), as well as a list with\n    indexes of runs (cells) where an error was encountered during loading.\n\n    Args:\n        use_cellpy_stat_file: use the stat file to perform the calculations.\n        info_df: pandas.DataFrame with information about the runs.\n        raw_dir: path to location where you want to save raw data.\n        sep: delimiter to use when exporting to csv.\n        force_raw: load raw data even-though cellpy-file is up-to-date.\n        force_cellpy: load cellpy files even-though cellpy-file is not\n            up-to-date.\n        export_cycles: set to True for exporting cycles to csv.\n        shifted_cycles: set to True for exporting the cycles with a cumulated\n            shift.\n        export_raw: set to True for exporting raw data to csv.\n        export_ica: set to True for calculating and exporting dQ/dV to csv.\n        save: set to False to prevent saving a cellpy-file.\n        parent_level: optional, should use \"cellpydata\" for older hdf5-files and\n            default for newer ones.\n\n    Returns: frames (list of cellpy summary DataFrames), keys (list of indexes),\n        errors (list of indexes that encountered errors).\n    \"\"\"\n    no_export = False\n    do_export_dqdv = export_ica\n    keys = []\n    frames = []\n    number_of_runs = len(info_df)\n    counter = 0\n    errors = []\n\n    for indx, row in info_df.iterrows():\n        counter += 1\n        h_txt = \"[\" + counter * \"|\" + (number_of_runs - counter) * \".\" + \"]\"\n        l_txt = \"starting to process file # %i (index=%s)\" % (counter, indx)\n        logger.debug(l_txt)\n        print(h_txt)\n        if not row.raw_file_names and not force_cellpy:\n            logger.info(\"File(s) not found!\")\n            logger.info(indx)\n            logger.debug(\"File(s) not found for index=%s\" % indx)\n            errors.append(indx)\n            continue\n        else:\n            logger.info(f\"Processing {indx}\")\n        cell_data = cellreader.CellpyData()\n        if not force_cellpy:\n            logger.info(\"setting cycle mode (%s)...\" % row.cell_type)\n            cell_data.set_cycle_mode(row.cell_type)\n\n        logger.info(\"loading cell\")\n        if not force_cellpy:\n            logger.info(\"not forcing\")\n            try:\n                cell_data.loadcell(raw_files=row.raw_file_names,\n                                   cellpy_file=row.cellpy_file_names,\n                                   mass=row.masses, summary_on_raw=True,\n                                   force_raw=force_raw,\n                                   use_cellpy_stat_file=use_cellpy_stat_file)\n            except Exception as e:\n                logger.debug('Failed to load: ' + str(e))\n                errors.append(\"loadcell:\" + str(indx))\n                continue\n        else:\n            logger.info(\"forcing\")\n            try:\n                cell_data.load(row.cellpy_file_names, parent_level=parent_level)\n            except Exception as e:\n                logger.info(f\"Critical exception encountered {type(e)} \"\n                            \"- skipping this file\")\n                logger.debug('Failed to load. Error-message: ' + str(e))\n                errors.append(\"load:\" + str(indx))\n                continue\n\n        if not cell_data.check():\n            logger.info(\"...not loaded...\")\n            logger.debug(\"Did not pass check(). Could not load cell!\")\n            errors.append(\"check:\" + str(indx))\n            continue\n\n        logger.info(\"...loaded successfully...\")\n        keys.append(indx)\n\n        summary_tmp = cell_data.dataset.dfsummary\n        logger.info(\"Trying to get summary_data\")\n        if summary_tmp is None:\n            logger.info(\"No existing summary made - running make_summary\")\n            cell_data.make_summary(find_end_voltage=True, find_ir=True)\n\n        if summary_tmp.index.name == b\"Cycle_Index\":\n            logger.debug(\"Strange: 'Cycle_Index' is a byte-string\")\n            summary_tmp.index.name = 'Cycle_Index'\n\n        if not summary_tmp.index.name == \"Cycle_Index\":\n            logger.debug(\"Setting index to Cycle_Index\")\n            # check if it is a byte-string\n            if b\"Cycle_Index\" in summary_tmp.columns:\n                logger.debug(\"Seems to be a byte-string in the column-headers\")\n                summary_tmp.rename(columns={b\"Cycle_Index\": 'Cycle_Index'},\n                                   inplace=True)\n            summary_tmp.set_index(\"Cycle_Index\", inplace=True)\n\n        frames.append(summary_tmp)\n\n        if save:\n            if not row.fixed:\n                logger.info(\"saving cell to %s\" % row.cellpy_file_names)\n                cell_data.ensure_step_table = True\n                cell_data.save(row.cellpy_file_names)\n            else:\n                logger.debug(\"saving cell skipped (set to 'fixed' in info_df)\")\n\n        if no_export:\n            continue\n\n        if export_raw:\n            logger.info(\"exporting csv\")\n            cell_data.to_csv(raw_dir, sep=sep, cycles=export_cycles,\n                             shifted=shifted_cycles, raw=export_raw,\n                             last_cycle=last_cycle)\n\n        if do_export_dqdv:\n            logger.info(\"exporting dqdv\")\n            try:\n                export_dqdv(cell_data, savedir=raw_dir, sep=sep,\n                            last_cycle=last_cycle)\n            except Exception as e:\n                logging.error(\"Could not make/export dq/dv data\")\n                logger.debug(\"Failed to make/export \"\n                             \"dq/dv data (%s): %s\" % (indx, str(e)))\n                errors.append(\"ica:\" + str(indx))\n\n    if len(errors) > 0:\n        logger.error(\"Finished with errors!\")\n        logger.debug(errors)\n    else:\n        logger.info(\"Finished\")\n\n    return frames, keys, errors"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nwrite the selected summaries to csv - files for the current node.", "response": "def save_summaries(frames, keys, selected_summaries, batch_dir, batch_name):\n    \"\"\"Writes the summaries to csv-files\n\n    Args:\n        frames: list of ``cellpy`` summary DataFrames\n        keys: list of indexes (typically run-names) for the different runs\n        selected_summaries: list defining which summary data to save\n        batch_dir: directory to save to\n        batch_name: the batch name (will be used for making the file-name(s))\n\n    Returns: a pandas DataFrame with your selected summaries.\n\n    \"\"\"\n    if not frames:\n        logger.info(\"Could save summaries - no summaries to save!\")\n        logger.info(\"You have no frames - aborting\")\n        return None\n    if not keys:\n        logger.info(\"Could save summaries - no summaries to save!\")\n        logger.info(\"You have no keys - aborting\")\n        return None\n\n    selected_summaries_dict = create_selected_summaries_dict(selected_summaries)\n    summary_df = pd.concat(frames, keys=keys, axis=1)\n    # saving the selected summaries\n    for key, value in selected_summaries_dict.items():\n        _summary_file_name = os.path.join(batch_dir, \"summary_%s_%s.csv\" % (\n        key, batch_name))\n        _summary_df = summary_df.iloc[:,\n                      summary_df.columns.get_level_values(1) == value]\n        # include function to tweak headers here (need to learn MultiIndex)\n        _header = _summary_df.columns\n        _summary_df.to_csv(_summary_file_name, sep=\";\")\n        logger.info(\n            \"saved summary (%s) to:\\n       %s\" % (key, _summary_file_name))\n    logger.info(\"finished saving summaries\")\n    return summary_df"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef pick_summary_data(key, summary_df, selected_summaries):\n\n    selected_summaries_dict = create_selected_summaries_dict(selected_summaries)\n    value = selected_summaries_dict[key]\n    return summary_df.iloc[:, summary_df.columns.get_level_values(1) == value]", "response": "picks the selected pandas. DataFrame"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates a figure of the selected df - data in the given axes and returns a list of lines that match up the selected cell.", "response": "def plot_summary_data(ax, df, info_df, color_list, symbol_list, is_charge=False,\n                      plot_style=None):\n    \"\"\"creates a plot of the selected df-data in the given axes.\n\n    Typical usage:\n        standard_fig, (ce_ax, cap_ax, ir_ax) = plt.subplots(nrows=3, ncols=1,\n                                                            sharex=True)\n        list_of_lines, plot_style = plot_summary_data(ce_ax, ce_df,\n                                                      info_df=info_df,\n                                                      color_list=color_list,\n                                                      symbol_list=symbol_list,\n                                                      is_charge=False,\n                                                      plot_style=plot_style)\n\n        the ce_df is a pandas.DataFrame with ce-values for all your selected\n        cells. the color_list and the symbol_list are both list with colors and\n        symbols to use when plotting to ensure that if you have several subplots\n        (axes), then the lines and symbols match up for each given cell.\n\n    Args:\n        ax: the matplotlib axes to plot on\n        df: DataFrame with the data to plot\n        info_df: DataFrame with info for the data\n        color_list: List of colors to use\n        symbol_list: List of symbols to use\n        is_charge: plots open symbols if True\n        plot_style: selected style of the plot\n\n    Returns: list of the matplotlib lines (convenient to have if you are adding\n        a custom legend) the plot style (dictionary with matplotlib plotstyles)\n\n    \"\"\"\n\n    logger.debug(\"trying to plot summary data\")\n    if plot_style is None:\n        logger.debug(\"no plot_style given, using default\")\n        plot_style = DEFAULT_PLOT_STYLE\n    else:\n        logger.debug(\"plot_style given\")\n\n    list_of_lines = list()\n\n    for datacol in df.columns:\n        group = info_df.get_value(datacol[0], \"groups\")\n        sub_group = info_df.get_value(datacol[0], \"sub_groups\")\n        color = color_list[group - 1]\n        marker = symbol_list[sub_group - 1]\n        plot_style[\"marker\"] = marker\n        plot_style[\"markeredgecolor\"] = color\n        plot_style[\"color\"] = color\n        plot_style[\"markerfacecolor\"] = 'none'\n        logger.debug(\"selecting color for group: \" + str(color))\n\n        if not is_charge:\n            plot_style[\"markerfacecolor\"] = color\n        lines = ax.plot(df[datacol], **plot_style)\n        list_of_lines.extend(lines)\n\n    return list_of_lines, plot_style"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef plot_summary_figure(info_df, summary_df, color_list, symbol_list,\n                        selected_summaries,\n                        batch_dir, batch_name, plot_style=None, show=False,\n                        save=True,\n                        figure_type=None):\n    \"\"\"Create a figure with summary graphs.\n    Args:\n        info_df: the pandas DataFrame with info about the runs.\n        summary_df: a pandas DataFrame with the summary data.\n        color_list: a list of colors to use (one pr. group)\n        symbol_list: a list of symbols to use (one pr. cell in largest group)\n        selected_summaries: a list of the selected summaries to plot\n        batch_dir: path to the folder where the figure should be saved.\n        batch_name: the batch name.\n        plot_style: the matplotlib plot-style to use.\n        show: show the figure if True.\n        save: save the figure if True.\n        figure_type: a string for selecting type of figure to make.\n    \"\"\"\n    figure_type_object = figure_types[figure_type]\n\n    logger.debug(\"creating figure ({})\".format(figure_type))\n    standard_fig, ax = plt.subplots(nrows=figure_type_object.rows,\n                                    ncols=figure_type_object.columns,\n                                    sharex=True)\n\n    ce_ax = figure_type_object.retrieve_axis(\"ce_ax\", ax)\n    cap_ax = figure_type_object.retrieve_axis(\"cap_ax\", ax)\n    ir_ax = figure_type_object.retrieve_axis(\"ir_ax\", ax)\n    ev_ax = figure_type_object.retrieve_axis(\"ev_ax\", ax)\n\n    # pick data (common for all plot types)\n    # could include a if cd_ax: pick_summary_data...\n    ce_df = pick_summary_data(\"coulombic_efficiency\", summary_df,\n                              selected_summaries)\n    cc_df = pick_summary_data(\"charge_capacity\", summary_df, selected_summaries)\n    dc_df = pick_summary_data(\"discharge_capacity\", summary_df,\n                              selected_summaries)\n\n    # generate labels\n    ce_labels = [info_df.get_value(filename, \"labels\") for filename in\n                 ce_df.columns.get_level_values(0)]\n\n    # adding charge/discharge label\n    ce_labels.extend([\"\", \"discharge\", \"charge\"])\n\n    # plot ce\n    list_of_lines, plot_style = plot_summary_data(ce_ax, ce_df, info_df=info_df,\n                                                  color_list=color_list,\n                                                  symbol_list=symbol_list,\n                                                  is_charge=False,\n                                                  plot_style=plot_style)\n    ce_ax.set_ylabel(\"Coulombic\\nefficiency\\n(%)\")\n    ce_ax.locator_params(nbins=5)\n\n    # adding charge/discharge label\n    color = plot_style[\"color\"]\n    markersize = plot_style[\"markersize\"]\n\n    open_label = mpl.lines.Line2D([], [], color=color, marker='s',\n                                  markeredgecolor=color, markerfacecolor='none',\n                                  markersize=markersize)\n    closed_label = mpl.lines.Line2D([], [], color=color, marker='s',\n                                    markeredgecolor=color,\n                                    markerfacecolor=color,\n                                    markersize=markersize)\n    no_label = mpl.lines.Line2D([], [], color='none', marker='s', markersize=0)\n    list_of_lines.extend([no_label, closed_label, open_label])\n\n    # plotting capacity (common)\n    plot_summary_data(cap_ax, cc_df, is_charge=True, info_df=info_df,\n                      color_list=color_list,\n                      symbol_list=symbol_list, plot_style=plot_style)\n    plot_summary_data(cap_ax, dc_df, is_charge=False, info_df=info_df,\n                      color_list=color_list,\n                      symbol_list=symbol_list, plot_style=plot_style)\n    cap_ax.set_ylabel(\"Capacity\\n(mAh/g)\")\n    cap_ax.locator_params(nbins=4)\n\n    # plotting ir data (common)\n    plot_ir_charge, plot_ir_discharge = figure_type_object.ir_selector\n    if plot_ir_charge:\n        irc_df = pick_summary_data(\"ir_charge\", summary_df, selected_summaries)\n        plot_summary_data(ir_ax, irc_df, is_charge=True, info_df=info_df,\n                          color_list=color_list,\n                          symbol_list=symbol_list, plot_style=plot_style)\n    if plot_ir_discharge:\n        ird_df = pick_summary_data(\"ir_discharge\", summary_df,\n                                   selected_summaries)\n        plot_summary_data(ir_ax, ird_df, is_charge=False, info_df=info_df,\n                          color_list=color_list,\n                          symbol_list=symbol_list, plot_style=plot_style)\n\n    ir_ax.set_ylabel(\"Internal\\nresistance\\n(Ohms)\")\n    ir_ax.set_xlabel(\"Cycle number\")\n    ir_ax.locator_params(axis=\"y\", nbins=4)\n    ir_ax.locator_params(axis=\"x\", nbins=10)\n    # should use MaxNLocator here instead\n\n    # pick data (not common for all plot types)\n    if ev_ax is not None:\n        plot_ev_charge, plot_ev_discharge = figure_type_object\\\n            .end_voltage_selector\n        if plot_ev_charge:\n            evc_df = pick_summary_data(\"end_voltage_charge\", summary_df,\n                                       selected_summaries)\n            plot_summary_data(ev_ax, evc_df, is_charge=True, info_df=info_df,\n                              color_list=color_list,\n                              symbol_list=symbol_list, plot_style=plot_style)\n        if plot_ev_discharge:\n            evd_df = pick_summary_data(\"end_voltage_discharge\", summary_df,\n                                       selected_summaries)\n            plot_summary_data(ev_ax, evd_df, is_charge=False, info_df=info_df,\n                              color_list=color_list,\n                              symbol_list=symbol_list, plot_style=plot_style)\n\n        ev_ax.set_ylabel(\"End\\nvoltage\\n(V)\")\n        ev_ax.locator_params(axis=\"y\", nbins=4)\n\n    # tweaking\n    plt.subplots_adjust(left=0.07, right=0.93, top=0.9, wspace=0.25,\n                        hspace=0.15)\n\n    # adding legend\n    logger.debug(\"trying to add legends \" + str(ce_labels))\n    standard_fig.legend(handles=list_of_lines, labels=ce_labels,\n                        bbox_to_anchor=(1.02, 1.1), loc=2,\n                        # bbox_transform=plt.gcf().transFigure,\n                        bbox_transform=ce_ax.transAxes,\n                        numpoints=1,\n                        ncol=1, labelspacing=0.,\n                        prop={\"size\": 10})\n\n    # plt.tight_layout()\n    if save:\n        extension = prms.Batch[\"fig_extension\"]\n        dpi = prms.Batch[\"dpi\"]\n        figure_file_name = os.path.join(batch_dir, \"%splot_%s.%s\" % (\n        figure_type, batch_name, extension))\n        standard_fig.savefig(figure_file_name, dpi=dpi, bbox_inches='tight')\n    if show:\n        plt.show()\n    return standard_fig, (ce_ax, cap_ax, ir_ax)", "response": "Create a figure with summary graphs."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef export_dqdv(cell_data, savedir, sep, last_cycle=None):\n    logger.debug(\"exporting dqdv\")\n    filename = cell_data.dataset.loaded_from\n    no_merged_sets = \"\"\n    firstname, extension = os.path.splitext(filename)\n    firstname += no_merged_sets\n    if savedir:\n        firstname = os.path.join(savedir, os.path.basename(firstname))\n        logger.debug(f\"savedir is true: {firstname}\")\n\n    outname_charge = firstname + \"_dqdv_charge.csv\"\n    outname_discharge = firstname + \"_dqdv_discharge.csv\"\n\n    list_of_cycles = cell_data.get_cycle_numbers()\n    number_of_cycles = len(list_of_cycles)\n    logger.debug(\"%s: you have %i cycles\" % (filename, number_of_cycles))\n\n    # extracting charge\n    out_data = _extract_dqdv(cell_data, cell_data.get_ccap, last_cycle)\n    logger.debug(\"extracted ica for charge\")\n    try:\n        _save_multi(data=out_data, file_name=outname_charge, sep=sep)\n    except ExportFailed:\n        logger.info(\"could not export ica for charge\")\n    else:\n        logger.debug(\"saved ica for charge\")\n\n    # extracting discharge\n    out_data = _extract_dqdv(cell_data, cell_data.get_dcap, last_cycle)\n    logger.debug(\"extracxted ica for discharge\")\n    try:\n        _save_multi(data=out_data, file_name=outname_discharge, sep=sep)\n    except ExportFailed:\n        logger.info(\"could not export ica for discharge\")\n    else:\n        logger.debug(\"saved ica for discharge\")", "response": "Exports dQ / dV data from a CellpyData instance."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn an initialized instance of the Batch class", "response": "def init(*args, **kwargs):\n    \"\"\"Returns an initialized instance of the Batch class\"\"\"\n    # set up cellpy logger\n    default_log_level = kwargs.pop(\"default_log_level\", None)\n    import cellpy.log as log\n    log.setup_logging(custom_log_dir=prms.Paths[\"filelogdir\"],\n                      default_level=default_log_level)\n    b = Batch(*args, **kwargs)\n    return b"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating a DataFrame with info about the runs", "response": "def create_info_df(self):\n        \"\"\"Creates a DataFrame with info about the runs (loaded from the DB)\"\"\"\n        logger.debug(\"running create_info_df\")\n        # initializing the reader\n        reader = self.reader()\n        self.info_df = make_df_from_batch(self.name, batch_col=self.batch_col,\n                                          reader=reader)\n        logger.debug(str(self.info_df.head(5)))"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsaves the DataFrame with info about the runs to a JSON file", "response": "def save_info_df(self):\n        \"\"\"Saves the DataFrame with info about the runs to a JSON file\"\"\"\n        logger.debug(\"running save_info_df\")\n\n        info_df = self.info_df\n        top_level_dict = {'info_df': info_df, 'metadata': self._prm_packer()}\n\n        # packing prms\n\n        jason_string = json.dumps(top_level_dict,\n                                  default=lambda info_df: json.loads(\n                                      info_df.to_json()))\n        with open(self.info_file, 'w') as outfile:\n            outfile.write(jason_string)\n        logger.info(\"Saved file to {}\".format(self.info_file))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef load_info_df(self, file_name=None):\n\n        if file_name is None:\n            file_name = self.info_file\n\n        with open(file_name, 'r') as infile:\n            top_level_dict = json.load(infile)\n\n        new_info_df_dict = top_level_dict['info_df']\n        new_info_df = pd.DataFrame(new_info_df_dict)\n        self.info_df = new_info_df\n\n        self._prm_packer(top_level_dict['metadata'])\n        self.info_file = file_name\n        logger.debug(\"loaded info_df\")\n        logger.debug(\" info_file: %s\" % self.info_file)", "response": "Loads a DataFrame with all the needed info about the run\n           "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncreate a folder structure based on the project and batch name.", "response": "def create_folder_structure(self):\n        \"\"\"Creates a folder structure based on the project and batch name.\n\n        Project - Batch-name - Raw-data-dir\n\n        The info_df JSON-file will be stored in the Project folder.\n        The summary-files will be saved in the Batch-name folder.\n        The raw data (including exported cycles and ica-data) will be saved to\n        the Raw-data-dir.\n\n        \"\"\"\n        self.info_file, directories = create_folder_structure(self.project,\n                                                              self.name)\n        self.project_dir, self.batch_dir, self.raw_dir = directories\n        logger.debug(\"create folders:\" + str(directories))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef load_and_save_raw(self, parent_level=\"CellpyData\"):\n        sep = prms.Reader[\"sep\"]\n        if self.use_cellpy_stat_file is None:\n            use_cellpy_stat_file = prms.Reader.use_cellpy_stat_file\n        else:\n            use_cellpy_stat_file = self.use_cellpy_stat_file\n        logger.debug(f\"b.load_and_save_raw: \"\n                     f\"use_cellpy_stat_file = {use_cellpy_stat_file}\")\n        self.frames, self.keys, errors = read_and_save_data(\n            self.info_df,\n            self.raw_dir,\n            sep=sep,\n            force_raw=self.force_raw_file,\n            force_cellpy=self.force_cellpy_file,\n            export_cycles=self.export_cycles,\n            shifted_cycles=self.shifted_cycles,\n            export_raw=self.export_raw,\n            export_ica=self.export_ica,\n            save=self.save_cellpy_file,\n            use_cellpy_stat_file=use_cellpy_stat_file,\n            parent_level=parent_level,\n            last_cycle=self.last_cycle\n        )\n        logger.debug(\"loaded and saved data. errors:\" + str(errors))", "response": "Loads the cellpy or raw - data file and saves to csv"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nmakes and save summary csv files", "response": "def make_summaries(self):\n        \"\"\"Make and save summary csv files,\n        each containing values from all cells\"\"\"\n        self.summary_df = save_summaries(self.frames, self.keys,\n                                         self.selected_summaries,\n                                         self.batch_dir, self.name)\n        logger.debug(\"made and saved summaries\")"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nplot the summary graphs for the current object.", "response": "def plot_summaries(self, show=False, save=True, figure_type=None):\n        \"\"\"Plot summary graphs.\n\n        Args:\n            show: shows the figure if True.\n            save: saves the figure if True.\n            figure_type: optional, figure type to create.\n        \"\"\"\n\n        if not figure_type:\n            figure_type = self.default_figure_type\n\n        if not figure_type in self.default_figure_types:\n            logger.debug(\"unknown figure type selected\")\n            figure_type = self.default_figure_type\n\n        color_list, symbol_list = self._create_colors_markers_list()\n        summary_df = self.summary_df\n        selected_summaries = self.selected_summaries\n        batch_dir = self.batch_dir\n        batch_name = self.name\n        fig, ax = plot_summary_figure(self.info_df, summary_df, color_list,\n                                      symbol_list, selected_summaries,\n                                      batch_dir, batch_name, show=show,\n                                      save=save, figure_type=figure_type)\n        self.figure[figure_type] = fig\n        self.axes[figure_type] = ax"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nupdate the selected datasets.", "response": "def update(self, all_in_memory=None):\n        \"\"\"Updates the selected datasets.\n\n        Args:\n            all_in_memory (bool): store the cellpydata in memory (default\n            False)\n\n        \"\"\"\n        logging.info(\"[update experiment]\")\n        if all_in_memory is not None:\n            self.all_in_memory = all_in_memory\n\n        pages = self.journal.pages\n        summary_frames = dict()\n        cell_data_frames = dict()\n        number_of_runs = len(pages)\n        counter = 0\n        errors = []\n\n        for indx, row in pages.iterrows():\n            counter += 1\n            h_txt = \"[\" + counter * \"|\" + (\n                    number_of_runs - counter) * \".\" + \"]\"\n            l_txt = \"starting to process file # %i (index=%s)\" % (counter, indx)\n            logging.debug(l_txt)\n            print(h_txt)\n\n            if not row.raw_file_names and not self.force_cellpy:\n                logging.info(\"File(s) not found!\")\n                logging.info(indx)\n                logging.debug(\"File(s) not found for index=%s\" % indx)\n                errors.append(indx)\n                continue\n\n            else:\n                logging.info(f\"Processing {indx}\")\n\n            cell_data = cellreader.CellpyData()\n            if not self.force_cellpy or self.force_recalc:\n                logging.info(\n                    \"setting cycle mode (%s)...\" % row.cell_type)\n                cell_data.cycle_mode = row.cell_type\n\n            logging.info(\"loading cell\")\n            if not self.force_cellpy:\n                logging.debug(\"not forcing to load cellpy-file instead of raw file.\")\n                try:\n                    cell_data.loadcell(\n                        raw_files=row.raw_file_names,\n                        cellpy_file=row.cellpy_file_names,\n                        mass=row.masses,\n                        summary_on_raw=True,\n                        force_raw=self.force_raw_file,\n                        use_cellpy_stat_file=prms.Reader.use_cellpy_stat_file\n                    )\n                except Exception as e:\n                    logging.info('Failed to load: ' + str(e))\n                    errors.append(\"loadcell:\" + str(indx))\n                    if not self.accept_errors:\n                        raise e\n                    continue\n\n            else:\n                logging.info(\"forcing\")\n                try:\n                    cell_data.load(row.cellpy_file_names,\n                                   parent_level=self.parent_level)\n                except Exception as e:\n                    logging.info(\n                        f\"Critical exception encountered {type(e)} \"\n                        \"- skipping this file\")\n                    logging.debug(\n                        'Failed to load. Error-message: ' + str(e))\n                    errors.append(\"load:\" + str(indx))\n                    if not self.accept_errors:\n                        raise e\n                    continue\n\n            if not cell_data.check():\n                logging.info(\"...not loaded...\")\n                logging.debug(\n                    \"Did not pass check(). Could not load cell!\")\n                errors.append(\"check:\" + str(indx))\n                continue\n\n            logging.info(\"...loaded successfully...\")\n\n            summary_tmp = cell_data.dataset.dfsummary\n            logging.info(\"Trying to get summary_data\")\n\n            if cell_data.dataset.step_table is None or self.force_recalc:\n                logging.info(\n                    \"Running make_step_table\"\n                )\n\n                cell_data.make_step_table()\n\n            if summary_tmp is None or self.force_recalc:\n                logging.info(\n                    \"Running make_summary\"\n                )\n\n                cell_data.make_summary(find_end_voltage=True,\n                                       find_ir=True)\n\n            if summary_tmp.index.name == b\"Cycle_Index\":\n                logging.debug(\"Strange: 'Cycle_Index' is a byte-string\")\n                summary_tmp.index.name = 'Cycle_Index'\n\n            if not summary_tmp.index.name == \"Cycle_Index\":\n                logging.debug(\"Setting index to Cycle_Index\")\n                # check if it is a byte-string\n                if b\"Cycle_Index\" in summary_tmp.columns:\n                    logging.debug(\n                        \"Seems to be a byte-string in the column-headers\")\n                    summary_tmp.rename(\n                        columns={b\"Cycle_Index\": 'Cycle_Index'},\n                        inplace=True)\n                summary_tmp.set_index(\"Cycle_Index\", inplace=True)\n\n            summary_frames[indx] = summary_tmp\n\n            if self.all_in_memory:\n                cell_data_frames[indx] = cell_data\n            else:\n                cell_data_frames[indx] = cellreader.CellpyData(initialize=True)\n                cell_data_frames[indx].dataset.step_table = \\\n                    cell_data.dataset.step_table\n                # cell_data_frames[indx].dataset.step_table_made = True\n\n            if self.save_cellpy:\n                logging.info(\"saving to cellpy-format\")\n                if not row.fixed:\n                    logging.info(\"saving cell to %s\" % row.cellpy_file_names)\n                    cell_data.ensure_step_table = True\n                    cell_data.save(row.cellpy_file_names)\n                else:\n                    logging.debug(\n                        \"saving cell skipped (set to 'fixed' in info_df)\")\n\n            if self.export_raw or self.export_cycles:\n                export_text = \"exporting\"\n                if self.export_raw:\n                    export_text += \" [raw]\"\n                if self.export_cycles:\n                    export_text += \" [cycles]\"\n                logging.info(export_text)\n                cell_data.to_csv(\n                    self.journal.raw_dir,\n                    sep=prms.Reader.sep,\n                    cycles=self.export_cycles,\n                    shifted=self.shifted_cycles,\n                    raw=self.export_raw,\n                    last_cycle=self.last_cycle\n                )\n\n            if self.export_ica:\n                logging.info(\"exporting [ica]\")\n                try:\n                    helper.export_dqdv(\n                        cell_data,\n                        savedir=self.journal.raw_dir,\n                        sep=prms.Reader.sep,\n                        last_cycle=self.last_cycle\n                    )\n                except Exception as e:\n                    logging.error(\n                        \"Could not make/export dq/dv data\"\n                    )\n                    logging.debug(\n                        \"Failed to make/export \"\n                        \"dq/dv data (%s): %s\" % (indx, str(e))\n                    )\n                    errors.append(\"ica:\" + str(indx))\n\n        self.errors[\"update\"] = errors\n        self.summary_frames = summary_frames\n        self.cell_data_frames = cell_data_frames"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nensures that an appropriate link to the cellpy - files exists for each cell.", "response": "def link(self):\n        \"\"\"Ensure that an appropriate link to the cellpy-files exists for\n        each cell.\n\n        The experiment will then contain a CellpyData object for each cell\n        (in the cell_data_frames attribute) with only the step-table stored.\n\n        Remark that running update persists the summary frames instead (or\n        everything in case you specify all_in_memory=True).\n        This might be considered \"a strange and unexpected behaviour\". Sorry\n        for that (but the authors of this package is also a bit strange...).\n\n        \"\"\"\n        logging.info(\"[estblishing links]\")\n        logging.debug(\"checking and establishing link to data\")\n        cell_data_frames = dict()\n        counter = 0\n        errors = []\n        try:\n            for indx, row in self.journal.pages.iterrows():\n\n                counter += 1\n                l_txt = \"starting to process file # %i (index=%s)\" % (counter, indx)\n                logging.debug(l_txt)\n                logging.info(f\"linking cellpy-file: {row.cellpy_file_names}\")\n\n                if not os.path.isfile(row.cellpy_file_names):\n                    logging.error(\"File does not exist\")\n                    raise IOError\n\n                cell_data_frames[indx] = cellreader.CellpyData(initialize=True)\n\n                step_table = helper.look_up_and_get(\n                    row.cellpy_file_names,\n                    \"step_table\"\n                )\n\n                cell_data_frames[indx].dataset.step_table = step_table\n\n            self.cell_data_frames = cell_data_frames\n\n        except IOError as e:\n            logging.warning(e)\n            e_txt = \"links not established - try update\"\n            logging.warning(e_txt)\n            errors.append(e_txt)\n\n        self.errors[\"link\"] = errors"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_default_config_file_path(init_filename=None):\n    prm_dir = get_package_prm_dir()\n    if not init_filename:\n        init_filename = DEFAULT_FILENAME\n    src = os.path.join(prm_dir, init_filename)\n    return src", "response": "gets the path to the default config - file"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_user_dir_and_dst(init_filename):\n    user_dir = get_user_dir()\n    dst_file = os.path.join(user_dir, init_filename)\n    return user_dir, dst_file", "response": "gets the name of the user directory and full prm filepath"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef setup(interactive, not_relative, dry_run, reset, root_dir, testuser):\n\n    click.echo(\"[cellpy] (setup)\")\n\n    # generate variables\n    init_filename = create_custom_init_filename()\n    userdir, dst_file = get_user_dir_and_dst(init_filename)\n\n    if testuser:\n        if not root_dir:\n            root_dir = os.getcwd()\n\n        click.echo(f\"[cellpy] (setup) DEV-MODE testuser: {testuser}\")\n        init_filename = create_custom_init_filename(testuser)\n        userdir = root_dir\n        dst_file = get_dst_file(userdir, init_filename)\n        click.echo(f\"[cellpy] (setup) DEV-MODE userdir: {userdir}\")\n        click.echo(f\"[cellpy] (setup) DEV-MODE dst_file: {dst_file}\")\n\n    if not pathlib.Path(dst_file).is_file():\n        reset = True\n\n    if interactive:\n        click.echo(\" interactive mode \".center(80, \"-\"))\n        _update_paths(root_dir, not not_relative, dry_run=dry_run, reset=reset)\n        _write_config_file(\n            userdir, dst_file,\n            init_filename, dry_run,\n        )\n        _check()\n\n    else:\n        _write_config_file(userdir, dst_file, init_filename, dry_run)\n        _check()", "response": "This function will help you to setup cellpy."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _parse_g_dir(repo, gdirpath):\n    for f in repo.get_contents(gdirpath):\n        if f.type == \"dir\":\n            for sf in repo.get_contents(f.path):\n                yield sf\n        else:\n            yield f", "response": "parses a repo directory two - levels deep"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nextract table from cellpy hdf5 - file.", "response": "def look_up_and_get(cellpy_file_name, table_name):\n    \"\"\"Extracts table from cellpy hdf5-file.\"\"\"\n\n    # infoname = '/CellpyData/info'\n    # dataname = '/CellpyData/dfdata'\n    # summaryname = '/CellpyData/dfsummary'\n    # fidname = '/CellpyData/fidtable'\n    # stepname = '/CellpyData/step_table'\n\n    root = '/CellpyData'\n    table_path = '/'.join([root, table_name])\n\n    logging.debug(f\"look_up_and_get({cellpy_file_name}, {table_name}\")\n    store = pd.HDFStore(cellpy_file_name)\n    table = store.select(table_path)\n    store.close()\n    return table"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef fix_groups(groups):\n    _groups = []\n    for g in groups:\n        try:\n            if not float(g) > 0:\n                _groups.append(1000)\n            else:\n                _groups.append(int(g))\n        except TypeError as e:\n            logging.info(\"Error in reading group number (check your db)\")\n            logging.debug(g)\n            logging.debug(e)\n            _groups.append(1000)\n    return _groups", "response": "Takes care of strange group numbers."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef create_selected_summaries_dict(summaries_list):\n    headers_summary = cellpy.parameters.internal_settings.get_headers_summary()\n    selected_summaries = dict()\n    for h in summaries_list:\n        selected_summaries[h] = headers_summary[h]\n    return selected_summaries", "response": "Creates a dictionary with selected summary column headers."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nparsing the summaries and combine based on column selected_summaries", "response": "def join_summaries(summary_frames, selected_summaries, keep_old_header=False):\n    \"\"\"parse the summaries and combine based on column (selected_summaries)\"\"\"\n\n    selected_summaries_dict = create_selected_summaries_dict(selected_summaries)\n    frames = []\n    keys = []\n    for key in summary_frames:\n        keys.append(key)\n        if summary_frames[key].empty:\n            logging.debug(\"Empty summary_frame encountered\")\n        frames.append(summary_frames[key])\n\n    out = []\n    summary_df = pd.concat(frames, keys=keys, axis=1)\n    for key, value in selected_summaries_dict.items():\n        _summary_df = summary_df.iloc[\n                      :, summary_df.columns.get_level_values(1) == value\n                      ]\n        _summary_df.name = key\n\n        if not keep_old_header:\n            try:\n                _summary_df.columns = _summary_df.columns.droplevel(-1)\n            except AttributeError as e:\n                logging.debug(\"could not drop level from frame\")\n                logging.debug(e)\n\n        out.append(_summary_df)\n    logger.debug(\"finished joining summaries\")\n\n    return out"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate sensible folder names.", "response": "def generate_folder_names(name, project):\n    \"\"\"Creates sensible folder names.\"\"\"\n\n    out_data_dir = prms.Paths.outdatadir\n    project_dir = os.path.join(out_data_dir, project)\n    batch_dir = os.path.join(project_dir, name)\n    raw_dir = os.path.join(batch_dir, \"raw_data\")\n    return out_data_dir, project_dir, batch_dir, raw_dir"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef group_by_interpolate(df, x=None, y=None, group_by=None,\n                         number_of_points=100, tidy=False,\n                         individual_x_cols=False, header_name=\"Unit\",\n                         dx=10.0, generate_new_x=True):\n    \"\"\"Use this for generating wide format from long (tidy) data\"\"\"\n\n    time_00 = time.time()\n    if x is None:\n        x = HEADERS_NORMAL.step_time_txt\n    if y is None:\n        y = HEADERS_NORMAL.voltage_txt\n    if group_by is None:\n        group_by = [HEADERS_NORMAL.cycle_index_txt]\n\n    if not isinstance(group_by, (list, tuple)):\n        group_by = [group_by]\n\n    if not generate_new_x:\n        # check if it makes sence\n        if (not tidy) and (not individual_x_cols):\n            logging.warning(\"Unlogical condition\")\n            generate_new_x = True\n\n    new_x = None\n\n    if generate_new_x:\n        x_max = df[x].max()\n        x_min = df[x].min()\n        if number_of_points:\n            new_x = np.linspace(x_max, x_min, number_of_points)\n        else:\n            new_x = np.arange(x_max, x_min, dx)\n\n    new_dfs = []\n    keys = []\n\n    for name, group in df.groupby(group_by):\n        keys.append(name)\n        if not isinstance(name, (list, tuple)):\n            name = [name]\n\n        new_group = _interpolate_df_col(\n            group, x=x, y=y, new_x=new_x,\n            number_of_points=number_of_points,\n            dx=dx,\n        )\n\n        if tidy or (not tidy and not individual_x_cols):\n            for i, j in zip(group_by, name):\n                new_group[i] = j\n        new_dfs.append(new_group)\n\n    if tidy:\n        new_df = pd.concat(new_dfs)\n    else:\n        if individual_x_cols:\n            new_df = pd.concat(new_dfs, axis=1, keys=keys)\n            group_by.append(header_name)\n            new_df.columns.names = group_by\n        else:\n            new_df = pd.concat(new_dfs)\n            new_df = new_df.pivot(index=x, columns=group_by[0], values=y, )\n    self.logger.debug(f\"(dt: {(time.time() - time_00):4.2f}s)\")\n    return new_df", "response": "This function is used to generate wide format from long data."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ninterpolates a column based on another column.", "response": "def _interpolate_df_col(df, x=None, y=None, new_x=None, dx=10.0,\n                        number_of_points=None, direction=1, **kwargs):\n        \"\"\"Interpolate a column based on another column.\n\n        Args:\n            df: DataFrame with the (cycle) data.\n            x: Column name for the x-value (defaults to the step-time column).\n            y: Column name for the y-value (defaults to the voltage column).\n            new_x (numpy array or None): Interpolate using these new x-values\n                instead of generating x-values based on dx or number_of_points.\n            dx: step-value (defaults to 10.0)\n            number_of_points: number of points for interpolated values (use\n                instead of dx and overrides dx if given).\n            direction (-1,1): if direction is negetive, then invert the\n                x-values before interpolating.\n            **kwargs: arguments passed to scipy.interpolate.interp1d\n\n        Returns: DataFrame with interpolated y-values based on given or\n            generated x-values.\n\n        \"\"\"\n\n        if x is None:\n            x = df.columns[0]\n        if y is None:\n            y = df.columns[1]\n\n        xs = df[x].values\n        ys = df[y].values\n\n        if direction > 0:\n            x_min = xs.min()\n            x_max = xs.max()\n        else:\n            x_max = xs.min()\n            x_min = xs.max()\n            dx = -dx\n\n        bounds_error = kwargs.pop(\"bounds_error\", False)\n        f = interpolate.interp1d(xs, ys, bounds_error=bounds_error, **kwargs)\n        if new_x is None:\n            if number_of_points:\n                new_x = np.linspace(x_min, x_max, number_of_points)\n            else:\n                new_x = np.arange(x_min, x_max, dx)\n\n        new_y = f(new_x)\n\n        new_df = pd.DataFrame(\n            {x: new_x, y: new_y}\n        )\n\n        return new_df"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncreate a list of pandas. DataFrames one for each charge step.", "response": "def _collect_capacity_curves(data, direction=\"charge\"):\n    \"\"\"Create a list of pandas.DataFrames, one for each charge step.\n\n    The DataFrames are named by its cycle number.\n\n    Input: CellpyData\n    Returns: list of pandas.DataFrames\n        minimum voltage value,\n        maximum voltage value\"\"\"\n\n    minimum_v_value = np.Inf\n    maximum_v_value = -np.Inf\n    charge_list = []\n    cycles = data.get_cycle_numbers()\n    for cycle in cycles:\n        try:\n            if direction == \"charge\":\n                q, v = data.get_ccap(cycle)\n            else:\n                q, v = data.get_dcap(cycle)\n\n        except NullData as e:\n            logging.warning(e)\n            break\n\n        else:\n            d = pd.DataFrame({\"q\": q, \"v\": v})\n            # d.name = f\"{cycle}\"\n            d.name = cycle\n            charge_list.append(d)\n            v_min = v.min()\n            v_max = v.max()\n            if v_min < minimum_v_value:\n                minimum_v_value = v_min\n            if v_max > maximum_v_value:\n                maximum_v_value = v_max\n    return charge_list, cycles, minimum_v_value, maximum_v_value"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef cell(filename=None, mass=None, instrument=None, logging_mode=\"INFO\",\n         cycle_mode=None, auto_summary=True):\n    \"\"\"Create a CellpyData object\"\"\"\n\n    from cellpy import log\n\n    log.setup_logging(default_level=logging_mode)\n    cellpy_instance = setup_cellpy_instance()\n\n    if instrument is not None:\n        cellpy_instance.set_instrument(instrument=instrument)\n\n    if cycle_mode is not None:\n        cellpy_instance.cycle_mode = cycle_mode\n\n    if filename is not None:\n        filename = Path(filename)\n\n        if filename.suffix in [\".h5\", \".hdf5\", \".cellpy\", \".cpy\"]:\n            logging.info(f\"Loading cellpy-file: {filename}\")\n            cellpy_instance.load(filename)\n        else:\n            logging.info(f\"Loading raw-file: {filename}\")\n            cellpy_instance.from_raw(filename)\n            if mass is not None:\n                logging.info(\"Setting mass\")\n                cellpy_instance.set_mass(mass)\n            if auto_summary:\n                logging.info(\"Creating step table\")\n                cellpy_instance.make_step_table()\n                logging.info(\"Creating summary data\")\n                cellpy_instance.make_summary()\n\n    logging.info(\"Created CellpyData object\")\n    return cellpy_instance", "response": "Create a CellpyData object from a file."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef just_load_srno(srno, prm_filename=None):\n    from cellpy import dbreader, filefinder\n    print(\"just_load_srno: srno: %i\" % srno)\n\n    # ------------reading parameters--------------------------------------------\n    # print \"just_load_srno: read prms\"\n    # prm = prmreader.read(prm_filename)\n    #\n    # print prm\n\n    print(\"just_load_srno: making class and setting prms\")\n    d = CellpyData()\n\n    # ------------reading db----------------------------------------------------\n    print()\n    print(\"just_load_srno: starting to load reader\")\n    # reader = dbreader.reader(prm_filename)\n    reader = dbreader.Reader()\n    print(\"------ok------\")\n\n    run_name = reader.get_cell_name(srno)\n    print(\"just_load_srno: run_name:\")\n    print(run_name)\n\n    m = reader.get_mass(srno)\n    print(\"just_load_srno: mass: %f\" % m)\n    print()\n\n    # ------------loadcell------------------------------------------------------\n    print(\"just_load_srno: getting file_names\")\n    raw_files, cellpy_file = filefinder.search_for_files(run_name)\n    print(\"raw_files:\", raw_files)\n    print(\"cellpy_file:\", cellpy_file)\n\n    print(\"just_load_srno: running loadcell\")\n    d.loadcell(raw_files, cellpy_file, mass=m)\n    print(\"------ok------\")\n\n    # ------------do stuff------------------------------------------------------\n    print(\"just_load_srno: getting step_numbers for charge\")\n    v = d.get_step_numbers(\"charge\")\n    print(v)\n\n    print()\n    print(\"just_load_srno: finding C-rates\")\n    d.find_C_rates(v, silent=False)\n\n    print()\n    print(\"just_load_srno: OK\")\n    return True", "response": "This function loads a dataset based on a serial number."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nloading a raw data file and saves it as a cellpy - file.", "response": "def load_and_save_resfile(filename, outfile=None, outdir=None, mass=1.00):\n    \"\"\"Load a raw data file and save it as cellpy-file.\n\n    Args:\n        mass (float): active material mass [mg].\n        outdir (path): optional, path to directory for saving the hdf5-file.\n        outfile (str): optional, name of hdf5-file.\n        filename (str): name of the resfile.\n\n    Returns:\n        out_file_name (str): name of saved file.\n    \"\"\"\n    d = CellpyData()\n\n    if not outdir:\n        outdir = prms.Paths[\"cellpydatadir\"]\n\n    if not outfile:\n        outfile = os.path.basename(filename).split(\".\")[0] + \".h5\"\n        outfile = os.path.join(outdir, outfile)\n\n    print(\"filename:\", filename)\n    print(\"outfile:\", outfile)\n    print(\"outdir:\", outdir)\n    print(\"mass:\", mass, \"mg\")\n\n    d.from_raw(filename)\n    d.set_mass(mass)\n    d.make_step_table()\n    d.make_summary()\n    d.save(filename=outfile)\n    d.to_csv(datadir=outdir, cycles=True, raw=True, summary=True)\n    return outfile"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef load_and_print_resfile(filename, info_dict=None):\n\n    # self.test_no = None\n    # self.mass = 1.0  # mass of (active) material (in mg)\n    # self.no_cycles = 0.0\n    # self.charge_steps = None  # not in use at the moment\n    # self.discharge_steps = None  # not in use at the moment\n    # self.ir_steps = None  # dict # not in use at the moment\n    # self.ocv_steps = None  # dict # not in use at the moment\n    # self.nom_cap = 3579  # mAh/g (used for finding c-rates)\n    # self.mass_given = False\n    # self.c_mode = True\n    # self.starts_with = \"discharge\"\n    # self.material = \"noname\"\n    # self.merged = False\n    # self.file_errors = None  # not in use at the moment\n    # self.loaded_from = None  # name of the .res file it is loaded from\n    # (can be list if merged)\n    # self.raw_data_files = []\n    # self.raw_data_files_length = []\n    # # self.parent_filename = None # name of the .res file it is loaded from\n    # (basename) (can be list if merded)\n    # # self.parent_filename = if listtype, for file in etc,,,\n    # os.path.basename(self.loaded_from)\n    # self.channel_index = None\n    # self.channel_number = None\n    # self.creator = None\n    # self.item_ID = None\n    # self.schedule_file_name = None\n    # self.start_datetime = None\n    # self.test_ID = None\n    # self.name = None\n\n    # NEXT: include nom_cap, tot_mass and  parameters table in save/load hdf5\n    if info_dict is None:\n        info_dict = dict()\n        info_dict[\"mass\"] = 1.23  # mg\n        info_dict[\"nom_cap\"] = 3600  # mAh/g (active material)\n        info_dict[\"tot_mass\"] = 2.33  # mAh/g (total mass of material)\n\n    d = CellpyData()\n\n    print(\"filename:\", filename)\n    print(\"info_dict in:\", end=' ')\n    print(info_dict)\n\n    d.from_raw(filename)\n    d.set_mass(info_dict[\"mass\"])\n    d.make_step_table()\n    d.make_summary()\n\n    for test in d.datasets:\n        print(\"newtest\")\n        print(test)\n\n    return info_dict", "response": "Loads a raw data file and prints information."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsets the instrument used for obtaining the data.", "response": "def set_instrument(self, instrument=None):\n        \"\"\"Set the instrument (i.e. tell cellpy the file-type you use).\n\n        Args:\n            instrument: (str) in [\"arbin\", \"bio-logic-csv\", \"bio-logic-bin\",...]\n\n        Sets the instrument used for obtaining the data (i.e. sets fileformat)\n\n        \"\"\"\n        if instrument is None:\n            instrument = self.tester\n\n        if instrument in [\"arbin\", \"arbin_res\"]:\n            self._set_arbin()\n            self.tester = \"arbin\"\n\n        elif instrument == \"arbin_sql\":\n            self._set_arbin_sql()\n            self.tester = \"arbin\"\n\n        elif instrument == \"arbin_experimental\":\n            self._set_arbin_experimental()\n            self.tester = \"arbin\"\n\n        elif instrument in [\"pec\", \"pec_csv\"]:\n            self._set_pec()\n            self.tester = \"pec\"\n\n        elif instrument in [\"biologics\", \"biologics_mpr\"]:\n            self._set_biologic()\n            self.tester = \"biologic\"\n\n        elif instrument == \"custom\":\n            self._set_custom()\n            self.tester = \"custom\"\n\n        else:\n            raise Exception(f\"option does not exist: '{instrument}'\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef set_raw_datadir(self, directory=None):\n\n        if directory is None:\n            self.logger.info(\"no directory name given\")\n            return\n        if not os.path.isdir(directory):\n            self.logger.info(directory)\n            self.logger.info(\"directory does not exist\")\n            return\n        self.raw_datadir = directory", "response": "Set the directory containing. res - files."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsets the directory containing. hdf5 - files.", "response": "def set_cellpy_datadir(self, directory=None):\n        \"\"\"Set the directory containing .hdf5-files.\n\n        Used for setting directory for looking for hdf5-files.\n        A valid directory name is required.\n\n        Args:\n            directory (str): path to hdf5-directory\n\n        Example:\n            >>> d = CellpyData()\n            >>> directory = \"MyData/HDF5\"\n            >>> d.set_raw_datadir(directory)\n\n        \"\"\"\n\n        if directory is None:\n            self.logger.info(\"no directory name given\")\n            return\n        if not os.path.isdir(directory):\n            self.logger.info(\"directory does not exist\")\n            return\n        self.cellpy_datadir = directory"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nchecking the stats for the files in the raw - data and cellpy hdf5.", "response": "def check_file_ids(self, rawfiles, cellpyfile):\n        \"\"\"Check the stats for the files (raw-data and cellpy hdf5).\n\n        This function checks if the hdf5 file and the res-files have the same\n        timestamps etc to find out if we need to bother to load .res -files.\n\n        Args:\n            cellpyfile (str): filename of the cellpy hdf5-file.\n            rawfiles (list of str): name(s) of raw-data file(s).\n\n\n        Returns:\n            False if the raw files are newer than the cellpy hdf5-file\n                (update needed).\n            If return_res is True it also returns list of raw-file_names as\n                second argument.\n            \"\"\"\n\n        txt = \"checking file ids - using '%s'\" % self.filestatuschecker\n        self.logger.info(txt)\n\n        ids_cellpy_file = self._check_cellpy_file(cellpyfile)\n\n        self.logger.debug(f\"cellpyfile ids: {ids_cellpy_file}\")\n\n        if not ids_cellpy_file:\n            # self.logger.debug(\"hdf5 file does not exist - needs updating\")\n            return False\n\n        ids_raw = self._check_raw(rawfiles)\n        similar = self._compare_ids(ids_raw, ids_cellpy_file)\n\n        if not similar:\n            # self.logger.debug(\"hdf5 file needs updating\")\n            return False\n        else:\n            # self.logger.debug(\"hdf5 file is updated\")\n            return True"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget the file - ids for the res_files.", "response": "def _check_raw(self, file_names, abort_on_missing=False):\n        \"\"\"Get the file-ids for the res_files.\"\"\"\n\n        strip_file_names = True\n        check_on = self.filestatuschecker\n        if not self._is_listtype(file_names):\n            file_names = [file_names, ]\n\n        ids = dict()\n        for f in file_names:\n            self.logger.debug(f\"checking res file {f}\")\n            fid = FileID(f)\n            # self.logger.debug(fid)\n            if fid.name is None:\n                warnings.warn(f\"file does not exist: {f}\")\n                if abort_on_missing:\n                    sys.exit(-1)\n            else:\n                if strip_file_names:\n                    name = os.path.basename(f)\n                else:\n                    name = f\n                if check_on == \"size\":\n                    ids[name] = int(fid.size)\n                elif check_on == \"modified\":\n                    ids[name] = int(fid.last_modified)\n                else:\n                    ids[name] = int(fid.last_accessed)\n        return ids"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncheck the file - ids for the cellpy - file.", "response": "def _check_cellpy_file(self, filename):\n        \"\"\"Get the file-ids for the cellpy_file.\"\"\"\n\n        strip_filenames = True\n        check_on = self.filestatuschecker\n        self.logger.debug(\"checking cellpy-file\")\n        self.logger.debug(filename)\n        if not os.path.isfile(filename):\n            self.logger.debug(\"cellpy-file does not exist\")\n            return None\n        try:\n            store = pd.HDFStore(filename)\n        except Exception as e:\n            self.logger.debug(f\"could not open cellpy-file ({e})\")\n            return None\n        try:\n            fidtable = store.select(\"CellpyData/fidtable\")\n        except KeyError:\n            self.logger.warning(\"no fidtable -\"\n                                \" you should update your hdf5-file\")\n            fidtable = None\n        finally:\n            store.close()\n        if fidtable is not None:\n            raw_data_files, raw_data_files_length = \\\n                self._convert2fid_list(fidtable)\n            txt = \"contains %i res-files\" % (len(raw_data_files))\n            self.logger.debug(txt)\n            ids = dict()\n            for fid in raw_data_files:\n                full_name = fid.full_name\n                size = fid.size\n                mod = fid.last_modified\n                self.logger.debug(f\"fileID information for: {full_name}\")\n                self.logger.debug(f\"   modified: {mod}\")\n                self.logger.debug(f\"   size: {size}\")\n\n                if strip_filenames:\n                    name = os.path.basename(full_name)\n                else:\n                    name = full_name\n                if check_on == \"size\":\n                    ids[name] = int(fid.size)\n                elif check_on == \"modified\":\n                    ids[name] = int(fid.last_modified)\n                else:\n                    ids[name] = int(fid.last_accessed)\n            return ids\n        else:\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef loadcell(self, raw_files, cellpy_file=None, mass=None,\n                 summary_on_raw=False, summary_ir=True, summary_ocv=False,\n                 summary_end_v=True, only_summary=False, only_first=False,\n                 force_raw=False,\n                 use_cellpy_stat_file=None):\n\n        \"\"\"Loads data for given cells.\n\n        Args:\n            raw_files (list): name of res-files\n            cellpy_file (path): name of cellpy-file\n            mass (float): mass of electrode or active material\n            summary_on_raw (bool): use raw-file for summary\n            summary_ir (bool): summarize ir\n            summary_ocv (bool): summarize ocv steps\n            summary_end_v (bool): summarize end voltage\n            only_summary (bool): get only the summary of the runs\n            only_first (bool): only use the first file fitting search criteria\n            force_raw (bool): only use raw-files\n            use_cellpy_stat_file (bool): use stat file if creating summary\n                from raw\n\n        Example:\n\n            >>> srnos = my_dbreader.select_batch(\"testing_new_solvent\")\n            >>> cell_datas = []\n            >>> for srno in srnos:\n            >>> ... my_run_name = my_dbreader.get_cell_name(srno)\n            >>> ... mass = my_dbreader.get_mass(srno)\n            >>> ... rawfiles, cellpyfiles = \\\n            >>> ...     filefinder.search_for_files(my_run_name)\n            >>> ... cell_data = cellreader.CellpyData()\n            >>> ... cell_data.loadcell(raw_files=rawfiles,\n            >>> ...                    cellpy_file=cellpyfiles)\n            >>> ... cell_data.set_mass(mass)\n            >>> ... if not cell_data.summary_exists:\n            >>> ...     cell_data.make_summary() # etc. etc.\n            >>> ... cell_datas.append(cell_data)\n            >>>\n        \"\"\"\n\n        # This is a part of a dramatic API change. It will not be possible to\n        # load more than one set of datasets (i.e. one single cellpy-file or\n        # several raw-files that will be automatically merged)\n        self.logger.info(\"started loadcell\")\n        if cellpy_file is None:\n            similar = False\n        elif force_raw:\n            similar = False\n        else:\n            similar = self.check_file_ids(raw_files, cellpy_file)\n        self.logger.debug(\"checked if the files were similar\")\n\n        if only_summary:\n            self.load_only_summary = True\n        else:\n            self.load_only_summary = False\n\n        if not similar:\n            self.logger.info(\"cellpy file(s) needs updating - loading raw\")\n            self.logger.debug(raw_files)\n            self.from_raw(raw_files)\n            self.logger.debug(\"loaded files\")\n            # Check if the run was loaded ([] if empty)\n            if self.status_datasets:\n                if mass:\n                    self.set_mass(mass)\n                if summary_on_raw:\n                    self.make_summary(all_tests=False, find_ocv=summary_ocv,\n                                      find_ir=summary_ir,\n                                      find_end_voltage=summary_end_v,\n                                      use_cellpy_stat_file=use_cellpy_stat_file)\n            else:\n                self.logger.warning(\"Empty run!\")\n\n        else:\n            self.load(cellpy_file)\n        return self", "response": "Loads data for given cells."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef from_raw(self, file_names=None, **kwargs):\n        # This function only loads one test at a time (but could contain several\n        # files). The function from_res() also implements loading several\n        # datasets (using list of lists as input).\n\n        if file_names:\n            self.file_names = file_names\n\n        if not isinstance(file_names, (list, tuple)):\n            self.file_names = [file_names, ]\n\n        # file_type = self.tester\n        raw_file_loader = self.loader\n        set_number = 0\n        test = None\n        counter = 0\n        self.logger.debug(\"start iterating through file(s)\")\n        for f in self.file_names:\n            self.logger.debug(\"loading raw file:\")\n            self.logger.debug(f\"{f}\")\n            new_tests = raw_file_loader(f, **kwargs)\n            if new_tests:\n                if test is not None:\n                    self.logger.debug(\"continuing reading files...\")\n                    _test = self._append(test[set_number], new_tests[set_number])\n                    if not _test:\n                        self.logger.warning(f\"EMPTY TEST: {f}\")\n                        continue\n                    test[set_number] = _test\n                    self.logger.debug(\"added this test - started merging\")\n                    for j in range(len(new_tests[set_number].raw_data_files)):\n                        raw_data_file = new_tests[set_number].raw_data_files[j]\n                        file_size = new_tests[set_number].raw_data_files_length[j]\n                        test[set_number].raw_data_files.append(raw_data_file)\n                        test[set_number].raw_data_files_length.append(file_size)\n                        counter += 1\n                        if counter > 10:\n                            self.logger.debug(\"ERROR? Too many files to merge\")\n                            raise ValueError(\"Too many files to merge - \"\n                                             \"could be a p2-p3 zip thing\")\n                else:\n                    self.logger.debug(\"getting data from first file\")\n                    if new_tests[set_number].no_data:\n                        self.logger.debug(\"NO DATA\")\n                    else:\n                        test = new_tests\n            else:\n                self.logger.debug(\"NOTHING LOADED\")\n\n        self.logger.debug(\"finished loading the raw-files\")\n\n        test_exists = False\n        if test:\n            if test[0].no_data:\n                self.logging.debug(\"the first dataset (or only dataset) loaded from the raw data file is empty\")\n            else:\n                test_exists = True\n\n        if test_exists:\n            if not prms.Reader.sorted_data:\n                self.logger.debug(\"sorting data\")\n                test[set_number] = self._sort_data(test[set_number])\n\n            self.datasets.append(test[set_number])\n        else:\n            self.logger.warning(\"No new datasets added!\")\n        self.number_of_datasets = len(self.datasets)\n        self.status_datasets = self._validate_datasets()\n        self._invent_a_name()\n        return self", "response": "Load a single raw - file into the current object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning True if datasets exists and if one or more of the datasets are empty.", "response": "def check(self):\n        \"\"\"Returns False if no datasets exists or if one or more of the datasets\n        are empty\"\"\"\n\n        if len(self.status_datasets) == 0:\n            return False\n        if all(self.status_datasets):\n            return True\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef load(self, cellpy_file, parent_level=\"CellpyData\"):\n\n        try:\n            self.logger.debug(\"loading cellpy-file (hdf5):\")\n            self.logger.debug(cellpy_file)\n            new_datasets = self._load_hdf5(cellpy_file, parent_level)\n            self.logger.debug(\"cellpy-file loaded\")\n        except AttributeError:\n            new_datasets = []\n            self.logger.warning(\"This cellpy-file version is not supported by\"\n                                \"current reader (try to update cellpy).\")\n\n        if new_datasets:\n            for dataset in new_datasets:\n                self.datasets.append(dataset)\n        else:\n            # raise LoadError\n            self.logger.warning(\"Could not load\")\n            self.logger.warning(str(cellpy_file))\n\n        self.number_of_datasets = len(self.datasets)\n        self.status_datasets = self._validate_datasets()\n        self._invent_a_name(cellpy_file)\n        return self", "response": "Loads a cellpy file into the internal state."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nloads a cellpy - file into a set of objects.", "response": "def _load_hdf5(self, filename, parent_level=\"CellpyData\"):\n        \"\"\"Load a cellpy-file.\n\n        Args:\n            filename (str): Name of the cellpy file.\n            parent_level (str) (optional): name of the parent level\n                (defaults to \"CellpyData\")\n\n        Returns:\n            loaded datasets (DataSet-object)\n        \"\"\"\n\n        if not os.path.isfile(filename):\n            self.logger.info(f\"file does not exist: {filename}\")\n            raise IOError\n        store = pd.HDFStore(filename)\n\n        # required_keys = ['dfdata', 'dfsummary', 'fidtable', 'info']\n        required_keys = ['dfdata', 'dfsummary', 'info']\n        required_keys = [\"/\" + parent_level + \"/\" + _ for _ in required_keys]\n\n        for key in required_keys:\n            if key not in store.keys():\n                self.logger.info(f\"This hdf-file is not good enough - \"\n                                 f\"at least one key is missing: {key}\")\n                raise Exception(f\"OH MY GOD! At least one crucial key\"\n                                f\"is missing {key}!\")\n\n        self.logger.debug(f\"Keys in current hdf5-file: {store.keys()}\")\n        data = DataSet()\n\n        if parent_level != \"CellpyData\":\n            self.logger.debug(\"Using non-default parent label for the \"\n                              \"hdf-store: {}\".format(parent_level))\n\n        # checking file version\n        infotable = store.select(parent_level + \"/info\")\n        try:\n            data.cellpy_file_version = \\\n                self._extract_from_dict(infotable, \"cellpy_file_version\")\n        except Exception as e:\n            data.cellpy_file_version = 0\n            warnings.warn(f\"Unhandled exception raised: {e}\")\n\n        if data.cellpy_file_version < MINIMUM_CELLPY_FILE_VERSION:\n            raise WrongFileVersion\n\n        if data.cellpy_file_version > CELLPY_FILE_VERSION:\n            raise WrongFileVersion\n\n        data.dfsummary = store.select(parent_level + \"/dfsummary\")\n        data.dfdata = store.select(parent_level + \"/dfdata\")\n\n        try:\n            data.step_table = store.select(parent_level + \"/step_table\")\n        except Exception as e:\n            self.logging.debug(\"could not get step_table from cellpy-file\")\n            data.step_table = pd.DataFrame()\n            warnings.warn(f\"Unhandled exception raised: {e}\")\n\n        try:\n            fidtable = store.select(\n                parent_level + \"/fidtable\")  # remark! changed spelling from\n            # lower letter to camel-case!\n            fidtable_selected = True\n        except Exception as e:\n            self.logging.debug(\"could not get fid-table from cellpy-file\")\n            fidtable = []\n\n            warnings.warn(\"no fidtable - you should update your hdf5-file\")\n            fidtable_selected = False\n        self.logger.debug(\"  h5\")\n        # this does not yet allow multiple sets\n\n        newtests = []  # but this is ready when that time comes\n\n        # The infotable stores \"meta-data\". The follwing statements loads the\n        # content of infotable and updates div. DataSet attributes.\n        # Maybe better use it as dict?\n\n        data = self._load_infotable(data, infotable, filename)\n\n        if fidtable_selected:\n            data.raw_data_files, data.raw_data_files_length = \\\n                self._convert2fid_list(fidtable)\n        else:\n            data.raw_data_files = None\n            data.raw_data_files_length = None\n        newtests.append(data)\n        store.close()\n        # self.datasets.append(data)\n        return newtests"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef merge(self, datasets=None, separate_datasets=False):\n        self.logger.info(\"merging\")\n        if separate_datasets:\n            warnings.warn(\"The option seperate_datasets=True is\"\n                          \"not implemented yet. Performing merging, but\"\n                          \"neglecting the option.\")\n        else:\n            if datasets is None:\n                datasets = list(range(len(self.datasets)))\n            first = True\n            for dataset_number in datasets:\n                if first:\n                    dataset = self.datasets[dataset_number]\n                    first = False\n                else:\n                    dataset = self._append(dataset, self.datasets[dataset_number])\n                    for raw_data_file, file_size in zip(self.datasets[dataset_number].raw_data_files,\n                                                        self.datasets[dataset_number].raw_data_files_length):\n                        dataset.raw_data_files.append(raw_data_file)\n                        dataset.raw_data_files_length.append(file_size)\n            self.datasets = [dataset]\n            self.number_of_datasets = 1\n        return self", "response": "This function merges datasets into one set."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef print_step_table(self, dataset_number=None):\n        dataset_number = self._validate_dataset_number(dataset_number)\n        if dataset_number is None:\n            self._report_empty_dataset()\n            return\n        st = self.datasets[dataset_number].step_table\n        print(st)", "response": "Print the step table."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_step_numbers(self, steptype='charge', allctypes=True, pdtype=False,\n                         cycle_number=None, dataset_number=None,\n                         steptable=None):\n        # TODO: @jepe - include sub_steps here\n        \"\"\"Get the step numbers of selected type.\n\n        Returns the selected step_numbers for the  elected type of step(s).\n\n        Args:\n            steptype (string): string identifying type of step.\n            allctypes (bool): get all types of charge (or discharge).\n            pdtype (bool): return results as pandas.DataFrame\n            cycle_number (int): selected cycle, selects all if not set.\n            dataset_number (int): test number (default first)\n                (usually not used).\n            steptable (pandas.DataFrame): optional steptable\n\n        Returns:\n            A dictionary containing a list of step numbers corresponding\n                to the selected steptype for the cycle(s).\n            Returns a pandas.DataFrame instead of a dict of lists if pdtype is\n                set to True. The frame is a sub-set of the step-table frame\n                (i.e. all the same columns, only filtered by rows).\n\n        Example:\n            >>> my_charge_steps = CellpyData.get_step_numbers(\n            >>>    \"charge\",\n            >>>    cycle_number = 3\n            >>> )\n            >>> print my_charge_steps\n            {3: [5,8]}\n\n        \"\"\"\n        # self.logger.debug(\"Trying to get step-types\")\n        if steptable is None:\n            dataset_number = self._validate_dataset_number(dataset_number)\n            if dataset_number is None:\n                self._report_empty_dataset()\n                return\n\n            if not self.datasets[dataset_number].step_table_made:\n                self.logger.debug(\"step_table is not made\")\n\n                if self.force_step_table_creation or self.force_all:\n                    self.logger.debug(\"creating step_table for\")\n                    self.logger.debug(self.datasets[dataset_number].loaded_from)\n                    # print \"CREAING STEP-TABLE\"\n                    self.make_step_table(dataset_number=dataset_number)\n\n                else:\n                    self.logger.info(\"ERROR! Cannot use get_steps: \"\n                                     \"create step_table first\")\n                    self.logger.info(\" you could use find_step_numbers\"\n                                     \" method instead\")\n                    self.logger.info(\" (but I don't recommend it)\")\n                    return None\n\n        # check if steptype is valid\n        steptype = steptype.lower()\n        steptypes = []\n        helper_step_types = ['ocv', 'charge_discharge']\n        valid_step_type = True\n        if steptype in self.list_of_step_types:\n            steptypes.append(steptype)\n        else:\n            txt = \"%s is not a valid core steptype\" % steptype\n            if steptype in helper_step_types:\n                txt = \"but a helper steptype\"\n                if steptype == 'ocv':\n                    steptypes.append('ocvrlx_up')\n                    steptypes.append('ocvrlx_down')\n                elif steptype == 'charge_discharge':\n                    steptypes.append('charge')\n                    steptypes.append('discharge')\n            else:\n                valid_step_type = False\n            self.logger.debug(txt)\n        if not valid_step_type:\n            return None\n\n        # in case of selection allctypes, then modify charge, discharge\n        if allctypes:\n            add_these = []\n            for st in steptypes:\n                if st in ['charge', 'discharge']:\n                    st1 = st + '_cv'\n                    add_these.append(st1)\n                    st1 = 'cv_' + st\n                    add_these.append(st1)\n            for st in add_these:\n                steptypes.append(st)\n\n        # self.logger.debug(\"Your steptypes:\")\n        # self.logger.debug(steptypes)\n\n        if steptable is None:\n            st = self.datasets[dataset_number].step_table\n        else:\n            st = steptable\n        shdr = self.headers_step_table\n\n        # retrieving cycle numbers\n        if cycle_number is None:\n            cycle_numbers = self.get_cycle_numbers(\n                dataset_number,\n                steptable=steptable\n            )\n\n        else:\n            if isinstance(cycle_number, (list, tuple)):\n                cycle_numbers = cycle_number\n            else:\n                cycle_numbers = [cycle_number, ]\n\n        if pdtype:\n            self.logger.debug(\"return pandas dataframe\")\n            out = st[st[shdr.type].isin(steptypes) &\n                     st[shdr.cycle].isin(cycle_numbers)]\n            return out\n\n        # if not pdtype, return a dict instead\n        # self.logger.debug(\"out as dict; out[cycle] = [s1,s2,...]\")\n        # self.logger.debug(\"(same behaviour as find_step_numbers)\")\n        self.logger.debug(\"return dict of lists\")\n        out = dict()\n        for cycle in cycle_numbers:\n            steplist = []\n            for s in steptypes:\n                step = st[(st[shdr.type] == s) &\n                          (st[shdr.cycle] == cycle)][shdr.step].tolist()\n                for newstep in step:\n                    steplist.append(int(newstep))\n                    # int(step.iloc[0])\n                    # self.is_empty(steps)\n            if not steplist:\n                steplist = [0]\n            out[cycle] = steplist\n        return out", "response": "Get the step numbers of a given type of step."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef load_step_specifications(self, file_name, short=False,\n                                 dataset_number=None):\n        \"\"\" Load a table that contains step-type definitions.\n\n        This function loads a file containing a specification for each step or\n        for each (cycle_number, step_number) combinations if short==False. The\n        step_cycle specifications that are allowed are stored in the variable\n        cellreader.list_of_step_types.\n        \"\"\"\n\n        dataset_number = self._validate_dataset_number(dataset_number)\n        if dataset_number is None:\n            self._report_empty_dataset()\n            return\n\n        # if short:\n        #     # the table only consists of steps (not cycle,step pairs) assuming\n        #     # that the step numbers uniquely defines step type (this is true\n        #     # for arbin at least).\n        #     raise NotImplementedError\n\n        step_specs = pd.read_csv(file_name, sep=prms.Reader.sep)\n        if \"step\" not in step_specs.columns:\n            self.logger.info(\"step col is missing\")\n            raise IOError\n\n        if \"type\" not in step_specs.columns:\n            self.logger.info(\"type col is missing\")\n            raise IOError\n\n        if not short and \"cycle\" not in step_specs.columns:\n            self.logger.info(\"cycle col is missing\")\n            raise IOError\n\n        self.make_step_table(custom_step_definition=True,\n                             step_specifications=step_specs,\n                             short=short)", "response": "Load a table containing step - type definitions."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncreates a table that contains summary information for each step.", "response": "def make_step_table(self, custom_step_definition=False,\n                        step_specifications=None,\n                        short=False,\n                        dataset_number=None):\n\n        \"\"\" Create a table (v.4) that contains summary information for each step.\n\n        This function creates a table containing information about the\n        different steps for each cycle and, based on that, decides what type of\n        step it is (e.g. charge) for each cycle.\n\n        The format of the step_table is:\n\n            index: cycleno - stepno - sub-step-no\n            Logging info (average, stdev, max, min, start, end, delta) -\n            Current info (average, stdev, max, min, start, end, delta) -\n            Voltage info (average,  stdev, max, min, start, end, delta) -\n            Type (from pre-defined list) - SubType -\n            Info\n        \"\"\"\n        time_00 = time.time()\n        dataset_number = self._validate_dataset_number(dataset_number)\n        if dataset_number is None:\n            self._report_empty_dataset()\n            return\n\n        nhdr = self.headers_normal\n        shdr = self.headers_step_table\n\n        df = self.datasets[dataset_number].dfdata\n        # df[shdr.internal_resistance_change] = \\\n        #     df[nhdr.internal_resistance_txt].pct_change()\n\n        def first(x):\n            return x.iloc[0]\n\n        def last(x):\n            return x.iloc[-1]\n\n        def delta(x):\n            if x.iloc[0] == 0.0:\n                # starts from a zero value\n                difference = 100.0 * x.iloc[-1]\n            else:\n                difference = (x.iloc[-1] - x.iloc[0]) * 100 / x.iloc[0]\n\n            return difference\n\n        keep = [\n            nhdr.data_point_txt,\n            nhdr.step_time_txt,\n            nhdr.step_index_txt,\n            nhdr.cycle_index_txt,\n            nhdr.current_txt,\n            nhdr.voltage_txt,\n            nhdr.ref_voltage_txt,\n            nhdr.charge_capacity_txt,\n            nhdr.discharge_capacity_txt,\n            nhdr.internal_resistance_txt,\n            # \"ir_pct_change\"\n        ]\n\n        # only use col-names that exist:\n        keep = [col for col in keep if col in df.columns]\n\n        df = df[keep]\n        df[nhdr.sub_step_index_txt] = 1\n        rename_dict = {\n            nhdr.cycle_index_txt: shdr.cycle,\n            nhdr.step_index_txt: shdr.step,\n            nhdr.sub_step_index_txt: shdr.sub_step,\n            nhdr.data_point_txt: shdr.point,\n            nhdr.step_time_txt: shdr.step_time,\n            nhdr.current_txt: shdr.current,\n            nhdr.voltage_txt: shdr.voltage,\n            nhdr.charge_capacity_txt: shdr.charge,\n            nhdr.discharge_capacity_txt: shdr.discharge,\n            nhdr.internal_resistance_txt: shdr.internal_resistance,\n        }\n\n        df = df.rename(columns=rename_dict)\n\n        by = [shdr.cycle, shdr.step, shdr.sub_step]\n\n        self.logger.debug(f\"groupby: {by}\")\n\n        gf = df.groupby(by=by)\n        df_steps = (gf.agg(\n            [np.mean, np.std, np.amin, np.amax, first, last, delta]\n        ).rename(columns={'amin': 'min', 'amax': 'max', 'mean': 'avr'}))\n\n        df_steps = df_steps.reset_index()\n\n        df_steps[shdr.type] = np.nan\n        df_steps[shdr.sub_type] = np.nan\n        df_steps[shdr.info] = np.nan\n\n        current_limit_value_hard = self.raw_limits[\"current_hard\"]\n        current_limit_value_soft = self.raw_limits[\"current_soft\"]\n        stable_current_limit_hard = self.raw_limits[\"stable_current_hard\"]\n        stable_current_limit_soft = self.raw_limits[\"stable_current_soft\"]\n        stable_voltage_limit_hard = self.raw_limits[\"stable_voltage_hard\"]\n        stable_voltage_limit_soft = self.raw_limits[\"stable_voltage_soft\"]\n        stable_charge_limit_hard = self.raw_limits[\"stable_charge_hard\"]\n        stable_charge_limit_soft = self.raw_limits[\"stable_charge_soft\"]\n        ir_change_limit = self.raw_limits[\"ir_change\"]\n\n        mask_no_current_hard = (\n            df_steps.loc[:, (shdr.current, \"max\")].abs()\n            + df_steps.loc[:, (shdr.current, \"min\")].abs()\n        ) < current_limit_value_hard\n\n        mask_voltage_down = df_steps.loc[:, (shdr.voltage, \"delta\")] < \\\n            - stable_voltage_limit_hard\n\n        mask_voltage_up = df_steps.loc[:, (shdr.voltage, \"delta\")] > \\\n            stable_voltage_limit_hard\n\n        mask_voltage_stable = df_steps.loc[:, (shdr.voltage, \"delta\")].abs() < \\\n            stable_voltage_limit_hard\n\n        mask_current_down = df_steps.loc[:, (shdr.current, \"delta\")] < \\\n            - stable_current_limit_soft\n\n        mask_current_up = df_steps.loc[:, (shdr.current, \"delta\")] > \\\n            stable_current_limit_soft\n\n        mask_current_negative = df_steps.loc[:, (shdr.current, \"avr\")] < \\\n            - current_limit_value_hard\n\n        mask_current_positive = df_steps.loc[:, (shdr.current, \"avr\")] > \\\n            current_limit_value_hard\n\n        mask_galvanostatic = df_steps.loc[:, (shdr.current, \"delta\")].abs() < \\\n            stable_current_limit_soft\n\n        mask_charge_changed = df_steps.loc[:, (shdr.charge, \"delta\")].abs() > \\\n            stable_charge_limit_hard\n\n        mask_discharge_changed = df_steps.loc[:, (shdr.discharge, \"delta\")].abs() > \\\n            stable_charge_limit_hard\n\n        mask_no_change = (df_steps.loc[:, (shdr.voltage, \"delta\")] == 0) & \\\n            (df_steps.loc[:, (shdr.current, \"delta\")] == 0) & \\\n            (df_steps.loc[:, (shdr.charge, \"delta\")] == 0) & \\\n            (df_steps.loc[:, (shdr.charge, \"delta\")] == 0)\n\n        if custom_step_definition:\n            self.logger.debug(\"parsing custom step definition\")\n            if not short:\n                self.logger.debug(\"using long format (cycle,step)\")\n                for row in step_specifications.itertuples():\n                    # self.logger.debug(f\"cycle: {row.cycle} step: {row.step}\"\n                    #                   f\" type: {row.type}\")\n                    df_steps.loc[(df_steps[shdr.step] == row.step) &\n                                 (df_steps[shdr.cycle] == row.cycle),\n                                 \"type\"] = row.type\n                    df_steps.loc[(df_steps[shdr.step] == row.step) &\n                                 (df_steps[shdr.cycle] == row.cycle),\n                                 \"info\"] = row.info\n            else:\n                self.logger.debug(\"using short format (step)\")\n                for row in step_specifications.itertuples():\n                    # self.logger.debug(f\"step: {row.step} \"\n                    #                   f\"type: {row.type}\"\n                    #                   f\"info: {row.info}\")\n\n                    df_steps.loc[df_steps[shdr.step] == row.step,\n                                 \"type\"] = row.type\n                    df_steps.loc[df_steps[shdr.step] == row.step,\n                                 \"info\"] = row.info\n\n        else:\n            self.logger.debug(\"masking and labelling steps\")\n            df_steps.loc[mask_no_current_hard & mask_voltage_stable,\n                         shdr.type] = 'rest'\n\n            df_steps.loc[mask_no_current_hard & mask_voltage_up,\n                         shdr.type] = 'ocvrlx_up'\n\n            df_steps.loc[mask_no_current_hard & mask_voltage_down,\n                         shdr.type] = 'ocvrlx_down'\n\n            df_steps.loc[mask_discharge_changed & mask_current_negative,\n                         shdr.type] = 'discharge'\n\n            df_steps.loc[mask_charge_changed & mask_current_positive,\n                         shdr.type] = 'charge'\n\n            df_steps.loc[\n                mask_voltage_stable & mask_current_negative & mask_current_down,\n                shdr.type\n            ] = 'cv_discharge'\n\n            df_steps.loc[mask_voltage_stable & mask_current_positive &\n                         mask_current_down, shdr.type] = 'cv_charge'\n\n            # --- internal resistance ----\n            df_steps.loc[mask_no_change, shdr.type] = 'ir'\n            # assumes that IR is stored in just one row\n\n            # --- sub-step-txt -----------\n            df_steps[shdr.sub_type] = None\n\n            # --- CV steps ----\n\n            # \"voltametry_charge\"\n            # mask_charge_changed\n            # mask_voltage_up\n            # (could also include abs-delta-cumsum current)\n\n            # \"voltametry_discharge\"\n            # mask_discharge_changed\n            # mask_voltage_down\n\n        # check if all the steps got categorizes\n        self.logger.debug(\"looking for un-categorized steps\")\n        empty_rows = df_steps.loc[df_steps[shdr.type].isnull()]\n        if not empty_rows.empty:\n            logging.warning(\n                f\"found {len(empty_rows)}\"\n                f\":{len(df_steps)} non-categorized steps \"\n                f\"(please, check your raw-limits)\")\n\n        # flatten (possible remove in the future),\n        # (maybe we will implement mulitindexed tables)\n\n        self.logger.debug(f\"flatten columns\")\n        flat_cols = []\n        for col in df_steps.columns:\n            if isinstance(col, tuple):\n                if col[-1]:\n                    col = \"_\".join(col)\n                else:\n                    col = col[0]\n            flat_cols.append(col)\n\n        df_steps.columns = flat_cols\n\n        self.datasets[dataset_number].step_table = df_steps\n        self.logger.debug(f\"(dt: {(time.time() - time_00):4.2f}s)\")\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef to_csv(self, datadir=None, sep=None, cycles=False, raw=True,\n               summary=True, shifted=False,\n               method=None, shift=0.0,\n               last_cycle=None):\n        \"\"\"Saves the data as .csv file(s).\n\n        Args:\n            datadir: folder where to save the data (uses current folder if not\n                given).\n            sep: the separator to use in the csv file\n                (defaults to CellpyData.sep).\n            cycles: (bool) export voltage-capacity curves if True.\n            raw: (bool) export raw-data if True.\n            summary: (bool) export summary if True.\n            shifted (bool): export with cumulated shift.\n            method (string): how the curves are given\n                \"back-and-forth\" - standard back and forth; discharge\n                    (or charge) reversed from where charge (or\n                    discharge) ends.\n                \"forth\" - discharge (or charge) continues along x-axis.\n                \"forth-and-forth\" - discharge (or charge) also starts at 0 (or\n                    shift if not shift=0.0)\n            shift: start-value for charge (or discharge)\n            last_cycle: process only up to this cycle (if not None).\n\n        Returns: Nothing\n\n        \"\"\"\n\n        if sep is None:\n            sep = self.sep\n\n        self.logger.debug(\"saving to csv\")\n\n        dataset_number = -1\n        for data in self.datasets:\n            dataset_number += 1\n            if not self._is_not_empty_dataset(data):\n                self.logger.info(\"to_csv -\")\n                self.logger.info(\"empty test [%i]\" % dataset_number)\n                self.logger.info(\"not saved!\")\n            else:\n                if isinstance(data.loaded_from, (list, tuple)):\n                    txt = \"merged file\"\n                    txt += \"using first file as basename\"\n                    self.logger.debug(txt)\n                    no_merged_sets = len(data.loaded_from)\n                    no_merged_sets = \"_merged_\" + str(no_merged_sets).zfill(3)\n                    filename = data.loaded_from[0]\n                else:\n                    filename = data.loaded_from\n                    no_merged_sets = \"\"\n                firstname, extension = os.path.splitext(filename)\n                firstname += no_merged_sets\n                if datadir:\n                    firstname = os.path.join(datadir,\n                                             os.path.basename(firstname))\n\n                if raw:\n                    outname_normal = firstname + \"_normal.csv\"\n                    self._export_normal(data, outname=outname_normal, sep=sep)\n                    if data.step_table_made is True:\n                        outname_steps = firstname + \"_steps.csv\"\n                        self._export_steptable(data, outname=outname_steps,\n                                               sep=sep)\n                    else:\n                        self.logger.debug(\"step_table_made is not True\")\n\n                if summary:\n                    outname_stats = firstname + \"_stats.csv\"\n                    self._export_stats(data, outname=outname_stats, sep=sep)\n\n                if cycles:\n                    outname_cycles = firstname + \"_cycles.csv\"\n                    self._export_cycles(outname=outname_cycles,\n                                        dataset_number=dataset_number,\n                                        sep=sep, shifted=shifted,\n                                        method=method, shift=shift,\n                                        last_cycle=last_cycle)", "response": "Saves the data in the cellpy data file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef save(self, filename, dataset_number=None, force=False, overwrite=True,\n             extension=\"h5\", ensure_step_table=None):\n        \"\"\"Save the data structure to cellpy-format.\n\n        Args:\n            filename: (str) the name you want to give the file\n            dataset_number: (int) if you have several datasets, chose the one\n                you want (probably leave this untouched)\n            force: (bool) save a file even if the summary is not made yet\n                (not recommended)\n            overwrite: (bool) save the new version of the file even if old one\n                exists.\n            extension: (str) filename extension.\n            ensure_step_table: (bool) make step-table if missing.\n\n        Returns: Nothing at all.\n        \"\"\"\n        if ensure_step_table is None:\n            ensure_step_table = self.ensure_step_table\n\n        dataset_number = self._validate_dataset_number(dataset_number)\n        if dataset_number is None:\n            self.logger.info(\"Saving test failed!\")\n            self._report_empty_dataset()\n            return\n\n        test = self.get_dataset(dataset_number)\n\n        dfsummary_made = test.dfsummary_made\n\n        if not dfsummary_made and not force:\n            self.logger.info(\n                \"You should not save datasets \"\n                \"without making a summary first!\"\n            )\n            self.logger.info(\n                \"If you really want to do it, \"\n                \"use save with force=True\"\n            )\n            return\n\n        step_table_made = test.step_table_made\n\n        if not step_table_made and not force and not ensure_step_table:\n            self.logger.info(\n                \"You should not save datasets \"\n                \"without making a step-table first!\"\n            )\n            self.logger.info(\n                \"If you really want to do it, \"\n                \"use save with force=True\"\n            )\n            return\n\n        if not os.path.splitext(filename)[-1]:\n            outfile_all = filename + \".\" + extension\n        else:\n            outfile_all = filename\n\n        if os.path.isfile(outfile_all):\n            self.logger.debug(\"Outfile exists\")\n            if overwrite:\n                self.logger.debug(\"overwrite = True\")\n                os.remove(outfile_all)\n            else:\n                self.logger.info(\n                    \"save (hdf5): file exist - did not save\",\n                    end=' '\n                )\n                self.logger.info(outfile_all)\n                return\n\n        if ensure_step_table:\n            self.logger.debug(\"ensure_step_table is on\")\n            if not test.step_table_made:\n                self.logger.debug(\"save: creating step table\")\n                self.make_step_table(dataset_number=dataset_number)\n\n        # This method can probalby be updated using pandas transpose trick\n        self.logger.debug(\"trying to make infotable\")\n        infotbl, fidtbl = self._create_infotable(\n            dataset_number=dataset_number\n        )\n        root = prms._cellpyfile_root\n\n        self.logger.debug(\"trying to save to hdf5\")\n        txt = \"\\nHDF5 file: %s\" % outfile_all\n        self.logger.debug(txt)\n\n        warnings.simplefilter(\"ignore\", PerformanceWarning)\n        try:\n            store = pd.HDFStore(\n                outfile_all,\n                complib=prms._cellpyfile_complib,\n                complevel=prms._cellpyfile_complevel,\n            )\n\n            self.logger.debug(\"trying to put dfdata\")\n\n            self.logger.debug(\" - lets set Data_Point as index\")\n            hdr_data_point = self.headers_normal.data_point_txt\n            test.dfdata = test.dfdata.set_index(hdr_data_point,\n                                                drop=False)\n\n            store.put(root + \"/dfdata\", test.dfdata,\n                      format=prms._cellpyfile_dfdata_format)\n            self.logger.debug(\" dfdata -> hdf5 OK\")\n\n            self.logger.debug(\"trying to put dfsummary\")\n            store.put(root + \"/dfsummary\", test.dfsummary,\n                      format=prms._cellpyfile_dfsummary_format)\n            self.logger.debug(\" dfsummary -> hdf5 OK\")\n\n            self.logger.debug(\"trying to put infotbl\")\n            store.put(root + \"/info\", infotbl,\n                      format=prms._cellpyfile_infotable_format)\n            self.logger.debug(\" infotable -> hdf5 OK\")\n\n            self.logger.debug(\"trying to put fidtable\")\n            store.put(root + \"/fidtable\", fidtbl,\n                      format=prms._cellpyfile_fidtable_format)\n            self.logger.debug(\" fidtable -> hdf5 OK\")\n\n            self.logger.debug(\"trying to put step_table\")\n            try:\n                store.put(root + \"/step_table\", test.step_table,\n                          format=prms._cellpyfile_stepdata_format)\n                self.logger.debug(\" step_table -> hdf5 OK\")\n            except TypeError:\n                test = self._fix_dtype_step_table(test)\n                store.put(root + \"/step_table\", test.step_table,\n                          format=prms._cellpyfile_stepdata_format)\n                self.logger.debug(\" fixed step_table -> hdf5 OK\")\n\n            # creating indexes\n            # hdr_data_point = self.headers_normal.data_point_txt\n            # hdr_cycle_steptable = self.headers_step_table.cycle\n            # hdr_cycle_normal = self.headers_normal.cycle_index_txt\n\n            # store.create_table_index(root + \"/dfdata\", columns=[hdr_data_point],\n            #                          optlevel=9, kind='full')\n        finally:\n            store.close()\n        self.logger.debug(\" all -> hdf5 OK\")\n        warnings.simplefilter(\"default\", PerformanceWarning)", "response": "Save the data structure to a file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef sget_voltage(self, cycle, step, set_number=None):\n\n        time_00 = time.time()\n        set_number = self._validate_dataset_number(set_number)\n        if set_number is None:\n            self._report_empty_dataset()\n            return\n        cycle_index_header = self.headers_normal.cycle_index_txt\n        voltage_header = self.headers_normal.voltage_txt\n        step_index_header = self.headers_normal.step_index_txt\n        test = self.datasets[set_number].dfdata\n\n        if isinstance(step, (list, tuple)):\n            warnings.warn(f\"The varialbe step is a list.\"\n                          f\"Should be an integer.\"\n                          f\"{step}\")\n            step = step[0]\n\n        c = test[(test[cycle_index_header] == cycle) &\n                 (test[step_index_header] == step)]\n\n        self.logger.debug(f\"(dt: {(time.time() - time_00):4.2f}s)\")\n        if not self.is_empty(c):\n            v = c[voltage_header]\n            return v\n        else:\n            return None", "response": "Returns the voltage for a cycle step."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_voltage(self, cycle=None, dataset_number=None, full=True):\n\n        dataset_number = self._validate_dataset_number(dataset_number)\n        if dataset_number is None:\n            self._report_empty_dataset()\n            return\n        cycle_index_header = self.headers_normal.cycle_index_txt\n        voltage_header = self.headers_normal.voltage_txt\n        # step_index_header  = self.headers_normal.step_index_txt\n\n        test = self.datasets[dataset_number].dfdata\n        if cycle:\n            self.logger.debug(\"getting voltage curve for cycle\")\n            c = test[(test[cycle_index_header] == cycle)]\n            if not self.is_empty(c):\n                v = c[voltage_header]\n                return v\n        else:\n            if not full:\n                self.logger.debug(\n                    \"getting list of voltage-curves for all cycles\"\n                )\n                v = []\n                no_cycles = np.amax(test[cycle_index_header])\n                for j in range(1, no_cycles + 1):\n                    txt = \"Cycle  %i:  \" % j\n                    self.logger.debug(txt)\n                    c = test[(test[cycle_index_header] == j)]\n                    v.append(c[voltage_header])\n            else:\n                self.logger.debug(\"getting frame of all voltage-curves\")\n                v = test[voltage_header]\n            return v", "response": "Returns the voltage of the current cycle."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the current in mA.", "response": "def get_current(self, cycle=None, dataset_number=None, full=True):\n        \"\"\"Returns current (in mA).\n\n        Args:\n            cycle: cycle number (all cycles if None)\n            dataset_number: first dataset if None\n            full: valid only for cycle=None (i.e. all cycles), returns the full\n               pandas.Series if True, else a list of pandas.Series\n\n        Returns:\n            pandas.Series (or list of pandas.Series if cycle=None og full=False)\n        \"\"\"\n\n        dataset_number = self._validate_dataset_number(dataset_number)\n        if dataset_number is None:\n            self._report_empty_dataset()\n            return\n        cycle_index_header = self.headers_normal.cycle_index_txt\n        current_header = self.headers_normal.current_txt\n        # step_index_header  = self.headers_normal.step_index_txt\n\n        test = self.datasets[dataset_number].dfdata\n        if cycle:\n            self.logger.debug(f\"getting current for cycle {cycle}\")\n            c = test[(test[cycle_index_header] == cycle)]\n            if not self.is_empty(c):\n                v = c[current_header]\n                return v\n        else:\n            if not full:\n                self.logger.debug(\n                    \"getting a list of current-curves for all cycles\"\n                )\n                v = []\n                no_cycles = np.amax(test[cycle_index_header])\n                for j in range(1, no_cycles + 1):\n                    txt = \"Cycle  %i:  \" % j\n                    self.logger.debug(txt)\n                    c = test[(test[cycle_index_header] == j)]\n                    v.append(c[current_header])\n            else:\n                self.logger.debug(\"getting all current-curves \")\n                v = test[current_header]\n            return v"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef sget_steptime(self, cycle, step, dataset_number=None):\n\n        dataset_number = self._validate_dataset_number(dataset_number)\n        if dataset_number is None:\n            self._report_empty_dataset()\n            return\n        cycle_index_header = self.headers_normal.cycle_index_txt\n        step_time_header = self.headers_normal.step_time_txt\n        step_index_header = self.headers_normal.step_index_txt\n        test = self.datasets[dataset_number].dfdata\n\n        if isinstance(step, (list, tuple)):\n            warnings.warn(f\"The varialbe step is a list.\"\n                          f\"Should be an integer.\"\n                          f\"{step}\")\n            step = step[0]\n\n        c = test.loc[\n            (test[cycle_index_header] == cycle) &\n            (test[step_index_header] == step), :\n        ]\n\n        if not self.is_empty(c):\n            t = c[step_time_header]\n            return t\n        else:\n            return None", "response": "Returns step time for cycle step."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the timestamp for cycle step.", "response": "def sget_timestamp(self, cycle, step, dataset_number=None):\n        \"\"\"Returns timestamp for cycle, step.\n\n        Convinience function; same as issuing\n           dfdata[(dfdata[cycle_index_header] == cycle) &\n                 (dfdata[step_index_header] == step)][timestamp_header]\n\n        Args:\n            cycle: cycle number\n            step: step number\n            dataset_number: the dataset number (automatic selection if None)\n\n        Returns:\n            pandas.Series\n        \"\"\"\n\n        dataset_number = self._validate_dataset_number(dataset_number)\n        if dataset_number is None:\n            self._report_empty_dataset()\n            return\n        cycle_index_header = self.headers_normal.cycle_index_txt\n        timestamp_header = self.headers_normal.test_time_txt\n        step_index_header = self.headers_normal.step_index_txt\n        test = self.datasets[dataset_number].dfdata\n\n        if isinstance(step, (list, tuple)):\n            warnings.warn(f\"The varialbe step is a list.\"\n                          f\"Should be an integer.\"\n                          f\"{step}\")\n            step = step[0]\n\n        c = test[(test[cycle_index_header] == cycle) &\n                 (test[step_index_header] == step)]\n        if not self.is_empty(c):\n            t = c[timestamp_header]\n            return t\n        else:\n            return pd.Series()"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the timestamps in sec or minutes for a given cycle.", "response": "def get_timestamp(self, cycle=None, dataset_number=None,\n                      in_minutes=False, full=True):\n        \"\"\"Returns timestamps (in sec or minutes (if in_minutes==True)).\n\n        Args:\n            cycle: cycle number (all if None)\n            dataset_number: first dataset if None\n            in_minutes: return values in minutes instead of seconds if True\n            full: valid only for cycle=None (i.e. all cycles), returns the full\n               pandas.Series if True, else a list of pandas.Series\n\n        Returns:\n            pandas.Series (or list of pandas.Series if cycle=None og full=False)\n        \"\"\"\n\n        dataset_number = self._validate_dataset_number(dataset_number)\n        if dataset_number is None:\n            self._report_empty_dataset()\n            return\n        cycle_index_header = self.headers_normal.cycle_index_txt\n        timestamp_header = self.headers_normal.test_time_txt\n\n        v = pd.Series()\n        test = self.datasets[dataset_number].dfdata\n        if cycle:\n            c = test[(test[cycle_index_header] == cycle)]\n            if not self.is_empty(c):\n                v = c[timestamp_header]\n\n        else:\n            if not full:\n                self.logger.debug(\"getting timestapm for all cycles\")\n                v = []\n                no_cycles = np.amax(test[cycle_index_header])\n                for j in range(1, no_cycles + 1):\n                    txt = \"Cycle  %i:  \" % j\n                    self.logger.debug(txt)\n                    c = test[(test[cycle_index_header] == j)]\n                    v.append(c[timestamp_header])\n            else:\n                self.logger.debug(\"returning full timestamp col\")\n                v = test[timestamp_header]\n                if in_minutes and v is not None:\n                    v /= 60.0\n        if in_minutes and v is not None:\n            v /= 60.0\n        return v"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns discharge capacity in mAh / g and voltage.", "response": "def get_dcap(self, cycle=None, dataset_number=None):\n        \"\"\"Returns discharge_capacity (in mAh/g), and voltage.\"\"\"\n\n        #  TODO: should return a DataFrame as default\n        #  but remark that we then have to update e.g. batch_helpers.py\n\n        dataset_number = self._validate_dataset_number(dataset_number)\n        if dataset_number is None:\n            self._report_empty_dataset()\n            return\n        dc, v = self._get_cap(cycle, dataset_number, \"discharge\")\n        return dc, v"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns charge capacity in mAh / g and voltage.", "response": "def get_ccap(self, cycle=None, dataset_number=None):\n        \"\"\"Returns charge_capacity (in mAh/g), and voltage.\"\"\"\n\n        #  TODO: should return a DataFrame as default\n        #  but remark that we then have to update e.g. batch_helpers.py\n\n        dataset_number = self._validate_dataset_number(dataset_number)\n        if dataset_number is None:\n            self._report_empty_dataset()\n            return\n        cc, v = self._get_cap(cycle, dataset_number, \"charge\")\n        return cc, v"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the capacity for the run.", "response": "def get_cap(self, cycle=None, dataset_number=None,\n                method=\"back-and-forth\",\n                shift=0.0,\n                categorical_column=False,\n                label_cycle_number=False,\n                split=False,\n                interpolated=False,\n                dx=0.1,\n                number_of_points=None,\n                dynamic=False,\n                ):\n        \"\"\"Gets the capacity for the run.\n        For cycle=None: not implemented yet, cycle set to 1.\n\n        Args:\n            cycle (int): cycle number.\n            method (string): how the curves are given\n                \"back-and-forth\" - standard back and forth; discharge\n                    (or charge) reversed from where charge (or discharge) ends.\n                \"forth\" - discharge (or charge) continues along x-axis.\n                \"forth-and-forth\" - discharge (or charge) also starts at 0\n                    (or shift if not shift=0.0)\n            shift: start-value for charge (or discharge) (typically used when\n                plotting shifted-capacity).\n            categorical_column: add a categorical column showing if it is\n                charge or discharge.\n            dataset_number (int): test number (default first)\n                (usually not used).\n            label_cycle_number (bool): add column for cycle number\n                (tidy format).\n            split (bool): return a list of c and v instead of the defualt\n                that is to return them combined in a DataFrame. This is only\n                possible for some specific combinations of options (neither\n                categorical_colum=True or label_cycle_number=True are\n                allowed).\n            interpolated (bool): set to True if you would like to get\n                interpolated data (typically if you want to save disk space\n                or memory). Defaults to False.\n            dx (float): the step used when interpolating.\n            number_of_points (int): number of points to use (over-rides dx)\n                for interpolation (i.e. the length of the interpolated data).\n            dynamic: for dynamic retrieving data from cellpy-file.\n                [NOT IMPLEMNETED YET]\n\n        Returns:\n            pandas.DataFrame ((cycle) voltage, capacity, (direction (-1, 1)))\n                unless split is explicitly set to True. Then it returns a tuple\n                with capacity (mAh/g) and voltage.\n        \"\"\"\n\n        dataset_number = self._validate_dataset_number(dataset_number)\n        if dataset_number is None:\n            self._report_empty_dataset()\n            return\n\n        # if cycle is not given, then this function should\n        # iterate through cycles\n        if cycle is None:\n            cycle = self.get_cycle_numbers()\n\n        if not isinstance(cycle, (collections.Iterable,)):\n            cycle = [cycle]\n\n        if split and not (categorical_column or label_cycle_number):\n            return_dataframe = False\n        else:\n            return_dataframe = True\n\n        method = method.lower()\n        if method not in [\"back-and-forth\", \"forth\", \"forth-and-forth\"]:\n            warnings.warn(f\"method '{method}' is not a valid option \"\n                          f\"- setting to 'back-and-forth'\")\n            method = \"back-and-forth\"\n\n        capacity = None\n        voltage = None\n        cycle_df = pd.DataFrame()\n\n        initial = True\n        for current_cycle in cycle:\n            # self.logger.debug(f\"processing cycle {current_cycle}\")\n            try:\n                cc, cv = self.get_ccap(current_cycle, dataset_number)\n                dc, dv = self.get_dcap(current_cycle, dataset_number)\n            except NullData as e:\n                self.logger.debug(e)\n                self.logger.debug(\"breaking out of loop\")\n                break\n\n            if cc.empty:\n                self.logger.debug(\"get_ccap returns empty cc Series\")\n\n            if dc.empty:\n                self.logger.debug(\"get_ccap returns empty dc Series\")\n\n            if initial:\n                # self.logger.debug(\"(initial cycle)\")\n                prev_end = shift\n                initial = False\n\n            if self._cycle_mode == \"anode\":\n                _first_step_c = dc\n                _first_step_v = dv\n                _last_step_c = cc\n                _last_step_v = cv\n            else:\n                _first_step_c = cc\n                _first_step_v = cv\n                _last_step_c = dc\n                _last_step_v = dv\n\n            if method == \"back-and-forth\":\n                _last = np.amax(_first_step_c)\n                # should change amax to last point\n                _first = None\n                _new_first = None\n                if _last_step_c is not None:\n                    _last_step_c = _last - _last_step_c + prev_end\n                else:\n                    self.logger.debug(\"no last charge step found\")\n                if _first_step_c is not None:\n                    _first = _first_step_c.iat[0]\n                    _first_step_c += prev_end\n                    _new_first = _first_step_c.iat[0]\n                else:\n                    self.logger.debug(\"probably empty (_first_step_c is None)\")\n                # self.logger.debug(f\"current shifts used: prev_end = {prev_end}\")\n                # self.logger.debug(f\"shifting start from {_first} to \"\n                #                   f\"{_new_first}\")\n\n                prev_end = np.amin(_last_step_c)\n                # should change amin to last point\n\n            elif method == \"forth\":\n                _last = np.amax(_first_step_c)\n                # should change amax to last point\n                if _last_step_c is not None:\n                    _last_step_c += _last + prev_end\n                else:\n                    self.logger.debug(\"no last charge step found\")\n                if _first_step_c is not None:\n                    _first_step_c += prev_end\n                else:\n                    self.logger.debug(\"no first charge step found\")\n\n                prev_end = np.amax(_last_step_c)\n                # should change amin to last point\n\n            elif method == \"forth-and-forth\":\n                if _last_step_c is not None:\n                    _last_step_c += shift\n                else:\n                    self.logger.debug(\"no last charge step found\")\n                if _first_step_c is not None:\n                    _first_step_c += shift\n                else:\n                    self.logger.debug(\"no first charge step found\")\n\n            if return_dataframe:\n\n                try:\n                    _first_df = pd.DataFrame(\n                            {\n                                \"voltage\": _first_step_v.values,\n                                \"capacity\": _first_step_c.values\n                             }\n                    )\n                    if interpolated:\n                        _first_df = _interpolate_df_col(\n                            _first_df, y=\"capacity\", x=\"voltage\",\n                            dx=dx, number_of_points=number_of_points,\n                            direction=-1\n                        )\n                    if categorical_column:\n                        _first_df[\"direction\"] = -1\n\n                    _last_df = pd.DataFrame(\n                        {\n                            \"voltage\": _last_step_v.values,\n                            \"capacity\": _last_step_c.values\n                        }\n                    )\n                    if interpolated:\n                        _last_df = _interpolate_df_col(\n                            _last_df, y=\"capacity\", x=\"voltage\",\n                            dx=dx, number_of_points=number_of_points,\n                            direction=1\n                        )\n                    if categorical_column:\n                        _last_df[\"direction\"] = 1\n\n                except AttributeError:\n                    self.logger.info(f\"could not extract cycle {current_cycle}\")\n                else:\n                    c = pd.concat([_first_df, _last_df], axis=0)\n                    if label_cycle_number:\n                        c.insert(0, \"cycle\", current_cycle)\n                        # c[\"cycle\"] = current_cycle\n                        # c = c[[\"cycle\", \"voltage\", \"capacity\", \"direction\"]]\n                    if cycle_df.empty:\n                        cycle_df = c\n                    else:\n                        cycle_df = pd.concat([cycle_df, c], axis=0)\n\n            else:\n                logging.warning(\"returning non-dataframe\")\n                c = pd.concat([_first_step_c, _last_step_c], axis=0)\n                v = pd.concat([_first_step_v, _last_step_v], axis=0)\n\n                capacity = pd.concat([capacity, c], axis=0)\n                voltage = pd.concat([voltage, v], axis=0)\n\n        if return_dataframe:\n            return cycle_df\n        else:\n            return capacity, voltage"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_ocv(self, cycles=None, direction=\"up\",\n                remove_first=False,\n                interpolated=False,\n                dx=None,\n                number_of_points=None):\n\n        \"\"\"get the open curcuit voltage relaxation curves.\n\n        Args:\n            cycles (list of ints or None): the cycles to extract from\n                (selects all if not given).\n            direction (\"up\", \"down\", or \"both\"): extract only relaxations that\n                is performed during discharge for \"up\" (because then the\n                voltage relaxes upwards) etc.\n            remove_first: remove the first relaxation curve (typically,\n                the first curve is from the initial rest period between\n                assembling the cell to the actual testing/cycling starts)\n            interpolated (bool): set to True if you want the data to be\n                interpolated (e.g. for creating smaller files)\n            dx (float): the step used when interpolating.\n            number_of_points (int): number of points to use (over-rides dx)\n                for interpolation (i.e. the length of the interpolated data).\n\n        Returns:\n            A pandas.DataFrame with cycle-number, step-number, step-time, and\n                voltage columns.\n        \"\"\"\n\n        if cycles is None:\n            cycles = self.get_cycle_numbers()\n        else:\n            if not isinstance(cycles, (list, tuple)):\n                cycles = [cycles, ]\n            else:\n                remove_first = False\n\n        ocv_rlx_id = \"ocvrlx\"\n        if direction == \"up\":\n            ocv_rlx_id += \"_up\"\n        elif direction == \"down\":\n            ocv_rlx_id += \"_down\"\n\n        step_table = self.dataset.step_table\n        dfdata = self.dataset.dfdata\n\n        ocv_steps = step_table.loc[\n                    step_table[\"cycle\"].isin(cycles), :\n                    ]\n\n        ocv_steps = ocv_steps.loc[\n                    ocv_steps.type.str.startswith(ocv_rlx_id), :\n                    ]\n\n        if remove_first:\n            ocv_steps = ocv_steps.iloc[1:, :]\n\n        step_time_label = self.headers_normal.step_time_txt\n        voltage_label = self.headers_normal.voltage_txt\n        cycle_label = self.headers_normal.cycle_index_txt\n        step_label = self.headers_normal.step_index_txt\n\n        selected_df = dfdata.where(\n            dfdata[cycle_label].isin(ocv_steps.cycle) &\n            dfdata[step_label].isin(ocv_steps.step)\n        ).dropna()\n\n        selected_df = selected_df.loc[\n            :, [cycle_label, step_label, step_time_label, voltage_label]\n        ]\n\n        if interpolated:\n            if dx is None and number_of_points is None:\n                dx = prms.Reader.time_interpolation_step\n            new_dfs = list()\n            groupby_list = [cycle_label, step_label]\n\n            for name, group in selected_df.groupby(groupby_list):\n                new_group = _interpolate_df_col(\n                    group,\n                    x=step_time_label,\n                    y=voltage_label,\n                    dx=dx,\n                    number_of_points=number_of_points,\n                )\n\n                for i, j in zip(groupby_list, name):\n                    new_group[i] = j\n                new_dfs.append(new_group)\n\n            selected_df = pd.concat(new_dfs)\n\n        return selected_df", "response": "get the open curcuit voltage relaxation curves for a given set of cycles"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget the OCV data for a given cycle.", "response": "def get_ocv_old(self, cycle_number=None, ocv_type='ocv', dataset_number=None):\n        \"\"\"Find ocv data in DataSet (voltage vs time).\n\n        Args:\n            cycle_number (int): find for all cycles if None.\n            ocv_type (\"ocv\", \"ocvrlx_up\", \"ocvrlx_down\"):\n                     ocv - get up and down (default)\n                     ocvrlx_up - get up\n                     ocvrlx_down - get down\n            dataset_number (int): test number (default first)\n                (usually not used).\n        Returns:\n                if cycle_number is not None\n                    ocv or [ocv_up, ocv_down]\n                    ocv (and ocv_up and ocv_down) are list\n                    containg [time,voltage] (that are Series)\n\n                if cycle_number is None\n                    [ocv1,ocv2,...ocvN,...] N = cycle\n                    ocvN = pandas DataFrame containing the columns\n                    cycle inded, step time, step index, data point, datetime,\n                        voltage\n                    (TODO: check if copy or reference of dfdata is returned)\n        \"\"\"\n        # function for getting ocv curves\n        dataset_number = self._validate_dataset_number(dataset_number)\n        if dataset_number is None:\n            self._report_empty_dataset()\n            return\n        if ocv_type in ['ocvrlx_up', 'ocvrlx_down']:\n            ocv = self._get_ocv(dataset_number=None,\n                                ocv_type=ocv_type,\n                                select_last=True,\n                                select_columns=True,\n                                cycle_number=cycle_number,\n                                )\n            return ocv\n        else:\n            ocv_up = self._get_ocv(dataset_number=None,\n                                   ocv_type='ocvrlx_up',\n                                   select_last=True,\n                                   select_columns=True,\n                                   cycle_number=cycle_number,\n                                   )\n            ocv_down = self._get_ocv(dataset_number=None,\n                                     ocv_type='ocvrlx_down',\n                                     select_last=True,\n                                     select_columns=True,\n                                     cycle_number=cycle_number,\n                                     )\n            return ocv_up, ocv_down"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_number_of_cycles(self, dataset_number=None, steptable=None):\n        if steptable is None:\n            dataset_number = self._validate_dataset_number(dataset_number)\n            if dataset_number is None:\n                self._report_empty_dataset()\n                return\n            d = self.datasets[dataset_number].dfdata\n            no_cycles = np.amax(d[self.headers_normal.cycle_index_txt])\n        else:\n            no_cycles = np.amax(steptable[self.headers_step_table.cycle])\n        return no_cycles", "response": "Get the number of cycles in the test."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting a list containing all the cycle numbers in the test.", "response": "def get_cycle_numbers(self, dataset_number=None, steptable=None):\n        \"\"\"Get a list containing all the cycle numbers in the test.\"\"\"\n        if steptable is None:\n            dataset_number = self._validate_dataset_number(dataset_number)\n            if dataset_number is None:\n                self._report_empty_dataset()\n                return\n            d = self.datasets[dataset_number].dfdata\n            cycles = np.unique(d[self.headers_normal.cycle_index_txt])\n        else:\n            cycles = np.unique(steptable[self.headers_step_table.cycle])\n        return cycles"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_converter_to_specific(self, dataset=None, mass=None,\n                                  to_unit=None, from_unit=None):\n        \"\"\"get the convertion values\n\n        Args:\n            dataset: DataSet object\n            mass: mass of electrode (for example active material in mg)\n            to_unit: (float) unit of input, f.ex. if unit of charge\n              is mAh and unit of mass is g, then to_unit for charge/mass\n              will be 0.001 / 1.0 = 0.001\n            from_unit: float) unit of output, f.ex. if unit of charge\n              is mAh and unit of mass is g, then to_unit for charge/mass\n              will be 1.0 / 0.001 = 1000.0\n\n        Returns:\n            multiplier (float) from_unit/to_unit * mass\n\n        \"\"\"\n\n        if not dataset:\n            dataset_number = self._validate_dataset_number(None)\n            if dataset_number is None:\n                self._report_empty_dataset()\n                return\n            dataset = self.datasets[dataset_number]\n\n        if not mass:\n            mass = dataset.mass\n\n        if not to_unit:\n            to_unit_cap = self.cellpy_units[\"charge\"]\n            to_unit_mass = self.cellpy_units[\"specific\"]\n            to_unit = to_unit_cap / to_unit_mass\n        if not from_unit:\n            from_unit_cap = self.raw_units[\"charge\"]\n            from_unit_mass = self.raw_units[\"mass\"]\n            from_unit = from_unit_cap / from_unit_mass\n\n        return from_unit / to_unit / mass", "response": "get the conversion values for the specific electrode"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set_mass(self, masses, dataset_number=None, validated=None):\n        self._set_run_attribute(\"mass\", masses, dataset_number=dataset_number,\n                                validated=validated)", "response": "Sets the mass for the test."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef set_tot_mass(self, masses, dataset_number=None, validated=None):\n        self._set_run_attribute(\"tot_mass\", masses,\n                                dataset_number=dataset_number,\n                                validated=validated)", "response": "Sets the total mass for the test."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsets the nominal cap for the test.", "response": "def set_nom_cap(self, nom_caps, dataset_number=None, validated=None):\n        \"\"\"Sets the mass (masses) for the test (datasets).\n        \"\"\"\n        self._set_run_attribute(\"nom_cap\", nom_caps,\n                                dataset_number=dataset_number,\n                                validated=validated)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef set_col_first(df, col_names):\n\n        column_headings = df.columns\n        column_headings = column_headings.tolist()\n        try:\n            for col_name in col_names:\n                i = column_headings.index(col_name)\n                column_headings.pop(column_headings.index(col_name))\n                column_headings.insert(0, col_name)\n\n        finally:\n            df = df.reindex(columns=column_headings)\n            return df", "response": "set selected columns first in a pandas. DataFrame."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_summary(self, dataset_number=None, use_dfsummary_made=False):\n        dataset_number = self._validate_dataset_number(dataset_number)\n        if dataset_number is None:\n            self._report_empty_dataset()\n            return None\n\n        test = self.get_dataset(dataset_number)\n\n        # This is a bit convoluted; in the old days, we used an attribute\n        # called dfsummary_made,\n        # that was set to True when the summary was made successfully.\n        # It is most likely never\n        # used anymore. And will most probably be deleted.\n        if use_dfsummary_made:\n            dfsummary_made = test.dfsummary_made\n        else:\n            dfsummary_made = True\n\n        if not dfsummary_made:\n            warnings.warn(\"Summary is not made yet\")\n            return None\n        else:\n            self.logger.info(\"returning datasets[test_no].dfsummary\")\n            return test.dfsummary", "response": "Retrieve summary returned as a pandas DataFrame."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef make_summary(self, find_ocv=False, find_ir=False,\n                     find_end_voltage=False,\n                     use_cellpy_stat_file=None, all_tests=True,\n                     dataset_number=0, ensure_step_table=True,\n                     convert_date=False):\n        \"\"\"Convenience function that makes a summary of the cycling data.\"\"\"\n\n        # first - check if we need some \"instrument-specific\" prms\n        if self.tester == \"arbin\":\n            convert_date = True\n\n        if ensure_step_table is None:\n            ensure_step_table = self.ensure_step_table\n        # Cycle_Index\tTest_Time(s)\tTest_Time(h)\tDate_Time\tCurrent(A)\n        # Current(mA)\tVoltage(V)\tCharge_Capacity(Ah)\tDischarge_Capacity(Ah)\n        # Charge_Energy(Wh)\tDischarge_Energy(Wh)\tInternal_Resistance(Ohm)\n        # AC_Impedance(Ohm)\tACI_Phase_Angle(Deg)\tCharge_Time(s)\n        # DisCharge_Time(s)\tVmax_On_Cycle(V)\tCoulombic_Efficiency\n        if use_cellpy_stat_file is None:\n            use_cellpy_stat_file = prms.Reader.use_cellpy_stat_file\n            self.logger.debug(\"using use_cellpy_stat_file from prms\")\n            self.logger.debug(f\"use_cellpy_stat_file: {use_cellpy_stat_file}\")\n\n        if all_tests is True:\n            for j in range(len(self.datasets)):\n                txt = \"creating summary for file \"\n                test = self.datasets[j]\n                if not self._is_not_empty_dataset(test):\n                    self.logger.info(\"empty test %i\" % j)\n                    return\n                if isinstance(test.loaded_from, (list, tuple)):\n                    for f in test.loaded_from:\n                        txt += f\n                        txt += \"\\n\"\n                else:\n                    txt += str(test.loaded_from)\n\n                if not test.mass_given:\n                    txt += \" mass for test %i is not given\" % j\n                    txt += \" setting it to %f mg\" % test.mass\n                self.logger.debug(txt)\n\n                self._make_summary(j,\n                                   find_ocv=find_ocv,\n                                   find_ir=find_ir,\n                                   find_end_voltage=find_end_voltage,\n                                   use_cellpy_stat_file=use_cellpy_stat_file,\n                                   ensure_step_table=ensure_step_table,\n                                   convert_date=convert_date,\n                                   )\n        else:\n            self.logger.debug(\"creating summary for only one test\")\n            dataset_number = self._validate_dataset_number(dataset_number)\n            if dataset_number is None:\n                self._report_empty_dataset()\n                return\n            self._make_summary(dataset_number,\n                               find_ocv=find_ocv,\n                               find_ir=find_ir,\n                               find_end_voltage=find_end_voltage,\n                               use_cellpy_stat_file=use_cellpy_stat_file,\n                               ensure_step_table=ensure_step_table,\n                               convert_date=convert_date,\n                               )\n        return self", "response": "Convenience function that makes a summary of the cycling data."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngenerating a single HTML page from an epub file.", "response": "def single_html(epub_file_path, html_out=sys.stdout, mathjax_version=None,\n                numchapters=None, includes=None):\n    \"\"\"Generate complete book HTML.\"\"\"\n    epub = cnxepub.EPUB.from_file(epub_file_path)\n    if len(epub) != 1:\n        raise Exception('Expecting an epub with one book')\n\n    package = epub[0]\n    binder = cnxepub.adapt_package(package)\n    partcount.update({}.fromkeys(parts, 0))\n    partcount['book'] += 1\n\n    html = cnxepub.SingleHTMLFormatter(binder, includes=includes)\n\n    # Truncate binder to the first N chapters where N = numchapters.\n    logger.debug('Full binder: {}'.format(cnxepub.model_to_tree(binder)))\n    if numchapters is not None:\n        apply_numchapters(html.get_node_type, binder, numchapters)\n        logger.debug('Truncated Binder: {}'.format(\n            cnxepub.model_to_tree(binder)))\n\n    # Add mathjax to the page.\n    if mathjax_version:\n        etree.SubElement(\n            html.head,\n            'script',\n            src=MATHJAX_URL.format(mathjax_version=mathjax_version))\n\n    print(str(html), file=html_out)\n    if hasattr(html_out, 'name'):\n        # html_out is a file, close after writing\n        html_out.close()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _pack_prms():\n\n    config_dict = {\n        \"Paths\": prms.Paths.to_dict(),\n        \"FileNames\": prms.FileNames.to_dict(),\n        \"Db\": prms.Db.to_dict(),\n        \"DbCols\": prms.DbCols.to_dict(),\n        \"DataSet\": prms.DataSet.to_dict(),\n        \"Reader\": prms.Reader.to_dict(),\n        \"Instruments\": prms.Instruments.to_dict(),\n        # \"excel_db_cols\": prms.excel_db_cols.to_dict(),\n        # \"excel_db_filename_cols\": prms.excel_db_filename_cols.to_dict(),\n        \"Batch\": prms.Batch.to_dict(),\n    }\n    return config_dict", "response": "Pack the prms into a dictionary that can be used to save the log files."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _read_prm_file(prm_filename):\n    logger.debug(\"Reading config-file: %s\" % prm_filename)\n    try:\n        with open(prm_filename, \"r\") as config_file:\n            prm_dict = yaml.load(config_file)\n    except yaml.YAMLError:\n        raise ConfigFileNotRead\n    else:\n        _update_prms(prm_dict)", "response": "read the prm file"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _get_prm_file(file_name=None, search_order=None):\n    if file_name is not None:\n        if os.path.isfile(file_name):\n            return file_name\n        else:\n            logger.info(\"Could not find the prm-file\")\n\n    default_name = prms._prm_default_name\n    prm_globtxt = prms._prm_globtxt\n\n    script_dir = os.path.abspath(os.path.dirname(__file__))\n\n    search_path = dict()\n    search_path[\"curdir\"] = os.path.abspath(os.path.dirname(sys.argv[0]))\n    search_path[\"filedir\"] = script_dir\n    search_path[\"userdir\"] = os.path.expanduser(\"~\")\n\n    if search_order is None:\n        search_order = [\"userdir\", ]  # [\"curdir\",\"filedir\", \"userdir\",]\n    else:\n        search_order = search_order\n\n    # The default name for the prm file is at the moment in the script-dir,@\n    # while default searching is in the userdir (yes, I know):\n    prm_default = os.path.join(script_dir, default_name)\n\n    # -searching-----------------------\n    search_dict = OrderedDict()\n\n    for key in search_order:\n        search_dict[key] = [None, None]\n        prm_directory = search_path[key]\n        default_file = os.path.join(prm_directory, default_name)\n\n        if os.path.isfile(default_file):\n            # noinspection PyTypeChecker\n            search_dict[key][0] = default_file\n\n        prm_globtxt_full = os.path.join(prm_directory, prm_globtxt)\n\n        user_files = glob.glob(prm_globtxt_full)\n\n        for f in user_files:\n            if os.path.basename(f) != os.path.basename(default_file):\n                search_dict[key][1] = f\n                break\n\n    # -selecting----------------------\n    prm_file = None\n    for key, file_list in search_dict.items():\n        if file_list[-1]:\n            prm_file = file_list[-1]\n            break\n        else:\n            if not prm_file:\n                prm_file = file_list[0]\n\n    if prm_file:\n        prm_filename = prm_file\n    else:\n        prm_filename = prm_default\n\n    return prm_filename", "response": "returns the name of the prm file"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef info():\n    print(\"convenience function for listing prms\")\n    print(type(prms))\n    print(prms.__name__)\n    print(f\"prm file: {_get_prm_file()}\")\n\n    for key in prms.__dict__:\n        if isinstance(prms.__dict__[key], box.Box):\n            print()\n            print(80 * \"=\")\n            print(f\"prms.{key}:\")\n            print(80 * \"-\")\n            for subkey in prms.__dict__[key]:\n                print(\n                    f\"prms.{key}.{subkey} = \",\n                    f\"{prms.__dict__[key][subkey]}\"\n                )\n            print(80 * \"=\")", "response": "this function will show only the box - type\n    attributes and their content in the cellpy. prms module"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _replace_tex_math(node, mml_url, mc_client=None, retry=0):\n\n    math = node.attrib['data-math'] or node.text\n    if math is None:\n        return None\n\n    eq = {}\n    if mc_client:\n        math_key = hashlib.md5(math.encode('utf-8')).hexdigest()\n        eq = json.loads(mc_client.get(math_key) or '{}')\n\n    if not eq:\n        res = requests.post(mml_url, {'math': math.encode('utf-8'),\n                                      'mathType': 'TeX',\n                                      'mml': 'true'})\n        if res:  # Non-error response from requests\n            eq = res.json()\n            if mc_client:\n                mc_client.set(math_key, res.text)\n\n    if 'components' in eq and len(eq['components']) > 0:\n        for component in eq['components']:\n            if component['format'] == 'mml':\n                mml = etree.fromstring(component['source'])\n        if node.tag.endswith('span'):\n            mml.set('display', 'inline')\n        elif node.tag.endswith('div'):\n            mml.set('display', 'block')\n        mml.tail = node.tail\n        return mml\n    else:\n        logger.warning('Retrying math TeX conversion: '\n                       '{}'.format(json.dumps(eq, indent=4)))\n        retry += 1\n        if retry < 2:\n            return _replace_tex_math(node, mml_url, mc_client, retry)\n\n    return None", "response": "call mml - api to replace TeX math in body of node with mathml"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates a callback function to replace an exercise by fetching from an external server.", "response": "def exercise_callback_factory(match, url_template,\n                              mc_client=None, token=None, mml_url=None):\n    \"\"\"Create a callback function to replace an exercise by fetching from\n    a server.\"\"\"\n\n    def _replace_exercises(elem):\n        item_code = elem.get('href')[len(match):]\n        url = url_template.format(itemCode=item_code)\n        exercise = {}\n        if mc_client:\n            mc_key = item_code + (token or '')\n            exercise = json.loads(mc_client.get(mc_key) or '{}')\n\n        if not exercise:\n            if token:\n                headers = {'Authorization': 'Bearer {}'.format(token)}\n                res = requests.get(url, headers=headers)\n            else:\n                res = requests.get(url)\n            if res:\n                # grab the json exercise, run it through Jinja2 template,\n                # replace element w/ it\n                exercise = res.json()\n                if mc_client:\n                    mc_client.set(mc_key, res.text)\n\n        if exercise['total_count'] == 0:\n            logger.warning('MISSING EXERCISE: {}'.format(url))\n\n            XHTML = '{{{}}}'.format(HTML_DOCUMENT_NAMESPACES['xhtml'])\n            missing = etree.Element(XHTML + 'div',\n                                    {'class': 'missing-exercise'},\n                                    nsmap=HTML_DOCUMENT_NAMESPACES)\n            missing.text = 'MISSING EXERCISE: tag:{}'.format(item_code)\n            nodes = [missing]\n        else:\n            html = EXERCISE_TEMPLATE.render(data=exercise)\n            try:\n                nodes = etree.fromstring('<div>{}</div>'.format(html))\n            except etree.XMLSyntaxError:  # Probably HTML\n                nodes = etree.HTML(html)[0]  # body node\n\n            if mml_url:\n                for node in nodes.xpath('//*[@data-math]'):\n                    mathml = _replace_tex_math(node, mml_url, mc_client)\n                    if mathml is not None:\n                        mparent = node.getparent()\n                        mparent.replace(node, mathml)\n                    else:\n                        mathtext = node.get('data-math') or node.text or ''\n                        logger.warning('BAD TEX CONVERSION: \"%s\" URL: %s'\n                                       % (mathtext.encode('utf-8'), url))\n\n        parent = elem.getparent()\n        if etree.QName(parent.tag).localname == 'p':\n            elem = parent\n            parent = elem.getparent()\n\n        parent.remove(elem)  # Special case - assumes single wrapper elem\n        for child in nodes:\n            parent.append(child)\n\n    xpath = '//xhtml:a[contains(@href, \"{}\")]'.format(match)\n    return (xpath, _replace_exercises)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef html_listify(tree, root_xl_element, extensions, list_type='ol'):\n    for node in tree:\n        li_elm = etree.SubElement(root_xl_element, 'li')\n        if node['id'] not in extensions:  # no extension, no associated file\n            span_elm = lxml.html.fragment_fromstring(\n                node['title'], create_parent='span')\n            li_elm.append(span_elm)\n        else:\n            a_elm = lxml.html.fragment_fromstring(\n                node['title'], create_parent='a')\n            a_elm.set('href', ''.join([node['id'], extensions[node['id']]]))\n            li_elm.append(a_elm)\n        if node['id'] is not None and node['id'] != 'subcol':\n            li_elm.set('cnx-archive-uri', node['id'])\n        if node['shortId'] is not None:\n            li_elm.set('cnx-archive-shortid', node['shortId'])\n        if 'contents' in node:\n            elm = etree.SubElement(li_elm, list_type)\n            html_listify(node['contents'], elm, extensions)", "response": "Convert a node tree into an xhtml nested list - of - lists."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _generate_ids(self, document, content):\n        existing_ids = content.xpath('//*/@id')\n        elements = [\n            'p', 'dl', 'dt', 'dd', 'table', 'div', 'section', 'figure',\n            'blockquote', 'q', 'code', 'pre', 'object', 'img', 'audio',\n            'video',\n            ]\n        elements_xpath = '|'.join(['.//{}|.//xhtml:{}'.format(elem, elem)\n                                  for elem in elements])\n\n        data_types = [\n            'equation', 'list', 'exercise', 'rule', 'example', 'note',\n            'footnote-number', 'footnote-ref', 'problem', 'solution', 'media',\n            'proof', 'statement', 'commentary'\n            ]\n        data_types_xpath = '|'.join(['.//*[@data-type=\"{}\"]'.format(data_type)\n                                     for data_type in data_types])\n\n        xpath = '|'.join([elements_xpath, data_types_xpath])\n\n        mapping = {}  # old id -> new id\n\n        for node in content.xpath(xpath, namespaces=HTML_DOCUMENT_NAMESPACES):\n            old_id = node.attrib.get('id')\n            document_id = document.id.replace('_', '')\n            if old_id:\n                new_id = 'auto_{}_{}'.format(document_id, old_id)\n            else:\n                random_number = random.randint(0, 100000)\n                new_id = 'auto_{}_{}'.format(document_id, random_number)\n            while new_id in existing_ids:\n                random_number = random.randint(0, 100000)\n                new_id = 'auto_{}_{}'.format(document_id, random_number)\n            node.attrib['id'] = new_id\n            if old_id:\n                mapping[old_id] = new_id\n            existing_ids.append(new_id)\n\n        for a in content.xpath('//a[@href]|//xhtml:a[@href]',\n                               namespaces=HTML_DOCUMENT_NAMESPACES):\n            href = a.attrib['href']\n            if href.startswith('#') and href[1:] in mapping:\n                a.attrib['href'] = '#{}'.format(mapping[href[1:]])", "response": "Generate unique ids for html elements in page content so that it s possible to link to them."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_node_type(self, node, parent=None):\n        if isinstance(node, CompositeDocument):\n            return 'composite-page'\n        elif isinstance(node, (Document, DocumentPointer)):\n            return 'page'\n        elif isinstance(node, Binder) and parent is None:\n            return 'book'\n        for child in node:\n            if isinstance(child, TranslucentBinder):\n                return 'unit'\n        return 'chapter'", "response": "Returns the type of node."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\npack the given directory into an epub file.", "response": "def pack_epub(directory, file):\n    \"\"\"Pack the given ``directory`` into an epub (i.e. zip) archive\n    given as ``file``, which can be a file-path or file-like object.\n    \"\"\"\n    with zipfile.ZipFile(file, 'w', zipfile.ZIP_DEFLATED) as zippy:\n        base_path = os.path.abspath(directory)\n        for root, dirs, filenames in os.walk(directory):\n            # Strip the absolute path\n            archive_path = os.path.relpath(root, base_path)\n            for filename in filenames:\n                filepath = os.path.join(root, filename)\n                archival_filepath = os.path.join(archive_path, filename)\n                zippy.write(filepath, archival_filepath)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef unpack_epub(file, directory):\n    if zipfile.is_zipfile(file):\n        # Extract the epub to the current working directory.\n        with zipfile.ZipFile(file, 'r') as zf:\n            zf.extractall(path=directory)", "response": "Unpack the given file to the given directory."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef from_file(cls, file):\n        root = None\n        if zipfile.is_zipfile(file):\n            unpack_dir = tempfile.mkdtemp('-epub')\n            # Extract the epub to the current working directory.\n            with zipfile.ZipFile(file, 'r') as zf:\n                zf.extractall(path=unpack_dir)\n            root = unpack_dir\n        elif os.path.isdir(file):\n            root = file\n        else:\n            raise TypeError(\"Can't decipher what should be done \"\n                            \"with the given file.\")\n\n        # NOTE We ignore the mimetype file, as it's not extremely important\n        #      to anything done here.\n\n        # Build a blank epub object then parse the packages.\n        container_xml_filepath = os.path.join(root,\n                                              EPUB_CONTAINER_XML_RELATIVE_PATH)\n        container_xml = etree.parse(container_xml_filepath)\n\n        packages = []\n        for pkg_filepath in container_xml.xpath(\n                '//ns:rootfile/@full-path',\n                namespaces=EPUB_CONTAINER_XML_NAMESPACES):\n            filepath = os.path.join(root, pkg_filepath)\n            packages.append(Package.from_file(filepath))\n        return cls(packages=packages, root=root)", "response": "Create an object from a file or a directory."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nexport to file which is a file - like object.", "response": "def to_file(epub, file):\n        \"\"\"Export to ``file``, which is a *file* or *file-like object*.\"\"\"\n        directory = tempfile.mkdtemp('-epub')\n        # Write out the contents to the filesystem.\n        package_filenames = []\n        for package in epub:\n            opf_filepath = Package.to_file(package, directory)\n            opf_filename = os.path.basename(opf_filepath)\n            package_filenames.append(opf_filename)\n\n        # Create the container.xml\n        container_xml_filepath = os.path.join(directory,\n                                              EPUB_CONTAINER_XML_RELATIVE_PATH)\n        template = jinja2.Template(CONTAINER_XML_TEMPLATE,\n                                   trim_blocks=True, lstrip_blocks=True)\n        os.makedirs(os.path.dirname(container_xml_filepath))  # FIXME PY3\n        with open(container_xml_filepath, 'w') as fb:\n            xml = template.render(package_filenames=package_filenames)\n            fb.write(xml)\n        # Write the mimetype file.\n        with open(os.path.join(directory, 'mimetype'), 'w') as fb:\n            fb.write(\"application/epub+zip\")\n\n        # Pack everything up\n        pack_epub(directory, file=file)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating an object from a file - like object.", "response": "def from_file(cls, file):\n        \"\"\"Create the object from a *file* or *file-like object*.\"\"\"\n        opf_xml = etree.parse(file)\n        # Check if ``file`` is file-like.\n        if hasattr(file, 'read'):\n            name = os.path.basename(file.name)\n            root = os.path.abspath(os.path.dirname(file.name))\n        else:  # ...a filepath\n            name = os.path.basename(file)\n            root = os.path.abspath(os.path.dirname(file))\n        parser = OPFParser(opf_xml)\n\n        # Roll through the item entries\n        manifest = opf_xml.xpath('/opf:package/opf:manifest/opf:item',\n                                 namespaces=EPUB_OPF_NAMESPACES)\n        pkg_items = []\n        for item in manifest:\n            absolute_filepath = os.path.join(root, item.get('href'))\n            properties = item.get('properties', '').split()\n            is_navigation = 'nav' in properties\n            media_type = item.get('media-type')\n            pkg_items.append(Item.from_file(absolute_filepath,\n                                            media_type=media_type,\n                                            is_navigation=is_navigation,\n                                            properties=properties))\n        # Ignore spine ordering, because it is not important\n        #   for our use cases.\n        return cls(name, pkg_items, parser.metadata)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nwrite the package to the given directory.", "response": "def to_file(package, directory):\n        \"\"\"Write the package to the given ``directory``.\n        Returns the OPF filename.\n        \"\"\"\n        opf_filepath = os.path.join(directory, package.name)\n\n        # Create the directory structure\n        for name in ('contents', 'resources',):\n            path = os.path.join(directory, name)\n            if not os.path.exists(path):\n                os.mkdir(path)\n\n        # Write the items to the filesystem\n        locations = {}  # Used when rendering\n        for item in package:\n            if item.media_type == 'application/xhtml+xml':\n                base = os.path.join(directory, 'contents')\n            else:\n                base = os.path.join(directory, 'resources')\n            filename = item.name\n            filepath = os.path.join(base, filename)\n            locations[item] = os.path.relpath(filepath, directory)\n            with open(filepath, 'wb') as item_file:\n                item_file.write(item.data.read())\n\n        # Write the OPF\n        template = jinja2.Template(OPF_TEMPLATE,\n                                   trim_blocks=True, lstrip_blocks=True)\n        with open(opf_filepath, 'wb') as opf_file:\n            opf = template.render(package=package, locations=locations)\n            if not isinstance(opf, bytes):\n                opf = opf.encode('utf-8')\n            opf_file.write(opf)\n\n        return opf_filepath"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nloads a DataFrame with all the needed info about the experiment", "response": "def from_file(self, file_name=None):\n        \"\"\"Loads a DataFrame with all the needed info about the experiment\"\"\"\n\n        file_name = self._check_file_name(file_name)\n\n        with open(file_name, 'r') as infile:\n            top_level_dict = json.load(infile)\n\n        pages_dict = top_level_dict['info_df']\n        pages = pd.DataFrame(pages_dict)\n        self.pages = pages\n        self.file_name = file_name\n        self._prm_packer(top_level_dict['metadata'])\n        self.generate_folder_names()\n        self.paginate()"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsaves a DataFrame with all the needed info about the experiment", "response": "def to_file(self, file_name=None):\n        \"\"\"Saves a DataFrame with all the needed info about the experiment\"\"\"\n\n        file_name = self._check_file_name(file_name)\n        pages = self.pages\n\n        top_level_dict = {\n            'info_df': pages,\n            'metadata': self._prm_packer()\n        }\n\n        jason_string = json.dumps(\n            top_level_dict,\n            default=lambda info_df: json.loads(\n                info_df.to_json()\n            )\n        )\n\n        self.paginate()\n\n        with open(file_name, 'w') as outfile:\n            outfile.write(jason_string)\n\n        self.file_name = file_name\n        logging.info(\"Saved file to {}\".format(file_name))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef generate_folder_names(self):\n        self.project_dir = os.path.join(prms.Paths.outdatadir, self.project)\n        self.batch_dir = os.path.join(self.project_dir, self.name)\n        self.raw_dir = os.path.join(self.batch_dir, \"raw_data\")", "response": "Set appropriate folder names."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate the folders where we would like to put results etc.", "response": "def paginate(self):\n        \"\"\"Make folders where we would like to put results etc.\"\"\"\n\n        project_dir = self.project_dir\n        raw_dir = self.raw_dir\n        batch_dir = self.batch_dir\n\n        if project_dir is None:\n            raise UnderDefined(\"no project directory defined\")\n        if raw_dir is None:\n            raise UnderDefined(\"no raw directory defined\")\n        if batch_dir is None:\n            raise UnderDefined(\"no batcb directory defined\")\n\n        # create the folders\n        if not os.path.isdir(project_dir):\n            os.mkdir(project_dir)\n            logging.info(f\"created folder {project_dir}\")\n        if not os.path.isdir(batch_dir):\n            os.mkdir(batch_dir)\n            logging.info(f\"created folder {batch_dir}\")\n        if not os.path.isdir(raw_dir):\n            os.mkdir(raw_dir)\n            logging.info(f\"created folder {raw_dir}\")\n\n        return project_dir, batch_dir, raw_dir"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef generate_file_name(self):\n        if not self.project:\n            raise UnderDefined(\"project name not given\")\n\n        out_data_dir = prms.Paths.outdatadir\n        project_dir = os.path.join(out_data_dir, self.project)\n        file_name = \"cellpy_batch_%s.json\" % self.name\n        self.file_name = os.path.join(project_dir, file_name)", "response": "generate a suitable file name for the experiment"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ndelivering some info to you about the class.", "response": "def info(self):\n        \"\"\"Delivers some info to you about the class.\"\"\"\n\n        print(\"Sorry, but I don't have much to share.\")\n        print(\"This is me:\")\n        print(self)\n        print(\"And these are the experiments assigned to me:\")\n        print(self.experiments)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef assign(self, experiment):\n\n        self.experiments.append(experiment)\n        self.farms.append(empty_farm)", "response": "Assign an experiment to the current set of active experiments."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef model_to_tree(model, title=None, lucent_id=TRANSLUCENT_BINDER_ID):\n    id = model.ident_hash\n    if id is None and isinstance(model, TranslucentBinder):\n        id = lucent_id\n    md = model.metadata\n    shortid = md.get('shortId', md.get('cnx-archive-shortid'))\n    title = title is not None and title or md.get('title')\n    tree = {'id': id, 'title': title, 'shortId': shortid}\n    if hasattr(model, '__iter__'):\n        contents = tree['contents'] = []\n        for node in model:\n            item = model_to_tree(node, model.get_title_for_node(node),\n                                 lucent_id=lucent_id)\n            contents.append(item)\n    return tree", "response": "Given a TranslucentBinder model return a tree object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef flatten_tree_to_ident_hashes(item_or_tree,\n                                 lucent_id=TRANSLUCENT_BINDER_ID):\n    \"\"\"Flatten a tree to id and version values (ident_hash).\"\"\"\n    if 'contents' in item_or_tree:\n        tree = item_or_tree\n        if tree['id'] != lucent_id:\n            yield tree['id']\n        for i in tree['contents']:\n            # yield from flatten_tree_to_ident_hashs(i, lucent_id)\n            for x in flatten_tree_to_ident_hashes(i, lucent_id):\n                yield x\n    else:\n        item = item_or_tree\n        yield item['id']", "response": "Flatten a tree to id and version values ( ident_hash )."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef flatten_model(model):\n    yield model\n    if isinstance(model, (TranslucentBinder, Binder,)):\n        for m in model:\n            # yield from flatten_model(m)\n            for x in flatten_model(m):\n                yield x", "response": "Flatten a model down to a list of models."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nflattening the model down to a list of documents.", "response": "def flatten_to_documents(model, include_pointers=False):\n    \"\"\"Flatten the model to a list of documents (aka ``Document`` objects).\n    This is to flatten a ``Binder``'ish model down to a list of documents.\n    If ``include_pointers`` has been set to ``True``, ``DocumentPointers``\n    will also be included in the results.\n\n    \"\"\"\n    types = [Document]\n    if include_pointers:\n        types.append(DocumentPointer)\n    types = tuple(types)\n\n    def _filter(m):\n        return isinstance(m, types)\n\n    return flatten_to(model, _filter)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngives a uri determine if it is internal or external.", "response": "def _discover_uri_type(uri):\n    \"\"\"Given a ``uri``, determine if it is internal or external.\"\"\"\n    parsed_uri = urlparse(uri)\n    if not parsed_uri.netloc:\n        if parsed_uri.scheme == 'data':\n            type_ = INLINE_REFERENCE_TYPE\n        else:\n            type_ = INTERNAL_REFERENCE_TYPE\n    else:\n        type_ = EXTERNAL_REFERENCE_TYPE\n    return type_"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nparsing the references to Reference instances.", "response": "def _parse_references(xml):\n    \"\"\"Parse the references to ``Reference`` instances.\"\"\"\n    references = []\n    ref_finder = HTMLReferenceFinder(xml)\n    for elm, uri_attr in ref_finder:\n        type_ = _discover_uri_type(elm.get(uri_attr))\n        references.append(Reference(elm, type_, uri_attr))\n    return references"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _set_uri_from_bound_model(self):\n        value = self._uri_template.format(self._bound_model.id)\n        self.elm.set(self._uri_attr, value)", "response": "Set the uri from the bound model."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef bind(self, model, template=\"{}\"):\n        self._bound_model = model\n        self._uri_template = template\n        self._set_uri_from_bound_model()", "response": "Bind the model to the reference."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef index_bounds(x):\n    if isinstance(x, (pd.DataFrame, pd.Series)):\n        return x.iloc[0], x.iloc[-1]\n    else:\n        return x[0], x[-1]", "response": "returns tuple with first and last item"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef dqdv_cycle(cycle, splitter=True, **kwargs):\n\n    c_first = cycle.loc[cycle[\"direction\"] == -1]\n    c_last = cycle.loc[cycle[\"direction\"] == 1]\n\n    converter = Converter(**kwargs)\n    converter.set_data(c_first[\"capacity\"], c_first[\"voltage\"])\n    converter.inspect_data()\n    converter.pre_process_data()\n    converter.increment_data()\n    converter.post_process_data()\n    voltage_first = converter.voltage_processed\n    incremental_capacity_first = converter.incremental_capacity\n\n    if splitter:\n        voltage_first = np.append(voltage_first, np.NaN)\n        incremental_capacity_first = np.append(incremental_capacity_first,\n                                               np.NaN)\n\n    converter = Converter(**kwargs)\n    converter.set_data(c_last[\"capacity\"], c_last[\"voltage\"])\n    converter.inspect_data()\n    converter.pre_process_data()\n    converter.increment_data()\n    converter.post_process_data()\n    voltage_last = converter.voltage_processed[::-1]\n    incremental_capacity_last = converter.incremental_capacity[::-1]\n    voltage = np.concatenate((voltage_first,\n                              voltage_last))\n    incremental_capacity = np.concatenate((incremental_capacity_first,\n                                           incremental_capacity_last))\n\n    return voltage, incremental_capacity", "response": "Convenience function for creating dq - dv data from given capacity and voltage cycle."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef dqdv_cycles(cycles, **kwargs):\n\n    # TODO: should add option for normalising based on first cycle capacity\n    # this is e.g. done by first finding the first cycle capacity (nom_cap)\n    # (or use nominal capacity given as input) and then propagating this to\n    # Converter using the key-word arguments\n    #   normalize=True, normalization_factor=1.0, normalization_roof=nom_cap\n\n    ica_dfs = list()\n    cycle_group = cycles.groupby(\"cycle\")\n    for cycle_number, cycle in cycle_group:\n\n        v, dq = dqdv_cycle(cycle, splitter=True, **kwargs)\n        _ica_df = pd.DataFrame(\n            {\n                \"voltage\": v,\n                \"dq\": dq,\n            }\n        )\n        _ica_df[\"cycle\"] = cycle_number\n        _ica_df = _ica_df[['cycle', 'voltage', 'dq']]\n        ica_dfs.append(_ica_df)\n\n    ica_df = pd.concat(ica_dfs)\n    return ica_df", "response": "Convenience function for creating dq - dv data from given capacity and voltage cycles."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef dqdv(voltage, capacity, voltage_resolution=None, capacity_resolution=None,\n         voltage_fwhm=0.01, pre_smoothing=True, diff_smoothing=False,\n         post_smoothing=True, post_normalization=True,\n         interpolation_method=None, gaussian_order=None, gaussian_mode=None, gaussian_cval=None,\n         gaussian_truncate=None, points_pr_split=None, savgol_filter_window_divisor_default=None,\n         savgol_filter_window_order=None, max_points=None, **kwargs):\n\n    \"\"\"Convenience functions for creating dq-dv data from given capacity\n    and voltage data.\n\n    Args:\n        voltage: nd.array or pd.Series\n        capacity: nd.array or pd.Series\n        voltage_resolution: used for interpolating voltage data (e.g. 0.005)\n        capacity_resolution: used for interpolating capacity data\n        voltage_fwhm: used for setting the post-processing gaussian sigma\n        pre_smoothing: set to True for pre-smoothing (window)\n        diff_smoothing: set to True for smoothing during differentiation (window)\n        post_smoothing: set to True for post-smoothing (gaussian)\n        post_normalization: set to True for normalising to capacity\n        interpolation_method: scipy interpolation method\n        gaussian_order: int\n        gaussian_mode: mode\n        gaussian_cval:\n        gaussian_truncate:\n        points_pr_split: only used when investigating data using splits\n        savgol_filter_window_divisor_default: used for window smoothing\n        savgol_filter_window_order: used for window smoothing\n        max_points: restricting to max points in vector (capacity-selected)\n\n    Returns: voltage, dqdv\n\n    Notes:\n        PEC data (Helge)\n            pre_smoothing = False\n            diff_smoothing = False\n            pos_smoothing = False\n            voltage_resolution = 0.005\n        PEC data (Preben)\n            ...\n        Arbin data (IFE)\n            ...\n    \"\"\"\n\n    converter = Converter(**kwargs)\n    logging.debug(\"dqdv - starting\")\n    logging.debug(\"dqdv - created Converter obj\")\n    converter.pre_smoothing = pre_smoothing\n    converter.post_smoothing = post_smoothing\n    converter.smoothing = diff_smoothing\n    converter.normalize = post_normalization\n    converter.voltage_fwhm = voltage_fwhm\n    logging.debug(f\"converter.pre_smoothing: {converter.pre_smoothing}\")\n    logging.debug(f\"converter.post_smoothing: {converter.post_smoothing}\")\n    logging.debug(f\"converter.smoothing: {converter.smoothing}\")\n    logging.debug(f\"converter.normalise: {converter.normalize}\")\n    logging.debug(f\"converter.voltage_fwhm: {converter.voltage_fwhm}\")\n\n    if voltage_resolution is not None:\n        converter.voltage_resolution = voltage_resolution\n\n    if capacity_resolution is not None:\n        converter.capacity_resolution = capacity_resolution\n\n    if savgol_filter_window_divisor_default is not None:\n        converter.savgol_filter_window_divisor_default = savgol_filter_window_divisor_default\n\n        logging.debug(f\"converter.savgol_filter_window_divisor_default: \"\n                      f\"{converter.savgol_filter_window_divisor_default}\")\n\n    if savgol_filter_window_order is not None:\n        converter.savgol_filter_window_order = savgol_filter_window_order\n\n        logging.debug(f\"converter.savgol_filter_window_order: \"\n                      f\"{converter.savgol_filter_window_order}\")\n\n    if gaussian_mode is not None:\n        converter.gaussian_mode = gaussian_mode\n\n    if gaussian_order is not None:\n        converter.gaussian_order = gaussian_order\n\n    if gaussian_truncate is not None:\n        converter.gaussian_truncate = gaussian_truncate\n\n    if gaussian_cval is not None:\n        converter.gaussian_cval = gaussian_cval\n\n    if interpolation_method is not None:\n        converter.interpolation_method = interpolation_method\n\n    if points_pr_split is not None:\n        converter.points_pr_split = points_pr_split\n\n    if max_points is not None:\n        converter.max_points = max_points\n\n    converter.set_data(capacity, voltage)\n    converter.inspect_data()\n    converter.pre_process_data()\n    converter.increment_data()\n    converter.post_process_data()\n\n    return converter.voltage_processed, converter.incremental_capacity", "response": "Convenience function for creating dq - dv data from given voltage and capacity data."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _dqdv_combinded_frame(cell, **kwargs):\n\n    cycles = cell.get_cap(\n        method=\"forth-and-forth\",\n        categorical_column=True,\n        label_cycle_number=True,\n    )\n    ica_df = dqdv_cycles(cycles, **kwargs)\n    assert isinstance(ica_df, pd.DataFrame)\n    return ica_df", "response": "Returns full cycle dqdv data for all cycles as one pd. DataFrame."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef dqdv_frames(cell, split=False, **kwargs):\n    # TODO: should add option for normalising based on first cycle capacity\n    # this is e.g. done by first finding the first cycle capacity (nom_cap)\n    # (or use nominal capacity given as input) and then propagating this to\n    # Converter using the key-word arguments\n    #   normalize=True, normalization_factor=1.0, normalization_roof=nom_cap\n\n    if split:\n        return _dqdv_split_frames(cell, tidy=True, **kwargs)\n    else:\n        return _dqdv_combinded_frame(cell, **kwargs)", "response": "Returns dqdv data as pandas. DataFrame for all cycles."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _dqdv_split_frames(cell, tidy=False, **kwargs):\n    charge_dfs, cycles, minimum_v, maximum_v = _collect_capacity_curves(\n        cell,\n        direction=\"charge\"\n    )\n    # charge_df = pd.concat(\n    # charge_dfs, axis=1, keys=[k.name for k in charge_dfs])\n\n    ica_charge_dfs = _make_ica_charge_curves(\n        charge_dfs, cycles, minimum_v, maximum_v,\n        **kwargs,\n    )\n    ica_charge_df = pd.concat(\n        ica_charge_dfs,\n        axis=1,\n        keys=[k.name for k in ica_charge_dfs]\n    )\n\n    dcharge_dfs, cycles, minimum_v, maximum_v = _collect_capacity_curves(\n        cell,\n        direction=\"discharge\"\n    )\n    ica_dcharge_dfs = _make_ica_charge_curves(\n        dcharge_dfs, cycles, minimum_v, maximum_v,\n        **kwargs,\n    )\n    ica_discharge_df = pd.concat(\n        ica_dcharge_dfs,\n        axis=1,\n        keys=[k.name for k in ica_dcharge_dfs]\n    )\n    ica_charge_df.columns.names = [\"cycle\", \"value\"]\n    ica_discharge_df.columns.names = [\"cycle\", \"value\"]\n\n    if tidy:\n        ica_charge_df = ica_charge_df.melt(\n            \"voltage\",\n            var_name=\"cycle\",\n            value_name=\"dq\",\n            col_level=0\n        )\n        ica_discharge_df = ica_discharge_df.melt(\n            \"voltage\",\n            var_name=\"cycle\",\n            value_name=\"dq\",\n            col_level=0\n        )\n\n    return ica_charge_df, ica_discharge_df", "response": "Returns dqdv data as pandas. DataFrames for all cycles."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsetting the data for the current object.", "response": "def set_data(self, capacity, voltage=None,\n                 capacity_label=\"q\", voltage_label=\"v\"\n                 ):\n        \"\"\"Set the data\"\"\"\n\n        logging.debug(\"setting data (capacity and voltage)\")\n\n        if isinstance(capacity, pd.DataFrame):\n            logging.debug(\"recieved a pandas.DataFrame\")\n            self.capacity = capacity[capacity_label]\n            self.voltage = capacity[voltage_label]\n        else:\n            assert len(capacity) == len(voltage)\n            self.capacity = capacity\n            self.voltage = voltage"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncheck and inspect the data", "response": "def inspect_data(self, capacity=None, voltage=None,\n                     err_est=False, diff_est=False):\n        \"\"\"check and inspect the data\"\"\"\n\n        logging.debug(\"inspecting the data\")\n\n        if capacity is None:\n            capacity = self.capacity\n        if voltage is None:\n            voltage = self.voltage\n\n        if capacity is None or voltage is None:\n            raise NullData\n\n        self.len_capacity = len(capacity)\n        self.len_voltage = len(voltage)\n\n        if self.len_capacity <= 1:\n            raise NullData\n        if self.len_voltage <= 1:\n            raise NullData\n\n        self.min_capacity, self.max_capacity = value_bounds(capacity)\n        self.start_capacity, self.end_capacity = index_bounds(capacity)\n\n        self.number_of_points = len(capacity)\n\n        if diff_est:\n            d_capacity = np.diff(capacity)\n            d_voltage = np.diff(voltage)\n\n            self.d_capacity_mean = np.mean(d_capacity)\n            self.d_voltage_mean = np.mean(d_voltage)\n\n        if err_est:\n\n            splits = int(self.number_of_points / self.points_pr_split)\n            rest = self.number_of_points % self.points_pr_split\n\n            if splits < self.minimum_splits:\n                txt = \"no point in splitting, too little data\"\n                logging.debug(txt)\n                self.errors.append(\"splitting: to few points\")\n            else:\n                if rest > 0:\n                    _cap = capacity[:-rest]\n                    _vol = voltage[:-rest]\n                else:\n                    _cap = capacity\n                    _vol = voltage\n\n                c_pieces = np.split(_cap, splits)\n                v_pieces = np.split(_vol, splits)\n                # c_middle = int(np.amax(c_pieces) / 2)\n\n                std_err = []\n                c_pieces_avg = []\n                for c, v in zip(c_pieces, v_pieces):\n                    _slope, _intercept, _r_value, _p_value, _std_err = stats.linregress(c, v)\n                    std_err.append(_std_err)\n                    c_pieces_avg.append(np.mean(c))\n\n                self.std_err_median = np.median(std_err)\n                self.std_err_mean = np.mean(std_err)\n\n        if not self.start_capacity == self.min_capacity:\n            self.errors.append(\"capacity: start<>min\")\n\n        if not self.end_capacity == self.max_capacity:\n            self.errors.append(\"capacity: end<>max\")\n\n        if self.normalizing_factor is None:\n            self.normalizing_factor = self.end_capacity\n\n        if self.normalizing_roof is not None:\n            self.normalizing_factor = self.normalizing_factor * \\\n                                      self.end_capacity / self.normalizing_roof"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef pre_process_data(self):\n\n        logging.debug(\"pre-processing the data\")\n\n        capacity = self.capacity\n        voltage = self.voltage\n\n        # performing an interpolation in v(q) space\n        logging.debug(\" - interpolating voltage(capacity)\")\n        c1, c2 = index_bounds(capacity)\n        if self.max_points is not None:\n            len_capacity = min(self.max_points, self.len_capacity)\n        elif self.capacity_resolution is not None:\n            len_capacity = round(abs(c2-c1) / self.capacity_resolution, 0)\n        else:\n            len_capacity = self.len_capacity\n\n        f = interp1d(capacity, voltage, kind=self.interpolation_method)\n\n\n        self.capacity_preprocessed = np.linspace(c1, c2, len_capacity)\n        self.voltage_preprocessed = f(self.capacity_preprocessed)\n\n        if self.pre_smoothing:\n            logging.debug(\" - pre-smoothing (savgol filter window)\")\n            savgol_filter_window_divisor = np.amin(\n                (self.savgol_filter_window_divisor_default, len_capacity / 5)\n            )\n            savgol_filter_window_length = int(\n                len_capacity / savgol_filter_window_divisor\n            )\n\n            if savgol_filter_window_length % 2 == 0:\n                savgol_filter_window_length -= 1\n            savgol_filter_window_length = np.amax(\n                [3, savgol_filter_window_length]\n            )\n\n            self.voltage_preprocessed = savgol_filter(\n                self.voltage_preprocessed,\n                savgol_filter_window_length,\n                self.savgol_filter_window_order\n            )", "response": "perform some pre - processing of the data"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nperform the dq - dv transform on the current state of the entry.", "response": "def increment_data(self):\n        \"\"\"perform the dq-dv transform\"\"\"\n\n        # NOTE TO ASBJOERN: Probably insert method for \"binning\" instead of\n        # differentiating here\n        # (use self.increment_method as the variable for selecting method for)\n\n        logging.debug(\"incrementing data\")\n\n        # ---- shifting to y-x ----------------------------------------\n        v1, v2 = value_bounds(self.voltage_preprocessed)\n        if self.voltage_resolution is not None:\n            len_voltage = round(abs(v2 - v1) / self.voltage_resolution, 0)\n        else:\n            len_voltage = len(self.voltage_preprocessed)\n\n        # ---- interpolating ------------------------------------------\n        logging.debug(\" - interpolating capacity(voltage)\")\n        f = interp1d(\n            self.voltage_preprocessed,\n            self.capacity_preprocessed,\n            kind=self.interpolation_method\n        )\n\n        self.voltage_inverted = np.linspace(v1, v2, len_voltage)\n        self.voltage_inverted_step = (v2 - v1) / (len_voltage - 1)\n        self.capacity_inverted = f(self.voltage_inverted)\n\n        if self.smoothing:\n            logging.debug(\" - smoothing (savgol filter window)\")\n            savgol_filter_window_divisor = np.amin(\n                (self.savgol_filter_window_divisor_default, len_voltage / 5)\n            )\n\n            savgol_filter_window_length = int(\n                len(self.voltage_inverted) / savgol_filter_window_divisor\n            )\n\n            if savgol_filter_window_length % 2 == 0:\n                savgol_filter_window_length -= 1\n\n            self.capacity_inverted = savgol_filter(\n                self.capacity_inverted,\n                np.amax([3, savgol_filter_window_length]),\n                self.savgol_filter_window_order\n            )\n\n        # ---  diff --------------------\n        if self.increment_method == \"diff\":\n            logging.debug(\" - diff using DIFF\")\n            self.incremental_capacity = np.ediff1d(self.capacity_inverted) / self.voltage_inverted_step\n            self._incremental_capacity = self.incremental_capacity\n            # --- need to adjust voltage ---\n            self._voltage_processed = self.voltage_inverted[1:]\n            self.voltage_processed = self.voltage_inverted[1:] - 0.5 * self.voltage_inverted_step  # centering\n\n        elif self.increment_method == \"hist\":\n            logging.debug(\" - diff using HIST\")\n            # TODO: Asbjoern, maybe you can put your method here?\n            raise NotImplementedError"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nperform post - processing of the data of the current object of the class", "response": "def post_process_data(self, voltage=None, incremental_capacity=None,\n                          voltage_step=None):\n        \"\"\"perform post-processing (smoothing, normalisation, interpolation) of\n        the data\"\"\"\n\n        logging.debug(\"post-processing data\")\n\n        if voltage is None:\n            voltage = self.voltage_processed\n            incremental_capacity = self.incremental_capacity\n            voltage_step = self.voltage_inverted_step\n\n        if self.post_smoothing:\n            logging.debug(\" - post smoothing (gaussian)\")\n            logging.debug(f\"    * using voltage fwhm: {self.voltage_fwhm}\")\n            points_fwhm = int(self.voltage_fwhm / voltage_step)\n\n            sigma = np.amax([1, points_fwhm / 2])\n\n            self.incremental_capacity = gaussian_filter1d(\n                incremental_capacity, sigma=sigma, order=self.gaussian_order,\n                mode=self.gaussian_mode,\n                cval=self.gaussian_cval,\n                truncate=self.gaussian_truncate\n            )\n\n        if self.normalize:\n            logging.debug(\" - normalizing\")\n            area = simps(incremental_capacity, voltage)\n            self.incremental_capacity = incremental_capacity * self.normalizing_factor / abs(area)\n\n        fixed_range = False\n        if isinstance(self.fixed_voltage_range, np.ndarray):\n            fixed_range = True\n        else:\n            if self.fixed_voltage_range:\n                fixed_range = True\n        if fixed_range:\n            logging.debug(\" - using fixed voltage range (interpolating)\")\n            v1, v2, number_of_points = self.fixed_voltage_range\n            v = np.linspace(v1, v2, number_of_points)\n            f = interp1d(x=self.voltage_processed, y=self.incremental_capacity,\n                         kind=self.interpolation_method, bounds_error=False,\n                         fill_value=np.NaN)\n\n            self.incremental_capacity = f(v)\n            self.voltage_processed = v"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef easybake(ruleset, in_html, out_html):\n    html = etree.parse(in_html)\n    oven = Oven(ruleset)\n    oven.bake(html)\n    out_html.write(etree.tostring(html))", "response": "This function bake the ruleset in_html into out_html."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef reconstitute(html):\n    try:\n        htree = etree.parse(html)\n    except etree.XMLSyntaxError:\n        html.seek(0)\n        htree = etree.HTML(html.read())\n\n    xhtml = etree.tostring(htree, encoding='utf-8')\n    return adapt_single_html(xhtml)", "response": "Given a file - like object as html reconstruct it into models."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncollating the contents of a binder into a new set .", "response": "def collate(binder, ruleset=None, includes=None):\n    \"\"\"Given a ``Binder`` as ``binder``, collate the content into a new set\n    of models.\n    Returns the collated binder.\n\n    \"\"\"\n    html_formatter = SingleHTMLFormatter(binder, includes)\n    raw_html = io.BytesIO(bytes(html_formatter))\n    collated_html = io.BytesIO()\n\n    if ruleset is None:\n        # No ruleset found, so no cooking necessary.\n        return binder\n\n    easybake(ruleset, raw_html, collated_html)\n\n    collated_html.seek(0)\n    collated_binder = reconstitute(collated_html)\n\n    return collated_binder"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nadapting ``.epub.Package`` to a ``BinderItem`` and cascades the adaptation downward to ``DocumentItem`` and ``ResourceItem``. The results of this process provide the same interface as ``.models.Binder``, ``.models.Document`` and ``.models.Resource``.", "response": "def adapt_package(package):\n    \"\"\"Adapts ``.epub.Package`` to a ``BinderItem`` and cascades\n    the adaptation downward to ``DocumentItem``\n    and ``ResourceItem``.\n    The results of this process provide the same interface as\n    ``.models.Binder``, ``.models.Document`` and ``.models.Resource``.\n    \"\"\"\n    navigation_item = package.navigation\n    html = etree.parse(navigation_item.data)\n    tree = parse_navigation_html_to_tree(html, navigation_item.name)\n    return _node_to_model(tree, package)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nadapt ``.epub.Item`` to a ``DocumentItem``.", "response": "def adapt_item(item, package, filename=None):\n    \"\"\"Adapts ``.epub.Item`` to a ``DocumentItem``.\n\n    \"\"\"\n    if item.media_type == 'application/xhtml+xml':\n        try:\n            html = etree.parse(item.data)\n        except Exception as exc:\n            logger.error(\"failed parsing {}\".format(item.name))\n            raise\n        metadata = DocumentPointerMetadataParser(\n            html, raise_value_error=False)()\n        item.data.seek(0)\n        if metadata.get('is_document_pointer'):\n            model = DocumentPointerItem(item, package)\n        else:\n            model = DocumentItem(item, package)\n    else:\n        model = Resource(item.name, item.data, item.media_type,\n                         filename or item.name)\n    return model"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef make_epub(binders, file):\n    if not isinstance(binders, (list, set, tuple,)):\n        binders = [binders]\n    epub = EPUB([_make_package(binder) for binder in binders])\n    epub.to_file(epub, file)", "response": "Creates an EPUB file from a list of binders."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef make_publication_epub(binders, publisher, publication_message, file):\n    if not isinstance(binders, (list, set, tuple,)):\n        binders = [binders]\n    packages = []\n    for binder in binders:\n        metadata = binder.metadata\n        binder.metadata = deepcopy(metadata)\n        binder.metadata.update({'publisher': publisher,\n                                'publication_message': publication_message})\n        packages.append(_make_package(binder))\n        binder.metadata = metadata\n    epub = EPUB(packages)\n    epub.to_file(epub, file)", "response": "Creates an epub file from a list of binders."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _make_package(binder):\n    package_id = binder.id\n    if package_id is None:\n        package_id = hash(binder)\n\n    package_name = \"{}.opf\".format(package_id)\n\n    extensions = get_model_extensions(binder)\n\n    template_env = jinja2.Environment(trim_blocks=True, lstrip_blocks=True)\n\n    # Build the package item list.\n    items = []\n    # Build the binder as an item, specifically a navigation item.\n    navigation_document = bytes(HTMLFormatter(binder, extensions))\n    navigation_document_name = \"{}{}\".format(\n        package_id,\n        mimetypes.guess_extension('application/xhtml+xml', strict=False))\n    item = Item(str(navigation_document_name),\n                io.BytesIO(navigation_document),\n                'application/xhtml+xml',\n                is_navigation=True, properties=['nav'])\n    items.append(item)\n    resources = {}\n    # Roll through the model list again, making each one an item.\n    for model in flatten_model(binder):\n        for resource in getattr(model, 'resources', []):\n            resources[resource.id] = resource\n            with resource.open() as data:\n                item = Item(resource.id, data, resource.media_type)\n            items.append(item)\n\n        if isinstance(model, (Binder, TranslucentBinder,)):\n            continue\n        if isinstance(model, DocumentPointer):\n            content = bytes(HTMLFormatter(model))\n            item = Item(''.join([model.ident_hash, extensions[model.id]]),\n                        io.BytesIO(content),\n                        model.media_type)\n            items.append(item)\n            continue\n        for reference in model.references:\n            if reference.remote_type == INLINE_REFERENCE_TYPE:\n                # has side effects - converts ref type to INTERNAL w/\n                # appropriate uri, so need to replicate resource treatment from\n                # above\n                resource = _make_resource_from_inline(reference)\n                model.resources.append(resource)\n                resources[resource.id] = resource\n                with resource.open() as data:\n                    item = Item(resource.id, data, resource.media_type)\n                items.append(item)\n                reference.bind(resource, '../resources/{}')\n\n            elif reference.remote_type == INTERNAL_REFERENCE_TYPE:\n                filename = os.path.basename(reference.uri)\n                resource = resources.get(filename)\n                if resource:\n                    reference.bind(resource, '../resources/{}')\n\n        complete_content = bytes(HTMLFormatter(model))\n        item = Item(''.join([model.ident_hash, extensions[model.id]]),\n                    io.BytesIO(complete_content),\n                    model.media_type)\n        items.append(item)\n\n    # Build the package.\n    package = Package(package_name, items, binder.metadata)\n    return package", "response": "Makes an. epub. Package from a Binder instance."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nmakes an object from a models. Reference that is of type INLINE. That is a data uri.", "response": "def _make_resource_from_inline(reference):\n    \"\"\"Makes an ``models.Resource`` from a ``models.Reference``\n       of type INLINE. That is, a data: uri\"\"\"\n    uri = DataURI(reference.uri)\n    data = io.BytesIO(uri.data)\n    mimetype = uri.mimetype\n    res = Resource('dummy', data, mimetype)\n    res.id = res.filename\n    return res"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nmake an. epub. Item from a. models. Document or. models. Resource.", "response": "def _make_item(model):\n    \"\"\"Makes an ``.epub.Item`` from\n    a ``.models.Document`` or ``.models.Resource``\n    \"\"\"\n    item = Item(model.id, model.content, model.media_type)\n    return item"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngiving a tree parse to a set of models", "response": "def _node_to_model(tree_or_item, package, parent=None,\n                   lucent_id=TRANSLUCENT_BINDER_ID):\n    \"\"\"Given a tree, parse to a set of models\"\"\"\n    if 'contents' in tree_or_item:\n        # It is a binder.\n        tree = tree_or_item\n        # Grab the package metadata, so we have required license info\n        metadata = package.metadata.copy()\n        if tree['id'] == lucent_id:\n            metadata['title'] = tree['title']\n            binder = TranslucentBinder(metadata=metadata)\n        else:\n            try:\n                package_item = package.grab_by_name(tree['id'])\n                binder = BinderItem(package_item, package)\n            except KeyError:  # Translucent w/ id\n                metadata.update({\n                   'title': tree['title'],\n                   'cnx-archive-uri': tree['id'],\n                   'cnx-archive-shortid': tree['shortId']})\n                binder = Binder(tree['id'], metadata=metadata)\n        for item in tree['contents']:\n            node = _node_to_model(item, package, parent=binder,\n                                  lucent_id=lucent_id)\n            if node.metadata['title'] != item['title']:\n                binder.set_title_for_node(node, item['title'])\n        result = binder\n    else:\n        # It is a document.\n        item = tree_or_item\n        package_item = package.grab_by_name(item['id'])\n        result = adapt_item(package_item, package)\n    if parent is not None:\n        parent.append(result)\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nadapts a single html document generated by . formatters. SingleHTMLFormatter to a Binder object.", "response": "def adapt_single_html(html):\n    \"\"\"Adapts a single html document generated by\n    ``.formatters.SingleHTMLFormatter`` to a ``models.Binder``\n    \"\"\"\n    html_root = etree.fromstring(html)\n\n    metadata = parse_metadata(html_root.xpath('//*[@data-type=\"metadata\"]')[0])\n    id_ = metadata['cnx-archive-uri'] or 'book'\n\n    binder = Binder(id_, metadata=metadata)\n    nav_tree = parse_navigation_html_to_tree(html_root, id_)\n\n    body = html_root.xpath('//xhtml:body', namespaces=HTML_DOCUMENT_NAMESPACES)\n    _adapt_single_html_tree(binder, body[0], nav_tree, top_metadata=metadata)\n\n    return binder"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef select_ocv_points(cellpydata, cycles=None, selection_method=\"martin\",\n                      number_of_points=5,\n                      interval=10,\n                      relative_voltage=False,\n                      report_times=False,\n                      direction=None):\n\n    \"\"\"Select points from the ocvrlx steps.\n\n        Args:\n            cellpydata: CellpyData-object\n            cycles: list of cycle numbers to process (optional)\n            selection_method: criteria for selecting points\n                martin: select first and last, and then last/2, last/2/2 etc.\n                    until you have reached the wanted number of points.\n                fixed_time: select first, and then\n            number_of_points: number of points you want.\n            interval: interval between each point (in use only for methods\n                where interval makes sense). If it is a list, then\n                number_of_points will be calculated as len(interval) + 1 (and\n                override the set number_of_points).\n            relative_voltage: set to True if you would like the voltage to be\n                relative to the voltage before starting the ocv rlx step.\n                Defaults to False. Remark that for the initial rxl step (when\n                you just have put your cell on the tester) does not have any\n                prior voltage. The relative voltage will then be versus the\n                first measurement point.\n            report_times: also report the ocv rlx total time if True (defaults\n                to False)\n            direction (\"up\", \"down\" or \"both\"): select \"up\" if you would like\n                to process only the ocv rlx steps where the voltage is relaxing\n                upwards and vize versa. Defaults to \"both\".\n\n        Returns:\n            pandas.DataFrame\n\n    \"\"\"\n\n    if cycles is None:\n        cycles = cellpydata.get_cycle_numbers()\n    else:\n        if not isinstance(cycles, (list, tuple)):\n            cycles = [cycles, ]\n\n    if direction is None:\n        direction = \"both\"\n\n    if not isinstance(interval, (list, tuple)):\n        interval = [float(interval) for _ in range(number_of_points-1)]\n\n    ocv_rlx_id = \"ocvrlx\"\n\n    step_table = cellpydata.dataset.step_table\n    dfdata = cellpydata.dataset.dfdata\n\n    ocv_steps = step_table.loc[\n        step_table[\"cycle\"].isin(cycles), :\n    ]\n\n    ocv_steps = ocv_steps.loc[\n        ocv_steps.type.str.startswith(ocv_rlx_id), :\n    ]\n\n    if selection_method in [\"fixed_times\", \"fixed_points\", \"selected_times\"]:\n        number_of_points = len(interval) + 1\n\n    headers2 = []\n    for j in range(number_of_points):\n        n = str(j).zfill(2)\n        headers2.append(f\"point_{n}\")\n\n    # doing an iteration (thought I didnt have to, but...) (fix later)\n\n    results_list = list()\n    iter_range = number_of_points - 1\n    if selection_method == \"martin\":\n        iter_range -= 1\n\n    for index, row in ocv_steps.iterrows():\n\n        # voltage\n        first, last, delta = (\n            row['voltage_first'],\n            row['voltage_last'],\n            row['voltage_delta']\n        )\n\n        voltage_reference = 0.0\n\n        if relative_voltage:\n            if index > 0:\n                reference_row = step_table.iloc[index-1, :]\n                voltage_reference = reference_row['voltage_last']\n\n            else:\n                voltage_reference = first\n                logging.warning(\"STEP 0: Using first point as ref voltage\")\n\n        # time\n        start, end, duration = (\n            row['step_time_first'],\n            row['step_time_last'],\n            row['step_time_delta']\n        )\n\n        cycle, step = (row['cycle'], row['step'])\n        info = row['type']\n\n        v_df = dfdata.loc[\n            (dfdata[\"Cycle_Index\"] == cycle) &\n            (dfdata[\"Step_Index\"] == step), [\"Step_Time\", \"Voltage\"]\n        ]\n\n        poi = []\n\n        _end = end\n        _start = start\n\n        if report_times:\n            t = str(datetime.timedelta(seconds=round(end-start, 0)))\n            print(f\"Cycle {cycle}:\", end=\" \")\n            print(f\"dt = {t}, dv = {first-last:6.3f}\")\n\n        for i, j in enumerate(range(max(1, iter_range))):\n            if selection_method == \"martin\":\n                logging.debug(\"using the 'martin'-method\")\n                _end = _end / 2.0\n                poi.append(_end)\n\n            elif selection_method == \"fixed_times\":\n                logging.debug(f\"using fixed times with interval {interval[i]}\")\n                _start = _start + interval[i]\n                logging.debug(f\"time: {_start}\")\n                poi.append(_start)\n            else:\n                # more methods to come?\n                logging.info(\"this method is not implemented\")\n                return None\n\n        if selection_method == \"martin\":\n            poi.reverse()\n\n        df_poi = pd.DataFrame({\"Step_Time\": poi})\n        df_poi[\"Voltage\"] = np.nan\n\n        v_df = v_df.append(df_poi, ignore_index=True)\n        v_df = v_df.sort_values(\"Step_Time\").reset_index(drop=True)\n        v_df[\"new\"] = v_df[\"Voltage\"].interpolate()\n\n        voi = []\n        for p in poi:\n            _v = v_df.loc[v_df[\"Step_Time\"].isin([p]), \"new\"].values\n            _v = _v - voltage_reference\n            voi.append(_v[0])\n\n        poi.insert(0, start)\n        voi.insert(0, first - voltage_reference)\n        if selection_method == \"martin\":\n            poi.append(end)\n            voi.append(last - voltage_reference)\n\n        d1 = {\"cycle\": cycle}\n        d2 = {h: [v] for h, v in zip(headers2, voi)}\n        d = {**d1, **d2}\n        result = pd.DataFrame(d)\n        result[\"step\"] = step\n        result[\"type\"] = info\n        results_list.append(result)\n\n    final = pd.concat(results_list)\n\n    if direction == \"down\":\n        final = final.loc[final[\"type\"] == \"ocvrlx_down\", :]\n    elif direction == \"up\":\n        final = final.loc[final[\"type\"] == \"ocvrlx_up\", :]\n\n    final = final.reset_index(drop=True)\n\n    return final", "response": "Select points from the ocv rlx steps."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_best_fit_parameters_grouped(self):\n        result_dict = dict()\n        result_dict['ocv'] = [parameters['ocv'] for parameters in\n                              self.best_fit_parameters]\n\n        for i in range(self.circuits):\n            result_dict['t' + str(i)] = [parameters['t' + str(i)] for parameters\n                                         in self.best_fit_parameters]\n            result_dict['w' + str(i)] = [parameters['w' + str(i)] for parameters\n                                         in self.best_fit_parameters]\n        return result_dict", "response": "Returns a dictionary of the best fit parameters grouped by the circuits."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_best_fit_parameters_translated_grouped(self):\n        result_dict = dict()\n        result_dict['ocv'] = [parameters['ocv'] for parameters in\n                              self.best_fit_parameters_translated]\n        result_dict['ir'] = [parameters['ir'] for parameters in\n                             self.best_fit_parameters_translated]\n\n        for i in range(self.circuits):\n            result_dict['r' + str(i)] = [parameters['r' + str(i)] for parameters\n                                         in self.best_fit_parameters_translated]\n            result_dict['c' + str(i)] = [parameters['c' + str(i)] for parameters\n                                         in self.best_fit_parameters_translated]\n        return result_dict", "response": "Returns the parameters as a dictionary of the real units for the best fit."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef plot_summary(self, cycles=None):\n        if cycles is None:\n            cycles = [0]\n        fig1 = plt.figure()\n        ax1 = fig1.add_subplot(221)\n        ax1.set_title('Fit')\n        ax2 = fig1.add_subplot(222)\n        ax2.set_title('OCV')\n        ax3 = fig1.add_subplot(223)\n        ax3.set_title('Tau')\n        ax3.set_yscale(\"log\")\n        ax4 = fig1.add_subplot(224)\n        ax4.set_title('Voltage Impact')\n\n        plot_data = self.get_best_fit_data()\n        for cycle in cycles:\n            ax1.plot(plot_data[cycle][0], plot_data[cycle][1])\n            ax1.plot(plot_data[cycle][0], plot_data[cycle][2])\n\n        plot_data = self.get_best_fit_parameters_grouped()\n\n        for i in range(self.circuits):\n            ax3.plot(self.get_fit_cycles(), plot_data['t' + str(i)])\n            ax4.plot(self.get_fit_cycles(), plot_data['w' + str(i)])\n\n        ax2.plot(self.get_fit_cycles(), plot_data['ocv'])", "response": "Convenience function for plotting the summary of the fit"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef plot_summary_translated(self):\n\n        fig2 = plt.figure()\n        ax1 = fig2.add_subplot(221)\n        ax1.set_title('OCV (V)')\n        ax2 = fig2.add_subplot(222)\n        ax2.set_title('IR (Ohm)')\n        ax3 = fig2.add_subplot(223)\n        ax3.set_title('Resistances (Ohm)')\n        ax4 = fig2.add_subplot(224)\n        ax4.set_title('Capacitances (F)')\n        ax4.set_yscale(\"log\")\n\n        plot_data = self.get_best_fit_parameters_translated_grouped()\n        print(plot_data['ocv'])\n        print(plot_data['ir'])\n        print(plot_data['r0'])\n\n        ax1.plot(self.get_fit_cycles(), plot_data['ocv'])\n        ax2.plot(self.get_fit_cycles(), plot_data['ir'])\n\n        for i in range(self.circuits):\n            ax3.plot(self.get_fit_cycles(), plot_data['r' + str(i)])\n            ax4.plot(self.get_fit_cycles(), plot_data['c' + str(i)])\n\n        plt.show()", "response": "Convenience function for plotting the summary of the the\n        fit."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef set_cellpydata(self, cellpydata, cycle):\n        self.data = cellpydata\n        self.step_table = self.data.dataset  # hope it works...\n        time_voltage = self.data.get_ocv(direction='up',\n                                         cycles=cycle)\n        time = time_voltage.Step_Time\n        voltage = time_voltage.Voltage\n\n        self.time = np.array(time)\n        self.voltage = np.array(voltage)", "response": "This method is used to set the data object for the next cycle in the cellpydata."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef run_fit(self):\n\n        # Check if data is set\n        if self.time is []:\n            self.result = []\n            return\n\n        try:\n            self.fit_model()\n        except ValueError as e:\n            print(e)\n        except AttributeError as e:\n            print(e)", "response": "Perform the fit of the OCV model"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef parse_navigation_html_to_tree(html, id):\n    def xpath(x):\n        return html.xpath(x, namespaces=HTML_DOCUMENT_NAMESPACES)\n    try:\n        value = xpath('//*[@data-type=\"binding\"]/@data-value')[0]\n        is_translucent = value == 'translucent'\n    except IndexError:\n        is_translucent = False\n    if is_translucent:\n        id = TRANSLUCENT_BINDER_ID\n    tree = {'id': id,\n            'title': xpath('//*[@data-type=\"document-title\"]/text()')[0],\n            'contents': [x for x in _nav_to_tree(xpath('//xhtml:nav')[0])]\n            }\n    return tree", "response": "Parse the given html object to a tree."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngiving an etree containing a navigation document structure containing a navigation document structure generate a tree structure containing the top level navigation elements.", "response": "def _nav_to_tree(root):\n    \"\"\"Given an etree containing a navigation document structure\n    rooted from the 'nav' element, parse to a tree:\n    {'id': <id>|'subcol', 'title': <title>, 'contents': [<tree>, ...]}\n    \"\"\"\n    def expath(e, x):\n        return e.xpath(x, namespaces=HTML_DOCUMENT_NAMESPACES)\n    for li in expath(root, 'xhtml:ol/xhtml:li'):\n        is_subtree = bool([e for e in li.getchildren()\n                           if e.tag[e.tag.find('}')+1:] == 'ol'])\n        if is_subtree:\n            # It's a sub-tree and have a 'span' and 'ol'.\n            itemid = li.get('cnx-archive-uri', 'subcol')\n            shortid = li.get('cnx-archive-shortid')\n            yield {'id': itemid,\n                   # Title is wrapped in a span, div or some other element...\n                   'title': squash_xml_to_text(expath(li, '*')[0],\n                                               remove_namespaces=True),\n                   'shortId': shortid,\n                   'contents': [x for x in _nav_to_tree(li)],\n                   }\n        else:\n            # It's a node and should only have an li.\n            a = li.xpath('xhtml:a', namespaces=HTML_DOCUMENT_NAMESPACES)[0]\n            yield {'id': a.get('href'),\n                   'shortid': li.get('cnx-archive-shortid'),\n                   'title': squash_xml_to_text(a, remove_namespaces=True)}"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a list of resource names found in the html metadata section.", "response": "def parse_resources(html):\n    \"\"\"Return a list of resource names found in the html metadata section.\"\"\"\n    xpath = '//*[@data-type=\"resources\"]//xhtml:li/xhtml:a'\n    for resource in html.xpath(xpath, namespaces=HTML_DOCUMENT_NAMESPACES):\n        yield {\n            'id': resource.get('href'),\n            'filename': resource.text.strip(),\n            }"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef on_connect(self, client, userdata, flags, rc):\n        '''\n        Callback for when the client receives a ``CONNACK`` response from the\n        broker.\n\n        Parameters\n        ----------\n        client : paho.mqtt.client.Client\n            The client instance for this callback.\n        userdata : object\n            The private user data as set in :class:`paho.mqtt.client.Client`\n            constructor or :func:`paho.mqtt.client.Client.userdata_set`.\n        flags : dict\n            Response flags sent by the broker.\n\n            The flag ``flags['session present']`` is useful for clients that\n            are using clean session set to 0 only.\n\n            If a client with clean session=0, that reconnects to a broker that\n            it has previously connected to, this flag indicates whether the\n            broker still has the session information for the client.\n\n            If 1, the session still exists.\n        rc : int\n            The connection result.\n\n            The value of rc indicates success or not:\n\n              - 0: Connection successful\n              - 1: Connection refused - incorrect protocol version\n              - 2: Connection refused - invalid client identifier\n              - 3: Connection refused - server unavailable\n              - 4: Connection refused - bad username or password\n              - 5: Connection refused - not authorised\n              - 6-255: Currently unused.\n\n        Notes\n        -----\n\n        Subscriptions should be defined in this method to ensure subscriptions\n        will be renewed upon reconnecting after a loss of connection.\n        '''\n        super(SerialDeviceManager, self).on_connect(client, userdata, flags, rc)\n\n        if rc == 0:\n            self.mqtt_client.subscribe('serial_device/+/connect')\n            self.mqtt_client.subscribe('serial_device/+/send')\n            self.mqtt_client.subscribe('serial_device/+/close')\n            self.mqtt_client.subscribe('serial_device/refresh_comports')\n            self.refresh_comports()", "response": "This method is called when a client connects to a specific broker."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _publish_status(self, port):\n        '''\n        Publish status for specified port.\n\n        Parameters\n        ----------\n        port : str\n            Device name/port.\n        '''\n        if port not in self.open_devices:\n            status = {}\n        else:\n            device = self.open_devices[port].serial\n            properties = ('port', 'baudrate', 'bytesize', 'parity', 'stopbits',\n                          'timeout', 'xonxoff', 'rtscts', 'dsrdtr')\n            status = {k: getattr(device, k) for k in properties}\n        status_json = json.dumps(status)\n        self.mqtt_client.publish(topic='serial_device/%s/status' % port,\n                                 payload=status_json, retain=True)", "response": "Publish status for specified port."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nhandles close request. Parameters ---------- port : str Device name/port.", "response": "def _serial_close(self, port):\n        '''\n        Handle close request.\n\n        Parameters\n        ----------\n        port : str\n            Device name/port.\n        '''\n        if port in self.open_devices:\n            try:\n                self.open_devices[port].close()\n            except Exception as exception:\n                logger.error('Error closing device `%s`: %s', port, exception)\n                return\n        else:\n            logger.debug('Device not connected to `%s`', port)\n            self._publish_status(port)\n            return"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _serial_connect(self, port, request):\n        '''\n        Handle connection request.\n\n        Parameters\n        ----------\n        port : str\n            Device name/port.\n        request : dict\n        '''\n        #     baudrate : int\n        #         Baud rate such as 9600 or 115200 etc.\n        #     bytesize : str, optional\n        #         Number of data bits.\n        #\n        #         Possible values: ``'FIVEBITS'``, ``'SIXBITS'``, ``'SEVENBITS'``,\n        #         ``'EIGHTBITS'``.\n        #\n        #         Default: ``'EIGHTBITS'``\n        #     parity : str, optional\n        #         Enable parity checking.\n        #\n        #         Possible values: ``'PARITY_NONE'``, ``'PARITY_EVEN'``, ``'PARITY_ODD'``,\n        #         ``'PARITY_MARK'``, ``'PARITY_SPACE'``.\n        #\n        #         Default: ``'PARITY_NONE'``\n        #     stopbits : str, optional\n        #         Number of stop bits.\n        #\n        #         Possible values: STOPBITS_ONE, STOPBITS_ONE_POINT_FIVE, STOPBITS_TWO\n        #     xonxoff : bool, optional\n        #         Enable software flow control.\n        #\n        #         Default: ``False``\n        #     rtscts : bool, optional\n        #         Enable hardware (RTS/CTS) flow control.\n        #\n        #         Default: ``False``\n        #     dsrdtr : bool, optional\n        #         Enable hardware (DSR/DTR) flow control.\n        #\n        #         Default: ``False``\n        command = 'connect'\n        if port in self.open_devices:\n            logger.debug('Already connected to: `%s`', port)\n            self._publish_status(port)\n            return\n\n        # TODO Write JSON schema definition for valid connect request.\n        if 'baudrate' not in request:\n            logger.error('Invalid `%s` request: `baudrate` must be '\n                         'specified.', command)\n            return\n        if 'bytesize' in request:\n            try:\n                bytesize = getattr(serial, request['bytesize'])\n                if not bytesize in serial.Serial.BYTESIZES:\n                    logger.error('`%s` request: `bytesize` `%s` not '\n                                 'available on current platform.', command,\n                                 request['bytesize'])\n                    return\n            except AttributeError as exception:\n                logger.error('`%s` request: invalid `bytesize`, `%s`', command,\n                             request['bytesize'])\n                return\n        else:\n            bytesize = serial.EIGHTBITS\n        if 'parity' in request:\n            try:\n                parity = getattr(serial, request['parity'])\n                if not parity in serial.Serial.PARITIES:\n                    logger.error('`%s` request: `parity` `%s` not available '\n                                 'on current platform.', command,\n                                 request['parity'])\n                    return\n            except AttributeError as exception:\n                logger.error('`%s` request: invalid `parity`, `%s`', command,\n                             request['parity'])\n                return\n        else:\n            parity = serial.PARITY_NONE\n        if 'stopbits' in request:\n            try:\n                stopbits = getattr(serial, request['stopbits'])\n                if not stopbits in serial.Serial.STOPBITS:\n                    logger.error('`%s` request: `stopbits` `%s` not '\n                                 'available on current platform.', command,\n                                 request['stopbits'])\n                    return\n            except AttributeError as exception:\n                logger.error('`%s` request: invalid `stopbits`, `%s`', command,\n                             request['stopbits'])\n                return\n        else:\n            stopbits = serial.STOPBITS_ONE\n\n        try:\n            baudrate = int(request['baudrate'])\n            xonxoff = bool(request.get('xonxoff'))\n            rtscts = bool(request.get('rtscts'))\n            dsrdtr = bool(request.get('dsrdtr'))\n        except TypeError as exception:\n            logger.error('`%s` request: %s', command, exception)\n            return\n\n        try:\n            device = serial.serial_for_url(port, baudrate=baudrate,\n                                           bytesize=bytesize, parity=parity,\n                                           stopbits=stopbits, xonxoff=xonxoff,\n                                           rtscts=rtscts, dsrdtr=dsrdtr)\n            parent = self\n\n            class PassThroughProtocol(serial.threaded.Protocol):\n                PORT = port\n\n                def connection_made(self, transport):\n                    \"\"\"Called when reader thread is started\"\"\"\n                    parent.open_devices[port] = transport\n                    parent._publish_status(self.PORT)\n\n                def data_received(self, data):\n                    \"\"\"Called with snippets received from the serial port\"\"\"\n                    parent.mqtt_client.publish(topic='serial_device/%s/received'\n                                               % self.PORT, payload=data)\n\n                def connection_lost(self, exception):\n                    \"\"\"\\\n                    Called when the serial port is closed or the reader loop terminated\n                    otherwise.\n                    \"\"\"\n                    if isinstance(exception, Exception):\n                        logger.error('Connection to port `%s` lost: %s',\n                                     self.PORT, exception)\n                    del parent.open_devices[self.PORT]\n                    parent._publish_status(self.PORT)\n\n            reader_thread = serial.threaded.ReaderThread(device,\n                                                         PassThroughProtocol)\n            reader_thread.start()\n            reader_thread.connect()\n        except Exception as exception:\n            logger.error('`%s` request: %s', command, exception)\n            return", "response": "Handle connection request.\n\n        Parameters\n        ----------\n        port : str\n            Device name/port.\n        request : dict"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nsend data to a connected device.", "response": "def _serial_send(self, port, payload):\n        '''\n        Send data to connected device.\n\n        Parameters\n        ----------\n        port : str\n            Device name/port.\n        payload : bytes\n            Payload to send to device.\n        '''\n        if port not in self.open_devices:\n            # Not connected to device.\n            logger.error('Error sending data: `%s` not connected', port)\n            self._publish_status(port)\n        else:\n            try:\n                device = self.open_devices[port]\n                device.write(payload)\n                logger.debug('Sent data to `%s`', port)\n            except Exception as exception:\n                logger.error('Error sending data to `%s`: %s', port, exception)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nprint a datetime object", "response": "def print_datetime_object(dt):\n    \"\"\"prints a date-object\"\"\"\n    print(dt)\n    print('ctime  :', dt.ctime())\n    print('tuple  :', dt.timetuple())\n    print('ordinal:', dt.toordinal())\n    print('Year   :', dt.year)\n    print('Mon    :', dt.month)\n    print('Day    :', dt.day)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nincluding the settings for how to examine the raw limits for the current and voltage of the current and voltage of the current and voltage of the current and voltage of the current and voltage of the current and voltage of the current and voltage of the current and voltage of the current and voltage are stable.", "response": "def get_raw_limits(self):\n        \"\"\"Include the settings for how to decide what kind of step you are examining here.\n\n        The raw limits are 'epsilons' used to check if the current and/or voltage is stable (for example\n        for galvanostatic steps, one would expect that the current is stable (constant) and non-zero).\n        It is expected that different instruments (with different resolution etc.) have different\n        'epsilons'.\n\n        Returns: the raw limits (dict)\n\n        \"\"\"\n        warnings.warn(\"raw limits have not been subject for testing yet\")\n        raw_limits = dict()\n        raw_limits[\"current_hard\"] = 0.1  # There is a bug in PEC\n        raw_limits[\"current_soft\"] = 1.0\n        raw_limits[\"stable_current_hard\"] = 2.0\n        raw_limits[\"stable_current_soft\"] = 4.0\n        raw_limits[\"stable_voltage_hard\"] = 2.0\n        raw_limits[\"stable_voltage_soft\"] = 4.0\n        raw_limits[\"stable_charge_hard\"] = 2.0\n        raw_limits[\"stable_charge_soft\"] = 5.0\n        raw_limits[\"ir_change\"] = 0.00001\n        return raw_limits"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncheck if you are on a 64 bit platform", "response": "def check64bit(current_system=\"python\"):\n    \"\"\"checks if you are on a 64 bit platform\"\"\"\n    if current_system == \"python\":\n        return sys.maxsize > 2147483647\n    elif current_system == \"os\":\n        import platform\n        pm = platform.machine()\n        if pm != \"..\" and pm.endswith('64'):  # recent Python (not Iron)\n            return True\n        else:\n            if 'PROCESSOR_ARCHITEW6432' in os.environ:\n                return True  # 32 bit program running on 64 bit Windows\n            try:\n                # 64 bit Windows 64 bit program\n                return os.environ['PROCESSOR_ARCHITECTURE'].endswith('64')\n            except IndexError:\n                pass  # not Windows\n            try:\n                # this often works in Linux\n                return '64' in platform.architecture()[0]\n            except Exception:\n                # is an older version of Python, assume also an older os@\n                # (best we can guess)\n                return False"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a humanized string representation of a number of b.", "response": "def humanize_bytes(b, precision=1):\n    \"\"\"Return a humanized string representation of a number of b.\n\n    Assumes `from __future__ import division`.\n\n    >>> humanize_bytes(1)\n    '1 byte'\n    >>> humanize_bytes(1024)\n    '1.0 kB'\n    >>> humanize_bytes(1024*123)\n    '123.0 kB'\n    >>> humanize_bytes(1024*12342)\n    '12.1 MB'\n    >>> humanize_bytes(1024*12342,2)\n    '12.05 MB'\n    >>> humanize_bytes(1024*1234,2)\n    '1.21 MB'\n    >>> humanize_bytes(1024*1234*1111,2)\n    '1.31 GB'\n    >>> humanize_bytes(1024*1234*1111,1)\n    '1.3 GB'\n    \"\"\"\n    # abbrevs = (\n    #     (1 << 50L, 'PB'),\n    #     (1 << 40L, 'TB'),\n    #     (1 << 30L, 'GB'),\n    #     (1 << 20L, 'MB'),\n    #     (1 << 10L, 'kB'),\n    #     (1, 'b')\n    # )\n    abbrevs = (\n        (1 << 50, 'PB'),\n        (1 << 40, 'TB'),\n        (1 << 30, 'GB'),\n        (1 << 20, 'MB'),\n        (1 << 10, 'kB'),\n        (1, 'b')\n    )\n    if b == 1:\n        return '1 byte'\n    for factor, suffix in abbrevs:\n        if b >= factor:\n            break\n    # return '%.*f %s' % (precision, old_div(b, factor), suffix)\n    return '%.*f %s' % (precision, b // factor, suffix)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nconverting a xls date stamp to a more sensible datetime object.", "response": "def xldate_as_datetime(xldate, datemode=0, option=\"to_datetime\"):\n    \"\"\"Converts a xls date stamp to a more sensible format.\n\n    Args:\n        xldate (str): date stamp in Excel format.\n        datemode (int): 0 for 1900-based, 1 for 1904-based.\n        option (str): option in (\"to_datetime\", \"to_float\", \"to_string\"),\n            return value\n\n    Returns:\n        datetime (datetime object, float, or string).\n\n    \"\"\"\n\n    # This does not work for numpy-arrays\n\n    if option == \"to_float\":\n        d = (xldate - 25589) * 86400.0\n    else:\n        try:\n            d = datetime.datetime(1899, 12, 30) + \\\n                datetime.timedelta(days=xldate + 1462 * datemode)\n            # date_format = \"%Y-%m-%d %H:%M:%S:%f\" # with microseconds,\n            # excel cannot cope with this!\n            if option == \"to_string\":\n                date_format = \"%Y-%m-%d %H:%M:%S\"  # without microseconds\n                d = d.strftime(date_format)\n        except TypeError:\n            logging.info(f'The date is not of correct type [{xldate}]')\n            d = xldate\n    return d"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef populate(self, filename):\n\n        if os.path.isfile(filename):\n            fid_st = os.stat(filename)\n            self.name = os.path.abspath(filename)\n            self.full_name = filename\n            self.size = fid_st.st_size\n            self.last_modified = fid_st.st_mtime\n            self.last_accessed = fid_st.st_atime\n            self.last_info_changed = fid_st.st_ctime\n            self.location = os.path.dirname(filename)", "response": "Finds the file - stats and populates the class with stat values."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_raw(self):\n        return [self.name, self.size, self.last_modified, self.location]", "response": "Get a list with information about the file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef dfsummary_made(self):\n        try:\n            empty = self.dfsummary.empty\n        except AttributeError:\n            empty = True\n        return not empty", "response": "check if the summary table exists"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef step_table_made(self):\n        try:\n            empty = self.step_table.empty\n        except AttributeError:\n            empty = True\n        return not empty", "response": "check if the step table exists"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nopen sheets and returns it", "response": "def _open_sheet(self, dtypes_dict=None):\n        \"\"\"Opens sheets and returns it\"\"\"\n        table_name = self.db_sheet_table\n        header_row = self.db_header_row\n        nrows = self.nrows\n        if dtypes_dict is None:\n            dtypes_dict = self.dtypes_dict\n\n        rows_to_skip = self.skiprows\n\n        logging.debug(f\"Trying to open the file {self.db_file}\")\n        logging.debug(f\"Number of rows: {nrows}\")\n        logging.debug(f\"Skipping the following rows: {rows_to_skip}\")\n        logging.debug(f\"Declaring the following dtyps: {dtypes_dict}\")\n        work_book = pd.ExcelFile(self.db_file)\n        try:\n            sheet = work_book.parse(\n                table_name, header=header_row, skiprows=rows_to_skip,\n                dtype=dtypes_dict, nrows=nrows,\n            )\n        except ValueError as e:\n            logging.debug(\"Could not parse all the columns (ValueError) \"\n                          \"using given dtypes. Trying without dtypes.\")\n            logging.debug(str(e))\n            sheet = work_book.parse(\n                table_name, header=header_row, skiprows=rows_to_skip,\n                nrows=nrows,\n            )\n\n        return sheet"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nchecking that the db - file is ok Returns True if OK False if not.", "response": "def _validate(self):\n        \"\"\"Checks that the db-file is ok\n\n        Returns:\n            True if OK, False if not.\n            \"\"\"\n        probably_good_to_go = True\n        sheet = self.table\n        identity = self.db_sheet_cols.id\n\n        # check if you have unique srnos\n        id_col = sheet.loc[:, identity]\n        if any(id_col.duplicated()):\n            warnings.warn(\n                \"your database is corrupt: duplicates\"\n                \" encountered in the srno-column\")\n            logger.debug(\"srno duplicates:\\n\" + str(\n                id_col.duplicated()))\n            probably_good_to_go = False\n        return probably_good_to_go"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nselecting row for identification number serial_number", "response": "def select_serial_number_row(self, serial_number):\n        \"\"\"Select row for identification number serial_number\n\n        Args:\n            serial_number: serial number\n\n        Returns:\n            pandas.DataFrame\n        \"\"\"\n        sheet = self.table\n        col = self.db_sheet_cols.id\n        rows = sheet.loc[:, col] == serial_number\n        return sheet.loc[rows, :]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nselect rows for identification for a list of serial numbers.", "response": "def select_all(self, serial_numbers):\n        \"\"\"Select rows for identification for a list of serial_number.\n\n        Args:\n            serial_numbers: list (or ndarray) of serial numbers\n\n        Returns:\n            pandas.DataFrame\n        \"\"\"\n        sheet = self.table\n        col = self.db_sheet_cols.id\n        rows = sheet.loc[:, col].isin(serial_numbers)\n        return sheet.loc[rows, :]"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef print_serial_number_info(self, serial_number, print_to_screen=True):\n        r = self.select_serial_number_row(serial_number)\n        if r.empty:\n            warnings.warn(\"missing serial number\")\n            return\n\n        txt1 = 80 * \"=\"\n        txt1 += \"\\n\"\n        txt1 += f\"   serial number {serial_number}\\n\"\n        txt1 = 80 * \"-\"\n        txt1 += \"\\n\"\n        txt2 = \"\"\n        for label, value in zip(r.columns, r.values[0]):\n            if label in self.headers:\n                txt1 += f\"{label}:    \\t {value}\\n\"\n            else:\n                txt2 += f\"({label}:    \\t {value})\\n\"\n        if print_to_screen:\n            print(txt1)\n            print(80 * \"-\")\n            print(txt2)\n            print(80 * \"=\")\n            return\n        else:\n            return txt1", "response": "Print information about the run."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nfilter the table by slurry name.", "response": "def filter_by_slurry(self, slurry, appender=\"_\"):\n        \"\"\"Filters sheet/table by slurry name.\n\n        Input is slurry name or list of slurry names, for example 'es030' or\n        [\"es012\",\"es033\",\"es031\"].\n\n        Args:\n            slurry (str or list of strings): slurry names.\n            appender (chr): char that surrounds slurry names.\n\n        Returns:\n            List of serial_number (ints).\n        \"\"\"\n\n        sheet = self.table\n        identity = self.db_sheet_cols.id\n        exists = self.db_sheet_cols.exists\n        cellname = self.db_sheet_cols.cell_name\n        search_string = \"\"\n\n        if not isinstance(slurry, (list, tuple)):\n            slurry = [slurry, ]\n\n        first = True\n        for slur in slurry:\n            s_s = appender + slur + appender\n            if first:\n                search_string = s_s\n                first = False\n            else:\n                search_string += \"|\"\n                search_string += s_s\n\n        criterion = sheet.loc[:, cellname].str.contains(\n            search_string\n        )\n        exists = sheet.loc[:, exists] > 0\n        sheet = sheet[criterion & exists]\n\n        return sheet.loc[:, identity].values.astype(int)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nfiltering sheet or table by columns", "response": "def filter_by_col(self, column_names):\n        \"\"\"filters sheet/table by columns (input is column header)\n\n        The routine returns the serial numbers with values>1 in the selected\n        columns.\n\n        Args:\n            column_names (list): the column headers.\n\n        Returns:\n            pandas.DataFrame\n        \"\"\"\n\n        if not isinstance(column_names, (list, tuple)):\n            column_names = [column_names, ]\n\n        sheet = self.table\n        identity = self.db_sheet_cols.id\n        exists = self.db_sheet_cols.exists\n        criterion = True\n\n        for column_name in column_names:\n            _criterion = sheet.loc[:, column_name] > 0\n            _exists = sheet.loc[:, exists] > 0\n            criterion = criterion & _criterion & _exists\n\n        return sheet.loc[criterion, identity].values.astype(int)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef filter_by_col_value(self, column_name,\n                            min_val=None, max_val=None):\n        \"\"\"filters sheet/table by column.\n\n        The routine returns the serial-numbers with min_val <= values >= max_val\n        in the selected column.\n\n        Args:\n            column_name (str): column name.\n            min_val (int): minimum value of serial number.\n            max_val (int): maximum value of serial number.\n\n        Returns:\n            pandas.DataFrame\n        \"\"\"\n        sheet = self.table\n        identity = self.db_sheet_cols.id\n        exists_col_number = self.db_sheet_cols.exists\n\n        exists = sheet.loc[:, exists_col_number] > 0\n\n        if min_val is not None and max_val is not None:\n\n            criterion1 = sheet.loc[:, column_name] >= min_val\n            criterion2 = sheet.loc[:, column_name] <= max_val\n            sheet = sheet[criterion1 & criterion2 & exists]\n\n        elif min_val is not None or max_val is not None:\n\n            if min_val is not None:\n                criterion = sheet.loc[:, column_name] >= min_val\n\n            if max_val is not None:\n                criterion = sheet.loc[:, column_name] <= max_val\n\n            # noinspection PyUnboundLocalVariable\n            sheet = sheet[criterion & exists]\n        else:\n            sheet = sheet[exists]\n\n        return sheet.loc[:, identity].values.astype(int)", "response": "filters sheet or table by column."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef select_batch(self, batch, batch_col_name=None):\n\n        if not batch_col_name:\n            batch_col_name = self.db_sheet_cols.batch\n        logger.debug(\"selecting batch - %s\" % batch)\n        sheet = self.table\n        identity = self.db_sheet_cols.id\n        exists_col_number = self.db_sheet_cols.exists\n\n        criterion = sheet.loc[:, batch_col_name] == batch\n        exists = sheet.loc[:, exists_col_number] > 0\n        # This will crash if the col is not of dtype number\n        sheet = sheet[criterion & exists]\n        return sheet.loc[:, identity].values.astype(int)", "response": "selects the rows in column batch_col_number\n       "}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nparses passed in single HTML file and create an epub of the tree.", "response": "def main(argv=None):\n    \"\"\"Parse passed in cooked single HTML.\"\"\"\n    parser = argparse.ArgumentParser(description=__doc__)\n    parser.add_argument('collated_html', type=argparse.FileType('r'),\n                        help='Path to the collated html'\n                             ' file (use - for stdin)')\n    parser.add_argument('-d', '--dump-tree', action='store_true',\n                        help='Print out parsed model tree.')\n\n    parser.add_argument('-o', '--output', type=argparse.FileType('w+'),\n                        help='Write out epub of parsed tree.')\n\n    parser.add_argument('-i', '--input', type=argparse.FileType('r'),\n                        help='Read and copy resources/ for output epub.')\n\n    args = parser.parse_args(argv)\n\n    if args.input and args.output == sys.stdout:\n        raise ValueError('Cannot output to stdout if reading resources')\n\n    from cnxepub.collation import reconstitute\n    binder = reconstitute(args.collated_html)\n\n    if args.dump_tree:\n        print(pformat(cnxepub.model_to_tree(binder)),\n              file=sys.stdout)\n    if args.output:\n        cnxepub.adapters.make_epub(binder, args.output)\n\n    if args.input:\n        args.output.seek(0)\n        zout = ZipFile(args.output, 'a', ZIP_DEFLATED)\n        zin = ZipFile(args.input, 'r')\n        for res in zin.namelist():\n            if res.startswith('resources'):\n                zres = zin.open(res)\n                zi = zin.getinfo(res)\n                zout.writestr(zi, zres.read(), ZIP_DEFLATED)\n        zout.close()\n\n    # TODO Check for documents that have no identifier.\n    #      These should likely be composite-documents\n    #      or the the metadata got wiped out.\n    # docs = [x for x in cnxepub.flatten_to(binder, only_documents_filter)\n    #         if x.ident_hash is None]\n\n    return 0"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating an embed UI containing a hex color message", "response": "def success(channel, image, hex_str):\n    \"\"\"\n    Creates an embed UI containing a hex color message\n\n    Args:\n        channel (discord.Channel): The Discord channel to bind the embed to\n        image (str): The url of the image to add\n        hex_str (str): The hex value\n\n    Returns:\n        ui (ui_embed.UI): The embed UI object that was created\n    \"\"\"\n\n    hex_number = int(hex_str, 16)\n\n    # Create embed UI object\n    gui = ui_embed.UI(\n        channel,\n        \"\",\n        \"#{}\".format(hex_str),\n        modulename=modulename,\n        colour=hex_number,\n        thumbnail=image,\n    )\n\n    return gui"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nadding text to the readme at the given level", "response": "def add_md(text, s, level=0):\n    \"\"\"Adds text to the readme at the given level\"\"\"\n    if level > 0:\n        if text != \"\":\n            text += \"\\n\"\n        text += \"#\" * level\n        text += \" \"\n\n    text += s + \"\\n\"\n\n    if level > 0:\n        text += \"\\n\"\n\n    return text"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef add_ul(text, ul):\n    text += \"\\n\"\n    for li in ul:\n        text += \"- \" + li + \"\\n\"\n    text += \"\\n\"\n\n    return text", "response": "Adds an unordered list to the readme"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ntakes a reporter editions dict and flatten it returning a dict for use in the DictWriter.", "response": "def make_editions_dict(editions):\n    \"\"\"Take a reporter editions dict and flatten it, returning a dict for\n    use in the DictWriter.\n    \"\"\"\n    d = {}\n    nums = ['1', '2', '3', '4', '5', '6']\n    num_counter = 0\n    for k, date_dict in editions.items():\n        d['edition%s' % nums[num_counter]] = k\n        if date_dict['start'] is not None:\n            d['start_e%s' % nums[num_counter]] = date_dict['start'].isoformat()\n        if date_dict['end'] is not None:\n            d['end_e%s' % nums[num_counter]] = date_dict['end'].isoformat()\n\n        num_counter += 1\n\n    return d"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\nasync def on_message(message):\n\n    # Simplify message info\n    server = message.server\n    author = message.author\n    channel = message.channel\n    content = message.content\n\n    data = datatools.get_data()\n\n    if not data[\"discord\"][\"servers\"][server.id][_data.modulename][\"activated\"]:\n        return\n\n    # Only reply to server messages and don't reply to myself\n    if server is not None and author != channel.server.me:\n        # Commands section\n        prefix = data[\"discord\"][\"servers\"][server.id][\"prefix\"]\n        if content.startswith(prefix):\n            # Parse message\n            package = content.split(\" \")\n            command = package[0][len(prefix):]\n            args = package[1:]\n\n            alias_steam = [\"steam\", \"pc\"]\n            alias_ps = [\"ps\", \"psn\", \"playstation\", \"ps4\", \"playstation 4\"]\n            alias_xbox = [\"xbox\", \"xb\", \"xb1\", \"xbone\", \"xbox one\", \"xbox one\"]\n\n            platform = \"steam\"\n            if len(args) > 0:\n                player_name = args[0]\n            else:\n                return\n\n            if len(args) > 1:\n                platform = ' '.join(args[1:]).lower()\n\n            if platform in alias_steam:\n                platform = \"steam\"\n            elif platform in alias_ps:\n                platform = \"ps\"\n            elif platform in alias_xbox:\n                platform = \"xbox\"\n\n            # Commands\n            if command == 'rlstats':\n                await client.send_typing(channel)\n\n                # Get Rocket League stats from stats API\n                success, rldata = api_rocketleaguestats.check_rank(player_name, platform)\n                # Create embed UI\n                if success:\n                    embed = ui_embed.success(channel, rldata[0], rldata[1], rldata[2], rldata[3])\n                else:\n                    embed = ui_embed.fail_api(channel)\n\n                await embed.send()", "response": "The on_message event handler for this module."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nupdates the Google API key with the text value", "response": "def update_keys(self):\n        \"\"\"Updates the Google API key with the text value\"\"\"\n        from ...main import add_api_key\n        add_api_key(\"google_api_key\", self.google_api_key.get())\n        add_api_key(\"soundcloud_client_id\", self.soundcloud_client_id.get())"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef modify_module(channel, module_name, module_state):\n\n    # Create embed UI object\n    gui = ui_embed.UI(\n        channel,\n        \"{} updated\".format(module_name),\n        \"{} is now {}\".format(module_name, \"activated\" if module_state else \"deactivated\"),\n        modulename=modulename\n    )\n\n    return gui", "response": "Creates an embed UI containing the module modified message"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate an embed UI containing the prefix modified message", "response": "def modify_prefix(channel, new_prefix):\n    \"\"\"\n    Creates an embed UI containing the prefix modified message\n\n    Args:\n        channel (discord.Channel): The Discord channel to bind the embed to\n        new_prefix (str): The value of the new prefix\n\n    Returns:\n        embed: The created embed\n    \"\"\"\n\n    # Create embed UI object\n    gui = ui_embed.UI(\n        channel,\n        \"Prefix updated\",\n        \"Modis prefix is now `{}`\".format(new_prefix),\n        modulename=modulename\n    )\n\n    return gui"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef user_warning(channel, user, warnings, max_warnings):\n\n    username = user.name\n    if isinstance(user, discord.Member):\n        if user.nick is not None:\n            username = user.nick\n\n    warning_count_text = \"warnings\" if warnings != 1 else \"warning\"\n    warning_text = \"{} {}\".format(warnings, warning_count_text)\n    result_text = \"at {} you will be banned\".format(max_warnings)\n    if warnings >= max_warnings:\n        result_text = \"you are being banned because you have more than the maximum warnings\"\n\n    # Create embed UI object\n    gui = ui_embed.UI(\n        channel,\n        \"Warning {}\".format(username),\n        \"You now have {} {}, {}\".format(warning_text, username, result_text),\n        modulename=modulename\n    )\n\n    return gui", "response": "Creates an embed UI containing a user warning message"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef user_ban(channel, user):\n\n    username = user.name\n    if isinstance(user, discord.Member):\n        if user.nick is not None:\n            username = user.nick\n\n    # Create embed UI object\n    gui = ui_embed.UI(\n        channel,\n        \"Banned {}\".format(username),\n        \"{} has been banned from this server\".format(username),\n        modulename=modulename\n    )\n\n    return gui", "response": "Creates an embed UI containing an user banned message"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating an embed UI containing an error message if the maximum warnings has been changed", "response": "def warning_max_changed(channel, max_warnings):\n    \"\"\"\n    Creates an embed UI containing an error message\n\n    Args:\n        channel (discord.Channel): The Discord channel to bind the embed to\n        max_warnings (int): The new maximum warnings\n\n    Returns:\n        ui (ui_embed.UI): The embed UI object\n    \"\"\"\n\n    # Create embed UI object\n    gui = ui_embed.UI(\n        channel,\n        \"Maximum Warnings Changed\",\n        \"Users must now have {} warnings to be banned \"\n        \"(this won't ban existing users with warnings)\".format(max_warnings),\n        modulename=modulename\n    )\n\n    return gui"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef error(channel, title, description):\n\n    # Create embed UI object\n    gui = ui_embed.UI(\n        channel,\n        title,\n        description,\n        modulename=modulename\n    )\n\n    return gui", "response": "Creates an embed UI containing an error message"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\nasync def update_server_data(server):\n\n    data = datatools.get_data()\n    # Add the server to server data if it doesn't yet exist\n    send_welcome_message = False\n    if server.id not in data[\"discord\"][\"servers\"]:\n        logger.debug(\"Adding new server to serverdata\")\n        data[\"discord\"][\"servers\"][server.id] = {\"prefix\": \"!\"}\n        if \"mute_intro\" not in data or not data[\"mute_intro\"]:\n            send_welcome_message = True\n\n    # Make sure all modules are in the server\n    _dir = os.path.realpath(os.path.join(os.getcwd(), os.path.dirname(__file__)))\n    _dir_modules = \"{}/../\".format(_dir)\n    for module_name in os.listdir(_dir_modules):\n        if module_name.startswith(\"_\") or module_name.startswith(\"!\"):\n            continue\n\n        if not os.path.isfile(\"{}/{}/_data.py\".format(_dir_modules, module_name)):\n            logger.warning(\"No _data.py file found for module {}\".format(module_name))\n            continue\n\n        try:\n            import_name = \".discord_modis.modules.{}.{}\".format(module_name, \"_data\")\n            _data = importlib.import_module(import_name, \"modis\")\n\n            if _data.modulename not in data[\"discord\"][\"servers\"][server.id]:\n                data[\"discord\"][\"servers\"][server.id][_data.modulename] = _data.sd_structure\n                datatools.write_data(data)\n        except Exception as e:\n            logger.error(\"Could not initialise module {}\".format(module_name))\n            logger.exception(e)\n\n    datatools.write_data(data)\n\n    # Send a welcome message now\n    if send_welcome_message:\n        default_channel = server.default_channel\n        if not default_channel:\n            for channel in server.channels:\n                if channel.name == \"general\":\n                    default_channel = channel\n                    break\n        if not default_channel:\n            for channel in server.channels:\n                if \"general\" in channel.name:\n                    default_channel = channel\n                    break\n        if not default_channel:\n            for channel in server.channels:\n                if channel.type == discord.ChannelType.text:\n                    default_channel = channel\n                    break\n\n        # Display a welcome message\n        if default_channel:\n            hello_message = \"Hello! I'm Modis.\\n\\n\" + \\\n                            \"The prefix is currently `!`, and can be changed at any time using `!prefix`\\n\\n\" + \\\n                            \"You can use `!help` to get help commands for all modules, \" + \\\n                            \"or {} me to get the server prefix and help commands.\".format(server.me.mention)\n            await client.send_message(default_channel, hello_message)", "response": "Updates the server data for the given server."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef remove_server_data(server_id):\n\n    logger.debug(\"Removing server from serverdata\")\n    # Remove the server from data\n    data = datatools.get_data()\n    if server_id in data[\"discord\"][\"servers\"]:\n        data[\"discord\"][\"servers\"].pop(server_id)\n        datatools.write_data(data)", "response": "Removes a server from the server data"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nchecks all servers and removes any that Modis isn t part of any more", "response": "def check_all_servers():\n    \"\"\"Checks all servers, removing any that Modis isn't part of any more\"\"\"\n    data = datatools.get_data()\n    for server_id in data[\"discord\"][\"servers\"]:\n        is_in_client = False\n        for client_server in client.servers:\n            if server_id == client_server.id:\n                is_in_client = True\n                break\n\n        if not is_in_client:\n            remove_server_data(server_id)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nclearing all modules from the list", "response": "def clear_modules(self):\n        \"\"\"Clears all modules from the list\"\"\"\n        for child in self.module_selection.winfo_children():\n            child.destroy()\n\n        self.clear_ui()\n\n        tk.Label(self.module_ui, text=\"Start Modis and select a module\").grid(\n            column=0, row=0, padx=0, pady=0, sticky=\"W E N S\")\n\n        if self.current_button is not None:\n            self.current_button.config(bg=\"white\")\n\n        self.module_buttons = {}\n        self.current_button = None"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef add_module(self, module_name, module_ui):\n        m_button = tk.Label(self.module_selection, text=module_name, bg=\"white\", anchor=\"w\")\n        m_button.grid(column=0, row=len(self.module_selection.winfo_children()), padx=0, pady=0, sticky=\"W E N S\")\n\n        self.module_buttons[module_name] = m_button\n        m_button.bind(\"<Button-1>\", lambda e: self.module_selected(module_name, module_ui))", "response": "Adds a module to the list of available modules"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncalling when a module is selected.", "response": "def module_selected(self, module_name, module_ui):\n        \"\"\"\n        Called when a module is selected\n\n        Args:\n            module_name (str): The name of the module\n            module_ui: The function to call to create the module's UI\n        \"\"\"\n        if self.current_button == self.module_buttons[module_name]:\n            return\n\n        self.module_buttons[module_name].config(bg=\"#cacaca\")\n        if self.current_button is not None:\n            self.current_button.config(bg=\"white\")\n        self.current_button = self.module_buttons[module_name]\n\n        self.clear_ui()\n\n        try:\n            # Create the UI\n            module_ui_frame = ModuleUIBaseFrame(self.module_ui, module_name, module_ui)\n            module_ui_frame.grid(column=0, row=0, sticky=\"W E N S\")\n        except Exception as e:\n            logger.error(\"Could not load UI for {}\".format(module_name))\n            logger.exception(e)\n            # Create a error UI\n            tk.Label(self.module_ui, text=\"Could not load UI for {}\".format(module_name)).grid(\n                column=0, row=0, padx=0, pady=0, sticky=\"W E N S\")"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ntoggle Modis on or off", "response": "def toggle(self, discord_token, discord_client_id):\n        \"\"\"Toggles Modis on or off\"\"\"\n        if self.state == 'off':\n            self.start(discord_token, discord_client_id)\n        elif self.state == 'on':\n            self.stop()"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef start(self, discord_token, discord_client_id):\n        self.button_toggle_text.set(\"Stop Modis\")\n        self.state = \"on\"\n\n        self.status_bar.set_status(1)\n\n        logger.info(\"----------------STARTING DISCORD MODIS----------------\")\n\n        # Clear the module list\n        self.module_frame.clear_modules()\n\n        # Start Modis\n        from modis.discord_modis import main\n        logger.debug(\"Creating event loop\")\n        loop = asyncio.new_event_loop()\n        asyncio.set_event_loop(loop)\n        self.discord_thread = threading.Thread(\n            target=main.start,\n            args=[discord_token, discord_client_id, loop, self.on_ready])\n        logger.debug(\"Starting event loop\")\n        self.discord_thread.start()\n\n        # Find module UIs\n        database_dir = \"{}/modules\".format(\n            os.path.dirname(os.path.realpath(__file__)))\n        for module_name in os.listdir(database_dir):\n            module_dir = \"{}/{}\".format(database_dir, module_name)\n\n            # Iterate through files in module\n            if os.path.isdir(module_dir) and not module_name.startswith(\"_\"):\n                # Add all defined event handlers in module files\n                module_event_handlers = os.listdir(module_dir)\n\n                if \"_ui.py\" in module_event_handlers:\n                    import_name = \".discord_modis.modules.{}.{}\".format(\n                        module_name, \"_ui\")\n                    logger.debug(\n                        \"Found module UI file {}\".format(import_name[23:]))\n\n                    self.module_frame.add_module(module_name, importlib.import_module(import_name, \"modis\"))\n                else:\n                    self.module_frame.add_module(module_name, None)", "response": "Start Modis and log it into Discord."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef stop(self):\n        self.button_toggle_text.set(\"Start Modis\")\n        self.state = \"off\"\n\n        logger.info(\"Stopping Discord Modis\")\n\n        from ._client import client\n        asyncio.run_coroutine_threadsafe(client.logout(), client.loop)\n        self.status_bar.set_status(0)", "response": "Stop Modis and log it out of Discord."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncheck if the key name and value fields have been set and updates the add key button", "response": "def key_changed(self):\n        \"\"\"Checks if the key name and value fields have been set, and updates the add key button\"\"\"\n        if self.key_name.get() and self.key_val.get():\n            self.button_key_add.state([\"!disabled\"])\n        else:\n            self.button_key_add.state([\"disabled\"])"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef key_add(self):\n        from .main import add_api_key\n        add_api_key(self.key_name.get(), self.key_val.get())\n\n        # Clear the text fields\n        self.key_name.set(\"\")\n        self.key_val.set(\"\")", "response": "Adds the current API key to the bot s data"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nupdates the status text for the modisical cache entry.", "response": "def set_status(self, status):\n        \"\"\"\n        Updates the status text\n\n        Args:\n            status (int): The offline/starting/online status of Modis\n                0: offline, 1: starting, 2: online\n        \"\"\"\n\n        text = \"\"\n        colour = \"#FFFFFF\"\n        if status == 0:\n            text = \"OFFLINE\"\n            colour = \"#EF9A9A\"\n        elif status == 1:\n            text = \"STARTING\"\n            colour = \"#FFE082\"\n        elif status == 2:\n            text = \"ONLINE\"\n            colour = \"#A5D6A7\"\n\n        self.status.set(text)\n        self.statusbar.config(background=colour)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_help_data(filepath):\n\n    try:\n        with open(filepath, 'r') as file:\n            return _json.load(file, object_pairs_hook=OrderedDict)\n    except Exception as e:\n        logger.error(\"Could not load file {}\".format(filepath))\n        logger.exception(e)\n        return {}", "response": "Get the json data from a help file"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_help_datapacks(filepath, prefix=\"!\"):\n\n    help_contents = get_help_data(filepath)\n\n    datapacks = []\n\n    # Add the content\n    for d in help_contents:\n        heading = d\n        content = \"\"\n\n        if \"commands\" in d.lower():\n            for c in help_contents[d]:\n                if \"name\" not in c:\n                    continue\n\n                content += \"- `\"\n                command = prefix + c[\"name\"]\n                content += \"{}\".format(command)\n                if \"params\" in c:\n                    for param in c[\"params\"]:\n                        content += \" [{}]\".format(param)\n                content += \"`: \"\n                if \"description\" in c:\n                    content += c[\"description\"]\n                content += \"\\n\"\n        else:\n            content += help_contents[d]\n\n        datapacks.append((heading, content, False))\n\n    return datapacks", "response": "Load help text from a file and give it as datapacks\nWorkItem"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nload the help text from a file and add it to the parent object.", "response": "def add_help_text(parent, filepath, prefix=\"!\"):\n    \"\"\"\n    Load help text from a file and adds it to the parent\n\n    Args:\n        parent: A tk or ttk object\n        filepath (str): The file to load help text from\n        prefix (str): The prefix to use for commands\n    \"\"\"\n\n    import tkinter as tk\n    import tkinter.ttk as ttk\n\n    help_contents = get_help_data(filepath)\n\n    text = tk.Text(parent, wrap='word', font=(\"Helvetica\", 10))\n    text.grid(row=0, column=0, sticky=\"W E N S\")\n    text.tag_config(\"heading\", font=(\"Helvetica\", 14))\n    text.tag_config(\"command\", font=(\"Courier\", 10))\n    text.tag_config(\"param\", font=(\"Courier\", 10))\n    text.tag_config(\"description\")\n\n    # Vertical Scrollbar\n    scrollbar = ttk.Scrollbar(parent, orient=\"vertical\", command=text.yview)\n    scrollbar.grid(column=1, row=0, sticky=\"N S\")\n    text['yscrollcommand'] = scrollbar.set\n\n    # Add the content\n    for d in help_contents:\n        text.insert('end', d, \"heading\")\n        text.insert('end', '\\n')\n\n        if \"commands\" in d.lower():\n            for c in help_contents[d]:\n                if \"name\" not in c:\n                    continue\n\n                command = prefix + c[\"name\"]\n                text.insert('end', command, (\"command\", \"description\"))\n                if \"params\" in c:\n                    for param in c[\"params\"]:\n                        text.insert('end', \" [{}]\".format(param), (\"param\", \"description\"))\n                text.insert('end', \": \")\n                if \"description\" in c:\n                    text.insert('end', c[\"description\"], \"description\")\n\n                text.insert('end', '\\n')\n\n            text.insert('end', '\\n')\n        else:\n            text.insert('end', help_contents[d], \"description\")\n            text.insert('end', '\\n\\n')\n\n    text.config(state=tk.DISABLED)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\nasync def on_reaction_add(reaction, user):\n\n    # Simplify reaction info\n    server = reaction.message.server\n    emoji = reaction.emoji\n\n    data = datatools.get_data()\n\n    if not data[\"discord\"][\"servers\"][server.id][_data.modulename][\"activated\"]:\n        return\n\n    # Commands section\n    if user != reaction.message.channel.server.me:\n        if server.id not in _data.cache or _data.cache[server.id].state == 'destroyed':\n            return\n\n        try:\n            valid_reaction = reaction.message.id == _data.cache[server.id].embed.sent_embed.id\n        except AttributeError:\n            pass\n        else:\n            if valid_reaction:\n                # Remove reaction\n                try:\n                    await client.remove_reaction(reaction.message, emoji, user)\n                except discord.errors.NotFound:\n                    pass\n                except discord.errors.Forbidden:\n                    pass\n\n                # Commands\n                if emoji == \"\u23ef\":\n                    await _data.cache[server.id].toggle()\n                if emoji == \"\u23f9\":\n                    await _data.cache[server.id].stop()\n                if emoji == \"\u23ed\":\n                    await _data.cache[server.id].skip(\"1\")\n                if emoji == \"\u23ee\":\n                    await _data.cache[server.id].rewind(\"1\")\n                if emoji == \"\ud83d\udd00\":\n                    await _data.cache[server.id].shuffle()\n                if emoji == \"\ud83d\udd09\":\n                    await _data.cache[server.id].setvolume('-')\n                if emoji == \"\ud83d\udd0a\":\n                    await _data.cache[server.id].setvolume('+')", "response": "The on_message event handler for this module."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nstarting Modis in console format.", "response": "def console(discord_token, discord_client_id):\n    \"\"\"\n    Start Modis in console format.\n\n    Args:\n        discord_token (str): The bot token for your Discord application\n        discord_client_id: The bot's client ID\n    \"\"\"\n\n    state, response = datatools.get_compare_version()\n\n    logger.info(\"Starting Modis in console\")\n    logger.info(response)\n\n    import threading\n    import asyncio\n\n    logger.debug(\"Loading packages\")\n    from modis.discord_modis import main as discord_modis_console\n    from modis.reddit_modis import main as reddit_modis_console\n    from modis.facebook_modis import main as facebook_modis_console\n\n    # Create threads\n    logger.debug(\"Initiating threads\")\n    loop = asyncio.get_event_loop()\n    discord_thread = threading.Thread(\n        target=discord_modis_console.start,\n        args=[discord_token, discord_client_id, loop])\n    reddit_thread = threading.Thread(\n        target=reddit_modis_console.start, args=[])\n    facebook_thread = threading.Thread(\n        target=facebook_modis_console.start, args=[])\n\n    # Run threads\n    logger.debug(\"Starting threads\")\n    discord_thread.start()\n    reddit_thread.start()\n    facebook_thread.start()\n\n    logger.debug(\"Root startup completed\")"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef gui(discord_token, discord_client_id):\n\n    logger.info(\"Starting Modis in GUI\")\n\n    import tkinter as tk\n\n    logger.debug(\"Loading packages\")\n    from modis.discord_modis import gui as discord_modis_gui\n    from modis.reddit_modis import gui as reddit_modis_gui\n    from modis.facebook_modis import gui as facebook_modis_gui\n\n    logger.debug(\"Initialising window\")\n\n    # Setup the root window\n    root = tk.Tk()\n    root.minsize(width=800, height=400)\n    root.geometry(\"800x600\")\n    root.title(\"Modis Control Panel\")\n    # Icon\n    root.iconbitmap(r\"{}/assets/modis.ico\".format(file_dir))\n\n    # Setup the notebook\n    \"\"\"notebook = ttk.Notebook(root)\n    notebook.grid(column=0, row=0, padx=0, pady=0, sticky=\"W E N S\")\n\n    # Configure stretch ratios\n    root.columnconfigure(0, weight=1)\n    root.rowconfigure(0, weight=1)\n    notebook.columnconfigure(0, weight=1)\n    notebook.rowconfigure(0, weight=1)\n\n    # Add tabs\n    logger.debug(\"Adding packages to window\")\n    notebook.add(\n        discord_modis_gui.Frame(notebook, discord_token, discord_client_id),\n        text=\"Discord\")\n    notebook.add(reddit_modis_gui.Frame(notebook), text=\"Reddit\")\n    notebook.add(facebook_modis_gui.Frame(notebook), text=\"Facebook\")\"\"\"\n    discord = discord_modis_gui.Frame(root, discord_token, discord_client_id)\n    discord.grid(column=0, row=0, padx=0, pady=0, sticky=\"W E N S\")\n    # Configure stretch ratios\n    root.columnconfigure(0, weight=1)\n    root.rowconfigure(0, weight=1)\n    discord.columnconfigure(0, weight=1)\n    discord.rowconfigure(0, weight=1)\n\n    logger.debug(\"GUI initialised\")\n\n    # Run the window UI\n    root.mainloop()", "response": "Start Modis in GUI format."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef write_data(data):\n\n    sorted_dict = sort_recursive(data)\n\n    with open(_datafile, 'w') as file:\n        _json.dump(sorted_dict, file, indent=2)", "response": "Writes the data dictionary to the data. json file"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef sort_recursive(data):\n\n    newdict = {}\n\n    for i in data.items():\n        if type(i[1]) is dict:\n            newdict[i[0]] = sort_recursive(i[1])\n        else:\n            newdict[i[0]] = i[1]\n\n    return OrderedDict(sorted(newdict.items(), key=lambda item: (compare_type(type(item[1])), item[0])))", "response": "Recursively sorts all elements in a dictionary\n   "}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_compare_version():\n\n    state, latest_version = compare_latest_version()\n    if state < 0:\n        return -1, \"A new version of Modis is available (v{})\".format(latest_version)\n    elif state == 0:\n        return 0, \"You are running the latest version of Modis (v{})\".format(version)\n    else:\n        return 1, \"You are running a preview version of Modis (v{} pre-release)\".format(version)", "response": "Get the version comparison info."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef success(channel, stats, name, platform, dp):\n\n    # Create datapacks\n    datapacks = [(\"Platform\", platform, False)]\n    for stat in stats:\n        # Add stats\n        if stat[0] in (\"Duel 1v1\", \"Doubles 2v2\", \"Solo Standard 3v3\", \"Standard 3v3\"):\n            stat_name = \"__\" + stat[0] + \"__\"\n            stat_value = \"**\" + stat[1] + \"**\"\n        else:\n            stat_name = stat[0]\n            stat_value = stat[1]\n\n        # Add percentile if it exists\n        if stat[2]:\n            stat_value += \" *(Top \" + stat[2] + \"%)*\"\n\n        datapacks.append((stat_name, stat_value, True))\n\n    # Create embed UI object\n    gui = ui_embed.UI(\n        channel,\n        \"Rocket League Stats: {}\".format(name),\n        \"*Stats obtained from [Rocket League Tracker Network](https://rocketleague.tracker.network/)*\",\n        modulename=modulename,\n        colour=0x0088FF,\n        thumbnail=dp,\n        datapacks=datapacks\n    )\n\n    return gui", "response": "Create an embed UI containing the Rocket League Stats"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef fail_steamid(channel):\n\n    gui = ui_embed.UI(\n        channel,\n        \"That SteamID doesn't exist.\",\n        \"You can get your SteamID by going to your profile page and looking at the url, \"\n        \"or you can set a custom ID by going to edit profile on your profile page.\",\n        modulename=modulename,\n        colour=0x0088FF\n    )\n\n    return gui", "response": "Creates an embed UI for invalid SteamIDs"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef fail_api(channel):\n\n    gui = ui_embed.UI(\n        channel,\n        \"Couldn't get stats off RLTrackerNetwork.\",\n        \"Maybe the API changed, please tell Infraxion.\",\n        modulename=modulename,\n        colour=0x0088FF\n    )\n\n    return gui", "response": "Creates an embed UI for when the API call didn t work"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\nasync def on_message(message):\n\n    # Simplify message info\n    server = message.server\n    author = message.author\n    channel = message.channel\n    content = message.content\n\n    data = datatools.get_data()\n\n    if not data[\"discord\"][\"servers\"][server.id][_data.modulename][\"activated\"]:\n        return\n\n    # Only reply to server messages and don't reply to myself\n    if server is not None and author != channel.server.me:\n        # Commands section\n        prefix = data[\"discord\"][\"servers\"][server.id][\"prefix\"]\n        if content.startswith(prefix):\n            # Parse message\n            package = content.split(\" \")\n            command = package[0][len(prefix):]\n\n            # Commands\n            if command == 'gamedeals':\n                await client.send_typing(channel)\n\n                # Get posts from Reddit API\n                posts = api_reddit.get_top10()\n\n                if posts:\n                    for post in posts:\n                        # Create embed UI\n                        embed = ui_embed.success(channel, post)\n                        await embed.send()\n                else:\n                    embed = ui_embed.no_results(channel)\n                    await embed.send()", "response": "The on_message event handler for this module."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncreates an embed UI containing the Reddit posts", "response": "def success(channel, post):\n    \"\"\"Creates an embed UI containing the Reddit posts\n\n    Args:\n        channel (discord.Channel): The Discord channel to bind the embed to\n        post (tuple): Tuples of (field, value, percentile)\n\n    Returns:\n\n    \"\"\"\n\n    # Create datapacks\n    datapacks = [(\"Game\", post[0], True), (\"Upvotes\", post[2], True)]\n\n    # Create embed UI object\n    gui = ui_embed.UI(\n        channel,\n        \"Link\",\n        post[1],\n        modulename=modulename,\n        colour=0xFF8800,\n        thumbnail=post[1],\n        datapacks=datapacks\n    )\n\n    return gui"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef no_results(channel):\n\n    gui = ui_embed.UI(\n        channel,\n        \"No results\",\n        \":c\",\n        modulename=modulename,\n        colour=0xFF8800\n    )\n\n    return gui", "response": "Creates an embed UI for when there were no results"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nmaking a new time bar string based on the current song s progress and duration.", "response": "def make_timebar(progress=0, duration=0):\n    \"\"\"\n    Makes a new time bar string\n\n    Args:\n        progress: How far through the current song we are (in seconds)\n        duration: The duration of the current song (in seconds)\n\n    Returns:\n        timebar (str): The time bar string\n    \"\"\"\n\n    duration_string = api_music.duration_to_string(duration)\n    if duration <= 0:\n        return \"---\"\n\n    time_counts = int(round((progress / duration) * TIMEBAR_LENGTH))\n    if time_counts > TIMEBAR_LENGTH:\n        time_counts = TIMEBAR_LENGTH\n\n    if duration > 0:\n        bar = \"\u2502\" + (TIMEBAR_PCHAR * time_counts) + (TIMEBAR_ECHAR * (TIMEBAR_LENGTH - time_counts)) + \"\u2502\"\n        time_bar = \"{} {}\".format(bar, duration_string)\n    else:\n        time_bar = duration_string\n\n    return time_bar"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef build(self):\n\n        if self.colour:\n            embed = discord.Embed(\n                title=self.title,\n                type='rich',\n                description=self.description,\n                colour=self.colour)\n        else:\n            embed = discord.Embed(\n                title=self.title,\n                type='rich',\n                description=self.description)\n\n        if self.thumbnail:\n            embed.set_thumbnail(url=self.thumbnail)\n\n        if self.image:\n            embed.set_image(url=self.image)\n\n        embed.set_author(\n            name=\"Modis\",\n            url=\"https://musicbyango.com/modis/\",\n            icon_url=\"http://musicbyango.com/modis/dp/modis64t.png\")\n\n        for pack in self.datapacks:\n            embed.add_field(\n                name=pack[0],\n                value=pack[1],\n                inline=pack[2]\n            )\n\n        return embed", "response": "Builds Discord embed for a specific object."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef update_data(self, index, data):\n\n        datapack = self.built_embed.to_dict()[\"fields\"][index]\n        self.built_embed.set_field_at(index, name=datapack[\"name\"], value=data, inline=datapack[\"inline\"])", "response": "Updates a particular datapack s data\n            at the given index"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nbuild a dictionary of variations to canonical reporters.", "response": "def suck_out_variations_only(reporters):\n    \"\"\"Builds a dictionary of variations to canonical reporters.\n\n    The dictionary takes the form of:\n        {\n         \"A. 2d\": [\"A.2d\"],\n         ...\n         \"P.R.\": [\"Pen. & W.\", \"P.R.R.\", \"P.\"],\n        }\n\n    In other words, it's a dictionary that maps each variation to a list of\n    reporters that it could be possibly referring to.\n    \"\"\"\n    variations_out = {}\n    for reporter_key, data_list in reporters.items():\n        # For each reporter key...\n        for data in data_list:\n            # For each book it maps to...\n            for variation_key, variation_value in data[\"variations\"].items():\n                try:\n                    variations_list = variations_out[variation_key]\n                    if variation_value not in variations_list:\n                        variations_list.append(variation_value)\n                except KeyError:\n                    # The item wasn't there; add it.\n                    variations_out[variation_key] = [variation_value]\n\n    return variations_out"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef suck_out_editions(reporters):\n    editions_out = {}\n    for reporter_key, data_list in reporters.items():\n        # For each reporter key...\n        for data in data_list:\n            # For each book it maps to...\n            for edition_key, edition_value in data[\"editions\"].items():\n                try:\n                    editions_out[edition_key]\n                except KeyError:\n                    # The item wasn't there; add it.\n                    editions_out[edition_key] = reporter_key\n    return editions_out", "response": "Builds a dictionary mapping edition keys to their root name."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nbuilding a dict mapping names to their variations.", "response": "def names_to_abbreviations(reporters):\n    \"\"\"Build a dict mapping names to their variations\n\n    Something like:\n\n        {\n            \"Atlantic Reporter\": ['A.', 'A.2d'],\n        }\n\n    Note that the abbreviations are sorted by start date.\n    \"\"\"\n    names = {}\n    for reporter_key, data_list in reporters.items():\n        for data in data_list:\n            abbrevs = data['editions'].keys()\n            # Sort abbreviations by start date of the edition\n            sort_func = lambda x: str(data['editions'][x]['start']) + x\n            abbrevs = sorted(abbrevs, key=sort_func)\n            names[data['name']] = abbrevs\n    sorted_names = OrderedDict(sorted(names.items(), key=lambda t: t[0]))\n    return sorted_names"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef check_rank(player, platform=\"steam\"):\n\n    # Get player ID and name Rocket League Tracker Network\n    webpage = requests.get(\n        \"https://rocketleague.tracker.network/profile/{}/{}\".format(platform, player)\n    ).text\n\n    try:\n        # Get player ID\n        playerid_index = webpage.index(\"/live?ids=\") + len(\"/live?ids=\")\n        playerid_end_index = webpage.index(\"\"\"\">\"\"\", playerid_index)\n        playerid = webpage[playerid_index:playerid_end_index]\n\n        # Get player name\n        name_index = webpage.index(\"Stats Profile : \") + len(\"Stats Profile : \")\n        name_end_index = webpage.index(\"\"\"\\n\"\"\", name_index)\n        name = webpage[name_index:name_end_index]\n    except (ValueError, IndexError):\n        return False, ()\n\n    # Get player stats from Rocket League Tracker Network\n    livedata = json.loads(\n        requests.post(\n            \"https://rocketleague.tracker.network/live/data\",\n            json={\"playerIds\": [playerid]}\n        ).text\n    )\n\n    stats = []\n    try:\n        for statpack in livedata['players'][0]['Stats']:\n            field = statpack['Value']['Label']\n            value = str(statpack['Value']['DisplayValue'])\n            if statpack['Value']['Percentile']:\n                percentile = str(statpack['Value']['Percentile'])\n            else:\n                percentile = None\n            stats.append((field, value, percentile))\n    except (IndexError, KeyError):\n        return False, ()\n\n    dp = \"https://rocketleague.media.zestyio.com/rocket-league-logos-vr-white.f1cb27a519bdb5b6ed34049a5b86e317.png\"\n\n    platform_display = platform\n    if platform == \"steam\":\n        platform_display = \"Steam\"\n    elif platform == \"ps\":\n        platform_display = \"PlayStation\"\n    elif platform == \"xbox\":\n        platform_display = \"Xbox\"\n\n    return True, (stats, name, platform_display, dp)", "response": "Checks if the player has ranked on the Rocket League Tracker."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef send_message(channel_id, message):\n\n    channel = client.get_channel(channel_id)\n\n    if channel is None:\n        logger.info(\"{} is not a channel\".format(channel_id))\n        return\n\n    # Check that it's enabled in the server\n    data = datatools.get_data()\n    if not data[\"discord\"][\"servers\"][channel.server.id][modulename][\"activated\"]:\n        logger.info(\"This module has been disabled in {} ({})\".format(channel.server.name, channel.server.id))\n\n    try:\n        runcoro(client.send_message(channel, message))\n    except Exception as e:\n        logger.exception(e)", "response": "Send a message to a channel"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef runcoro(async_function):\n\n    future = _asyncio.run_coroutine_threadsafe(async_function, client.loop)\n    result = future.result()\n    return result", "response": "Runs an asynchronous function without needing to use async - useful for lambda\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\nasync def on_message(message):\n\n    # Simplify message info\n    server = message.server\n    author = message.author\n    channel = message.channel\n    content = message.content\n\n    data = datatools.get_data()\n\n    if not data[\"discord\"][\"servers\"][server.id][_data.modulename][\"activated\"]:\n        return\n\n    # Only reply to server messages and don't reply to myself\n    if server is not None and author != channel.server.me:\n        # Do a flip check\n        flipchecked = api_flipcheck.flipcheck(content)\n        if flipchecked:\n            await client.send_typing(channel)\n            await client.send_message(channel, flipchecked)", "response": "The on_message event handler for this module."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef update_keys(self):\n        from ...main import add_api_key\n        add_api_key(\"reddit_api_user_agent\", self.reddit_api_user_agent.get())\n        add_api_key(\"reddit_api_client_id\", self.reddit_api_client_id.get())\n        add_api_key(\"reddit_api_client_secret\", self.reddit_api_client_secret.get())", "response": "Updates the Google API key with the text value"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nactivates a module in the server", "response": "async def activate_module(channel, module_name, activate):\n    \"\"\"\n    Changes a modules activated/deactivated state for a server\n\n    Args:\n        channel: The channel to send the message to\n        module_name: The name of the module to change state for\n        activate: The activated/deactivated state of the module\n    \"\"\"\n\n    data = datatools.get_data()\n    server_id = channel.server.id\n\n    _dir = os.path.realpath(os.path.join(os.getcwd(), os.path.dirname(__file__)))\n    _dir_modules = \"{}/../\".format(_dir)\n    if not os.path.isfile(\"{}/{}/_data.py\".format(_dir_modules, module_name)):\n        await client.send_typing(channel)\n        embed = ui_embed.error(channel, \"Error\", \"No module found named '{}'\".format(module_name))\n        await embed.send()\n        return\n\n    try:\n        import_name = \".discord_modis.modules.{}.{}\".format(module_name, \"_data\")\n        module_data = importlib.import_module(import_name, \"modis\")\n\n        # Don't try and deactivate this module (not that it would do anything)\n        if module_data.modulename == _data.modulename:\n            await client.send_typing(channel)\n            embed = ui_embed.error(channel, \"Error\", \"I'm sorry, Dave. I'm afraid I can't do that.\")\n            await embed.send()\n            return\n\n        # This /should/ never happen if everything goes well\n        if module_data.modulename not in data[\"discord\"][\"servers\"][server_id]:\n            await client.send_typing(channel)\n            embed = ui_embed.error(channel, \"Error\",\n                                   \"No data found for module '{}'\".format(module_data.modulename))\n            await embed.send()\n            return\n\n        # Modify the module\n        if \"activated\" in data[\"discord\"][\"servers\"][server_id][module_data.modulename]:\n            data[\"discord\"][\"servers\"][server_id][module_data.modulename][\"activated\"] = activate\n            # Write the data\n            datatools.write_data(data)\n\n            await client.send_typing(channel)\n            embed = ui_embed.modify_module(channel, module_data.modulename, activate)\n            await embed.send()\n            return\n        else:\n            await client.send_typing(channel)\n            embed = ui_embed.error(channel, \"Error\", \"Can't deactivate module '{}'\".format(module_data.modulename))\n            await embed.send()\n            return\n    except Exception as e:\n        logger.error(\"Could not modify module {}\".format(module_name))\n        logger.exception(e)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nbans a user from a server", "response": "async def ban_user(channel, user):\n    \"\"\"\n    Bans a user from a server\n\n    Args:\n        channel: The channel to send the warning message in\n        user: The user to give the warning to\n    \"\"\"\n\n    data = datatools.get_data()\n    server_id = channel.server.id\n\n    try:\n        await client.ban(user)\n    except discord.errors.Forbidden:\n        await client.send_typing(channel)\n        embed = ui_embed.error(channel, \"Ban Error\", \"I do not have the permissions to ban that person.\")\n        await embed.send()\n        return\n\n    # Set the user's warnings to 0\n    if \"warnings\" in data[\"discord\"][\"servers\"][server_id][_data.modulename]:\n        if user.id in data[\"discord\"][\"servers\"][server_id][_data.modulename][\"warnings\"]:\n            data[\"discord\"][\"servers\"][server_id][_data.modulename][\"warnings\"][user.id] = 0\n            datatools.write_data(data)\n\n    await client.send_typing(channel)\n    embed = ui_embed.user_ban(channel, user)\n    await embed.send()\n\n    try:\n        response = \"You have been banned from the server '{}' \" \\\n                   \"contact the owners to resolve this issue.\".format(channel.server.name)\n        await client.send_message(user, response)\n    except Exception as e:\n        logger.exception(e)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget the help datapacks for a module", "response": "def get_help_datapacks(module_name, server_prefix):\n    \"\"\"\n    Get the help datapacks for a module\n\n    Args:\n        module_name (str): The module to get help data for\n        server_prefix (str): The command prefix for this server\n\n    Returns:\n        datapacks (list): The help datapacks for the module\n    \"\"\"\n\n    _dir = os.path.realpath(\n        os.path.join(os.getcwd(), os.path.dirname(__file__)))\n    module_dir = \"{}/../{}\".format(_dir, module_name, \"_help.json\")\n    if os.path.isdir(module_dir):\n        module_help_path = \"{}/{}\".format(module_dir, \"_help.json\")\n\n        if os.path.isfile(module_help_path):\n            return helptools.get_help_datapacks(module_help_path, server_prefix)\n        else:\n            return [(\"Help\", \"{} does not have a help.json file\".format(module_name), False)]\n    else:\n        return [(\"Help\", \"No module found called {}\".format(module_name), False)]"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_help_commands(server_prefix):\n\n    datapacks = []\n\n    _dir = os.path.realpath(\n        os.path.join(os.getcwd(), os.path.dirname(__file__)))\n    for module_name in os.listdir(\"{}/../\".format(_dir)):\n        if not module_name.startswith(\"_\") and not module_name.startswith(\"!\"):\n            help_command = \"`{}help {}`\".format(server_prefix, module_name)\n            datapacks.append((module_name, help_command, True))\n\n    return datapacks", "response": "Get the help commands for all modules in the current directory"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\nasync def on_message(message):\n\n    # Simplify message info\n    server = message.server\n    author = message.author\n    channel = message.channel\n    content = message.content\n\n    data = datatools.get_data()\n\n    # Only reply to server messages and don't reply to myself\n    if server is not None and author != channel.server.me:\n        # Commands section\n        prefix = data[\"discord\"][\"servers\"][server.id][\"prefix\"]\n        if content.startswith(prefix):\n            # Parse message\n            package = content.split(\" \")\n            command = package[0][len(prefix):]\n            args = package[1:]\n            arg = ' '.join(args)\n\n            # Commands\n            if command == 'help':\n                if args:\n                    # Parse message\n                    datapacks = api_help.get_help_datapacks(arg, prefix)\n                    # Create embed UI\n                    if datapacks:\n                        await client.send_typing(channel)\n                        embed = ui_embed.success(channel, arg, datapacks)\n                        try:\n                            await embed.send()\n                        except discord.errors.HTTPException:\n                            embed = ui_embed.http_exception(channel, arg)\n                            await embed.send()\n                else:\n                    # Parse message\n                    datapacks = api_help.get_help_commands(prefix)\n                    # Create embed UI\n                    if datapacks:\n                        await client.send_typing(channel)\n                        embed = ui_embed.success(channel, arg, datapacks)\n                        try:\n                            await embed.send()\n                        except discord.errors.HTTPException:\n                            embed = ui_embed.http_exception(channel, arg)\n                            await embed.send()", "response": "The on_message event handler for this module."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\nasync def on_message(message):\n\n    # Simplify message info\n    server = message.server\n    author = message.author\n    channel = message.channel\n    content = message.content\n\n    data = datatools.get_data()\n\n    # Only reply to server messages and don't reply to myself\n    if server is not None and author != channel.server.me:\n        prefix = data[\"discord\"][\"servers\"][server.id][\"prefix\"]\n        # Check for mentions reply to mentions\n        if channel.server.me in message.mentions:\n            await client.send_typing(channel)\n            response = \"The current server prefix is `{0}`. Type `{0}help` for help.\".format(prefix)\n            await client.send_message(channel, response)\n\n        # Commands section\n        if content.startswith(prefix):\n            # Parse message\n            package = content.split(\" \")\n            command = package[0][len(prefix):]\n            args = package[1:]\n            arg = ' '.join(args)\n\n            # Commands\n            if command not in [\"prefix\", \"activate\", \"deactivate\", \"warnmax\", \"warn\", \"ban\"]:\n                return\n\n            is_admin = author == server.owner\n            for role in message.author.roles:\n                if role.permissions.administrator:\n                    is_admin = True\n\n            if not is_admin:\n                await client.send_typing(channel)\n                reason = \"You must have a role that has the permission 'Administrator'\"\n                embed = ui_embed.error(channel, \"Insufficient Permissions\", reason)\n                await embed.send()\n                return\n\n            if command == \"prefix\" and args:\n                new_prefix = arg.replace(\" \", \"\").strip()\n                data[\"discord\"][\"servers\"][server.id][\"prefix\"] = new_prefix\n                # Write the data\n                datatools.write_data(data)\n\n                await client.send_typing(channel)\n                embed = ui_embed.modify_prefix(channel, new_prefix)\n                await embed.send()\n\n            if command == \"warnmax\" and args:\n                try:\n                    warn_max = int(arg)\n                    if warn_max > 0:\n                        data[\"discord\"][\"servers\"][server.id][_data.modulename][\"warnings_max\"] = warn_max\n                        datatools.write_data(data)\n                        await client.send_typing(channel)\n                        embed = ui_embed.warning_max_changed(channel, warn_max)\n                        await embed.send()\n                    else:\n                        reason = \"Maximum warnings must be greater than 0\"\n                        embed = ui_embed.error(channel, \"Error\", reason)\n                        await embed.send()\n                except (ValueError, TypeError):\n                    reason = \"Warning maximum must be a number\"\n                    embed = ui_embed.error(channel, \"Error\", reason)\n                    await embed.send()\n                except Exception as e:\n                    logger.exception(e)\n\n            if command == \"warn\" and args:\n                for user in message.mentions:\n                    await api_manager.warn_user(channel, user)\n\n            if command == \"ban\" and args:\n                for user in message.mentions:\n                    await api_manager.ban_user(channel, user)\n\n            if command == \"activate\" and args:\n                await api_manager.activate_module(channel, arg, True)\n            elif command == \"deactivate\" and args:\n                await api_manager.activate_module(channel, arg, False)", "response": "The on_message event handler for this module."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate an embed UI for the topic update", "response": "def topic_update(channel, topic_channel):\n    \"\"\"\n    Creates an embed UI for the topic update\n\n    Args:\n        channel (discord.Channel): The Discord channel to bind the embed to\n        topic_channel: The new topic channel\n\n    Returns:\n        embed: The created embed\n    \"\"\"\n\n    if topic_channel is not None:\n        try:\n            channel_message = \"Topic channel is now `{}`.\".format(topic_channel.name)\n        except Exception as e:\n            logger.exception(e)\n            channel_message = \"Topic channel has been updated.\"\n    else:\n        channel_message = \"Topic channel has been cleared.\"\n\n    # Create embed UI object\n    gui = ui_embed.UI(\n            channel,\n            \"Topic channel updated\",\n            channel_message,\n            modulename=modulename,\n            colour=modulecolor_info\n    )\n\n    return gui"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating an embed UI for the topic update with an error message", "response": "def error_message(channel, err_title, err_message):\n    \"\"\"\n    Creates an embed UI for the topic update\n\n    Args:\n        channel (discord.Channel): The Discord channel to bind the embed to\n        err_title: The title for the error\n        err_message: The message for the error\n\n    Returns:\n        embed: The created embed\n    \"\"\"\n\n    # Create embed UI object\n    gui = ui_embed.UI(\n            channel,\n            err_title,\n            err_message,\n            modulename=modulename,\n            colour=modulecolor_error\n    )\n\n    return gui"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef clear_cache_root():\n    logger.debug(\"Clearing root cache\")\n    if os.path.isdir(_root_songcache_dir):\n        for filename in os.listdir(_root_songcache_dir):\n            file_path = os.path.join(_root_songcache_dir, filename)\n            try:\n                if os.path.isfile(file_path):\n                    os.unlink(file_path)\n                elif os.path.isdir(file_path):\n                    shutil.rmtree(file_path)\n            except PermissionError:\n                pass\n            except Exception as e:\n                logger.exception(e)\n    logger.debug(\"Root cache cleared\")", "response": "Clears all the song cache from the root folder."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nplaying the song .", "response": "async def play(self, author, text_channel, query, index=None, stop_current=False, shuffle=False):\n        \"\"\"\n        The play command\n\n        Args:\n            author (discord.Member): The member that called the command\n            text_channel (discord.Channel): The channel where the command was called\n            query (str): The argument that was passed with the command\n            index (str): Whether to play next or at the end of the queue\n            stop_current (bool): Whether to stop the currently playing song\n            shuffle (bool): Whether to shuffle the queue after starting\n        \"\"\"\n\n        if self.state == 'off':\n            self.state = 'starting'\n            self.prev_queue = []\n            await self.set_topic(\"\")\n            # Init the music player\n            await self.msetup(text_channel)\n            # Queue the song\n            await self.enqueue(query, index, stop_current, shuffle)\n            # Connect to voice\n            await self.vsetup(author)\n\n            # Mark as 'ready' if everything is ok\n            self.state = 'ready' if self.mready and self.vready else 'off'\n        else:\n            # Queue the song\n            await self.enqueue(query, index, stop_current, shuffle)\n\n        if self.state == 'ready':\n            if self.streamer is None:\n                await self.vplay()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndestroy the whole gui and music player", "response": "async def destroy(self):\n        \"\"\"Destroy the whole gui and music player\"\"\"\n\n        self.logger.debug(\"destroy command\")\n        self.state = 'destroyed'\n\n        await self.set_topic(\"\")\n        self.nowplayinglog.debug(\"---\")\n        self.nowplayingauthorlog.debug(\"---\")\n        self.nowplayingsourcelog.debug(\"---\")\n        self.timelog.debug(_timebar.make_timebar())\n        self.prev_time = \"---\"\n        self.statuslog.debug(\"Destroying\")\n\n        self.mready = False\n        self.vready = False\n        self.pause_time = None\n        self.loop_type = 'off'\n\n        if self.vclient:\n            try:\n                await self.vclient.disconnect()\n            except Exception as e:\n                logger.error(e)\n                pass\n\n        if self.streamer:\n            try:\n                self.streamer.stop()\n            except:\n                pass\n\n        self.vclient = None\n        self.vchannel = None\n        self.streamer = None\n        self.current_duration = 0\n        self.current_download_elapsed = 0\n        self.is_live = False\n        self.queue = []\n        self.prev_queue = []\n\n        if self.embed:\n            await self.embed.delete()\n            self.embed = None\n\n        self.clear_cache()"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\nasync def toggle(self):\n\n        self.logger.debug(\"toggle command\")\n\n        if not self.state == 'ready':\n            return\n\n        if self.streamer is None:\n            return\n\n        try:\n            if self.streamer.is_playing():\n                await self.pause()\n            else:\n                await self.resume()\n        except Exception as e:\n            logger.error(e)\n            pass", "response": "Toggles between pause and resume command"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\npauses playback if playing", "response": "async def pause(self):\n        \"\"\"Pauses playback if playing\"\"\"\n\n        self.logger.debug(\"pause command\")\n\n        if not self.state == 'ready':\n            return\n\n        if self.streamer is None:\n            return\n\n        try:\n            if self.streamer.is_playing():\n                self.streamer.pause()\n                self.pause_time = self.vclient.loop.time()\n                self.statuslog.info(\"Paused\")\n        except Exception as e:\n            logger.error(e)\n            pass"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\nasync def resume(self):\n\n        self.logger.debug(\"resume command\")\n\n        if not self.state == 'ready':\n            return\n\n        if self.streamer is None:\n            return\n\n        try:\n            if not self.streamer.is_playing():\n                play_state = \"Streaming\" if self.is_live else \"Playing\"\n                self.statuslog.info(play_state)\n                self.streamer.resume()\n\n                if self.pause_time is not None:\n                    self.vclient_starttime += (self.vclient.loop.time() - self.pause_time)\n                self.pause_time = None\n        except Exception as e:\n            logger.error(e)\n            pass", "response": "Resumes playback if paused"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\nasync def skip(self, query=\"1\"):\n\n        if not self.state == 'ready':\n            logger.debug(\"Trying to skip from wrong state '{}'\".format(self.state))\n            return\n\n        if query == \"\":\n            query = \"1\"\n        elif query == \"all\":\n            query = str(len(self.queue) + 1)\n\n        try:\n            num = int(query)\n        except TypeError:\n            self.statuslog.error(\"Skip argument must be a number\")\n        except ValueError:\n            self.statuslog.error(\"Skip argument must be a number\")\n        else:\n            self.statuslog.info(\"Skipping\")\n\n            for i in range(num - 1):\n                if len(self.queue) > 0:\n                    self.prev_queue.append(self.queue.pop(0))\n\n            try:\n                self.streamer.stop()\n            except Exception as e:\n                logger.exception(e)", "response": "The skip command\n\n        Args:\n            query (str): The number of items to skip"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nremove a single entry from the queue.", "response": "async def remove(self, index=\"\"):\n        \"\"\"\n        The remove command\n\n        Args:\n            index (str): The index to remove, can be either a number, or a range in the for '##-##'\n        \"\"\"\n\n        if not self.state == 'ready':\n            logger.debug(\"Trying to remove from wrong state '{}'\".format(self.state))\n            return\n\n        if index == \"\":\n            self.statuslog.error(\"Must provide index to remove\")\n            return\n        elif index == \"all\":\n            self.queue = []\n            self.update_queue()\n            self.statuslog.info(\"Removed all songs\")\n            return\n\n        indexes = index.split(\"-\")\n        self.logger.debug(\"Removing {}\".format(indexes))\n\n        try:\n            if len(indexes) == 0:\n                self.statuslog.error(\"Remove must specify an index or range\")\n                return\n            elif len(indexes) == 1:\n                num_lower = int(indexes[0]) - 1\n                num_upper = num_lower + 1\n            elif len(indexes) == 2:\n                num_lower = int(indexes[0]) - 1\n                num_upper = int(indexes[1])\n            else:\n                self.statuslog.error(\"Cannot have more than 2 indexes for remove range\")\n                return\n        except TypeError:\n            self.statuslog.error(\"Remove index must be a number\")\n            return\n        except ValueError:\n            self.statuslog.error(\"Remove index must be a number\")\n            return\n\n        if num_lower < 0 or num_lower >= len(self.queue) or num_upper > len(self.queue):\n            if len(self.queue) == 0:\n                self.statuslog.warning(\"No songs in queue\")\n            elif len(self.queue) == 1:\n                self.statuslog.error(\"Remove index must be 1 (only 1 song in queue)\")\n            else:\n                self.statuslog.error(\"Remove index must be between 1 and {}\".format(len(self.queue)))\n            return\n\n        if num_upper <= num_lower:\n            self.statuslog.error(\"Second index in range must be greater than first\")\n            return\n\n        lower_songname = self.queue[num_lower][1]\n        for num in range(0, num_upper - num_lower):\n            self.logger.debug(\"Removed {}\".format(self.queue[num_lower][1]))\n            self.queue.pop(num_lower)\n\n        if len(indexes) == 1:\n            self.statuslog.info(\"Removed {}\".format(lower_songname))\n        else:\n            self.statuslog.info(\"Removed songs {}-{}\".format(num_lower + 1, num_upper))\n\n        self.update_queue()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nrewinding the current state of the current state of the current songs.", "response": "async def rewind(self, query=\"1\"):\n        \"\"\"\n        The rewind command\n\n        Args:\n            query (str): The number of items to skip\n        \"\"\"\n\n        if not self.state == 'ready':\n            logger.debug(\"Trying to rewind from wrong state '{}'\".format(self.state))\n            return\n\n        if query == \"\":\n            query = \"1\"\n\n        try:\n            num = int(query)\n        except TypeError:\n            self.statuslog.error(\"Rewind argument must be a number\")\n        except ValueError:\n            self.statuslog.error(\"Rewind argument must be a number\")\n        else:\n            if len(self.prev_queue) == 0:\n                self.statuslog.error(\"No songs to rewind\")\n                return\n\n            if num < 0:\n                self.statuslog.error(\"Rewind must be postitive or 0\")\n                return\n            elif num > len(self.prev_queue):\n                self.statuslog.warning(\"Rewinding to start\")\n            else:\n                self.statuslog.info(\"Rewinding\")\n\n            for i in range(num + 1):\n                if len(self.prev_queue) > 0:\n                    self.queue.insert(0, self.prev_queue.pop())\n\n            try:\n                self.streamer.stop()\n            except Exception as e:\n                logger.exception(e)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\nasync def set_loop(self, loop_value):\n        if loop_value not in ['on', 'off', 'shuffle']:\n            self.statuslog.error(\"Loop value must be `off`, `on`, or `shuffle`\")\n            return\n\n        self.loop_type = loop_value\n        if self.loop_type == 'on':\n            self.statuslog.info(\"Looping on\")\n        elif self.loop_type == 'off':\n            self.statuslog.info(\"Looping off\")\n        elif self.loop_type == 'shuffle':\n            self.statuslog.info(\"Looping on and shuffling\")", "response": "Updates the loop value."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef write_volume(self):\n        # Update the volume\n        data = datatools.get_data()\n        data[\"discord\"][\"servers\"][self.server_id][_data.modulename][\"volume\"] = self.volume\n        datatools.write_data(data)", "response": "Writes the current volume to the data. json"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nmoving the embed message to a new channel", "response": "async def movehere(self, channel):\n        \"\"\"\n        Moves the embed message to a new channel; can also be used to move the musicplayer to the front\n\n        Args:\n            channel (discord.Channel): The channel to move to\n        \"\"\"\n\n        self.logger.debug(\"movehere command\")\n\n        # Delete the old message\n        await self.embed.delete()\n        # Set the channel to this channel\n        self.embed.channel = channel\n        # Send a new embed to the channel\n        await self.embed.send()\n        # Re-add the reactions\n        await self.add_reactions()\n\n        self.statuslog.info(\"Moved to front\")"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsetting the topic channel for this server", "response": "async def set_topic_channel(self, channel):\n        \"\"\"Set the topic channel for this server\"\"\"\n        data = datatools.get_data()\n        data[\"discord\"][\"servers\"][self.server_id][_data.modulename][\"topic_id\"] = channel.id\n        datatools.write_data(data)\n\n        self.topicchannel = channel\n        await self.set_topic(self.topic)\n\n        await client.send_typing(channel)\n        embed = ui_embed.topic_update(channel, self.topicchannel)\n        await embed.send()"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nclears the topic channel for this server", "response": "async def clear_topic_channel(self, channel):\n        \"\"\"Set the topic channel for this server\"\"\"\n        try:\n            if self.topicchannel:\n                await client.edit_channel(self.topicchannel, topic=\"\")\n        except Exception as e:\n            logger.exception(e)\n\n        self.topicchannel = None\n        logger.debug(\"Clearing topic channel\")\n\n        data = datatools.get_data()\n        data[\"discord\"][\"servers\"][self.server_id][_data.modulename][\"topic_id\"] = \"\"\n        datatools.write_data(data)\n\n        await client.send_typing(channel)\n        embed = ui_embed.topic_update(channel, self.topicchannel)\n        await embed.send()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\nasync def vsetup(self, author):\n\n        if self.vready:\n            logger.warning(\"Attempt to init voice when already initialised\")\n            return\n\n        if self.state != 'starting':\n            logger.error(\"Attempt to init from wrong state ('{}'), must be 'starting'.\".format(self.state))\n            return\n\n        self.logger.debug(\"Setting up voice\")\n\n        # Create voice client\n        self.vchannel = author.voice.voice_channel\n        if self.vchannel:\n            self.statuslog.info(\"Connecting to voice\")\n            try:\n                self.vclient = await client.join_voice_channel(self.vchannel)\n            except discord.ClientException as e:\n                logger.exception(e)\n                self.statuslog.warning(\"I'm already connected to a voice channel.\")\n                return\n            except discord.opus.OpusNotLoaded as e:\n                logger.exception(e)\n                logger.error(\"Could not load Opus. This is an error with your FFmpeg setup.\")\n                self.statuslog.error(\"Could not load Opus.\")\n                return\n            except discord.DiscordException as e:\n                logger.exception(e)\n                self.statuslog.error(\"I couldn't connect to the voice channel. Check my permissions.\")\n                return\n            except Exception as e:\n                self.statuslog.error(\"Internal error connecting to voice, disconnecting.\")\n                logger.error(\"Error connecting to voice {}\".format(e))\n                return\n        else:\n            self.statuslog.error(\"You're not connected to a voice channel.\")\n            return\n\n        self.vready = True", "response": "Creates the voice client and sets up the internal state of the object."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates the gui and the music", "response": "async def msetup(self, text_channel):\n        \"\"\"Creates the gui\n\n        Args:\n            text_channel (discord.Channel): The channel for the embed ui to run in\n        \"\"\"\n\n        if self.mready:\n            logger.warning(\"Attempt to init music when already initialised\")\n            return\n\n        if self.state != 'starting':\n            logger.error(\"Attempt to init from wrong state ('{}'), must be 'starting'.\".format(self.state))\n            return\n\n        self.logger.debug(\"Setting up gui\")\n\n        # Create gui\n        self.mchannel = text_channel\n        self.new_embed_ui()\n        await self.embed.send()\n        await self.embed.usend()\n        await self.add_reactions()\n\n        self.mready = True"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef new_embed_ui(self):\n\n        self.logger.debug(\"Creating new embed ui object\")\n\n        # Initial queue display\n        queue_display = []\n        for i in range(self.queue_display):\n            queue_display.append(\"{}. ---\\n\".format(str(i + 1)))\n\n        # Initial datapacks\n        datapacks = [\n            (\"Now playing\", \"---\", False),\n            (\"Author\", \"---\", True),\n            (\"Source\", \"---\", True),\n            (\"Time\", \"```http\\n\" + _timebar.make_timebar() + \"\\n```\", False),\n            (\"Queue\", \"```md\\n{}\\n```\".format(''.join(queue_display)), False),\n            (\"Songs left in queue\", \"---\", True),\n            (\"Volume\", \"{}%\".format(self.volume), True),\n            (\"Status\", \"```---```\", False)\n        ]\n\n        # Create embed UI object\n        self.embed = ui_embed_tools.UI(\n            self.mchannel,\n            \"\",\n            \"\",\n            modulename=_data.modulename,\n            colour=_data.modulecolor,\n            datapacks=datapacks\n        )\n\n        # Add handlers to update gui\n        noformatter = logging.Formatter(\"{message}\", style=\"{\")\n        timeformatter = logging.Formatter(\"```http\\n{message}\\n```\", style=\"{\")\n        mdformatter = logging.Formatter(\"```md\\n{message}\\n```\", style=\"{\")\n        statusformatter = logging.Formatter(\"```__{levelname}__\\n{message}\\n```\", style=\"{\")\n        volumeformatter = logging.Formatter(\"{message}%\", style=\"{\")\n\n        nowplayinghandler = EmbedLogHandler(self, self.embed, 0)\n        nowplayinghandler.setFormatter(noformatter)\n        nowplayingauthorhandler = EmbedLogHandler(self, self.embed, 1)\n        nowplayingauthorhandler.setFormatter(noformatter)\n        nowplayingsourcehandler = EmbedLogHandler(self, self.embed, 2)\n        nowplayingsourcehandler.setFormatter(noformatter)\n        timehandler = EmbedLogHandler(self, self.embed, 3)\n        timehandler.setFormatter(timeformatter)\n        queuehandler = EmbedLogHandler(self, self.embed, 4)\n        queuehandler.setFormatter(mdformatter)\n        queuelenhandler = EmbedLogHandler(self, self.embed, 5)\n        queuelenhandler.setFormatter(noformatter)\n        volumehandler = EmbedLogHandler(self, self.embed, 6)\n        volumehandler.setFormatter(volumeformatter)\n        statushandler = EmbedLogHandler(self, self.embed, 7)\n        statushandler.setFormatter(statusformatter)\n\n        self.nowplayinglog.addHandler(nowplayinghandler)\n        self.nowplayingauthorlog.addHandler(nowplayingauthorhandler)\n        self.nowplayingsourcelog.addHandler(nowplayingsourcehandler)\n        self.timelog.addHandler(timehandler)\n        self.queuelog.addHandler(queuehandler)\n        self.queuelenlog.addHandler(queuelenhandler)\n        self.volumelog.addHandler(volumehandler)\n        self.statuslog.addHandler(statushandler)", "response": "Create the embed UI object and save it to self"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nadding the reactions buttons to the current message", "response": "async def add_reactions(self):\n        \"\"\"Adds the reactions buttons to the current message\"\"\"\n        self.statuslog.info(\"Loading buttons\")\n        for e in (\"\u23ef\", \"\u23ee\", \"\u23f9\", \"\u23ed\", \"\ud83d\udd00\", \"\ud83d\udd09\", \"\ud83d\udd0a\"):\n            try:\n                if self.embed is not None:\n                    await client.add_reaction(self.embed.sent_embed, e)\n            except discord.DiscordException as e:\n                logger.exception(e)\n                self.statuslog.error(\"I couldn't add the buttons. Check my permissions.\")\n            except Exception as e:\n                logger.exception(e)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nqueuing songs based on either a YouTube search or a link Args: query (str): Either a search term or a link queue_index (str): The queue index to enqueue at (None for end) stop_current (bool): Whether to stop the current song after the songs are queued shuffle (bool): Whether to shuffle the added songs", "response": "async def enqueue(self, query, queue_index=None, stop_current=False, shuffle=False):\n        \"\"\"\n        Queues songs based on either a YouTube search or a link\n\n        Args:\n            query (str): Either a search term or a link\n            queue_index (str): The queue index to enqueue at (None for end)\n            stop_current (bool): Whether to stop the current song after the songs are queued\n            shuffle (bool): Whether to shuffle the added songs\n        \"\"\"\n\n        if query is None or query == \"\":\n            return\n\n        self.statuslog.info(\"Parsing {}\".format(query))\n        self.logger.debug(\"Enqueueing from query\")\n\n        indexnum = None\n        if queue_index is not None:\n            try:\n                indexnum = int(queue_index) - 1\n            except TypeError:\n                self.statuslog.error(\"Play index argument must be a number\")\n                return\n            except ValueError:\n                self.statuslog.error(\"Play index argument must be a number\")\n                return\n\n        if not self.vready:\n            self.parse_query(query, indexnum, stop_current, shuffle)\n        else:\n            parse_thread = threading.Thread(\n                target=self.parse_query,\n                args=[query, indexnum, stop_current, shuffle])\n            # Run threads\n            parse_thread.start()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef parse_query(self, query, index, stop_current, shuffle):\n\n        if index is not None and len(self.queue) > 0:\n            if index < 0 or index >= len(self.queue):\n                if len(self.queue) == 1:\n                    self.statuslog.error(\"Play index must be 1 (1 song in queue)\")\n                    return\n                else:\n                    self.statuslog.error(\"Play index must be between 1 and {}\".format(len(self.queue)))\n                    return\n\n        try:\n            yt_videos = api_music.parse_query(query, self.statuslog)\n            if shuffle:\n                random.shuffle(yt_videos)\n\n            if len(yt_videos) == 0:\n                self.statuslog.error(\"No results for: {}\".format(query))\n                return\n\n            if index is None:\n                self.queue = self.queue + yt_videos\n            else:\n                if len(self.queue) > 0:\n                    self.queue = self.queue[:index] + yt_videos + self.queue[index:]\n                else:\n                    self.queue = yt_videos\n\n            self.update_queue()\n\n            if stop_current:\n                if self.streamer:\n                    self.streamer.stop()\n        except Exception as e:\n            logger.exception(e)", "response": "Parses a query and adds it to the queue"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef update_queue(self):\n\n        self.logger.debug(\"Updating queue display\")\n\n        queue_display = []\n        for i in range(self.queue_display):\n            try:\n                if len(self.queue[i][1]) > 40:\n                    songname = self.queue[i][1][:37] + \"...\"\n                else:\n                    songname = self.queue[i][1]\n            except IndexError:\n                songname = \"---\"\n            queue_display.append(\"{}. {}\\n\".format(str(i + 1), songname))\n\n        self.queuelog.debug(''.join(queue_display))\n        self.queuelenlog.debug(str(len(self.queue)))", "response": "Updates the queue in the music player"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset the topic for the topic channel", "response": "async def set_topic(self, topic):\n        \"\"\"Sets the topic for the topic channel\"\"\"\n        self.topic = topic\n        try:\n            if self.topicchannel:\n                await client.edit_channel(self.topicchannel, topic=topic)\n        except Exception as e:\n            logger.exception(e)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef clear_cache(self):\n        self.logger.debug(\"Clearing cache\")\n        if os.path.isdir(self.songcache_dir):\n            for filename in os.listdir(self.songcache_dir):\n                file_path = os.path.join(self.songcache_dir, filename)\n                try:\n                    if os.path.isfile(file_path):\n                        os.unlink(file_path)\n                except PermissionError:\n                    pass\n                except Exception as e:\n                    logger.exception(e)\n        self.logger.debug(\"Cache cleared\")", "response": "Removes all files from the songcache dir"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nmoves files in the next cache dir to the root", "response": "def move_next_cache(self):\n        \"\"\"Moves files in the 'next' cache dir to the root\"\"\"\n        if not os.path.isdir(self.songcache_next_dir):\n            return\n\n        logger.debug(\"Moving next cache\")\n        files = os.listdir(self.songcache_next_dir)\n        for f in files:\n            try:\n                os.rename(\"{}/{}\".format(self.songcache_next_dir, f), \"{}/{}\".format(self.songcache_dir, f))\n            except PermissionError:\n                pass\n            except Exception as e:\n                logger.exception(e)\n        logger.debug(\"Next cache moved\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef ytdl_progress_hook(self, d):\n        if d['status'] == 'downloading':\n            self.play_empty()\n\n            if \"elapsed\" in d:\n                if d[\"elapsed\"] > self.current_download_elapsed + 4:\n                    self.current_download_elapsed = d[\"elapsed\"]\n\n                    current_download = 0\n                    current_download_total = 0\n                    current_download_eta = 0\n                    if \"total_bytes\" in d and d[\"total_bytes\"] > 0:\n                        current_download_total = d[\"total_bytes\"]\n                    elif \"total_bytes_estimate\" in d and d[\"total_bytes_estimate\"] > 0:\n                        current_download_total = d[\"total_bytes_estimate\"]\n                    if \"downloaded_bytes\" in d and d[\"downloaded_bytes\"] > 0:\n                        current_download = d[\"downloaded_bytes\"]\n                    if \"eta\" in d and d[\"eta\"] > 0:\n                        current_download_eta = d[\"eta\"]\n\n                    if current_download_total > 0:\n                        percent = round(100 * (current_download / current_download_total))\n                        if percent > 100:\n                            percent = 100\n                        elif percent < 0:\n                            percent = 0\n\n                        seconds = str(round(current_download_eta)) if current_download_eta > 0 else \"\"\n                        eta = \" ({} {} remaining)\".format(seconds, \"seconds\" if seconds != 1 else \"second\")\n\n                        downloading = \"Downloading song: {}%{}\".format(percent, eta)\n                        if self.prev_time != downloading:\n                            self.timelog.debug(downloading)\n                            self.prev_time = downloading\n        if d['status'] == 'error':\n            self.statuslog.error(\"Error downloading song\")\n        elif d['status'] == 'finished':\n            self.statuslog.info(\"Downloaded song\")\n            downloading = \"Downloading song: {}%\".format(100)\n            if self.prev_time != downloading:\n                self.timelog.debug(downloading)\n                self.prev_time = downloading\n\n            if \"elapsed\" in d:\n                download_time = \"{} {}\".format(d[\"elapsed\"] if d[\"elapsed\"] > 0 else \"<1\",\n                                               \"seconds\" if d[\"elapsed\"] != 1 else \"second\")\n                self.logger.debug(\"Downloaded song in {}\".format(download_time))\n\n            # Create an FFmpeg player\n            future = asyncio.run_coroutine_threadsafe(self.create_ffmpeg_player(d['filename']), client.loop)\n            try:\n                future.result()\n            except Exception as e:\n                logger.exception(e)\n                return", "response": "Called when youtube - dl updates progress"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef play_empty(self):\n        if self.vclient:\n            if self.streamer:\n                self.streamer.volume = 0\n            self.vclient.play_audio(\"\\n\".encode(), encode=False)", "response": "Play blank audio to let Discord know we re still here"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ndownloading the next song and starts playing it", "response": "def download_next_song(self, song):\n        \"\"\"Downloads the next song and starts playing it\"\"\"\n\n        dl_ydl_opts = dict(ydl_opts)\n        dl_ydl_opts[\"progress_hooks\"] = [self.ytdl_progress_hook]\n        dl_ydl_opts[\"outtmpl\"] = self.output_format\n\n        # Move the songs from the next cache to the current cache\n        self.move_next_cache()\n\n        self.state = 'ready'\n        self.play_empty()\n        # Download the file and create the stream\n        with youtube_dl.YoutubeDL(dl_ydl_opts) as ydl:\n            try:\n                ydl.download([song])\n            except DownloadStreamException:\n                # This is a livestream, use the appropriate player\n                future = asyncio.run_coroutine_threadsafe(self.create_stream_player(song, dl_ydl_opts), client.loop)\n                try:\n                    future.result()\n                except Exception as e:\n                    logger.exception(e)\n                    self.vafter_ts()\n                    return\n            except PermissionError:\n                # File is still in use, it'll get cleared next time\n                pass\n            except youtube_dl.utils.DownloadError as e:\n                self.logger.exception(e)\n                self.statuslog.error(e)\n                self.vafter_ts()\n                return\n            except Exception as e:\n                self.logger.exception(e)\n                self.vafter_ts()\n                return"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ndownloading the next song in the queue to the cache", "response": "def download_next_song_cache(self):\n        \"\"\"Downloads the next song in the queue to the cache\"\"\"\n        if len(self.queue) == 0:\n            return\n\n        cache_ydl_opts = dict(ydl_opts)\n        cache_ydl_opts[\"outtmpl\"] = self.output_format_next\n\n        with youtube_dl.YoutubeDL(cache_ydl_opts) as ydl:\n            try:\n                url = self.queue[0][0]\n                ydl.download([url])\n            except:\n                pass"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate a streamer that plays from a file", "response": "async def create_ffmpeg_player(self, filepath):\n        \"\"\"Creates a streamer that plays from a file\"\"\"\n        self.current_download_elapsed = 0\n\n        self.streamer = self.vclient.create_ffmpeg_player(filepath, after=self.vafter_ts)\n        self.state = \"ready\"\n        await self.setup_streamer()\n\n        try:\n            # Read from the info json\n            info_filename = \"{}.info.json\".format(filepath)\n            with open(info_filename, 'r') as file:\n                info = json.load(file)\n\n                self.nowplayinglog.debug(info[\"title\"])\n                self.is_live = False\n\n                if \"duration\" in info and info[\"duration\"] is not None:\n                    self.current_duration = info[\"duration\"]\n                else:\n                    self.current_duration = 0\n\n                if \"uploader\" in info:\n                    self.nowplayingauthorlog.info(info[\"uploader\"])\n                else:\n                    self.nowplayingauthorlog.info(\"Unknown\")\n\n                self.nowplayingsourcelog.info(api_music.parse_source(info))\n\n                play_state = \"Streaming\" if self.is_live else \"Playing\"\n                await self.set_topic(\"{} {}\".format(play_state, info[\"title\"]))\n                self.statuslog.debug(play_state)\n        except Exception as e:\n            logger.exception(e)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate a streamer that plays from a URL", "response": "async def create_stream_player(self, url, opts=ydl_opts):\n        \"\"\"Creates a streamer that plays from a URL\"\"\"\n        self.current_download_elapsed = 0\n\n        self.streamer = await self.vclient.create_ytdl_player(url, ytdl_options=opts, after=self.vafter_ts)\n        self.state = \"ready\"\n\n        await self.setup_streamer()\n\n        self.nowplayinglog.debug(self.streamer.title)\n        self.nowplayingauthorlog.debug(self.streamer.uploader if self.streamer.uploader is not None else \"Unknown\")\n        self.current_duration = 0\n        self.is_live = True\n\n        info = self.streamer.yt.extract_info(url, download=False)\n        self.nowplayingsourcelog.info(api_music.parse_source(info))\n\n        play_state = \"Streaming\" if self.is_live else \"Playing\"\n        await self.set_topic(\"{} {}\".format(play_state, self.streamer.title))\n        self.statuslog.debug(play_state)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\nasync def setup_streamer(self):\n        self.streamer.volume = self.volume / 100\n        self.streamer.start()\n\n        self.pause_time = None\n        self.vclient_starttime = self.vclient.loop.time()\n\n        # Cache next song\n        self.logger.debug(\"Caching next song\")\n        dl_thread = threading.Thread(target=self.download_next_song_cache)\n        dl_thread.start()", "response": "Sets up basic defaults for the streamer"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef vafter_ts(self):\n        logger.debug(\"Song finishing\")\n        future = asyncio.run_coroutine_threadsafe(self.vafter(), client.loop)\n        try:\n            future.result()\n        except Exception as e:\n            logger.exception(e)", "response": "Function that is called after a song finishes playing"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nfunction that is called after a song finishes playing", "response": "async def vafter(self):\n        \"\"\"Function that is called after a song finishes playing\"\"\"\n        self.logger.debug(\"Finished playing a song\")\n        if self.state != 'ready':\n            self.logger.debug(\"Returning because player is in state {}\".format(self.state))\n            return\n\n        self.pause_time = None\n\n        if self.vclient_task:\n            loop = asyncio.get_event_loop()\n            loop.call_soon(self.vclient_task.cancel)\n            self.vclient_task = None\n\n        try:\n            if self.streamer is None:\n                await self.stop()\n                return\n\n            if self.streamer.error is None:\n                await self.vplay()\n            else:\n                self.statuslog.error(self.streamer.error)\n                await self.destroy()\n        except Exception as e:\n            logger.exception(e)\n            try:\n                await self.destroy()\n            except Exception as e:\n                logger.exception(e)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nbuild the YouTube API for future use", "response": "def build_yt_api():\n    \"\"\"Build the YouTube API for future use\"\"\"\n    data = datatools.get_data()\n    if \"google_api_key\" not in data[\"discord\"][\"keys\"]:\n        logger.warning(\"No API key found with name 'google_api_key'\")\n        logger.info(\"Please add your Google API key with name 'google_api_key' \"\n                    \"in data.json to use YouTube features of the music module\")\n        return False\n\n    logger.debug(\"Building YouTube discovery API\")\n    ytdevkey = data[\"discord\"][\"keys\"][\"google_api_key\"]\n\n    try:\n        global ytdiscoveryapi\n        ytdiscoveryapi = googleapiclient.discovery.build(\"youtube\", \"v3\", developerKey=ytdevkey)\n        logger.debug(\"YouTube API build successful\")\n        return True\n    except Exception as e:\n        logger.exception(e)\n        logger.warning(\"HTTP error connecting to YouTube API, YouTube won't be available\")\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef build_sc_api():\n    data = datatools.get_data()\n    if \"soundcloud_client_id\" not in data[\"discord\"][\"keys\"]:\n        logger.warning(\"No API key found with name 'soundcloud_client_id'\")\n        logger.info(\"Please add your SoundCloud client id with name 'soundcloud_client_id' \"\n                    \"in data.json to use Soundcloud features of the music module\")\n        return False\n\n    try:\n        global scclient\n        scclient = soundcloud.Client(client_id=data[\"discord\"][\"keys\"][\"soundcloud_client_id\"])\n        logger.debug(\"SoundCloud build successful\")\n        return True\n    except Exception as e:\n        logger.exception(e)\n        return False", "response": "Build the SoundCloud API for future use"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nbuilds the Spotify API for future use", "response": "def build_spotify_api():\n    \"\"\"Build the Spotify API for future use\"\"\"\n    data = datatools.get_data()\n    if \"spotify_client_id\" not in data[\"discord\"][\"keys\"]:\n        logger.warning(\"No API key found with name 'spotify_client_id'\")\n        logger.info(\"Please add your Spotify client id with name 'spotify_client_id' \"\n                    \"in data.json to use Spotify features of the music module\")\n        return False\n    if \"spotify_client_secret\" not in data[\"discord\"][\"keys\"]:\n        logger.warning(\"No API key found with name 'spotify_client_secret'\")\n        logger.info(\"Please add your Spotify client secret with name 'spotify_client_secret' \"\n                    \"in data.json to use Spotify features of the music module\")\n        return False\n\n    try:\n        global spclient\n        client_credentials_manager = SpotifyClientCredentials(\n                data[\"discord\"][\"keys\"][\"spotify_client_id\"],\n                data[\"discord\"][\"keys\"][\"spotify_client_secret\"])\n        spclient = spotipy.Spotify(client_credentials_manager=client_credentials_manager)\n        logger.debug(\"Spotify build successful\")\n        return True\n    except Exception as e:\n        logger.exception(e)\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nparse a YouTube search query and returns a list of items from the YouTube search queue.", "response": "def parse_query(query, ilogger):\n    \"\"\"\n    Gets either a list of videos from a query, parsing links and search queries\n    and playlists\n\n    Args:\n        query (str): The YouTube search query\n        ilogger (logging.logger): The logger to log API calls to\n\n    Returns:\n        queue (list): The items obtained from the YouTube search\n    \"\"\"\n\n    # Try parsing this as a link\n    p = urlparse(query)\n    if p and p.scheme and p.netloc:\n        if \"youtube\" in p.netloc and p.query and ytdiscoveryapi is not None:\n            query_parts = p.query.split('&')\n            yturl_parts = {}\n            for q in query_parts:\n                s = q.split('=')\n                if len(s) < 2:\n                    continue\n\n                q_name = s[0]\n                q_val = '='.join(s[1:])\n                # Add to the query\n                if q_name not in yturl_parts:\n                    yturl_parts[q_name] = q_val\n\n            if \"list\" in yturl_parts:\n                ilogger.info(\"Queued YouTube playlist from link\")\n                return get_queue_from_playlist(yturl_parts[\"list\"])\n            elif \"v\" in yturl_parts:\n                ilogger.info(\"Queued YouTube video from link\")\n                return [[\"https://www.youtube.com/watch?v={}\".format(yturl_parts[\"v\"]), query]]\n        elif \"soundcloud\" in p.netloc:\n            if scclient is None:\n                ilogger.error(\"Could not queue from SoundCloud API, using link\")\n                return [[query, query]]\n            try:\n                result = scclient.get('/resolve', url=query)\n\n                track_list = []\n                if isinstance(result, ResourceList):\n                    for r in result.data:\n                        tracks = get_sc_tracks(r)\n                        if tracks is not None:\n                            for t in tracks:\n                                track_list.append(t)\n                elif isinstance(result, Resource):\n                    tracks = get_sc_tracks(result)\n                    if tracks is not None:\n                        for t in tracks:\n                            track_list.append(t)\n\n                if track_list is not None and len(track_list) > 0:\n                    ilogger.info(\"Queued SoundCloud songs from link\")\n                    return track_list\n                else:\n                    ilogger.error(\"Could not queue from SoundCloud API\")\n                    return [[query, query]]\n            except Exception as e:\n                logger.exception(e)\n                ilogger.error(\"Could not queue from SoundCloud API, using link\")\n                return [[query, query]]\n        else:\n            ilogger.debug(\"Using url: {}\".format(query))\n            return [[query, query]]\n\n    args = query.split(' ')\n    if len(args) == 0:\n        ilogger.error(\"No query given\")\n        return []\n\n    if args[0].lower() in [\"sp\", \"spotify\"] and spclient is not None:\n        if spclient is None:\n            ilogger.error(\"Host does not support Spotify\")\n            return []\n\n        try:\n            if len(args) > 2 and args[1] in ['album', 'artist', 'song', 'track', 'playlist']:\n                query_type = args[1].lower()\n                query_search = ' '.join(args[2:])\n            else:\n                query_type = 'track'\n                query_search = ' '.join(args[1:])\n            query_type = query_type.replace('song', 'track')\n            ilogger.info(\"Queueing Spotify {}: {}\".format(query_type, query_search))\n            spotify_tracks = search_sp_tracks(query_type, query_search)\n            if spotify_tracks is None or len(spotify_tracks) == 0:\n                ilogger.error(\"Could not queue Spotify {}: {}\".format(query_type, query_search))\n                return []\n            ilogger.info(\"Queued Spotify {}: {}\".format(query_type, query_search))\n            return spotify_tracks\n        except Exception as e:\n            logger.exception(e)\n            ilogger.error(\"Error queueing from Spotify\")\n            return []\n    elif args[0].lower() in [\"sc\", \"soundcloud\"]:\n        if scclient is None:\n            ilogger.error(\"Host does not support SoundCloud\")\n            return []\n\n        try:\n            requests = ['song', 'songs', 'track', 'tracks', 'user', 'playlist', 'tagged', 'genre']\n            if len(args) > 2 and args[1] in requests:\n                query_type = args[1].lower()\n                query_search = ' '.join(args[2:])\n            else:\n                query_type = 'track'\n                query_search = ' '.join(args[1:])\n            query_type = query_type.replace('song', 'track')\n            ilogger.info(\"Queueing SoundCloud {}: {}\".format(query_type, query_search))\n            soundcloud_tracks = search_sc_tracks(query_type, query_search)\n            ilogger.info(\"Queued SoundCloud {}: {}\".format(query_type, query_search))\n            return soundcloud_tracks\n        except Exception as e:\n            logger.exception(e)\n            ilogger.error(\"Could not queue from SoundCloud\")\n            return []\n    elif args[0].lower() in [\"yt\", \"youtube\"] and ytdiscoveryapi is not None:\n        if ytdiscoveryapi is None:\n            ilogger.error(\"Host does not support YouTube\")\n            return []\n\n        try:\n            query_search = ' '.join(args[1:])\n            ilogger.info(\"Queued Youtube search: {}\".format(query_search))\n            return get_ytvideos(query_search, ilogger)\n        except Exception as e:\n            logger.exception(e)\n            ilogger.error(\"Could not queue YouTube search\")\n            return []\n\n    if ytdiscoveryapi is not None:\n        ilogger.info(\"Queued YouTube search: {}\".format(query))\n        return get_ytvideos(query, ilogger)\n    else:\n        ilogger.error(\"Host does not support YouTube\".format(query))\n        return []"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_ytvideos(query, ilogger):\n\n    queue = []\n\n    # Search YouTube\n    search_result = ytdiscoveryapi.search().list(\n            q=query,\n            part=\"id,snippet\",\n            maxResults=1,\n            type=\"video,playlist\"\n    ).execute()\n\n    if not search_result[\"items\"]:\n        return []\n\n    # Get video/playlist title\n    title = search_result[\"items\"][0][\"snippet\"][\"title\"]\n    ilogger.info(\"Queueing {}\".format(title))\n\n    # Queue video if video\n    if search_result[\"items\"][0][\"id\"][\"kind\"] == \"youtube#video\":\n        # Get ID of video\n        videoid = search_result[\"items\"][0][\"id\"][\"videoId\"]\n\n        # Append video to queue\n        queue.append([\"https://www.youtube.com/watch?v={}\".format(videoid), title])\n\n    # Queue playlist if playlist\n    elif search_result[\"items\"][0][\"id\"][\"kind\"] == \"youtube#playlist\":\n        queue = get_queue_from_playlist(search_result[\"items\"][0][\"id\"][\"playlistId\"])\n\n    return queue", "response": "Gets either a list of videos from a playlist or a single video"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nconverting a duration in seconds to a string", "response": "def duration_to_string(duration):\n    \"\"\"\n    Converts a duration to a string\n\n    Args:\n        duration (int): The duration in seconds to convert\n\n    Returns s (str): The duration as a string\n    \"\"\"\n\n    m, s = divmod(duration, 60)\n    h, m = divmod(m, 60)\n    return \"%d:%02d:%02d\" % (h, m, s)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nparsing the source info from a dictionary generated by youtube - dl", "response": "def parse_source(info):\n    \"\"\"\n    Parses the source info from an info dict generated by youtube-dl\n\n    Args:\n        info (dict): The info dict to parse\n\n    Returns:\n        source (str): The source of this song\n    \"\"\"\n\n    if \"extractor_key\" in info:\n        source = info[\"extractor_key\"]\n        lower_source = source.lower()\n\n        for key in SOURCE_TO_NAME:\n            lower_key = key.lower()\n            if lower_source == lower_key:\n                source = SOURCE_TO_NAME[lower_key]\n\n        if source != \"Generic\":\n            return source\n\n    if \"url\" in info and info[\"url\"] is not None:\n        p = urlparse(info[\"url\"])\n        if p and p.netloc:\n            return p.netloc\n\n    return \"Unknown\""}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef flipcheck(content):\n\n    # Prevent tampering with flip\n    punct = \"\"\"!\"#$%&'*+,-./:;<=>?@[\\]^_`{|}~ \u2501\u2500\"\"\"\n    tamperdict = str.maketrans('', '', punct)\n    tamperproof = content.translate(tamperdict)\n\n    # Unflip\n    if \"(\u256f\u00b0\u25a1\u00b0\uff09\u256f\ufe35\" in tamperproof:\n        # For tables\n        if \"\u253b\u253b\" in tamperproof:\n            # Calculate table length\n            length = 0\n            for letter in content:\n                if letter == \"\u2501\":\n                    length += 1.36\n                elif letter == \"\u2500\":\n                    length += 1\n                elif letter == \"-\":\n                    length += 0.50\n\n            # Construct table\n            putitback = \"\u252c\"\n\n            for i in range(int(length)):\n                putitback += \"\u2500\"\n\n            putitback += \"\u252c\ufeff \u30ce( \u309c-\u309c\u30ce)\"\n\n            return putitback\n\n        # For text\n        else:\n            # Create dictionary for flipping text\n            flipdict = str.maketrans(\n                'abcdefghijklmnopqrstuvwxyz\u0250q\u0254p\u01dd\u025fb\u0265\u0131\u0638\u029e\u05df\u026fuodb\u0279s\u0287n\u028c\u028dx\u028ez\ud83d\ude05\ud83d\ude43\ud83d\ude1e\ud83d\ude1f\ud83d\ude20\ud83d\ude21\u2639\ud83d\ude41\ud83d\ude31\ud83d\ude28\ud83d\ude30\ud83d\ude26\ud83d\ude27\ud83d\ude22\ud83d\ude13\ud83d\ude25\ud83d\ude2d',\n                '\u0250q\u0254p\u01dd\u025fb\u0265\u0131\u0638\u029e\u05df\u026fuodb\u0279s\u0287n\u028c\u028dx\u028ezabcdefghijklmnopqrstuvwxyz\ud83d\ude04\ud83d\ude42\ud83d\ude42\ud83d\ude42\ud83d\ude42\ud83d\ude42\ud83d\ude42\ud83d\ude00\ud83d\ude00\ud83d\ude42\ud83d\ude04\ud83d\ude42\ud83d\ude42\ud83d\ude04\ud83d\ude04\ud83d\ude04\ud83d\ude01'\n            )\n\n            # Construct flipped text\n            flipstart = content.index('\ufe35')\n            flipped = content[flipstart+1:]\n            flipped = str.lower(flipped).translate(flipdict)\n\n            putitback = ''.join(list(reversed(list(flipped))))\n\n            putitback += \"\u30ce( \u309c-\u309c\u30ce)\"\n\n            return putitback\n    else:\n        return False", "response": "Flips a string for an anger and soothes."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget a botcust2 identifier used to identify a speaker with Mitsuku", "response": "def get_botcust2():\n    \"\"\"Gets a botcust2, used to identify a speaker with Mitsuku\n\n    Returns:\n        botcust2 (str): The botcust2 identifier\n    \"\"\"\n    logger.debug(\"Getting new botcust2\")\n\n    # Set up http request packages\n    params = {\n        'botid': 'f6a012073e345a08',\n        'amp;skin': 'chat'\n    }\n    headers = {\n        'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',\n        'Accept-Encoding': 'gzip, deflate, sdch, br',\n        'Accept-Language': 'en-US,en;q=0.8',\n        'Connection': 'keep-alive',\n        'DNT': '1',\n        'Host': 'kakko.pandorabots.com',\n        'Upgrade-Insecure-Requests': '1',\n        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) '\n                      'AppleWebKit/537.36 (KHTML, like Gecko) '\n                      'Chrome/58.0.3029.110 Safari/537.36'\n    }\n\n    # Get response from http POST request to url\n    logger.debug(\"Sending POST request\")\n    response = requests.post(\n        url,\n        params=params,\n        headers=headers\n    )\n    logger.debug(\"POST response {}\".format(response))\n\n    # Try to extract Mitsuku response from POST response\n    try:\n        result = response.headers['set-cookie'][9:25]\n        logger.debug(\"Getting botcust2 successful\")\n    except IndexError:\n        result = False\n        logger.critical(\"Getting botcust2 from html failed\")\n\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsending a message to Mitsuku and retrieves the reply", "response": "def query(botcust2, message):\n    \"\"\"Sends a message to Mitsuku and retrieves the reply\n\n    Args:\n        botcust2 (str): The botcust2 identifier\n        message (str): The message to send to Mitsuku\n\n    Returns:\n        reply (str): The message Mitsuku sent back\n    \"\"\"\n    logger.debug(\"Getting Mitsuku reply\")\n\n    # Set up http request packages\n    params = {\n        'botid': 'f6a012073e345a08',\n        'amp;skin': 'chat'\n    }\n    headers = {\n        'Accept-Encoding': 'gzip, deflate, br',\n        'Accept-Language': 'en-US,en;q=0.8',\n        'Cache-Control': 'max-age=0',\n        'Connection': 'keep-alive',\n        'Content-Length': str(len(message) + 34),\n        'Content-Type': 'application/x-www-form-urlencoded',\n        'Cookie': 'botcust2=' + botcust2,\n        'DNT': '1',\n        'Host': 'kakko.pandorabots.com',\n        'Origin': 'https://kakko.pandorabots.com',\n        'Referer': 'https://kakko.pandorabots.com/pandora/talk?botid=f6a012073e345a08&amp;skin=chat',\n        'Upgrade-Insecure-Requests': '1',\n        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) '\n                      'AppleWebKit/537.36 (KHTML, like Gecko) '\n                      'Chrome/58.0.3029.110 Safari/537.36'\n    }\n    data = {\n        'botcust2': botcust2,\n        'message': message\n    }\n\n    # Get response from http POST request to url\n    logger.debug(\"Sending POST request\")\n    response = requests.post(\n        url,\n        params=params,\n        headers=headers,\n        data=data\n    )\n    logger.debug(\"POST response {}\".format(response))\n\n    # Parse response\n    parsed = lxml.html.parse(io.StringIO(response.text)).getroot()\n    try:\n        result = parsed[1][2][0][2].tail[1:]\n        logger.debug(\"Getting botcust2 successful\")\n    except IndexError:\n        result = False\n        logger.critical(\"Getting botcust2 from html failed\")\n\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\nasync def on_message(message):\n\n    # Simplify message info\n    server = message.server\n    author = message.author\n    channel = message.channel\n    content = message.content\n\n    data = datatools.get_data()\n\n    if not data[\"discord\"][\"servers\"][server.id][_data.modulename][\"activated\"]:\n        return\n\n    # Only reply to server messages and don't reply to myself\n    if server is not None and author != channel.server.me:\n        # Commands section\n        prefix = data[\"discord\"][\"servers\"][server.id][\"prefix\"]\n        if content.startswith(prefix):\n            # Parse message\n            package = content.split(\" \")\n            command = package[0][len(prefix):]\n            args = package[1:]\n            arg = ' '.join(args)\n\n            # Lock on to server if not yet locked\n            if server.id not in _data.cache or _data.cache[server.id].state == 'destroyed':\n                _data.cache[server.id] = _musicplayer.MusicPlayer(server.id)\n\n            # Remove message\n            if command in ['play', 'playnext', 'playnow', 'playshuffle', 'insert',\n                           'pause', 'resume', 'skip', 'remove',\n                           'rewind', 'restart', 'shuffle', 'volume',\n                           'stop', 'destroy', 'front', 'movehere',\n                           'settopic', 'cleartopic', 'notopic', 'loop']:\n                try:\n                    await client.delete_message(message)\n                except discord.errors.NotFound:\n                    logger.warning(\"Could not delete music player command message - NotFound\")\n                except discord.errors.Forbidden:\n                    logger.warning(\"Could not delete music player command message - Forbidden\")\n\n            # Commands\n            if command == 'play':\n                await _data.cache[server.id].play(author, channel, arg)\n\n            if command == 'playnext':\n                await _data.cache[server.id].play(author, channel, arg, index=1)\n\n            if command == 'playnow':\n                await _data.cache[server.id].play(author, channel, arg, index=1, stop_current=True)\n\n            if command == 'playshuffle':\n                await _data.cache[server.id].play(author, channel, arg, shuffle=True)\n\n            if command == 'insert':\n                if len(args) >= 2:\n                    index = args[0]\n                    query = ' '.join(args[1:])\n                    await _data.cache[server.id].play(author, channel, query, index=index)\n                else:\n                    await _data.cache[server.id].play(author, channel, arg)\n\n            elif command == 'pause':\n                await _data.cache[server.id].pause()\n\n            elif command == 'resume':\n                await _data.cache[server.id].resume()\n\n            elif command == 'skip':\n                await _data.cache[server.id].skip(query=arg)\n\n            elif command == 'remove':\n                await _data.cache[server.id].remove(index=arg)\n\n            elif command == 'rewind':\n                await _data.cache[server.id].rewind(query=arg)\n\n            elif command == 'restart':\n                await _data.cache[server.id].rewind(query=\"0\")\n\n            elif command == 'shuffle':\n                await _data.cache[server.id].shuffle()\n\n            elif command == 'loop':\n                await _data.cache[server.id].set_loop(arg)\n\n            elif command == 'stop':\n                await _data.cache[server.id].stop(log_stop=True)\n\n            elif command == 'volume':\n                await _data.cache[server.id].setvolume(arg)\n\n            elif command == 'settopic':\n                await _data.cache[server.id].set_topic_channel(channel)\n\n            elif command == 'cleartopic' or command == 'notopic':\n                await _data.cache[server.id].clear_topic_channel(channel)\n\n            elif command == 'nowplaying':\n                await _data.cache[server.id].nowplaying_info(channel)\n\n            elif command == 'destroy':\n                await _data.cache[server.id].destroy()\n\n            elif command == 'front' or command == 'movehere':\n                await _data.cache[server.id].movehere(channel)", "response": "The on_message event handler for this module."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef start(token, client_id, loop, on_ready_handler=None):\n    import discord\n    import asyncio\n\n    # Create client\n    logger.debug(\"Creating Discord client\")\n    asyncio.set_event_loop(loop)\n    client = discord.Client()\n    from . import _client\n    _client.client = client\n\n    from .. import datatools\n    if datatools.has_data():\n        data = datatools.get_data()\n    else:\n        # Create a blank data file\n        data = {\"discord\": {}}\n\n    # Save default server info to data\n    if \"servers\" not in data[\"discord\"]:\n        data[\"discord\"][\"servers\"] = {}\n\n    # Save default key info to data\n    if \"keys\" not in data[\"discord\"]:\n        data[\"discord\"][\"keys\"] = {}\n\n    # Save logger info to data\n    if \"log_level\" not in data:\n        data[\"log_level\"] = \"DEBUG\"\n\n    data[\"discord\"][\"token\"] = token\n    data[\"discord\"][\"client_id\"] = client_id\n    datatools.write_data(data)\n\n    # Import event handlers\n    logger.debug(\"Importing event handlers\")\n    event_handlers = _get_event_handlers()\n\n    # Create event handler combiner\n    logger.debug(\"Compiling event handlers\")\n\n    def create_event_handler(event_handler_type):\n        async def func(*args, **kwargs):\n            for module_event_handler in event_handlers[event_handler_type]:\n                # Check for errors in the module event\n                try:\n                    module_event_handler_func = getattr(module_event_handler,\n                                                        event_handler_type)\n                    await module_event_handler_func(*args, **kwargs)\n                except Exception as module_exception:\n                    logger.error(\"An error occured in '{}'\".format(module_event_handler))\n                    logger.exception(module_exception)\n\n            if on_ready_handler is not None and event_handler_type == \"on_ready\":\n                await on_ready_handler()\n\n        func.__name__ = event_handler_type\n        return func\n\n    # Register event handlers\n    logger.debug(\"Registering event handlers into client\")\n    for event_handler in event_handlers.keys():\n        client.event(create_event_handler(event_handler))\n\n    # Run the client loop\n    logger.info(\"Connecting to Discord\")\n    try:\n        client.loop.run_until_complete(client.login(token))\n    except Exception as e:\n        logger.exception(e)\n        logger.critical(\"Could not connect to Discord\")\n    else:\n        logger.debug(\"Running the bot\")\n        try:\n            client.loop.run_until_complete(client.connect())\n        except KeyboardInterrupt:\n            client.loop.run_until_complete(client.logout())\n            pending = asyncio.Task.all_tasks(loop=client.loop)\n            gathered = asyncio.gather(*pending, loop=client.loop)\n            try:\n                gathered.cancel()\n                client.loop.run_until_complete(gathered)\n\n                # we want to retrieve any exceptions to make sure that\n                # they don't nag us about it being un-retrieved.\n                gathered.exception()\n            except Exception as e:\n                logger.exception(e)\n        except Exception as e:\n            logger.exception(e)\n            pending = asyncio.Task.all_tasks(loop=client.loop)\n            gathered = asyncio.gather(*pending, loop=client.loop)\n            gathered.exception()\n        finally:\n            try:\n                client.loop.run_until_complete(client.logout())\n            except Exception as e:\n                logger.exception(e)\n\n            logger.critical(\"Bot stopped\\n\")\n            client.loop.close()", "response": "Start the Discord client and log Modis into Discord."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _get_event_handlers():\n\n    import os\n    import importlib\n\n    event_handlers = {\n        \"on_ready\": [],\n        \"on_resume\": [],\n        \"on_error\": [],\n        \"on_message\": [],\n        \"on_socket_raw_receive\": [],\n        \"on_socket_raw_send\": [],\n        \"on_message_delete\": [],\n        \"on_message_edit\": [],\n        \"on_reaction_add\": [],\n        \"on_reaction_remove\": [],\n        \"on_reaction_clear\": [],\n        \"on_channel_delete\": [],\n        \"on_channel_create\": [],\n        \"on_channel_update\": [],\n        \"on_member_join\": [],\n        \"on_member_remove\": [],\n        \"on_member_update\": [],\n        \"on_server_join\": [],\n        \"on_server_remove\": [],\n        \"on_server_update\": [],\n        \"on_server_role_create\": [],\n        \"on_server_role_delete\": [],\n        \"on_server_role_update\": [],\n        \"on_server_emojis_update\": [],\n        \"on_server_available\": [],\n        \"on_server_unavailable\": [],\n        \"on_voice_state_update\": [],\n        \"on_member_ban\": [],\n        \"on_member_unban\": [],\n        \"on_typing\": [],\n        \"on_group_join\": [],\n        \"on_group_remove\": []\n    }\n\n    # Iterate through module folders\n    database_dir = \"{}/modules\".format(\n        os.path.dirname(os.path.realpath(__file__)))\n    for module_name in os.listdir(database_dir):\n        module_dir = \"{}/{}\".format(database_dir, module_name)\n\n        # Iterate through files in module\n        if os.path.isdir(module_dir) and not module_name.startswith(\"_\"):\n            # Add all defined event handlers in module files\n            module_event_handlers = os.listdir(module_dir)\n\n            for event_handler in event_handlers.keys():\n                if \"{}.py\".format(event_handler) in module_event_handlers:\n                    import_name = \".discord_modis.modules.{}.{}\".format(\n                        module_name, event_handler)\n                    logger.debug(\"Found event handler {}\".format(import_name[23:]))\n\n                    try:\n                        event_handlers[event_handler].append(\n                            importlib.import_module(import_name, \"modis\"))\n                    except Exception as e:\n                        # Log errors in modules\n                        logger.exception(e)\n\n    return event_handlers", "response": "Returns a dictionary of event handlers and modules that define them"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef add_api_key(key, value):\n\n    if key is None or key == \"\":\n        logger.error(\"Key cannot be empty\")\n\n    if value is None or value == \"\":\n        logger.error(\"Value cannot be empty\")\n\n    from .. import datatools\n    data = datatools.get_data()\n\n    if \"keys\" not in data[\"discord\"]:\n        data[\"discord\"][\"keys\"] = {}\n\n    is_key_new = False\n    if key not in data[\"discord\"][\"keys\"]:\n        is_key_new = True\n    elif data[\"discord\"][\"keys\"][key] == value:\n        logger.info(\"API key '{}' already has value '{}'\".format(key, value))\n        return\n\n    data[\"discord\"][\"keys\"][key] = value\n    datatools.write_data(data)\n\n    key_text = \"added\" if is_key_new else \"updated\"\n    logger.info(\"API key '{}' {} with value '{}'\".format(key, key_text, value))", "response": "Adds a key to the bot s data structures."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates an embed UI containing the help message", "response": "def success(channel, title, datapacks):\n    \"\"\"\n    Creates an embed UI containing the help message\n\n    Args:\n        channel (discord.Channel): The Discord channel to bind the embed to\n        title (str): The title of the embed\n        datapacks (list): The hex value\n\n    Returns:\n        ui (ui_embed.UI): The embed UI object\n    \"\"\"\n\n    # Create embed UI object\n    gui = ui_embed.UI(\n        channel,\n        title,\n        \"\",\n        modulename=modulename,\n        datapacks=datapacks\n    )\n\n    return gui"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate an embed UI containing the too long error message", "response": "def http_exception(channel, title):\n    \"\"\"\n    Creates an embed UI containing the 'too long' error message\n\n    Args:\n        channel (discord.Channel): The Discord channel to bind the embed to\n        title (str): The title of the embed\n\n    Returns:\n        ui (ui_embed.UI): The embed UI object\n    \"\"\"\n\n    # Create embed UI object\n    gui = ui_embed.UI(\n        channel,\n        \"Too much help\",\n        \"{} is too helpful! Try trimming some of the help messages.\".format(title),\n        modulename=modulename\n    )\n\n    return gui"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting or create a Tarbell configuration file.", "response": "def _get_or_create_config(path, prompt=True):\n    \"\"\"\n    Get or create a Tarbell configuration directory.\n    \"\"\"\n    dirname = os.path.dirname(path)\n    filename = os.path.basename(path)\n\n    try:\n        os.makedirs(dirname)\n    except OSError:\n        pass\n\n    try:\n        with open(path, 'r+') as f:\n            if os.path.isfile(path):\n                puts(\"{0} already exists, backing up\".format(colored.green(path)))\n                _backup(dirname, filename)\n            return yaml.load(f)\n    except IOError:\n        return {}"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset up a Google spreadsheet.", "response": "def _setup_google_spreadsheets(settings, path, prompt=True):\n    \"\"\"\n    Set up a Google spreadsheet.\n    \"\"\"\n    ret = {}\n    if prompt:\n        use = raw_input(\"\\nWould you like to use Google spreadsheets [Y/n]? \")\n        if use.lower() != \"y\" and use != \"\":\n            return settings\n\n    dirname = os.path.dirname(path)\n    path = os.path.join(dirname, \"client_secrets.json\")\n\n    write_secrets = True\n    if os.path.isfile(path):\n        write_secrets_input = raw_input(\"client_secrets.json already exists. Would you like to overwrite it? [y/N] \")\n        if not write_secrets_input.lower().startswith('y'):\n            write_secrets = False\n\n    if write_secrets:\n        puts((\"\\nLogin in to Google and go to {0} to create an app and generate a \"\n              \"\\nclient_secrets authentication file. You should create credentials for an `installed app`. See \"\n              \"\\n{1} for more information.\"\n              .format(colored.red(\"https://console.developers.google.com/project\"),\n                      colored.red(\"http://tarbell.readthedocs.org/en/{0}/install.html#configure-google-spreadsheet-access-optional\".format(LONG_VERSION))\n                     )\n            ))\n\n        secrets_path = raw_input((\"\\nWhere is your client secrets file? \"\n                                  \"[~/Downloads/client_secrets.json] \"\n                                ))\n\n        if secrets_path == \"\":\n            secrets_path = os.path.join(\"~\", \"Downloads/client_secrets.json\")\n\n        secrets_path = os.path.expanduser(secrets_path)\n\n        puts(\"\\nCopying {0} to {1}\\n\"\n             .format(colored.green(secrets_path),\n                     colored.green(dirname))\n        )\n\n        _backup(dirname, \"client_secrets.json\")\n        try:\n            shutil.copy(secrets_path, os.path.join(dirname, 'client_secrets.json'))\n        except shutil.Error as e:\n            show_error(str(e))\n\n    # Now, try and obtain the API for the first time\n    get_api = raw_input(\"Would you like to authenticate your client_secrets.json? [Y/n] \")\n    if get_api == '' or get_api.lower().startswith('y'):\n        get_drive_api_from_client_secrets(path, reset_creds=True)\n\n    default_account = settings.get(\"google_account\", \"\")\n    account = raw_input((\"What Google account(s) should have access to new spreadsheets? \"\n                         \"(e.g. somebody@gmail.com, leave blank to specify for each new \"\n                         \"project, separate multiple addresses with commas) [{0}] \"\n                            .format(default_account)\n                        ))\n    if default_account != \"\" and account == \"\":\n        account = default_account\n    if account != \"\":\n        ret = { \"google_account\" : account }\n\n    puts(\"\\n- Done configuring Google spreadsheets.\")\n    return ret"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nprompting user to set up Amazon S3.", "response": "def _setup_s3(settings, path, prompt=True):\n    \"\"\"\n    Prompt user to set up Amazon S3.\n    \"\"\"\n    ret = {'default_s3_buckets': {}, 's3_credentials': settings.get('s3_credentials', {})}\n\n    if prompt:\n        use = raw_input(\"\\nWould you like to set up Amazon S3? [Y/n] \")\n        if use.lower() != \"y\" and use != \"\":\n            puts(\"\\n- Not configuring Amazon S3.\")\n            return ret\n\n    existing_access_key = settings.get('default_s3_access_key_id', None) or \\\n                          os.environ.get('AWS_ACCESS_KEY_ID', None)\n    existing_secret_key = settings.get('default_s3_secret_access_key', None) or \\\n                          os.environ.get('AWS_SECRET_ACCESS_KEY', None)\n\n    access_key_prompt = \"\\nPlease enter your default Amazon Access Key ID:\"\n    if existing_access_key:\n        access_key_prompt += ' [%s] ' % existing_access_key\n    else:\n        access_key_prompt += ' (leave blank to skip) '\n    default_aws_access_key_id = raw_input(access_key_prompt)\n\n    if default_aws_access_key_id == '' and existing_access_key:\n        default_aws_access_key_id = existing_access_key\n\n\n    if default_aws_access_key_id:\n        secret_key_prompt = \"\\nPlease enter your default Amazon Secret Access Key:\"\n        if existing_secret_key:\n            secret_key_prompt += ' [%s] ' % existing_secret_key\n        else:\n            secret_key_prompt += ' (leave blank to skip) '\n        default_aws_secret_access_key = raw_input(secret_key_prompt)\n\n        if default_aws_secret_access_key == '' and existing_secret_key:\n            default_aws_secret_access_key = existing_secret_key\n\n        ret.update({\n            'default_s3_access_key_id': default_aws_access_key_id,\n            'default_s3_secret_access_key': default_aws_secret_access_key,\n        })\n\n    # If we're all set with AWS creds, we can setup our default\n    # staging and production buckets\n    if default_aws_access_key_id and default_aws_secret_access_key:\n        existing_staging_bucket = None\n        existing_production_bucket = None\n        if settings.get('default_s3_buckets'):\n            existing_staging_bucket = settings['default_s3_buckets'].get('staging', None)\n            existing_production_bucket = settings['default_s3_buckets'].get('production', None)\n\n        staging_prompt = \"\\nWhat is your default staging bucket?\"\n        if existing_staging_bucket:\n            staging_prompt += ' [%s] ' % existing_staging_bucket\n        else:\n            staging_prompt += ' (e.g. apps.beta.myorg.com, leave blank to skip) '\n        staging = raw_input(staging_prompt)\n\n        if staging == '' and existing_staging_bucket:\n            staging = existing_staging_bucket\n        if staging != \"\":\n            ret['default_s3_buckets'].update({\n                'staging': staging,\n            })\n\n        production_prompt = \"\\nWhat is your default production bucket?\"\n        if existing_production_bucket:\n            production_prompt += ' [%s] ' % existing_production_bucket\n        else:\n            production_prompt += ' (e.g. apps.myorg.com, leave blank to skip) '\n        production = raw_input(production_prompt)\n\n        if production == '' and existing_production_bucket:\n            production = existing_production_bucket\n        if production != \"\":\n            ret['default_s3_buckets'].update({\n                'production': production,\n            })\n\n\n    more_prompt = \"\\nWould you like to add additional buckets and credentials? [y/N] \"\n    while raw_input(more_prompt).lower() == 'y':\n        ## Ask for a uri\n        additional_s3_bucket = raw_input(\n            \"\\nPlease specify an additional bucket (e.g. \"\n            \"additional.bucket.myorg.com/, leave blank to skip adding bucket) \")\n        if additional_s3_bucket == \"\":\n            continue\n\n        ## Ask for an access key, if it differs from the default\n        additional_access_key_prompt = \"\\nPlease specify an AWS Access Key ID for this bucket:\"\n\n        if default_aws_access_key_id:\n            additional_access_key_prompt += ' [%s] ' % default_aws_access_key_id\n        else:\n            additional_access_key_prompt += ' (leave blank to skip adding bucket) '\n\n        additional_aws_access_key_id = raw_input(additional_access_key_prompt)\n\n        if additional_aws_access_key_id == \"\" and default_aws_access_key_id:\n            additional_aws_access_key_id = default_aws_access_key_id\n        elif additional_aws_access_key_id == \"\":\n            continue\n\n        # Ask for a secret key, if it differs from default\n        additional_secret_key_prompt = \"\\nPlease specify an AWS Secret Access Key for this bucket:\"\n\n        if default_aws_secret_access_key:\n            additional_secret_key_prompt += ' [%s] ' % default_aws_secret_access_key\n        else:\n            additional_secret_key_prompt += ' (leave blank to skip adding bucket) '\n\n        additional_aws_secret_access_key = raw_input(\n            additional_secret_key_prompt)\n\n        if additional_aws_secret_access_key == \"\" and default_aws_secret_access_key:\n            additional_aws_secret_access_key = default_aws_secret_access_key\n        elif additional_aws_secret_access_key == \"\":\n            continue\n\n        ret['s3_credentials'][additional_s3_bucket] = {\n            'access_key_id': additional_aws_access_key_id,\n            'secret_access_key': additional_aws_secret_access_key,\n        }\n\n    puts(\"\\n- Done configuring Amazon S3.\")\n    return ret"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _setup_tarbell_project_path(settings, path, prompt=True):\n    default_path = os.path.expanduser(os.path.join(\"~\", \"tarbell\"))\n    projects_path = raw_input(\"\\nWhat is your Tarbell projects path? [Default: {0}, 'none' to skip] \".format(default_path))\n    if projects_path == \"\":\n        projects_path = default_path\n    if projects_path.lower() == 'none':\n        puts(\"\\n- Not creating projects directory.\")\n        return {}\n\n    if os.path.isdir(projects_path):\n        puts(\"\\nDirectory exists!\")\n    else:\n        puts(\"\\nDirectory does not exist.\")\n        make = raw_input(\"\\nWould you like to create it? [Y/n] \")\n        if make.lower() == \"y\" or not make:\n            os.makedirs(projects_path)\n    puts(\"\\nProjects path is {0}\".format(projects_path))\n    puts(\"\\n- Done setting up projects path.\")\n    return {\"projects_path\": projects_path}", "response": "Setup Tarbell project path."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _setup_default_templates(settings, path, prompt=True):\n    project_templates = [{\n        \"name\": \"Basic Bootstrap 3 template\",\n        \"url\": \"https://github.com/tarbell-project/tarbell-template\",\n    }, {\n        \"name\": \"Searchable map template\",\n        \"url\": \"https://github.com/tarbell-project/tarbell-map-template\",\n    }, {\n        \"name\": \"Tarbell template walkthrough\",\n        \"url\": \"https://github.com/tarbell-project/tarbell-tutorial-template\",\n    }]\n    for project in project_templates:\n        puts(\"+ Adding {0} ({1})\".format(project[\"name\"], project[\"url\"]))\n\n    puts(\"\\n- Done configuring project templates.\")\n    return {\"project_templates\": project_templates}", "response": "Add some (hardcoded) default templates."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef puts(s='', newline=True, stream=STDOUT):\n    if not is_werkzeug_process():\n        try:\n            return _puts(s, newline, stream)\n        except UnicodeEncodeError:\n            return _puts(s.encode(sys.stdout.encoding), newline, stream)", "response": "Wrap puts to avoid getting called twice by Werkzeug reloader."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef list_get(l, idx, default=None):\n    try:\n        if l[idx]:\n            return l[idx]\n        else:\n            return default\n    except IndexError:\n        return default", "response": "Get from a list with an optional default value."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef split_sentences(s, pad=0):\n    sentences = []\n    for index, sentence in enumerate(s.split('. ')):\n        padding = ''\n        if index > 0:\n            padding = ' ' * (pad + 1)\n        if sentence.endswith('.'):\n            sentence = sentence[:-1]\n        sentences.append('%s %s.' % (padding, sentence.strip()))\n    return \"\\n\".join(sentences)", "response": "Split a string into a list of sentences."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nensures that the directory exists for a given file path.", "response": "def ensure_directory(path):\n    \"\"\"\n    Ensure directory exists for a given file path.\n    \"\"\"\n    dirname = os.path.dirname(path)\n    if not os.path.exists(dirname):\n        os.makedirs(dirname)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef add_stream(self, policy):\n        _srtp_assert(lib.srtp_add_stream(self._srtp[0], policy._policy))", "response": "Add a stream to the SRTP session applying the given policy to the stream."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nremove the stream with the given ssrc from the SRTP session.", "response": "def remove_stream(self, ssrc):\n        \"\"\"\n        Remove the stream with the given `ssrc` from the SRTP session.\n\n        :param ssrc: :class:`int`\n        \"\"\"\n        _srtp_assert(lib.srtp_remove_stream(self._srtp[0], htonl(ssrc)))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef process_xlsx(content):\n    data = {}\n    workbook = xlrd.open_workbook(file_contents=content)\n    worksheets = [w for w in workbook.sheet_names() if not w.startswith('_')]\n    for worksheet_name in worksheets:\n        if worksheet_name.startswith('_'):\n            continue\n\n        worksheet = workbook.sheet_by_name(worksheet_name)\n\n        merged_cells = worksheet.merged_cells\n        if len(merged_cells):\n            raise MergedCellError(worksheet.name, merged_cells)\n\n        worksheet.name = slughifi(worksheet.name)\n        headers = make_headers(worksheet)\n        worksheet_data = make_worksheet_data(headers, worksheet)\n        data[worksheet.name] = worksheet_data\n    return data", "response": "Converts Excel file contents into Tarbell worksheet data"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef copy_global_values(data):\n    for k, v in data['values'].items():\n        if not data.get(k):\n            data[k] = v\n        else:\n            puts(\"There is both a worksheet and a \"\n                 \"value named '{0}'. The worksheet data \"\n                 \"will be preserved.\".format(k))\n    data.pop(\"values\", None)\n    return data", "response": "Copy values from the global namespace into the data."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef make_headers(worksheet):\n    headers = {}\n    cell_idx = 0\n    while cell_idx < worksheet.ncols:\n        cell_type = worksheet.cell_type(0, cell_idx)\n        if cell_type == 1:\n            header = slughifi(worksheet.cell_value(0, cell_idx))\n            if not header.startswith(\"_\"):\n                headers[cell_idx] = header\n        cell_idx += 1\n    return headers", "response": "Make headers from worksheet\n   "}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef make_worksheet_data(headers, worksheet):\n    data = []\n    row_idx = 1\n    while row_idx < worksheet.nrows:\n        cell_idx = 0\n        row_dict = {}\n        while cell_idx < worksheet.ncols:\n            cell_type = worksheet.cell_type(row_idx, cell_idx)\n            if cell_type in VALID_CELL_TYPES:\n                cell_value = worksheet.cell_value(row_idx, cell_idx)\n                try:\n                    if cell_type == 2 and cell_value.is_integer():\n                        cell_value = int(cell_value)\n                    row_dict[headers[cell_idx]] = cell_value\n                except KeyError:\n                    try:\n                        column = ascii_uppercase[cell_idx]\n                    except IndexError:\n                        column = cell_idx\n                        puts(\"There is no header for cell with value '{0}' in column '{1}' of '{2}'\" .format(\n                            cell_value, column, worksheet.name\n                        ))\n            cell_idx += 1\n        data.append(row_dict)\n        row_idx += 1\n\n    # Magic key handling\n    if 'key' in headers.values():\n        keyed_data = {}\n        for row in data:\n            if 'key' in row.keys():\n                key = slughifi(row['key'])\n                if keyed_data.get(key):\n                    puts(\"There is already a key named '{0}' with value \"\n                           \"'{1}' in '{2}'. It is being overwritten with \"\n                           \"value '{3}'.\".format(key,\n                                   keyed_data.get(key),\n                                   worksheet.name,\n                                   row))\n\n                # Magic values worksheet\n                if worksheet.name == \"values\":\n                    value = row.get('value')\n                    if value not in (\"\", None):\n                        keyed_data[key] = value\n                else:\n                    keyed_data[key] = row\n\n        data = keyed_data\n\n    return data", "response": "Make data from a worksheet."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nensures preview is never cached", "response": "def never_cache_preview(self, response):\n        \"\"\"\n        Ensure preview is never cached\n        \"\"\"\n        response.cache_control.max_age = 0\n        response.cache_control.no_cache = True\n        response.cache_control.must_revalidate = True\n        response.cache_control.no_store = True\n        return response"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncalls each registered hook", "response": "def call_hook(self, hook, *args, **kwargs):\n        \"\"\"\n        Calls each registered hook\n        \"\"\"\n        for function in self.hooks[hook]:\n            function.__call__(*args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _get_base(self, path):\n        base = None\n\n        # Slightly ugly DRY violation for backwards compatibility with old\n        # \"_base\" convention\n        if os.path.isdir(os.path.join(path, \"_blueprint\")):\n            base_dir = os.path.join(path, \"_blueprint/\")\n            # Get the blueprint template and register it as a blueprint\n            if os.path.exists(os.path.join(base_dir, \"blueprint.py\")):\n                filename, pathname, description = imp.find_module('blueprint', [base_dir])\n                base = imp.load_module('blueprint', filename, pathname, description)\n                self.blueprint_name = \"_blueprint\"\n            else:\n                puts(\"No _blueprint/blueprint.py file found\")\n        elif os.path.isdir(os.path.join(path, \"_base\")):\n            puts(\"Using old '_base' convention\")\n            base_dir = os.path.join(path, \"_base/\")\n            if os.path.exists(os.path.join(base_dir, \"base.py\")):\n                filename, pathname, description = imp.find_module('base', [base_dir])\n                base = imp.load_module('base', filename, pathname, description)\n                self.blueprint_name = \"_base\"\n            else:\n                puts(\"No _base/base.py file found\")\n\n        if base:\n            base.base_dir = base_dir\n\n        if hasattr(base, 'blueprint') and isinstance(base.blueprint, Blueprint):\n            self.app.register_blueprint(base.blueprint, site=self)\n\n        return base", "response": "Get the base module for the current project."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nloads a Tarbell project and return a dictionary of the project s attributes.", "response": "def load_project(self, path):\n        \"\"\"\n        Load a Tarbell project\n        \"\"\"\n        base = self._get_base(path)\n\n        filename, pathname, description = imp.find_module('tarbell_config', [path])\n        project = imp.load_module('project', filename, pathname, description)\n\n        try:\n            self.key = project.SPREADSHEET_KEY\n            self.client = get_drive_api()\n        except AttributeError:\n            self.key = None\n            self.client = None\n\n        try:\n            project.CREATE_JSON\n        except AttributeError:\n            project.CREATE_JSON = False\n\n        try:\n            project.S3_BUCKETS\n        except AttributeError:\n            project.S3_BUCKETS = {}\n\n        project.EXCLUDES = list(set(EXCLUDES + getattr(project, 'EXCLUDES', []) + getattr(base, 'EXCLUDES', [])))\n\n        # merge project template types with defaults\n        project.TEMPLATE_TYPES = set(getattr(project, 'TEMPLATE_TYPES', [])) | set(TEMPLATE_TYPES)\n\n        try:\n            project.DEFAULT_CONTEXT\n        except AttributeError:\n            project.DEFAULT_CONTEXT = {}\n\n        project.DEFAULT_CONTEXT.update({\n            \"PROJECT_PATH\": self.path,\n            \"ROOT_URL\": \"127.0.0.1:5000\",\n            \"SPREADSHEET_KEY\": self.key,\n            \"BUCKETS\": project.S3_BUCKETS,\n            \"SITE\": self,\n        })\n\n        # Set up template loaders\n        template_dirs = [path]\n        if base:\n            template_dirs.append(base.base_dir)\n        error_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'error_templates')\n        template_dirs.append(error_path)\n\n        self.app.jinja_loader = TarbellFileSystemLoader(template_dirs)\n\n        # load the project blueprint, if it exists\n        if hasattr(project, 'blueprint') and isinstance(project.blueprint, Blueprint):\n            self.app.register_blueprint(project.blueprint, site=self)\n\n        return project, base"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nresolve static file paths", "response": "def _resolve_path(self, path):\n        \"\"\"\n        Resolve static file paths\n        \"\"\"\n        filepath = None\n        mimetype = None\n\n        for root, dirs, files in self.filter_files(self.path):\n            # Does it exist in error path?\n            error_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'error_templates', path)\n            try:\n                with open(error_path):\n                    mimetype, encoding = mimetypes.guess_type(error_path)\n                    filepath = error_path\n            except IOError:\n                pass\n\n            # Does it exist in Tarbell blueprint?\n            if self.base:\n                basepath = os.path.join(root, self.blueprint_name, path)\n                try:\n                    with open(basepath):\n                        mimetype, encoding = mimetypes.guess_type(basepath)\n                        filepath = basepath\n                except IOError:\n                    pass\n\n            # Does it exist under regular path?\n            fullpath = os.path.join(root, path)\n            try:\n                with open(fullpath):\n                    mimetype, encoding = mimetypes.guess_type(fullpath)\n                    filepath = fullpath\n            except IOError:\n                pass\n\n        return filepath, mimetype"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef data_json(self, extra_context=None, publish=False):\n        if not self.project.CREATE_JSON:\n            # nothing to see here, but the right mimetype\n            return jsonify()\n\n        if not self.data:\n            # this sets site.data by spreadsheet or gdoc\n            self.get_context(publish)\n\n        return jsonify(self.data)", "response": "Serve site context as JSON. Useful for debugging."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nserves up a project path and return a response.", "response": "def preview(self, path=None, extra_context=None, publish=False):\n        \"\"\"\n        Serve up a project path\n        \"\"\"\n        try:\n            self.call_hook(\"preview\", self)\n\n            if path is None:\n                path = 'index.html'\n\n            # Detect files\n            filepath, mimetype = self._resolve_path(path)\n\n            # Serve dynamic\n            if filepath and mimetype and mimetype in self.project.TEMPLATE_TYPES:\n                context = self.get_context(publish)\n                context.update({\n                    \"PATH\": path,\n                    \"PREVIEW_SERVER\": not publish,\n                    \"TIMESTAMP\": int(time.time()),\n                })\n                if extra_context:\n                    context.update(extra_context)\n\n                rendered = render_template(path, **context)\n                return Response(rendered, mimetype=mimetype)\n\n            # Serve static\n            if filepath:\n                dir, filename = os.path.split(filepath)\n                return send_from_directory(dir, filename)\n\n        except Exception as e:\n            ex_type, ex, tb = sys.exc_info()\n            try:\n                # Find template with name of error\n                cls = e.__class__\n                ex_type, ex, tb = sys.exc_info()\n\n                context = self.project.DEFAULT_CONTEXT\n                context.update({\n                    'PATH': path,\n                    'traceback': traceback.format_exception(ex_type, ex, tb),\n                    'e': e,\n                })\n                if extra_context:\n                    context.update(extra_context)\n\n                try:\n                    error_path = '_{0}.{1}.html'.format(cls.__module__, cls.__name__)\n                    rendered = render_template(error_path, **context)\n                except TemplateNotFound:\n                    # Find template without underscore prefix, @TODO remove in v1.1\n                    error_path = '{0}.{1}.html'.format(cls.__module__, cls.__name__)\n                    rendered = render_template(error_path, **context)\n\n                return Response(rendered, mimetype=\"text/html\")\n            except TemplateNotFound:\n                # Otherwise raise old error\n                reraise(ex_type, ex, tb)\n\n        # Last ditch effort -- see if path has \"index.html\" underneath it\n        if not path.endswith(\"index.html\"):\n            if not path.endswith(\"/\"):\n                path = \"{0}/\".format(path)\n            path = \"{0}{1}\".format(path, \"index.html\")\n            return self.preview(path)\n\n        # It's a 404\n        if path.endswith('/index.html'):\n            path = path[:-11]\n        rendered = render_template(\"404.html\", PATH=path)\n        return Response(rendered, status=404)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the parsed data.", "response": "def get_context(self, publish=False):\n        \"\"\"\n        Use optional CONTEXT_SOURCE_FILE setting to determine data source.\n        Return the parsed data.\n\n        Can be an http|https url or local file. Supports csv and excel files.\n        \"\"\"\n        context = self.project.DEFAULT_CONTEXT\n        try:\n            file = self.project.CONTEXT_SOURCE_FILE\n            # CSV\n            if re.search(r'(csv|CSV)$', file):\n                context.update(self.get_context_from_csv())\n            # Excel\n            if re.search(r'(xlsx|XLSX|xls|XLS)$', file):\n                context.update(self.get_context_from_xlsx())\n        except AttributeError:\n            context.update(self.get_context_from_gdoc())\n\n        return context"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting context from an Excel file", "response": "def get_context_from_xlsx(self):\n        \"\"\"\n        Get context from an Excel file\n        \"\"\"\n        if re.search('^(http|https)://', self.project.CONTEXT_SOURCE_FILE):\n            resp = requests.get(self.project.CONTEXT_SOURCE_FILE)\n            content = resp.content\n        else:\n            try:\n                with open(self.project.CONTEXT_SOURCE_FILE) as xlsxfile:\n                    content = xlsxfile.read()\n            except IOError:\n                filepath = \"%s/%s\" % (\n                    os.path.abspath(self.path),\n                    self.project.CONTEXT_SOURCE_FILE)\n                with open(filepath) as xlsxfile:\n                    content = xlsxfile.read()\n\n        data = process_xlsx(content)\n        if 'values' in data:\n            data = copy_global_values(data)\n\n        return data"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nparsing and return a context from the CONTEXT_SOURCE_FILE", "response": "def get_context_from_csv(self):\n        \"\"\"\n        Open CONTEXT_SOURCE_FILE, parse and return a context\n        \"\"\"\n        if re.search('^(http|https)://', self.project.CONTEXT_SOURCE_FILE):\n            data = requests.get(self.project.CONTEXT_SOURCE_FILE)\n            reader = csv.reader(\n                data.iter_lines(), delimiter=',', quotechar='\"')\n            ret = {rows[0]: rows[1] for rows in reader}\n        else:\n            try:\n                with open(self.project.CONTEXT_SOURCE_FILE) as csvfile:\n                    reader = csv.reader(csvfile, delimiter=',', quotechar='\"')\n                    ret = {rows[0]: rows[1] for rows in reader}\n            except IOError:\n                file = \"%s/%s\" % (\n                    os.path.abspath(self.path),\n                    self.project.CONTEXT_SOURCE_FILE)\n                with open(file) as csvfile:\n                    reader = csv.reader(csvfile, delimiter=',', quotechar='\"')\n                    ret = {rows[0]: rows[1] for rows in reader}\n        ret.update({\n            \"CONTEXT_SOURCE_FILE\": self.project.CONTEXT_SOURCE_FILE,\n        })\n        return ret"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_context_from_gdoc(self):\n        try:\n            start = int(time.time())\n            if not self.data or start > self.expires:\n                self.data = self._get_context_from_gdoc(self.project.SPREADSHEET_KEY)\n                end = int(time.time())\n                ttl = getattr(self.project, 'SPREADSHEET_CACHE_TTL',\n                              SPREADSHEET_CACHE_TTL)\n                self.expires = end + ttl\n            return self.data\n        except AttributeError:\n            return {}", "response": "Wrap getting context from Google sheets in a simple caching mechanism."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _get_context_from_gdoc(self, key):\n        try:\n            content = self.export_xlsx(key)\n            data = process_xlsx(content)\n            if 'values' in data:\n                data = copy_global_values(data)\n            return data\n        except BadStatusLine:\n            # Stale connection, reset API and data\n            puts(\"Connection reset, reloading drive API\")\n            self.client = get_drive_api()\n            return self._get_context_from_gdoc(key)", "response": "Create a Jinja2 context from a Google spreadsheet."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ndownloads xlsx version of spreadsheet.", "response": "def export_xlsx(self, key):\n        \"\"\"\n        Download xlsx version of spreadsheet.\n        \"\"\"\n        spreadsheet_file = self.client.files().get(fileId=key).execute()\n        links = spreadsheet_file.get('exportLinks')\n        downloadurl = links.get('application/vnd.openxmlformats-officedocument.spreadsheetml.sheet')\n        resp, content = self.client._http.request(downloadurl)\n        return content"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ngenerate a static site for the current application.", "response": "def generate_static_site(self, output_root=None, extra_context=None):\n        \"\"\"\n        Bake out static site\n        \"\"\"\n        self.app.config['BUILD_PATH'] = output_root\n\n        # use this hook for registering URLs to freeze\n        self.call_hook(\"generate\", self, output_root, extra_context)\n\n        if output_root is not None:\n            # realpath or this gets generated relative to the tarbell package\n            self.app.config['FREEZER_DESTINATION'] = os.path.realpath(output_root)\n\n        self.freezer.freeze()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nfilter files based on blueprint and project configuration as well as hidden files.", "response": "def filter_files(self, path):\n        \"\"\"\n        Exclude files based on blueprint and project configuration as well as hidden files.\n        \"\"\"\n        excludes = r'|'.join([fnmatch.translate(x) for x in self.project.EXCLUDES]) or r'$.'\n        for root, dirs, files in os.walk(path, topdown=True):\n            dirs[:] = [d for d in dirs if not re.match(excludes, d)]\n            dirs[:] = [os.path.join(root, d) for d in dirs]\n            rel_path = os.path.relpath(root, path)\n\n            paths = []\n            for f in files:\n                if rel_path == '.':\n                    file_path = f\n                else:\n                    file_path = os.path.join(rel_path, f)\n                if not re.match(excludes, file_path):\n                    paths.append(f)\n\n            files[:] = paths\n            yield root, dirs, files"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nfind all files for publishing yield urlname kwargs", "response": "def find_files(self):\n        \"\"\"\n        Find all file paths for publishing, yield (urlname, kwargs)\n        \"\"\"\n        # yield blueprint paths first\n        if getattr(self, 'blueprint_name', None):\n            for path in walk_directory(os.path.join(self.path, self.blueprint_name), ignore=self.project.EXCLUDES):\n                yield 'preview', {'path': path}\n\n        # then yield project paths\n        for path in walk_directory(self.path, ignore=self.project.EXCLUDES):\n            yield 'preview', {'path': path}"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ndeploying a directory to an s3 bucket.", "response": "def deploy_to_s3(self):\n        \"\"\"\n        Deploy a directory to an s3 bucket.\n        \"\"\"\n        self.tempdir = tempfile.mkdtemp('s3deploy')\n\n        for keyname, absolute_path in self.find_file_paths():\n            self.s3_upload(keyname, absolute_path)\n\n        shutil.rmtree(self.tempdir, True)\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef s3_upload(self, keyname, absolute_path):\n        mimetype = mimetypes.guess_type(absolute_path)\n        options = {'Content-Type': mimetype[0]}\n\n        if mimetype[0] is not None and mimetype[0].startswith('text/'):\n            upload = open(absolute_path, 'rb')\n            options['Content-Encoding'] = 'gzip'\n            key_parts = keyname.split('/')\n            filename = key_parts.pop()\n            temp_path = os.path.join(self.tempdir, filename)\n            gzfile = gzip.GzipFile(temp_path, 'wb', 9, None, GZIP_TIMESTAMP)\n            gzfile.write(upload.read())\n            gzfile.close()\n            absolute_path = temp_path\n\n        hash = '\"{0}\"'.format(hashlib.md5(open(absolute_path, 'rb').read()).hexdigest())\n        key = \"{0}/{1}\".format(self.bucket.path, keyname)\n        existing = self.connection.get_key(key)\n\n        if self.force or not existing or (existing.etag != hash):\n            k = Key(self.connection)\n            k.key = key\n            puts(\"+ Uploading {0}/{1}\".format(self.bucket, keyname))\n            k.set_contents_from_filename(absolute_path, options, policy='public-read')\n        else:\n            puts(\"- Skipping  {0}/{1}, files match\".format(self.bucket, keyname))", "response": "Upload a file to s3"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef find_file_paths(self):\n        paths = []\n        for root, dirs, files in os.walk(self.directory, topdown=True):\n            rel_path = os.path.relpath(root, self.directory)\n            for f in files:\n                if rel_path == '.':\n                    path = (f, os.path.join(root, f))\n                else:\n                    path = (os.path.join(rel_path, f), os.path.join(root, f))\n                paths.append(path)\n        return paths", "response": "A generator function that recursively finds all files in the upload directory."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_drive_api():\n    settings = Settings()\n\n    if settings.credentials:\n        return get_drive_api_from_file(settings.credentials_path)\n\n    if settings.client_secrets:\n        return get_drive_api_from_client_secrets(settings.client_secrets_path)", "response": "Get drive API client based on settings."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nread the client secrets file if available and authorizes them.", "response": "def get_drive_api_from_client_secrets(path, reset_creds=False):\n    \"\"\"\n    Reads the local client secrets file if available (otherwise, opens a\n    browser tab to walk through the OAuth 2.0 process, and stores the client\n    secrets for future use) and then authorizes those credentials. Returns a\n    Google Drive API service object.\n    \"\"\"\n    storage = keyring_storage.Storage('tarbell', getpass.getuser())\n    credentials = None\n    if not reset_creds:\n        credentials = storage.get()\n    if path and not credentials:\n        flow = client.flow_from_clientsecrets(path, scope=OAUTH_SCOPE)\n        credentials = tools.run_flow(flow, storage, flags)\n        storage.put(credentials)\n\n    return _get_drive_api(credentials)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_drive_api_from_file(path):\n    f = open(path)\n    credentials = client.OAuth2Credentials.from_json(f.read())\n    return _get_drive_api(credentials)", "response": "Get drive API from file."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a drive API object for a given set of credentials.", "response": "def _get_drive_api(credentials):\n    \"\"\"\n    For a given set of credentials, return a drive API object.\n    \"\"\"\n    http = httplib2.Http()\n    http = credentials.authorize(http)\n    service = discovery.build('drive', 'v2', http=http)\n    service.credentials = credentials  # duck punch service obj. with credentials\n    return service"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef tarbell_install_blueprint(command, args):\n    with ensure_settings(command, args) as settings:\n        name = None\n        error = None\n        template_url = args.get(0)\n        matches = [template for template in settings.config[\"project_templates\"] if template.get(\"url\") == template_url]\n        tempdir = tempfile.mkdtemp()\n\n        if matches:\n            puts(\"\\n{0} already exists. Nothing more to do.\\n\".format(\n                colored.yellow(template_url)\n            ))\n            sys.exit()\n\n        try:\n            puts(\"\\nInstalling {0}\".format(colored.cyan(template_url)))\n            puts(\"\\n- Cloning repo\")\n            git = sh.git.bake(_cwd=tempdir, _tty_in=True, _tty_out=False, _err_to_out=True)\n            puts(git.clone(template_url, '.'))\n\n            _install_requirements(tempdir)\n\n            filename, pathname, description = imp.find_module('blueprint', [tempdir])\n            blueprint = imp.load_module('blueprint', filename, pathname, description)\n            puts(\"\\n- Found _blueprint/blueprint.py\")\n            name = blueprint.NAME\n            puts(\"\\n- Name specified in blueprint.py: {0}\".format(colored.yellow(name)))\n            settings.config[\"project_templates\"].append({\"name\": name, \"url\": template_url})\n            settings.save()\n\n        except AttributeError:\n            name = template_url.split(\"/\")[-1]\n            error = \"\\n- No name specified in blueprint.py, using '{0}'\".format(colored.yellow(name))\n\n        except ImportError:\n            error = 'No blueprint.py found'\n\n        except sh.ErrorReturnCode_128 as e:\n            if e.stdout.strip('\\n').endswith('Device not configured'):\n                error = 'Git tried to prompt for a username or password.\\n\\nTarbell doesn\\'t support interactive sessions. Please configure ssh key access to your Git repository. (See https://help.github.com/articles/generating-ssh-keys/)'\n            else:\n                error = 'Not a valid repository or Tarbell project'\n        finally:\n            _delete_dir(tempdir)\n            if error:\n                show_error(error)\n            else:\n                puts(\"\\n+ Added new project template: {0}\".format(colored.yellow(name)))", "response": "Install a project template."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nlisting available Tarbell templates.", "response": "def tarbell_list_templates(command, args):\n    \"\"\"\n    List available Tarbell blueprints.\n    \"\"\"\n    with ensure_settings(command, args) as settings:\n        puts(\"\\nAvailable project templates\\n\")\n        _list_templates(settings)\n        puts(\"\")"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef tarbell_newproject(command, args):\n    with ensure_settings(command, args) as settings:\n        # Set it up and make the directory\n        name = _get_project_name(args)\n        puts(\"Creating {0}\".format(colored.cyan(name)))\n        path = _get_path(name, settings)\n        _mkdir(path)\n\n        try:\n            _newproject(command, path, name, settings)\n        except KeyboardInterrupt:\n            _delete_dir(path)\n            show_error(\"ctrl-c pressed, not creating new project.\")\n        except:\n            _delete_dir(path)\n            show_error(\"Unexpected error: {0}\".format(sys.exc_info()[0]))\n            raise", "response": "Create a new Tarbell project."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nserve the current Tarbell project.", "response": "def tarbell_serve(command, args):\n    \"\"\"\n    Serve the current Tarbell project.\n    \"\"\"\n    with ensure_project(command, args) as site:\n        with ensure_settings(command, args) as settings:\n            address = list_get(args, 0, \"\").split(\":\")\n            ip = list_get(address, 0, settings.config['default_server_ip'])\n            port = int(list_get(address, 1, settings.config['default_server_port']))\n\n        puts(\"\\n * Running local server. Press {0} to stop the server\".format(colored.red(\"ctrl-c\")))\n        puts(\" * Edit this project's templates at {0}\".format(colored.yellow(site.path)))\n        try:\n            if not is_werkzeug_process():\n                site.call_hook(\"server_start\", site)\n\n            site.app.run(ip, port=port)\n\n            if not is_werkzeug_process():\n                site.call_hook(\"server_stop\", site)\n\n        except socket.error:\n            show_error(\"Address {0} is already in use, please try another port or address.\"\n                 .format(colored.yellow(\"{0}:{1}\".format(ip, port))))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef tarbell_switch(command, args):\n    with ensure_settings(command, args) as settings:\n        projects_path = settings.config.get(\"projects_path\")\n        if not projects_path:\n            show_error(\"{0} does not exist\".format(projects_path))\n            sys.exit()\n        project = args.get(0)\n        args.remove(project)\n        project_path = os.path.join(projects_path, project)\n        if os.path.isdir(project_path):\n            os.chdir(project_path)\n            puts(\"\\nSwitching to {0}\".format(colored.red(project)))\n            tarbell_serve(command, args)\n        else:\n            show_error(\"{0} isn't a tarbell project\".format(project_path))", "response": "Switch to a project."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nupdating the current tarbell project.", "response": "def tarbell_update(command, args):\n    \"\"\"\n    Update the current tarbell project.\n    \"\"\"\n    with ensure_settings(command, args) as settings, ensure_project(command, args) as site:\n        puts(\"Updating to latest blueprint\\n\")\n\n        git = sh.git.bake(_cwd=site.base.base_dir)\n\n        # stash then pull\n        puts(colored.yellow(\"Stashing local changes\"))\n        puts(git.stash())\n\n        puts(colored.yellow(\"Pull latest changes\"))\n        puts(git.pull())\n        \n        # need to pop any local changes back to get back on the original branch\n        # this may behave oddly if you have old changes stashed\n        if git.stash.list():\n            puts(git.stash.pop())"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nopens a context spreadsheet with the specified settings and project.", "response": "def tarbell_spreadsheet(command, args):\n    \"\"\"\n    Open context spreadsheet\n    \"\"\"\n    with ensure_settings(command, args) as settings, ensure_project(command, args) as site:\n        try:\n            # First, try to get the Google Spreadsheet URL\n            spreadsheet_url = _google_spreadsheet_url(site.project.SPREADSHEET_KEY)\n        except AttributeError:\n            # The project doesn't seem to be using a Google Spreadsheet.\n            # Try the URL or path specified in the CONTEXT_SOURCE_FILE setting\n            try:\n                spreadsheet_url = _context_source_file_url(\n                    site.project.CONTEXT_SOURCE_FILE)\n                print(spreadsheet_url)\n            except AttributeError:\n                puts(colored.red(\"No Google spreadsheet or context source file \"\n                                 \"has been configured.\\n\"))\n                return\n\n        # Use the webbrowser package to try to open the file whether it's a\n        # remote URL on the web, or a local file.  On some platforms it will\n        # successfully open local files in the default application.\n        # This seems preferable to trying to do os detection and calling\n        # the system-specific command for opening files in default\n        # applications.\n        # See\n        # http://stackoverflow.com/questions/434597/open-document-with-default-application-in-python\n        webbrowser.open(spreadsheet_url)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a URL for a remote or local context CSV file", "response": "def _context_source_file_url(path_or_url):\n    \"\"\"\n    Returns a URL for a remote or local context CSV file\n    \"\"\"\n    if path_or_url.startswith('http'):\n        # Remote CSV. Just return the URL\n        return path_or_url\n\n    if path_or_url.startswith('/'):\n        # Absolute path\n        return \"file://\" + path_or_url\n\n    return \"file://\" + os.path.join(os.path.realpath(os.getcwd()), path_or_url)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _newproject(command, path, name, settings):\n    key = None\n    title = _get_project_title()\n    template = _get_template(settings)\n\n    # Init repo\n    git = sh.git.bake(_cwd=path)\n    puts(git.init())\n\n    if template.get(\"url\"):\n        # Create submodule\n        puts(git.submodule.add(template['url'], '_blueprint'))\n        puts(git.submodule.update(*['--init']))\n\n        # Create spreadsheet\n        key = _create_spreadsheet(name, title, path, settings)\n\n        # Copy html files\n        puts(colored.green(\"\\nCopying html files...\"))\n        files = glob.iglob(os.path.join(path, \"_blueprint\", \"*.html\"))\n        for file in files:\n            if os.path.isfile(file):\n                dir, filename = os.path.split(file)\n                if not filename.startswith(\"_\") and not filename.startswith(\".\"):\n                    puts(\"Copying {0} to {1}\".format(filename, path))\n                    shutil.copy2(file, path)\n        ignore = os.path.join(path, \"_blueprint\", \".gitignore\")\n        if os.path.isfile(ignore):\n            shutil.copy2(ignore, path)\n    else:\n        empty_index_path = os.path.join(path, \"index.html\")\n        open(empty_index_path, \"w\")\n\n    # Create config file\n    _copy_config_template(name, title, template, path, key, settings)\n\n    # Commit\n    puts(colored.green(\"\\nInitial commit\"))\n    puts(git.add('.'))\n    puts(git.commit(m='Created {0} from {1}'.format(name, template['name'])))\n\n    _install_requirements(path)\n\n    # Get site, run hook\n    with ensure_project(command, args, path) as site:\n        site.call_hook(\"newproject\", site, git)\n\n    # Messages\n    puts(\"\\nAll done! To preview your new project, type:\\n\")\n    puts(\"{0} {1}\".format(colored.green(\"tarbell switch\"), colored.green(name)))\n    puts(\"\\nor\\n\")\n    puts(\"{0}\".format(colored.green(\"cd %s\" % path)))\n    puts(\"{0}\".format(colored.green(\"tarbell serve\\n\")))\n\n    puts(\"\\nYou got this!\\n\")", "response": "Helper to create a new project."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ninstalls a blueprint s requirements. txt", "response": "def _install_requirements(path):\n    \"\"\"\n    Install a blueprint's requirements.txt\n    \"\"\"\n    locations = [os.path.join(path, \"_blueprint\"), os.path.join(path, \"_base\"), path]\n    success = True\n\n    for location in locations:\n        try:\n            with open(os.path.join(location, \"requirements.txt\")):\n                puts(\"\\nRequirements file found at {0}\".format(os.path.join(location, \"requirements.txt\")))\n                install_reqs = raw_input(\"Install requirements now with pip install -r requirements.txt? [Y/n] \")\n                if not install_reqs or install_reqs.lower() == 'y':\n                    pip = sh.pip.bake(_cwd=location)\n                    puts(\"\\nInstalling requirements...\")\n                    puts(pip(\"install\", \"-r\", \"requirements.txt\"))\n                else:\n                    success = False\n                    puts(\"Not installing requirements. This may break everything! Vaya con dios.\")\n        except IOError:\n            pass\n\n    return success"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nremove the suffix from the string and returns the string.", "response": "def _clean_suffix(string, suffix):\n    \"\"\"\n    If string endswith the suffix, remove it. Else leave it alone.\n    \"\"\"\n    suffix_len = len(suffix)\n\n    if len(string) < suffix_len:\n        # the string param was shorter than the suffix\n        raise ValueError(\"A suffix can not be bigger than string argument.\")\n    if string.endswith(suffix):\n        # return from the beginning up to\n        # but not including the first letter\n        # in the suffix\n        return string[0:-suffix_len]\n    else:\n        # leave unharmed\n        return string"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _get_path(name, settings, mkdir=True):\n    default_projects_path = settings.config.get(\"projects_path\")\n    path = None\n\n    if default_projects_path:\n        path = raw_input(\"\\nWhere would you like to create this project? [{0}/{1}] \".format(default_projects_path, name))\n        if not path:\n            path = os.path.join(default_projects_path, name)\n    else:\n        while not path:\n            path = raw_input(\"\\nWhere would you like to create this project? (e.g. ~/tarbell/) \")\n\n    return os.path.expanduser(path)", "response": "Generate a project path."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _mkdir(path):\n    try:\n        os.mkdir(path)\n    except OSError as e:\n        if e.errno == 17:\n            show_error(\"ABORTING: Directory {0} already exists.\".format(path))\n        else:\n            show_error(\"ABORTING: OSError {0}\".format(e))\n        sys.exit()", "response": "Make a directory or bail."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _get_template(settings):\n    puts(\"\\nPick a template\\n\")\n    template = None\n    while not template:\n        _list_templates(settings)\n        index = raw_input(\"\\nWhich template would you like to use? [1] \")\n        if not index:\n            index = \"1\"\n        try:\n            index = int(index) - 1\n            return settings.config[\"project_templates\"][index]\n        except:\n            puts(\"\\\"{0}\\\" isn't a valid option!\".format(colored.red(\"{0}\".format(index))))\n            pass", "response": "Prompt user to pick a template from a list."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nlisting templates from settings.", "response": "def _list_templates(settings):\n    \"\"\"\n    List templates from settings.\n    \"\"\"\n    for idx, option in enumerate(settings.config.get(\"project_templates\"), start=1):\n        puts(\"  {0!s:5} {1!s:36}\".format(\n            colored.yellow(\"[{0}]\".format(idx)),\n            colored.cyan(option.get(\"name\"))\n        ))\n        if option.get(\"url\"):\n            puts(\"      {0}\\n\".format(option.get(\"url\")))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate a Google spreadsheet.", "response": "def _create_spreadsheet(name, title, path, settings):\n    \"\"\"\n    Create Google spreadsheet.\n    \"\"\"\n    if not settings.client_secrets:\n        return None\n\n    create = raw_input(\"Would you like to create a Google spreadsheet? [Y/n] \")\n\n    if create and not create.lower() == \"y\":\n        return puts(\"Not creating spreadsheet.\")\n\n    email_message = (\n        \"What Google account(s) should have access to this \"\n        \"this spreadsheet? (Use a full email address, such as \"\n        \"your.name@gmail.com. Separate multiple addresses with commas.)\")\n\n    if settings.config.get(\"google_account\"):\n        emails = raw_input(\"\\n{0}(Default: {1}) \".format(email_message,\n                                             settings.config.get(\"google_account\")\n                                            ))\n        if not emails:\n            emails = settings.config.get(\"google_account\")\n    else:\n        emails = None\n        while not emails:\n            emails = raw_input(email_message)\n\n    try:\n        media_body = _MediaFileUpload(os.path.join(path, '_blueprint/_spreadsheet.xlsx'),\n                                      mimetype='application/vnd.ms-excel')\n    except IOError:\n        show_error(\"_blueprint/_spreadsheet.xlsx doesn't exist!\")\n        return None\n\n    service = get_drive_api()\n    body = {\n        'title': '{0} (Tarbell)'.format(title),\n        'description': '{0} ({1})'.format(title, name),\n        'mimeType': 'application/vnd.ms-excel',\n    }\n    try:\n        newfile = service.files()\\\n            .insert(body=body, media_body=media_body, convert=True).execute()\n        for email in emails.split(\",\"):\n            _add_user_to_file(newfile['id'], service, user_email=email.strip())\n        puts(\"\\n{0!s}! View the spreadsheet at {1!s}\".format(\n            colored.green(\"Success\"),\n            colored.yellow(\"https://docs.google.com/spreadsheet/ccc?key={0}\"\n                           .format(newfile['id']))\n            ))\n        return newfile['id']\n    except errors.HttpError as error:\n        show_error('An error occurred creating spreadsheet: {0}'.format(error))\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nadds a user to a file in the spreadsheet.", "response": "def _add_user_to_file(file_id, service, user_email,\n                      perm_type='user', role='writer'):\n    \"\"\"\n    Grants the given set of permissions for a given file_id. service is an\n    already-credentialed Google Drive service instance.\n    \"\"\"\n    new_permission = {\n        'value': user_email,\n        'type': perm_type,\n        'role': role\n    }\n    try:\n        service.permissions()\\\n            .insert(fileId=file_id, body=new_permission)\\\n            .execute()\n    except errors.HttpError as error:\n        show_error('An error adding users to spreadsheet: {0}'.format(error))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _copy_config_template(name, title, template, path, key, settings):\n        puts(\"\\nCopying configuration file\")\n        context = settings.config\n        context.update({\n            \"default_context\": {\n                \"name\": name,\n                \"title\": title,\n            },\n            \"name\": name,\n            \"title\": title,\n            \"template_repo_url\": template.get('url'),\n            \"key\": key,\n        })\n\n        # @TODO refactor this a bit\n        if not key:\n            spreadsheet_path = os.path.join(path, '_blueprint/', '_spreadsheet.xlsx')\n            try:\n                with open(spreadsheet_path, \"rb\") as f:\n                    puts(\"Copying _blueprint/_spreadsheet.xlsx to tarbell_config.py's DEFAULT_CONTEXT\")\n                    data = process_xlsx(f.read())\n                    if 'values' in data:\n                        data = copy_global_values(data)\n                    context[\"default_context\"].update(data)\n            except IOError:\n                pass\n\n        s3_buckets = settings.config.get(\"s3_buckets\")\n        if s3_buckets:\n            puts(\"\")\n            for bucket, bucket_conf in s3_buckets.items():\n                puts(\"Configuring {0!s} bucket at {1!s}\\n\".format(\n                    colored.green(bucket),\n                    colored.yellow(\"{0}/{1}\".format(bucket_conf['uri'], name))\n                ))\n\n        puts(\"\\n- Creating {0!s} project configuration file\".format(\n            colored.cyan(\"tarbell_config.py\")\n        ))\n        template_dir = os.path.dirname(pkg_resources.resource_filename(\"tarbell\", \"templates/tarbell_config.py.template\"))\n        loader = jinja2.FileSystemLoader(template_dir)\n        env = jinja2.Environment(loader=loader)\n        env.filters[\"pprint_lines\"] = pprint_lines  # For dumping context\n        content = env.get_template('tarbell_config.py.template').render(context)\n        codecs.open(os.path.join(path, \"tarbell_config.py\"), \"w\", encoding=\"utf-8\").write(content)\n        puts(\"\\n- Done copying configuration file\")", "response": "Copy a template from Tarbell default to the tarbell_config. py. template file."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef save(self):\n        with open(self.path, \"w\") as f:\n            self.config[\"project_templates\"] = list(filter(lambda template: template.get(\"url\"), self.config[\"project_templates\"]))\n            yaml.dump(self.config, f, default_flow_style=False)", "response": "Save settings.\n            to file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef read_file(path, absolute=False, encoding='utf-8'):\n    site = g.current_site\n    if not absolute:\n        path = os.path.join(site.path, path)\n\n    try:\n        return codecs.open(path, 'r', encoding).read()\n    except IOError:\n        return None", "response": "Read the file at path."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nrender a file using the current context.", "response": "def render_file(context, path, absolute=False):\n    \"\"\"\n    Like :py:func:`read_file`, except that the file is rendered as a Jinja template \n    using the current context. If `absolute` is True, use absolute path, otherwise \n    path is assumed to be relative to Tarbell template root dir.\n        \n    For example:\n\n    .. code-block:: html+jinja\n    \n        <div class=\"chapter\">\n            {{ render_file('_chapters/one.txt') }}\n        </div>\n    \"\"\"\n    site = g.current_site\n    if not absolute:\n        path = os.path.join(site.path, path)\n\n    return render_template(path, **context)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a formatted date string.", "response": "def format_date(value, format='%b %d, %Y', convert_tz=None):\n    \"\"\"\n    Format an Excel date or date string, returning a formatted date.\n    To return a Python :py:class:`datetime.datetime` object, pass ``None``\n    as a ``format`` argument.\n\n    >>> format_date(42419.82163)\n    'Feb. 19, 2016'\n\n    .. code-block:: html+jinja\n\n        {{ row.date|format_date('%Y-%m-%d') }}\n    \"\"\"\n    if isinstance(value, float) or isinstance(value, int):\n        seconds = (value - 25569) * 86400.0\n        parsed = datetime.datetime.utcfromtimestamp(seconds)\n    else:\n        parsed = dateutil.parser.parse(value)\n    if convert_tz:\n        local_zone = dateutil.tz.gettz(convert_tz)\n        parsed = parsed.astimezone(tz=local_zone)\n\n    if format:\n        return parsed.strftime(format)\n    else:\n        return parsed"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef plot_composition(df, intervals, axes=None):\n\n    generics = df.columns\n    if (axes is not None) and (len(axes) != len(generics)):\n        raise ValueError(\"If 'axes' is not None then it must be the same \"\n                         \"length as 'df.columns'\")\n\n    if axes is None:\n        _, axes = plt.subplots(nrows=len(generics), ncols=1)\n        if len(generics) == 1:\n            axes = [axes]\n\n    for ax, generic in zip(axes, generics):\n        ax.plot(df.loc[:, generic], label=generic)\n        # no legend line to avoid clutter\n        ax.legend(loc='center right', handlelength=0)\n        dates = intervals.loc[intervals.loc[:, \"generic\"] == generic,\n                              [\"start_date\", \"end_date\", \"contract\"]]\n        date_ticks = set(\n            dates.loc[:, \"start_date\"].tolist() +\n            dates.loc[:, \"end_date\"].tolist()\n        )\n        xticks = [ts.toordinal() for ts in date_ticks]\n        xlabels = [ts.strftime(\"%Y-%m-%d\") for ts in date_ticks]\n        ax.set_xticks(xticks)\n        ax.set_xticklabels(xlabels)\n        y_top = ax.get_ylim()[1]\n        count = 0\n        # label and colour each underlying\n        for _, dt1, dt2, instr in dates.itertuples():\n            if count % 2:\n                fc = \"b\"\n            else:\n                fc = \"r\"\n            count += 1\n            ax.axvspan(dt1, dt2, facecolor=fc, alpha=0.2)\n            x_mid = dt1 + (dt2 - dt1) / 2\n            ax.text(x_mid, y_top, instr, rotation=45)\n\n    return axes", "response": "Plot a dataframe of generics and label underlying instruments which are composed of."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nextracts intervals where generics are composed of different tradeable instruments.", "response": "def intervals(weights):\n    \"\"\"\n    Extract intervals where generics are composed of different tradeable\n    instruments.\n\n    Parameters\n    ----------\n    weights: DataFrame or dict\n        A DataFrame or dictionary of DataFrames with columns representing\n        generics and a MultiIndex of date and contract. Values represent\n        weights on tradeables for each generic.\n\n    Returns\n    -------\n    A DataFrame with [columns]\n    ['contract', 'generic', 'start_date', 'end_date']\n\n    \"\"\"\n    intrvls = []\n    if isinstance(weights, dict):\n        for root in weights:\n            wts = weights[root]\n            intrvls.append(_intervals(wts))\n        intrvls = pd.concat(intrvls, axis=0)\n    else:\n        intrvls = _intervals(weights)\n    intrvls = intrvls.reset_index(drop=True)\n    return intrvls"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef synchronize(self):\n        LOG.info(_LI('Syncing Neutron Router DB <-> EOS'))\n        routers, router_interfaces = self.get_routers_and_interfaces()\n        expected_vrfs = set()\n        if self._use_vrf:\n            expected_vrfs.update(self.driver._arista_router_name(\n                r['id'], r['name']) for r in routers)\n        expected_vlans = set(r['seg_id'] for r in router_interfaces)\n        if self._enable_cleanup:\n            self.do_cleanup(expected_vrfs, expected_vlans)\n        self.create_routers(routers)\n        self.create_router_interfaces(router_interfaces)", "response": "Synchronizes the Router DB with the EOS."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates a new router entry in DB and create it Arista HW.", "response": "def create_router(self, context, router):\n        \"\"\"Create a new router entry in DB, and create it Arista HW.\"\"\"\n\n        # Add router to the DB\n        new_router = super(AristaL3ServicePlugin, self).create_router(\n            context,\n            router)\n        # create router on the Arista Hw\n        try:\n            self.driver.create_router(context, new_router)\n            return new_router\n        except Exception:\n            with excutils.save_and_reraise_exception():\n                LOG.error(_LE(\"Error creating router on Arista HW router=%s \"),\n                          new_router)\n                super(AristaL3ServicePlugin, self).delete_router(\n                    context,\n                    new_router['id']\n                )"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nupdate an existing router in DB and update it in Arista HW.", "response": "def update_router(self, context, router_id, router):\n        \"\"\"Update an existing router in DB, and update it in Arista HW.\"\"\"\n\n        # Read existing router record from DB\n        original_router = self.get_router(context, router_id)\n        # Update router DB\n        new_router = super(AristaL3ServicePlugin, self).update_router(\n            context, router_id, router)\n\n        # Modify router on the Arista Hw\n        try:\n            self.driver.update_router(context, router_id,\n                                      original_router, new_router)\n            return new_router\n        except Exception:\n            LOG.error(_LE(\"Error updating router on Arista HW router=%s \"),\n                      new_router)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef delete_router(self, context, router_id):\n\n        router = self.get_router(context, router_id)\n\n        # Delete router on the Arista Hw\n        try:\n            self.driver.delete_router(context, router_id, router)\n        except Exception as e:\n            LOG.error(_LE(\"Error deleting router on Arista HW \"\n                          \"router %(r)s exception=%(e)s\"),\n                      {'r': router, 'e': e})\n\n        super(AristaL3ServicePlugin, self).delete_router(context, router_id)", "response": "Delete an existing router from Arista HW and from the DB."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef add_router_interface(self, context, router_id, interface_info):\n\n        new_router = super(AristaL3ServicePlugin, self).add_router_interface(\n            context, router_id, interface_info)\n\n        core = directory.get_plugin()\n\n        # Get network info for the subnet that is being added to the router.\n        # Check if the interface information is by port-id or subnet-id\n        add_by_port, add_by_sub = self._validate_interface_info(interface_info)\n        if add_by_sub:\n            subnet = core.get_subnet(context, interface_info['subnet_id'])\n        elif add_by_port:\n            port = core.get_port(context, interface_info['port_id'])\n            subnet_id = port['fixed_ips'][0]['subnet_id']\n            subnet = core.get_subnet(context, subnet_id)\n        network_id = subnet['network_id']\n\n        # To create SVI's in Arista HW, the segmentation Id is required\n        # for this network.\n        ml2_db = NetworkContext(self, context, {'id': network_id})\n        seg_id = ml2_db.network_segments[0]['segmentation_id']\n\n        # Package all the info needed for Hw programming\n        router = self.get_router(context, router_id)\n        router_info = copy.deepcopy(new_router)\n        router_info['seg_id'] = seg_id\n        router_info['name'] = router['name']\n        router_info['cidr'] = subnet['cidr']\n        router_info['gip'] = subnet['gateway_ip']\n        router_info['ip_version'] = subnet['ip_version']\n\n        try:\n            self.driver.add_router_interface(context, router_info)\n            return new_router\n        except Exception:\n            with excutils.save_and_reraise_exception():\n                LOG.error(_LE(\"Error Adding subnet %(subnet)s to \"\n                              \"router %(router_id)s on Arista HW\"),\n                          {'subnet': subnet, 'router_id': router_id})\n                super(AristaL3ServicePlugin, self).remove_router_interface(\n                    context,\n                    router_id,\n                    interface_info)", "response": "Add a subnet of a network to an existing router."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nremoves a subnet of a network from an existing router.", "response": "def remove_router_interface(self, context, router_id, interface_info):\n        \"\"\"Remove a subnet of a network from an existing router.\"\"\"\n\n        router_to_del = (\n            super(AristaL3ServicePlugin, self).remove_router_interface(\n                context,\n                router_id,\n                interface_info)\n            )\n\n        # Get network information of the subnet that is being removed\n        core = directory.get_plugin()\n        subnet = core.get_subnet(context, router_to_del['subnet_id'])\n        network_id = subnet['network_id']\n\n        # For SVI removal from Arista HW, segmentation ID is needed\n        ml2_db = NetworkContext(self, context, {'id': network_id})\n        seg_id = ml2_db.network_segments[0]['segmentation_id']\n\n        router = self.get_router(context, router_id)\n        router_info = copy.deepcopy(router_to_del)\n        router_info['seg_id'] = seg_id\n        router_info['name'] = router['name']\n\n        try:\n            self.driver.remove_router_interface(context, router_info)\n            return router_to_del\n        except Exception as exc:\n            LOG.error(_LE(\"Error removing interface %(interface)s from \"\n                          \"router %(router_id)s on Arista HW\"\n                          \"Exception =(exc)s\"),\n                      {'interface': interface_info, 'router_id': router_id,\n                       'exc': exc})"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef initialize_switch_endpoints(self):\n        self._switches = {}\n        self._port_group_info = {}\n        self._validate_config()\n        for s in cfg.CONF.ml2_arista.switch_info:\n            switch_ip, switch_user, switch_pass = s.split(\":\")\n            if switch_pass == \"''\":\n                switch_pass = ''\n            self._switches[switch_ip] = api.EAPIClient(\n                switch_ip,\n                switch_user,\n                switch_pass,\n                verify=False,\n                timeout=cfg.CONF.ml2_arista.conn_timeout)\n        self._check_dynamic_acl_support()", "response": "Initialize switch endpoints for switch communication"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _check_dynamic_acl_support(self):\n        cmds = ['ip access-list openstack-test dynamic',\n                'no ip access-list openstack-test']\n        for switch_ip, switch_client in self._switches.items():\n            try:\n                self.run_openstack_sg_cmds(cmds)\n            except Exception:\n                LOG.error(\"Switch %s does not support dynamic ACLs. SG \"\n                          \"support will not be enabled on this switch.\",\n                          switch_ip)", "response": "Log an error if any switches don t support dynamic ACLs."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nensures at least one switch is configured", "response": "def _validate_config(self):\n        \"\"\"Ensure at least one switch is configured\"\"\"\n        if len(cfg.CONF.ml2_arista.get('switch_info')) < 1:\n            msg = _('Required option - when \"sec_group_support\" is enabled, '\n                    'at least one switch must be specified ')\n            LOG.exception(msg)\n            raise arista_exc.AristaConfigError(msg=msg)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef run_openstack_sg_cmds(self, commands, switch):\n        if not switch:\n            LOG.exception(\"No client found for switch\")\n            return []\n        if len(commands) == 0:\n            return []\n        command_start = ['enable', 'configure']\n        command_end = ['exit']\n        full_command = command_start + commands + command_end\n        return self._run_eos_cmds(full_command, switch)", "response": "Execute a list of commands on Arista switch and send them to the Arista server."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nexecuting a list of commands on Arista switch and return the result of the command.", "response": "def _run_eos_cmds(self, commands, switch):\n        \"\"\"Execute/sends a CAPI (Command API) command to EOS.\n\n        This method is useful for running show commands that require no\n        prefix or postfix commands.\n\n        :param commands : List of commands to be executed on EOS.\n        :param switch: Endpoint on the Arista switch to be configured\n        \"\"\"\n        LOG.info(_LI('Executing command on Arista EOS: %s'), commands)\n\n        try:\n            # this returns array of return values for every command in\n            # commands list\n            ret = switch.execute(commands)\n            LOG.info(_LI('Results of execution on Arista EOS: %s'), ret)\n            return ret\n        except Exception:\n            msg = (_('Error occurred while trying to execute '\n                     'commands %(cmd)s on EOS %(host)s') %\n                   {'cmd': commands, 'host': switch})\n            LOG.exception(msg)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn list of switch_ip and interface tuples from local_link_info", "response": "def _get_switchports(profile):\n        \"\"\"Return list of (switch_ip, interface) tuples from local_link_info\"\"\"\n        switchports = []\n        if profile.get('local_link_information'):\n            for link in profile['local_link_information']:\n                if 'switch_info' in link and 'port_id' in link:\n                    switch = link['switch_info']\n                    interface = link['port_id']\n                    switchports.append((switch, interface))\n                else:\n                    LOG.warning(\"Incomplete link information: %s\", link)\n        return switchports"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nrefresh data on switch interfaces port group membership", "response": "def _update_port_group_info(self, switches=None):\n        \"\"\"Refresh data on switch interfaces' port group membership\"\"\"\n        if switches is None:\n            switches = self._switches.keys()\n        for switch_ip in switches:\n            client = self._switches.get(switch_ip)\n            ret = self._run_eos_cmds(['show interfaces'], client)\n            if not ret or len(ret) == 0:\n                LOG.warning(\"Unable to retrieve interface info for %s\",\n                            switch_ip)\n                continue\n            intf_info = ret[0]\n            self._port_group_info[switch_ip] = intf_info.get('interfaces', {})"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _get_port_for_acl(self, port_id, switch):\n        all_intf_info = self._port_group_info.get(switch, {})\n        intf_info = all_intf_info.get(port_id, {})\n        member_info = intf_info.get('interfaceMembership', '')\n        port_group_info = re.search('Member of (?P<port_group>\\S+)',\n                                    member_info)\n        if port_group_info:\n            port_id = port_group_info.group('port_group')\n        return port_id", "response": "Gets the interface name for a given port_id for a switch."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _supported_rule(protocol, ethertype):\n        if not protocol or protocol not in utils.SUPPORTED_SG_PROTOCOLS:\n            return False\n\n        if ethertype != n_const.IPv4:\n            return False\n\n        return True", "response": "Checks that the rule is an IPv4 rule of a supported protocol"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets EOS formatted rule", "response": "def _format_rule(self, protocol, cidr, min_port, max_port, direction):\n        \"\"\"Get EOS formatted rule\"\"\"\n        if cidr is None:\n            cidr = 'any'\n\n        if direction == n_const.INGRESS_DIRECTION:\n            dst_ip = 'any'\n            src_ip = cidr\n        elif direction == n_const.EGRESS_DIRECTION:\n            dst_ip = cidr\n            src_ip = 'any'\n\n        if protocol == n_const.PROTO_NAME_ICMP:\n            rule = \"permit icmp %s %s\" % (src_ip, dst_ip)\n            if min_port:\n                rule += \" %s\" % (min_port)\n                if max_port:\n                    rule += \" %s\" % (max_port)\n        else:\n            rule = \"permit %s %s %s\" % (protocol, src_ip, dst_ip)\n            if min_port and max_port:\n                rule += \" range %s %s\" % (min_port, max_port)\n            elif min_port and not max_port:\n                rule += \" eq %s\" % min_port\n        return rule"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nformats list of rules for EOS and sort into ingress and egress rules", "response": "def _format_rules_for_eos(self, rules):\n        \"\"\"Format list of rules for EOS and sort into ingress/egress rules\"\"\"\n        in_rules = []\n        eg_rules = []\n        for rule in rules:\n            protocol = rule.get('protocol')\n            cidr = rule.get('remote_ip_prefix', 'any')\n            min_port = rule.get('port_range_min')\n            max_port = rule.get('port_range_max')\n            direction = rule.get('direction')\n            ethertype = rule.get('ethertype')\n            if not self._supported_rule(protocol, ethertype):\n                continue\n            formatted_rule = self._format_rule(protocol, cidr, min_port,\n                                               max_port, direction)\n            if rule['direction'] == n_const.INGRESS_DIRECTION:\n                in_rules.append(formatted_rule)\n            elif rule['direction'] == n_const.EGRESS_DIRECTION:\n                eg_rules.append(formatted_rule)\n        return in_rules, eg_rules"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nrun all cmds on all configured switches", "response": "def run_cmds_on_all_switches(self, cmds):\n        \"\"\"Runs all cmds on all configured switches\n\n        This helper is used for ACL and rule creation/deletion as ACLs\n        and rules must exist on all switches.\n        \"\"\"\n        for switch in self._switches.values():\n            self.run_openstack_sg_cmds(cmds, switch)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef run_per_switch_cmds(self, switch_cmds):\n        for switch_ip, cmds in switch_cmds.items():\n            switch = self._switches.get(switch_ip)\n            self.run_openstack_sg_cmds(cmds, switch)", "response": "Applies cmds to appropriate switches\n        This will run only the set of cmds that are specified for a switch on that switch."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _get_switches(self, profile):\n        switchports = self._get_switchports(profile)\n        switches = set([switchport[0] for switchport in switchports])\n        return switches", "response": "Get set of switches referenced in a port binding profile"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_create_security_group_commands(self, sg_id, sg_rules):\n        cmds = []\n        in_rules, eg_rules = self._format_rules_for_eos(sg_rules)\n        cmds.append(\"ip access-list %s dynamic\" %\n                    self._acl_name(sg_id, n_const.INGRESS_DIRECTION))\n        for in_rule in in_rules:\n            cmds.append(in_rule)\n        cmds.append(\"exit\")\n        cmds.append(\"ip access-list %s dynamic\" %\n                    self._acl_name(sg_id, n_const.EGRESS_DIRECTION))\n        for eg_rule in eg_rules:\n            cmds.append(eg_rule)\n        cmds.append(\"exit\")\n        return cmds", "response": "Returns the list of commands to create a security group."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the list of commands to delete a security group", "response": "def get_delete_security_group_commands(self, sg_id):\n        \"\"\"Commands for deleting ACL\"\"\"\n        cmds = []\n        cmds.append(\"no ip access-list %s\" %\n                    self._acl_name(sg_id, n_const.INGRESS_DIRECTION))\n        cmds.append(\"no ip access-list %s\" %\n                    self._acl_name(sg_id, n_const.EGRESS_DIRECTION))\n        return cmds"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_delete_security_group_rule_commands(self, sg_id, sg_rule):\n        return self._get_rule_cmds(sg_id, sg_rule, delete=True)", "response": "Returns the list of commands to remove a rule from an existing security group"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _get_interface_commands(self, sg_id, profile, delete=False):\n        rule_prefix = \"\"\n        if delete:\n            rule_prefix = \"no \"\n        switch_cmds = {}\n        switchports = self._get_switchports(profile)\n        for switch_ip, intf in switchports:\n            cmds = []\n            intf_id = self._get_port_for_acl(intf, switch_ip)\n            cmds.append(\"interface %s\" % intf_id)\n            name = self._acl_name(sg_id, n_const.INGRESS_DIRECTION)\n            cmds.append(rule_prefix + \"ip access-group %s %s\" %\n                        (name, a_const.INGRESS_DIRECTION))\n            name = self._acl_name(sg_id, n_const.EGRESS_DIRECTION)\n            cmds.append(rule_prefix + \"ip access-group %s %s\" %\n                        (name, a_const.EGRESS_DIRECTION))\n            cmds.append(\"exit\")\n            if switch_ip not in switch_cmds.keys():\n                switch_cmds[switch_ip] = []\n            switch_cmds[switch_ip].extend(cmds)\n        return switch_cmds", "response": "Helper method for getting the list of commands for an interface ACL apply or remove."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_remove_security_group_commands(self, sg_id, profile):\n        return self._get_interface_commands(sg_id, profile, delete=True)", "response": "Returns the list of commands to remove ACL from interface"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _parse_acl_config(self, acl_config):\n        parsed_acls = dict()\n        for acl in acl_config['aclList']:\n            parsed_acls[acl['name']] = set()\n            for rule in acl['sequence']:\n                parsed_acls[acl['name']].add(rule['text'])\n        return parsed_acls", "response": "Parse the ACLs and rules\n        and return a dict of rule sets."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _parse_binding_config(self, binding_config):\n        parsed_bindings = set()\n        for acl in binding_config['aclList']:\n            for intf in acl['configuredIngressIntfs']:\n                parsed_bindings.add((intf['name'], acl['name'],\n                                     a_const.INGRESS_DIRECTION))\n            for intf in acl['configuredEgressIntfs']:\n                parsed_bindings.add((intf['name'], acl['name'],\n                                     a_const.EGRESS_DIRECTION))\n        return parsed_bindings", "response": "Parse the config file for the ACL bindings."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nretrieve ACLs rules and interface bindings from switch", "response": "def _get_dynamic_acl_info(self, switch_ip):\n        \"\"\"Retrieve ACLs, ACLs rules and interface bindings from switch\"\"\"\n        cmds = [\"enable\",\n                \"show ip access-lists dynamic\",\n                \"show ip access-lists summary dynamic\"]\n        switch = self._switches.get(switch_ip)\n\n        _, acls, bindings = self._run_eos_cmds(cmds, switch)\n\n        parsed_acls = self._parse_acl_config(acls)\n        parsed_bindings = self._parse_binding_config(bindings)\n\n        return parsed_acls, parsed_bindings"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nquerying the neutron DB for the expected ACLs.", "response": "def get_expected_acls(self):\n        \"\"\"Query the neutron DB for Security Groups and Rules\n\n        Groups and rules are returned as a dict of rule sets:\n        {<eos_acl1_name>: set([<eos_acl1_rules>]),\n         <eos_acl2_name>: set([<eos_acl2_rules>]),\n         ...,\n        }\n        \"\"\"\n        security_groups = db_lib.get_security_groups()\n\n        expected_acls = collections.defaultdict(set)\n        for sg in security_groups:\n            in_rules, out_rules = self._format_rules_for_eos(sg['rules'])\n            ingress_acl_name = self._acl_name(sg['id'],\n                                              n_const.INGRESS_DIRECTION)\n            egress_acl_name = self._acl_name(sg['id'],\n                                             n_const.EGRESS_DIRECTION)\n            expected_acls[ingress_acl_name].update(in_rules)\n            expected_acls[egress_acl_name].update(out_rules)\n        return expected_acls"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nqueries the neutron DB for SG - > switch interface bindings and return a dict of expected bindings for each switch.", "response": "def get_expected_bindings(self):\n        \"\"\"Query the neutron DB for SG->switch interface bindings\n\n        Bindings are returned as a dict of bindings for each switch:\n        {<switch1>: set([(intf1, acl_name, direction),\n                         (intf2, acl_name, direction)]),\n         <switch2>: set([(intf1, acl_name, direction)]),\n         ...,\n        }\n        \"\"\"\n        sg_bindings = db_lib.get_baremetal_sg_bindings()\n\n        all_expected_bindings = collections.defaultdict(set)\n        for sg_binding, port_binding in sg_bindings:\n            sg_id = sg_binding['security_group_id']\n            try:\n                binding_profile = json.loads(port_binding.profile)\n            except ValueError:\n                binding_profile = {}\n            switchports = self._get_switchports(binding_profile)\n            for switch, intf in switchports:\n                ingress_name = self._acl_name(sg_id, n_const.INGRESS_DIRECTION)\n                egress_name = self._acl_name(sg_id, n_const.EGRESS_DIRECTION)\n                all_expected_bindings[switch].add(\n                    (intf, ingress_name, a_const.INGRESS_DIRECTION))\n                all_expected_bindings[switch].add(\n                    (intf, egress_name, a_const.EGRESS_DIRECTION))\n        return all_expected_bindings"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadjusting interface names for expected bindings where LAGs exist", "response": "def adjust_bindings_for_lag(self, switch_ip, bindings):\n        \"\"\"Adjusting interface names for expected bindings where LAGs exist\"\"\"\n\n        # Get latest LAG info for switch\n        self._update_port_group_info([switch_ip])\n\n        # Update bindings to account for LAG info\n        adjusted_bindings = set()\n        for binding in bindings:\n            adjusted_bindings.add(\n                (self._get_port_for_acl(binding[0], switch_ip),) + binding[1:])\n        return adjusted_bindings"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the list of commands required synchronize switch ACLs and expected ACLs and switch rules.", "response": "def get_sync_acl_cmds(self, switch_acls, expected_acls):\n        \"\"\"Returns the list of commands required synchronize switch ACLs\n\n        1. Identify unexpected ACLs and delete them\n        2. Iterate over expected ACLs\n           a. Add missing ACLs + all rules\n           b. Delete unexpected rules\n           c. Add missing rules\n        \"\"\"\n        switch_cmds = list()\n\n        # Delete any stale ACLs\n        acls_to_delete = (set(switch_acls.keys()) - set(expected_acls.keys()))\n        for acl in acls_to_delete:\n            switch_cmds.append('no ip access-list %s' % acl)\n\n        # Update or create ACLs and rules\n        for acl, expected_rules in expected_acls.items():\n            switch_rules = switch_acls.get(acl, set())\n            rules_to_delete = switch_rules - expected_rules\n            rules_to_add = expected_rules - switch_rules\n            # Check if ACL requires create or rule changes\n            if (acl in switch_acls and\n                    len(rules_to_add | rules_to_delete) == 0):\n                continue\n            switch_cmds.append('ip access-list %s dynamic' % acl)\n            # Delete any stale rules\n            for rule in rules_to_delete:\n                switch_cmds.append('no ' + rule)\n            # Add any missing rules\n            for rule in rules_to_add:\n                switch_cmds.append(rule)\n                switch_cmds.append('exit')\n        return switch_cmds"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the list of commands required to synchronize the ACL bindings with the expected bindings.", "response": "def get_sync_binding_cmds(self, switch_bindings, expected_bindings):\n        \"\"\"Returns the list of commands required to synchronize ACL bindings\n\n        1. Delete any unexpected bindings\n        2. Add any missing bindings\n        \"\"\"\n        switch_cmds = list()\n\n        # Update any necessary switch interface ACLs\n        bindings_to_delete = switch_bindings - expected_bindings\n        bindings_to_add = expected_bindings - switch_bindings\n        for intf, acl, direction in bindings_to_delete:\n            switch_cmds.extend(['interface %s' % intf,\n                                'no ip access-group %s %s' %\n                                (acl, direction),\n                                'exit'])\n        for intf, acl, direction in bindings_to_add:\n            switch_cmds.extend(['interface %s' % intf,\n                                'ip access-group %s %s' % (acl, direction),\n                                'exit'])\n        return switch_cmds"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nflattens a DataFrame of instrument weights into a long DataFrame.", "response": "def flatten(weights):\n    \"\"\"\n    Flatten weights into a long DataFrame.\n\n    Parameters\n    ----------\n    weights: pandas.DataFrame or dict\n        A DataFrame of instrument weights with a MultiIndex where the top level\n        contains pandas. Timestamps and the second level is instrument names.\n        The columns consist of generic names. If dict is given this should be\n        a dict of pandas.DataFrame in the above format, with keys for different\n        root generics, e.g. 'CL'\n\n    Returns\n    -------\n    A long DataFrame of weights, where columns are \"date\", \"contract\",\n    \"generic\" and \"weight\". If a dictionary is passed, DataFrame will contain\n    additional colum \"key\" containing the key value and be sorted according to\n    this key value.\n\n    Example\n    -------\n    >>> import pandas as pd\n    >>> import mapping.util as util\n    >>> vals = [[1, 0], [0, 1], [1, 0], [0, 1]]\n    >>> widx = pd.MultiIndex.from_tuples([(pd.Timestamp('2015-01-03'), 'CLF5'),\n    ...                                   (pd.Timestamp('2015-01-03'), 'CLG5'),\n    ...                                   (pd.Timestamp('2015-01-04'), 'CLG5'),\n    ...                                   (pd.Timestamp('2015-01-04'), 'CLH5')])\n    >>> weights = pd.DataFrame(vals, index=widx, columns=[\"CL1\", \"CL2\"])\n    >>> util.flatten(weights)\n    \"\"\"  # NOQA\n    if isinstance(weights, pd.DataFrame):\n        wts = weights.stack().reset_index()\n        wts.columns = [\"date\", \"contract\", \"generic\", \"weight\"]\n    elif isinstance(weights, dict):\n        wts = []\n        for key in sorted(weights.keys()):\n            wt = weights[key].stack().reset_index()\n            wt.columns = [\"date\", \"contract\", \"generic\", \"weight\"]\n            wt.loc[:, \"key\"] = key\n            wts.append(wt)\n        wts = pd.concat(wts, axis=0).reset_index(drop=True)\n    else:\n        raise ValueError(\"weights must be pd.DataFrame or dict\")\n\n    return wts"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef unflatten(flat_weights):\n    if flat_weights.columns.contains(\"key\"):\n        weights = {}\n        for key in flat_weights.loc[:, \"key\"].unique():\n            flt_wts = flat_weights.loc[flat_weights.loc[:, \"key\"] == key, :]\n            flt_wts = flt_wts.drop(labels=\"key\", axis=1)\n            wts = flt_wts.pivot_table(index=[\"date\", \"contract\"],\n                                      columns=[\"generic\"],\n                                      values=[\"weight\"])\n            wts.columns = wts.columns.droplevel(0)\n            weights[key] = wts\n    else:\n        weights = flat_weights.pivot_table(index=[\"date\", \"contract\"],\n                                           columns=[\"generic\"],\n                                           values=[\"weight\"])\n        weights.columns = weights.columns.droplevel(0)\n\n    return weights", "response": "Unflattens a single - level dataframe into a single - level DataFrame."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef calc_rets(returns, weights):\n\n    if not isinstance(returns, dict):\n        returns = {\"\": returns}\n    if not isinstance(weights, dict):\n        weights = {\"\": weights}\n\n    generic_superset = []\n    for root in weights:\n        generic_superset.extend(weights[root].columns.tolist())\n    if len(set(generic_superset)) != len(generic_superset):\n        raise ValueError(\"Columns for weights must all be unique\")\n\n    _check_indices(returns, weights)\n\n    grets = []\n    cols = []\n    for root in returns:\n        root_wts = weights[root]\n        root_rets = returns[root]\n        for generic in root_wts.columns:\n            gnrc_wts = root_wts.loc[:, generic]\n            # drop generics where weight is 0, this avoids potential KeyError\n            # in later indexing of rets even when ret has weight of 0\n            gnrc_wts = gnrc_wts.loc[gnrc_wts != 0]\n            rets = root_rets.loc[gnrc_wts.index]\n            # groupby time\n            group_rets = (rets * gnrc_wts).groupby(level=0)\n            grets.append(group_rets.apply(pd.DataFrame.sum, skipna=False))\n        cols.extend(root_wts.columns.tolist())\n\n    rets = pd.concat(grets, axis=1, keys=cols).sort_index(axis=1)\n    return rets", "response": "Calculates continuous return series for futures instruments."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef reindex(prices, index, limit):\n    if not index.is_unique:\n        raise ValueError(\"'index' must be unique\")\n\n    index = index.sort_values()\n    index.names = [\"date\", \"instrument\"]\n    price_dts = prices.sort_index().index.unique(level=0)\n    index_dts = index.unique(level=0)\n\n    mask = price_dts < index_dts[0]\n    leading_price_dts = price_dts[mask]\n    if len(leading_price_dts) == 0:\n        raise ValueError(\"'prices' must have a date preceding first date in \"\n                         \"'index'\")\n    prev_dts = index_dts.tolist()\n    prev_dts.insert(0, leading_price_dts[-1])\n    # avoid just lagging to preserve the calendar\n    previous_date = dict(zip(index_dts, prev_dts))\n\n    first_instr = index.to_frame(index=False)\n    first_instr = (\n        first_instr.drop_duplicates(subset=[\"instrument\"], keep=\"first\")\n    )\n    first_instr.loc[:, \"prev_date\"] = (\n        first_instr.loc[:, \"date\"].apply(lambda x: previous_date[x])\n    )\n    additional_indices = pd.MultiIndex.from_tuples(\n        first_instr.loc[:, [\"prev_date\", \"instrument\"]].values.tolist()\n    )\n\n    augmented_index = index.union(additional_indices).sort_values()\n    prices = prices.reindex(augmented_index)\n    if limit != 0:\n        prices = prices.groupby(level=1).fillna(method=\"ffill\", limit=limit)\n    return prices", "response": "Reindex a Series of prices with a pd. MultiIndex of instrument weights and fill forward missing values with previous price up to limit."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncalculating the number of tradeable contracts for rebalancing from a set of current and desired generic notional holdings.", "response": "def calc_trades(current_contracts, desired_holdings, trade_weights, prices,\n                multipliers, **kwargs):\n    \"\"\"\n    Calculate the number of tradeable contracts for rebalancing from a set\n    of current contract holdings to a set of desired generic notional holdings\n    based on prevailing prices and mapping from generics to tradeable\n    instruments. Differences between current holdings and desired holdings\n    are treated as 0. Zero trades are dropped.\n\n    Parameters\n    ----------\n    current_contracts: pandas.Series\n        Series of current number of contracts held for tradeable instruments.\n        Can pass 0 if all holdings are 0.\n    desired_holdings: pandas.Series\n        Series of desired holdings in base notional currency of generics. Index\n        is generic contracts, these should be the same generics as in\n        trade_weights.\n    trade_weights: pandas.DataFrame or dict\n        A pandas.DataFrame of loadings of generic contracts on tradeable\n        instruments **for a given date**. The columns refer to generic\n        contracts and the index is strings representing instrument names.\n        If dict is given keys should be root generic names, e.g. 'CL', and\n        values should be pandas.DataFrames of loadings. The union of all\n        columns should be a superset of the desired_holdings.index\n    prices: pandas.Series\n        Series of instrument prices. Index is instrument name and values are\n        number of contracts. Extra instrument prices will be ignored.\n    multipliers: pandas.Series\n        Series of instrument multipliers. Index is instrument name and\n        values are the multiplier associated with the contract.\n        multipliers.index should be a superset of mapped desired_holdings\n        intruments.\n    kwargs: key word arguments\n        Key word arguments to be passed to to_contracts()\n\n    Returns\n    -------\n    A pandas.Series of instrument contract trades, lexigraphically sorted.\n\n    Example\n    -------\n    >>> import pandas as pd\n    >>> import mapping.util as util\n    >>> wts = pd.DataFrame([[0.5, 0], [0.5, 0.5], [0, 0.5]],\n    ...                    index=[\"CLX16\", \"CLZ16\", \"CLF17\"],\n    ...                    columns=[\"CL1\", \"CL2\"])\n    >>> desired_holdings = pd.Series([200000, -50000], index=[\"CL1\", \"CL2\"])\n    >>> current_contracts = pd.Series([0, 1, 0],\n    ...                               index=['CLX16', 'CLZ16', 'CLF17'])\n    >>> prices = pd.Series([50.32, 50.41, 50.48],\n    ...                    index=['CLX16', 'CLZ16', 'CLF17'])\n    >>> multipliers = pd.Series([100, 100, 100],\n    ...                        index=['CLX16', 'CLZ16', 'CLF17'])\n    >>> trades = util.calc_trades(current_contracts, desired_holdings, wts,\n    ...                           prices, multipliers)\n    \"\"\"\n    if not isinstance(trade_weights, dict):\n        trade_weights = {\"\": trade_weights}\n\n    generics = []\n    for key in trade_weights:\n        generics.extend(trade_weights[key].columns)\n\n    if not set(desired_holdings.index).issubset(set(generics)):\n        raise ValueError(\"'desired_holdings.index' contains values which \"\n                         \"cannot be mapped to tradeables.\\n\"\n                         \"Received: 'desired_holdings.index'\\n {0}\\n\"\n                         \"Expected in 'trade_weights' set of columns:\\n {1}\\n\"\n                         .format(sorted(desired_holdings.index),\n                                 sorted(generics)))\n\n    desired_contracts = []\n    for root_key in trade_weights:\n        gnrc_weights = trade_weights[root_key]\n\n        subset = gnrc_weights.columns.intersection(desired_holdings.index)\n        gnrc_des_hlds = desired_holdings.loc[subset]\n        gnrc_weights = gnrc_weights.loc[:, subset]\n        # drop indexes where all non zero weights were in columns dropped above\n        gnrc_weights = gnrc_weights.loc[~(gnrc_weights == 0).all(axis=1)]\n\n        instr_des_hlds = gnrc_des_hlds * gnrc_weights\n        instr_des_hlds = instr_des_hlds.sum(axis=1)\n        wprices = prices.loc[instr_des_hlds.index]\n        desired_contracts.append(to_contracts(instr_des_hlds, wprices,\n                                              multipliers, **kwargs))\n\n    desired_contracts = pd.concat(desired_contracts, axis=0)\n\n    trades = desired_contracts.subtract(current_contracts, fill_value=0)\n    trades = trades.loc[trades != 0]\n    trades = trades.sort_index()\n    return trades"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef to_notional(instruments, prices, multipliers, desired_ccy=None,\n                instr_fx=None, fx_rates=None):\n    \"\"\"\n    Convert number of contracts of tradeable instruments to notional value of\n    tradeable instruments in a desired currency.\n\n    Parameters\n    ----------\n    instruments: pandas.Series\n        Series of instrument holdings. Index is instrument name and values are\n        number of contracts.\n    prices: pandas.Series\n        Series of instrument prices. Index is instrument name and values are\n        instrument prices. prices.index should be a superset of\n        instruments.index otherwise NaN returned for instruments without prices\n    multipliers: pandas.Series\n        Series of instrument multipliers. Index is instrument name and\n        values are the multiplier associated with the contract.\n        multipliers.index should be a superset of instruments.index\n    desired_ccy: str\n        Three letter string representing desired currency to convert notional\n        values to, e.g. 'USD'. If None is given currency conversion is ignored.\n    instr_fx: pandas.Series\n        Series of instrument fx denominations. Index is instrument name and\n        values are three letter strings representing the currency the\n        instrument is denominated in. instr_fx.index should match prices.index\n    fx_rates: pandas.Series\n        Series of fx rates used for conversion to desired_ccy. Index is strings\n        representing the FX pair, e.g. 'AUDUSD' or 'USDCAD'. Values are the\n        corresponding exchange rates.\n\n    Returns\n    -------\n    pandas.Series of notional amounts of instruments with Index of instruments\n    names\n\n    Example\n    -------\n    >>> import pandas as pd\n    >>> import mapping.util as util\n    >>> current_contracts = pd.Series([-1, 1], index=['CLX16', 'CLZ16'])\n    >>> prices = pd.Series([50.32, 50.41], index=['CLX16', 'CLZ16'])\n    >>> multipliers = pd.Series([100, 100], index=['CLX16', 'CLZ16'])\n    >>> ntln = util.to_notional(current_contracts, prices, multipliers)\n    \"\"\"\n    notionals = _instr_conv(instruments, prices, multipliers, True,\n                            desired_ccy, instr_fx, fx_rates)\n    return notionals", "response": "Convert number of contracts prices multipliers and fx rates to a notional value of the current tradeable instruments."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nconvert notional amount of tradeable instruments to number of instrument contracts.", "response": "def to_contracts(instruments, prices, multipliers, desired_ccy=None,\n                 instr_fx=None, fx_rates=None, rounder=None):\n    \"\"\"\n    Convert notional amount of tradeable instruments to number of instrument\n    contracts, rounding to nearest integer number of contracts.\n\n    Parameters\n    ----------\n    instruments: pandas.Series\n        Series of instrument holdings. Index is instrument name and values are\n        notional amount on instrument.\n    prices: pandas.Series\n        Series of instrument prices. Index is instrument name and values are\n        instrument prices. prices.index should be a superset of\n        instruments.index\n    multipliers: pandas.Series\n        Series of instrument multipliers. Index is instrument name and\n        values are the multiplier associated with the contract.\n        multipliers.index should be a superset of instruments.index\n    desired_ccy: str\n        Three letter string representing desired currency to convert notional\n        values to, e.g. 'USD'. If None is given currency conversion is ignored.\n    instr_fx: pandas.Series\n        Series of instrument fx denominations. Index is instrument name and\n        values are three letter strings representing the currency the\n        instrument is denominated in. instr_fx.index should match prices.index\n    fx_rates: pandas.Series\n        Series of fx rates used for conversion to desired_ccy. Index is strings\n        representing the FX pair, e.g. 'AUDUSD' or 'USDCAD'. Values are the\n        corresponding exchange rates.\n    rounder: function\n        Function to round pd.Series contracts to integers, if None default\n        pd.Series.round is used.\n\n    Returns\n    -------\n    pandas.Series of contract numbers of instruments with Index of instruments\n    names\n    \"\"\"\n    contracts = _instr_conv(instruments, prices, multipliers, False,\n                            desired_ccy, instr_fx, fx_rates)\n    if rounder is None:\n        rounder = pd.Series.round\n\n    contracts = rounder(contracts)\n    contracts = contracts.astype(int)\n    return contracts"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ndetermine tradeable instrument multiplier based on generic asset multipliers and weights mapping from generics to tradeables. Parameters ---------- weights: pandas.DataFrame or dict A pandas.DataFrame of loadings of generic contracts on tradeable instruments **for a given date**. The columns are integers refering to generic number indexed from 0, e.g. [0, 1], and the index is strings representing instrument names. If dict is given keys should be generic instrument names, e.g. 'CL', and values should be pandas.DataFrames of loadings. The union of all indexes should be a superset of the instruments.index root_generic_multiplier: pandas.Series Series of multipliers for generic instruments lexigraphically sorted. If a dictionary of weights is given, root_generic_multiplier.index should correspond to the weights keys. Returns ------- A pandas.Series of multipliers for tradeable instruments. Examples -------- >>> import pandas as pd >>> import mapping.util as util >>> wts = pd.DataFrame([[0.5, 0], [0.5, 0.5], [0, 0.5]], ... index=[\"CLX16\", \"CLZ16\", \"CLF17\"], ... columns=[0, 1]) >>> ast_mult = pd.Series([1000], index=[\"CL\"]) >>> util.get_multiplier(wts, ast_mult)", "response": "def get_multiplier(weights, root_generic_multiplier):\n    \"\"\"\n    Determine tradeable instrument multiplier based on generic asset\n    multipliers and weights mapping from generics to tradeables.\n\n    Parameters\n    ----------\n    weights: pandas.DataFrame or dict\n        A pandas.DataFrame of loadings of generic contracts on tradeable\n        instruments **for a given date**. The columns are integers refering to\n        generic number indexed from 0, e.g. [0, 1], and the index is strings\n        representing instrument names. If dict is given keys should be generic\n        instrument names, e.g. 'CL', and values should be pandas.DataFrames of\n        loadings. The union of all indexes should be a superset of the\n        instruments.index\n    root_generic_multiplier: pandas.Series\n        Series of multipliers for generic instruments lexigraphically sorted.\n        If a dictionary of weights is given, root_generic_multiplier.index\n        should correspond to the weights keys.\n\n    Returns\n    -------\n    A pandas.Series of multipliers for tradeable instruments.\n\n    Examples\n    --------\n    >>> import pandas as pd\n    >>> import mapping.util as util\n    >>> wts = pd.DataFrame([[0.5, 0], [0.5, 0.5], [0, 0.5]],\n    ...                    index=[\"CLX16\", \"CLZ16\", \"CLF17\"],\n    ...                    columns=[0, 1])\n    >>> ast_mult = pd.Series([1000], index=[\"CL\"])\n    >>> util.get_multiplier(wts, ast_mult)\n    \"\"\"\n    if len(root_generic_multiplier) > 1 and not isinstance(weights, dict):\n        raise ValueError(\"For multiple generic instruments weights must be a \"\n                         \"dictionary\")\n\n    mults = []\n    intrs = []\n    for ast, multiplier in root_generic_multiplier.iteritems():\n        if isinstance(weights, dict):\n            weights_ast = weights[ast].index\n        else:\n            weights_ast = weights.index\n        mults.extend(np.repeat(multiplier, len(weights_ast)))\n        intrs.extend(weights_ast)\n\n    imults = pd.Series(mults, intrs)\n    imults = imults.sort_index()\n    return imults"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef weighted_expiration(weights, contract_dates):\n    cols = weights.columns\n    weights = weights.reset_index(level=-1)\n    expiries = contract_dates.to_dict()\n    weights.loc[:, \"expiry\"] = weights.iloc[:, 0].apply(lambda x: expiries[x])\n    diffs = (pd.DatetimeIndex(weights.expiry)\n             - pd.Series(weights.index, weights.index)).apply(lambda x: x.days)\n    weights = weights.loc[:, cols]\n    wexp = weights.mul(diffs, axis=0).groupby(level=0).sum()\n    return wexp", "response": "Calculates the days to expiration for a single resource item."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _valid_baremetal_port(port):\n        if port.get(portbindings.VNIC_TYPE) != portbindings.VNIC_BAREMETAL:\n            return False\n        sgs = port.get('security_groups', [])\n        if len(sgs) == 0:\n            # Nothing to do\n            return False\n        if len(port.get('security_groups', [])) > 1:\n            LOG.warning('SG provisioning failed for %(port)s. Only one '\n                        'SG may be applied per port.',\n                        {'port': port['id']})\n            return False\n        return True", "response": "Check if the port is a baremetal port with exactly one security group."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef synchronize_resources(self):\n        # Grab the sync lock\n        if not self._rpc.sync_start():\n            LOG.info(\"%(pid)s Failed to grab the sync lock\",\n                     {'pid': os.getpid()})\n            greenthread.sleep(1)\n            return\n\n        for resource in self._resources_to_update:\n            self.update_neutron_resource(resource)\n        self._resources_to_update = list()\n\n        # Sync any necessary resources.\n        # We delete in reverse order and create in order to ensure that\n        # dependent resources  are deleted before the resources they depend\n        # on and created after them\n        for resource_type in reversed(self.sync_order):\n            resource_type.delete_cvx_resources()\n        for resource_type in self.sync_order:\n            resource_type.create_cvx_resources()\n\n        # Release the sync lock\n        self._rpc.sync_end()\n\n        # Update local uuid if this was a full sync\n        if self._synchronizing_uuid:\n            LOG.info(\"%(pid)s Full sync for cvx uuid %(uuid)s complete\",\n                     {'uuid': self._synchronizing_uuid,\n                      'pid': os.getpid()})\n            self._cvx_uuid = self._synchronizing_uuid\n            self._synchronizing_uuid = None", "response": "Synchronize with CVX and update the internal state of all resources."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef register(self, resource, event, trigger, **kwargs):\n        super(AristaTrunkDriver, self).register(resource, event,\n                                                trigger, kwargs)\n        registry.subscribe(self.subport_create,\n                           resources.SUBPORTS, events.AFTER_CREATE)\n        registry.subscribe(self.subport_delete,\n                           resources.SUBPORTS, events.AFTER_DELETE)\n        registry.subscribe(self.trunk_create,\n                           resources.TRUNK, events.AFTER_CREATE)\n        registry.subscribe(self.trunk_update,\n                           resources.TRUNK, events.AFTER_UPDATE)\n        registry.subscribe(self.trunk_delete,\n                           resources.TRUNK, events.AFTER_DELETE)\n        self.core_plugin = directory.get_plugin()\n        LOG.debug(\"Arista trunk driver initialized.\")", "response": "Called in trunk plugin s AFTER_INIT method"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates a router on Arista HW Device.", "response": "def create_router_on_eos(self, router_name, rdm, server):\n        \"\"\"Creates a router on Arista HW Device.\n\n        :param router_name: globally unique identifier for router/VRF\n        :param rdm: A value generated by hashing router name\n        :param server: Server endpoint on the Arista switch to be configured\n        \"\"\"\n        cmds = []\n        rd = \"%s:%s\" % (rdm, rdm)\n\n        for c in self.routerDict['create']:\n            cmds.append(c.format(router_name, rd))\n\n        if self._mlag_configured:\n            mac = VIRTUAL_ROUTER_MAC\n            for c in self._additionalRouterCmdsDict['create']:\n                cmds.append(c.format(mac))\n\n        self._run_config_cmds(cmds, server)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef delete_router_from_eos(self, router_name, server):\n        cmds = []\n        for c in self.routerDict['delete']:\n            cmds.append(c.format(router_name))\n        if self._mlag_configured:\n            for c in self._additionalRouterCmdsDict['delete']:\n                cmds.append(c)\n\n        self._run_config_cmds(cmds, server)", "response": "Deletes a router from Arista HW Device."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef add_interface_to_router(self, segment_id,\n                                router_name, gip, router_ip, mask, server):\n        \"\"\"Adds an interface to existing HW router on Arista HW device.\n\n        :param segment_id: VLAN Id associated with interface that is added\n        :param router_name: globally unique identifier for router/VRF\n        :param gip: Gateway IP associated with the subnet\n        :param router_ip: IP address of the router\n        :param mask: subnet mask to be used\n        :param server: Server endpoint on the Arista switch to be configured\n        \"\"\"\n\n        if not segment_id:\n            segment_id = DEFAULT_VLAN\n        cmds = []\n        for c in self._interfaceDict['add']:\n            if self._mlag_configured:\n                # In VARP config, use router ID else, use gateway IP address.\n                ip = router_ip\n            else:\n                ip = gip + '/' + mask\n            cmds.append(c.format(segment_id, router_name, ip))\n        if self._mlag_configured:\n            for c in self._additionalInterfaceCmdsDict['add']:\n                cmds.append(c.format(gip))\n\n        self._run_config_cmds(cmds, server)", "response": "Adds an interface to existing HW router on Arista HW device."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ndeleting an interface from existing HW router on Arista HW device.", "response": "def delete_interface_from_router(self, segment_id, router_name, server):\n        \"\"\"Deletes an interface from existing HW router on Arista HW device.\n\n        :param segment_id: VLAN Id associated with interface that is added\n        :param router_name: globally unique identifier for router/VRF\n        :param server: Server endpoint on the Arista switch to be configured\n        \"\"\"\n\n        if not segment_id:\n            segment_id = DEFAULT_VLAN\n        cmds = []\n        for c in self._interfaceDict['remove']:\n            cmds.append(c.format(segment_id))\n\n        self._run_config_cmds(cmds, server)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef create_router(self, context, router):\n        if router:\n            router_name = self._arista_router_name(router['id'],\n                                                   router['name'])\n\n            hashed = hashlib.sha256(router_name.encode('utf-8'))\n            rdm = str(int(hashed.hexdigest(), 16) % 65536)\n\n            mlag_peer_failed = False\n            for s in self._servers:\n                try:\n                    self.create_router_on_eos(router_name, rdm, s)\n                    mlag_peer_failed = False\n                except Exception:\n                    if self._mlag_configured and not mlag_peer_failed:\n                        # In paied switch, it is OK to fail on one switch\n                        mlag_peer_failed = True\n                    else:\n                        msg = (_('Failed to create router %s on EOS') %\n                               router_name)\n                        LOG.exception(msg)\n                        raise arista_exc.AristaServicePluginRpcError(msg=msg)", "response": "Creates a router on Arista Switch."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ndeletes a router from Arista Switch.", "response": "def delete_router(self, context, router_id, router):\n        \"\"\"Deletes a router from Arista Switch.\"\"\"\n\n        if router:\n            router_name = self._arista_router_name(router_id, router['name'])\n            mlag_peer_failed = False\n            for s in self._servers:\n                try:\n                    self.delete_router_from_eos(router_name, s)\n                    mlag_peer_failed = False\n                except Exception:\n                    if self._mlag_configured and not mlag_peer_failed:\n                        # In paied switch, it is OK to fail on one switch\n                        mlag_peer_failed = True\n                    else:\n                        msg = (_('Failed to create router %s on EOS') %\n                               router_name)\n                        LOG.exception(msg)\n                        raise arista_exc.AristaServicePluginRpcError(msg=msg)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nadd an interface to a router.", "response": "def add_router_interface(self, context, router_info):\n        \"\"\"Adds an interface to a router created on Arista HW router.\n\n        This deals with both IPv6 and IPv4 configurations.\n        \"\"\"\n        if router_info:\n            self._select_dicts(router_info['ip_version'])\n            cidr = router_info['cidr']\n            subnet_mask = cidr.split('/')[1]\n            router_name = self._arista_router_name(router_info['id'],\n                                                   router_info['name'])\n            if self._mlag_configured:\n                # For MLAG, we send a specific IP address as opposed to cidr\n                # For now, we are using x.x.x.253 and x.x.x.254 as virtual IP\n                mlag_peer_failed = False\n                for i, server in enumerate(self._servers):\n                    # Get appropriate virtual IP address for this router\n                    router_ip = self._get_router_ip(cidr, i,\n                                                    router_info['ip_version'])\n                    try:\n                        self.add_interface_to_router(router_info['seg_id'],\n                                                     router_name,\n                                                     router_info['gip'],\n                                                     router_ip, subnet_mask,\n                                                     server)\n                        mlag_peer_failed = False\n                    except Exception:\n                        if not mlag_peer_failed:\n                            mlag_peer_failed = True\n                        else:\n                            msg = (_('Failed to add interface to router '\n                                     '%s on EOS') % router_name)\n                            LOG.exception(msg)\n                            raise arista_exc.AristaServicePluginRpcError(\n                                msg=msg)\n\n            else:\n                for s in self._servers:\n                    self.add_interface_to_router(router_info['seg_id'],\n                                                 router_name,\n                                                 router_info['gip'],\n                                                 None, subnet_mask, s)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef remove_router_interface(self, context, router_info):\n        if router_info:\n            router_name = self._arista_router_name(router_info['id'],\n                                                   router_info['name'])\n            mlag_peer_failed = False\n            for s in self._servers:\n                try:\n                    self.delete_interface_from_router(router_info['seg_id'],\n                                                      router_name, s)\n                    if self._mlag_configured:\n                        mlag_peer_failed = False\n                except Exception:\n                    if self._mlag_configured and not mlag_peer_failed:\n                        mlag_peer_failed = True\n                    else:\n                        msg = (_('Failed to add interface to router '\n                                 '%s on EOS') % router_name)\n                        LOG.exception(msg)\n                        raise arista_exc.AristaServicePluginRpcError(msg=msg)", "response": "Removes previously configured router interface from Arista HW."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nexecuting a list of commands on Arista switch and send them to the Arista switch", "response": "def _run_config_cmds(self, commands, server):\n        \"\"\"Execute/sends a CAPI (Command API) command to EOS.\n\n        In this method, list of commands is appended with prefix and\n        postfix commands - to make is understandble by EOS.\n\n        :param commands : List of command to be executed on EOS.\n        :param server: Server endpoint on the Arista switch to be configured\n        \"\"\"\n        command_start = ['enable', 'configure']\n        command_end = ['exit']\n        full_command = command_start + commands + command_end\n        self._run_eos_cmds(full_command, server)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _get_binary_from_ipv4(self, ip_addr):\n\n        return struct.unpack(\"!L\", socket.inet_pton(socket.AF_INET,\n                                                    ip_addr))[0]", "response": "Converts IPv4 address to binary form."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _get_binary_from_ipv6(self, ip_addr):\n\n        hi, lo = struct.unpack(\"!QQ\", socket.inet_pton(socket.AF_INET6,\n                                                       ip_addr))\n        return (hi << 64) | lo", "response": "Converts IPv6 address to binary form."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nconverts binary address to Ipv4 format.", "response": "def _get_ipv4_from_binary(self, bin_addr):\n        \"\"\"Converts binary address to Ipv4 format.\"\"\"\n\n        return socket.inet_ntop(socket.AF_INET, struct.pack(\"!L\", bin_addr))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _get_ipv6_from_binary(self, bin_addr):\n\n        hi = bin_addr >> 64\n        lo = bin_addr & 0xFFFFFFFF\n        return socket.inet_ntop(socket.AF_INET6, struct.pack(\"!QQ\", hi, lo))", "response": "Converts binary address to Ipv6 format."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nrun migrations in offline mode.", "response": "def run_migrations_offline():\n    \"\"\"Run migrations in 'offline' mode.\n\n    This configures the context with just a URL or an Engine.\n\n    Calls to context.execute() here emit the given string to the\n    script output.\n\n    \"\"\"\n    set_mysql_engine()\n\n    kwargs = dict()\n    if neutron_config.database.connection:\n        kwargs['url'] = neutron_config.database.connection\n    else:\n        kwargs['dialect_name'] = neutron_config.database.engine\n    kwargs['include_object'] = include_object\n    kwargs['version_table'] = ARISTA_VERSION_TABLE\n    context.configure(**kwargs)\n\n    with context.begin_transaction():\n        context.run_migrations()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_instance_type(self, port):\n        if port[portbindings.VNIC_TYPE] == portbindings.VNIC_BAREMETAL:\n            return a_const.BAREMETAL_RESOURCE\n        owner_to_type = {\n            n_const.DEVICE_OWNER_DHCP: a_const.DHCP_RESOURCE,\n            n_const.DEVICE_OWNER_DVR_INTERFACE: a_const.ROUTER_RESOURCE,\n            trunk_consts.TRUNK_SUBPORT_OWNER: a_const.VM_RESOURCE}\n        if port['device_owner'] in owner_to_type.keys():\n            return owner_to_type[port['device_owner']]\n        elif port['device_owner'].startswith(\n                n_const.DEVICE_OWNER_COMPUTE_PREFIX):\n            return a_const.VM_RESOURCE\n        return None", "response": "Determine the port type based on the device owner and vnic type."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting the binding keys from the port binding", "response": "def _get_binding_keys(self, port, host):\n        \"\"\"Get binding keys from the port binding\"\"\"\n        binding_keys = list()\n        switch_binding = port[portbindings.PROFILE].get(\n            'local_link_information', None)\n        if switch_binding:\n            for binding in switch_binding:\n                switch_id = binding.get('switch_id')\n                port_id = binding.get('port_id')\n                binding_keys.append((port['id'], (switch_id, port_id)))\n        else:\n            binding_keys.append((port['id'], host))\n        return binding_keys"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef delete_port_binding(self, port, host):\n        if not self.get_instance_type(port):\n            return\n        for pb_key in self._get_binding_keys(port, host):\n            pb_res = MechResource(pb_key, a_const.PORT_BINDING_RESOURCE,\n                                  a_const.DELETE)\n            self.provision_queue.put(pb_res)", "response": "Enqueue port binding delete"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef create_network_postcommit(self, context):\n        network = context.current\n\n        log_context(\"create_network_postcommit: network\", network)\n\n        segments = context.network_segments\n        tenant_id = network['project_id']\n        self.create_tenant(tenant_id)\n        self.create_network(network)\n        self.create_segments(segments)", "response": "Provision the network on CVX and create the segments on CVX"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef update_network_postcommit(self, context):\n        network = context.current\n        orig_network = context.original\n\n        log_context(\"update_network_postcommit: network\", network)\n        log_context(\"update_network_postcommit: orig\", orig_network)\n\n        segments = context.network_segments\n\n        self.create_network(network)\n\n        # New segments may have been added\n        self.create_segments(segments)", "response": "Send network updates to CVX"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef delete_network_postcommit(self, context):\n        network = context.current\n\n        log_context(\"delete_network_postcommit: network\", network)\n\n        segments = context.network_segments\n        tenant_id = network['project_id']\n        self.delete_segments(segments)\n        self.delete_network(network)\n        self.delete_tenant_if_removed(tenant_id)", "response": "Delete the network from CVX and tenant from CVX"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nsend port updates to CVX", "response": "def update_port_postcommit(self, context):\n        \"\"\"Send port updates to CVX\n\n        This method is also responsible for the initial creation of ports\n        as we wait until after a port is bound to send the port data to CVX\n        \"\"\"\n        port = context.current\n        orig_port = context.original\n        network = context.network.current\n\n        log_context(\"update_port_postcommit: port\", port)\n        log_context(\"update_port_postcommit: orig\", orig_port)\n\n        tenant_id = port['project_id']\n\n        # Device id can change without a port going DOWN, but the new device\n        # id may not be supported\n        if orig_port and port['device_id'] != orig_port['device_id']:\n            self._delete_port_resources(orig_port, context.original_host)\n\n        if context.status == n_const.PORT_STATUS_DOWN:\n            if (context.original_host and\n                    context.status != context.original_status):\n                self._delete_port_resources(orig_port, context.original_host)\n                self._try_to_release_dynamic_segment(context, migration=True)\n        else:\n            self.create_tenant(tenant_id)\n            self.create_network(network)\n            if context.binding_levels:\n                segments = [\n                    level['bound_segment'] for level in context.binding_levels]\n                self.create_segments(segments)\n            self.create_instance(port)\n            self.create_port(port)\n            self.create_port_binding(port, context.host)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef delete_port_postcommit(self, context):\n        port = context.current\n\n        log_context(\"delete_port_postcommit: port\", port)\n\n        self._delete_port_resources(port, context.host)\n        self._try_to_release_dynamic_segment(context)", "response": "Delete the port from CVX"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _bind_baremetal_port(self, context, segment):\n        port = context.current\n        vif_details = {\n            portbindings.VIF_DETAILS_VLAN: str(\n                segment[driver_api.SEGMENTATION_ID])\n        }\n        context.set_binding(segment[driver_api.ID],\n                            portbindings.VIF_TYPE_OTHER,\n                            vif_details,\n                            n_const.ACTIVE)\n        LOG.debug(\"AristaDriver: bound port info- port ID %(id)s \"\n                  \"on network %(network)s\",\n                  {'id': port['id'],\n                   'network': context.network.current['id']})\n        if port.get('trunk_details'):\n            self.trunk_driver.bind_port(port)\n        return True", "response": "Bind the baremetal port to the segment"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nfinding the appropriate physnet for the current node in the context.", "response": "def _get_physnet(self, context):\n        \"\"\"Find the appropriate physnet for the host\n\n        - Baremetal ports' physnet is determined by looking at the\n          local_link_information contained in the binding profile\n        - Other ports' physnet is determined by looking for the host in the\n          topology\n        \"\"\"\n        port = context.current\n        physnet = None\n        if (port.get(portbindings.VNIC_TYPE) == portbindings.VNIC_BAREMETAL):\n            physnet = self.eapi.get_baremetal_physnet(context)\n        else:\n            physnet = self.eapi.get_host_physnet(context)\n        # If the switch is part of an mlag pair, the physnet is called\n        # peer1_peer2\n        physnet = self.mlag_pairs.get(physnet, physnet)\n        return physnet"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nallocating dynamic segments for the port and continue binding.", "response": "def _bind_fabric(self, context, segment):\n        \"\"\"Allocate dynamic segments for the port\n\n        Segment physnets are based on the switch to which the host is\n        connected.\n        \"\"\"\n        port_id = context.current['id']\n        physnet = self._get_physnet(context)\n        if not physnet:\n            LOG.debug(\"bind_port for port %(port)s: no physical_network \"\n                      \"found\", {'port': port_id})\n            return False\n\n        next_segment = context.allocate_dynamic_segment(\n            {'network_id': context.network.current['id'],\n             'network_type': n_const.TYPE_VLAN,\n             'physical_network': physnet})\n        LOG.debug(\"bind_port for port %(port)s: \"\n                  \"current_segment=%(current_seg)s, \"\n                  \"next_segment=%(next_seg)s\",\n                  {'port': port_id, 'current_seg': segment,\n                   'next_seg': next_segment})\n        context.continue_binding(segment['id'], [next_segment])\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef bind_port(self, context):\n        port = context.current\n\n        log_context(\"bind_port: port\", port)\n\n        for segment in context.segments_to_bind:\n            physnet = segment.get(driver_api.PHYSICAL_NETWORK)\n            segment_type = segment[driver_api.NETWORK_TYPE]\n            if not physnet:\n                if (segment_type == n_const.TYPE_VXLAN and self.manage_fabric):\n                    if self._bind_fabric(context, segment):\n                        continue\n            elif (port.get(portbindings.VNIC_TYPE)\n                    == portbindings.VNIC_BAREMETAL):\n                if (not self.managed_physnets or\n                        physnet in self.managed_physnets):\n                    if self._bind_baremetal_port(context, segment):\n                        continue\n            LOG.debug(\"Arista mech driver unable to bind port %(port)s to \"\n                      \"%(seg_type)s segment on physical_network %(physnet)s\",\n                      {'port': port.get('id'), 'seg_type': segment_type,\n                       'physnet': physnet})", "response": "Bind a port to a network segment."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _try_to_release_dynamic_segment(self, context, migration=False):\n        if migration:\n            binding_levels = context.original_binding_levels\n        else:\n            binding_levels = context.binding_levels\n        LOG.debug(\"_try_release_dynamic_segment: \"\n                  \"binding_levels=%(bl)s\", {'bl': binding_levels})\n        if not binding_levels:\n            return\n\n        for prior_level, binding in enumerate(binding_levels[1:]):\n            allocating_driver = binding_levels[prior_level].get(\n                driver_api.BOUND_DRIVER)\n            if allocating_driver != a_const.MECHANISM_DRV_NAME:\n                continue\n            bound_segment = binding.get(driver_api.BOUND_SEGMENT, {})\n            segment_id = bound_segment.get('id')\n            if not db_lib.segment_is_dynamic(segment_id):\n                continue\n            if not db_lib.segment_bound(segment_id):\n                context.release_dynamic_segment(segment_id)\n                LOG.debug(\"Released dynamic segment %(seg)s allocated \"\n                          \"by %(drv)s\", {'seg': segment_id,\n                                         'drv': allocating_driver})", "response": "Try to release dynamic segment if necessary."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef roller(timestamps, contract_dates, get_weights, **kwargs):\n    timestamps = sorted(timestamps)\n    contract_dates = contract_dates.sort_values()\n    _check_contract_dates(contract_dates)\n    weights = []\n    # for loop speedup only validate inputs the first function call to\n    # get_weights()\n    validate_inputs = True\n    ts = timestamps[0]\n    weights.extend(get_weights(ts, contract_dates,\n                               validate_inputs=validate_inputs, **kwargs))\n    validate_inputs = False\n    for ts in timestamps[1:]:\n        weights.extend(get_weights(ts, contract_dates,\n                                   validate_inputs=validate_inputs, **kwargs))\n\n    weights = aggregate_weights(weights)\n    return weights", "response": "Calculates weight allocations for a given set of timestamps for a given root generic."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef aggregate_weights(weights, drop_date=False):\n    dwts = pd.DataFrame(weights,\n                        columns=[\"generic\", \"contract\", \"weight\", \"date\"])\n    dwts = dwts.pivot_table(index=['date', 'contract'],\n                            columns=['generic'], values='weight', fill_value=0)\n    dwts = dwts.astype(float)\n    dwts = dwts.sort_index()\n    if drop_date:\n        dwts.index = dwts.index.levels[-1]\n    return dwts", "response": "Takes a list of tuples of weight on this contract and returns a pandas. DataFrame of loadings of generic contracts on the tradeable contracts for that date."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef static_transition(timestamp, contract_dates, transition, holidays=None,\n                      validate_inputs=True):\n    \"\"\"\n    An implementation of *get_weights* parameter in roller().\n    Return weights to tradeable instruments for a given date based on a\n    transition DataFrame which indicates how to roll through the roll period.\n\n    Parameters\n    ----------\n    timestamp: pandas.Timestamp\n        The timestamp to return instrument weights for\n    contract_dates: pandas.Series\n        Series with index of tradeable contract names and pandas.Timestamps\n        representing the last date of the roll as values, sorted by values.\n        Index must be unique and values must be strictly monotonic.\n    transition: pandas.DataFrame\n        A DataFrame with a index of integers representing business day offsets\n        from the last roll date and a column which is a MultiIndex where the\n        top level is generic instruments and the second level is\n        ['front', 'back'] which refer to the front month contract and the back\n        month contract of the roll. Note that for different generics, e.g. CL1,\n        CL2, the front and back month contract during a roll would refer to\n        different underlying instruments. The values represent the fraction of\n        the roll on each day during the roll period. The first row of the\n        transition period should be completely allocated to the front contract\n        and the last row should be completely allocated to the back contract.\n    holidays: array_like of datetime64[D]\n        Holidays to exclude when calculating business day offsets from the last\n        roll date. See numpy.busday_count.\n    validate_inputs: Boolean\n        Whether or not to validate ordering of contract_dates and transition.\n        **Caution** this is provided for speed however if this is set to False\n        and inputs are not defined properly algorithm may return incorrect\n        data.\n\n    Returns\n    -------\n    A list of tuples consisting of the generic instrument name, the tradeable\n    contract as a string, the weight on this contract as a float and the date\n    as a pandas.Timestamp.\n\n    Examples\n    --------\n    >>> import pandas as pd\n    >>> import mapping.mappings as mappings\n    >>> cols = pd.MultiIndex.from_product([[\"CL1\", \"CL2\"], ['front', 'back']])\n    >>> idx = [-2, -1, 0]\n    >>> transition = pd.DataFrame([[1.0, 0.0, 1.0, 0.0], [0.5, 0.5, 0.5, 0.5],\n    ...                            [0.0, 1.0, 0.0, 1.0]],\n    ...                           index=idx, columns=cols)\n    >>> contract_dates = pd.Series([pd.Timestamp('2016-10-20'),\n    ...                             pd.Timestamp('2016-11-21'),\n    ...                             pd.Timestamp('2016-12-20')],\n    ...                            index=['CLX16', 'CLZ16', 'CLF17'])\n    >>> ts = pd.Timestamp('2016-10-19')\n    >>> wts = mappings.static_transition(ts, contract_dates, transition)\n    \"\"\"\n\n    if validate_inputs:\n        # required for MultiIndex slicing\n        _check_static(transition.sort_index(axis=1))\n        # the algorithm below will return invalid results if contract_dates is\n        # not as expected so better to fail explicitly\n        _check_contract_dates(contract_dates)\n\n    if not holidays:\n        holidays = []\n\n    # further speedup can be obtained using contract_dates.loc[timestamp:]\n    # but this requires swapping contract_dates index and values\n    after_contract_dates = contract_dates.loc[contract_dates >= timestamp]\n    contracts = after_contract_dates.index\n    front_expiry_dt = after_contract_dates.iloc[0]\n    days_to_expiry = np.busday_count(front_expiry_dt.date(), timestamp.date(),\n                                     holidays=holidays)\n\n    name2num = dict(zip(transition.columns.levels[0],\n                        range(len(transition.columns.levels[0]))))\n    if days_to_expiry in transition.index:\n        weights_iter = transition.loc[days_to_expiry].iteritems()\n    # roll hasn't started yet\n    elif days_to_expiry < transition.index.min():\n        # provides significant speedup over transition.iloc[0].iteritems()\n        vals = transition.values[0]\n        weights_iter = zip(transition.columns.tolist(), vals)\n    # roll is finished\n    else:\n        vals = transition.values[-1]\n        weights_iter = zip(transition.columns.tolist(), vals)\n\n    cwts = []\n    for idx_tuple, weighting in weights_iter:\n        gen_name, position = idx_tuple\n        if weighting != 0:\n            if position == \"front\":\n                cntrct_idx = name2num[gen_name]\n            elif position == \"back\":\n                cntrct_idx = name2num[gen_name] + 1\n            try:\n                cntrct_name = contracts[cntrct_idx]\n            except IndexError as e:\n                raise type(e)((\"index {0} is out of bounds in\\n{1}\\nas of {2} \"\n                               \"resulting from {3} mapping\")\n                              .format(cntrct_idx, after_contract_dates,\n                                      timestamp, idx_tuple)\n                              ).with_traceback(sys.exc_info()[2])\n            cwts.append((gen_name, cntrct_name, weighting, timestamp))\n\n    return cwts", "response": "This function returns a static transition for a given date based on a given transition."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nmapping tradeable instruments to generics given weights and tradeable instrument holdings. This is solving the equation Ax = b where A is the weights, and b is the instrument holdings. When Ax = b has no solution we solve for x' such that Ax' is closest to b in the least squares sense with the additional constraint that sum(x') = sum(instruments). Scenarios with exact solutions and non exact solutions are depicted below +------------+-----+-----+ Instruments | contract | CL1 | CL2 | ------------------------------------ |------------+-----+-----| Scenario 1 | Scenario 2 | Scenario 3 | CLX16 | 0.5 | 0 | 10 | 10 | 10 | CLZ16 | 0.5 | 0.5 | 20 | 20 | 25 | CLF17 | 0 | 0.5 | 10 | 11 | 11 +------------+-----+-----+ In scenario 1 the solution is given by x = [20, 20], in scenario 2 the solution is given by x = [19.5, 21.5], and in scenario 3 the solution is given by x = [22, 24]. NOTE: Integer solutions are not guruanteed, as demonstrated above. This is intended for use with contract numbers but can also be used with notional amounts of contracts. Parameters ---------- instruments: pandas.Series Series of tradeable instrument holdings where the index is the name of the tradeable instrument and the value is the number of that instrument held. weights: pandas.DataFrame or dict A pandas.DataFrame of loadings of generic contracts on tradeable instruments for a given date. The columns are generic instruments and the index is strings representing instrument names. If dict is given keys should be root generic, e.g. 'CL', and values should be pandas.DataFrames of loadings. The union of all indexes should be a superset of the instruments.index Returns ------- A pandas.Series where the index is the generic and the value is the number of contracts, sorted by index. Examples -------- >>> import pandas as pd >>> import mapping.mappings as mappings >>> wts = pd.DataFrame([[0.5, 0], [0.5, 0.5], [0, 0.5]], ... index=[\"CLX16\", \"CLZ16\", \"CLF17\"], ... columns=[\"CL1\", \"CL2\"]) >>> instrs = pd.Series([10, 20, 10], index=[\"CLX16\", \"CLZ16\", \"CLF17\"]) >>> generics = mappings.to_generics(instrs, wts)", "response": "def to_generics(instruments, weights):\n    \"\"\"\n    Map tradeable instruments to generics given weights and tradeable\n    instrument holdings. This is solving the equation Ax = b where A is the\n    weights, and b is the instrument holdings. When Ax = b has no solution we\n    solve for x' such that Ax' is closest to b in the least squares sense with\n    the additional constraint that sum(x') = sum(instruments).\n\n    Scenarios with exact solutions and non exact solutions are depicted below\n\n    +------------+-----+-----+ Instruments\n    | contract   | CL1 | CL2 | ------------------------------------\n    |------------+-----+-----| Scenario 1 | Scenario 2 | Scenario 3\n    | CLX16      | 0.5 | 0   | 10         | 10         | 10\n    | CLZ16      | 0.5 | 0.5 | 20         | 20         | 25\n    | CLF17      | 0   | 0.5 | 10         | 11         | 11\n    +------------+-----+-----+\n\n    In scenario 1 the solution is given by x = [20, 20], in scenario 2 the\n    solution is given by x = [19.5, 21.5], and in scenario 3 the solution is\n    given by x = [22, 24].\n\n    NOTE: Integer solutions are not guruanteed, as demonstrated above. This is\n    intended for use with contract numbers but can also be used with notional\n    amounts of contracts.\n\n    Parameters\n    ----------\n    instruments: pandas.Series\n        Series of tradeable instrument holdings where the index is the name of\n        the tradeable instrument and the value is the number of that instrument\n        held.\n    weights: pandas.DataFrame or dict\n        A pandas.DataFrame of loadings of generic contracts on tradeable\n        instruments for a given date. The columns are generic instruments\n        and the index is strings representing instrument names. If dict is\n        given keys should be root generic, e.g. 'CL', and values should be\n        pandas.DataFrames of loadings. The union of all indexes should be a\n        superset of the instruments.index\n\n    Returns\n    -------\n    A pandas.Series where the index is the generic and the value is the number\n    of contracts, sorted by index.\n\n    Examples\n    --------\n    >>> import pandas as pd\n    >>> import mapping.mappings as mappings\n    >>> wts = pd.DataFrame([[0.5, 0], [0.5, 0.5], [0, 0.5]],\n    ...                    index=[\"CLX16\", \"CLZ16\", \"CLF17\"],\n    ...                    columns=[\"CL1\", \"CL2\"])\n    >>> instrs = pd.Series([10, 20, 10], index=[\"CLX16\", \"CLZ16\", \"CLF17\"])\n    >>> generics = mappings.to_generics(instrs, wts)\n    \"\"\"\n    if not isinstance(weights, dict):\n        weights = {\"\": weights}\n\n    allocations = []\n    unmapped_instr = instruments.index\n    for key in weights:\n        w = weights[key]\n        # may not always have instrument holdings for a set of weights so allow\n        # weights to be a superset of instruments, drop values where no\n        # holdings\n        winstrs = instruments.reindex(w.index).dropna()\n        w = w.loc[winstrs.index]\n        # drop generics where all weights for instruments on the genric are 0.\n        # This avoids numerical rounding issues where solution has epsilon\n        # weight on a generic\n        w = w.loc[:, ~(w == 0).all(axis=0)]\n\n        unmapped_instr = unmapped_instr.difference(winstrs.index)\n\n        A = w.values\n        b = winstrs.values\n        x = cvxpy.Variable(A.shape[1])\n        constrs = [CVX_SUM(x) == np.sum(b)]\n        obj = cvxpy.Minimize(cvxpy.sum_squares(A * x - b))\n        prob = cvxpy.Problem(obj, constrs)\n        prob.solve()\n\n        vals = np.array(x.value).squeeze()\n        idx = w.columns.tolist()\n        allocations.append(pd.Series(vals, index=idx))\n\n    if len(unmapped_instr) > 0:\n        raise KeyError(\"Unmapped instruments %s. weights must be a superset of\"\n                       \" instruments\" % unmapped_instr.tolist())\n\n    allocations = pd.concat(allocations, axis=0)\n    allocations = allocations.sort_index()\n    return allocations"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef synchronize_switch(self, switch_ip, expected_acls, expected_bindings):\n\n        # Get ACL rules and interface mappings from the switch\n        switch_acls, switch_bindings = self._get_dynamic_acl_info(switch_ip)\n\n        # Adjust expected bindings for switch LAG config\n        expected_bindings = self.adjust_bindings_for_lag(switch_ip,\n                                                         expected_bindings)\n        # Get synchronization commands\n        switch_cmds = list()\n        switch_cmds.extend(\n            self.get_sync_acl_cmds(switch_acls, expected_acls))\n        switch_cmds.extend(\n            self.get_sync_binding_cmds(switch_bindings, expected_bindings))\n\n        # Update switch config\n        self.run_openstack_sg_cmds(switch_cmds, self._switches.get(switch_ip))", "response": "Synchronize a switch with the expected config."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nperforms synchronization of the security groups between ML2 and EOS.", "response": "def synchronize(self):\n        \"\"\"Perform sync of the security groups between ML2 and EOS.\"\"\"\n\n        # Get expected ACLs and rules\n        expected_acls = self.get_expected_acls()\n\n        # Get expected interface to ACL mappings\n        all_expected_bindings = self.get_expected_bindings()\n\n        # Check that config is correct on every registered switch\n        for switch_ip in self._switches.keys():\n            expected_bindings = all_expected_bindings.get(switch_ip, [])\n            try:\n                self.synchronize_switch(switch_ip, expected_acls,\n                                        expected_bindings)\n            except Exception:\n                LOG.exception(\"Failed to sync SGs for %(switch)s\",\n                              {'switch': switch_ip})"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nchecks validity of CLI commands for Arista s VLAN type driver.", "response": "def check_vlan_type_driver_commands(self):\n        \"\"\"Checks the validity of CLI commands for Arista's VLAN type driver.\n\n           This method tries to execute the commands used exclusively by the\n           arista_vlan type driver and stores the commands if they succeed.\n        \"\"\"\n        cmd = ['show openstack resource-pool vlan region %s uuid'\n               % self.region]\n        try:\n            self._run_eos_cmds(cmd)\n            self.cli_commands['resource-pool'] = cmd\n        except arista_exc.AristaRpcError:\n            self.cli_commands['resource-pool'] = []\n            LOG.warning(\n                _LW(\"'resource-pool' command '%s' is not available on EOS\"),\n                cmd)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_vlan_assignment_uuid(self):\n        vlan_uuid_cmd = self.cli_commands['resource-pool']\n        if vlan_uuid_cmd:\n            return self._run_eos_cmds(commands=vlan_uuid_cmd)[0]\n        return None", "response": "Returns the UUID for the region s vlan assignment on CVX\n       "}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_vlan_allocation(self):\n        if not self.cli_commands['resource-pool']:\n            LOG.warning(_('The version of CVX you are using does not support'\n                          'arista VLAN type driver.'))\n        else:\n            cmd = ['show openstack resource-pools region %s' % self.region]\n            command_output = self._run_eos_cmds(cmd)\n            if command_output:\n                regions = command_output[0]['physicalNetwork']\n                if self.region in regions.keys():\n                    return regions[self.region]['vlanPool']['default']\n        return {'assignedVlans': '',\n                'availableVlans': '',\n                'allocatedVlans': ''}", "response": "Returns the status of the region s VLAN pool in CVX"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nexecutes a list of commands on Arista EOS and return the response.", "response": "def _run_eos_cmds(self, commands, commands_to_log=None):\n        \"\"\"Execute/sends a CAPI (Command API) command to EOS.\n\n        In this method, list of commands is appended with prefix and\n        postfix commands - to make is understandble by EOS.\n\n        :param commands : List of command to be executed on EOS.\n        :param commands_to_log : This should be set to the command that is\n                                 logged. If it is None, then the commands\n                                 param is logged.\n        \"\"\"\n\n        # Always figure out who is master (starting with the last known val)\n        try:\n            if self._get_eos_master() is None:\n                msg = \"Failed to identify CVX master\"\n                self.set_cvx_unavailable()\n                raise arista_exc.AristaRpcError(msg=msg)\n        except Exception:\n            self.set_cvx_unavailable()\n            raise\n\n        self.set_cvx_available()\n        log_cmds = commands\n        if commands_to_log:\n            log_cmds = commands_to_log\n\n        LOG.info(_LI('Executing command on Arista EOS: %s'), log_cmds)\n        # this returns array of return values for every command in\n        # full_command list\n        try:\n            response = self._send_eapi_req(cmds=commands,\n                                           commands_to_log=log_cmds)\n            if response is None:\n                # Reset the server as we failed communicating with it\n                self._server_ip = None\n                self.set_cvx_unavailable()\n                msg = \"Failed to communicate with CVX master\"\n                raise arista_exc.AristaRpcError(msg=msg)\n            return response\n        except arista_exc.AristaRpcError:\n            raise"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nbuilds full EOS s openstack CLI command.", "response": "def _build_command(self, cmds, sync=False):\n        \"\"\"Build full EOS's openstack CLI command.\n\n        Helper method to add commands to enter and exit from openstack\n        CLI modes.\n\n        :param cmds: The openstack CLI commands that need to be executed\n                     in the openstack config mode.\n        :param sync: This flags indicates that the region is being synced.\n        \"\"\"\n\n        region_cmd = 'region %s' % self.region\n        if sync:\n            region_cmd = self.cli_commands[const.CMD_REGION_SYNC]\n\n        full_command = [\n            'enable',\n            'configure',\n            'cvx',\n            'service openstack',\n            region_cmd,\n        ]\n        full_command.extend(cmds)\n        return full_command"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _run_openstack_cmds(self, commands, commands_to_log=None, sync=False):\n\n        full_command = self._build_command(commands, sync=sync)\n        if commands_to_log:\n            full_log_command = self._build_command(commands_to_log, sync=sync)\n        else:\n            full_log_command = None\n        return self._run_eos_cmds(full_command, full_log_command)", "response": "Execute a list of commands on the OpenStack device."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_baremetal_physnet(self, context):\n        port = context.current\n        host_id = context.host\n        cmd = ['show network physical-topology hosts']\n        try:\n            response = self._run_eos_cmds(cmd)\n            binding_profile = port.get(portbindings.PROFILE, {})\n            link_info = binding_profile.get('local_link_information', [])\n            for link in link_info:\n                switch_id = link.get('switch_id')\n                for host in response[0]['hosts'].values():\n                    if switch_id == host['name']:\n                        physnet = host['hostname']\n                        LOG.debug(\"get_physical_network: Physical Network for \"\n                                  \"%(host)s is %(physnet)s\",\n                                  {'host': host_id, 'physnet': physnet})\n                        return physnet\n            LOG.debug(\"Physical network not found for %(host)s\",\n                      {'host': host_id})\n        except Exception as exc:\n            LOG.error(_LE('command %(cmd)s failed with '\n                      '%(exc)s'), {'cmd': cmd, 'exc': exc})\n        return None", "response": "Returns dictionary which contains mac to hostname mapping"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns dictionary which contains physical topology information for a given host_id", "response": "def get_host_physnet(self, context):\n        \"\"\"Returns dictionary which contains physical topology information\n\n        for a given host_id\n        \"\"\"\n        host_id = utils.hostname(context.host)\n        cmd = ['show network physical-topology neighbors']\n        try:\n            response = self._run_eos_cmds(cmd)\n            # Get response for 'show network physical-topology neighbors'\n            # command\n            neighbors = response[0]['neighbors']\n            for neighbor in neighbors:\n                if host_id in neighbor:\n                    physnet = neighbors[neighbor]['toPort'][0]['hostname']\n                    LOG.debug(\"get_physical_network: Physical Network for \"\n                              \"%(host)s is %(physnet)s\", {'host': host_id,\n                                                          'physnet': physnet})\n                    return physnet\n            LOG.debug(\"Physical network not found for %(host)s\",\n                      {'host': host_id})\n        except Exception as exc:\n            LOG.error(_LE('command %(cmd)s failed with '\n                      '%(exc)s'), {'cmd': cmd, 'exc': exc})\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef filter_unnecessary_segments(query):\n    segment_model = segment_models.NetworkSegment\n    network_model = models_v2.Network\n    query = (query\n             .join_if_necessary(network_model)\n             .join_if_necessary(segment_model)\n             .filter(network_model.project_id != '')\n             .filter_network_type())\n    return query", "response": "Filter segments are not needed on CVX"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nfilter unsupported network types", "response": "def filter_network_type(query):\n    \"\"\"Filter unsupported segment types\"\"\"\n    segment_model = segment_models.NetworkSegment\n    query = (query\n             .filter(\n                 segment_model.network_type.in_(\n                     utils.SUPPORTED_NETWORK_TYPES)))\n    return query"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nfilters ports not bound to a host or network", "response": "def filter_unbound_ports(query):\n    \"\"\"Filter ports not bound to a host or network\"\"\"\n    # hack for pep8 E711: comparison to None should be\n    # 'if cond is not None'\n    none = None\n    port_model = models_v2.Port\n    binding_level_model = ml2_models.PortBindingLevel\n    query = (query\n             .join_if_necessary(port_model)\n             .join_if_necessary(binding_level_model)\n             .filter(\n                 binding_level_model.host != '',\n                 port_model.device_id != none,\n                 port_model.network_id != none))\n    return query"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nfilters ports by device_owner", "response": "def filter_by_device_owner(query, device_owners=None):\n    \"\"\"Filter ports by device_owner\n\n    Either filter using specified device_owner or using the list of all\n    device_owners supported and unsupported by the arista ML2 plugin\n    \"\"\"\n    port_model = models_v2.Port\n    if not device_owners:\n        device_owners = utils.SUPPORTED_DEVICE_OWNERS\n    supported_device_owner_filter = [\n        port_model.device_owner.ilike('%s%%' % owner)\n        for owner in device_owners]\n    unsupported_device_owner_filter = [\n        port_model.device_owner.notilike('%s%%' % owner)\n        for owner in utils.UNSUPPORTED_DEVICE_OWNERS]\n    query = (query\n             .filter(\n                 and_(*unsupported_device_owner_filter),\n                 or_(*supported_device_owner_filter)))\n    return query"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef filter_by_device_id(query):\n    port_model = models_v2.Port\n    unsupported_device_id_filter = [\n        port_model.device_id.notilike('%s%%' % id)\n        for id in utils.UNSUPPORTED_DEVICE_IDS]\n    query = (query\n             .filter(and_(*unsupported_device_id_filter)))\n    return query", "response": "Filter ports attached to devices we don t care about"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef filter_by_vnic_type(query, vnic_type):\n    port_model = models_v2.Port\n    binding_model = ml2_models.PortBinding\n    dst_binding_model = ml2_models.DistributedPortBinding\n    query = (query\n             .outerjoin_if_necessary(\n                 binding_model,\n                 port_model.id == binding_model.port_id)\n             .outerjoin_if_necessary(\n                 dst_binding_model,\n                 port_model.id == dst_binding_model.port_id)\n             .filter(\n                 (binding_model.vnic_type == vnic_type) |\n                 (dst_binding_model.vnic_type == vnic_type)))\n    return query", "response": "Filter ports by vnic_type"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nfilters ports managed by other ML2 plugins", "response": "def filter_unmanaged_physnets(query):\n    \"\"\"Filter ports managed by other ML2 plugins \"\"\"\n    config = cfg.CONF.ml2_arista\n    managed_physnets = config['managed_physnets']\n\n    # Filter out ports bound to segments on physnets that we're not\n    # managing\n    segment_model = segment_models.NetworkSegment\n    if managed_physnets:\n        query = (query\n                 .join_if_necessary(segment_model)\n                 .filter(segment_model.physical_network.in_(\n                     managed_physnets)))\n    return query"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef filter_inactive_ports(query):\n    port_model = models_v2.Port\n    query = (query\n             .filter(port_model.status == n_const.PORT_STATUS_ACTIVE))\n    return query", "response": "Filter ports that aren t in active status"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nfilters out ports that are not needed on CVX.", "response": "def filter_unnecessary_ports(query, device_owners=None, vnic_type=None,\n                             active=True):\n    \"\"\"Filter out all ports are not needed on CVX \"\"\"\n    query = (query\n             .filter_unbound_ports()\n             .filter_by_device_owner(device_owners)\n             .filter_by_device_id()\n             .filter_unmanaged_physnets())\n    if active:\n        query = query.filter_inactive_ports()\n    if vnic_type:\n        query = query.filter_by_vnic_type(vnic_type)\n    return query"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_tenants(tenant_id=None):\n    if tenant_id == '':\n        return []\n    session = db.get_reader_session()\n    project_ids = set()\n    with session.begin():\n        for m in [models_v2.Network, models_v2.Port]:\n            q = session.query(m.project_id).filter(m.project_id != '')\n            if tenant_id:\n                q = q.filter(m.project_id == tenant_id)\n            project_ids.update(pid[0] for pid in q.distinct())\n    return [{'project_id': project_id} for project_id in project_ids]", "response": "Returns list of all project ids that may be relevant on CVX"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn list of all networks that may be relevant on CVX", "response": "def get_networks(network_id=None):\n    \"\"\"Returns list of all networks that may be relevant on CVX\"\"\"\n    session = db.get_reader_session()\n    with session.begin():\n        model = models_v2.Network\n        networks = session.query(model).filter(model.project_id != '')\n        if network_id:\n            networks = networks.filter(model.id == network_id)\n    return networks.all()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_segments(segment_id=None):\n    session = db.get_reader_session()\n    with session.begin():\n        model = segment_models.NetworkSegment\n        segments = session.query(model).filter_unnecessary_segments()\n        if segment_id:\n            segments = segments.filter(model.id == segment_id)\n    return segments.all()", "response": "Returns list of all network segments that may be relevant on CVX"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_instances(device_owners=None, vnic_type=None, instance_id=None):\n    session = db.get_reader_session()\n    with session.begin():\n        port_model = models_v2.Port\n        binding_model = ml2_models.PortBinding\n        instances = (session\n                     .query(port_model,\n                            binding_model)\n                     .outerjoin(\n                         binding_model,\n                         port_model.id == binding_model.port_id)\n                     .distinct(port_model.device_id)\n                     .group_by(port_model.device_id)\n                     .filter_unnecessary_ports(device_owners, vnic_type))\n        if instance_id:\n            instances = instances.filter(port_model.device_id == instance_id)\n    return instances.all()", "response": "Returns a list of all instances in the neutron database"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_vm_instances(instance_id=None):\n    return get_instances(device_owners=[n_const.DEVICE_OWNER_COMPUTE_PREFIX],\n                         vnic_type=portbindings.VNIC_NORMAL,\n                         instance_id=instance_id)", "response": "Returns filtered list of vms that may be relevant on CVX"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_ports(device_owners=None, vnic_type=None, port_id=None, active=True):\n    session = db.get_reader_session()\n    with session.begin():\n        port_model = models_v2.Port\n        ports = (session\n                 .query(port_model)\n                 .filter_unnecessary_ports(device_owners, vnic_type, active))\n        if port_id:\n            ports = ports.filter(port_model.id == port_id)\n    return ports.all()", "response": "Returns list of all ports in neutron the db"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn filtered list of vms that may be relevant on CVX", "response": "def get_vm_ports(port_id=None):\n    \"\"\"Returns filtered list of vms that may be relevant on CVX\"\"\"\n    return get_ports(device_owners=[n_const.DEVICE_OWNER_COMPUTE_PREFIX,\n                                    t_const.TRUNK_SUBPORT_OWNER],\n                     vnic_type=portbindings.VNIC_NORMAL, port_id=port_id)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_port_bindings(binding_key=None):\n    session = db.get_reader_session()\n    with session.begin():\n        binding_level_model = ml2_models.PortBindingLevel\n        aliased_blm = aliased(ml2_models.PortBindingLevel)\n        port_binding_model = ml2_models.PortBinding\n        dist_binding_model = ml2_models.DistributedPortBinding\n        bindings = (session.query(port_binding_model, aliased_blm)\n                    .join(binding_level_model,\n                          and_(\n                              port_binding_model.port_id ==\n                              binding_level_model.port_id,\n                              port_binding_model.host ==\n                              binding_level_model.host))\n                    .filter_unnecessary_ports()\n                    .join(aliased_blm,\n                          and_(port_binding_model.port_id ==\n                               aliased_blm.port_id,\n                               port_binding_model.host ==\n                               aliased_blm.host)))\n        dist_bindings = (session.query(dist_binding_model, aliased_blm)\n                         .join(\n                             binding_level_model,\n                             and_(dist_binding_model.port_id ==\n                                  binding_level_model.port_id,\n                                  dist_binding_model.host ==\n                                  binding_level_model.host))\n                         .filter_unnecessary_ports()\n                         .filter(dist_binding_model.status ==\n                                 n_const.PORT_STATUS_ACTIVE)\n                         .join(aliased_blm,\n                               and_(dist_binding_model.port_id ==\n                                    aliased_blm.port_id,\n                                    dist_binding_model.host ==\n                                    aliased_blm.host)))\n        if binding_key:\n            port_id = binding_key[0]\n            if type(binding_key[1]) == tuple:\n                switch_id = binding_key[1][0]\n                switch_port = binding_key[1][1]\n                bindings = bindings.filter(and_(\n                    port_binding_model.port_id == port_id,\n                    port_binding_model.profile.ilike('%%%s%%' % switch_id),\n                    port_binding_model.profile.ilike('%%%s%%' % switch_port)))\n                dist_bindings = dist_bindings.filter(and_(\n                    dist_binding_model.port_id == port_id,\n                    dist_binding_model.profile.ilike('%%%s%%' % switch_id),\n                    dist_binding_model.profile.ilike('%%%s%%' % switch_port)))\n            else:\n                host_id = binding_key[1]\n                bindings = bindings.filter(and_(\n                    port_binding_model.port_id == port_id,\n                    port_binding_model.host == host_id))\n                dist_bindings = dist_bindings.filter(and_(\n                    dist_binding_model.port_id == port_id,\n                    dist_binding_model.host == host_id))\n    binding_levels = collections.defaultdict(list)\n    for binding, level in bindings.all() + dist_bindings.all():\n        binding_levels[binding].append(level)\n    bindings_with_levels = list()\n    for binding, levels in binding_levels.items():\n        binding.levels = levels\n        bindings_with_levels.append(binding)\n    return bindings_with_levels", "response": "Returns a filtered list of port bindings that may be relevant on CVX."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef tenant_provisioned(tenant_id):\n    session = db.get_reader_session()\n    with session.begin():\n        res = any(\n            session.query(m).filter(m.tenant_id == tenant_id).count()\n            for m in [models_v2.Network, models_v2.Port]\n        )\n    return res", "response": "Returns True if any networks or ports exist for a tenant."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn True if any ports exist for an instance.", "response": "def instance_provisioned(device_id):\n    \"\"\"Returns true if any ports exist for an instance.\"\"\"\n    session = db.get_reader_session()\n    with session.begin():\n        port_model = models_v2.Port\n        res = bool(session.query(port_model)\n                   .filter(port_model.device_id == device_id).count())\n    return res"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef port_provisioned(port_id):\n    session = db.get_reader_session()\n    with session.begin():\n        port_model = models_v2.Port\n        res = bool(session.query(port_model)\n                   .filter(port_model.id == port_id).count())\n    return res", "response": "Returns true if port is already provisioned."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_parent(port_id):\n    session = db.get_reader_session()\n    res = dict()\n    with session.begin():\n        subport_model = trunk_models.SubPort\n        trunk_model = trunk_models.Trunk\n        subport = (session.query(subport_model).\n                   filter(subport_model.port_id == port_id).first())\n        if subport:\n            trunk = (session.query(trunk_model).\n                     filter(trunk_model.id == subport.trunk_id).first())\n            if trunk:\n                trunk_port_id = trunk.port.id\n                res = get_ports(port_id=trunk_port_id, active=False)[0]\n    return res", "response": "Get trunk subport s parent port"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_port_binding_level(filters):\n    session = db.get_reader_session()\n    with session.begin():\n        return (session.query(ml2_models.PortBindingLevel).\n                filter_by(**filters).\n                order_by(ml2_models.PortBindingLevel.level).\n                all())", "response": "Returns entries from PortBindingLevel based on the specified filters."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreads audio data from a sound file.", "response": "def read(file, frames=-1, start=0, stop=None, dtype='float64', always_2d=False,\n         fill_value=None, out=None, samplerate=None, channels=None,\n         format=None, subtype=None, endian=None, closefd=True):\n    \"\"\"Provide audio data from a sound file as NumPy array.\n\n    By default, the whole file is read from the beginning, but the\n    position to start reading can be specified with `start` and the\n    number of frames to read can be specified with `frames`.\n    Alternatively, a range can be specified with `start` and `stop`.\n\n    If there is less data left in the file than requested, the rest of\n    the frames are filled with `fill_value`.\n    If no `fill_value` is specified, a smaller array is returned.\n\n    Parameters\n    ----------\n    file : str or int or file-like object\n        The file to read from.  See :class:`SoundFile` for details.\n    frames : int, optional\n        The number of frames to read. If `frames` is negative, the whole\n        rest of the file is read.  Not allowed if `stop` is given.\n    start : int, optional\n        Where to start reading.  A negative value counts from the end.\n    stop : int, optional\n        The index after the last frame to be read.  A negative value\n        counts from the end.  Not allowed if `frames` is given.\n    dtype : {'float64', 'float32', 'int32', 'int16'}, optional\n        Data type of the returned array, by default ``'float64'``.\n        Floating point audio data is typically in the range from\n        ``-1.0`` to ``1.0``.  Integer data is in the range from\n        ``-2**15`` to ``2**15-1`` for ``'int16'`` and from ``-2**31`` to\n        ``2**31-1`` for ``'int32'``.\n\n        .. note:: Reading int values from a float file will *not*\n            scale the data to [-1.0, 1.0). If the file contains\n            ``np.array([42.6], dtype='float32')``, you will read\n            ``np.array([43], dtype='int32')`` for ``dtype='int32'``.\n\n    Returns\n    -------\n    audiodata : numpy.ndarray or type(out)\n        A two-dimensional (frames x channels) NumPy array is returned.\n        If the sound file has only one channel, a one-dimensional array\n        is returned.  Use ``always_2d=True`` to return a two-dimensional\n        array anyway.\n\n        If `out` was specified, it is returned.  If `out` has more\n        frames than available in the file (or if `frames` is smaller\n        than the length of `out`) and no `fill_value` is given, then\n        only a part of `out` is overwritten and a view containing all\n        valid frames is returned.\n    samplerate : int\n        The sample rate of the audio file.\n\n    Other Parameters\n    ----------------\n    always_2d : bool, optional\n        By default, reading a mono sound file will return a\n        one-dimensional array.  With ``always_2d=True``, audio data is\n        always returned as a two-dimensional array, even if the audio\n        file has only one channel.\n    fill_value : float, optional\n        If more frames are requested than available in the file, the\n        rest of the output is be filled with `fill_value`.  If\n        `fill_value` is not specified, a smaller array is returned.\n    out : numpy.ndarray or subclass, optional\n        If `out` is specified, the data is written into the given array\n        instead of creating a new array.  In this case, the arguments\n        `dtype` and `always_2d` are silently ignored!  If `frames` is\n        not given, it is obtained from the length of `out`.\n    samplerate, channels, format, subtype, endian, closefd\n        See :class:`SoundFile`.\n\n    Examples\n    --------\n    >>> import soundfile as sf\n    >>> data, samplerate = sf.read('stereo_file.wav')\n    >>> data\n    array([[ 0.71329652,  0.06294799],\n           [-0.26450912, -0.38874483],\n           ...\n           [ 0.67398441, -0.11516333]])\n    >>> samplerate\n    44100\n\n    \"\"\"\n    with SoundFile(file, 'r', samplerate, channels,\n                   subtype, endian, format, closefd) as f:\n        frames = f._prepare_read(start, stop, frames)\n        data = f.read(frames, dtype, always_2d, fill_value, out)\n    return data, f.samplerate"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nwriting data to a sound file.", "response": "def write(file, data, samplerate, subtype=None, endian=None, format=None,\n          closefd=True):\n    \"\"\"Write data to a sound file.\n\n    .. note:: If `file` exists, it will be truncated and overwritten!\n\n    Parameters\n    ----------\n    file : str or int or file-like object\n        The file to write to.  See :class:`SoundFile` for details.\n    data : array_like\n        The data to write.  Usually two-dimensional (frames x channels),\n        but one-dimensional `data` can be used for mono files.\n        Only the data types ``'float64'``, ``'float32'``, ``'int32'``\n        and ``'int16'`` are supported.\n\n        .. note:: The data type of `data` does **not** select the data\n                  type of the written file. Audio data will be\n                  converted to the given `subtype`. Writing int values\n                  to a float file will *not* scale the values to\n                  [-1.0, 1.0). If you write the value ``np.array([42],\n                  dtype='int32')``, to a ``subtype='FLOAT'`` file, the\n                  file will then contain ``np.array([42.],\n                  dtype='float32')``.\n\n    samplerate : int\n        The sample rate of the audio data.\n    subtype : str, optional\n        See :func:`default_subtype` for the default value and\n        :func:`available_subtypes` for all possible values.\n\n    Other Parameters\n    ----------------\n    format, endian, closefd\n        See :class:`SoundFile`.\n\n    Examples\n    --------\n    Write 10 frames of random data to a new file:\n\n    >>> import numpy as np\n    >>> import soundfile as sf\n    >>> sf.write('stereo_file.wav', np.random.randn(10, 2), 44100, 'PCM_24')\n\n    \"\"\"\n    import numpy as np\n    data = np.asarray(data)\n    if data.ndim == 1:\n        channels = 1\n    else:\n        channels = data.shape[1]\n    with SoundFile(file, 'w', samplerate, channels,\n                   subtype, endian, format, closefd) as f:\n        f.write(data)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a generator for reading audio files in a specific block - wise fashion.", "response": "def blocks(file, blocksize=None, overlap=0, frames=-1, start=0, stop=None,\n           dtype='float64', always_2d=False, fill_value=None, out=None,\n           samplerate=None, channels=None,\n           format=None, subtype=None, endian=None, closefd=True):\n    \"\"\"Return a generator for block-wise reading.\n\n    By default, iteration starts at the beginning and stops at the end\n    of the file.  Use `start` to start at a later position and `frames`\n    or `stop` to stop earlier.\n\n    If you stop iterating over the generator before it's exhausted,\n    the sound file is not closed. This is normally not a problem\n    because the file is opened in read-only mode. To close the file\n    properly, the generator's ``close()`` method can be called.\n\n    Parameters\n    ----------\n    file : str or int or file-like object\n        The file to read from.  See :class:`SoundFile` for details.\n    blocksize : int\n        The number of frames to read per block.\n        Either this or `out` must be given.\n    overlap : int, optional\n        The number of frames to rewind between each block.\n\n    Yields\n    ------\n    numpy.ndarray or type(out)\n        Blocks of audio data.\n        If `out` was given, and the requested frames are not an integer\n        multiple of the length of `out`, and no `fill_value` was given,\n        the last block will be a smaller view into `out`.\n\n    Other Parameters\n    ----------------\n    frames, start, stop\n        See :func:`read`.\n    dtype : {'float64', 'float32', 'int32', 'int16'}, optional\n        See :func:`read`.\n    always_2d, fill_value, out\n        See :func:`read`.\n    samplerate, channels, format, subtype, endian, closefd\n        See :class:`SoundFile`.\n\n    Examples\n    --------\n    >>> import soundfile as sf\n    >>> for block in sf.blocks('stereo_file.wav', blocksize=1024):\n    >>>     pass  # do something with 'block'\n\n    \"\"\"\n    with SoundFile(file, 'r', samplerate, channels,\n                   subtype, endian, format, closefd) as f:\n        frames = f._prepare_read(start, stop, frames)\n        for block in f.blocks(blocksize, overlap, frames,\n                              dtype, always_2d, fill_value, out):\n            yield block"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a dictionary of available subtypes.", "response": "def available_subtypes(format=None):\n    \"\"\"Return a dictionary of available subtypes.\n\n    Parameters\n    ----------\n    format : str\n        If given, only compatible subtypes are returned.\n\n    Examples\n    --------\n    >>> import soundfile as sf\n    >>> sf.available_subtypes('FLAC')\n    {'PCM_24': 'Signed 24 bit PCM',\n     'PCM_16': 'Signed 16 bit PCM',\n     'PCM_S8': 'Signed 8 bit PCM'}\n\n    \"\"\"\n    subtypes = _available_formats_helper(_snd.SFC_GET_FORMAT_SUBTYPE_COUNT,\n                                         _snd.SFC_GET_FORMAT_SUBTYPE)\n    return dict((subtype, name) for subtype, name in subtypes\n                if format is None or check_format(format, subtype))"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nchecks if the combination of format subtype and endian is valid.", "response": "def check_format(format, subtype=None, endian=None):\n    \"\"\"Check if the combination of format/subtype/endian is valid.\n\n    Examples\n    --------\n    >>> import soundfile as sf\n    >>> sf.check_format('WAV', 'PCM_24')\n    True\n    >>> sf.check_format('FLAC', 'VORBIS')\n    False\n\n    \"\"\"\n    try:\n        return bool(_format_int(format, subtype, endian))\n    except (ValueError, TypeError):\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns numeric ID for given format|subtype|endian combo.", "response": "def _format_int(format, subtype, endian):\n    \"\"\"Return numeric ID for given format|subtype|endian combo.\"\"\"\n    result = _check_format(format)\n    if subtype is None:\n        subtype = default_subtype(format)\n        if subtype is None:\n            raise TypeError(\n                \"No default subtype for major format {0!r}\".format(format))\n    elif not isinstance(subtype, (_unicode, str)):\n        raise TypeError(\"Invalid subtype: {0!r}\".format(subtype))\n    try:\n        result |= _subtypes[subtype.upper()]\n    except KeyError:\n        raise ValueError(\"Unknown subtype: {0!r}\".format(subtype))\n    if endian is None:\n        endian = 'FILE'\n    elif not isinstance(endian, (_unicode, str)):\n        raise TypeError(\"Invalid endian-ness: {0!r}\".format(endian))\n    try:\n        result |= _endians[endian.upper()]\n    except KeyError:\n        raise ValueError(\"Unknown endian-ness: {0!r}\".format(endian))\n\n    info = _ffi.new(\"SF_INFO*\")\n    info.format = result\n    info.channels = 1\n    if _snd.sf_format_check(info) == _snd.SF_FALSE:\n        raise ValueError(\n            \"Invalid combination of format, subtype and endian\")\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nchecks if mode is valid and return its integer representation.", "response": "def _check_mode(mode):\n    \"\"\"Check if mode is valid and return its integer representation.\"\"\"\n    if not isinstance(mode, (_unicode, str)):\n        raise TypeError(\"Invalid mode: {0!r}\".format(mode))\n    mode_set = set(mode)\n    if mode_set.difference('xrwb+') or len(mode) > len(mode_set):\n        raise ValueError(\"Invalid mode: {0!r}\".format(mode))\n    if len(mode_set.intersection('xrw')) != 1:\n        raise ValueError(\"mode must contain exactly one of 'xrw'\")\n\n    if '+' in mode_set:\n        mode_int = _snd.SFM_RDWR\n    elif 'r' in mode_set:\n        mode_int = _snd.SFM_READ\n    else:\n        mode_int = _snd.SFM_WRITE\n    return mode_int"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncheck arguments and create SF_INFO struct.", "response": "def _create_info_struct(file, mode, samplerate, channels,\n                        format, subtype, endian):\n    \"\"\"Check arguments and create SF_INFO struct.\"\"\"\n    original_format = format\n    if format is None:\n        format = _get_format_from_filename(file, mode)\n        assert isinstance(format, (_unicode, str))\n    else:\n        _check_format(format)\n\n    info = _ffi.new(\"SF_INFO*\")\n    if 'r' not in mode or format.upper() == 'RAW':\n        if samplerate is None:\n            raise TypeError(\"samplerate must be specified\")\n        info.samplerate = samplerate\n        if channels is None:\n            raise TypeError(\"channels must be specified\")\n        info.channels = channels\n        info.format = _format_int(format, subtype, endian)\n    else:\n        if any(arg is not None for arg in (\n                samplerate, channels, original_format, subtype, endian)):\n            raise TypeError(\"Not allowed for existing files (except 'RAW'): \"\n                            \"samplerate, channels, format, subtype, endian\")\n    return info"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget a format string obtained from a file extension.", "response": "def _get_format_from_filename(file, mode):\n    \"\"\"Return a format string obtained from file (or file.name).\n\n    If file already exists (= read mode), an empty string is returned on\n    error.  If not, an exception is raised.\n    The return type will always be str or unicode (even if\n    file/file.name is a bytes object).\n\n    \"\"\"\n    format = ''\n    file = getattr(file, 'name', file)\n    try:\n        # This raises an exception if file is not a (Unicode/byte) string:\n        format = _os.path.splitext(file)[-1][1:]\n        # Convert bytes to unicode (raises AttributeError on Python 3 str):\n        format = format.decode('utf-8', 'replace')\n    except Exception:\n        pass\n    if format.upper() not in _formats and 'r' not in mode:\n        raise TypeError(\"No format specified and unable to get format from \"\n                        \"file extension: {0!r}\".format(file))\n    return format"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the string representation of a given numeric format.", "response": "def _format_str(format_int):\n    \"\"\"Return the string representation of a given numeric format.\"\"\"\n    for dictionary in _formats, _subtypes, _endians:\n        for k, v in dictionary.items():\n            if v == format_int:\n                return k\n    else:\n        return 'n/a'"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _format_info(format_int, format_flag=_snd.SFC_GET_FORMAT_INFO):\n    format_info = _ffi.new(\"SF_FORMAT_INFO*\")\n    format_info.format = format_int\n    _snd.sf_command(_ffi.NULL, format_flag, format_info,\n                    _ffi.sizeof(\"SF_FORMAT_INFO\"))\n    name = format_info.name\n    return (_format_str(format_info.format),\n            _ffi.string(name).decode('utf-8', 'replace') if name else \"\")", "response": "Return the ID and short description of a given format."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _check_format(format_str):\n    if not isinstance(format_str, (_unicode, str)):\n        raise TypeError(\"Invalid format: {0!r}\".format(format_str))\n    try:\n        format_int = _formats[format_str.upper()]\n    except KeyError:\n        raise ValueError(\"Unknown format: {0!r}\".format(format_str))\n    return format_int", "response": "Check if format_str is valid and return format ID."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nchecks if file has all the necessary attributes for virtual IO.", "response": "def _has_virtual_io_attrs(file, mode_int):\n    \"\"\"Check if file has all the necessary attributes for virtual IO.\"\"\"\n    readonly = mode_int == _snd.SFM_READ\n    writeonly = mode_int == _snd.SFM_WRITE\n    return all([\n        hasattr(file, 'seek'),\n        hasattr(file, 'tell'),\n        hasattr(file, 'write') or readonly,\n        hasattr(file, 'read') or hasattr(file, 'readinto') or writeonly,\n    ])"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nretrieve the extra info generated when opening the file.", "response": "def extra_info(self):\n        \"\"\"Retrieve the log string generated when opening the file.\"\"\"\n        info = _ffi.new(\"char[]\", 2**14)\n        _snd.sf_command(self._file, _snd.SFC_GET_LOG_INFO,\n                        info, _ffi.sizeof(info))\n        return _ffi.string(info).decode('utf-8', 'replace')"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsets the absolute position of the file.", "response": "def seek(self, frames, whence=SEEK_SET):\n        \"\"\"Set the read/write position.\n\n        Parameters\n        ----------\n        frames : int\n            The frame index or offset to seek.\n        whence : {SEEK_SET, SEEK_CUR, SEEK_END}, optional\n            By default (``whence=SEEK_SET``), `frames` are counted from\n            the beginning of the file.\n            ``whence=SEEK_CUR`` seeks from the current position\n            (positive and negative values are allowed for `frames`).\n            ``whence=SEEK_END`` seeks from the end (use negative value\n            for `frames`).\n\n        Returns\n        -------\n        int\n            The new absolute read/write position in frames.\n\n        Examples\n        --------\n        >>> from soundfile import SoundFile, SEEK_END\n        >>> myfile = SoundFile('stereo_file.wav')\n\n        Seek to the beginning of the file:\n\n        >>> myfile.seek(0)\n        0\n\n        Seek to the end of the file:\n\n        >>> myfile.seek(0, SEEK_END)\n        44100  # this is the file length\n\n        \"\"\"\n        self._check_if_closed()\n        position = _snd.sf_seek(self._file, frames, whence)\n        _error_check(self._errorcode)\n        return position"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef read(self, frames=-1, dtype='float64', always_2d=False,\n             fill_value=None, out=None):\n        \"\"\"Read from the file and return data as NumPy array.\n\n        Reads the given number of frames in the given data format\n        starting at the current read/write position.  This advances the\n        read/write position by the same number of frames.\n        By default, all frames from the current read/write position to\n        the end of the file are returned.\n        Use :meth:`.seek` to move the current read/write position.\n\n        Parameters\n        ----------\n        frames : int, optional\n            The number of frames to read. If ``frames < 0``, the whole\n            rest of the file is read.\n        dtype : {'float64', 'float32', 'int32', 'int16'}, optional\n            Data type of the returned array, by default ``'float64'``.\n            Floating point audio data is typically in the range from\n            ``-1.0`` to ``1.0``. Integer data is in the range from\n            ``-2**15`` to ``2**15-1`` for ``'int16'`` and from\n            ``-2**31`` to ``2**31-1`` for ``'int32'``.\n\n            .. note:: Reading int values from a float file will *not*\n                scale the data to [-1.0, 1.0). If the file contains\n                ``np.array([42.6], dtype='float32')``, you will read\n                ``np.array([43], dtype='int32')`` for\n                ``dtype='int32'``.\n\n        Returns\n        -------\n        audiodata : numpy.ndarray or type(out)\n            A two-dimensional NumPy (frames x channels) array is\n            returned. If the sound file has only one channel, a\n            one-dimensional array is returned. Use ``always_2d=True``\n            to return a two-dimensional array anyway.\n\n            If `out` was specified, it is returned. If `out` has more\n            frames than available in the file (or if `frames` is\n            smaller than the length of `out`) and no `fill_value` is\n            given, then only a part of `out` is overwritten and a view\n            containing all valid frames is returned. numpy.ndarray or\n            type(out)\n\n        Other Parameters\n        ----------------\n        always_2d : bool, optional\n            By default, reading a mono sound file will return a\n            one-dimensional array. With ``always_2d=True``, audio data\n            is always returned as a two-dimensional array, even if the\n            audio file has only one channel.\n        fill_value : float, optional\n            If more frames are requested than available in the file,\n            the rest of the output is be filled with `fill_value`. If\n            `fill_value` is not specified, a smaller array is\n            returned.\n        out : numpy.ndarray or subclass, optional\n            If `out` is specified, the data is written into the given\n            array instead of creating a new array. In this case, the\n            arguments `dtype` and `always_2d` are silently ignored! If\n            `frames` is not given, it is obtained from the length of\n            `out`.\n\n        Examples\n        --------\n        >>> from soundfile import SoundFile\n        >>> myfile = SoundFile('stereo_file.wav')\n\n        Reading 3 frames from a stereo file:\n\n        >>> myfile.read(3)\n        array([[ 0.71329652,  0.06294799],\n               [-0.26450912, -0.38874483],\n               [ 0.67398441, -0.11516333]])\n        >>> myfile.close()\n\n        See Also\n        --------\n        buffer_read, .write\n\n        \"\"\"\n        if out is None:\n            frames = self._check_frames(frames, fill_value)\n            out = self._create_empty_array(frames, always_2d, dtype)\n        else:\n            if frames < 0 or frames > len(out):\n                frames = len(out)\n        frames = self._array_io('read', out, frames)\n        if len(out) > frames:\n            if fill_value is None:\n                out = out[:frames]\n            else:\n                out[frames:] = fill_value\n        return out", "response": "Read from the file and return data as NumPy array."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef buffer_read(self, frames=-1, dtype=None):\n        frames = self._check_frames(frames, fill_value=None)\n        ctype = self._check_dtype(dtype)\n        cdata = _ffi.new(ctype + '[]', frames * self.channels)\n        read_frames = self._cdata_io('read', cdata, ctype, frames)\n        assert read_frames == frames\n        return _ffi.buffer(cdata)", "response": "Read from the file and return the data as a buffer object."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreads from the file into a given buffer object.", "response": "def buffer_read_into(self, buffer, dtype):\n        \"\"\"Read from the file into a given buffer object.\n\n        Fills the given `buffer` with frames in the given data format\n        starting at the current read/write position (which can be\n        changed with :meth:`.seek`) until the buffer is full or the end\n        of the file is reached.  This advances the read/write position\n        by the number of frames that were read.\n\n        Parameters\n        ----------\n        buffer : writable buffer\n            Audio frames from the file are written to this buffer.\n        dtype : {'float64', 'float32', 'int32', 'int16'}\n            The data type of `buffer`.\n\n        Returns\n        -------\n        int\n            The number of frames that were read from the file.\n            This can be less than the size of `buffer`.\n            The rest of the buffer is not filled with meaningful data.\n\n        See Also\n        --------\n        buffer_read, .read\n\n        \"\"\"\n        ctype = self._check_dtype(dtype)\n        cdata, frames = self._check_buffer(buffer, ctype)\n        frames = self._cdata_io('read', cdata, ctype, frames)\n        return frames"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef write(self, data):\n        import numpy as np\n        # no copy is made if data has already the correct memory layout:\n        data = np.ascontiguousarray(data)\n        written = self._array_io('write', data, len(data))\n        assert written == len(data)\n        self._update_frames(written)", "response": "Write audio data from a NumPy array to the file."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nwrite audio data from a buffer or bytes object to the file.", "response": "def buffer_write(self, data, dtype):\n        \"\"\"Write audio data from a buffer/bytes object to the file.\n\n        Writes the contents of `data` to the file at the current\n        read/write position.\n        This also advances the read/write position by the number of\n        frames that were written and enlarges the file if necessary.\n\n        Parameters\n        ----------\n        data : buffer or bytes\n            A buffer or bytes object containing the audio data to be\n            written.\n        dtype : {'float64', 'float32', 'int32', 'int16'}\n            The data type of the audio data stored in `data`.\n\n        See Also\n        --------\n        .write, buffer_read\n\n        \"\"\"\n        ctype = self._check_dtype(dtype)\n        cdata, frames = self._check_buffer(data, ctype)\n        written = self._cdata_io('write', cdata, ctype, frames)\n        assert written == frames\n        self._update_frames(written)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef blocks(self, blocksize=None, overlap=0, frames=-1, dtype='float64',\n               always_2d=False, fill_value=None, out=None):\n        \"\"\"Return a generator for block-wise reading.\n\n        By default, the generator yields blocks of the given\n        `blocksize` (using a given `overlap`) until the end of the file\n        is reached; `frames` can be used to stop earlier.\n\n        Parameters\n        ----------\n        blocksize : int\n            The number of frames to read per block. Either this or `out`\n            must be given.\n        overlap : int, optional\n            The number of frames to rewind between each block.\n        frames : int, optional\n            The number of frames to read.\n            If ``frames < 0``, the file is read until the end.\n        dtype : {'float64', 'float32', 'int32', 'int16'}, optional\n            See :meth:`.read`.\n\n        Yields\n        ------\n        numpy.ndarray or type(out)\n            Blocks of audio data.\n            If `out` was given, and the requested frames are not an\n            integer multiple of the length of `out`, and no\n            `fill_value` was given, the last block will be a smaller\n            view into `out`.\n\n\n        Other Parameters\n        ----------------\n        always_2d, fill_value, out\n            See :meth:`.read`.\n        fill_value : float, optional\n            See :meth:`.read`.\n        out : numpy.ndarray or subclass, optional\n            If `out` is specified, the data is written into the given\n            array instead of creating a new array. In this case, the\n            arguments `dtype` and `always_2d` are silently ignored!\n\n        Examples\n        --------\n        >>> from soundfile import SoundFile\n        >>> with SoundFile('stereo_file.wav') as f:\n        >>>     for block in f.blocks(blocksize=1024):\n        >>>         pass  # do something with 'block'\n\n        \"\"\"\n        import numpy as np\n\n        if 'r' not in self.mode and '+' not in self.mode:\n            raise RuntimeError(\"blocks() is not allowed in write-only mode\")\n\n        if out is None:\n            if blocksize is None:\n                raise TypeError(\"One of {blocksize, out} must be specified\")\n            out = self._create_empty_array(blocksize, always_2d, dtype)\n            copy_out = True\n        else:\n            if blocksize is not None:\n                raise TypeError(\n                    \"Only one of {blocksize, out} may be specified\")\n            blocksize = len(out)\n            copy_out = False\n\n        overlap_memory = None\n        frames = self._check_frames(frames, fill_value)\n        while frames > 0:\n            if overlap_memory is None:\n                output_offset = 0\n            else:\n                output_offset = len(overlap_memory)\n                out[:output_offset] = overlap_memory\n\n            toread = min(blocksize - output_offset, frames)\n            self.read(toread, dtype, always_2d, fill_value, out[output_offset:])\n\n            if overlap:\n                if overlap_memory is None:\n                    overlap_memory = np.copy(out[-overlap:])\n                else:\n                    overlap_memory[:] = out[-overlap:]\n\n            if blocksize > frames + overlap and fill_value is None:\n                block = out[:frames + overlap]\n            else:\n                block = out\n            yield np.copy(block) if copy_out else block\n            frames -= toread", "response": "Return a generator for reading audio files in a specific block size."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ntruncating the file to a given number of frames.", "response": "def truncate(self, frames=None):\n        \"\"\"Truncate the file to a given number of frames.\n\n        After this command, the read/write position will be at the new\n        end of the file.\n\n        Parameters\n        ----------\n        frames : int, optional\n            Only the data before `frames` is kept, the rest is deleted.\n            If not specified, the current read/write position is used.\n\n        \"\"\"\n        if frames is None:\n            frames = self.tell()\n        err = _snd.sf_command(self._file, _snd.SFC_FILE_TRUNCATE,\n                              _ffi.new(\"sf_count_t*\", frames),\n                              _ffi.sizeof(\"sf_count_t\"))\n        if err:\n            raise RuntimeError(\"Error truncating the file\")\n        self._info.frames = frames"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nclosing the file. Can be called multiple times.", "response": "def close(self):\n        \"\"\"Close the file.  Can be called multiple times.\"\"\"\n        if not self.closed:\n            # be sure to flush data to disk before closing the file\n            self.flush()\n            err = _snd.sf_close(self._file)\n            self._file = None\n            _error_check(err)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _open(self, file, mode_int, closefd):\n        if isinstance(file, (_unicode, bytes)):\n            if _os.path.isfile(file):\n                if 'x' in self.mode:\n                    raise OSError(\"File exists: {0!r}\".format(self.name))\n                elif set(self.mode).issuperset('w+'):\n                    # truncate the file, because SFM_RDWR doesn't:\n                    _os.close(_os.open(file, _os.O_WRONLY | _os.O_TRUNC))\n            openfunction = _snd.sf_open\n            if isinstance(file, _unicode):\n                if _sys.platform == 'win32':\n                    openfunction = _snd.sf_wchar_open\n                else:\n                    file = file.encode(_sys.getfilesystemencoding())\n            file_ptr = openfunction(file, mode_int, self._info)\n        elif isinstance(file, int):\n            file_ptr = _snd.sf_open_fd(file, mode_int, self._info, closefd)\n        elif _has_virtual_io_attrs(file, mode_int):\n            file_ptr = _snd.sf_open_virtual(self._init_virtual_io(file),\n                                            mode_int, self._info, _ffi.NULL)\n        else:\n            raise TypeError(\"Invalid file: {0!r}\".format(self.name))\n        _error_check(_snd.sf_error(file_ptr),\n                     \"Error opening {0!r}: \".format(self.name))\n        if mode_int == _snd.SFM_WRITE:\n            # Due to a bug in libsndfile version <= 1.0.25, frames != 0\n            # when opening a named pipe in SFM_WRITE mode.\n            # See http://github.com/erikd/libsndfile/issues/77.\n            self._info.frames = 0\n            # This is not necessary for \"normal\" files (because\n            # frames == 0 in this case), but it doesn't hurt, either.\n        return file_ptr", "response": "Open the file and return the file handle."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ninitializing the virtual io for the current version of the file.", "response": "def _init_virtual_io(self, file):\n        \"\"\"Initialize callback functions for sf_open_virtual().\"\"\"\n        @_ffi.callback(\"sf_vio_get_filelen\")\n        def vio_get_filelen(user_data):\n            curr = file.tell()\n            file.seek(0, SEEK_END)\n            size = file.tell()\n            file.seek(curr, SEEK_SET)\n            return size\n\n        @_ffi.callback(\"sf_vio_seek\")\n        def vio_seek(offset, whence, user_data):\n            file.seek(offset, whence)\n            return file.tell()\n\n        @_ffi.callback(\"sf_vio_read\")\n        def vio_read(ptr, count, user_data):\n            # first try readinto(), if not available fall back to read()\n            try:\n                buf = _ffi.buffer(ptr, count)\n                data_read = file.readinto(buf)\n            except AttributeError:\n                data = file.read(count)\n                data_read = len(data)\n                buf = _ffi.buffer(ptr, data_read)\n                buf[0:data_read] = data\n            return data_read\n\n        @_ffi.callback(\"sf_vio_write\")\n        def vio_write(ptr, count, user_data):\n            buf = _ffi.buffer(ptr, count)\n            data = buf[:]\n            written = file.write(data)\n            # write() returns None for file objects in Python <= 2.7:\n            if written is None:\n                written = count\n            return written\n\n        @_ffi.callback(\"sf_vio_tell\")\n        def vio_tell(user_data):\n            return file.tell()\n\n        # Note: the callback functions must be kept alive!\n        self._virtual_io = {'get_filelen': vio_get_filelen,\n                            'seek': vio_seek,\n                            'read': vio_read,\n                            'write': vio_write,\n                            'tell': vio_tell}\n\n        return _ffi.new(\"SF_VIRTUAL_IO*\", self._virtual_io)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreduces frames to no more than are available in the file.", "response": "def _check_frames(self, frames, fill_value):\n        \"\"\"Reduce frames to no more than are available in the file.\"\"\"\n        if self.seekable():\n            remaining_frames = self.frames - self.tell()\n            if frames < 0 or (frames > remaining_frames and\n                              fill_value is None):\n                frames = remaining_frames\n        elif frames < 0:\n            raise ValueError(\"frames must be specified for non-seekable files\")\n        return frames"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _check_buffer(self, data, ctype):\n        assert ctype in _ffi_types.values()\n        if not isinstance(data, bytes):\n            data = _ffi.from_buffer(data)\n        frames, remainder = divmod(len(data),\n                                   self.channels * _ffi.sizeof(ctype))\n        if remainder:\n            raise ValueError(\"Data size must be a multiple of frame size\")\n        return data, frames", "response": "Convert buffer to cdata and check for valid size."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _create_empty_array(self, frames, always_2d, dtype):\n        import numpy as np\n        if always_2d or self.channels > 1:\n            shape = frames, self.channels\n        else:\n            shape = frames,\n        return np.empty(shape, dtype, order='C')", "response": "Create an empty array with appropriate shape."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nchecking if dtype string is valid and return ctype string.", "response": "def _check_dtype(self, dtype):\n        \"\"\"Check if dtype string is valid and return ctype string.\"\"\"\n        try:\n            return _ffi_types[dtype]\n        except KeyError:\n            raise ValueError(\"dtype must be one of {0!r} and not {1!r}\".format(\n                sorted(_ffi_types.keys()), dtype))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _array_io(self, action, array, frames):\n        if (array.ndim not in (1, 2) or\n                array.ndim == 1 and self.channels != 1 or\n                array.ndim == 2 and array.shape[1] != self.channels):\n            raise ValueError(\"Invalid shape: {0!r}\".format(array.shape))\n        if not array.flags.c_contiguous:\n            raise ValueError(\"Data must be C-contiguous\")\n        ctype = self._check_dtype(array.dtype.name)\n        assert array.dtype.itemsize == _ffi.sizeof(ctype)\n        cdata = _ffi.cast(ctype + '*', array.__array_interface__['data'][0])\n        return self._cdata_io(action, cdata, ctype, frames)", "response": "Check array and call low - level IO function."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _cdata_io(self, action, data, ctype, frames):\n        assert ctype in _ffi_types.values()\n        self._check_if_closed()\n        if self.seekable():\n            curr = self.tell()\n        func = getattr(_snd, 'sf_' + action + 'f_' + ctype)\n        frames = func(self._file, data, frames)\n        _error_check(self._errorcode)\n        if self.seekable():\n            self.seek(curr + frames, SEEK_SET)  # Update read & write position\n        return frames", "response": "Call one of libsndfile s read and write functions."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nupdates self. frames after writing.", "response": "def _update_frames(self, written):\n        \"\"\"Update self.frames after writing.\"\"\"\n        if self.seekable():\n            curr = self.tell()\n            self._info.frames = self.seek(0, SEEK_END)\n            self.seek(curr, SEEK_SET)\n        else:\n            self._info.frames += written"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _prepare_read(self, start, stop, frames):\n        if start != 0 and not self.seekable():\n            raise ValueError(\"start is only allowed for seekable files\")\n        if frames >= 0 and stop is not None:\n            raise TypeError(\"Only one of {frames, stop} may be used\")\n\n        start, stop, _ = slice(start, stop).indices(self.frames)\n        if stop < start:\n            stop = start\n        if frames < 0:\n            frames = stop - start\n        if self.seekable():\n            self.seek(start, SEEK_SET)\n        return frames", "response": "Seek to start frame and calculate length."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef ensure_dir(dirname):\n  try:\n    # Tries to create the directory\n    os.makedirs(dirname)\n  except OSError:\n    # Check that the directory exists\n    if os.path.isdir(dirname): pass\n    else: raise", "response": "Creates the directory dirname if it does not already exist."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef probes_used_generate_vector(probe_files_full, probe_files_model):\n  import numpy as np\n  C_probesUsed = np.ndarray((len(probe_files_full),), 'bool')\n  C_probesUsed.fill(False)\n  c=0\n  for k in sorted(probe_files_full.keys()):\n    if probe_files_model.has_key(k): C_probesUsed[c] = True\n    c+=1\n  return C_probesUsed", "response": "Generates boolean matrices indicating which are the probes for each model in the probe_files_full."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nextracts a matrix of scores for a model given a probes_used row vector of boolean", "response": "def probes_used_extract_scores(full_scores, same_probes):\n  \"\"\"Extracts a matrix of scores for a model, given a probes_used row vector of boolean\"\"\"\n  if full_scores.shape[1] != same_probes.shape[0]: raise \"Size mismatch\"\n  import numpy as np\n  model_scores = np.ndarray((full_scores.shape[0],np.sum(same_probes)), 'float64')\n  c=0\n  for i in range(0,full_scores.shape[1]):\n    if same_probes[i]:\n      for j in range(0,full_scores.shape[0]):\n        model_scores[j,c] = full_scores[j,i]\n      c+=1\n  return model_scores"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\napplying a unit mean and variance normalization to an arrayset", "response": "def normalize_std_array(vector):\n  \"\"\"Applies a unit mean and variance normalization to an arrayset\"\"\"\n\n  # Initializes variables\n  length = 1\n  n_samples = len(vector)\n  mean = numpy.ndarray((length,), 'float64')\n  std = numpy.ndarray((length,), 'float64')\n  mean.fill(0)\n  std.fill(0)\n\n  # Computes mean and variance\n  for array in vector:\n    x = array.astype('float64')\n    mean += x\n    std += (x ** 2)\n\n  mean /= n_samples\n  std /= n_samples\n  std -= (mean ** 2)\n  std = std ** 0.5\n  arrayset = numpy.ndarray(shape=(n_samples,mean.shape[0]), dtype=numpy.float64)\n\n  for i in range (0, n_samples):\n    arrayset[i,:] = (vector[i]-mean) / std\n  return arrayset"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef smoothing(labels, smoothing_window):\n\n  if numpy.sum(labels)< smoothing_window:\n    return labels\n  segments = []\n  for k in range(1,len(labels)-1):\n    if labels[k]==0 and labels[k-1]==1 and labels[k+1]==1 :\n      labels[k]=1\n  for k in range(1,len(labels)-1):\n    if labels[k]==1 and labels[k-1]==0 and labels[k+1]==0 :\n      labels[k]=0\n\n  seg = numpy.array([0,0,labels[0]])\n  for k in range(1,len(labels)):\n    if labels[k] != labels[k-1]:\n      seg[1]=k-1\n      segments.append(seg)\n      seg = numpy.array([k,k,labels[k]])\n  seg[1]=len(labels)-1\n  segments.append(seg)\n\n  if len(segments) < 2:\n    return labels\n\n  curr = segments[0]\n  next = segments[1]\n\n  # Look at the first segment. If it's short enough, just change its labels\n  if (curr[1]-curr[0]+1) < smoothing_window and (next[1]-next[0]+1) > smoothing_window:\n    if curr[2]==1:\n      labels[curr[0] : (curr[1]+1)] = numpy.zeros(curr[1] - curr[0] + 1)\n      curr[2]=0\n    else: #curr[2]==0\n      labels[curr[0] : (curr[1]+1)] = numpy.ones(curr[1] - curr[0] + 1)\n      curr[2]=1\n\n  for k in range(1,len(segments)-1):\n    prev = segments[k-1]\n    curr = segments[k]\n    next = segments[k+1]\n\n    if (curr[1]-curr[0]+1) < smoothing_window and (prev[1]-prev[0]+1) > smoothing_window and (next[1]-next[0]+1) > smoothing_window:\n      if curr[2]==1:\n        labels[curr[0] : (curr[1]+1)] = numpy.zeros(curr[1] - curr[0] + 1)\n        curr[2]=0\n      else: #curr[2]==0\n        labels[curr[0] : (curr[1]+1)] = numpy.ones(curr[1] - curr[0] + 1)\n        curr[2]=1\n\n  prev = segments[-2]\n  curr = segments[-1]\n\n  if (curr[1]-curr[0]+1) < smoothing_window and (prev[1]-prev[0]+1) > smoothing_window:\n    if curr[2]==1:\n      labels[curr[0] : (curr[1]+1)] = numpy.zeros(curr[1] - curr[0] + 1)\n      curr[2]=0\n    else: #if curr[2]==0\n      labels[curr[0] : (curr[1]+1)] = numpy.ones(curr[1] - curr[0] + 1)\n      curr[2]=1\n\n  return labels", "response": "Applies a smoothing on VAD"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _conversion(self, input_signal, vad_file):\n    \n    e = bob.ap.Energy(rate_wavsample[0], self.win_length_ms, self.win_shift_ms)\n    energy_array = e(rate_wavsample[1])\n    labels = self.use_existing_vad(energy_array, vad_file)\n    \n    return labels", "response": "Convert an external VAD to a Spear label."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncompute and returns the 4Hz modulation energy features for the given input wave file", "response": "def mod_4hz(self, rate_wavsample):\n    \"\"\"Computes and returns the 4Hz modulation energy features for the given input wave file\"\"\"\n\n    # Set parameters\n    wl = self.win_length_ms\n    ws = self.win_shift_ms\n    nf = self.n_filters\n    f_min = self.f_min\n    f_max = self.f_max\n    pre = self.pre_emphasis_coef\n\n    c = bob.ap.Spectrogram(rate_wavsample[0], wl, ws, nf, f_min, f_max, pre)\n    c.energy_filter=True\n    c.log_filter=False\n    c.energy_bands=True\n\n    sig =  rate_wavsample[1]\n    energy_bands = c(sig)\n    filtering_res = self.pass_band_filtering(energy_bands, rate_wavsample[0])\n    mod_4hz = self.modulation_4hz(filtering_res, rate_wavsample)\n    mod_4hz = self.averaging(mod_4hz)\n    e = bob.ap.Energy(rate_wavsample[0], wl, ws)\n    energy_array = e(rate_wavsample[1])\n    labels = self._voice_activity_detection(energy_array, mod_4hz)\n    labels = utils.smoothing(labels,self.smoothing_window) # discard isolated speech less than 100ms\n    logger.info(\"After Mod-4Hz based VAD there are %d frames remaining over %d\", numpy.sum(labels), len(labels))\n    return labels, energy_array, mod_4hz"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef read_matlab_files(self, biofile, directory, extension):\n        import bob.io.matlab\n        # return the numpy array read from the data_file\n        data_path = biofile.make_path(directory, extension)\n        return bob.io.base.load(data_path)", "response": "Read pre - computed CQCC Matlab features here\n       "}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef write_data(self, data, data_file, compression=0):\n    f = bob.io.base.HDF5File(data_file, 'w')\n    f.set(\"rate\", data[0], compression=compression)\n    f.set(\"data\", data[1], compression=compression)\n    f.set(\"labels\", data[2], compression=compression)", "response": "Writes the given preprocessed data to a file with the given name."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef command_line_arguments(command_line_parameters):\n\n  # create parser\n  parser = argparse.ArgumentParser(description='Execute baseline algorithms with default parameters', formatter_class=argparse.ArgumentDefaultsHelpFormatter)\n\n  # add parameters\n  # - the algorithm to execute\n  parser.add_argument('-a', '--algorithms', choices = all_algorithms, default = ('gmm-voxforge',), nargs = '+', help = 'Select one (or more) algorithms that you want to execute.')\n  parser.add_argument('--all', action = 'store_true', help = 'Select all algorithms.')\n  # - the database to choose\n  parser.add_argument('-d', '--database', choices = available_databases, default = 'voxforge', help = 'The database on which the baseline algorithm is executed.')\n  # - the database to choose\n  parser.add_argument('-b', '--baseline-directory', default = 'baselines', help = 'The sub-directory, where the baseline results are stored.')\n  # - the directory to write\n  parser.add_argument('-f', '--directory', help = 'The directory to write the data of the experiment into. If not specified, the default directories of the verify.py script are used (see verify.py --help).')\n\n  # - use the Idiap grid -- option is only useful if you are at Idiap\n  parser.add_argument('-g', '--grid', action = 'store_true', help = 'Execute the algorithm in the SGE grid.')\n  # - run in parallel on the local machine\n  parser.add_argument('-l', '--parallel', type=int, help = 'Run the algorithms in parallel on the local machine, using the given number of parallel threads')\n  # - perform ZT-normalization\n  parser.add_argument('-z', '--zt-norm', action = 'store_false', help = 'Compute the ZT norm for the files (might not be availabe for all databases).')\n\n  # - just print?\n  parser.add_argument('-q', '--dry-run', action = 'store_true', help = 'Just print the commands, but do not execute them.')\n\n  # - evaluate the algorithm (after it has finished)\n  parser.add_argument('-e', '--evaluate', nargs='+', choices = ('EER', 'HTER', 'ROC', 'DET', 'CMC', 'RR'), help = 'Evaluate the results of the algorithms (instead of running them) using the given evaluation techniques.')\n  # TODO: add MIN-DCT measure\n  # - other parameters that are passed to the underlying script\n  parser.add_argument('parameters', nargs = argparse.REMAINDER, help = 'Parameters directly passed to the verify.py script.')\n\n  bob.core.log.add_command_line_option(parser)\n  args = parser.parse_args(command_line_parameters)\n  if args.all:\n    args.algorithms = all_algorithms\n\n  bob.core.log.set_verbosity_level(logger, args.verbose)\n\n  return args", "response": "Defines the command line arguments that are accepted by the user."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncomputes the energy of the audio sample", "response": "def _compute_energy(self, rate_wavsample):\n    \"\"\"retreive the speech / non speech labels for the speech sample given by the tuple (rate, wave signal)\"\"\"\n\n    e = bob.ap.Energy(rate_wavsample[0], self.win_length_ms, self.win_shift_ms)\n    energy_array = e(rate_wavsample[1])\n    labels = self._voice_activity_detection(energy_array)\n    # discard isolated speech a number of frames defined in smoothing_window\n    labels = utils.smoothing(labels,self.smoothing_window)\n\n    logger.info(\"After 2 Gaussian Energy-based VAD there are %d frames remaining over %d\", numpy.sum(labels), len(labels))\n    return labels"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef calc_mean(c0, c1=[]):\n    if c1 != []:\n        return (numpy.mean(c0, 0) + numpy.mean(c1, 0)) / 2.\n    else:\n        return numpy.mean(c0, 0)", "response": "Calculates the mean of the data."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef calc_std(c0, c1=[]):\n    if c1 == []:\n        return numpy.std(c0, 0)\n    prop = float(len(c0)) / float(len(c1))\n    if prop < 1:\n        p0 = int(math.ceil(1 / prop))\n        p1 = 1\n    else:\n        p0 = 1\n        p1 = int(math.ceil(prop))\n    return numpy.std(numpy.vstack(p0 * [c0] + p1 * [c1]), 0)", "response": "Calculates the variance of the data."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef calc_mean_std(c0, c1=[], nonStdZero=False):\n    mi = calc_mean(c0, c1)\n    std = calc_std(c0, c1)\n    if (nonStdZero):\n        std[std == 0] = 1\n\n    return mi, std", "response": "Calculates both the mean and standard deviation of the data."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef vad_filter_features(vad_labels, features, filter_frames=\"trim_silence\"):\n\n    if not features.size:\n        raise ValueError(\"vad_filter_features(): data sample is empty, no features extraction is possible\")\n\n    vad_labels = numpy.asarray(vad_labels, dtype=numpy.int8)\n    features = numpy.asarray(features, dtype=numpy.float64)\n    features = numpy.reshape(features, (vad_labels.shape[0], -1))\n\n    #    logger.info(\"RatioVectorExtractor, vad_labels shape: %s\", str(vad_labels.shape))\n    #    print (\"RatioVectorExtractor, features max: %f and min: %f\" %(numpy.max(features), numpy.min(features)))\n\n    # first, take the whole thing, in case there are problems later\n    filtered_features = features\n\n    # if VAD detection worked on this sample\n    if vad_labels is not None and filter_frames != \"no_filter\":\n        # make sure the size of VAD labels and sectrogram lenght match\n        if len(vad_labels) == len(features):\n\n            # take only speech frames, as in VAD speech frames are 1 and silence are 0\n            speech, = numpy.nonzero(vad_labels)\n            silences = None\n            if filter_frames == \"silence_only\":\n                # take only silent frames - those for which VAD gave zeros\n                silences, = numpy.nonzero(vad_labels == 0)\n\n            if len(speech):\n                nzstart = speech[0]  # index of the first non-zero\n                nzend = speech[-1]  # index of the last non-zero\n\n                if filter_frames == \"silence_only\":  # extract only silent frames\n                    # take only silent frames in-between the speech\n                    silences = silences[silences > nzstart]\n                    silences = silences[silences < nzend]\n                    filtered_features = features[silences, :]\n                elif filter_frames == \"speech_only\":\n                    filtered_features = features[speech, :]\n                else:  # when we take all\n                    filtered_features = features[nzstart:nzend + 1, :]  # numpy slicing is a non-closed interval [)\n        else:\n            logger.error(\"vad_filter_features(): VAD labels should be the same length as energy bands\")\n\n        logger.info(\"vad_filter_features(): filtered_features shape: %s\", str(filtered_features.shape))\n\n    return filtered_features", "response": "Filter the features of a VAD file."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef solve_sweep_structure(\n        self,\n        structures,\n        sweep_param_list,\n        filename=\"structure_n_effs.dat\",\n        plot=True,\n        x_label=\"Structure number\",\n        fraction_mode_list=[],\n    ):\n        \"\"\"\n        Find the modes of many structures.\n\n        Args:\n            structures (list): A list of `Structures` to find the modes\n                of.\n            sweep_param_list (list): A list of the parameter-sweep sweep\n                that was used.  This is for plotting purposes only.\n            filename (str): The nominal filename to use when saving the\n                effective indices.  Defaults to 'structure_n_effs.dat'.\n            plot (bool): `True` if plots should be generates,\n                otherwise `False`.  Default is `True`.\n            x_label (str): x-axis text to display in the plot.\n            fraction_mode_list (list): A list of mode indices of the modes\n                that should be included in the TE/TM mode fraction plot.\n                If the list is empty, all modes will be included.  The list\n                is empty by default.\n\n        Returns:\n            list: A list of the effective indices found for each structure.\n        \"\"\"\n        n_effs = []\n        mode_types = []\n        fractions_te = []\n        fractions_tm = []\n        for s in tqdm.tqdm(structures, ncols=70):\n            self.solve(s)\n            n_effs.append(np.real(self.n_effs))\n            mode_types.append(self._get_mode_types())\n            fractions_te.append(self.fraction_te)\n            fractions_tm.append(self.fraction_tm)\n\n        if filename:\n            self._write_n_effs_to_file(\n                n_effs, self._modes_directory + filename, sweep_param_list\n            )\n\n            with open(self._modes_directory + \"mode_types.dat\", \"w\") as fs:\n                header = \",\".join(\n                    \"Mode%i\" % i for i, _ in enumerate(mode_types[0])\n                )\n                fs.write(\"# \" + header + \"\\n\")\n                for mt in mode_types:\n                    txt = \",\".join(\"%s %.2f\" % pair for pair in mt)\n                    fs.write(txt + \"\\n\")\n\n            with open(self._modes_directory + \"fraction_te.dat\", \"w\") as fs:\n                header = \"fraction te\"\n                fs.write(\"# param sweep,\" + header + \"\\n\")\n                for param, fte in zip(sweep_param_list, fractions_te):\n                    txt = \"%.6f,\" % param\n                    txt += \",\".join(\"%.2f\" % f for f in fte)\n                    fs.write(txt + \"\\n\")\n\n            with open(self._modes_directory + \"fraction_tm.dat\", \"w\") as fs:\n                header = \"fraction tm\"\n                fs.write(\"# param sweep,\" + header + \"\\n\")\n                for param, ftm in zip(sweep_param_list, fractions_tm):\n                    txt = \"%.6f,\" % param\n                    txt += \",\".join(\"%.2f\" % f for f in ftm)\n                    fs.write(txt + \"\\n\")\n\n            if plot:\n                if MPL:\n                    title = \"$n_{eff}$ vs %s\" % x_label\n                    y_label = \"$n_{eff}$\"\n                else:\n                    title = \"n_{effs} vs %s\" % x_label\n                    y_label = \"n_{eff}\"\n                self._plot_n_effs(\n                    self._modes_directory + filename, self._modes_directory + \"fraction_te.dat\", x_label, y_label, title\n                )\n\n                title = \"TE Fraction vs %s\" % x_label\n                self._plot_fraction(\n                    self._modes_directory + \"fraction_te.dat\",\n                    x_label,\n                    \"TE Fraction [%]\",\n                    title,\n                    fraction_mode_list,\n                )\n\n                title = \"TM Fraction vs %s\" % x_label\n                self._plot_fraction(\n                    self._modes_directory + \"fraction_tm.dat\",\n                    x_label,\n                    \"TM Fraction [%]\",\n                    title,\n                    fraction_mode_list,\n                )\n\n        return n_effs", "response": "Solve the structures and save the effective indices in the mode types."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef solve_sweep_wavelength(\n        self,\n        structure,\n        wavelengths,\n        filename=\"wavelength_n_effs.dat\",\n        plot=True,\n    ):\n        \"\"\"\n        Solve for the effective indices of a fixed structure at\n        different wavelengths.\n\n        Args:\n            structure (Slabs): The target structure to solve\n                for modes.\n            wavelengths (list): A list of wavelengths to sweep\n                over.\n            filename (str): The nominal filename to use when saving the\n                effective indices.  Defaults to 'wavelength_n_effs.dat'.\n            plot (bool): `True` if plots should be generates,\n                otherwise `False`.  Default is `True`.\n\n        Returns:\n            list: A list of the effective indices found for each wavelength.\n        \"\"\"\n        n_effs = []\n        for w in tqdm.tqdm(wavelengths, ncols=70):\n            structure.change_wavelength(w)\n            self.solve(structure)\n            n_effs.append(np.real(self.n_effs))\n\n        if filename:\n            self._write_n_effs_to_file(\n                n_effs, self._modes_directory + filename, wavelengths\n            )\n            if plot:\n                if MPL:\n                    title = \"$n_{eff}$ vs Wavelength\"\n                    y_label = \"$n_{eff}$\"\n                else:\n                    title = \"n_{effs} vs Wavelength\" % x_label\n                    y_label = \"n_{eff}\"\n                self._plot_n_effs(\n                    self._modes_directory + filename,\n                    self._modes_directory + \"fraction_te.dat\",\n                    \"Wavelength\",\n                    \"n_{eff}\",\n                    title,\n                )\n\n        return n_effs", "response": "Solve for the effective indices of a fixed structure at\n        different wavelengths."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef solve_ng(self, structure, wavelength_step=0.01, filename=\"ng.dat\"):\n        wl_nom = structure._wl\n\n        self.solve(structure)\n        n_ctrs = self.n_effs\n\n        structure.change_wavelength(wl_nom - wavelength_step)\n        self.solve(structure)\n        n_bcks = self.n_effs\n\n        structure.change_wavelength(wl_nom + wavelength_step)\n        self.solve(structure)\n        n_frws = self.n_effs\n\n        n_gs = []\n        for n_ctr, n_bck, n_frw in zip(n_ctrs, n_bcks, n_frws):\n            n_gs.append(\n                n_ctr - wl_nom * (n_frw - n_bck) / (2 * wavelength_step)\n            )\n\n        if filename:\n            with open(self._modes_directory + filename, \"w\") as fs:\n                fs.write(\"# Mode idx, Group index\\n\")\n                for idx, n_g in enumerate(n_gs):\n                    fs.write(\"%i,%.3f\\n\" % (idx, np.round(n_g.real, 3)))\n\n        return n_gs", "response": "r Solve for the group index and the group index of a structure at a particular wavelength."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nwriting the mode fields to a file and optionally plots them.", "response": "def write_modes_to_file(self, filename=\"mode.dat\", plot=True, analyse=True):\n        \"\"\"\n        Writes the mode fields to a file and optionally plots them.\n\n        Args:\n            filename (str): The nominal filename to use for the saved\n                data.  The suffix will be automatically be changed to\n                identifiy each mode number.  Default is 'mode.dat'\n            plot (bool): `True` if plots should be generates,\n                otherwise `False`.  Default is `True`.\n            analyse (bool): `True` if an analysis on the fundamental\n                mode should be performed.  The analysis adds to the\n                plot of the fundamental mode the power mode-field\n                diameter (MFD) and marks it on the output, and it\n                marks with a cross the maximum E-field value.\n                Default is `True`.\n\n        Returns:\n            dict: A dictionary containing the effective indices\n            and mode field profiles (if solved for).\n        \"\"\"\n        modes_directory = \"./modes_semi_vec/\"\n        if not os.path.isdir(modes_directory):\n            os.mkdir(modes_directory)\n        filename = modes_directory + filename\n\n        for i, mode in enumerate(self._ms.modes):\n            filename_mode = self._get_mode_filename(\n                self._semi_vectorial_method, i, filename\n            )\n            self._write_mode_to_file(np.real(mode), filename_mode)\n\n            if plot:\n                if i == 0 and analyse:\n                    A, centre, sigma_2 = anal.fit_gaussian(\n                        self._structure.xc, self._structure.yc, np.abs(mode)\n                    )\n                    subtitle = (\n                        \"E_{max} = %.3f, (x_{max}, y_{max}) = (%.3f, %.3f), MFD_{x} = %.3f, \"\n                        \"MFD_{y} = %.3f\"\n                    ) % (A, centre[0], centre[1], sigma_2[0], sigma_2[1])\n                    self._plot_mode(\n                        self._semi_vectorial_method,\n                        i,\n                        filename_mode,\n                        self.n_effs[i],\n                        subtitle,\n                        sigma_2[0],\n                        sigma_2[1],\n                        centre[0],\n                        centre[1],\n                        wavelength=self._structure._wl,\n                    )\n                else:\n                    self._plot_mode(\n                        self._semi_vectorial_method,\n                        i,\n                        filename_mode,\n                        self.n_effs[i],\n                        wavelength=self._structure._wl,\n                    )\n\n        return self.modes"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nwrites the mode fields to a file.", "response": "def write_modes_to_file(\n        self,\n        filename=\"mode.dat\",\n        plot=True,\n        fields_to_write=(\"Ex\", \"Ey\", \"Ez\", \"Hx\", \"Hy\", \"Hz\"),\n    ):\n        \"\"\"\n        Writes the mode fields to a file and optionally plots them.\n\n        Args:\n            filename (str): The nominal filename to use for the saved\n                data.  The suffix will be automatically be changed to\n                identifiy each field and mode number.  Default is\n                'mode.dat'\n            plot (bool): `True` if plots should be generates,\n                otherwise `False`.  Default is `True`.\n            fields_to_write (tuple): A tuple of strings where the\n                strings can be 'Ex', 'Ey', 'Ez', 'Hx', 'Hy' and 'Hz'\n                defining what part of the mode should be saved and\n                plotted.  By default, all six components are written\n                and plotted.\n\n        Returns:\n            dict: A dictionary containing the effective indices\n            and mode field profiles (if solved for).\n        \"\"\"\n        modes_directory = self._modes_directory\n\n        # Mode info file.\n        with open(modes_directory + \"mode_info\", \"w\") as fs:\n            fs.write(\"# Mode idx, Mode type, % in major direction, n_eff\\n\")\n            for i, (n_eff, (mode_type, percentage)) in enumerate(\n                zip(self.n_effs, self.mode_types)\n            ):\n                mode_idx = str(i)\n                line = \"%s,%s,%.2f,%.3f\" % (\n                    mode_idx,\n                    mode_type,\n                    percentage,\n                    n_eff.real,\n                )\n                fs.write(line + \"\\n\")\n\n        # Mode field plots.\n        for i, (mode, areas) in enumerate(zip(self._ms.modes, self.overlaps)):\n            mode_directory = \"%smode_%i/\" % (modes_directory, i)\n            if not os.path.isdir(mode_directory):\n                os.mkdir(mode_directory)\n            filename_full = mode_directory + filename\n\n            for (field_name, field_profile), area in zip(\n                mode.fields.items(), areas\n            ):\n                if field_name in fields_to_write:\n                    filename_mode = self._get_mode_filename(\n                        field_name, i, filename_full\n                    )\n                    self._write_mode_to_file(\n                        np.real(field_profile), filename_mode\n                    )\n                    if plot:\n                        self._plot_mode(\n                            field_name,\n                            i,\n                            filename_mode,\n                            self.n_effs[i],\n                            area=area,\n                            wavelength=self._structure._wl,\n                        )\n\n        return self.modes"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set_required(field, render_kw=None, force=False):\n    if render_kw is None:\n        render_kw = {}\n    if 'required' in render_kw and not force:\n        return render_kw\n    if field.flags.required:\n        render_kw['required'] = True\n    return render_kw", "response": "Sets the required key for the given field."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsets the invalid CSS class for the a ArcGIS field.", "response": "def set_invalid(field, render_kw=None):\n    \"\"\"\n    Returns *render_kw* with `invalid` added to *class* on validation errors.\n\n    Set (or appends) 'invalid' to the fields CSS class(es), if the *field* got\n    any errors. 'invalid' is also set by browsers if they detect errors on a\n    field.\n\n    \"\"\"\n    if render_kw is None:\n        render_kw = {}\n    if field.errors:\n        classes = render_kw.get('class') or render_kw.pop('class_', '')\n        if classes:\n            render_kw['class'] = 'invalid {}'.format(classes)\n        else:\n            render_kw['class'] = 'invalid'\n    return render_kw"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsetting min and max keys for a SequenceField.", "response": "def set_minmax(field, render_kw=None, force=False):\n    \"\"\"\n    Returns *render_kw* with *min* and *max* set if validators use them.\n\n    Sets *min* and / or *max* keys if a `Length` or `NumberRange` validator is\n    using them.\n\n    ..note::\n\n        This won't change keys already present unless *force* is used.\n\n    \"\"\"\n    if render_kw is None:\n        render_kw = {}\n    for validator in field.validators:\n        if isinstance(validator, MINMAX_VALIDATORS):\n            if 'min' not in render_kw or force:\n                v_min = getattr(validator, 'min', -1)\n                if v_min not in (-1, None):\n                    render_kw['min'] = v_min\n            if 'max' not in render_kw or force:\n                v_max = getattr(validator, 'max', -1)\n                if v_max not in (-1, None):\n                    render_kw['max'] = v_max\n    return render_kw"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting the title of the page.", "response": "def set_title(field, render_kw=None):\n    \"\"\"\n    Returns *render_kw* with *min* and *max* set if required.\n\n    If the field got a *description* but no *title* key is set, the *title* is\n    set to *description*.\n\n    \"\"\"\n    if render_kw is None:\n        render_kw = {}\n    if 'title' not in render_kw and getattr(field, 'description'):\n        render_kw['title'] = '{}'.format(field.description)\n    return render_kw"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a dictionary containing keyword arguments for the HTML5 language.", "response": "def get_html5_kwargs(field, render_kw=None, force=False):\n    \"\"\"\n    Returns a copy of *render_kw*  with keys added for a bound *field*.\n\n    If some *render_kw* are given, the new keys are added to a copy of them,\n    which is then returned. If none are given, a dictionary containing only\n    the automatically generated keys is returned.\n\n    .. important::\n\n        This might add new keys but won't changes any values if a key is\n        already in *render_kw*,  unless *force* is used.\n\n    Raises:\n\n        ValueError: if *field* is an :cls:`UnboundField`.\n\n    The following keys are set automatically:\n\n    :required:\n        Sets the *required* key if the `required` flag is set for the\n        field (this is mostly the case if it is set by validators). The\n        `required` attribute is used by browsers to indicate a required field.\n\n    :invalid:\n        Set (or appends) 'invalid' to the fields CSS class(es), if the *field*\n        got any errors. 'invalid' is also set by browsers if they detect\n        errors on a field.\n\n    :min / max:\n        Sets *min* and / or *max* keys if a `Length` or `NumberRange`\n        validator is using them.\n\n    :title:\n        If the field got a *description* but no *title* key is set, the\n        *title* is set to *description*.\n\n    \"\"\"\n    if isinstance(field, UnboundField):\n        msg = 'This function needs a bound field not: {}'\n        raise ValueError(msg.format(field))\n    kwargs = render_kw.copy() if render_kw else {}\n    kwargs = set_required(field, kwargs, force)  # is field required?\n    kwargs = set_invalid(field, kwargs)  # is field invalid?\n    kwargs = set_minmax(field, kwargs, force)  # check validators for min/max\n    kwargs = set_title(field, kwargs)  # missing tile?\n    return kwargs"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the rendered field after adding auto\u2013attributes.", "response": "def render_field(self, field, render_kw):\n        \"\"\"\n        Returns the rendered field after adding auto\u2013attributes.\n\n        Calls the field`s widget with the following kwargs:\n\n        1. the *render_kw* set on the field are used as based\n        2. and are updated with the *render_kw* arguments from the render call\n        3. this is used as an argument for a call to `get_html5_kwargs`\n        4. the return value of the call is used as final *render_kw*\n\n        \"\"\"\n        field_kw = getattr(field, 'render_kw', None)\n        if field_kw is not None:\n            render_kw = dict(field_kw, **render_kw)\n        render_kw = get_html5_kwargs(field, render_kw)\n        return field.widget(field, **render_kw)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef x(self):\n        '''\n        np.array: The grid points in x.\n        '''\n        if None not in (self.x_min, self.x_max, self.x_step) and \\\n                self.x_min != self.x_max:\n            x = np.arange(self.x_min, self.x_max+self.x_step-self.y_step*0.1, self.x_step)\n        else:\n            x = np.array([])\n        return x", "response": "np. array : The grid points in x."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef y(self):\n        '''\n        np.array: The grid points in y.\n        '''\n        if None not in (self.y_min, self.y_max, self.y_step) and \\\n                self.y_min != self.y_max:\n            y = np.arange(self.y_min, self.y_max-self.y_step*0.1, self.y_step)\n        else:\n            y = np.array([])\n        return y", "response": "np. array : The grid points in y."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef eps_func(self):\n        '''\n        function: a function that when passed a `x` and `y` values,\n            returns the permittivity profile of the structure,\n            interpolating if necessary.\n        '''\n        interp_real = interpolate.interp2d(self.x, self.y, self.eps.real)\n        interp_imag = interpolate.interp2d(self.x, self.y, self.eps.imag)\n        interp = lambda x, y: interp_real(x, y) + 1.j*interp_imag(x, y)\n        return interp", "response": "function that returns the permittivity profile of the structure"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef n_func(self):\n        '''\n        function: a function that when passed a `x` and `y` values,\n            returns the refractive index profile of the structure,\n            interpolating if necessary.\n        '''\n        return interpolate.interp2d(self.x, self.y, self.n)", "response": "function that returns the refractive index profile of the structure"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef write_to_file(self, filename='material_index.dat', plot=True):\n        '''\n        Write the refractive index profile to file.\n\n        Args:\n            filename (str): The nominal filename the refractive\n                index data should be saved to.\n            plot (bool): `True` if plots should be generates,\n                otherwise `False`.  Default is `True`.\n        '''\n        path = os.path.dirname(sys.modules[__name__].__file__) + '/'\n\n        with open(filename, 'w') as fs:\n            for n_row in np.abs(self.n[::-1]):\n                n_str = ','.join([str(v) for v in n_row])\n                fs.write(n_str+'\\n')\n\n        if plot:\n            filename_image_prefix, _ = os.path.splitext(filename)\n            filename_image = filename_image_prefix + '.png'\n            args = {\n                'title': 'Refractive Index Profile',\n                'x_pts': self.x_pts,\n                'y_pts': self.y_pts,\n                'x_min': self.x_min,\n                'x_max': self.x_max,\n                'y_min': self.y_min,\n                'y_max': self.y_max,\n                'filename_data': filename,\n                'filename_image': filename_image\n            }\n\n            if MPL:\n                heatmap = np.loadtxt(args['filename_data'], delimiter=',')\n                plt.clf()\n                plt.title(args['title'])\n                plt.xlabel('$x$')\n                plt.ylabel('$y$')\n                plt.imshow(np.flipud(heatmap),\n                           extent=(args['x_min'], args['x_max'], args['y_min'], args['y_max']),\n                           aspect=\"auto\")\n                plt.colorbar()\n                plt.savefig(filename_image)\n            else:\n                gp.gnuplot(path+'structure.gpi', args)", "response": "Writes the refractive index profile to file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef add_slab(self, height, n_background=1., position='top'):\n        '''\n        Creates and adds a :class:`Slab` object.\n\n        Args:\n            height (float): Height of the slab.\n            n_background (float): The nominal refractive\n                index of the slab.  Default is 1 (air).\n\n        Returns:\n            str: The name of the slab.\n        '''\n        assert position in ('top', 'bottom')\n\n        name = str(self.slab_count)\n\n        if not callable(n_background):\n            n_back = lambda wl: n_background\n        else:\n            n_back = n_background\n\n        height_discretised = self.y_step*((height // self.y_step) + 1)\n\n        y_min = self._next_start\n        y_max = y_min + height_discretised\n        self.slabs[name] = Slab(name, self.x_step, self.y_step, self.x_max,\n                                 y_max, self.x_min, y_min, n_back, self._wl)\n\n        self.y_max = y_max\n        self._next_start = y_min + height_discretised\n        self.slab_count += 1\n\n        if position == 'bottom':\n            slabs = {}\n            for k in self.slabs.keys():\n                slabs[str(int(k)+1)] = self.slabs[k]\n            slabs['0'] = slabs.pop(str(self.slab_count))\n            self.slabs = slabs\n\n        return name", "response": "Creates and adds a new slab object."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nchange the wavelength of the structure.", "response": "def change_wavelength(self, wavelength):\n        '''\n        Changes the wavelength of the structure.\n\n        This will affect the mode solver and potentially\n        the refractive indices used (provided functions\n        were provided as refractive indices).\n\n        Args:\n            wavelength (float): The new wavelength.\n        '''\n        for name, slab in self.slabs.items():\n            const_args = slab._const_args\n            mat_args = slab._mat_params\n\n            const_args[8] = wavelength\n\n            s = Slab(*const_args)\n            for mat_arg in mat_args:\n                s.add_material(*mat_arg)\n\n            self.slabs[name] = s\n\n        self._wl = wavelength"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef n(self):\n        '''\n        np.array: The refractive index profile matrix\n        of the current slab.\n        '''\n        try:\n            n_mat = self.slabs['0'].n\n            for s in range(1, self.slab_count):\n                n_mat = np.vstack((self.slabs[str(s)].n, n_mat))\n        except KeyError:\n            n_mat = None\n        return n_mat", "response": "Return the refractive index profile matrix of the current slab."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nadd a material to the structure.", "response": "def add_material(self, x_min, x_max, n, angle=0):\n        '''\n        Add a refractive index between two x-points.\n\n        Args:\n            x_min (float): The start x-point.\n            x_max (float): The stop x-point.\n            n (float, function):  Refractive index between\n                 `x_min` and `x_max`.  Either a constant (`float`), or\n                 a function that accepts one parameters, the\n                 wavelength, and returns a float of the refractive\n                 index.  This is useful when doing wavelength\n                 sweeps and solving for the group velocity.  The\n                 function provided could be a Sellmeier equation.\n            angle (float): Angle in degrees of the slope of the\n                sidewalls at `x_min` and `x_max`.  This is useful\n                for defining a ridge with angled sidewalls.\n        '''\n        self._mat_params.append([x_min, x_max, n, angle])\n\n        if not callable(n):\n            n_mat = lambda wl: n\n        else:\n            n_mat = n\n\n        Structure._add_material(self, x_min, self.y_min, x_max, self.y_max, n_mat(self._wl), angle)\n        return self.n"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nwriting the refractive index profile to file.", "response": "def write_to_file(self, filename='material_index.dat', plot=True):\n        '''\n        Write the refractive index profile to file.\n\n        Args:\n            filename (str): The nominal filename the refractive\n                index data should be saved to.\n            plot (bool): `True` if plots should be generates,\n                otherwise `False`.  Default is `True`.\n        '''\n        path = os.path.dirname(sys.modules[__name__].__file__) + '/'\n\n        dir_plot = 'material_index/'\n        if not os.path.exists(dir_plot):\n            os.makedirs(dir_plot)\n\n        for axis, name in zip(self.axes, self.axes_str):\n            root, ext = os.path.splitext(filename)\n            fn = dir_plot + root + '_'+ name + ext\n            with open(fn, 'w') as fs:\n                for n_row in np.abs(axis.n[::-1]):\n                    n_str = ','.join([str(v) for v in n_row])\n                    fs.write(n_str+'\\n')\n\n            if plot:\n                filename_image_prefix, _ = os.path.splitext(fn)\n                filename_image = filename_image_prefix + '.png'\n                args = {\n                    'title': 'Refractive Index Profile: %s' % name,\n                    'x_pts': self.xx.x_pts,\n                    'y_pts': self.xx.y_pts,\n                    'x_min': self.xx.x_min,\n                    'x_max': self.xx.x_max,\n                    'y_min': self.xx.y_min,\n                    'y_max': self.xx.y_max,\n                    'filename_data': fn,\n                    'filename_image': filename_image\n                }\n                if MPL:\n                    heatmap = np.loadtxt(args['filename_data'], delimiter=',')\n                    plt.clf()\n                    plt.title(args['title'])\n                    plt.xlabel('$x$')\n                    plt.ylabel('$y$')\n                    plt.imshow(np.flipud(heatmap),\n                               extent=(args['x_min'], args['x_max'], args['y_min'], args['y_max']),\n                               aspect=\"auto\")\n                    plt.colorbar()\n                    plt.savefig(filename_image)\n                else:\n                    gp.gnuplot(path+'structure.gpi', args, silent=False)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nchanging the wavelength of the structure.", "response": "def change_wavelength(self, wavelength):\n        '''\n        Changes the wavelength of the structure.\n\n        This will affect the mode solver and potentially\n        the refractive indices used (provided functions\n        were provided as refractive indices).\n\n        Args:\n            wavelength (float): The new wavelength.\n        '''\n        for axis in self.axes:\n            if issubclass(type(axis), Slabs):\n                axis.change_wavelength(wavelength)\n        self.xx, self.xy, self.yx, self.yy, self.zz = self.axes\n        self._wl = wavelength"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef covstr(s):\n  try:\n    ret = int(s)\n  except ValueError:\n    ret = float(s)\n  return ret", "response": "convert string to int or float."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef output(self):\n    #re = \"{%(time)s} %(name)s %(stock_no)s %(c)s %(range)+.2f(%(pp)+.2f%%) %(value)s\" % {\n    '''\n    re = \"\"\"<table>\n            <tr><td>%(name)s</td><td>%(c)s</td><td>%(range)+.2f(%(pp)+.2f%%)</td></tr>\n            <tr><td>%(stock_no)s</td><td>%(value)s</td><td>%(time)s</td></tr></table>\"\"\" % {\n    '''\n    if covstr(self.g['range']) > 0:\n      css = \"red\"\n    elif covstr(self.g['range']) < 0:\n      css = \"green\"\n    else:\n      css = \"gray\"\n\n    re = {\n      'name': self.g['name'],\n      'stock_no': self.g['no'],\n      'time': self.g['time'],\n      'open': self.g['open'],\n      'h': self.g['h'],\n      'l': self.g['l'],\n      'c': self.g['c'],\n      'max': self.g['max'],\n      'min': self.g['min'],\n      'range': covstr(self.g['range']),\n      'ranges': self.g['ranges'],\n      'value': self.g['value'],\n      'pvalue': self.g['pvalue'],\n      'pp': covstr(self.g['pp']),\n      'top5buy': self.g['top5buy'],\n      'top5sell': self.g['top5sell'],\n      'crosspic': self.g['crosspic'],\n      'css': css\n    }\n    return re", "response": "Return the output string for the sequence of n - stocks."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef Rt_display(stock_no):\n  a = twsk(stock_no).real\n  if a:\n    re = \"{%(time)s} %(stock_no)s %(c)s %(range)+.2f(%(pp)+.2f%%) %(value)s\" % {\n        'stock_no': stock_no,\n        'time': a['time'],\n        'c': a['c'],\n        'range': covstr(a['range']),\n        'value': a['value'],\n        'pp': covstr(a['pp'])\n      }\n    return re\n  else:\n    return a", "response": "For real time stock display\n      \u5373\u6642\u76e4\u7528\uff0c\u986f\u793a\u76ee\u524d\u67e5\u8a62\u5404\u80a1\u7684\u80a1\u7684\u8cc7\u8a0a\u3002"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nchecks the value is date or not", "response": "def ckinv(self,oo):\n    \"\"\" check the value is date or not\n        \u6aa2\u67e5\u662f\u5426\u70ba\u65e5\u671f\u683c\u5f0f\n    \"\"\"\n    pattern = re.compile(r\"[0-9]{2}/[0-9]{2}/[0-9]{2}\")\n    b = re.search(pattern, oo[0])\n    try:\n      b.group()\n      return True\n    except:\n      return False"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning \u2191\u2193 - for high or low or equal.", "response": "def high_or_low(self,one,two,rev=0):\n    \"\"\" Return \u2191\u2193- for high, low or equal.\n        \u56de\u50b3\u6f32\u8dcc\u6a19\u793a\n        rev = 0\n          \u56de\u50b3 \u2191\u2193-\n        rev = 1\n          \u56de\u50b3 1 -1 0\n    \"\"\"\n    if rev == 0:\n      if one > two:\n        re = '\u2191'.decode('utf-8')\n      elif one < two:\n        re = '\u2193'.decode('utf-8')\n      else:\n        re = '-'.decode('utf-8')\n    else:\n      if one > two:\n        re = 1\n      elif one < two:\n        re = -1\n      else:\n        re = 0\n    return re"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef goback(self,days = 1):\n    for i in xrange(days):\n      self.raw_data.pop()\n      self.data_date.pop()\n      self.stock_range.pop()\n      self.stock_vol.pop()\n      self.stock_open.pop()\n      self.stock_h.pop()\n      self.stock_l.pop()", "response": "Go back days\n        \u522a\u9664\u6700\u65b0\u5929\u6578\u8cc7\u6599\u6578\u64da\n        days \u4ee3\u8868\u522a\u9664\u591a\u5c11\u5929\u6578\uff08\u5012\u9000\u5e7e\u5929\uff09"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nfetch data from twse. com. tw", "response": "def fetch_data(self, stock_no, nowdatetime, firsttime = 1):\n    \"\"\" Fetch data from twse.com.tw\n        return list.\n        \u5f9e twse.com.tw \u4e0b\u8f09\u8cc7\u6599\uff0c\u56de\u50b3\u683c\u5f0f\u70ba list\n    \"\"\"\n    url = 'http://www.twse.com.tw/ch/trading/exchange/STOCK_DAY/STOCK_DAY_print.php?genpage=genpage/Report%(year)d%(mon)02d/%(year)d%(mon)02d_F3_1_8_%(stock)s.php&type=csv&r=%(rand)s' % {'year': nowdatetime.year, 'mon': nowdatetime.month, 'stock': stock_no, 'rand': random.randrange(1,1000000)}\n    self.debug_print(url)\n    logging.info(url)\n    #print cc.info().headers\n\n    # set memcache expire\n    now = TWTime().now\n    if now >= datetime(now.year, now.month, now.day, 14, 45):\n      addday = 1\n    else:\n      addday = 0\n    endtime = datetime(now.year, now.month, now.day, 14, 00) + timedelta(days = addday) ## change from 13:35 to 14:00\n    logging.info('endtime: %s' % str(endtime))\n\n    if firsttime == 0:\n      if endtime <= now:\n        expire = 'ALUP' ## always update.\n      else:\n        expire = (endtime - now).seconds\n    else:\n      expire = 0 ## never expire.\n    logging.info('expire: %s' % expire)\n\n    ## get memcache\n    memname = '%(stock)s%(year)d%(mon)02d' % {'year': nowdatetime.year, 'mon': nowdatetime.month,'stock': stock_no}\n    stkm = memcache.get(memname)\n    if stkm:\n      csv_read = csv.reader(stkm)\n      logging.info('#MemcacheGet: %s' % memname)\n    else:\n      cc = urllib2.urlopen(url)\n      cc_read = cc.readlines()\n      csv_read = csv.reader(cc_read)\n      if expire != 'ALUP':\n        memcache.add(memname, cc_read, expire)\n      else:\n        memcache.delete(memname)\n      memcache.add('time%s' % memname, '%s %s' % (now, expire))\n      logging.info('#MemcacheAdd: %s' % memname)\n\n    return csv_read"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nrange percentage of the last two words", "response": "def range_per(self):\n    \"\"\" Range percentage\n        \u8a08\u7b97\u6700\u65b0\u65e5\u4e4b\u6f32\u8dcc\u5e45\u5ea6\u767e\u5206\u6bd4\n    \"\"\"\n    rp = float((self.raw_data[-1] - self.raw_data[-2]) / self.raw_data[-2] * 100)\n    return rp"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef SD(self, days=45):\n    if len(self.raw_data) >= days:\n      data = self.raw_data[-days:]\n      data_avg = float(sum(data) / days)\n      data2 = []\n      for x in data:\n        data2.append((x - data_avg ) ** 2)\n\n      return math.sqrt(sum(data2) / len(data2))\n    else:\n      return 0", "response": "Standard Deviation.\n        \u8a08\u7b97 days \u65e5\u5167\u4e4b\u6a19\u6e96\u5dee\uff0c\u9810\u8a2d 45 \u65e5"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef SDAVG(self, days=45):\n    if len(self.raw_data) >= days:\n      data = self.raw_data[-days:]\n      data_avg = float(sum(data) / days)\n      return data_avg\n    else:\n      return 0", "response": "the last 45 days average."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef CV(self, days=45):\n    if len(self.raw_data) >= days:\n      data_avg = sum(self.raw_data[-days:]) / days\n      return self.SD / data_avg\n    else:\n      return 0", "response": "Coefficient of Variation.\n        \u8a08\u7b97 days \u65e5\u5167\u4e4b\u8b8a\u7570\u6578\uff0c\u9810\u8a2d 45 \u65e5"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef TimeinOpen(self):\n    now = TWTime().now.hour\n    if now >= 9 and now <= 14:\n      return True\n    else:\n      return False", "response": "In open market time."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncalculates the MAC of the given number of days.", "response": "def MAC(self,days,rev = 0):\n    \"\"\" Comparing yesterday price is high, low or equal.\n        return \u2191,\u2193 or -\n        \u8207\u524d\u4e00\u5929 days \u65e5\u6536\u76e4\u50f9\u79fb\u52d5\u5e73\u5747\u6bd4\u8f03\n        rev = 0\n          \u56de\u50b3 \u2191,\u2193 or -\n        rev = 1\n          \u56de\u50b3 1,-1 or 0\n    \"\"\"\n    yesterday = self.raw_data[:]\n    yesterday.pop()\n    yes_MA = float(sum(yesterday[-days:]) / days)\n    today_MA = self.MA(days)\n\n    return self.high_or_low(today_MA, yes_MA, rev)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef MA_serial(self,days,rev=0):\n    return self.make_serial(self.raw_data,days,rev)", "response": "make_serial is a wrapper around make_serial"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncalculate the MACVOL of the given days", "response": "def MACVOL(self,days,rev=0):\n    \"\"\" Comparing yesterday volume is high, low or equal.\n        return \u2191,\u2193 or -\n        \u8207\u524d\u4e00\u5929 days \u65e5\u6210\u4ea4\u91cf\u79fb\u52d5\u5e73\u5747\u6bd4\u8f03\n        rev = 0\n          \u56de\u50b3 \u2191,\u2193 or -\n        rev = 1\n          \u56de\u50b3 1,-1 or 0\n    \"\"\"\n    yesterday = self.stock_vol[:]\n    yesterday.pop()\n    yes_MAVOL = float(sum(yesterday[-days:]) / days)\n    today_MAVOL = self.MAVOL(days)\n\n    return self.high_or_low(today_MAVOL, yes_MAVOL,rev)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nseeing make_serial() \u6210\u8f03\u91cf\u79fb\u52d5\u5e73\u5747 list \u5316\uff0c\u8cc7\u6599\u683c\u5f0f\u8acb\u898b def make_serial()", "response": "def MAVOL_serial(self,days,rev=0):\n    \"\"\" see make_serial()\n        \u6210\u8f03\u91cf\u79fb\u52d5\u5e73\u5747 list \u5316\uff0c\u8cc7\u6599\u683c\u5f0f\u8acb\u898b def make_serial()\n    \"\"\"\n    return self.make_serial(self.stock_vol,days,rev=0)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef VOLMAX3(self):\n    if self.stock_vol[-1] > self.stock_vol[-2] and self.stock_vol[-1] > self.stock_vol[-3]:\n      return True\n    else:\n      return False", "response": "Check if volume is the max in last 3 days."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn ABC \u8f49\u6298\u9ede ABC", "response": "def RABC(self):\n    \"\"\" Return ABC\n        \u8f49\u6298\u9ede ABC\n    \"\"\"\n    A = self.raw_data[-3]*2 - self.raw_data[-6]\n    B = self.raw_data[-2]*2 - self.raw_data[-5]\n    C = self.raw_data[-1]*2 - self.raw_data[-4]\n    return '(%.2f,%.2f,%.2f)' % (A,B,C)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef make_serial(self,data,days,rev=0):\n    raw = data[:]\n    result = []\n    try:\n      while len(raw) >= days:\n        result.append(float(sum(raw[-days:]) / days))\n        raw.pop()\n        self.debug_print(len(result))\n\n      result.reverse()\n      re = [self.cum_serial(result,rev), result]\n      return re\n    except:\n      return '?'", "response": "make data in list\nAddon"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef cum_serial(self, raw,rev=0):\n    org = raw[1:]\n    diff = raw[:-1]\n    result = []\n    for i in xrange(len(org)):\n      result.append(self.high_or_low(org[i], diff[i],rev))\n\n    times = 0\n    try:\n      if result[-1] == result[-2]:\n        signal = result[-1]\n        re_signal = result[:]\n        try:\n          while signal == re_signal[-1]:\n            re_signal.pop()\n            times += 1\n        except:\n          pass\n      else:\n        times += 1\n    except:\n      times = '?'\n\n    if self.debug:\n      for i in result:\n        print i\n\n    self.debug_print(times)\n    return times", "response": "Cumulate serial data\n        and return times(int)\n        \u8a08\u7b97\u6578\u64da\u91cd\u8907\uff08\u6301\u7e8c\uff09\u6b21\u6578"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndisplay the data in a single line.", "response": "def display(self,*arg):\n    \"\"\" For simple Demo\n        \u6e2c\u8a66\u7528\u986f\u793a\u6a23\u5f0f\u3002\n    \"\"\"\n    print self.stock_name,self.stock_no\n    print '%s %s %s(%+.2f%%)' % (self.data_date[-1],self.raw_data[-1],self.stock_range[-1],self.range_per)\n    for i in arg:\n      print ' - MA%02s  %.2f %s(%s)' % (i,self.MA(i),self.MAC(i),self.MA_serial(i)[0])\n    print ' - Volume: %s %s(%s)' % (self.MAVOL(1)/1000,self.MACVOL(1),self.MAVOL_serial(1)[0])\n    MAO = self.MAO(3,6)\n    print ' - MAO(3-6): %.2f %s(%s)' % (MAO[0][1][-1], MAO[1], MAO[0][0])\n    print ' - RABC: %s' % self.RABC"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef XMPP_display(self,*arg):\n\n    MA = ''\n    for i in arg:\n      MAs = '- MA%02s: %.2f %s(%s)\\n' % (\n        unicode(i),\n        self.MA(i),\n        self.MAC(i),\n        unicode(self.MA_serial(i)[0])\n      )\n      MA = MA + MAs\n\n    vol = '- Volume: %s %s(%s)' % (\n      unicode(self.MAVOL(1)/1000),\n      unicode(self.MACVOL(1)),\n      unicode(self.MAVOL_serial(1)[0])\n    )\n\n    MAO = self.MAO(3,6)\n\n    re = \"\"\"%(stock_name)s %(stock_no)s\n%(stock_date)s: %(stock_price)s %(stock_range)s(%(range_per)+.2f%%)\n%(MA)s%(vol)s\n- MAO(3-6): %(MAO_v).2f %(MAO_c)s(%(MAO_times)s)\n- RABC: %(RABC)s\"\"\" % {\n        'stock_name': unicode(self.stock_name),\n        'stock_no': unicode(self.stock_no),\n        'stock_date': unicode(self.data_date[-1]),\n        'stock_price': unicode(self.raw_data[-1]),\n        'stock_range': unicode(self.stock_range[-1]),\n        'range_per': self.range_per,\n        'MA': MA,\n        'vol': vol,\n        'MAO_v': MAO[0][1][-1],\n        'MAO_c': unicode(MAO[1]),\n        'MAO_times': unicode(MAO[0][0]),\n        'RABC': self.RABC\n      }\n\n    return re", "response": "Display the data in XMPP Demo."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef Task_display(self):\n    re = \"\"\"%(stock_name)s %(stock_no)s %(stock_date)s\nToday: %(stock_price)s %(stock_range)s\n=-=-=-=\"\"\" % {\n        'stock_name': unicode(self.stock_name),\n        'stock_no': unicode(self.stock_no),\n        'stock_date': unicode(self.data_date[-1]),\n        'stock_price': unicode(self.raw_data[-1]),\n        'stock_range': unicode(self.stock_range[-1]),\n      }\n    return re", "response": "For Task overall stock display\n        \u986f\u793a\u8cc7\u8a0a\u6a23\u5f0f\u4e4b\u4e00\uff0c\u5169\u884c\u8cc7\u8a0a\u3002"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef gchart(self, s = 0, size = [], candle = 20):\n    if s == 0:\n      s = len(self.raw_data)\n    if len(size) == 2:\n      sw,sh = size\n    else:\n      sh = 300\n      sw = 25 * s\n      if sw > 1000:\n        sw = 1000\n        candle = 950/s\n\n    stc = ''\n    for i in self.raw_data[-s:]:\n      stc += str(i) + ','\n    sto = ''\n    for i in self.stock_open[-s:]:\n      sto += str(i) + ','\n    sth = ''\n    for i in self.stock_h[-s:]:\n      sth += str(i) + ','\n    stl = ''\n    for i in self.stock_l[-s:]:\n      stl += str(i) + ','\n    stdate = ''\n    for i in self.data_date[-s:]:\n      stdate += str(i[-2:]) + '|'\n\n    stmax = max(self.stock_h[-s:])\n    stmin = min(self.stock_l[-s:])\n    strange = (stmax-stmin) / 10\n\n    re = \"http://%(rand)s.chart.apis.google.com/chart?chs=%(sw)sx%(sh)s&cht=lc&chd=t1:0,0,0|0,%(h)s0|0,%(c)s0|0,%(o)s0|0,%(l)s0&chm=F,,1,1:-1,%(candle)s&chxt=y,x&chds=%(min)s,%(max)s&chxr=0,%(min)s,%(max)s,%(range)s&chg=20,%(chg)s&chtt=%(chtt)s&chxl=1:||%(chxl)s\" % {\n      'h': sth,\n      'c': stc,\n      'o': sto,\n      'l': stl,\n      'min': stmin,\n      'max': stmax,\n      'sw': sw,\n      'sh': sh,\n      'range': strange,\n      'candle': candle,\n      'chg': 10,\n      'rand': random.randint(0,9),\n      'chxl': stdate,\n      'chtt': '%s %s' % (self.stock_name,self.stock_no)\n    }\n    return re", "response": "Return a list of url to the Google Chart API"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef buy(self, no, price, value):\n    ''' \u8cb7 '''\n    self.money += -price*value\n    try:\n      self.store[no] += value\n    except:\n      self.store[no] = value\n    try:\n      self.avgprice[no]['buy'] += [price]\n    except:\n      try:\n        self.avgprice[no]['buy'] = [price]\n      except:\n        self.avgprice[no] = {}\n        self.avgprice[no]['buy'] = [price]", "response": "add buy price to store"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef sell(self, no, price, value):\n    ''' \u8ce3 '''\n    self.money += price*value\n    try:\n      self.store[no] += -value\n    except:\n      self.store[no] = -value\n    try:\n      self.avgprice[no]['sell'] += [price]\n    except:\n      try:\n        self.avgprice[no]['sell'] = [price]\n      except:\n        self.avgprice[no] = {}\n        self.avgprice[no]['sell'] = [price]", "response": "update the amount of the article with the given price"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef showinfo(self):\n    ''' \u7e3d\u89bd\u986f\u793a '''\n    print 'money:',self.money\n    print 'store:',self.store\n    print 'avgprice:',self.avgprice", "response": "Prints information about the current state of the object."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsearching for the given stock number.", "response": "def search(self,q):\n    \"\"\" Search. \"\"\"\n    import re\n    pattern = re.compile(\"%s\" % q)\n    result = {}\n    for i in self.allstockno:\n      b = re.search(pattern, self.allstockno[i])\n      try:\n        b.group()\n        result[i] = self.allstockno[i]\n      except:\n        pass\n\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef solve(self, neigs=4, tol=0, guess=None, mode_profiles=True, initial_mode_guess=None):\n\n        from scipy.sparse.linalg import eigen\n\n        self.nmodes = neigs\n        self.tol = tol\n\n        A = self.build_matrix()\n\n        if guess is not None:\n            # calculate shift for eigs function\n            k = 2 * numpy.pi / self.wl\n            shift = (guess * k) ** 2\n        else:\n            shift = None\n\n        [eigvals, eigvecs] = eigen.eigs(A,\n                                        k=neigs,\n                                        which='LR',\n                                        tol=0.001,\n                                        ncv=None,\n                                        v0 = initial_mode_guess,\n                                        return_eigenvectors=mode_profiles,\n                                        sigma=shift)\n\n        neffs = self.wl * scipy.sqrt(eigvals) / (2 * numpy.pi)\n        if mode_profiles:\n            Hxs = []\n            Hys = []\n            nx = self.nx\n            ny = self.ny\n            for ieig in range(neigs):\n                Hxs.append(eigvecs[:nx * ny, ieig].reshape(nx, ny))\n                Hys.append(eigvecs[nx * ny:, ieig].reshape(nx, ny))\n\n        # sort the modes\n        idx = numpy.flipud(numpy.argsort(neffs))\n        neffs = neffs[idx]\n        self.neff = neffs\n        if mode_profiles:\n            tmpx = []\n            tmpy = []\n            for i in idx:\n                tmpx.append(Hxs[i])\n                tmpy.append(Hys[i])\n            Hxs = tmpx\n            Hys = tmpy\n\n            [Hzs, Exs, Eys, Ezs] = self.compute_other_fields(neffs, Hxs, Hys)\n\n            self.modes = []\n            for (neff, Hx, Hy, Hz, Ex, Ey, Ez) in zip(neffs, Hxs, Hys, Hzs, Exs, Eys, Ezs):\n                self.modes.append(\n                    FDMode(self.wl, self.x, self.y, neff, Ey, Ex, Ez, Hy, Hx, Hz).normalize())\n\n        return self", "response": "This function solves the VFD mode for a specific set of eigenmodes."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef real(self):\n    try:\n      unch = sum([covstr(self.stock[3]),covstr(self.stock[4])])/2\n      re = {'name': unicode(self.stock[36].replace(' ',''), 'cp950'),\n            'no': self.stock[0],\n            'range': self.stock[1],\n            'time': self.stock[2],\n            'max': self.stock[3],\n            'min': self.stock[4],\n            'unch': '%.2f' % unch,\n            'pp': '%.2f' % ((covstr(self.stock[8]) - unch)/unch*100),\n            'open': self.stock[5],\n            'h': self.stock[6],\n            'l': self.stock[7],\n            'c': self.stock[8],\n            'value': self.stock[9],\n            'pvalue': self.stock[10],\n            'top5buy': [\n                (self.stock[11], self.stock[12]),\n                (self.stock[13], self.stock[14]),\n                (self.stock[15], self.stock[16]),\n                (self.stock[17], self.stock[18]),\n                (self.stock[19], self.stock[20])\n              ],\n            'top5sell': [\n                (self.stock[21], self.stock[22]),\n                (self.stock[23], self.stock[24]),\n                (self.stock[25], self.stock[26]),\n                (self.stock[27], self.stock[28]),\n                (self.stock[29], self.stock[30])\n              ]\n            }\n\n      if '-' in self.stock[1]:\n        re['ranges'] = False ## price down\n      else:\n        re['ranges'] = True ## price up\n\n      re['crosspic'] = \"http://chart.apis.google.com/chart?chf=bg,s,ffffff&chs=20x50&cht=ls&chd=t1:0,0,0|0,%s,0|0,%s,0|0,%s,0|0,%s,0&chds=%s,%s&chm=F,,1,1:4,20\" % (re['h'],re['c'],re['open'],re['l'],re['l'],re['h'])\n      re['top5buy'].sort()\n      re['top5sell'].sort()\n\n      return re\n    except:\n      return False", "response": "Return real time data"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ndisplaying Taiwan Time now \u986f\u793a\u53f0\u7063\u6b64\u523b\u6642\u9593", "response": "def now(self):\n    ''' Display Taiwan Time now\n        \u986f\u793a\u53f0\u7063\u6b64\u523b\u6642\u9593\n    '''\n    localtime = datetime.datetime.now()\n    return localtime + datetime.timedelta(hours = time.timezone/60/60 + self.TimeZone)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef date(self):\n    ''' Display Taiwan date now\n        \u986f\u793a\u53f0\u7063\u6b64\u523b\u65e5\u671f\n    '''\n    localtime = datetime.date.today()\n    return localtime + datetime.timedelta(hours = time.timezone/60/60 + self.TimeZone)", "response": "Display Taiwan date now\n        \u986f\u793a\u53f0\u7063\u6b64\u523b\u65e5\u671f"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef directional_coupler_lc(wavelength_nm, n_eff_1, n_eff_2):\n    '''\n    Calculates the coherence length (100% power transfer) of a\n    directional coupler.\n\n    Args:\n        wavelength_nm (float): The wavelength in [nm] the\n            directional coupler should operate at.\n        n_eff_1 (float): n_eff of the fundamental (even)\n            supermode of the directional coupler.\n        n_eff_2 (float): n_eff of the first-order (odd)\n            supermode of the directional coupler.\n\n    Returns:\n        float: The length [um] the directional coupler\n        needs to be to achieve 100% power transfer.\n\n    '''\n    wavelength_m = wavelength_nm * 1.e-9\n    dn_eff = (n_eff_1 - n_eff_2).real\n    lc_m = wavelength_m / (2. * dn_eff)\n    lc_um = lc_m * 1.e6\n    return lc_um", "response": "Calculates the coherence length of the directional coupler."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef grating_coupler_period(wavelength,\n                           n_eff,\n                           n_clad,\n                           incidence_angle_deg,\n                           diffration_order=1):\n    '''\n    Calculate the period needed for a grating coupler.\n\n    Args:\n        wavelength (float): The target wavelength for the\n            grating coupler.\n        n_eff (float): The effective index of the mode\n            of a waveguide with the width of the grating\n            coupler.\n        n_clad (float): The refractive index of the cladding.\n        incidence_angle_deg (float): The incidence angle\n            the grating coupler should operate at [degrees].\n        diffration_order (int): The grating order the coupler\n            should work at.  Default is 1st order (1).\n\n    Returns:\n        float: The period needed for the grating coupler\n        in the same units as the wavelength was given at.\n    '''\n    k0 = 2. * np.pi / wavelength\n    beta = n_eff.real * k0\n    n_inc = n_clad\n\n    grating_period = (2.*np.pi*diffration_order) \\\n        / (beta - k0*n_inc*np.sin(np.radians(incidence_angle_deg)))\n\n    return grating_period", "response": "Calculates the period needed for a grating coupler."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreading a file into a string.", "response": "def read_file(filename, prepend_paths=[]):\n  \"\"\"\n  Returns the contents of *filename* (UTF-8).\n\n  If *prepend_paths* is set, join those before the *fielname*.\n  If it is `True`, prepend the path to `setup.py`.\n\n  \"\"\"\n  if prepend_paths is True:\n    prepend_paths = [\n      os.path.abspath(os.path.dirname(__file__)),\n    ]\n  if prepend_paths:\n    prepend_paths.append(filename)\n    filename = os.path.join(*prepend_paths)\n  print(filename)\n  with open(filename, encoding='utf-8') as f:\n    return f.read()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef loaddate(self):\n    ''' \u8f09\u5165\u6a94\u6848\n        \u6a94\u6848\u4f9d\u64da http://www.twse.com.tw/ch/trading/trading_days.php\n    '''\n    ld = csv.reader(open('./%s/opendate.csv' % _CSVFILEPATH, 'r'))\n    re = {}\n    re['close'] = []\n    re['open'] = []\n\n    for i in ld:\n      ''' 0 = \u4f11\u5e02, 1 = \u958b\u5e02 '''\n      if i[1] == '0':\n        re['close'] += [datetime.strptime(i[0],'%Y/%m/%d').date()]\n      elif i[1] == '1':\n        re['open'] += [datetime.strptime(i[0],'%Y/%m/%d').date()]\n      else:\n        pass\n    return re", "response": "Load the date from CSV file."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning True if the object is open False if it is close True if it is open False if it is close True if it is open False if it is close False if it is not close", "response": "def ooc(self):\n    ''' Open or close\n        \u56de\u50b3 True\uff1a\u958b\u5e02\uff0cFalse\uff1a\u4f11\u5e02\u3002\n    '''\n    if self.ptime.date() in self.ocdate['close']: ## \u5224\u5c0d\u662f\u5426\u70ba\u6cd5\u5b9a\u4f11\u5e02\n      return False\n    elif self.ptime.date() in self.ocdate['open']: ## \u5224\u5c0d\u662f\u5426\u70ba\u6cd5\u5b9a\u958b\u5e02\n      return True\n    else:\n      ''' \u5224\u65b7\u662f\u5426\u70ba\u6bcf\u9031\u958b\u4f11\u5e02 '''\n      if self.ptime.weekday() <= 4:\n        return True\n      else:\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef ck_portf_001(self):\n    ''' 3-6\u8ca0\u4e56\u96e2\u4e14\u5411\u4e0a\uff0c\u4e09\u65e5\u5167\u6700\u5927\u91cf\uff0c\u6210\u4ea4\u91cf\u5927\u65bc 1000 \u5f35\uff0c\u6536\u76e4\u50f9\u5927\u65bc 10 \u5143\u3002\uff08\u8f03\u56b4\u8b39\u7684\u9078\u80a1\uff09'''\n    return self.a.MAO(3,6)[1] == '\u2191'.decode('utf-8') and (self.a.MAO(3,6)[0][1][-1] < 0 or ( self.a.MAO(3,6)[0][1][-1] < 1 and self.a.MAO(3,6)[0][1][-1] > 0 and self.a.MAO(3,6)[0][1][-2] < 0 and  self.a.MAO(3,6)[0][0] == 3)) and self.a.VOLMAX3 and self.a.stock_vol[-1] > 1000*1000 and self.a.raw_data[-1] > 10", "response": "A CK portf is 1999"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ntesting if portf is 0", "response": "def ck_portf_002(self):\n    ''' 3\u65e5\u5747\u50f9\u5927\u65bc6\u65e5\u5747\u50f9\uff0c6\u65e5\u5747\u50f9\u5927\u65bc18\u65e5\u5747\u50f9\u3002\uff08\u77ed\u4e2d\u9577\u7dda\u5448\u73fe\u591a\u982d\u7684\u614b\u52e2\uff09 '''\n    return self.a.MA(3) > self.a.MA(6) > self.a.MA(18) and self.a.MAC(18) == '\u2191'.decode('utf-8') and self.a.stock_vol[-1] > 1000*1000 and self.a.raw_data[-1] > 10"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef ck_portf_004(self):\n    ''' \u50f9\u8d70\u5e73\u4e00\u500b\u534a\u6708\u3002\uff08\u7bb1\u578b\u6574\u7406\u3001\u76e4\u6574\uff09 '''\n    return self.a.SD < 0.25 and self.a.stock_vol[-1] > 1000*1000 and self.a.raw_data[-1] > 10", "response": "Checks if portf is 0. 0"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncalculates the power reflection at the interface of two refractive index materials.", "response": "def reflection(n1, n2):\n    '''\n    Calculate the power reflection at the interface\n    of two refractive index materials.\n\n    Args:\n        n1 (float): Refractive index of material 1.\n        n2 (float): Refractive index of material 2.\n\n    Returns:\n        float: The percentage of reflected power.\n    '''\n    r = abs((n1-n2) / (n1+n2))**2\n    return r"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nfind the coupling efficiency between a solved fundamental mode and a fibre.", "response": "def coupling_efficiency(mode_solver, fibre_mfd,\n                        fibre_offset_x=0, fibre_offset_y=0,\n                        n_eff_fibre=1.441):\n    '''\n    Finds the coupling efficiency between a solved\n    fundamental mode and a fibre of given MFD.\n\n    Args:\n        mode_solver (_ModeSolver): Mode solver that\n            has found a fundamental mode.\n        fibre_mfd (float): The mode-field diameter\n            (MFD) of the fibre.\n        fibre_offset_x (float): Offset the fibre\n            from the centre position of the window\n            in x. Default is 0 (no offset).\n        fibre_offset_y (float): Offset the fibre\n            from the centre position of the window\n            in y. Default is 0 (no offset).\n        n_eff_fibre (float): The effective index\n            of the fibre mode.  Default is 1.441.\n\n    Returns:\n        float: The power coupling efficiency.\n    '''\n    etas = []\n\n    gaus = _make_gaussian(mode_solver._structure.xc, mode_solver._structure.yc,\n                          fibre_mfd, fibre_offset_x, fibre_offset_y)\n\n    for mode, n_eff in zip(mode_solver.modes, mode_solver.n_effs):\n        o = abs(_overlap(mode, gaus))\n        t = abs(transmission(n_eff, n_eff_fibre))\n        eta = o * t\n        etas.append(eta)\n\n    return etas"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncreates the index for the given reference folder", "response": "def getIndex(reference):\n    '''\n    Find the reference folder using the location of the script file\n    Create the index, test if successful\n    '''\n    if reference:\n        reffas = reference\n    else:\n        parent_directory = path.dirname(path.abspath(path.dirname(__file__)))\n        reffas = path.join(parent_directory, \"reference/DNA_CS.fasta\")\n    if not path.isfile(reffas):\n        logging.error(\"Could not find reference fasta for lambda genome.\")\n        sys.exit(\"Could not find reference fasta for lambda genome.\")\n    aligner = mp.Aligner(reffas, preset=\"map-ont\")  # build index\n    if not aligner:\n        logging.error(\"Failed to load/build index\")\n        raise Exception(\"ERROR: failed to load/build index\")\n    return aligner"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef align(aligner, reads):\n    '''\n    Test if reads can get aligned to the lambda genome,\n    if not: write to stdout\n    '''\n    i = 0\n    for record in SeqIO.parse(reads, \"fastq\"):\n        try:\n            next(aligner.map(str(record.seq)))\n            i += 1\n        except StopIteration:\n            print(record.format(\"fastq\"), end='')\n    sys.stderr.write(\"NanoLyse: removed {} reads.\\n\".format(i))", "response": "Test if reads can get aligned to the lambda genome and write to stdout\n   "}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _convert_json_response_to_entities(response, property_resolver, require_encryption,\n                                       key_encryption_key, key_resolver):\n    ''' Converts the response to tables class.\n    '''\n    if response is None or response.body is None:\n        return None\n\n    entities = _list()\n\n    entities.next_marker = _get_continuation_from_response_headers(response)\n\n    root = loads(response.body.decode('utf-8'))\n\n    if 'value' in root:\n        for entity in root['value']:\n            entity = _decrypt_and_deserialize_entity(entity, property_resolver, require_encryption, \n                                           key_encryption_key, key_resolver)\n            entities.append(entity)\n\n    else:\n        entities.append(_convert_json_to_entity(entity, \n                                             property_resolver))\n\n    return entities", "response": "Converts the response to tables class."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nexecute the ipmitool command.", "response": "def _exec_ipmitool(driver_info, command):\n    \"\"\"Execute the ipmitool command.\n\n    This uses the lanplus interface to communicate with the BMC device driver.\n\n    :param driver_info: the ipmitool parameters for accessing a node.\n    :param command: the ipmitool command to be executed.\n\n    \"\"\"\n    ipmi_cmd = (\"ipmitool -H %(address)s\"\n                \" -I lanplus -U %(user)s -P %(passwd)s %(cmd)s\"\n                % {'address': driver_info['address'],\n                   'user': driver_info['username'],\n                   'passwd': driver_info['password'],\n                   'cmd': command})\n\n    out = None\n    try:\n        out = subprocess.check_output(ipmi_cmd, shell=True)\n    except Exception:\n        pass\n    return out"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_nic_capacity(driver_info, ilo_fw):\n    i = 0x0\n    value = None\n    ilo_fw_rev = get_ilo_version(ilo_fw) or DEFAULT_FW_REV\n\n    # Note(vmud213): iLO firmware versions >= 2.3 support reading the FRU\n    # information in a single call instead of iterating over each FRU id.\n    if ilo_fw_rev < MIN_SUGGESTED_FW_REV:\n        for i in range(0xff):\n            # Note(vmud213): We can discard FRU ID's between 0x6e and 0xee\n            # as they don't contain any NIC related information\n            if (i < 0x6e) or (i > 0xee):\n                cmd = \"fru print %s\" % hex(i)\n                out = _exec_ipmitool(driver_info, cmd)\n                if out and 'port' in out and 'Adapter' in out:\n                    value = _parse_ipmi_nic_capacity(out)\n                    if value is not None:\n                        break\n            else:\n                continue\n    else:\n        cmd = \"fru print\"\n        out = _exec_ipmitool(driver_info, cmd)\n        if out:\n            for line in out.split('\\n'):\n                if line and 'port' in line and 'Adapter' in line:\n                    value = _parse_ipmi_nic_capacity(line)\n                    if value is not None:\n                        break\n    return value", "response": "Gets the max capacity supported by the NIC adapter."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nparsing the NIC capacity output for the NIC adapter.", "response": "def _parse_ipmi_nic_capacity(nic_out):\n    \"\"\"Parse the FRU output for NIC capacity\n\n    Parses the FRU output. Seraches for the key \"Product Name\"\n    in FRU output and greps for maximum speed supported by the\n    NIC adapter.\n\n    :param nic_out: the FRU output for NIC adapter.\n    :returns: the max capacity supported by the NIC adapter.\n\n    \"\"\"\n    if ((\"Device not present\" in nic_out)\n       or (\"Unknown FRU header\" in nic_out) or not nic_out):\n        return None\n\n    capacity = None\n    product_name = None\n    data = nic_out.split('\\n')\n    for item in data:\n        fields = item.split(':')\n        if len(fields) > 1:\n            first_field = fields[0].strip()\n            if first_field == \"Product Name\":\n                # Join the string back if the Product Name had some\n                # ':' by any chance\n                product_name = ':'.join(fields[1:])\n                break\n\n    if product_name:\n        product_name_array = product_name.split(' ')\n        for item in product_name_array:\n            if 'Gb' in item:\n                capacity_int = item.strip('Gb')\n                if capacity_int.isdigit():\n                    capacity = item\n\n    return capacity"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _extract_encryption_metadata(entity, require_encryption, key_encryption_key, key_resolver):\n    '''\n    Extracts the encryption metadata from the given entity, setting them to be utf-8 strings.\n    If no encryption metadata is present, will return None for all return values unless\n    require_encryption is true, in which case the method will throw.\n\n    :param entity:\n        The entity being retrieved and decrypted. Could be a dict or an entity object.\n    :param bool require_encryption:\n        If set, will enforce that the retrieved entity is encrypted and decrypt it.\n    :param object key_encryption_key:\n        The user-provided key-encryption-key. Must implement the following methods:\n        unwrap_key(key, algorithm)--returns the unwrapped form of the specified symmetric key using the \n        string-specified algorithm.\n        get_kid()--returns a string key id for this key-encryption-key.\n    :param function key_resolver(kid):\n        The user-provided key resolver. Uses the kid string to return a key-encryption-key implementing\n        the interface defined above.\n    :returns: a tuple containing the entity iv, the list of encrypted properties, the entity cek,\n        and whether the entity was encrypted using JavaV1.\n    :rtype: tuple (bytes[], list, bytes[], bool)\n    '''\n    _validate_not_none('entity', entity)\n    \n    try:\n        encrypted_properties_list = _decode_base64_to_bytes(entity['_ClientEncryptionMetadata2'])\n        encryption_data = entity['_ClientEncryptionMetadata1']\n        encryption_data = _dict_to_encryption_data(loads(encryption_data))\n    except Exception as e:\n        # Message did not have properly formatted encryption metadata.\n        if require_encryption:\n            raise ValueError(_ERROR_ENTITY_NOT_ENCRYPTED)\n        else:\n            return (None,None,None,None)\n\n    if not(encryption_data.encryption_agent.encryption_algorithm == _EncryptionAlgorithm.AES_CBC_256):\n        raise ValueError(_ERROR_UNSUPPORTED_ENCRYPTION_ALGORITHM)\n\n    content_encryption_key = _validate_and_unwrap_cek(encryption_data, key_encryption_key, key_resolver)\n\n    # Special check for compatibility with Java V1 encryption protocol.\n    isJavaV1 = (encryption_data.key_wrapping_metadata is None) or \\\n        ((encryption_data.encryption_agent.protocol == _ENCRYPTION_PROTOCOL_V1) and \\\n        'EncryptionLibrary' in encryption_data.key_wrapping_metadata and \\\n        'Java' in encryption_data.key_wrapping_metadata['EncryptionLibrary'])\n\n    metadataIV = _generate_property_iv(encryption_data.content_encryption_IV,\n                                      entity['PartitionKey'], entity['RowKey'],\n                                      '_ClientEncryptionMetadata2', isJavaV1)\n\n    cipher = _generate_AES_CBC_cipher(content_encryption_key, metadataIV)\n\n    # Decrypt the data.\n    decryptor = cipher.decryptor()\n    encrypted_properties_list = decryptor.update(encrypted_properties_list) + decryptor.finalize()\n\n    # Unpad the data.\n    unpadder = PKCS7(128).unpadder()\n    encrypted_properties_list = unpadder.update(encrypted_properties_list) + unpadder.finalize()\n\n    encrypted_properties_list = encrypted_properties_list.decode('utf-8')\n\n    if isJavaV1:\n        # Strip the square braces from the ends and split string into list.\n        encrypted_properties_list = encrypted_properties_list[1:-1]\n        encrypted_properties_list = encrypted_properties_list.split(', ')\n    else:\n        encrypted_properties_list = loads(encrypted_properties_list)\n\n    return (encryption_data.content_encryption_IV, encrypted_properties_list, content_encryption_key, isJavaV1)", "response": "Extracts the encryption metadata from the given entity."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting the resource HPELogicalDriveCollection of ArrayControllers", "response": "def logical_drives(self):\n        \"\"\"Gets the resource HPELogicalDriveCollection of ArrayControllers\"\"\"\n\n        return logical_drive.HPELogicalDriveCollection(\n            self._conn, utils.get_subresource_path_by(\n                self, ['Links', 'LogicalDrives']),\n            redfish_version=self.redfish_version)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the resource HPEPhysicalDriveCollection of ArrayControllers", "response": "def physical_drives(self):\n        \"\"\"Gets the resource HPEPhysicalDriveCollection of ArrayControllers\"\"\"\n        return physical_drive.HPEPhysicalDriveCollection(\n            self._conn, utils.get_subresource_path_by(\n                self, ['Links', 'PhysicalDrives']),\n            redfish_version=self.redfish_version)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the biggest logical drive", "response": "def logical_drives_maximum_size_mib(self):\n        \"\"\"Gets the biggest logical drive\n\n        :returns the size in MiB.\n        \"\"\"\n        return utils.max_safe([member.logical_drives.maximum_size_mib\n                               for member in self.get_members()])"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the biggest disk clf.", "response": "def physical_drives_maximum_size_mib(self):\n        \"\"\"Gets the biggest disk\n\n        :returns the size in MiB.\n        \"\"\"\n        return utils.max_safe([member.physical_drives.maximum_size_mib\n                               for member in self.get_members()])"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef has_ssd(self):\n        for member in self.get_members():\n            if member.physical_drives.has_ssd:\n                return True\n        return False", "response": "Return true if any of the array controllers is ssd"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef has_rotational(self):\n        for member in self.get_members():\n            if member.physical_drives.has_rotational:\n                return True\n        return False", "response": "Return true if any of the members of ArrayControllers is ssd"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting the set of raid levels configured for each logical volume", "response": "def logical_raid_levels(self):\n        \"\"\"Gets the raid level for each logical volume\n\n        :returns the set of list of raid levels configured\n        \"\"\"\n        lg_raid_lvls = set()\n        for member in self.get_members():\n            lg_raid_lvls.update(member.logical_drives.logical_raid_levels)\n        return lg_raid_lvls"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef array_controller_by_location(self, location):\n        for member in self.get_members():\n            if member.location == location:\n                return member", "response": "Returns array controller instance by location"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn array controller instance by model", "response": "def array_controller_by_model(self, model):\n        \"\"\"Returns array controller instance by model\n\n        :returns Instance of array controller\n        \"\"\"\n        for member in self.get_members():\n            if member.model == model:\n                return member"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_subresource_path_by(resource, subresource_path):\n    if isinstance(subresource_path, six.string_types):\n        subresource_path = [subresource_path]\n    elif not subresource_path:\n        raise ValueError('\"subresource_path\" cannot be empty')\n\n    body = resource.json\n    for path_item in subresource_path:\n        body = body.get(path_item, {})\n\n    if not body:\n        raise exception.MissingAttributeError(\n            attribute='/'.join(subresource_path), resource=resource.path)\n\n    if '@odata.id' not in body:\n        raise exception.MissingAttributeError(\n            attribute='/'.join(subresource_path)+'/@odata.id',\n            resource=resource.path)\n\n    return body['@odata.id']", "response": "Helper function to find the resource path by a list of path items."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_supported_boot_mode(supported_boot_mode):\n        boot_mode_bios = 'false'\n        boot_mode_uefi = 'false'\n        if (supported_boot_mode ==\n                sys_cons.SUPPORTED_LEGACY_BIOS_ONLY):\n            boot_mode_bios = 'true'\n        elif (supported_boot_mode ==\n                sys_cons.SUPPORTED_UEFI_ONLY):\n            boot_mode_uefi = 'true'\n        elif (supported_boot_mode ==\n                sys_cons.SUPPORTED_LEGACY_BIOS_AND_UEFI):\n            boot_mode_bios = 'true'\n            boot_mode_uefi = 'true'\n\n        return SupportedBootModes(boot_mode_bios=boot_mode_bios,\n                                  boot_mode_uefi=boot_mode_uefi)", "response": "Return a tuple of true / false based on bios and uefi support respectively."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_allowed_operations(resource, subresouce_path):\n    uri = get_subresource_path_by(resource, subresouce_path)\n    response = resource._conn.get(path=uri)\n    return response.headers['Allow']", "response": "Helper function to get the HTTP allowed methods."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _set_next_host_location(self, context):\n        '''\n        A function which sets the next host location on the request, if applicable. \n\n        :param ~azure.storage.models.RetryContext context: \n            The retry context containing the previous host location and the request \n            to evaluate and possibly modify.\n        '''\n        if len(context.request.host_locations) > 1:\n            # If there's more than one possible location, retry to the alternative\n            if context.location_mode == LocationMode.PRIMARY:\n                context.location_mode = LocationMode.SECONDARY\n            else:\n                context.location_mode = LocationMode.PRIMARY\n\n            context.request.host = context.request.host_locations.get(context.location_mode)", "response": "A function which sets the next host location on the request if applicable."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\noverriding the base method to support retrying the operation.", "response": "def _op(self, method, path='', data=None, headers=None):\n        \"\"\"Overrides the base method to support retrying the operation.\n\n        :param method: The HTTP method to be used, e.g: GET, POST,\n            PUT, PATCH, etc...\n        :param path: The sub-URI path to the resource.\n        :param data: Optional JSON data.\n        :param headers: Optional dictionary of headers.\n        :returns: The response from the connector.Connector's _op method.\n        \"\"\"\n        resp = super(HPEConnector, self)._op(method, path, data,\n                                             headers, allow_redirects=False)\n        # With IPv6, Gen10 server gives redirection response with new path with\n        # a prefix of '/' so this check is required\n        if resp.status_code == 308:\n            path = urlparse(resp.headers['Location']).path\n            resp = super(HPEConnector, self)._op(method, path, data, headers)\n        return resp"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ngenerate a shared access signature for the file. Use the returned signature with the sas_token parameter of FileService. :param str share_name: Name of share. :param str directory_name: Name of directory. SAS tokens cannot be created for directories, so this parameter should only be present if file_name is provided. :param str file_name: Name of file. :param FilePermissions permission: The permissions associated with the shared access signature. The user is restricted to operations allowed by the permissions. Permissions must be ordered read, create, write, delete, list. Required unless an id is given referencing a stored access policy which contains this field. This field must be omitted if it has been specified in an associated stored access policy. :param expiry: The time at which the shared access signature becomes invalid. Required unless an id is given referencing a stored access policy which contains this field. This field must be omitted if it has been specified in an associated stored access policy. Azure will always convert values to UTC. If a date is passed in without timezone info, it is assumed to be UTC. :type expiry: date or str :param start: The time at which the shared access signature becomes valid. If omitted, start time for this call is assumed to be the time when the storage service receives the request. Azure will always convert values to UTC. If a date is passed in without timezone info, it is assumed to be UTC. :type start: date or str :param str id: A unique value up to 64 characters in length that correlates to a stored access policy. To create a stored access policy, use set_file_service_properties. :param str ip: Specifies an IP address or a range of IP addresses from which to accept requests. If the IP address from which the request originates does not match the IP address or address range specified on the SAS token, the request is not authenticated. For example, specifying sip=168.1.5.65 or sip=168.1.5.60-168.1.5.70 on the SAS restricts the request to those IP addresses. :param str protocol: Specifies the protocol permitted for a request made. Possible values are both HTTPS and HTTP (https,http) or HTTPS only (https). The default value is https,http. Note that HTTP only is not a permitted value. :param str cache_control: Response header value for Cache-Control when resource is accessed using this shared access signature. :param str content_disposition: Response header value for Content-Disposition when resource is accessed using this shared access signature. :param str content_encoding: Response header value for Content-Encoding when resource is accessed using this shared access signature. :param str content_language: Response header value for Content-Language when resource is accessed using this shared access signature. :param str content_type: Response header value for Content-Type when resource is accessed using this shared access signature. :return: A Shared Access Signature (sas) token. :rtype: str", "response": "def generate_file_shared_access_signature(self, share_name, \n                                         directory_name=None, \n                                         file_name=None,\n                                         permission=None, \n                                         expiry=None,\n                                         start=None, \n                                         id=None,\n                                         ip=None,\n                                         protocol=None,\n                                         cache_control=None,\n                                         content_disposition=None,\n                                         content_encoding=None,\n                                         content_language=None,\n                                         content_type=None):\n        '''\n        Generates a shared access signature for the file.\n        Use the returned signature with the sas_token parameter of FileService.\n\n        :param str share_name:\n            Name of share.\n        :param str directory_name:\n            Name of directory. SAS tokens cannot be created for directories, so \n            this parameter should only be present if file_name is provided.\n        :param str file_name:\n            Name of file.\n        :param FilePermissions permission:\n            The permissions associated with the shared access signature. The \n            user is restricted to operations allowed by the permissions.\n            Permissions must be ordered read, create, write, delete, list.\n            Required unless an id is given referencing a stored access policy \n            which contains this field. This field must be omitted if it has been \n            specified in an associated stored access policy.\n        :param expiry:\n            The time at which the shared access signature becomes invalid. \n            Required unless an id is given referencing a stored access policy \n            which contains this field. This field must be omitted if it has \n            been specified in an associated stored access policy. Azure will always \n            convert values to UTC. If a date is passed in without timezone info, it \n            is assumed to be UTC.\n        :type expiry: date or str\n        :param start:\n            The time at which the shared access signature becomes valid. If \n            omitted, start time for this call is assumed to be the time when the \n            storage service receives the request. Azure will always convert values \n            to UTC. If a date is passed in without timezone info, it is assumed to \n            be UTC.\n        :type start: date or str\n        :param str id:\n            A unique value up to 64 characters in length that correlates to a \n            stored access policy. To create a stored access policy, use \n            set_file_service_properties.\n        :param str ip:\n            Specifies an IP address or a range of IP addresses from which to accept requests.\n            If the IP address from which the request originates does not match the IP address\n            or address range specified on the SAS token, the request is not authenticated.\n            For example, specifying sip=168.1.5.65 or sip=168.1.5.60-168.1.5.70 on the SAS\n            restricts the request to those IP addresses.\n        :param str protocol:\n            Specifies the protocol permitted for a request made. Possible values are\n            both HTTPS and HTTP (https,http) or HTTPS only (https). The default value\n            is https,http. Note that HTTP only is not a permitted value.\n        :param str cache_control:\n            Response header value for Cache-Control when resource is accessed\n            using this shared access signature.\n        :param str content_disposition:\n            Response header value for Content-Disposition when resource is accessed\n            using this shared access signature.\n        :param str content_encoding:\n            Response header value for Content-Encoding when resource is accessed\n            using this shared access signature.\n        :param str content_language:\n            Response header value for Content-Language when resource is accessed\n            using this shared access signature.\n        :param str content_type:\n            Response header value for Content-Type when resource is accessed\n            using this shared access signature.\n        :return: A Shared Access Signature (sas) token.\n        :rtype: str\n        '''\n        _validate_not_none('share_name', share_name)\n        _validate_not_none('file_name', file_name)\n        _validate_not_none('self.account_name', self.account_name)\n        _validate_not_none('self.account_key', self.account_key)\n\n        sas = SharedAccessSignature(self.account_name, self.account_key)\n        return sas.generate_file(\n            share_name,\n            directory_name,\n            file_name,\n            permission, \n            expiry,\n            start=start, \n            id=id,\n            ip=ip,\n            protocol=protocol,\n            cache_control=cache_control,\n            content_disposition=content_disposition,\n            content_encoding=content_encoding,\n            content_language=content_language,\n            content_type=content_type,\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsetting the properties of a storage account s File service including the File service properties.", "response": "def set_file_service_properties(self, hour_metrics=None, minute_metrics=None, \n                                    cors=None, timeout=None):\n        '''\n        Sets the properties of a storage account's File service, including\n        Azure Storage Analytics. If an element (ex HourMetrics) is left as None, the \n        existing settings on the service for that functionality are preserved.\n\n        :param Metrics hour_metrics:\n            The hour metrics settings provide a summary of request \n            statistics grouped by API in hourly aggregates for files.\n        :param Metrics minute_metrics:\n            The minute metrics settings provide request statistics \n            for each minute for files.\n        :param cors:\n            You can include up to five CorsRule elements in the \n            list. If an empty list is specified, all CORS rules will be deleted, \n            and CORS will be disabled for the service.\n        :type cors: list of :class:`~azure.storage.models.CorsRule`\n        :param int timeout:\n            The timeout parameter is expressed in seconds.\n        '''\n        request = HTTPRequest()\n        request.method = 'PUT'\n        request.host = self._get_host()\n        request.path = _get_path()\n        request.query = [\n            ('restype', 'service'),\n            ('comp', 'properties'),\n            ('timeout', _int_to_str(timeout)),         \n        ]\n        request.body = _get_request_body(\n            _convert_service_properties_to_xml(None, hour_metrics, minute_metrics, cors))\n\n        self._perform_request(request)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef list_shares(self, prefix=None, marker=None, num_results=None, \n                    include_metadata=False, timeout=None):\n        '''\n        Returns a generator to list the shares under the specified account.\n        The generator will lazily follow the continuation tokens returned by\n        the service and stop when all shares have been returned or num_results \n        is reached.\n\n        If num_results is specified and the account has more than that number of \n        shares, the generator will have a populated next_marker field once it \n        finishes. This marker can be used to create a new generator if more \n        results are desired.\n\n        :param str prefix:\n            Filters the results to return only shares whose names\n            begin with the specified prefix.\n        :param int num_results:\n            Specifies the maximum number of shares to return.\n        :param bool include_metadata:\n            Specifies that share metadata be returned in the response.\n        :param str marker:\n            An opaque continuation token. This value can be retrieved from the \n            next_marker field of a previous generator object if num_results was \n            specified and that generator has finished enumerating results. If \n            specified, this generator will begin returning results from the point \n            where the previous generator stopped.\n        :param int timeout:\n            The timeout parameter is expressed in seconds.\n        '''\n        include = 'metadata' if include_metadata else None\n        kwargs = {'prefix': prefix, 'marker': marker, 'max_results': num_results, \n                'include': include, 'timeout': timeout}\n        resp = self._list_shares(**kwargs)\n\n        return ListGenerator(resp, self._list_shares, (), kwargs)", "response": "Returns a generator to list the shares under the specified account."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_share_properties(self, share_name, timeout=None):\n        '''\n        Returns all user-defined metadata and system properties for the\n        specified share. The data returned does not include the shares's\n        list of files or directories.\n\n        :param str share_name:\n            Name of existing share.\n        :param int timeout:\n            The timeout parameter is expressed in seconds.\n        :return: A Share that exposes properties and metadata.\n        :rtype: :class:`.Share`\n        '''\n        _validate_not_none('share_name', share_name)\n        request = HTTPRequest()\n        request.method = 'GET'\n        request.host = self._get_host()\n        request.path = _get_path(share_name)\n        request.query = [\n            ('restype', 'share'),\n            ('timeout', _int_to_str(timeout)),\n        ]\n\n        response = self._perform_request(request)\n        return _parse_share(share_name, response)", "response": "Returns all user - defined metadata and system properties for the specified share."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsets the properties of the specified share.", "response": "def set_share_properties(self, share_name, quota, timeout=None):\n        '''\n        Sets service-defined properties for the specified share.\n\n        :param str share_name:\n            Name of existing share.\n        :param int quota:\n            Specifies the maximum size of the share, in gigabytes. Must be \n            greater than 0, and less than or equal to 5 TB (5120 GB).\n        :param int timeout:\n            The timeout parameter is expressed in seconds.\n        '''\n        _validate_not_none('share_name', share_name)\n        _validate_not_none('quota', quota)\n        request = HTTPRequest()\n        request.method = 'PUT'\n        request.host = self._get_host()\n        request.path = _get_path(share_name)\n        request.query = [\n            ('restype', 'share'),\n            ('comp', 'properties'),\n            ('timeout', _int_to_str(timeout)),\n        ]\n        request.headers = [('x-ms-share-quota', _int_to_str(quota))]\n\n        self._perform_request(request)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning all user - defined metadata for the specified share.", "response": "def get_share_metadata(self, share_name, timeout=None):\n        '''\n        Returns all user-defined metadata for the specified share.\n\n        :param str share_name:\n            Name of existing share.\n        :param int timeout:\n            The timeout parameter is expressed in seconds.\n        :return:\n            A dictionary representing the share metadata name, value pairs.\n        :rtype: a dict mapping str to str\n        '''\n        _validate_not_none('share_name', share_name)\n        request = HTTPRequest()\n        request.method = 'GET'\n        request.host = self._get_host()\n        request.path = _get_path(share_name)\n        request.query = [\n            ('restype', 'share'),\n            ('comp', 'metadata'),\n            ('timeout', _int_to_str(timeout)),\n        ]\n\n        response = self._perform_request(request)\n        return _parse_metadata(response)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_share_stats(self, share_name, timeout=None):\n        '''\n        Gets the approximate size of the data stored on the share,\n        rounded up to the nearest gigabyte.\n        \n        Note that this value may not include all recently created\n        or recently resized files.\n\n        :param str share_name:\n            Name of existing share.\n        :param int timeout:\n            The timeout parameter is expressed in seconds.\n        :return: the approximate size of the data stored on the share.\n        :rtype: int\n        '''\n        _validate_not_none('share_name', share_name)\n        request = HTTPRequest()\n        request.method = 'GET'\n        request.host = self._get_host()\n        request.path = _get_path(share_name)\n        request.query = [\n            ('restype', 'share'),\n            ('comp', 'stats'),\n            ('timeout', _int_to_str(timeout)),\n        ]\n\n        response = self._perform_request(request)\n        return _convert_xml_to_share_stats(response)", "response": "Retrieves the approximate size of the data stored on the given share."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a generator to list the directories and files under the specified share.", "response": "def list_directories_and_files(self, share_name, directory_name=None, \n                                   num_results=None, marker=None, timeout=None):\n        '''\n        Returns a generator to list the directories and files under the specified share.\n        The generator will lazily follow the continuation tokens returned by\n        the service and stop when all directories and files have been returned or\n        num_results is reached.\n\n        If num_results is specified and the share has more than that number of \n        containers, the generator will have a populated next_marker field once it \n        finishes. This marker can be used to create a new generator if more \n        results are desired.\n\n        :param str share_name:\n            Name of existing share.\n        :param str directory_name:\n            The path to the directory.\n        :param int num_results:\n            Specifies the maximum number of files to return,\n            including all directory elements. If the request does not specify\n            num_results or specifies a value greater than 5,000, the server will\n            return up to 5,000 items. Setting num_results to a value less than\n            or equal to zero results in error response code 400 (Bad Request).\n        :param str marker:\n            An opaque continuation token. This value can be retrieved from the \n            next_marker field of a previous generator object if num_results was \n            specified and that generator has finished enumerating results. If \n            specified, this generator will begin returning results from the point \n            where the previous generator stopped.\n        :param int timeout:\n            The timeout parameter is expressed in seconds.\n        '''\n        args = (share_name, directory_name)\n        kwargs = {'marker': marker, 'max_results': num_results, 'timeout': timeout}\n        resp = self._list_directories_and_files(*args, **kwargs)\n\n        return ListGenerator(resp, self._list_directories_and_files, args, kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a list of directories and files under the specified share.", "response": "def _list_directories_and_files(self, share_name, directory_name=None, \n                                   marker=None, max_results=None, timeout=None):\n        '''\n        Returns a list of the directories and files under the specified share.\n\n        :param str share_name:\n            Name of existing share.\n        :param str directory_name:\n            The path to the directory.\n        :param str marker:\n            A string value that identifies the portion of the list\n            to be returned with the next list operation. The operation returns\n            a next_marker value within the response body if the list returned was\n            not complete. The marker value may then be used in a subsequent\n            call to request the next set of list items. The marker value is\n            opaque to the client.\n        :param int max_results:\n            Specifies the maximum number of files to return,\n            including all directory elements. If the request does not specify\n            max_results or specifies a value greater than 5,000, the server will\n            return up to 5,000 items. Setting max_results to a value less than\n            or equal to zero results in error response code 400 (Bad Request).\n        :param int timeout:\n            The timeout parameter is expressed in seconds.\n        '''\n        _validate_not_none('share_name', share_name)\n        request = HTTPRequest()\n        request.method = 'GET'\n        request.host = self._get_host()\n        request.path = _get_path(share_name, directory_name)\n        request.query = [\n            ('restype', 'directory'),\n            ('comp', 'list'),\n            ('marker', _to_str(marker)),\n            ('maxresults', _int_to_str(max_results)),\n            ('timeout', _int_to_str(timeout)),\n        ]\n\n        response = self._perform_request(request)\n        return _convert_xml_to_directories_and_files(response)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsetting system properties on the file.", "response": "def set_file_properties(self, share_name, directory_name, file_name, \n                            content_settings, timeout=None):\n        '''\n        Sets system properties on the file. If one property is set for the\n        content_settings, all properties will be overriden.\n\n        :param str share_name:\n            Name of existing share.\n        :param str directory_name:\n            The path to the directory.\n        :param str file_name:\n            Name of existing file.\n        :param ~azure.storage.file.models.ContentSettings content_settings:\n            ContentSettings object used to set the file properties.\n        :param int timeout:\n            The timeout parameter is expressed in seconds.\n        '''\n        _validate_not_none('share_name', share_name)\n        _validate_not_none('file_name', file_name)\n        _validate_not_none('content_settings', content_settings)\n        request = HTTPRequest()\n        request.method = 'PUT'\n        request.host = self._get_host()\n        request.path = _get_path(share_name, directory_name, file_name)\n        request.query = [\n            ('comp', 'properties'),\n            ('timeout', _int_to_str(timeout)),\n        ]\n        request.headers = None\n        request.headers = content_settings._to_headers()\n\n        self._perform_request(request)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncopying a blob or file to a destination file within the storage account.", "response": "def copy_file(self, share_name, directory_name, file_name, copy_source,\n                  metadata=None, timeout=None):\n        '''\n        Copies a blob or file to a destination file within the storage account. \n\n        :param str share_name:\n            Name of existing share.\n        :param str directory_name:\n            The path to the directory.\n        :param str file_name:\n            Name of existing file.\n        :param str copy_source:\n            Specifies the URL of the source blob or file, up to 2 KB in length. \n            A source file in the same account can be private, but a file in another account\n            must be public or accept credentials included in this URL, such as\n            a Shared Access Signature. Examples:\n            https://myaccount.file.core.windows.net/myshare/mydirectory/myfile\n        :param metadata:\n            Dict containing name, value pairs.\n        :type metadata: A dict mapping str to str.\n        :param int timeout:\n            The timeout parameter is expressed in seconds.\n        :return: Copy operation properties such as status, source, and ID.\n        :rtype: :class:`~azure.storage.file.models.CopyProperties`\n        '''\n        _validate_not_none('share_name', share_name)\n        _validate_not_none('file_name', file_name)\n        _validate_not_none('copy_source', copy_source)\n\n        request = HTTPRequest()\n        request.method = 'PUT'\n        request.host = self._get_host()\n        request.path = _get_path(share_name, directory_name, file_name)\n        request.query = [('timeout', _int_to_str(timeout))]\n        request.headers = [\n            ('x-ms-copy-source', _to_str(copy_source)),\n            ('x-ms-meta-name-values', metadata),\n        ]\n\n        response = self._perform_request(request)\n        props = _parse_properties(response, FileProperties)\n        return props.copy"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating a new file in the specified share.", "response": "def create_file(self, share_name, directory_name, file_name,\n                    content_length, content_settings=None, metadata=None, \n                    timeout=None):\n        '''\n        Creates a new file.\n\n        See create_file_from_* for high level functions that handle the\n        creation and upload of large files with automatic chunking and\n        progress notifications.\n\n        :param str share_name:\n            Name of existing share.\n        :param str directory_name:\n            The path to the directory.\n        :param str file_name:\n            Name of file to create or update.\n        :param int content_length:\n            Length of the file in bytes.\n        :param ~azure.storage.file.models.ContentSettings content_settings:\n            ContentSettings object used to set file properties.\n        :param metadata:\n            Name-value pairs associated with the file as metadata.\n        :type metadata: a dict mapping str to str\n        :param int timeout:\n            The timeout parameter is expressed in seconds.\n        '''\n        _validate_not_none('share_name', share_name)\n        _validate_not_none('file_name', file_name)\n        _validate_not_none('content_length', content_length)\n        request = HTTPRequest()\n        request.method = 'PUT'\n        request.host = self._get_host()\n        request.path = _get_path(share_name, directory_name, file_name)\n        request.query = [('timeout', _int_to_str(timeout))]\n        request.headers = [\n            ('x-ms-meta-name-values', metadata),\n            ('x-ms-content-length', _to_str(content_length)),\n            ('x-ms-type', 'file')\n        ]\n        if content_settings is not None:\n            request.headers += content_settings._to_headers()\n\n        self._perform_request(request)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef create_file_from_text(self, share_name, directory_name, file_name, \n                           text, encoding='utf-8', content_settings=None,\n                           metadata=None, timeout=None):\n        '''\n        Creates a new file from str/unicode, or updates the content of an\n        existing file, with automatic chunking and progress notifications.\n\n        :param str share_name:\n            Name of existing share.\n        :param str directory_name:\n            The path to the directory.\n        :param str file_name:\n            Name of file to create or update.\n        :param str text:\n            Text to upload to the file.\n        :param str encoding:\n            Python encoding to use to convert the text to bytes.\n        :param ~azure.storage.file.models.ContentSettings content_settings:\n            ContentSettings object used to set file properties.\n        :param metadata:\n            Name-value pairs associated with the file as metadata.\n        :type metadata: a dict mapping str to str\n        :param int timeout:\n            The timeout parameter is expressed in seconds. This method may make \n            multiple calls to the Azure service and the timeout will apply to \n            each call individually.\n        '''\n        _validate_not_none('share_name', share_name)\n        _validate_not_none('file_name', file_name)\n        _validate_not_none('text', text)\n\n        if not isinstance(text, bytes):\n            _validate_not_none('encoding', encoding)\n            text = text.encode(encoding)\n\n        self.create_file_from_bytes(\n            share_name, directory_name, file_name, text, 0,\n            len(text), content_settings, metadata, timeout)", "response": "Creates a new file from a string or updates the content of an existing file."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating a new file from an array of bytes.", "response": "def create_file_from_bytes(\n        self, share_name, directory_name, file_name, file,\n        index=0, count=None, content_settings=None, metadata=None,\n        progress_callback=None, max_connections=1, max_retries=5,\n        retry_wait=1.0, timeout=None):\n        '''\n        Creates a new file from an array of bytes, or updates the content\n        of an existing file, with automatic chunking and progress\n        notifications.\n\n        :param str share_name:\n            Name of existing share.\n        :param str directory_name:\n            The path to the directory.\n        :param str file_name:\n            Name of file to create or update.\n        :param str file:\n            Content of file as an array of bytes.\n        :param int index:\n            Start index in the array of bytes.\n        :param int count:\n            Number of bytes to upload. Set to None or negative value to upload\n            all bytes starting from index.\n        :param ~azure.storage.file.models.ContentSettings content_settings:\n            ContentSettings object used to set file properties.\n        :param metadata:\n            Name-value pairs associated with the file as metadata.\n        :type metadata: a dict mapping str to str\n        :param progress_callback:\n            Callback for progress with signature function(current, total) where\n            current is the number of bytes transfered so far and total is the\n            size of the file, or None if the total size is unknown.\n        :type progress_callback: callback function in format of func(current, total)\n        :param int max_connections:\n            Maximum number of parallel connections to use when the file size\n            exceeds 64MB.\n            Set to 1 to upload the file chunks sequentially.\n            Set to 2 or more to upload the file chunks in parallel. This uses\n            more system resources but will upload faster.\n        :param int max_retries:\n            Number of times to retry upload of file chunk if an error occurs.\n        :param int retry_wait:\n            Sleep time in secs between retries.\n        :param int timeout:\n            The timeout parameter is expressed in seconds. This method may make \n            multiple calls to the Azure service and the timeout will apply to \n            each call individually.\n        '''\n        _validate_not_none('share_name', share_name)\n        _validate_not_none('file_name', file_name)\n        _validate_not_none('file', file)\n        _validate_type_bytes('file', file)\n\n        if index < 0:\n            raise TypeError(_ERROR_VALUE_NEGATIVE.format('index'))\n\n        if count is None or count < 0:\n            count = len(file) - index\n\n        stream = BytesIO(file)\n        stream.seek(index)\n\n        self.create_file_from_stream(\n            share_name, directory_name, file_name, stream, count,\n            content_settings, metadata, progress_callback,\n            max_connections, max_retries, retry_wait, timeout)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef create_file_from_stream(\n        self, share_name, directory_name, file_name, stream, count,\n        content_settings=None, metadata=None, progress_callback=None,\n        max_connections=1, max_retries=5, retry_wait=1.0, timeout=None):\n        '''\n        Creates a new file from a file/stream, or updates the content of an\n        existing file, with automatic chunking and progress notifications.\n\n        :param str share_name:\n            Name of existing share.\n        :param str directory_name:\n            The path to the directory.\n        :param str file_name:\n            Name of file to create or update.\n        :param io.IOBase stream:\n            Opened file/stream to upload as the file content.\n        :param int count:\n            Number of bytes to read from the stream. This is required, a\n            file cannot be created if the count is unknown.\n        :param ~azure.storage.file.models.ContentSettings content_settings:\n            ContentSettings object used to set file properties.\n        :param metadata:\n            Name-value pairs associated with the file as metadata.\n        :type metadata: a dict mapping str to str\n        :param progress_callback:\n            Callback for progress with signature function(current, total) where\n            current is the number of bytes transfered so far and total is the\n            size of the file, or None if the total size is unknown.\n        :type progress_callback: callback function in format of func(current, total)\n        :param int max_connections:\n            Maximum number of parallel connections to use when the file size\n            exceeds 64MB.\n            Set to 1 to upload the file chunks sequentially.\n            Set to 2 or more to upload the file chunks in parallel. This uses\n            more system resources but will upload faster.\n            Note that parallel upload requires the stream to be seekable.\n        :param int max_retries:\n            Number of times to retry upload of file chunk if an error occurs.\n        :param int retry_wait:\n            Sleep time in secs between retries.\n        :param int timeout:\n            The timeout parameter is expressed in seconds. This method may make \n            multiple calls to the Azure service and the timeout will apply to \n            each call individually.\n        '''\n        _validate_not_none('share_name', share_name)\n        _validate_not_none('file_name', file_name)\n        _validate_not_none('stream', stream)\n        _validate_not_none('count', count)\n\n        if count < 0:\n            raise TypeError(_ERROR_VALUE_NEGATIVE.format('count'))\n\n        self.create_file(\n            share_name,\n            directory_name,\n            file_name,\n            count,\n            content_settings,\n            metadata,\n            timeout\n        )\n\n        _upload_file_chunks(\n            self,\n            share_name,\n            directory_name,\n            file_name,\n            count,\n            self.MAX_RANGE_SIZE,\n            stream,\n            max_connections,\n            max_retries,\n            retry_wait,\n            progress_callback,\n            timeout\n        )", "response": "Creates a new file from a file or stream."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _get_file(self, share_name, directory_name, file_name,\n                 start_range=None, end_range=None,\n                 range_get_content_md5=None, timeout=None):\n        '''\n        Downloads a file's content, metadata, and properties. You can specify a\n        range if you don't need to download the file in its entirety. If no range\n        is specified, the full file will be downloaded.\n\n        See get_file_to_* for high level functions that handle the download\n        of large files with automatic chunking and progress notifications.\n\n        :param str share_name:\n            Name of existing share.\n        :param str directory_name:\n            The path to the directory.\n        :param str file_name:\n            Name of existing file.\n        :param int start_range:\n            Start of byte range to use for downloading a section of the file.\n            If no end_range is given, all bytes after the start_range will be downloaded.\n            The start_range and end_range params are inclusive.\n            Ex: start_range=0, end_range=511 will download first 512 bytes of file.\n        :param int end_range:\n            End of byte range to use for downloading a section of the file.\n            If end_range is given, start_range must be provided.\n            The start_range and end_range params are inclusive.\n            Ex: start_range=0, end_range=511 will download first 512 bytes of file.\n        :param bool range_get_content_md5:\n            When this header is set to True and specified together\n            with the Range header, the service returns the MD5 hash for the\n            range, as long as the range is less than or equal to 4 MB in size.\n        :param int timeout:\n            The timeout parameter is expressed in seconds.\n        :return: A File with content, properties, and metadata.\n        :rtype: :class:`~azure.storage.file.models.File`\n        '''\n        _validate_not_none('share_name', share_name)\n        _validate_not_none('file_name', file_name)\n        request = HTTPRequest()\n        request.method = 'GET'\n        request.host = self._get_host()\n        request.path = _get_path(share_name, directory_name, file_name)\n        request.query = [('timeout', _int_to_str(timeout))]\n        _validate_and_format_range_headers(\n            request,\n            start_range,\n            end_range,\n            start_range_required=False,\n            end_range_required=False,\n            check_content_md5=range_get_content_md5)\n\n        response = self._perform_request(request, None)\n        return _parse_file(file_name, response)", "response": "Download a file from the Cloud Storage service."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_file_to_path(self, share_name, directory_name, file_name, file_path,\n                         open_mode='wb', start_range=None, end_range=None,\n                         range_get_content_md5=None, progress_callback=None,\n                         max_connections=1, max_retries=5, retry_wait=1.0, timeout=None):\n        '''\n        Downloads a file to a file path, with automatic chunking and progress\n        notifications. Returns an instance of File with properties and metadata.\n\n        :param str share_name:\n            Name of existing share.\n        :param str directory_name:\n            The path to the directory.\n        :param str file_name:\n            Name of existing file.\n        :param str file_path:\n            Path of file to write to.\n        :param str open_mode:\n            Mode to use when opening the file.\n        :param int start_range:\n            Start of byte range to use for downloading a section of the file.\n            If no end_range is given, all bytes after the start_range will be downloaded.\n            The start_range and end_range params are inclusive.\n            Ex: start_range=0, end_range=511 will download first 512 bytes of file.\n        :param int end_range:\n            End of byte range to use for downloading a section of the file.\n            If end_range is given, start_range must be provided.\n            The start_range and end_range params are inclusive.\n            Ex: start_range=0, end_range=511 will download first 512 bytes of file.\n        :param bool range_get_content_md5:\n            When this header is set to True and specified together\n            with the Range header, the service returns the MD5 hash for the\n            range, as long as the range is less than or equal to 4 MB in size.\n        :param progress_callback:\n            Callback for progress with signature function(current, total) \n            where current is the number of bytes transfered so far, and total is \n            the size of the file if known.\n        :type progress_callback: callback function in format of func(current, total)\n        :param int max_connections:\n            Set to 1 to download the file sequentially.\n            Set to 2 or greater if you want to download a file larger than 64MB in chunks.\n            If the file size does not exceed 64MB it will be downloaded in one chunk.\n        :param int max_retries:\n            Number of times to retry download of file chunk if an error occurs.\n        :param int retry_wait:\n            Sleep time in secs between retries.\n        :param int timeout:\n            The timeout parameter is expressed in seconds. This method may make \n            multiple calls to the Azure service and the timeout will apply to \n            each call individually.\n        :return: A File with properties and metadata.\n        :rtype: :class:`~azure.storage.file.models.File`\n        '''\n        _validate_not_none('share_name', share_name)\n        _validate_not_none('file_name', file_name)\n        _validate_not_none('file_path', file_path)\n        _validate_not_none('open_mode', open_mode)\n\n        with open(file_path, open_mode) as stream:\n            file = self.get_file_to_stream(\n                share_name, directory_name, file_name, stream,\n                start_range, end_range, range_get_content_md5,\n                progress_callback, max_connections, max_retries,\n                retry_wait, timeout)\n\n        return file", "response": "Downloads a file to a file path."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ndownloading a file from the given share to a stream.", "response": "def get_file_to_stream(\n        self, share_name, directory_name, file_name, stream,\n        start_range=None, end_range=None, range_get_content_md5=None,\n        progress_callback=None, max_connections=1, max_retries=5,\n        retry_wait=1.0, timeout=None):\n        '''\n        Downloads a file to a stream, with automatic chunking and progress\n        notifications. Returns an instance of :class:`File` with properties\n        and metadata.\n\n        :param str share_name:\n            Name of existing share.\n        :param str directory_name:\n            The path to the directory.\n        :param str file_name:\n            Name of existing file.\n        :param io.IOBase stream:\n            Opened file/stream to write to.\n        :param int start_range:\n            Start of byte range to use for downloading a section of the file.\n            If no end_range is given, all bytes after the start_range will be downloaded.\n            The start_range and end_range params are inclusive.\n            Ex: start_range=0, end_range=511 will download first 512 bytes of file.\n        :param int end_range:\n            End of byte range to use for downloading a section of the file.\n            If end_range is given, start_range must be provided.\n            The start_range and end_range params are inclusive.\n            Ex: start_range=0, end_range=511 will download first 512 bytes of file.\n        :param bool range_get_content_md5:\n            When this header is set to True and specified together\n            with the Range header, the service returns the MD5 hash for the\n            range, as long as the range is less than or equal to 4 MB in size.\n        :param progress_callback:\n            Callback for progress with signature function(current, total) \n            where current is the number of bytes transfered so far, and total is \n            the size of the file if known.\n        :type progress_callback: callback function in format of func(current, total)\n        :param int max_connections:\n            Set to 1 to download the file sequentially.\n            Set to 2 or greater if you want to download a file larger than 64MB in chunks.\n            If the file size does not exceed 64MB it will be downloaded in one chunk.\n        :param int max_retries:\n            Number of times to retry download of file chunk if an error occurs.\n        :param int retry_wait:\n            Sleep time in secs between retries.\n        :param int timeout:\n            The timeout parameter is expressed in seconds. This method may make \n            multiple calls to the Azure service and the timeout will apply to \n            each call individually.\n        :return: A File with properties and metadata.\n        :rtype: :class:`~azure.storage.file.models.File`\n        '''\n        _validate_not_none('share_name', share_name)\n        _validate_not_none('file_name', file_name)\n        _validate_not_none('stream', stream)\n\n        if sys.version_info >= (3,) and max_connections > 1 and not stream.seekable():\n            raise ValueError(_ERROR_PARALLEL_NOT_SEEKABLE)\n\n        # Only get properties if parallelism will actually be used\n        file_size = None\n        if max_connections > 1 and range_get_content_md5 is None:\n            file = self.get_file_properties(share_name, directory_name, \n                                            file_name, timeout=timeout)\n            file_size = file.properties.content_length\n\n            # If file size is large, use parallel download\n            if file_size >= self.MAX_SINGLE_GET_SIZE:\n                _download_file_chunks(\n                    self,\n                    share_name,\n                    directory_name,\n                    file_name,\n                    file_size,\n                    self.MAX_CHUNK_GET_SIZE,\n                    start_range,\n                    end_range,\n                    stream,\n                    max_connections,\n                    max_retries,\n                    retry_wait,\n                    progress_callback, \n                    timeout\n                )\n                return file\n\n        # If parallelism is off or the file is small, do a single download\n        download_size = _get_download_size(start_range, end_range, file_size)\n        if progress_callback:\n            progress_callback(0, download_size)\n\n        file = self._get_file(\n            share_name,\n            directory_name,\n            file_name,\n            start_range=start_range,\n            end_range=end_range,\n            range_get_content_md5=range_get_content_md5,\n            timeout=timeout)\n\n        if file.content is not None:\n            stream.write(file.content)\n\n        if progress_callback:\n            download_size = len(file.content)\n            progress_callback(download_size, download_size)\n\n        file.content = None # Clear file content since output has been written to user stream\n        return file"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_file_to_bytes(self, share_name, directory_name, file_name, \n                          start_range=None, end_range=None, range_get_content_md5=None,\n                          progress_callback=None, max_connections=1, max_retries=5,\n                          retry_wait=1.0, timeout=None):\n        '''\n        Downloads a file as an array of bytes, with automatic chunking and\n        progress notifications. Returns an instance of :class:`File` with\n        properties, metadata, and content.\n\n        :param str share_name:\n            Name of existing share.\n        :param str directory_name:\n            The path to the directory.\n        :param str file_name:\n            Name of existing file.\n        :param int start_range:\n            Start of byte range to use for downloading a section of the file.\n            If no end_range is given, all bytes after the start_range will be downloaded.\n            The start_range and end_range params are inclusive.\n            Ex: start_range=0, end_range=511 will download first 512 bytes of file.\n        :param int end_range:\n            End of byte range to use for downloading a section of the file.\n            If end_range is given, start_range must be provided.\n            The start_range and end_range params are inclusive.\n            Ex: start_range=0, end_range=511 will download first 512 bytes of file.\n        :param bool range_get_content_md5:\n            When this header is set to True and specified together\n            with the Range header, the service returns the MD5 hash for the\n            range, as long as the range is less than or equal to 4 MB in size.\n        :param progress_callback:\n            Callback for progress with signature function(current, total) \n            where current is the number of bytes transfered so far, and total is \n            the size of the file if known.\n        :type progress_callback: callback function in format of func(current, total)\n        :param int max_connections:\n            Set to 1 to download the file sequentially.\n            Set to 2 or greater if you want to download a file larger than 64MB in chunks.\n            If the file size does not exceed 64MB it will be downloaded in one chunk.\n        :param int max_retries:\n            Number of times to retry download of file chunk if an error occurs.\n        :param int retry_wait:\n            Sleep time in secs between retries.\n        :param int timeout:\n            The timeout parameter is expressed in seconds. This method may make \n            multiple calls to the Azure service and the timeout will apply to \n            each call individually.\n        :return: A File with properties, content, and metadata.\n        :rtype: :class:`~azure.storage.file.models.File`\n        '''\n        _validate_not_none('share_name', share_name)\n        _validate_not_none('file_name', file_name)\n\n        stream = BytesIO()\n        file = self.get_file_to_stream(\n            share_name,\n            directory_name,\n            file_name,\n            stream,\n            start_range,\n            end_range,\n            range_get_content_md5,\n            progress_callback,\n            max_connections,\n            max_retries,\n            retry_wait,\n            timeout)\n\n        file.content = stream.getvalue()\n        return file", "response": "Downloads a file from the given share and returns an array of bytes."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_file_to_text(\n        self, share_name, directory_name, file_name, encoding='utf-8',\n        start_range=None, end_range=None, range_get_content_md5=None,\n        progress_callback=None, max_connections=1, max_retries=5,\n        retry_wait=1.0, timeout=None):\n        '''\n        Downloads a file as unicode text, with automatic chunking and progress\n        notifications. Returns an instance of :class:`File` with properties,\n        metadata, and content.\n\n        :param str share_name:\n            Name of existing share.\n        :param str directory_name:\n            The path to the directory.\n        :param str file_name:\n            Name of existing file.\n        :param str encoding:\n            Python encoding to use when decoding the file data.\n        :param int start_range:\n            Start of byte range to use for downloading a section of the file.\n            If no end_range is given, all bytes after the start_range will be downloaded.\n            The start_range and end_range params are inclusive.\n            Ex: start_range=0, end_range=511 will download first 512 bytes of file.\n        :param int end_range:\n            End of byte range to use for downloading a section of the file.\n            If end_range is given, start_range must be provided.\n            The start_range and end_range params are inclusive.\n            Ex: start_range=0, end_range=511 will download first 512 bytes of file.\n        :param bool range_get_content_md5:\n            When this header is set to True and specified together\n            with the Range header, the service returns the MD5 hash for the\n            range, as long as the range is less than or equal to 4 MB in size.\n        :param progress_callback:\n            Callback for progress with signature function(current, total) \n            where current is the number of bytes transfered so far, and total is \n            the size of the file if known.\n        :type progress_callback: callback function in format of func(current, total)\n        :param int max_connections:\n            Set to 1 to download the file sequentially.\n            Set to 2 or greater if you want to download a file larger than 64MB in chunks.\n            If the file size does not exceed 64MB it will be downloaded in one chunk.\n        :param int max_retries:\n            Number of times to retry download of file chunk if an error occurs.\n        :param int retry_wait:\n            Sleep time in secs between retries.\n        :param int timeout:\n            The timeout parameter is expressed in seconds. This method may make \n            multiple calls to the Azure service and the timeout will apply to \n            each call individually.\n        :return: A File with properties, content, and metadata.\n        :rtype: :class:`~azure.storage.file.models.File`\n        '''\n        _validate_not_none('share_name', share_name)\n        _validate_not_none('file_name', file_name)\n        _validate_not_none('encoding', encoding)\n\n        file = self.get_file_to_bytes(\n            share_name,\n            directory_name,\n            file_name,\n            start_range,\n            end_range,\n            range_get_content_md5,\n            progress_callback,\n            max_connections,\n            max_retries,\n            retry_wait,\n            timeout)\n\n        file.content = file.content.decode(encoding)\n        return file", "response": "Downloads a file as unicode text and returns a File instance."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef update_range(self, share_name, directory_name, file_name, data, \n                     start_range, end_range, content_md5=None, timeout=None):\n        '''\n        Writes the bytes specified by the request body into the specified range.\n         \n        :param str share_name:\n            Name of existing share.\n        :param str directory_name:\n            The path to the directory.\n        :param str file_name:\n            Name of existing file.\n        :param bytes data:\n            Content of the range.\n        :param int start_range:\n            Start of byte range to use for updating a section of the file.\n            The range can be up to 4 MB in size.\n            The start_range and end_range params are inclusive.\n            Ex: start_range=0, end_range=511 will download first 512 bytes of file.\n        :param int end_range:\n            End of byte range to use for updating a section of the file.\n            The range can be up to 4 MB in size.\n            The start_range and end_range params are inclusive.\n            Ex: start_range=0, end_range=511 will download first 512 bytes of file.\n        :param str content_md5:\n            An MD5 hash of the range content. This hash is used to\n            verify the integrity of the range during transport. When this header\n            is specified, the storage service compares the hash of the content\n            that has arrived with the header value that was sent. If the two\n            hashes do not match, the operation will fail with error code 400\n            (Bad Request).\n        :param int timeout:\n            The timeout parameter is expressed in seconds.\n        '''\n        _validate_not_none('share_name', share_name)\n        _validate_not_none('file_name', file_name)\n        _validate_not_none('data', data)\n        request = HTTPRequest()\n        request.method = 'PUT'\n        request.host = self._get_host()\n        request.path = _get_path(share_name, directory_name, file_name)\n        request.query = [\n            ('comp', 'range'),\n            ('timeout', _int_to_str(timeout)),\n        ]\n        request.headers = [\n            ('Content-MD5', _to_str(content_md5)),\n            ('x-ms-write', 'update'),\n        ]\n        _validate_and_format_range_headers(\n            request, start_range, end_range)\n        request.body = _get_request_body_bytes_only('data', data)\n\n        self._perform_request(request)", "response": "Update the range of the file in the specified share."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef clear_range(self, share_name, directory_name, file_name, start_range,\n                    end_range, timeout=None):\n        '''\n        Clears the specified range and releases the space used in storage for \n        that range.\n         \n        :param str share_name:\n            Name of existing share.\n        :param str directory_name:\n            The path to the directory.\n        :param str file_name:\n            Name of existing file.\n        :param int start_range:\n            Start of byte range to use for clearing a section of the file.\n            The range can be up to 4 MB in size.\n            The start_range and end_range params are inclusive.\n            Ex: start_range=0, end_range=511 will download first 512 bytes of file.\n        :param int end_range:\n            End of byte range to use for clearing a section of the file.\n            The range can be up to 4 MB in size.\n            The start_range and end_range params are inclusive.\n            Ex: start_range=0, end_range=511 will download first 512 bytes of file.\n        :param int timeout:\n            The timeout parameter is expressed in seconds.\n        '''\n        _validate_not_none('share_name', share_name)\n        _validate_not_none('file_name', file_name)\n        request = HTTPRequest()\n        request.method = 'PUT'\n        request.host = self._get_host()\n        request.path = _get_path(share_name, directory_name, file_name)\n        request.query = [\n            ('comp', 'range'),\n            ('timeout', _int_to_str(timeout)),\n        ]\n        request.headers = [\n            ('Content-Length', '0'),\n            ('x-ms-write', 'clear'),\n        ]\n        _validate_and_format_range_headers(\n            request, start_range, end_range)\n\n        self._perform_request(request)", "response": "Clears the specified range and releases the space used in storage for \n        that range is in the specified range."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef list_ranges(self, share_name, directory_name, file_name,\n                    start_range=None, end_range=None, timeout=None):\n        '''\n        Retrieves the valid ranges for a file.\n\n        :param str share_name:\n            Name of existing share.\n        :param str directory_name:\n            The path to the directory.\n        :param str file_name:\n            Name of existing file.\n        :param int start_range:\n            Specifies the start offset of bytes over which to list ranges.\n            The start_range and end_range params are inclusive.\n            Ex: start_range=0, end_range=511 will download first 512 bytes of file.\n        :param int end_range:\n            Specifies the end offset of bytes over which to list ranges.\n            The start_range and end_range params are inclusive.\n            Ex: start_range=0, end_range=511 will download first 512 bytes of file.\n        :param int timeout:\n            The timeout parameter is expressed in seconds.\n        :returns: a list of valid ranges\n        :rtype: a list of :class:`.FileRange`\n        '''\n        _validate_not_none('share_name', share_name)\n        _validate_not_none('file_name', file_name)\n        request = HTTPRequest()\n        request.method = 'GET'\n        request.host = self._get_host()\n        request.path = _get_path(share_name, directory_name, file_name)\n        request.query = [\n            ('comp', 'rangelist'),\n            ('timeout', _int_to_str(timeout)),\n        ]\n        if start_range is not None:\n            _validate_and_format_range_headers(\n                request,\n                start_range,\n                end_range,\n                start_range_required=False,\n                end_range_required=False)\n\n        response = self._perform_request(request)\n        return _convert_xml_to_ranges(response)", "response": "Retrieves the valid ranges for a file in a given share."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting the sushy system for the system_id.", "response": "def _get_sushy_system(self, system_id):\n        \"\"\"Get the sushy system for system_id\n\n        :param system_id: The identity of the System resource\n        :returns: the Sushy system instance\n        :raises: IloError\n        \"\"\"\n        system_url = parse.urljoin(self._sushy.get_system_collection_path(),\n                                   system_id)\n        try:\n            return self._sushy.get_system(system_url)\n        except sushy.exceptions.SushyError as e:\n            msg = (self._('The Redfish System \"%(system)s\" was not found. '\n                          'Error %(error)s') %\n                   {'system': system_id, 'error': str(e)})\n            LOG.debug(msg)\n            raise exception.IloError(msg)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _get_sushy_manager(self, manager_id):\n        manager_url = parse.urljoin(self._sushy.get_manager_collection_path(),\n                                    manager_id)\n        try:\n            return self._sushy.get_manager(manager_url)\n        except sushy.exceptions.SushyError as e:\n            msg = (self._('The Redfish Manager \"%(manager)s\" was not found. '\n                          'Error %(error)s') %\n                   {'manager': manager_id, 'error': str(e)})\n            LOG.debug(msg)\n            raise exception.IloError(msg)", "response": "Get the sushy Manager for the manager_id."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nrequest the power state of the server.", "response": "def get_host_power_status(self):\n        \"\"\"Request the power state of the server.\n\n        :returns: Power State of the server, 'ON' or 'OFF'\n        :raises: IloError, on an error from iLO.\n        \"\"\"\n        sushy_system = self._get_sushy_system(PROLIANT_SYSTEM_ID)\n        return GET_POWER_STATE_MAP.get(sushy_system.power_state)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nresets the server. :raises: IloError, on an error from iLO.", "response": "def reset_server(self):\n        \"\"\"Resets the server.\n\n        :raises: IloError, on an error from iLO.\n        \"\"\"\n        sushy_system = self._get_sushy_system(PROLIANT_SYSTEM_ID)\n        try:\n            sushy_system.reset_system(sushy.RESET_FORCE_RESTART)\n        except sushy.exceptions.SushyError as e:\n            msg = (self._('The Redfish controller failed to reset server. '\n                          'Error %(error)s') %\n                   {'error': str(e)})\n            LOG.debug(msg)\n            raise exception.IloError(msg)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set_host_power(self, target_value):\n        if target_value not in POWER_RESET_MAP:\n            msg = ('The parameter \"%(parameter)s\" value \"%(target_value)s\" is '\n                   'invalid. Valid values are: %(valid_power_values)s' %\n                   {'parameter': 'target_value', 'target_value': target_value,\n                    'valid_power_values': POWER_RESET_MAP.keys()})\n            raise exception.InvalidInputError(msg)\n\n        # Check current power status, do not act if it's in requested state.\n        current_power_status = self.get_host_power_status()\n        if current_power_status == target_value:\n            LOG.debug(self._(\"Node is already in '%(target_value)s' power \"\n                             \"state.\"), {'target_value': target_value})\n            return\n\n        sushy_system = self._get_sushy_system(PROLIANT_SYSTEM_ID)\n        try:\n            sushy_system.reset_system(POWER_RESET_MAP[target_value])\n        except sushy.exceptions.SushyError as e:\n            msg = (self._('The Redfish controller failed to set power state '\n                          'of server to %(target_value)s. Error %(error)s') %\n                   {'target_value': target_value, 'error': str(e)})\n            LOG.debug(msg)\n            raise exception.IloError(msg)", "response": "Sets the power state of the server."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef press_pwr_btn(self):\n        sushy_system = self._get_sushy_system(PROLIANT_SYSTEM_ID)\n        try:\n            sushy_system.push_power_button(sys_cons.PUSH_POWER_BUTTON_PRESS)\n        except sushy.exceptions.SushyError as e:\n            msg = (self._('The Redfish controller failed to press power button'\n                          ' of server. Error %(error)s') %\n                   {'error': str(e)})\n            LOG.debug(msg)\n            raise exception.IloError(msg)", "response": "Simulates a physical press of the server power button."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nactivate the iLO license.", "response": "def activate_license(self, key):\n        \"\"\"Activates iLO license.\n\n        :param key: iLO license key.\n        :raises: IloError, on an error from iLO.\n        \"\"\"\n        sushy_manager = self._get_sushy_manager(PROLIANT_MANAGER_ID)\n        try:\n            sushy_manager.set_license(key)\n        except sushy.exceptions.SushyError as e:\n            msg = (self._('The Redfish controller failed to update '\n                          'the license. Error %(error)s') %\n                   {'error': str(e)})\n            LOG.debug(msg)\n            raise exception.IloError(msg)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nretrieves the current setting for the one - time boot.", "response": "def get_one_time_boot(self):\n        \"\"\"Retrieves the current setting for the one time boot.\n\n        :returns: Returns boot device that would be used in next\n                  boot. Returns 'Normal' if no device is set.\n        \"\"\"\n        sushy_system = self._get_sushy_system(PROLIANT_SYSTEM_ID)\n        if (sushy_system.boot.enabled == sushy.BOOT_SOURCE_ENABLED_ONCE):\n            return DEVICE_REDFISH_TO_COMMON.get(sushy_system.boot.target)\n        else:\n            # value returned by RIBCL if one-time boot setting are absent\n            return 'Normal'"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_pending_boot_mode(self):\n        sushy_system = self._get_sushy_system(PROLIANT_SYSTEM_ID)\n        try:\n            return BOOT_MODE_MAP.get(\n                sushy_system.bios_settings.pending_settings.boot_mode)\n        except sushy.exceptions.SushyError as e:\n            msg = (self._('The pending BIOS Settings was not found. Error '\n                          '%(error)s') %\n                   {'error': str(e)})\n            LOG.debug(msg)\n            raise exception.IloError(msg)", "response": "Retrieves the pending boot mode of the server."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nchecks if the device is valid virtual media.", "response": "def _validate_virtual_media(self, device):\n        \"\"\"Check if the device is valid device.\n\n        :param device: virtual media device\n        :raises: IloInvalidInputError, if the device is not valid.\n        \"\"\"\n        if device not in VIRTUAL_MEDIA_MAP:\n            msg = (self._(\"Invalid device '%s'. Valid devices: FLOPPY or \"\n                          \"CDROM.\")\n                   % device)\n            LOG.debug(msg)\n            raise exception.IloInvalidInputError(msg)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef eject_virtual_media(self, device):\n        self._validate_virtual_media(device)\n        manager = self._get_sushy_manager(PROLIANT_MANAGER_ID)\n        try:\n            vmedia_device = (\n                manager.virtual_media.get_member_device(\n                    VIRTUAL_MEDIA_MAP[device]))\n            if not vmedia_device.inserted:\n                LOG.debug(self._(\"No media available in the device '%s' to \"\n                                 \"perform eject operation.\") % device)\n                return\n\n            LOG.debug(self._(\"Ejecting the media image '%(url)s' from the \"\n                             \"device %(device)s.\") %\n                      {'url': vmedia_device.image, 'device': device})\n            vmedia_device.eject_media()\n        except sushy.exceptions.SushyError as e:\n            msg = (self._(\"The Redfish controller failed to eject the virtual\"\n                          \" media device '%(device)s'. Error %(error)s.\") %\n                   {'device': device, 'error': str(e)})\n            LOG.debug(msg)\n            raise exception.IloError(msg)", "response": "Ejects the Virtual Media image if one is inserted."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef set_vm_status(self, device='FLOPPY',\n                      boot_option='BOOT_ONCE', write_protect='YES'):\n        \"\"\"Sets the Virtual Media drive status\n\n        It sets the boot option for virtual media device.\n        Note: boot option can be set only for CD device.\n\n        :param device: virual media device\n        :param boot_option: boot option to set on the virtual media device\n        :param write_protect: set the write protect flag on the vmedia device\n                              Note: It's ignored. In Redfish it is read-only.\n        :raises: IloError, on an error from iLO.\n        :raises: IloInvalidInputError, if the device is not valid.\n        \"\"\"\n        # CONNECT is a RIBCL call. There is no such property to set in Redfish.\n        if boot_option == 'CONNECT':\n            return\n\n        self._validate_virtual_media(device)\n\n        if boot_option not in BOOT_OPTION_MAP:\n            msg = (self._(\"Virtual media boot option '%s' is invalid.\")\n                   % boot_option)\n            LOG.debug(msg)\n            raise exception.IloInvalidInputError(msg)\n\n        manager = self._get_sushy_manager(PROLIANT_MANAGER_ID)\n        try:\n            vmedia_device = (\n                manager.virtual_media.get_member_device(\n                    VIRTUAL_MEDIA_MAP[device]))\n            vmedia_device.set_vm_status(BOOT_OPTION_MAP[boot_option])\n        except sushy.exceptions.SushyError as e:\n            msg = (self._(\"The Redfish controller failed to set the virtual \"\n                          \"media status for '%(device)s'. Error %(error)s\") %\n                   {'device': device, 'error': str(e)})\n            LOG.debug(msg)\n            raise exception.IloError(msg)", "response": "Set the virtual media drive status for the specified virtual media device."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nupdates the given firmware on the server for the given component type.", "response": "def update_firmware(self, file_url, component_type):\n        \"\"\"Updates the given firmware on the server for the given component.\n\n        :param file_url: location of the raw firmware file. Extraction of the\n                         firmware file (if in compact format) is expected to\n                         happen prior to this invocation.\n        :param component_type: Type of component to be applied to.\n        :raises: IloError, on an error from iLO.\n        \"\"\"\n        try:\n            update_service_inst = self._sushy.get_update_service()\n            update_service_inst.flash_firmware(self, file_url)\n        except sushy.exceptions.SushyError as e:\n            msg = (self._('The Redfish controller failed to update firmware '\n                          'with firmware %(file)s Error %(error)s') %\n                   {'file': file_url, 'error': str(e)})\n            LOG.debug(msg)\n            raise exception.IloError(msg)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncheck if the system is in uefi boot mode.", "response": "def _is_boot_mode_uefi(self):\n        \"\"\"Checks if the system is in uefi boot mode.\n\n        :return: 'True' if the boot mode is uefi else 'False'\n        \"\"\"\n        boot_mode = self.get_current_boot_mode()\n        return (boot_mode == BOOT_MODE_MAP.get(sys_cons.BIOS_BOOT_MODE_UEFI))"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets persistent boot device for the host.", "response": "def get_persistent_boot_device(self):\n        \"\"\"Get current persistent boot device set for the host\n\n        :returns: persistent boot device for the system\n        :raises: IloError, on an error from iLO.\n        \"\"\"\n        sushy_system = self._get_sushy_system(PROLIANT_SYSTEM_ID)\n        # Return boot device if it is persistent.\n        if ((sushy_system.\n             boot.enabled) == sushy.BOOT_SOURCE_ENABLED_CONTINUOUS):\n            return PERSISTENT_BOOT_MAP.get(sushy_system.boot.target)\n        # Check if we are in BIOS boot mode.\n        # There is no resource to fetch boot device order for BIOS boot mode\n        if not self._is_boot_mode_uefi():\n            return None\n\n        try:\n            boot_device = (sushy_system.bios_settings.boot_settings.\n                           get_persistent_boot_device())\n            return PERSISTENT_BOOT_MAP.get(boot_device)\n        except sushy.exceptions.SushyError as e:\n            msg = (self._(\"The Redfish controller is unable to get \"\n                          \"persistent boot device. Error %(error)s\") %\n                   {'error': str(e)})\n            LOG.debug(msg)\n            raise exception.IloError(msg)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsetting the pending boot mode of the system for next boot.", "response": "def set_pending_boot_mode(self, boot_mode):\n        \"\"\"Sets the boot mode of the system for next boot.\n\n        :param boot_mode: either 'uefi' or 'legacy'.\n        :raises: IloInvalidInputError, on an invalid input.\n        :raises: IloError, on an error from iLO.\n        \"\"\"\n        sushy_system = self._get_sushy_system(PROLIANT_SYSTEM_ID)\n\n        if boot_mode.upper() not in BOOT_MODE_MAP_REV.keys():\n            msg = (('Invalid Boot mode: \"%(boot_mode)s\" specified, valid boot '\n                    'modes are either \"uefi\" or \"legacy\"')\n                   % {'boot_mode': boot_mode})\n            raise exception.IloInvalidInputError(msg)\n\n        try:\n            sushy_system.bios_settings.pending_settings.set_pending_boot_mode(\n                BOOT_MODE_MAP_REV.get(boot_mode.upper()))\n        except sushy.exceptions.SushyError as e:\n            msg = (self._('The Redfish controller failed to set '\n                          'pending boot mode to %(boot_mode)s. '\n                          'Error: %(error)s') %\n                   {'boot_mode': boot_mode, 'error': str(e)})\n            LOG.debug(msg)\n            raise exception.IloError(msg)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef update_persistent_boot(self, devices=[]):\n        sushy_system = self._get_sushy_system(PROLIANT_SYSTEM_ID)\n        # Check if the input is valid\n        for item in devices:\n            if item.upper() not in DEVICE_COMMON_TO_REDFISH:\n                msg = (self._('Invalid input \"%(device)s\". Valid devices: '\n                              'NETWORK, HDD, ISCSI or CDROM.') %\n                       {'device': item})\n                raise exception.IloInvalidInputError(msg)\n\n        try:\n            sushy_system.update_persistent_boot(\n                devices, persistent=True)\n        except sushy.exceptions.SushyError as e:\n            msg = (self._('The Redfish controller failed to update '\n                          'persistent boot device %(devices)s.'\n                          'Error: %(error)s') %\n                   {'devices': devices, 'error': str(e)})\n            LOG.debug(msg)\n            raise exception.IloError(msg)", "response": "Updates the persistent boot order for the host."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef set_one_time_boot(self, device):\n        sushy_system = self._get_sushy_system(PROLIANT_SYSTEM_ID)\n        # Check if the input is valid\n        if device.upper() not in DEVICE_COMMON_TO_REDFISH:\n            msg = (self._('Invalid input \"%(device)s\". Valid devices: '\n                          'NETWORK, HDD, ISCSI or CDROM.') %\n                   {'device': device})\n            raise exception.IloInvalidInputError(msg)\n\n        try:\n            sushy_system.update_persistent_boot(\n                [device], persistent=False)\n        except sushy.exceptions.SushyError as e:\n            msg = (self._('The Redfish controller failed to set '\n                          'one time boot device %(device)s. '\n                          'Error: %(error)s') %\n                   {'device': device, 'error': str(e)})\n            LOG.debug(msg)\n            raise exception.IloError(msg)", "response": "Configures a single boot from a specific device."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nresetting the iLO password.", "response": "def reset_ilo_credential(self, password):\n        \"\"\"Resets the iLO password.\n\n        :param password: The password to be set.\n        :raises: IloError, if account not found or on an error from iLO.\n        \"\"\"\n        try:\n            acc_service = self._sushy.get_account_service()\n            member = acc_service.accounts.get_member_details(self._username)\n            if member is None:\n                msg = (self._(\"No account found with username: %s\")\n                       % self._username)\n                LOG.debug(msg)\n                raise exception.IloError(msg)\n            member.update_credentials(password)\n        except sushy.exceptions.SushyError as e:\n            msg = (self._('The Redfish controller failed to update '\n                          'credentials for %(username)s. Error %(error)s') %\n                   {'username': self._username, 'error': str(e)})\n            LOG.debug(msg)\n            raise exception.IloError(msg)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_supported_boot_mode(self):\n        sushy_system = self._get_sushy_system(PROLIANT_SYSTEM_ID)\n        try:\n            return SUPPORTED_BOOT_MODE_MAP.get(\n                sushy_system.supported_boot_mode)\n        except sushy.exceptions.SushyError as e:\n            msg = (self._('The Redfish controller failed to get the '\n                          'supported boot modes. Error: %s') % e)\n            LOG.debug(msg)\n            raise exception.IloError(msg)", "response": "Get the system supported boot modes."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the server capabilities from the iLO server.", "response": "def get_server_capabilities(self):\n        \"\"\"Returns the server capabilities\n\n        raises: IloError on an error from iLO.\n        \"\"\"\n        capabilities = {}\n\n        sushy_system = self._get_sushy_system(PROLIANT_SYSTEM_ID)\n        sushy_manager = self._get_sushy_manager(PROLIANT_MANAGER_ID)\n        try:\n            count = len(sushy_system.pci_devices.gpu_devices)\n            boot_mode = rf_utils.get_supported_boot_mode(\n                sushy_system.supported_boot_mode)\n            capabilities.update(\n                {'pci_gpu_devices': count,\n                 'ilo_firmware_version': sushy_manager.firmware_version,\n                 'rom_firmware_version': sushy_system.rom_version,\n                 'server_model': sushy_system.model,\n                 'nic_capacity': sushy_system.pci_devices.max_nic_capacity,\n                 'boot_mode_bios': boot_mode.boot_mode_bios,\n                 'boot_mode_uefi': boot_mode.boot_mode_uefi})\n\n            tpm_state = sushy_system.bios_settings.tpm_state\n            all_key_to_value_expression_tuples = [\n                ('sriov_enabled',\n                 sushy_system.bios_settings.sriov == sys_cons.SRIOV_ENABLED),\n                ('cpu_vt',\n                 sushy_system.bios_settings.cpu_vt == (\n                     sys_cons.CPUVT_ENABLED)),\n                ('trusted_boot',\n                 (tpm_state == sys_cons.TPM_PRESENT_ENABLED\n                  or tpm_state == sys_cons.TPM_PRESENT_DISABLED)),\n                ('secure_boot', self._has_secure_boot()),\n                ('iscsi_boot',\n                 (sushy_system.bios_settings.iscsi_resource.\n                  is_iscsi_boot_supported())),\n                ('hardware_supports_raid',\n                 len(sushy_system.smart_storage.array_controllers.\n                     members_identities) > 0),\n                ('has_ssd',\n                 common_storage.has_ssd(sushy_system)),\n                ('has_rotational',\n                 common_storage.has_rotational(sushy_system)),\n                ('has_nvme_ssd',\n                 common_storage.has_nvme_ssd(sushy_system))\n                ]\n\n            all_key_to_value_expression_tuples += (\n                [('logical_raid_level_' + x, True)\n                 for x in sushy_system.smart_storage.logical_raid_levels])\n\n            all_key_to_value_expression_tuples += (\n                [('drive_rotational_' + str(x) + '_rpm', True)\n                 for x in\n                 common_storage.get_drive_rotational_speed_rpm(sushy_system)])\n\n            capabilities.update(\n                {key: 'true'\n                 for (key, value) in all_key_to_value_expression_tuples\n                 if value})\n\n            memory_data = sushy_system.memory.details()\n\n            if memory_data.has_nvdimm_n:\n                capabilities.update(\n                    {'persistent_memory': (\n                     json.dumps(memory_data.has_persistent_memory)),\n                     'nvdimm_n': (\n                     json.dumps(memory_data.has_nvdimm_n)),\n                     'logical_nvdimm_n': (\n                     json.dumps(memory_data.has_logical_nvdimm_n))})\n\n        except sushy.exceptions.SushyError as e:\n            msg = (self._(\"The Redfish controller is unable to get \"\n                          \"resource or its members. Error \"\n                          \"%(error)s)\") % {'error': str(e)})\n            LOG.debug(msg)\n            raise exception.IloError(msg)\n        return capabilities"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef reset_bios_to_default(self):\n        sushy_system = self._get_sushy_system(PROLIANT_SYSTEM_ID)\n        try:\n            sushy_system.bios_settings.update_bios_to_default()\n        except sushy.exceptions.SushyError as e:\n            msg = (self._(\"The Redfish controller is unable to update bios \"\n                          \"settings to default Error %(error)s\") %\n                   {'error': str(e)})\n            LOG.debug(msg)\n            raise exception.IloError(msg)", "response": "Resets the BIOS settings to default values."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_secure_boot_mode(self):\n        sushy_system = self._get_sushy_system(PROLIANT_SYSTEM_ID)\n        try:\n            secure_boot_enabled = GET_SECUREBOOT_CURRENT_BOOT_MAP.get(\n                sushy_system.secure_boot.current_boot)\n        except sushy.exceptions.SushyError as e:\n            msg = (self._('The Redfish controller failed to provide '\n                          'information about secure boot on the server. '\n                          'Error: %(error)s') %\n                   {'error': str(e)})\n            LOG.debug(msg)\n            raise exception.IloCommandNotSupportedError(msg)\n\n        if secure_boot_enabled:\n            LOG.debug(self._(\"Secure boot is Enabled\"))\n        else:\n            LOG.debug(self._(\"Secure boot is Disabled\"))\n        return secure_boot_enabled", "response": "Get the status of secure boot on the server."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef set_secure_boot_mode(self, secure_boot_enable):\n        if self._is_boot_mode_uefi():\n            sushy_system = self._get_sushy_system(PROLIANT_SYSTEM_ID)\n            try:\n                sushy_system.secure_boot.enable_secure_boot(secure_boot_enable)\n            except exception.InvalidInputError as e:\n                msg = (self._('Invalid input. Error %(error)s')\n                       % {'error': str(e)})\n                LOG.debug(msg)\n                raise exception.IloError(msg)\n            except sushy.exceptions.SushyError as e:\n                msg = (self._('The Redfish controller failed to set secure '\n                              'boot settings on the server. Error: %(error)s')\n                       % {'error': str(e)})\n                LOG.debug(msg)\n                raise exception.IloError(msg)\n        else:\n            msg = (self._('System is not in UEFI boot mode. \"SecureBoot\" '\n                          'related resources cannot be changed.'))\n            raise exception.IloCommandNotSupportedInBiosError(msg)", "response": "Enable or disable secure boot on the server."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nresets secure boot keys to manufacturing defaults.", "response": "def reset_secure_boot_keys(self):\n        \"\"\"Reset secure boot keys to manufacturing defaults.\n\n        :raises: IloError, on an error from iLO.\n        :raises: IloCommandNotSupportedError, if the command is not supported\n                 on the server.\n        \"\"\"\n        if self._is_boot_mode_uefi():\n            sushy_system = self._get_sushy_system(PROLIANT_SYSTEM_ID)\n            try:\n                sushy_system.secure_boot.reset_keys(\n                    sys_cons.SECUREBOOT_RESET_KEYS_DEFAULT)\n            except sushy.exceptions.SushyError as e:\n                msg = (self._('The Redfish controller failed to reset secure '\n                              'boot keys on the server. Error %(error)s')\n                       % {'error': str(e)})\n                LOG.debug(msg)\n                raise exception.IloError(msg)\n        else:\n            msg = (self._('System is not in UEFI boot mode. \"SecureBoot\" '\n                          'related resources cannot be changed.'))\n            raise exception.IloCommandNotSupportedInBiosError(msg)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nconstructs the dictionary of essential properties named cpu cpu_arch local_gb memory_mb", "response": "def get_essential_properties(self):\n        \"\"\"Constructs the dictionary of essential properties\n\n        Constructs the dictionary of essential properties, named\n        cpu, cpu_arch, local_gb, memory_mb. The MACs are also returned\n        as part of this method.\n        \"\"\"\n        sushy_system = self._get_sushy_system(PROLIANT_SYSTEM_ID)\n        try:\n            # TODO(nisha): Add local_gb here and return after\n            # local_gb changes are merged.\n            # local_gb = sushy_system.storage_summary\n            prop = {'memory_mb': (sushy_system.memory_summary.size_gib * 1024),\n                    'cpus': sushy_system.processors.summary.count,\n                    'cpu_arch': sushy_map.PROCESSOR_ARCH_VALUE_MAP_REV.get(\n                    sushy_system.processors.summary.architecture),\n                    'local_gb': common_storage.get_local_gb(sushy_system)}\n            return {'properties': prop,\n                    'macs': sushy_system.ethernet_interfaces.summary}\n        except sushy.exceptions.SushyError as e:\n            msg = (self._('The Redfish controller failed to get the '\n                          'resource data. Error %(error)s')\n                   % {'error': str(e)})\n            LOG.debug(msg)\n            raise exception.IloError(msg)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nchanging iSCSI target settings.", "response": "def _change_iscsi_target_settings(self, iscsi_info):\n        \"\"\"Change iSCSI target settings.\n\n        :param iscsi_info: A dictionary that contains information of iSCSI\n                           target like target_name, lun, ip_address, port etc.\n        :raises: IloError, on an error from iLO.\n        \"\"\"\n        sushy_system = self._get_sushy_system(PROLIANT_SYSTEM_ID)\n        try:\n            pci_settings_map = (\n                sushy_system.bios_settings.bios_mappings.pci_settings_mappings)\n            nics = []\n            for mapping in pci_settings_map:\n                for subinstance in mapping['Subinstances']:\n                    for association in subinstance['Associations']:\n                        if 'NicBoot' in association:\n                            nics.append(association)\n        except sushy.exceptions.SushyError as e:\n            msg = (self._('The Redfish controller failed to get the '\n                          'bios mappings. Error %(error)s')\n                   % {'error': str(e)})\n            LOG.debug(msg)\n            raise exception.IloError(msg)\n\n        if not nics:\n            msg = ('No nics were found on the system')\n            raise exception.IloError(msg)\n\n        # Set iSCSI info to all nics\n        iscsi_infos = []\n        for nic in nics:\n            data = iscsi_info.copy()\n            data['iSCSIAttemptName'] = nic\n            data['iSCSINicSource'] = nic\n            data['iSCSIAttemptInstance'] = nics.index(nic) + 1\n            iscsi_infos.append(data)\n\n        iscsi_data = {'iSCSISources': iscsi_infos}\n        try:\n            (sushy_system.bios_settings.iscsi_resource.\n             iscsi_settings.update_iscsi_settings(iscsi_data))\n        except sushy.exceptions.SushyError as e:\n            msg = (self._(\"The Redfish controller is failed to update iSCSI \"\n                          \"settings. Error %(error)s\") %\n                   {'error': str(e)})\n            LOG.debug(msg)\n            raise exception.IloError(msg)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset iSCSI details of the initiator system in UEFI boot mode.", "response": "def set_iscsi_info(self, target_name, lun, ip_address,\n                       port='3260', auth_method=None, username=None,\n                       password=None):\n        \"\"\"Set iSCSI details of the system in UEFI boot mode.\n\n        The initiator system is set with the target details like\n        IQN, LUN, IP, Port etc.\n        :param target_name: Target Name for iSCSI.\n        :param lun: logical unit number.\n        :param ip_address: IP address of the target.\n        :param port: port of the target.\n        :param auth_method : either None or CHAP.\n        :param username: CHAP Username for authentication.\n        :param password: CHAP secret.\n        :raises: IloCommandNotSupportedInBiosError, if the system is\n                 in the bios boot mode.\n        \"\"\"\n        if(self._is_boot_mode_uefi()):\n            iscsi_info = {}\n            iscsi_info['iSCSITargetName'] = target_name\n            iscsi_info['iSCSILUN'] = lun\n            iscsi_info['iSCSITargetIpAddress'] = ip_address\n            iscsi_info['iSCSITargetTcpPort'] = int(port)\n            iscsi_info['iSCSITargetInfoViaDHCP'] = False\n            iscsi_info['iSCSIConnection'] = 'Enabled'\n            if (auth_method == 'CHAP'):\n                iscsi_info['iSCSIAuthenticationMethod'] = 'Chap'\n                iscsi_info['iSCSIChapUsername'] = username\n                iscsi_info['iSCSIChapSecret'] = password\n            self._change_iscsi_target_settings(iscsi_info)\n        else:\n            msg = 'iSCSI boot is not supported in the BIOS boot mode'\n            raise exception.IloCommandNotSupportedInBiosError(msg)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef unset_iscsi_info(self):\n        if(self._is_boot_mode_uefi()):\n            iscsi_info = {'iSCSIConnection': 'Disabled'}\n            self._change_iscsi_target_settings(iscsi_info)\n        else:\n            msg = 'iSCSI boot is not supported in the BIOS boot mode'\n            raise exception.IloCommandNotSupportedInBiosError(msg)", "response": "Disable iSCSI boot option in UEFI boot mode."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset iSCSI initiator information in iLO.", "response": "def set_iscsi_initiator_info(self, initiator_iqn):\n        \"\"\"Set iSCSI initiator information in iLO.\n\n        :param initiator_iqn: Initiator iqn for iLO.\n        :raises: IloError, on an error from iLO.\n        :raises: IloCommandNotSupportedInBiosError, if the system is\n                 in the BIOS boot mode.\n        \"\"\"\n        sushy_system = self._get_sushy_system(PROLIANT_SYSTEM_ID)\n        if(self._is_boot_mode_uefi()):\n            iscsi_data = {'iSCSIInitiatorName': initiator_iqn}\n            try:\n                (sushy_system.bios_settings.iscsi_resource.\n                 iscsi_settings.update_iscsi_settings(iscsi_data))\n            except sushy.exceptions.SushyError as e:\n                msg = (self._(\"The Redfish controller has failed to update \"\n                              \"iSCSI settings. Error %(error)s\") %\n                       {'error': str(e)})\n                LOG.debug(msg)\n                raise exception.IloError(msg)\n        else:\n            msg = 'iSCSI initiator cannot be updated in BIOS boot mode'\n            raise exception.IloCommandNotSupportedInBiosError(msg)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_iscsi_initiator_info(self):\n        sushy_system = self._get_sushy_system(PROLIANT_SYSTEM_ID)\n        if(self._is_boot_mode_uefi()):\n            try:\n                iscsi_initiator = (\n                    sushy_system.bios_settings.iscsi_resource.iscsi_initiator)\n            except sushy.exceptions.SushyError as e:\n                msg = (self._('The Redfish controller has failed to get the '\n                              'iSCSI initiator. Error %(error)s')\n                       % {'error': str(e)})\n                LOG.debug(msg)\n                raise exception.IloError(msg)\n            return iscsi_initiator\n        else:\n            msg = 'iSCSI initiator cannot be retrieved in BIOS boot mode'\n            raise exception.IloCommandNotSupportedInBiosError(msg)", "response": "Give iSCSI initiator information of iLO."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ninject NMI and Non Maskable Interrupt for a node immediately.", "response": "def inject_nmi(self):\n        \"\"\"Inject NMI, Non Maskable Interrupt.\n\n        Inject NMI (Non Maskable Interrupt) for a node immediately.\n\n        :raises: IloError, on an error from iLO\n        \"\"\"\n        sushy_system = self._get_sushy_system(PROLIANT_SYSTEM_ID)\n        if sushy_system.power_state != sushy.SYSTEM_POWER_STATE_ON:\n            raise exception.IloError(\"Server is not in powered on state.\")\n\n        try:\n            sushy_system.reset_system(sushy.RESET_NMI)\n        except sushy.exceptions.SushyError as e:\n            msg = (self._('The Redfish controller failed to inject nmi to '\n                          'server. Error %(error)s') % {'error': str(e)})\n            LOG.debug(msg)\n            raise exception.IloError(msg)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_host_post_state(self):\n        sushy_system = self._get_sushy_system(PROLIANT_SYSTEM_ID)\n        return GET_POST_STATE_MAP.get(sushy_system.post_state)", "response": "Get the current state of system POST."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreads the logical drives from the system", "response": "def read_raid_configuration(self, raid_config=None):\n        \"\"\"Read the logical drives from the system\n\n        :param raid_config: None in case of post-delete read or in case of\n                            post-create a dictionary containing target raid\n                            configuration data. This data stucture should be as\n                            follows:\n                            raid_config = {'logical_disks': [{'raid_level': 1,\n                            'size_gb': 100, 'physical_disks': ['6I:1:5'],\n                            'controller': 'HPE Smart Array P408i-a SR Gen10'},\n                            <info-for-logical-disk-2>]}\n        :raises: IloError, on an error from iLO.\n        :returns: A dictionary containing list of logical disks\n        \"\"\"\n        sushy_system = self._get_sushy_system(PROLIANT_SYSTEM_ID)\n        return sushy_system.read_raid(raid_config=raid_config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget current BIOS settings.", "response": "def get_current_bios_settings(self, only_allowed_settings=True):\n        \"\"\"Get current BIOS settings.\n\n        :param: only_allowed_settings: True when only allowed BIOS settings\n                are to be returned. If False, All the BIOS settings supported\n                by iLO are returned.\n        :return: a dictionary of current BIOS settings is returned. Depending\n                 on the 'only_allowed_settings', either only the allowed\n                 settings are returned or all the supported settings are\n                 returned.\n        :raises: IloError, on an error from iLO\n        \"\"\"\n        sushy_system = self._get_sushy_system(PROLIANT_SYSTEM_ID)\n        try:\n            current_settings = sushy_system.bios_settings.json\n        except sushy.exceptions.SushyError as e:\n            msg = (self._('The current BIOS Settings were not found. Error '\n                          '%(error)s') %\n                   {'error': str(e)})\n            LOG.debug(msg)\n            raise exception.IloError(msg)\n\n        attributes = current_settings.get(\"Attributes\")\n        if only_allowed_settings and attributes:\n            return common_utils.apply_bios_properties_filter(\n                attributes, ilo_cons.SUPPORTED_REDFISH_BIOS_PROPERTIES)\n        return attributes"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting current BIOS settings to the provided data.", "response": "def set_bios_settings(self, data=None, only_allowed_settings=True):\n        \"\"\"Sets current BIOS settings to the provided data.\n\n        :param: only_allowed_settings: True when only allowed BIOS settings\n                are to be set. If False, all the BIOS settings supported by\n                iLO and present in the 'data' are set.\n        :param: data: a dictionary of BIOS settings to be applied. Depending\n                on the 'only_allowed_settings', either only the allowed\n                settings are set or all the supported settings that are in the\n                'data' are set.\n        :raises: IloError, on an error from iLO.\n        :raises: IloCommandNotSupportedError, if the command is not supported\n                 on the server.\n        \"\"\"\n        if not data:\n            raise exception.IloError(\"Could not apply settings with\"\n                                     \" empty data\")\n\n        sushy_system = self._get_sushy_system(PROLIANT_SYSTEM_ID)\n        if only_allowed_settings:\n            unsupported_settings = [key for key in data if key not in (\n                ilo_cons.SUPPORTED_REDFISH_BIOS_PROPERTIES)]\n            if unsupported_settings:\n                msg = (\"Could not apply settings as one or more settings are\"\n                       \" not supported. Unsupported settings are %s.\"\n                       \" Supported settings are %s.\" % (\n                           unsupported_settings,\n                           ilo_cons.SUPPORTED_REDFISH_BIOS_PROPERTIES))\n                raise exception.IloError(msg)\n        try:\n            settings_required = sushy_system.bios_settings.pending_settings\n            settings_required.update_bios_data_by_patch(data)\n        except sushy.exceptions.SushyError as e:\n            msg = (self._('The pending BIOS Settings resource not found.'\n                          ' Error %(error)s') %\n                   {'error': str(e)})\n            LOG.debug(msg)\n            raise exception.IloError(msg)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_default_bios_settings(self, only_allowed_settings=True):\n        sushy_system = self._get_sushy_system(PROLIANT_SYSTEM_ID)\n        try:\n            settings = sushy_system.bios_settings.default_settings\n        except sushy.exceptions.SushyError as e:\n            msg = (self._('The default BIOS Settings were not found. Error '\n                          '%(error)s') %\n                   {'error': str(e)})\n            LOG.debug(msg)\n            raise exception.IloError(msg)\n        if only_allowed_settings:\n            return common_utils.apply_bios_properties_filter(\n                settings, ilo_cons.SUPPORTED_REDFISH_BIOS_PROPERTIES)\n        return settings", "response": "Get default BIOS settings."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef create_raid_configuration(self, raid_config):\n        sushy_system = self._get_sushy_system(PROLIANT_SYSTEM_ID)\n        sushy_system.create_raid(raid_config)", "response": "Create the raid configuration on the hardware."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting the result of the bios settings applied to the server.", "response": "def get_bios_settings_result(self):\n        \"\"\"Gets the result of the bios settings applied\n\n        :raises: IloError, on an error from iLO.\n        :raises: IloCommandNotSupportedError, if the command is\n                 not supported on the server.\n        \"\"\"\n        sushy_system = self._get_sushy_system(PROLIANT_SYSTEM_ID)\n        try:\n            settings_result = sushy_system.bios_settings.messages\n        except sushy.exceptions.SushyError as e:\n            msg = (self._('The BIOS Settings results were not found. Error '\n                          '%(error)s') %\n                   {'error': str(e)})\n            LOG.debug(msg)\n            raise exception.IloError(msg)\n        status = \"failed\" if len(settings_result) > 1 else \"success\"\n        return {\"status\": status, \"results\": settings_result}"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _get_collection(self, collection_uri, request_headers=None):\n\n        # get the collection\n        status, headers, thecollection = self._rest_get(collection_uri)\n\n        if status != 200:\n            msg = self._get_extended_error(thecollection)\n            raise exception.IloError(msg)\n\n        while status < 300:\n            # verify expected type\n            # Don't limit to version 0 here as we will rev to 1.0 at some\n            # point hopefully with minimal changes\n            ctype = self._get_type(thecollection)\n            if (ctype not in ['Collection.0', 'Collection.1']):\n                raise exception.IloError(\"collection not found\")\n\n            # if this collection has inline items, return those\n            # NOTE:  Collections are very flexible in how the represent\n            # members.  They can be inline in the collection as members\n            # of the 'Items' array, or they may be href links in the\n            # links/Members array.  The could actually be both. Typically,\n            # iLO implements the inline (Items) for only when the collection\n            # is read only.  We have to render it with the href links when an\n            # array contains PATCHable items because its complex to PATCH\n            # inline collection members.\n\n            if 'Items' in thecollection:\n                # iterate items\n                for item in thecollection['Items']:\n                    # if the item has a self uri pointer,\n                    # supply that for convenience.\n                    memberuri = None\n                    if 'links' in item and 'self' in item['links']:\n                        memberuri = item['links']['self']['href']\n                    yield 200, None, item, memberuri\n\n            # else walk the member links\n            elif ('links' in thecollection and\n                  'Member' in thecollection['links']):\n                # iterate members\n                for memberuri in thecollection['links']['Member']:\n                    # for each member return the resource indicated by the\n                    # member link\n                    status, headers, member = self._rest_get(memberuri['href'])\n                    yield status, headers, member, memberuri['href']\n\n            # page forward if there are more pages in the collection\n            if ('links' in thecollection and\n                    'NextPage' in thecollection['links']):\n                next_link_uri = (collection_uri + '?page=' + str(\n                                 thecollection['links']['NextPage']['page']))\n                status, headers, thecollection = self._rest_get(next_link_uri)\n\n            # else we are finished iterating the collection\n            else:\n                break", "response": "Generator function that returns collection members."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _get_type(self, obj):\n        typever = obj['Type']\n        typesplit = typever.split('.')\n        return typesplit[0] + '.' + typesplit[1]", "response": "Return the type of an object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nparsing the ExtendedError JSON object and returns a list of plain language strings that represent the message.", "response": "def _render_extended_error_message_list(self, extended_error):\n        \"\"\"Parse the ExtendedError object and retruns the message.\n\n        Build a list of decoded messages from the extended_error using the\n        message registries. An ExtendedError JSON object is a response from\n        the with its own schema.  This function knows how to parse the\n        ExtendedError object and, using any loaded message registries,\n        render an array of plain language strings that represent\n        the response.\n        \"\"\"\n        messages = []\n        if isinstance(extended_error, dict):\n            if ('Type' in extended_error and\n                    extended_error['Type'].startswith('ExtendedError.')):\n                for msg in extended_error['Messages']:\n                    message_id = msg['MessageID']\n                    x = message_id.split('.')\n                    registry = x[0]\n                    msgkey = x[len(x) - 1]\n\n                    # if the correct message registry is loaded,\n                    # do string resolution\n                    if (registry in self.message_registries and msgkey in\n                            self.message_registries[registry]['Messages']):\n                        rmsgs = self.message_registries[registry]['Messages']\n                        msg_dict = rmsgs[msgkey]\n                        msg_str = message_id + ':  ' + msg_dict['Message']\n\n                        for argn in range(0, msg_dict['NumberOfArgs']):\n                            subst = '%' + str(argn+1)\n                            m = str(msg['MessageArgs'][argn])\n                            msg_str = msg_str.replace(subst, m)\n\n                        if ('Resolution' in msg_dict and\n                                msg_dict['Resolution'] != 'None'):\n                            msg_str += '  ' + msg_dict['Resolution']\n\n                        messages.append(msg_str)\n                    else:\n                        # no message registry, simply return the msg object\n                        # in string form\n                        messages.append(str(message_id))\n\n        return messages"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _get_host_details(self):\n        # Assuming only one system present as part of collection,\n        # as we are dealing with iLO's here.\n        status, headers, system = self._rest_get('/rest/v1/Systems/1')\n        if status < 300:\n            stype = self._get_type(system)\n            if stype not in ['ComputerSystem.0', 'ComputerSystem.1']:\n                msg = \"%s is not a valid system type \" % stype\n                raise exception.IloError(msg)\n        else:\n            msg = self._get_extended_error(system)\n            raise exception.IloError(msg)\n\n        return system", "response": "Get the system details."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _check_bios_resource(self, properties=[]):\n\n        system = self._get_host_details()\n        if ('links' in system['Oem']['Hp'] and\n                'BIOS' in system['Oem']['Hp']['links']):\n            # Get the BIOS URI and Settings\n            bios_uri = system['Oem']['Hp']['links']['BIOS']['href']\n            status, headers, bios_settings = self._rest_get(bios_uri)\n\n            if status >= 300:\n                msg = self._get_extended_error(bios_settings)\n                raise exception.IloError(msg)\n\n            # If property is not None, check if the bios_property is supported\n            for property in properties:\n                if property not in bios_settings:\n                    # not supported on this platform\n                    msg = ('BIOS Property \"' + property + '\" is not'\n                           ' supported on this system.')\n                    raise exception.IloCommandNotSupportedError(msg)\n\n            return headers, bios_uri, bios_settings\n\n        else:\n            msg = ('\"links/BIOS\" section in ComputerSystem/Oem/Hp'\n                   ' does not exist')\n            raise exception.IloCommandNotSupportedError(msg)", "response": "Check if the bios resource exists."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting the PCI devices list if the pci resource exist.", "response": "def _get_pci_devices(self):\n        \"\"\"Gets the PCI devices.\n\n        :returns: PCI devices list if the pci resource exist.\n        :raises: IloCommandNotSupportedError if the PCI resource\n            doesn't exist.\n        :raises: IloError, on an error from iLO.\n        \"\"\"\n\n        system = self._get_host_details()\n        if ('links' in system['Oem']['Hp'] and\n                'PCIDevices' in system['Oem']['Hp']['links']):\n            # Get the PCI URI and Settings\n            pci_uri = system['Oem']['Hp']['links']['PCIDevices']['href']\n            status, headers, pci_device_list = self._rest_get(pci_uri)\n\n            if status >= 300:\n                msg = self._get_extended_error(pci_device_list)\n                raise exception.IloError(msg)\n\n            return pci_device_list\n\n        else:\n            msg = ('links/PCIDevices section in ComputerSystem/Oem/Hp'\n                   ' does not exist')\n            raise exception.IloCommandNotSupportedError(msg)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the list of gpu devices.", "response": "def _get_gpu_pci_devices(self):\n        \"\"\"Returns the list of gpu devices.\"\"\"\n        pci_device_list = self._get_pci_devices()\n\n        gpu_list = []\n        items = pci_device_list['Items']\n        for item in items:\n            if item['ClassCode'] in CLASSCODE_FOR_GPU_DEVICES:\n                if item['SubclassCode'] in SUBCLASSCODE_FOR_GPU_DEVICES:\n                    gpu_list.append(item)\n        return gpu_list"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the SmartStorage resource if exists.", "response": "def _get_storage_resource(self):\n        \"\"\"Gets the SmartStorage resource if exists.\n\n        :raises: IloCommandNotSupportedError if the resource SmartStorage\n            doesn't exist.\n        :returns the tuple of SmartStorage URI, Headers and settings.\n        \"\"\"\n        system = self._get_host_details()\n        if ('links' in system['Oem']['Hp'] and\n                'SmartStorage' in system['Oem']['Hp']['links']):\n            # Get the SmartStorage URI and Settings\n            storage_uri = system['Oem']['Hp']['links']['SmartStorage']['href']\n            status, headers, storage_settings = self._rest_get(storage_uri)\n\n            if status >= 300:\n                msg = self._get_extended_error(storage_settings)\n                raise exception.IloError(msg)\n\n            return headers, storage_uri, storage_settings\n        else:\n            msg = ('\"links/SmartStorage\" section in ComputerSystem/Oem/Hp'\n                   ' does not exist')\n            raise exception.IloCommandNotSupportedError(msg)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the ArrayController resource if exists.", "response": "def _get_array_controller_resource(self):\n        \"\"\"Gets the ArrayController resource if exists.\n\n        :raises: IloCommandNotSupportedError if the resource ArrayController\n            doesn't exist.\n        :returns the tuple of SmartStorage URI, Headers and settings.\n        \"\"\"\n        headers, storage_uri, storage_settings = self._get_storage_resource()\n        if ('links' in storage_settings and\n                'ArrayControllers' in storage_settings['links']):\n            # Get the ArrayCOntrollers URI and Settings\n            array_uri = storage_settings['links']['ArrayControllers']['href']\n            status, headers, array_settings = self._rest_get(array_uri)\n\n            if status >= 300:\n                msg = self._get_extended_error(array_settings)\n                raise exception.IloError(msg)\n\n            return headers, array_uri, array_settings\n        else:\n            msg = ('\"links/ArrayControllers\" section in SmartStorage'\n                   ' does not exist')\n            raise exception.IloCommandNotSupportedError(msg)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _create_list_of_array_controllers(self):\n        headers, array_uri, array_settings = (\n            self._get_array_controller_resource())\n        array_uri_links = []\n        if ('links' in array_settings and\n                'Member' in array_settings['links']):\n            array_uri_links = array_settings['links']['Member']\n        else:\n            msg = ('\"links/Member\" section in ArrayControllers'\n                   ' does not exist')\n            raise exception.IloCommandNotSupportedError(msg)\n        return array_uri_links", "response": "Creates the list of Array Controller URIs."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the disk drive type and speed.", "response": "def _get_drive_type_and_speed(self):\n        \"\"\"Gets the disk drive type.\n\n        :returns: A dictionary with the following keys:\n            - has_rotational: True/False. It is True if atleast one\n            rotational disk is attached.\n            - has_ssd: True/False. It is True if at least one SSD disk is\n            attached.\n            - drive_rotational_<speed>_rpm: These are set to true as\n              per the speed of the rotational disks.\n        :raises: IloCommandNotSupportedError if the PhysicalDrives resource\n            doesn't exist.\n        :raises: IloError, on an error from iLO.\n        \"\"\"\n        disk_details = self._get_physical_drive_resource()\n        drive_hdd = False\n        drive_ssd = False\n        drive_details = {}\n        speed_const_list = [4800, 5400, 7200, 10000, 15000]\n        if disk_details:\n            for item in disk_details:\n                value = item['MediaType']\n                if value == \"HDD\":\n                    drive_hdd = True\n                    speed = item['RotationalSpeedRpm']\n                    if speed in speed_const_list:\n                        var = 'rotational_drive_' + str(speed) + '_rpm'\n                        drive_details.update({var: 'true'})\n                # Note: RIS returns value as 'SDD' for SSD drives.\n                else:\n                    drive_ssd = True\n        if drive_hdd:\n            drive_details.update({'has_rotational': 'true'})\n        if drive_ssd:\n            drive_details.update({'has_ssd': 'true'})\n        return drive_details if len(drive_details.keys()) > 0 else None"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _get_drive_resource(self, drive_name):\n        disk_details_list = []\n        array_uri_links = self._create_list_of_array_controllers()\n        for array_link in array_uri_links:\n            _, _, member_settings = (\n                self._rest_get(array_link['href']))\n\n            if ('links' in member_settings and\n                    drive_name in member_settings['links']):\n                disk_uri = member_settings['links'][drive_name]['href']\n                headers, disk_member_uri, disk_mem = (\n                    self._rest_get(disk_uri))\n                if ('links' in disk_mem and\n                        'Member' in disk_mem['links']):\n                    for disk_link in disk_mem['links']['Member']:\n                        diskdrive_uri = disk_link['href']\n                        _, _, disk_details = (\n                            self._rest_get(diskdrive_uri))\n                        disk_details_list.append(disk_details)\n                else:\n                    msg = ('\"links/Member\" section in %s'\n                           ' does not exist', drive_name)\n                    raise exception.IloCommandNotSupportedError(msg)\n            else:\n                msg = ('\"links/%s\" section in '\n                       ' ArrayController/links/Member does not exist',\n                       drive_name)\n                raise exception.IloCommandNotSupportedError(msg)\n        if disk_details_list:\n            return disk_details_list", "response": "Gets the DiskDrive resource if exists."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the different raid levels configured on a server.", "response": "def _get_logical_raid_levels(self):\n        \"\"\"Gets the different raid levels configured on a server.\n\n        :returns a dictionary of logical_raid_levels set to true.\n            Example if raid level 1+0 and 6 are configured, it returns\n            {'logical_raid_level_10': 'true',\n             'logical_raid_level_6': 'true'}\n        \"\"\"\n        logical_drive_details = self._get_logical_drive_resource()\n        raid_level = {}\n        if logical_drive_details:\n            for item in logical_drive_details:\n                if 'Raid' in item:\n                    raid_level_var = \"logical_raid_level_\" + item['Raid']\n                    raid_level.update({raid_level_var: 'true'})\n        return raid_level if len(raid_level.keys()) > 0 else None"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _is_raid_supported(self):\n        header, uri, array_resource = self._get_array_controller_resource()\n\n        return True if array_resource['Total'] > 0 else False", "response": "Get the RAID support on the physical server."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the BIOS settings resource.", "response": "def _get_bios_settings_resource(self, data):\n        \"\"\"Get the BIOS settings resource.\"\"\"\n        try:\n            bios_settings_uri = data['links']['Settings']['href']\n        except KeyError:\n            msg = ('BIOS Settings resource not found.')\n            raise exception.IloError(msg)\n\n        status, headers, bios_settings = self._rest_get(bios_settings_uri)\n        if status != 200:\n            msg = self._get_extended_error(bios_settings)\n            raise exception.IloError(msg)\n\n        return headers, bios_settings_uri, bios_settings"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncheck if PATCH Operation is supported on the resource.", "response": "def _validate_if_patch_supported(self, headers, uri):\n        \"\"\"Check if the PATCH Operation is allowed on the resource.\"\"\"\n        if not self._operation_allowed(headers, 'PATCH'):\n                msg = ('PATCH Operation not supported on the resource '\n                       '\"%s\"' % uri)\n                raise exception.IloError(msg)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nretrieve the bios settings of the server.", "response": "def _get_bios_setting(self, bios_property):\n        \"\"\"Retrieves bios settings of the server.\"\"\"\n        headers, bios_uri, bios_settings = self._check_bios_resource([\n            bios_property])\n        return bios_settings[bios_property]"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _get_bios_hash_password(self, bios_password):\n        request_headers = {}\n        if bios_password:\n            bios_password_hash = hashlib.sha256((bios_password.encode()).\n                                                hexdigest().upper())\n            request_headers['X-HPRESTFULAPI-AuthToken'] = bios_password_hash\n        return request_headers", "response": "Get the hashed BIOS password."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _change_bios_setting(self, properties):\n        keys = properties.keys()\n        # Check if the BIOS resource/property exists.\n        headers, bios_uri, settings = self._check_bios_resource(keys)\n        if not self._operation_allowed(headers, 'PATCH'):\n            headers, bios_uri, _ = self._get_bios_settings_resource(settings)\n            self._validate_if_patch_supported(headers, bios_uri)\n\n        request_headers = self._get_bios_hash_password(self.bios_password)\n        status, headers, response = self._rest_patch(bios_uri, request_headers,\n                                                     properties)\n        if status >= 300:\n            msg = self._get_extended_error(response)\n            raise exception.IloError(msg)", "response": "Change the bios settings to specified values."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _get_iscsi_settings_resource(self, data):\n        try:\n            iscsi_settings_uri = data['links']['Settings']['href']\n        except KeyError:\n            msg = ('iscsi settings resource not found.')\n            raise exception.IloCommandNotSupportedError(msg)\n\n        status, headers, iscsi_settings = self._rest_get(iscsi_settings_uri)\n\n        if status != 200:\n            msg = self._get_extended_error(iscsi_settings)\n            raise exception.IloError(msg)\n\n        return headers, iscsi_settings_uri, iscsi_settings", "response": "Get the iscsi settings resource."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the Boot resource like BootSources.", "response": "def _get_bios_boot_resource(self, data):\n        \"\"\"Get the Boot resource like BootSources.\n\n        :param data: Existing Bios settings of the server.\n        :returns: boot settings.\n        :raises: IloCommandNotSupportedError, if resource is not found.\n        :raises: IloError, on an error from iLO.\n        \"\"\"\n        try:\n            boot_uri = data['links']['Boot']['href']\n        except KeyError:\n            msg = ('Boot resource not found.')\n            raise exception.IloCommandNotSupportedError(msg)\n\n        status, headers, boot_settings = self._rest_get(boot_uri)\n\n        if status != 200:\n            msg = self._get_extended_error(boot_settings)\n            raise exception.IloError(msg)\n\n        return boot_settings"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget the Mappings resource.", "response": "def _get_bios_mappings_resource(self, data):\n        \"\"\"Get the Mappings resource.\n\n        :param data: Existing Bios settings of the server.\n        :returns: mappings settings.\n        :raises: IloCommandNotSupportedError, if resource is not found.\n        :raises: IloError, on an error from iLO.\n        \"\"\"\n        try:\n            map_uri = data['links']['Mappings']['href']\n        except KeyError:\n            msg = ('Mappings resource not found.')\n            raise exception.IloCommandNotSupportedError(msg)\n\n        status, headers, map_settings = self._rest_get(map_uri)\n        if status != 200:\n            msg = self._get_extended_error(map_settings)\n            raise exception.IloError(msg)\n\n        return map_settings"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _check_iscsi_rest_patch_allowed(self):\n\n        headers, bios_uri, bios_settings = self._check_bios_resource()\n        # Check if the bios resource exists.\n\n        if('links' in bios_settings and 'iScsi' in bios_settings['links']):\n            iscsi_uri = bios_settings['links']['iScsi']['href']\n            status, headers, settings = self._rest_get(iscsi_uri)\n\n            if status != 200:\n                msg = self._get_extended_error(settings)\n                raise exception.IloError(msg)\n\n            if not self._operation_allowed(headers, 'PATCH'):\n                headers, iscsi_uri, settings = (\n                    self._get_iscsi_settings_resource(settings))\n                self._validate_if_patch_supported(headers, iscsi_uri)\n\n            return iscsi_uri\n\n        else:\n            msg = ('\"links/iScsi\" section in bios'\n                   ' does not exist')\n            raise exception.IloCommandNotSupportedError(msg)", "response": "Checks if patch is supported on iscsi url."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nchanging iSCSI settings. :param iscsi_info: A dictionary that contains information of iSCSI target like target_name, lun, ip_address, port etc. :raises: IloError, on an error from iLO.", "response": "def _change_iscsi_settings(self, iscsi_info):\n        \"\"\"Change iSCSI settings.\n\n        :param iscsi_info: A dictionary that contains information of iSCSI\n                           target like target_name, lun, ip_address, port etc.\n        :raises: IloError, on an error from iLO.\n        \"\"\"\n        headers, bios_uri, bios_settings = self._check_bios_resource()\n        # Get the Mappings resource.\n        map_settings = self._get_bios_mappings_resource(bios_settings)\n        nics = []\n        for mapping in map_settings['BiosPciSettingsMappings']:\n            for subinstance in mapping['Subinstances']:\n                for association in subinstance['Associations']:\n                    if 'NicBoot' in association:\n                        nics.append(association)\n\n        if not nics:\n            msg = ('No nics found')\n            raise exception.IloError(msg)\n\n        iscsi_uri = self._check_iscsi_rest_patch_allowed()\n        # Set iSCSI info to all nics\n        iscsi_infos = []\n        for nic in nics:\n            data = iscsi_info.copy()\n            data['iSCSIBootAttemptName'] = nic\n            data['iSCSINicSource'] = nic\n            data['iSCSIBootAttemptInstance'] = nics.index(nic) + 1\n            iscsi_infos.append(data)\n\n        patch_data = {'iSCSIBootSources': iscsi_infos}\n        status, headers, response = self._rest_patch(iscsi_uri,\n                                                     None, patch_data)\n        if status >= 300:\n            msg = self._get_extended_error(response)\n            raise exception.IloError(msg)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _change_secure_boot_settings(self, property, value):\n        system = self._get_host_details()\n        # find the BIOS URI\n        if ('links' not in system['Oem']['Hp'] or\n           'SecureBoot' not in system['Oem']['Hp']['links']):\n            msg = (' \"SecureBoot\" resource or feature is not '\n                   'supported on this system')\n            raise exception.IloCommandNotSupportedError(msg)\n\n        secure_boot_uri = system['Oem']['Hp']['links']['SecureBoot']['href']\n\n        # Change the property required\n        new_secure_boot_settings = {}\n        new_secure_boot_settings[property] = value\n\n        # perform the patch\n        status, headers, response = self._rest_patch(\n            secure_boot_uri, None, new_secure_boot_settings)\n\n        if status >= 300:\n            msg = self._get_extended_error(response)\n            raise exception.IloError(msg)\n\n        # Change the bios setting as a workaround to enable secure boot\n        # Can be removed when fixed for Gen9 snap2\n        val = self._get_bios_setting('CustomPostMessage')\n        val = val.rstrip() if val.endswith(\" \") else val+\" \"\n        self._change_bios_setting({'CustomPostMessage': val})", "response": "Change the secure boot settings on the server."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the status of secure boot.", "response": "def get_secure_boot_mode(self):\n        \"\"\"Get the status of secure boot.\n\n        :returns: True, if enabled, else False\n        :raises: IloError, on an error from iLO.\n        :raises: IloCommandNotSupportedError, if the command is not supported\n                 on the server.\n        \"\"\"\n        system = self._get_host_details()\n\n        if ('links' not in system['Oem']['Hp'] or\n           'SecureBoot' not in system['Oem']['Hp']['links']):\n            msg = ('\"SecureBoot\" resource or feature is not supported'\n                   ' on this system')\n            raise exception.IloCommandNotSupportedError(msg)\n\n        secure_boot_uri = system['Oem']['Hp']['links']['SecureBoot']['href']\n\n        # get the Secure Boot object\n        status, headers, secure_boot_settings = self._rest_get(secure_boot_uri)\n\n        if status >= 300:\n            msg = self._get_extended_error(secure_boot_settings)\n            raise exception.IloError(msg)\n\n        return secure_boot_settings['SecureBootCurrentState']"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nenabling or disable secure boot on the server.", "response": "def set_secure_boot_mode(self, secure_boot_enable):\n        \"\"\"Enable/Disable secure boot on the server.\n\n        :param secure_boot_enable: True, if secure boot needs to be\n               enabled for next boot, else False.\n        :raises: IloError, on an error from iLO.\n        :raises: IloCommandNotSupportedError, if the command is not supported\n                 on the server.\n        \"\"\"\n        if self._is_boot_mode_uefi():\n            self._change_secure_boot_settings('SecureBootEnable',\n                                              secure_boot_enable)\n        else:\n            msg = ('System is not in UEFI boot mode. \"SecureBoot\" related '\n                   'resources cannot be changed.')\n            raise exception.IloCommandNotSupportedInBiosError(msg)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef reset_secure_boot_keys(self):\n        if self._is_boot_mode_uefi():\n            self._change_secure_boot_settings('ResetToDefaultKeys', True)\n        else:\n            msg = ('System is not in UEFI boot mode. \"SecureBoot\" related '\n                   'resources cannot be changed.')\n            raise exception.IloCommandNotSupportedInBiosError(msg)", "response": "Reset secure boot keys to manufacturing defaults."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nresetting all keys. :raises: IloError, on an error from iLO. :raises: IloCommandNotSupportedError, if the command is not supported on the server.", "response": "def clear_secure_boot_keys(self):\n        \"\"\"Reset all keys.\n\n        :raises: IloError, on an error from iLO.\n        :raises: IloCommandNotSupportedError, if the command is not supported\n                 on the server.\n        \"\"\"\n        if self._is_boot_mode_uefi():\n            self._change_secure_boot_settings('ResetAllKeys', True)\n        else:\n            msg = ('System is not in UEFI boot mode. \"SecureBoot\" related '\n                   'resources cannot be changed.')\n            raise exception.IloCommandNotSupportedInBiosError(msg)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _perform_power_op(self, oper):\n\n        power_settings = {\"Action\": \"Reset\",\n                          \"ResetType\": oper}\n        systems_uri = \"/rest/v1/Systems/1\"\n\n        status, headers, response = self._rest_post(systems_uri, None,\n                                                    power_settings)\n        if status >= 300:\n            msg = self._get_extended_error(response)\n            raise exception.IloError(msg)", "response": "Perform requested power operation."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsimulating a physical press of the server power button.", "response": "def _press_pwr_btn(self, pushType=\"Press\"):\n        \"\"\"Simulates a physical press of the server power button.\n\n        :param pushType: Type of power button press to simulate\n                         Supported values are: 'Press' and 'PressAndHold'\n        :raises: IloError, on an error from iLO.\n        \"\"\"\n        power_settings = {\"Action\": \"PowerButton\",\n                          \"Target\": \"/Oem/Hp\",\n                          \"PushType\": pushType}\n\n        systems_uri = \"/rest/v1/Systems/1\"\n\n        status, headers, response = self._rest_post(systems_uri, None,\n                                                    power_settings)\n        if status >= 300:\n            msg = self._get_extended_error(response)\n            raise exception.IloError(msg)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _retry_until_powered_on(self, power):\n        # If the system is in the same power state as\n        # requested by the user, it gives the error\n        # InvalidOperationForSystemState. To avoid this error\n        # the power state is checked before power on\n        # operation is performed.\n        status = self.get_host_power_status()\n        if (status != power):\n            self._perform_power_op(POWER_STATE[power])\n            return self.get_host_power_status()\n        else:\n            return status", "response": "This method retries power on operation."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef set_host_power(self, power):\n        power = power.upper()\n        if (power is not None) and (power not in POWER_STATE):\n            msg = (\"Invalid input '%(pow)s'. \"\n                   \"The expected input is ON or OFF.\" %\n                   {'pow': power})\n            raise exception.IloInvalidInputError(msg)\n\n        # Check current power status, do not act if it's in requested state.\n        cur_status = self.get_host_power_status()\n\n        if cur_status == power:\n            LOG.debug(self._(\"Node is already in '%(power)s' power state.\"),\n                      {'power': power})\n            return\n        if power == 'ON' and 'PROLIANT BL' in self.get_product_name().upper():\n            self._retry_until_powered_on(power)\n        else:\n            self._perform_power_op(POWER_STATE[power])", "response": "Toggle the power button of server."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nrequesting the http boot url from system in uefi boot mode.", "response": "def get_http_boot_url(self):\n        \"\"\"Request the http boot url from system in uefi boot mode.\n\n        :returns: URL for http boot\n        :raises: IloError, on an error from iLO.\n        :raises: IloCommandNotSupportedInBiosError, if the system is\n                 in the bios boot mode.\n        \"\"\"\n        if(self._is_boot_mode_uefi() is True):\n            return self._get_bios_setting('UefiShellStartupUrl')\n        else:\n            msg = 'get_http_boot_url is not supported in the BIOS boot mode'\n            raise exception.IloCommandNotSupportedInBiosError(msg)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsets url to the system in uefi boot mode.", "response": "def set_http_boot_url(self, url):\n        \"\"\"Set url to the UefiShellStartupUrl to the system in uefi boot mode.\n\n        :param url: URL for http boot\n        :raises: IloError, on an error from iLO.\n        :raises: IloCommandNotSupportedInBiosError, if the system is\n                 in the bios boot mode.\n        \"\"\"\n        if(self._is_boot_mode_uefi() is True):\n            self._change_bios_setting({'UefiShellStartupUrl': url})\n        else:\n            msg = 'set_http_boot_url is not supported in the BIOS boot mode'\n            raise exception.IloCommandNotSupportedInBiosError(msg)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef unset_iscsi_info(self):\n        if(self._is_boot_mode_uefi() is True):\n            iscsi_info = {'iSCSIBootEnable': 'Disabled'}\n            self._change_iscsi_settings(iscsi_info)\n        else:\n            msg = 'iSCSI boot is not supported in the BIOS boot mode'\n            raise exception.IloCommandNotSupportedInBiosError(msg)", "response": "Disable iSCSI boot option in UEFI boot mode."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_iscsi_initiator_info(self):\n        headers, bios_uri, bios_settings = self._check_bios_resource()\n        if('links' in bios_settings and 'iScsi' in bios_settings['links']):\n            iscsi_uri = bios_settings['links']['iScsi']['href']\n            status, headers, iscsi_settings = self._rest_get(iscsi_uri)\n\n            if status != 200:\n                msg = self._get_extended_error(iscsi_settings)\n                raise exception.IloError(msg)\n            return iscsi_settings['iSCSIInitiatorName']\n        else:\n            msg = ('\"links/iScsi\" section in bios '\n                   'does not exist')\n            raise exception.IloCommandNotSupportedError(msg)", "response": "Gets iSCSI initiator information of the system."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef set_iscsi_initiator_info(self, initiator_iqn):\n        if(self._is_boot_mode_uefi() is True):\n            iscsi_uri = self._check_iscsi_rest_patch_allowed()\n            initiator_info = {'iSCSIInitiatorName': initiator_iqn}\n            status, headers, response = self._rest_patch(iscsi_uri,\n                                                         None, initiator_info)\n            if status >= 300:\n                msg = self._get_extended_error(response)\n                raise exception.IloError(msg)\n        else:\n            msg = 'iSCSI initiator cannot be set in the BIOS boot mode'\n            raise exception.IloCommandNotSupportedError(msg)", "response": "Set iSCSI initiator information in iLO."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nretrieving the pending boot mode of the server.", "response": "def get_pending_boot_mode(self):\n        \"\"\"Retrieves the pending boot mode of the server.\n\n        Gets the boot mode to be set on next reset.\n        :returns: either LEGACY or UEFI.\n        :raises: IloError, on an error from iLO.\n        \"\"\"\n        headers, uri, bios_settings = self._check_bios_resource(['BootMode'])\n        _, _, settings = self._get_bios_settings_resource(bios_settings)\n        boot_mode = settings.get('BootMode')\n        if boot_mode == 'LegacyBios':\n            boot_mode = 'legacy'\n        return boot_mode.upper()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset the boot mode of the system for next boot.", "response": "def set_pending_boot_mode(self, boot_mode):\n        \"\"\"Sets the boot mode of the system for next boot.\n\n        :param boot_mode: either 'uefi' or 'legacy'.\n        :raises: IloInvalidInputError, on an invalid input.\n        :raises: IloError, on an error from iLO.\n        :raises: IloCommandNotSupportedError, if the command is not supported\n                 on the server.\n        \"\"\"\n        boot_mode = boot_mode.lower()\n        if boot_mode not in ['uefi', 'legacy']:\n            msg = 'Invalid Boot mode specified'\n            raise exception.IloInvalidInputError(msg)\n\n        boot_properties = {'BootMode': boot_mode}\n\n        if boot_mode == 'legacy':\n            boot_properties['BootMode'] = 'LegacyBios'\n        else:\n            # If Boot Mode is 'Uefi' set the UEFIOptimizedBoot first.\n            boot_properties['UefiOptimizedBoot'] = \"Enabled\"\n\n        # Change the Boot Mode\n        self._change_bios_setting(boot_properties)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_supported_boot_mode(self):\n        system = self._get_host_details()\n        bios_uefi_class_val = 0  # value for bios_only boot mode\n        if ('Bios' in system['Oem']['Hp'] and\n                'UefiClass' in system['Oem']['Hp']['Bios']):\n            bios_uefi_class_val = (system['Oem']['Hp']\n                                         ['Bios']['UefiClass'])\n        return mappings.GET_SUPPORTED_BOOT_MODE_RIS_MAP.get(\n            bios_uefi_class_val)", "response": "Retrieves the supported boot mode."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef reset_ilo_credential(self, password):\n        acc_uri = '/rest/v1/AccountService/Accounts'\n\n        for status, hds, account, memberuri in self._get_collection(acc_uri):\n            if account['UserName'] == self.login:\n                mod_user = {}\n                mod_user['Password'] = password\n                status, headers, response = self._rest_patch(memberuri,\n                                                             None, mod_user)\n                if status != 200:\n                    msg = self._get_extended_error(response)\n                    raise exception.IloError(msg)\n                return\n\n        msg = \"iLO Account with specified username is not found.\"\n        raise exception.IloError(msg)", "response": "Resets the iLO password."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting iLO details :raises: IloError, on an error from iLO. :raises: IloConnectionError, if iLO is not up after reset. :raises: IloCommandNotSupportedError, if the command is not supported on the server.", "response": "def _get_ilo_details(self):\n        \"\"\"Gets iLO details\n\n        :raises: IloError, on an error from iLO.\n        :raises: IloConnectionError, if iLO is not up after reset.\n        :raises: IloCommandNotSupportedError, if the command is not supported\n                 on the server.\n        \"\"\"\n        manager_uri = '/rest/v1/Managers/1'\n        status, headers, manager = self._rest_get(manager_uri)\n\n        if status != 200:\n            msg = self._get_extended_error(manager)\n            raise exception.IloError(msg)\n\n        # verify expected type\n        mtype = self._get_type(manager)\n        if (mtype not in ['Manager.0', 'Manager.1']):\n            msg = \"%s is not a valid Manager type \" % mtype\n            raise exception.IloError(msg)\n\n        return manager, manager_uri"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef reset_ilo(self):\n        manager, reset_uri = self._get_ilo_details()\n        action = {'Action': 'Reset'}\n\n        # perform the POST\n        status, headers, response = self._rest_post(reset_uri, None, action)\n\n        if(status != 200):\n            msg = self._get_extended_error(response)\n            raise exception.IloError(msg)\n\n        # Check if the iLO is up again.\n        common.wait_for_ilo_after_reset(self)", "response": "Resets the iLO.\n\n        :raises: IloError, on an error from iLO.\n        :raises: IloConnectionError, if iLO is not up after reset.\n        :raises: IloCommandNotSupportedError, if the command is not supported\n                 on the server."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef reset_bios_to_default(self):\n        # Check if the BIOS resource if exists.\n        headers_bios, bios_uri, bios_settings = self._check_bios_resource()\n        # Get the BaseConfig resource.\n        try:\n            base_config_uri = bios_settings['links']['BaseConfigs']['href']\n        except KeyError:\n            msg = (\"BaseConfigs resource not found. Couldn't apply the BIOS \"\n                   \"Settings.\")\n            raise exception.IloCommandNotSupportedError(msg)\n\n        # Check if BIOS resource supports patch, else get the settings\n        if not self._operation_allowed(headers_bios, 'PATCH'):\n            headers, bios_uri, _ = self._get_bios_settings_resource(\n                bios_settings)\n            self._validate_if_patch_supported(headers, bios_uri)\n\n        status, headers, config = self._rest_get(base_config_uri)\n        if status != 200:\n            msg = self._get_extended_error(config)\n            raise exception.IloError(msg)\n\n        new_bios_settings = {}\n        for cfg in config['BaseConfigs']:\n            default_settings = cfg.get('default', None)\n            if default_settings is not None:\n                new_bios_settings = default_settings\n                break\n        else:\n            msg = (\"Default Settings not found in 'BaseConfigs' resource.\")\n            raise exception.IloCommandNotSupportedError(msg)\n        request_headers = self._get_bios_hash_password(self.bios_password)\n        status, headers, response = self._rest_patch(bios_uri, request_headers,\n                                                     new_bios_settings)\n        if status >= 300:\n            msg = self._get_extended_error(response)\n            raise exception.IloError(msg)", "response": "Resets the BIOS settings to default values."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_ilo_firmware_version_as_major_minor(self):\n        try:\n            manager, reset_uri = self._get_ilo_details()\n            ilo_fw_ver_str = (\n                manager['Oem']['Hp']['Firmware']['Current']['VersionString']\n            )\n            return common.get_major_minor(ilo_fw_ver_str)\n        except Exception:\n            return None", "response": "Gets the ilo firmware version for server capabilities"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the server properties which can be used for scheduling ArcGIS.", "response": "def get_server_capabilities(self):\n        \"\"\"Gets server properties which can be used for scheduling\n\n        :returns: a dictionary of hardware properties like firmware\n                  versions, server model.\n        :raises: IloError, if iLO returns an error in command execution.\n\n        \"\"\"\n        capabilities = {}\n        system = self._get_host_details()\n        capabilities['server_model'] = system['Model']\n        rom_firmware_version = (\n            system['Oem']['Hp']['Bios']['Current']['VersionString'])\n        capabilities['rom_firmware_version'] = rom_firmware_version\n        capabilities.update(self._get_ilo_firmware_version())\n        capabilities.update(self._get_number_of_gpu_devices_connected())\n        drive_details = self._get_drive_type_and_speed()\n        if drive_details is not None:\n            capabilities.update(drive_details)\n        raid_details = self._get_logical_raid_levels()\n        if raid_details is not None:\n            capabilities.update(raid_details)\n        if self._is_raid_supported():\n            capabilities['hardware_supports_raid'] = 'true'\n        boot_modes = common.get_supported_boot_modes(\n            self.get_supported_boot_mode())\n        capabilities.update({\n            'boot_mode_bios': boot_modes.boot_mode_bios,\n            'boot_mode_uefi': boot_modes.boot_mode_uefi})\n        if self._get_tpm_capability():\n            capabilities['trusted_boot'] = 'true'\n        if self._get_cpu_virtualization():\n            capabilities['cpu_vt'] = 'true'\n        if self._get_nvdimm_n_status():\n            capabilities['nvdimm_n'] = 'true'\n        try:\n            self._check_iscsi_rest_patch_allowed()\n            capabilities['iscsi_boot'] = 'true'\n        except exception.IloError:\n            # If an error is raised dont populate the capability\n            # iscsi_boot\n            pass\n        try:\n            self.get_secure_boot_mode()\n            capabilities['secure_boot'] = 'true'\n        except exception.IloCommandNotSupportedError:\n            # If an error is raised dont populate the capability\n            # secure_boot\n            pass\n        if self._is_sriov_enabled():\n            capabilities['sriov_enabled'] = 'true'\n        return capabilities"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nactivate the iLO license.", "response": "def activate_license(self, key):\n        \"\"\"Activates iLO license.\n\n        :param key: iLO license key.\n        :raises: IloError, on an error from iLO.\n        :raises: IloCommandNotSupportedError, if the command is not supported\n                 on the server.\n        \"\"\"\n        manager, uri = self._get_ilo_details()\n        try:\n            lic_uri = manager['Oem']['Hp']['links']['LicenseService']['href']\n        except KeyError:\n            msg = ('\"LicenseService\" section in Manager/Oem/Hp does not exist')\n            raise exception.IloCommandNotSupportedError(msg)\n\n        lic_key = {}\n        lic_key['LicenseKey'] = key\n\n        # Perform POST to activate license\n        status, headers, response = self._rest_post(lic_uri, None, lic_key)\n\n        if status >= 300:\n            msg = self._get_extended_error(response)\n            raise exception.IloError(msg)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the given virtual media device status and the virtual media device URI.", "response": "def _get_vm_device_status(self,  device='FLOPPY'):\n        \"\"\"Returns the given virtual media device status and device URI\n\n        :param  device: virtual media device to be queried\n        :returns json format virtual media device status and its URI\n        :raises: IloError, on an error from iLO.\n        :raises: IloCommandNotSupportedError, if the command is not supported\n                 on the server.\n        \"\"\"\n        valid_devices = {'FLOPPY': 'floppy',\n                         'CDROM': 'cd'}\n\n        # Check if the input is valid\n        if device not in valid_devices:\n                raise exception.IloInvalidInputError(\n                    \"Invalid device. Valid devices: FLOPPY or CDROM.\")\n\n        manager, uri = self._get_ilo_details()\n        try:\n            vmedia_uri = manager['links']['VirtualMedia']['href']\n        except KeyError:\n            msg = ('\"VirtualMedia\" section in Manager/links does not exist')\n            raise exception.IloCommandNotSupportedError(msg)\n\n        for status, hds, vmed, memberuri in self._get_collection(vmedia_uri):\n            status, headers, response = self._rest_get(memberuri)\n            if status != 200:\n                msg = self._get_extended_error(response)\n                raise exception.IloError(msg)\n\n            if (valid_devices[device] in\n               [item.lower() for item in response['MediaTypes']]):\n                vm_device_uri = response['links']['self']['href']\n                return response, vm_device_uri\n\n        # Requested device not found\n        msg = ('Virtualmedia device \"' + device + '\" is not'\n               ' found on this system.')\n        raise exception.IloError(msg)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_vm_status(self, device='FLOPPY'):\n        response, vm_device_uri = self._get_vm_device_status(device)\n\n        # Create RIBCL equivalent response\n        # RIBCL provides this data in VM status\n        # VM_APPLET = CONNECTED | DISCONNECTED\n        # DEVICE = FLOPPY | CDROM\n        # BOOT_OPTION = BOOT_ALWAYS | BOOT_ONCE | NO_BOOT\n        # WRITE_PROTECT = YES | NO\n        # IMAGE_INSERTED = YES | NO\n        response_data = {}\n\n        if response.get('WriteProtected', False):\n            response_data['WRITE_PROTECT'] = 'YES'\n        else:\n            response_data['WRITE_PROTECT'] = 'NO'\n\n        if response.get('BootOnNextServerReset', False):\n            response_data['BOOT_OPTION'] = 'BOOT_ONCE'\n        else:\n            response_data['BOOT_OPTION'] = 'BOOT_ALWAYS'\n\n        if response.get('Inserted', False):\n            response_data['IMAGE_INSERTED'] = 'YES'\n        else:\n            response_data['IMAGE_INSERTED'] = 'NO'\n\n        if response.get('ConnectedVia') == 'NotConnected':\n            response_data['VM_APPLET'] = 'DISCONNECTED'\n            # When media is not connected, it's NO_BOOT\n            response_data['BOOT_OPTION'] = 'NO_BOOT'\n        else:\n            response_data['VM_APPLET'] = 'CONNECTED'\n\n        response_data['IMAGE_URL'] = response['Image']\n        response_data['DEVICE'] = device\n\n        # FLOPPY cannot be a boot device\n        if ((response_data['BOOT_OPTION'] == 'BOOT_ONCE') and\n           (response_data['DEVICE'] == 'FLOPPY')):\n            response_data['BOOT_OPTION'] = 'NO_BOOT'\n\n        return response_data", "response": "Returns the virtual media drive status in dictionary form."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsetting the Virtual Media drive status It sets the boot option for virtual media device. Note: boot option can be set only for CD device. :param device: virual media device :param boot_option: boot option to set on the virtual media device :param write_protect: set the write protect flag on the vmedia device Note: It's ignored. In RIS it is read-only. :raises: IloError, on an error from iLO. :raises: IloCommandNotSupportedError, if the command is not supported on the server.", "response": "def set_vm_status(self, device='FLOPPY',\n                      boot_option='BOOT_ONCE', write_protect='YES'):\n        \"\"\"Sets the Virtual Media drive status\n\n        It sets the boot option for virtual media device.\n        Note: boot option can be set only for CD device.\n\n        :param device: virual media device\n        :param boot_option: boot option to set on the virtual media device\n        :param write_protect: set the write protect flag on the vmedia device\n                              Note: It's ignored. In RIS it is read-only.\n        :raises: IloError, on an error from iLO.\n        :raises: IloCommandNotSupportedError, if the command is not supported\n                 on the server.\n        \"\"\"\n        # CONNECT is a RIBCL call. There is no such property to set in RIS.\n        if boot_option == 'CONNECT':\n            return\n\n        boot_option_map = {'BOOT_ONCE': True,\n                           'BOOT_ALWAYS': False,\n                           'NO_BOOT': False\n                           }\n\n        if boot_option not in boot_option_map:\n            msg = ('Virtualmedia boot option \"' + boot_option + '\" is '\n                   'invalid.')\n            raise exception.IloInvalidInputError(msg)\n\n        response, vm_device_uri = self._get_vm_device_status(device)\n\n        # Update required property\n        vm_settings = {}\n        vm_settings['Oem'] = (\n            {'Hp': {'BootOnNextServerReset': boot_option_map[boot_option]}})\n\n        # perform the patch operation\n        status, headers, response = self._rest_patch(\n            vm_device_uri, None, vm_settings)\n\n        if status >= 300:\n            msg = self._get_extended_error(response)\n            raise exception.IloError(msg)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef insert_virtual_media(self, url, device='FLOPPY'):\n        response, vm_device_uri = self._get_vm_device_status(device)\n\n        # Eject media if there is one. RIBCL was tolerant enough to overwrite\n        # existing media, RIS is not. This check is to take care of that\n        # assumption.\n        if response.get('Inserted', False):\n            self.eject_virtual_media(device)\n\n        # Update required property\n        vm_settings = {}\n        vm_settings['Image'] = url\n\n        # Perform the patch operation\n        status, headers, response = self._rest_patch(\n            vm_device_uri, None, vm_settings)\n\n        if status >= 300:\n            msg = self._get_extended_error(response)\n            raise exception.IloError(msg)", "response": "Inserts a virtual media diskette image into the iLO."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting details of persistent boot devices and its order", "response": "def _get_persistent_boot_devices(self):\n        \"\"\"Get details of persistent boot devices, its order\n\n        :returns: List of dictionary of boot sources and\n                  list of boot device order\n        :raises: IloError, on an error from iLO.\n        :raises: IloCommandNotSupportedError, if the command is not supported\n                 on the server.\n        \"\"\"\n        # Check if the BIOS resource if exists.\n        headers_bios, bios_uri, bios_settings = self._check_bios_resource()\n\n        # Get the Boot resource.\n        boot_settings = self._get_bios_boot_resource(bios_settings)\n\n        # Get the BootSources resource\n        try:\n            boot_sources = boot_settings['BootSources']\n        except KeyError:\n            msg = (\"BootSources resource not found.\")\n            raise exception.IloError(msg)\n\n        try:\n            boot_order = boot_settings['PersistentBootConfigOrder']\n        except KeyError:\n            msg = (\"PersistentBootConfigOrder resource not found.\")\n            raise exception.IloCommandNotSupportedError(msg)\n\n        return boot_sources, boot_order"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting the persistent boot device for the host.", "response": "def get_persistent_boot_device(self):\n        \"\"\"Get current persistent boot device set for the host\n\n        :returns: persistent boot device for the system\n        :raises: IloError, on an error from iLO.\n        :raises: IloCommandNotSupportedError, if the command is not supported\n                 on the server.\n        \"\"\"\n        system = self._get_host_details()\n        try:\n            # Return boot device if it is persistent.\n            if system['Boot']['BootSourceOverrideEnabled'] == 'Continuous':\n                device = system['Boot']['BootSourceOverrideTarget']\n                if device in DEVICE_RIS_TO_COMMON:\n                    return DEVICE_RIS_TO_COMMON[device]\n                return device\n        except KeyError as e:\n            msg = \"get_persistent_boot_device failed with the KeyError:%s\"\n            raise exception.IloError((msg) % e)\n\n        # Check if we are in BIOS boot mode.\n        # There is no resource to fetch boot device order for BIOS boot mode\n        if not self._is_boot_mode_uefi():\n            return None\n\n        # Get persistent boot device order for UEFI\n        boot_sources, boot_devices = self._get_persistent_boot_devices()\n\n        boot_string = \"\"\n        try:\n            for source in boot_sources:\n                if (source[\"StructuredBootString\"] == boot_devices[0]):\n                    boot_string = source[\"BootString\"]\n                    break\n        except KeyError as e:\n            msg = \"get_persistent_boot_device failed with the KeyError:%s\"\n            raise exception.IloError((msg) % e)\n\n        if 'HP iLO Virtual USB CD' in boot_string:\n            return 'CDROM'\n\n        elif ('NIC' in boot_string or\n              'PXE' in boot_string or\n              \"iSCSI\" in boot_string):\n            return 'NETWORK'\n\n        elif common.isDisk(boot_string):\n            return 'HDD'\n\n        else:\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nupdates the persistent boot mode for a specific boot device.", "response": "def _update_persistent_boot(self, device_type=[], persistent=False):\n        \"\"\"Changes the persistent boot device order in BIOS boot mode for host\n\n        Note: It uses first boot device from the device_type and ignores rest.\n\n        :param device_type: ordered list of boot devices\n        :param persistent: Boolean flag to indicate if the device to be set as\n                           a persistent boot device\n        :raises: IloError, on an error from iLO.\n        :raises: IloCommandNotSupportedError, if the command is not supported\n                 on the server.\n        \"\"\"\n        tenure = 'Once'\n        new_device = device_type[0]\n        # If it is a standard device, we need to convert in RIS convention\n        if device_type[0].upper() in DEVICE_COMMON_TO_RIS:\n            new_device = DEVICE_COMMON_TO_RIS[device_type[0].upper()]\n\n        if persistent:\n            tenure = 'Continuous'\n\n        systems_uri = \"/rest/v1/Systems/1\"\n        # Need to set this option first if device is 'UefiTarget'\n        if new_device is 'UefiTarget':\n            system = self._get_host_details()\n            uefi_devices = (\n                system['Boot']['UefiTargetBootSourceOverrideSupported'])\n            iscsi_device = None\n            for device in uefi_devices:\n                if device is not None and 'iSCSI' in device:\n                    iscsi_device = device\n                    break\n\n            if iscsi_device is None:\n                msg = 'No UEFI iSCSI bootable device found'\n                raise exception.IloError(msg)\n\n            new_boot_settings = {}\n            new_boot_settings['Boot'] = {'UefiTargetBootSourceOverride':\n                                         iscsi_device}\n\n            status, headers, response = self._rest_patch(systems_uri, None,\n                                                         new_boot_settings)\n            if status >= 300:\n                msg = self._get_extended_error(response)\n                raise exception.IloError(msg)\n\n        new_boot_settings = {}\n        new_boot_settings['Boot'] = {'BootSourceOverrideEnabled': tenure,\n                                     'BootSourceOverrideTarget': new_device}\n        status, headers, response = self._rest_patch(systems_uri, None,\n                                                     new_boot_settings)\n        if status >= 300:\n            msg = self._get_extended_error(response)\n            raise exception.IloError(msg)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nupdate the persistent boot device order for the host.", "response": "def update_persistent_boot(self, device_type=[]):\n        \"\"\"Changes the persistent boot device order for the host\n\n        :param device_type: ordered list of boot devices\n        :raises: IloError, on an error from iLO.\n        :raises: IloCommandNotSupportedError, if the command is not supported\n                 on the server.\n        \"\"\"\n        # Check if the input is valid\n        for item in device_type:\n            if item.upper() not in DEVICE_COMMON_TO_RIS:\n                raise exception.IloInvalidInputError(\"Invalid input. Valid \"\n                                                     \"devices: NETWORK, HDD,\"\n                                                     \" ISCSI or CDROM.\")\n\n        self._update_persistent_boot(device_type, persistent=True)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_one_time_boot(self):\n        system = self._get_host_details()\n        try:\n            if system['Boot']['BootSourceOverrideEnabled'] == 'Once':\n                device = system['Boot']['BootSourceOverrideTarget']\n                if device in DEVICE_RIS_TO_COMMON:\n                    return DEVICE_RIS_TO_COMMON[device]\n                return device\n            else:\n                # value returned by RIBCL if one-time boot setting are absent\n                return 'Normal'\n\n        except KeyError as e:\n            msg = \"get_one_time_boot failed with the KeyError:%s\"\n            raise exception.IloError((msg) % e)", "response": "Retrieves the current setting for the one - time boot."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _get_firmware_update_service_resource(self):\n        manager, uri = self._get_ilo_details()\n        try:\n            fw_uri = manager['Oem']['Hp']['links']['UpdateService']['href']\n        except KeyError:\n            msg = (\"Firmware Update Service resource not found.\")\n            raise exception.IloCommandNotSupportedError(msg)\n        return fw_uri", "response": "Gets the firmware update service uri."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nupdate the given firmware on the server for the given component type.", "response": "def update_firmware(self, file_url, component_type):\n        \"\"\"Updates the given firmware on the server for the given component.\n\n        :param file_url: location of the raw firmware file. Extraction of the\n                         firmware file (if in compact format) is expected to\n                         happen prior to this invocation.\n        :param component_type: Type of component to be applied to.\n        :raises: InvalidInputError, if the validation of the input fails\n        :raises: IloError, on an error from iLO\n        :raises: IloConnectionError, if not able to reach iLO.\n        :raises: IloCommandNotSupportedError, if the command is\n                 not supported on the server\n        \"\"\"\n        fw_update_uri = self._get_firmware_update_service_resource()\n        action_data = {\n            'Action': 'InstallFromURI',\n            'FirmwareURI': file_url,\n        }\n\n        # perform the POST\n        LOG.debug(self._('Flashing firmware file: %s ...'), file_url)\n        status, headers, response = self._rest_post(\n            fw_update_uri, None, action_data)\n        if status != 200:\n            msg = self._get_extended_error(response)\n            raise exception.IloError(msg)\n\n        # wait till the firmware update completes.\n        common.wait_for_ris_firmware_update_to_complete(self)\n\n        try:\n            state, percent = self.get_firmware_update_progress()\n        except exception.IloError:\n            msg = 'Status of firmware update not known'\n            LOG.debug(self._(msg))  # noqa\n            return\n\n        if state == \"ERROR\":\n            msg = 'Unable to update firmware'\n            LOG.debug(self._(msg))  # noqa\n            raise exception.IloError(msg)\n        elif state == \"UNKNOWN\":\n            msg = 'Status of firmware update not known'\n            LOG.debug(self._(msg))  # noqa\n        else:  # \"COMPLETED\" | \"IDLE\"\n            LOG.info(self._('Flashing firmware file: %s ... done'), file_url)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the current state of the firmware update.", "response": "def get_firmware_update_progress(self):\n        \"\"\"Get the progress of the firmware update.\n\n        :returns: firmware update state, one of the following values:\n                  \"IDLE\", \"UPLOADING\", \"PROGRESSING\", \"COMPLETED\", \"ERROR\".\n                  If the update resource is not found, then \"UNKNOWN\".\n        :returns: firmware update progress percent\n        :raises: IloError, on an error from iLO.\n        :raises: IloConnectionError, if not able to reach iLO.\n        \"\"\"\n        try:\n            fw_update_uri = self._get_firmware_update_service_resource()\n        except exception.IloError as e:\n            LOG.debug(self._('Progress of firmware update not known: %s'),\n                      str(e))\n            return \"UNKNOWN\", \"UNKNOWN\"\n\n        # perform the GET\n        status, headers, response = self._rest_get(fw_update_uri)\n        if status != 200:\n            msg = self._get_extended_error(response)\n            raise exception.IloError(msg)\n\n        fw_update_state = response.get('State')\n        fw_update_progress_percent = response.get('ProgressPercent')\n        LOG.debug(self._('Flashing firmware file ... in progress %d%%'),\n                  fw_update_progress_percent)\n        return fw_update_state, fw_update_progress_percent"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nretrieve if the server is TPM capable or not.", "response": "def _get_tpm_capability(self):\n        \"\"\"Retrieves if server is TPM capable or not.\n\n        :returns True if TPM is Present else False\n        \"\"\"\n        tpm_values = {\"NotPresent\": False,\n                      \"PresentDisabled\": True,\n                      \"PresentEnabled\": True}\n        try:\n            tpm_state = self._get_bios_setting('TpmState')\n        except exception.IloCommandNotSupportedError:\n            tpm_state = \"NotPresent\"\n        tpm_result = tpm_values[tpm_state]\n        return tpm_result"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _get_cpu_virtualization(self):\n        try:\n            cpu_vt = self._get_bios_setting('ProcVirtualization')\n        except exception.IloCommandNotSupportedError:\n            return False\n        if cpu_vt == 'Enabled':\n            vt_status = True\n        else:\n            vt_status = False\n        return vt_status", "response": "get cpu virtualization status."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget status of NVDIMM_N.", "response": "def _get_nvdimm_n_status(self):\n        \"\"\"Get status of NVDIMM_N.\n\n        :returns: True if NVDIMM_N is present and enabled, False otherwise.\n        \"\"\"\n        try:\n            nvdimm_n_status = self._get_bios_setting('NvDimmNMemFunctionality')\n            if nvdimm_n_status == 'Enabled':\n                nvn_status = True\n            else:\n                nvn_status = False\n        except exception.IloCommandNotSupportedError:\n            nvn_status = False\n        return nvn_status"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef inject_nmi(self):\n        cur_status = self.get_host_power_status()\n        if cur_status != 'ON':\n            raise exception.IloError(\"Server is not in powered on state.\")\n\n        self._perform_power_op(\"Nmi\")", "response": "Inject NMI and Non Maskable Interrupt for a node immediately."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_current_bios_settings(self, only_allowed_settings=True):\n        headers, bios_uri, bios_settings = self._check_bios_resource()\n        # Remove the \"links\" section\n        bios_settings.pop(\"links\", None)\n        if only_allowed_settings:\n            return utils.apply_bios_properties_filter(\n                bios_settings, constants.SUPPORTED_BIOS_PROPERTIES)\n        return bios_settings", "response": "Get the current BIOS settings."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_pending_bios_settings(self, only_allowed_settings=True):\n        headers, bios_uri, bios_settings = self._check_bios_resource()\n        try:\n            settings_config_uri = bios_settings['links']['Settings']['href']\n        except KeyError:\n            msg = (\"Settings resource not found. Couldn't get pending BIOS \"\n                   \"Settings.\")\n            raise exception.IloCommandNotSupportedError(msg)\n\n        status, headers, config = self._rest_get(settings_config_uri)\n        if status != 200:\n            msg = self._get_extended_error(config)\n            raise exception.IloError(msg)\n\n        # Remove the \"links\" section\n        config.pop(\"links\", None)\n\n        if only_allowed_settings:\n            return utils.apply_bios_properties_filter(\n                config, constants.SUPPORTED_BIOS_PROPERTIES)\n        return config", "response": "Get the pending BIOS settings."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef set_bios_settings(self, data=None, only_allowed_settings=True):\n        if not data:\n            raise exception.IloError(\"Could not apply settings with\"\n                                     \" empty data\")\n\n        if only_allowed_settings:\n            unsupported_settings = [key for key in data if key not in (\n                constants.SUPPORTED_BIOS_PROPERTIES)]\n            if unsupported_settings:\n                msg = (\"Could not apply settings as one or more settings are\"\n                       \" not supported. Unsupported settings are %s.\"\n                       \" Supported settings are %s.\" % (\n                           unsupported_settings,\n                           constants.SUPPORTED_BIOS_PROPERTIES))\n                raise exception.IloError(msg)\n\n        self._change_bios_setting(data)", "response": "Set current BIOS settings to the provided data."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_default_bios_settings(self, only_allowed_settings=True):\n        headers_bios, bios_uri, bios_settings = self._check_bios_resource()\n        # Get the BaseConfig resource.\n        try:\n            base_config_uri = bios_settings['links']['BaseConfigs']['href']\n        except KeyError:\n            msg = (\"BaseConfigs resource not found. Couldn't apply the BIOS \"\n                   \"Settings.\")\n            raise exception.IloCommandNotSupportedError(msg)\n\n        status, headers, config = self._rest_get(base_config_uri)\n        if status != 200:\n            msg = self._get_extended_error(config)\n            raise exception.IloError(msg)\n\n        for cfg in config['BaseConfigs']:\n            default_settings = cfg.get('default')\n            if default_settings:\n                break\n        else:\n            msg = (\"Default BIOS Settings not found in 'BaseConfigs' \"\n                   \"resource.\")\n            raise exception.IloCommandNotSupportedError(msg)\n\n        if only_allowed_settings:\n            return utils.apply_bios_properties_filter(\n                default_settings, constants.SUPPORTED_BIOS_PROPERTIES)\n        return default_settings", "response": "Get default BIOS settings."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_bios_settings_result(self):\n        headers, bios_uri, bios_settings = self._check_bios_resource()\n        settings_result = bios_settings.get(\"SettingsResult\").get(\"Messages\")\n        status = \"failed\" if len(settings_result) > 1 else \"success\"\n        return {\"status\": status, \"results\": settings_result}", "response": "Gets the result of the bios settings applied"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ninterfacing to plot average over mass_range. Parameters ---------- directory : string Location of h5 file to plot. Needed for plot_tools. name_h5_file : string Name of h5 file. Needed for plot_tools. mass_range : list A 1x2 array required to plot data in a certain mass range. Needed for _read_iso_abund_marco. cycle : integer which cycle from the h5 file?. Needed for _read_iso_abund_marco. logic_stable : boolean Do you want to plot only stable or not. i_decay : integer If i_decay is 1, then plot not decayed. If i_decay is 2, then plot decayed. Make sense only if stable is true. file_solar : string File where to take solar abundances. solar_factor : float value to correct initial abundances to solar, e.g. for Z=0.01 and AG89 solar_factor = 2. See Also -------- se._read_iso_abund_marco()", "response": "def _obsolete_plot_iso_abund_marco(directory, name_h5_file, mass_range,\n                                  cycle, logic_stable, i_decay,\n                                  file_solar, solar_factor):\n    \"\"\"\n    Interface to plot average over mass_range.\n\n    Parameters\n    ----------\n    directory : string\n        Location of h5 file to plot.  Needed for plot_tools.\n    name_h5_file : string\n        Name of h5 file.  Needed for plot_tools.\n    mass_range : list\n        A 1x2 array required to plot data in a certain mass range.  Needed for\n        _read_iso_abund_marco.\n    cycle : integer\n        which cycle from the h5 file?.  Needed for _read_iso_abund_marco.\n    logic_stable : boolean\n        Do you want to plot only stable or not.\n    i_decay : integer\n        If i_decay is 1, then plot not decayed.  If i_decay is 2, then\n        plot decayed.  Make sense only if stable is true.\n    file_solar : string\n        File where to take solar abundances.\n    solar_factor : float\n        value to correct initial abundances to solar, e.g. for Z=0.01\n        and AG89 solar_factor = 2.\n\n    See Also\n    --------\n    se._read_iso_abund_marco()\n\n    \"\"\"\n\n\n    # provide library for Z versus element names, and Z for elements\n    u.give_zip_element_z_and_names()\n    # solar abundances are read here\n    u.solar(file_solar,solar_factor)\n    # from here I have average abundances in mass_range to plot\n    average_iso_abund_marco(mass_range,cycle,logic_stable,i_decay)\n\n    fig = pl.figure()            # Figure object\n    ax = fig.add_subplot(1,1,1)     # Axes object: one row, one column, first plot (one plot!)\n    # Tick marks\n    xminorlocator = MultipleLocator(1)\n    xmajorlocator = MultipleLocator(10)\n    ax.xaxis.set_major_locator(xmajorlocator)\n    ax.xaxis.set_minor_locator(xminorlocator)\n    yminorlocator = MultipleLocator(0.1)\n    ymajorlocator = MultipleLocator(1)\n    ax.yaxis.set_major_locator(ymajorlocator)\n    ax.yaxis.set_minor_locator(yminorlocator)\n\n    ax.set_yscale('log')\n\n    if not logic_stable:\n        for i in range(len(u.spe)):\n            pl.plot(amass_int[u.cl[spe[i]]],average_mass_frac[u.cl[spe[i]]],'ko')\n\n        pl.xlabel('$Mass$ $number$', fontsize=20)\n        pl.ylabel('$X_{i}$', fontsize=20)\n\n        pl.ylim(1.0e-10,10.)\n        pl.xlim(55,110)\n\n    elif logic_stable:\n    # plot stable\n        #for i in range(len(stable)):\n        #    pl.plot(amass_int[cl[stable[i].capitalize()]],average_mass_frac[cl[stable[i].capitalize()]]/u.solar_abundance[stable[i].lower()],'ko')\n\n        if i_decay == 2:\n            for j in range(len(stable)):\n                    #print cl[stable[j].capitalize()],stable[j].capitalize(),amass_int[cl[stable[j].capitalize()]]\n                pl.plot(amass_int[u.cl[stable[j].capitalize()]],old_div(u.mass_fractions_array_decayed[u.back_ind[stable[j]]],u.solar_abundance[stable[j].lower()]),'Dk')\n\n        for i in range(len(stable)):\n            for j in range(len(stable)):\n                if stable[i][:2] == stable[j][:2]:\n                    if stable[i] == stable[j-1]:\n                        adum  =[amass_int[u.cl[stable[i].capitalize()]],amass_int[u.cl[stable[j].capitalize()]]]\n                        mfdum =[old_div(float(average_mass_frac[u.cl[stable[i].capitalize()]]),float(u.solar_abundance[stable[i].lower()])),old_div(float(average_mass_frac[u.cl[stable[j].capitalize()]]),float(u.solar_abundance[stable[j].lower()]))]\n                        mfddum=[old_div(float(u.average_mass_frac_decay[u.back_ind[stable[i]]]),float(u.solar_abundance[stable[i].lower()])),old_div(float(u.average_mass_frac_decay[u.back_ind[stable[j]]]),float(u.solar_abundance[stable[j].lower()]))]\n                        #pl.plot(adum,mfdum,'k-')\n                        # I had to add this try/except...why? I guess is someone related to H2, that I spotted that was wrong in stable_raw...\n                        # should deal without this. Have to be solved when I have time Marco (June 7 2011)\n                        if i_decay == 2:\n                            try:\n                                pl.plot(adum,mfddum,'k-')\n                            except UnboundLocalError:\n                                continue\n\n    pl.xlabel('$Mass$ $number$', fontsize=20)\n    pl.ylabel('$X_{i}/X_{sun}$', fontsize=20)\n\n    pl.ylim(1.0e-3,5000.)\n    pl.xlim(55,210)\n\n\n\n    pl.grid()\n    pl.show()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ninterfacing to plot elements abundances averaged over mass_range. Parameters ---------- directory : string Location of h5 file to plot. Needed for plot_tools. name_h5_file : string Name of h5 file. Needed for plot_tools. mass_range : list A 1x2 array required to plot data in a certain mass range. Needed for _read_iso_abund_marco. cycle : integer which cycle from the h5 file?. Needed for _read_iso_abund_marco. logic_stable : boolean Do you want to plot only stable or not. i_decay : integer If i_decay is 1, then plot not decayed. If i_decay is 2, then plot decayed. Make sense only if stable is true. file_solar : string File where to take solar abundances. solar_factor : float value to correct initial abundances to solar, e.g. for Z=0.01 and AG89 solar_factor = 2. See Also -------- se._read_iso_abund_marco()", "response": "def _obsolete_plot_el_abund_marco(directory,name_h5_file,mass_range,cycle,logic_stable,i_decay,file_solar,solar_factor,symbol='ko'):\n    \"\"\"\n    Interface to plot elements abundances averaged over mass_range.\n\n    Parameters\n    ----------\n    directory : string\n        Location of h5 file to plot.  Needed for plot_tools.\n    name_h5_file : string\n        Name of h5 file.  Needed for plot_tools.\n    mass_range : list\n        A 1x2 array required to plot data in a certain mass range.  Needed for\n        _read_iso_abund_marco.\n    cycle : integer\n        which cycle from the h5 file?.  Needed for _read_iso_abund_marco.\n    logic_stable : boolean\n        Do you want to plot only stable or not.\n    i_decay : integer\n        If i_decay is 1, then plot not decayed.  If i_decay is 2, then\n        plot decayed.  Make sense only if stable is true.\n    file_solar : string\n        File where to take solar abundances.\n    solar_factor : float\n        value to correct initial abundances to solar, e.g. for Z=0.01\n        and AG89 solar_factor = 2.\n\n    See Also\n    --------\n    se._read_iso_abund_marco()\n\n    \"\"\"\n\n    # provide library for Z versus element names, and Z for elements\n    u.give_zip_element_z_and_names()\n    # solar abundances are read here\n    u.solar(file_solar,solar_factor)\n    # from here I have average abundances in mass_range to plot\n    average_iso_abund_marco(mass_range,cycle,logic_stable,i_decay)\n    # element abundances are calculated here\n    mass_fractions_array_decayed = average_mass_frac_decay\n    mass_fractions_array_not_decayed = average_mass_frac\n    u.element_abund_marco(i_decay,stable,jjdum,mass_fractions_array_not_decayed,mass_fractions_array_decayed)\n\n\n    fig = pl.figure()            # Figure object\n    ax = fig.add_subplot(1,1,1)     # Axes object: one row, one column, first plot (one plot!)\n    # Tick marks\n    xminorlocator = MultipleLocator(1)\n    xmajorlocator = MultipleLocator(10)\n    ax.xaxis.set_major_locator(xmajorlocator)\n    ax.xaxis.set_minor_locator(xminorlocator)\n    yminorlocator = MultipleLocator(0.1)\n    ymajorlocator = MultipleLocator(1)\n    ax.yaxis.set_major_locator(ymajorlocator)\n    ax.yaxis.set_minor_locator(yminorlocator)\n\n    ax.set_yscale('log')\n\n    if not logic_stable:\n        for i in range(u.z_bismuth):\n            pl.plot(z_for_elem[i],elem_prod_fac[i],symbol,markersize=10.)\n\n        pl.xlabel('$Atomic$ $number$', fontsize=20)\n        pl.ylabel('$X_{i}/X_{sun}$', fontsize=20)\n\n        pl.ylim(1.0e-2,1000.)\n        pl.xlim(0,95)\n\n    elif logic_stable:\n        for i in range(u.z_bismuth):\n            if index_stable[i] == 1:\n                continue\n                #pl.plot(z_for_elem[i],elem_prod_fac[i],'ko')\n        if i_decay == 2:\n            for i in range(u.z_bismuth):\n                if index_stable[i] == 1:\n                    pl.plot(z_for_elem[i],elem_prod_fac_decayed[i],symbol,markersize=10.)\n\n        pl.xlabel('$Atomic$ $number$', fontsize=20)\n        pl.ylabel('$X_{i}/X_{sun}$', fontsize=20)\n\n        pl.ylim(1.0e-2,1000.)\n        pl.xlim(0,95)\n\n\n\n    pl.grid()\n    pl.show()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_elemental_abunds(self,cycle,index=None):\n\n        isoabunds=self.se.get(cycle,'iso_massf')\n        A=array(self.se.A)\n        Z=array(self.se.Z)\n        names=self.se.isos\n        Zuq=list(set(Z)) # list of unique Zs\n        Zuq.sort()\n\n        if index==None:\n            index=[0,len(isoabunds)]\n\n        if type(index)==list:\n            elemabunds=[]\n            for zone in range(index[0],index[1]):\n                percent=int((zone-index[0])*100./(index[1]-index[0]))\n                sys.stdout.flush()\n                sys.stdout.write(\"\\rgetting elemental abundances \" + \"...%d%%\" % percent)\n\n                elemabunds.append([sum(isoabunds[zone][where(Z==iZ)]) for iZ in Zuq])\n        else:\n            elemabunds=[sum(isoabunds[index][where(Z==iZ)]) for iZ in Zuq]\n\n        return elemabunds", "response": "Returns the elemental abundances for one cycle or whole star or a specific zone."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef plot_prof_1(self, mod, species, xlim1, xlim2, ylim1, ylim2,\n                    symbol=None):\n        \"\"\"\n        plot one species for cycle between xlim1 and xlim2\n\n        Parameters\n        ----------\n        mod : string or integer\n            Model to plot, same as cycle number.\n        species : list\n            Which species to plot.\n        xlim1, xlim2 : float\n            Mass coordinate range.\n        ylim1, ylim2 : float\n            Mass fraction coordinate range.\n        symbol : string, optional\n            Which symbol you want to use.  If None symbol is set to '-'.\n            The default is None.\n\n        \"\"\"\n        DataPlot.plot_prof_1(self,species,mod,xlim1,xlim2,ylim1,ylim2,symbol)\n        \"\"\"\n        tot_mass=self.se.get(mod,'total_mass')\n        age=self.se.get(mod,'age')\n        mass=self.se.get(mod,'mass')\n        Xspecies=self.se.get(mod,'iso_massf',species)\n        pyl.plot(mass,np.log10(Xspecies),'-',label=species)\n        pyl.xlim(xlim1,xlim2)\n        pyl.ylim(ylim1,ylim2)\n        pyl.legend()\n\n        pl.xlabel('$Mass$ $coordinate$', fontsize=20)\n        pl.ylabel('$X_{i}$', fontsize=20)\n        pl.title('Mass='+str(tot_mass)+', Time='+str(age)+' years, cycle='+str(mod))\n        \"\"\"", "response": "Plot one species for cycle between xlim1 and xlim2."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef plot_prof_2(self, mod, species, xlim1, xlim2):\n\n        \"\"\"\n        Plot one species for cycle between xlim1 and xlim2\n\n        Parameters\n        ----------\n        mod : string or integer\n            Model to plot, same as cycle number.\n        species : list\n            Which species to plot.\n        xlim1, xlim2 : float\n            Mass coordinate range.\n\n        \"\"\"\n\n        mass=self.se.get(mod,'mass')\n        Xspecies=self.se.get(mod,'yps',species)\n        pyl.plot(mass,Xspecies,'-',label=str(mod)+', '+species)\n        pyl.xlim(xlim1,xlim2)\n        pyl.legend()", "response": "Plot one species for cycle between xlim1 and xlim2."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _tp_finder(self, dcycle):   # Private routine\n        # read in c and o isotopes for all cycles, regarding deltacycle\n        last_cycle = int(self.se.cycles[len(self.se.cycles)-1])\n        cyc_tp = list(range(1,last_cycle + dcycle, dcycle))\n        all_data = array(self.get(cyc_tp,['C-12','C-13','O-16','O-17','O-18']))\n        c_nf = np.zeros(len(all_data))\n        o_nf = np.zeros(len(all_data))\n        for i in range(len(all_data)):\n            c_nf[i] = all_data[i][0] + all_data[i][1]\n            o_nf[i] = all_data[i][2] + all_data[i][3] + all_data[i][4]\n\n        # search for thermal pulses\n        co_ratio = (old_div(c_nf, o_nf)) * 15.9994 / 12.0107\n        tp_guess     = 200   # this should be an upper limit!\n        tp_guess_max = 200   # to through an error\n        # guess variables, i is the actual break criterion, n a max counter\n        gi = 0\n        gn = 0\n\n        while gi != 1 and gn < 10000:\n            tp_ind = list()\n            i = 0\n            while i < len(co_ratio)-2:\n                gcompar= old_div(1., (dcycle*tp_guess*100.))\n                slope1 = old_div((co_ratio[i+1]-co_ratio[i]),(dcycle))\n                slope2 = old_div((co_ratio[i+2]-co_ratio[i+1]),dcycle)\n                if slope1 > gcompar and slope2 < gcompar and co_ratio[i+1] > co_ratio[i]:\n                    tp_ind.append(i+1)\n                    i += 3   # jump three cycles to avoid defining a single cycle twice!\n                else:\n                    i += 1\n\n            if abs(len(tp_ind) - tp_guess) < old_div(tp_guess,2):   # gotta be within factor two of guess\n                gi = 1\n            else:\n                gn += 1\n                tp_guess /= 2\n        # check w/ maximum of thermal pulses allowed\n        if len(tp_ind) > tp_guess_max:\n            print('Problem detected with number of pulses')\n        # create thermal pulse vector\n        tp_startf = zeros(len(tp_ind))   # found start\n        for i in range(len(tp_startf)):\n            tp_startf[i] = cyc_tp[tp_ind[i]]\n        # read out isotopic composition at 95% of the thermal pulse and the initial of the star\n        # set up thermal pulse positions\n        tp_limits = zeros(len(tp_startf)+1)\n        for i in range(len(tp_startf)):\n            tp_limits[i] = tp_startf[i]\n        tp_limits[len(tp_limits)-1] = int(self.se.cycles[len(self.se.cycles)-1])\n        # thermal pulse position (where to read the isotope ratio)\n        tp_pos = list()\n        for i in range(len(tp_startf)):\n            tp_pos.append(int(tp_limits[i] + 0.95 * (tp_limits[i+1] - tp_limits[i])))\n        # create co_ret vector to return c/o ratio vector\n        co_return = zeros(len(tp_pos))\n        for i in range(len(tp_pos)):\n            co_return[i] = co_ratio[tp_ind[i]]\n        # return the two vectors\n        return tp_pos,co_return", "response": "This routine finds the thermal pulses in given star and returns the corresponding index vector that gives the position of the thermal pulse that occures the thermal pulse."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef ernst_table_exporter(self, cycle, outfname='table_out',\n                             sheetname='Sheet 1'):\n        \"\"\"\n        This routine takes NuGrid data (model output) for a given\n        cycle and writes it into an Excel sheet.\n\n        This is one format as requested by Ernst Zinner in June 2013\n        (through Marco).  If you want all radioactive isotopes, start\n        from the restart file.  Empty columns are not written out and\n        you will get a message how many were empty.  Please note that\n        only one cycle is written out.\n\n        Parameters\n        ----------\n        cycle : integer\n            Number of the cycle to consider.\n        outfname : string, optional\n            File name to write it to, .xlsx is appended automatically.\n            The default is 'table_out'.\n        sheetname : string, optional\n            Name of the sheet in the excel file.  The default is\n            'Sheet 1'.\n\n        \"\"\"\n\n        from xlsxwriter.workbook import Workbook # https://xlsxwriter.readthedocs.org/ Note: We neex xlswriter. Please meake sure it is installed. Run pip install xlsxwriter to install it using pip. If pip is not installed, install it via easy_install pip. Depending on the system you are on, you might need sudo rights for thesethings.'\n\n        # isotopes and data\n        all_data = np.array(self.get(cycle,'iso_massf'))\n        header_data = self.se.isotopes\n\n        # get mass data\n        mass_data = np.array(self.get(cycle,'mass'))[np.newaxis]\n\n        # stack mass data and header together\n        header_data = np.hstack((['Mass'],header_data))\n        all_data    = np.hstack((mass_data.transpose(),all_data))\n\n\n        # zero the cells with 1.e-99 entry\n        for i in range(len(all_data)):\n            for j in range(len(all_data[i])):\n                if all_data[i][j] == 1.e-99:\n                    all_data[i][j] = 0.\n\n        # check how many columns have all zeros in the file\n        colzero = 0\n        all_sum = all_data.sum(0)\n        for i in range(len(all_sum)):\n            if all_sum[i] == 0.:\n                colzero += 1\n\n        print(str(colzero) + ' columns are empty. Skipping them.')\n\n        # now filter data\n        all_data_fil = np.zeros((len(all_data),len(all_data[0])-colzero))\n        header_data_fil = np.zeros((len(header_data)-colzero),dtype='|S9')\n        k = 0\n        for j in range(len(all_data[0])):\n            if all_sum[j] != 0:\n                for i in range(len(all_data)):\n                    all_data_fil[i][k] = all_data[i][j]\n                header_data_fil[k] = header_data[j]\n                k += 1\n\n        # write to excel file\n        excelfile = Workbook(outfname + '.xlsx')\n        wsh = excelfile.add_worksheet(sheetname)\n        print('If you run from a restart file, this might take a little bit. Be patient!')\n        for i in range(len(all_data_fil)):\n            for j in range(len(all_data_fil[i])):\n                if i == 0:\n                    wsh.write(0,j,header_data_fil[j])\n                wsh.write(i+1,j,all_data_fil[i][j])\n\n        excelfile.close()\n        return None", "response": "This routine takes NuGrid data for a given cycle and writes it into an Excel file."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef plot4(self, num):\n        self.plot_prof_1(num,'H-1',0.,5.,-5,0.)\n        self.plot_prof_1(num,'He-4',0.,5.,-5,0.)\n        self.plot_prof_1(num,'C-12',0.,5.,-5,0.)\n        self.plot_prof_1(num,'O-16',0.,5.,-5,0.)\n        pyl.legend(loc=3)", "response": "Plot the abundance of the log entry for the given log entry number."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef plot4_nolog(self, num):\n        self.plot_prof_2(num,'H-1',0.,5.)\n        self.plot_prof_2(num,'He-4',0.,5.)\n        self.plot_prof_2(num,'C-12',0.,5.)\n        self.plot_prof_2(num,'O-16',0.,5.)\n        pyl.legend(loc=3)", "response": "Plot the nolog of the log entries for the given log entry number."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nplotting one species for cycle between xlim1 and xlim2 and limits1 and limits2 and a symbol.", "response": "def plot_prof_sparse(self, mod, species, xlim1, xlim2, ylim1, ylim2,\n                         sparse, symbol):\n\n        \"\"\"\n        plot one species for cycle between xlim1 and xlim2.\n\n        Parameters\n        ----------\n        species : list\n            which species to plot.\n        mod : string or integer\n            Model (cycle) to plot.\n        xlim1, xlim2 : float\n            Mass coordinate range.\n        ylim1, ylim2 : float\n            Mass fraction coordinate range.\n        sparse : integer\n            Sparsity factor for points.\n        symbol : string\n            which symbol you want to use?\n\n        \"\"\"\n        mass=self.se.get(mod,'mass')\n        Xspecies=self.se.get(mod,'yps',species)\n        pyl.plot(mass[0:len(mass):sparse],np.log10(Xspecies[0:len(Xspecies):sparse]),symbol)\n        pyl.xlim(xlim1,xlim2)\n        pyl.ylim(ylim1,ylim2)\n        pyl.legend()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef trajectory(self, ini, end, delta, mass_coo, age_in_sec=False,\n                   online=False):\n        \"\"\"\n        create a trajectory out of a stellar model\n\n        Parameters\n        ----------\n        ini : integer\n            Initial model, inital cycle number.\n        end : integer\n            Final model, final cycle number.\n        delta : integer\n            Sparsity factor of the frames.\n        mass_coo : float\n            Mass coordinate for the traj.\n        age_in_sec : boolean, optional\n            Set to True if age in se file is in seconds (like in MESA).\n            The default is False.\n\n        Returns\n        --------\n        float\n            radius_at_mass_coo, density_at_mass_coo,\n            temperature_at_mass_coo, age_all\n\n        Notes\n        -----\n        plus writes a file with the trajectory information to be used\n        with ppn.\n\n        Warning: remove the old trajectory, if you have any for the same\n        mass coordinate.  You are appending data, not overwriting.\n\n        Update: this method works for output types with indexes going\n        from the outside in (MESA) or the other way around.  Also the\n        requested quantities are linearly interpolated in the mass\n        shell.\n        online: boolean, optional\n        are you working online in the ipython notebook? If so,\n        you will be given an HTML link to download the file.\n\n        \"\"\"\n\n        filename='traj_'+str(mass_coo)+'.dat'\n        f = open(filename,'a')\n        radius_at_mass_coo=[]\n        density_at_mass_coo=[]\n        temperature_at_mass_coo=[]\n        masses=self.se.get(list(range(ini,end+1,delta)),'mass')\n        temps=self.se.get(list(range(ini,end+1,delta)),'temperature')\n        rhos=self.se.get(list(range(ini,end+1,delta)),'rho')\n        radii=self.se.get(list(range(ini,end+1,delta)),'radius')\n        ages=self.se.get(list(range(ini,end+1,delta)),'age')\n        cycs=list(range(ini,end+1,delta))\n        age_all=[]\n        for i in range(len(ages)):\n            age=ages[i]\n            if age_in_sec:\n                age /= constants.one_year\n            mass=masses[i]\n            temperature=temps[i]\n            rho=rhos[i]\n            radius=radii[i]\n            my_things=[temperature,rho,radius]\n\n            if mass[0]>mass[len(mass)-1]:\n                zone_above=where(mass>mass_coo)[0][-1]\n                zone_below=zone_above+1\n            else:\n                zone_above=where(mass>mass_coo)[0][0]\n                zone_below=zone_above-1\n\n            if mass[zone_below]>mass[zone_above]:\n                sys.exit(\"ERROR: finding of zone index confused\")\n            all_things_interplt=[]\n            for thing in my_things:\n                thing_interplt=thing[zone_below]+(mass_coo-mass[zone_below])* \\\n                    (thing[zone_above]-thing[zone_below])/(mass[zone_above]-mass[zone_below])\n                all_things_interplt.append(thing_interplt)\n            this_temperature,this_rho,this_radius=all_things_interplt\n\n            string = str(cycs[i])+'  '+str(age)+'  '+str(this_temperature)+'  '+str(this_rho)\n            f.write(string+\"\\n\")\n            radius_at_mass_coo.append(this_radius)\n            density_at_mass_coo.append(this_rho)\n            temperature_at_mass_coo.append(this_temperature)\n            age_all.append(age)\n        f.close()\n        if online:\n            return FileLink(filename)\n\n        return radius_at_mass_coo, density_at_mass_coo, temperature_at_mass_coo, age_all", "response": "Create a new trajectory from a stellar model."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates a file with distribution at a given mass coordinate.", "response": "def abund_at_masscoordinate(self, ini, mass_coo, online=False):\n        \"\"\"\n        Create a file with distribution at a given mass coord, and at\n        a given time step.\n\n        This for instance may be used as intial distribution for\n        function trajectory, to reproduce local conditions in ppn.\n\n        Parameters\n        ----------\n        ini : integer\n            Initial model, inital cycle number.\n        mass_coo : float or 1x2 list\n            Mass coordinate for the traj.\n            If list, return mass-averaged abundances for the region\n            spanned by the list.\n        online: boolean, optional\n            are you working online in the ipython notebook? If so,\n            you will be given an HTML link to download the file.\n\n        \"\"\"\n\n        age=self.se.get(ini,'age')\n        mass=self.se.get(ini,'mass')\n        temperature=self.se.get(ini,'temperature')\n        rho=self.se.get(ini,'rho')\n        abund_string = self.se.dcols[5]\n        print(abund_string)\n        if online:\n            from IPython.display import FileLink, FileLinks\n        tm=type(mass_coo)\n        if tm is not list:\n            filename='massf_'+str(mass_coo)+'.dat'\n            f = open(filename,'w')\n            zone=np.abs(mass-mass_coo).argmin()\n            abunds=self.se.get(ini,abund_string)[zone]\n            mass_coo_new=mass[zone]\n        else:\n            filename='massf_'+str(mass_coo[0])+'_'+str(mass_coo[1])+'.dat'\n            f = open(filename,'w')\n            idx1=np.abs(mass-mass_coo[0]).argmin()\n            idx2=np.abs(mass-mass_coo[1]).argmin()\n            dm=np.diff(np.insert(mass,0,0.))\n            dm=dm[idx1:idx2]\n            #average abundances:\n            totmass=sum(dm)\n            abunds=self.se.get(ini,abund_string)[idx1:idx2]\n            dmabunds=[abunds[i]*dm[i] for i in range(len(dm))]\n            abundsum=np.zeros(len(self.se.isotopes))\n            for i in range(len(abundsum)):\n                abundsum[i]=sum([vec[i] for vec in dmabunds])\n            abunds=old_div(abundsum, totmass)\n#        for i in range(len(mass)):\n#            if mass_coo == mass[i]:\n#                mass_coo_new = mass[i]\n#                zone = int(i)\n#            elif mass_coo > mass[i]:\n#                try:\n#                    dum = mass[i+1]\n#                    if mass_coo <= mass[i+1]:\n#                        mass_coo_new = mass[i+1]\n#                        zone = int(i+1)\n#                except IndexError:\n#                    mass_coo_new = mass[i]\n#                    zone = int(i)\n        if tm is not list:\n            string = 'C Model number | time (yr)  |  Temperature (GK)  | density (cm^-3) '\n            f.write(string+\"\\n\")\n            string = 'C '+str(ini)+'  '+str(age)+'  '+str(temperature[zone])+'  '+str(rho[zone])\n            f.write(string+\"\\n\")\n            string = 'C Mass coordinate that is really used'\n            f.write(string+\"\\n\")\n            string = 'C '+str(mass_coo_new)\n            f.write(string+\"\\n\")\n        else:\n            string = 'C Model number | time (yr)'\n            f.write(string+\"\\n\")\n            string = 'C '+str(ini)+'  '+str(age)\n            f.write(string+\"\\n\")\n            string = 'C Mass coordinate range'\n            f.write(string+\"\\n\")\n            string = 'C '+str(mass_coo[0])+', '+str(mass_coo[1])\n            f.write(string+\"\\n\")\n        # the for loop below maybe optimized, I believe\n        # defining before isotopes and abundances. Marco 13 Jannuary 2011\n        for i in range(len(self.se.isotopes)):\n            if str(self.se.isotopes[i].split('-')[1][-2:]).upper() != 'M1':\n                string = 'D '+str(self.se.isotopes[i].split('-')[0]).upper()+'   '+str(self.se.isotopes[i].split('-')[1]).upper()+'    '+str(abunds[i])\n                f.write(string+\"\\n\")\n        f.close()\n        if online:\n            return FileLink(filename)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _kip(self, cycle_end, mix_thresh, xaxis, sparse):\n\n        original_cyclelist = self.se.cycles\n        cyclelist = original_cyclelist[0:cycle_end:sparse]\n\n        xx = self.se.ages[:cycle_end:sparse]\n        totalmass = []\n        m_ini = float(self.se.get('mini'))\n\n\n        fig = pl.figure(1)\n        ax = pl.subplot(1,1,1)\n        fsize = 12\n\n        def getlims(d_coeff, massco):\n            \"\"\"\n            This function returns the convective boundaries for a cycle,\n            given the cycle's dcoeff and massco columns, taking into\n            account whether surface or centre are at the top.\n\n            \"\"\"\n            plotlims = []\n            if massco[0] > massco[-1]:\n                for j in range(-1,-len(d_coeff)-1,-1):\n                    if j == -1:\n                        if d_coeff[j] >= mix_thresh:\n                            plotlims.append(massco[j])\n                        else:\n                            pass\n                    elif (d_coeff[j]-mix_thresh)*(d_coeff[j+1]-mix_thresh) < 0:\n                        plotlims.append(massco[j])\n                    if j == -len(d_coeff):\n                        if d_coeff[j] >= mix_thresh:\n                            plotlims.append(massco[j])\n                return plotlims\n            else:\n                for j in range(len(d_coeff)):\n                    if j == 0:\n                        if d_coeff[j] >= mix_thresh:\n                            plotlims.append(massco[j])\n                        else:\n                            pass\n                    elif (d_coeff[j]-mix_thresh)*(d_coeff[j-1]-mix_thresh) < 0:\n                        plotlims.append(massco[j])\n                    if j == len(d_coeff)-1:\n                        if d_coeff[j] >= mix_thresh:\n                            plotlims.append(massco[j])\n                return plotlims\n\n\n        if xaxis == 'age':\n            ax.set_xlabel('Age [yr]',fontsize=fsize)\n        elif xaxis == 'cycle':\n            xx = cyclelist\n            ax.set_xlabel('Cycle',fontsize=fsize)\n        elif xaxis == 'log_age':\n            for i in range(len(xx)):\n                xx[i] = np.log10(xx[i])\n            ax.set_xlabel('log$_{10}$(age) [yr]',fontsize=fsize)\n        elif xaxis == 'log_time_left':\n            for i in range(len(xx)):\n                xx[i] = np.log10(max(xx)-xx[i])\n            xx[-2] = xx[-3]-abs(xx[-4]-xx[-3])\n            xx[-1] = xx[-2]-abs(xx[-3]-xx[-2])\n            ax.set_xlabel('log$_{10}$(time until collapse) [yr]',fontsize=fsize)\n\n        #centre-surface flag:\n        flag = False\n\n        if self.se.get(cyclelist[1],'mass')[0] > self.se.get(cyclelist[1],'mass')[-1]:\n            flag = True\n\n        for i in range(len(cyclelist)):\n            if flag == True:\n                totalmass.append(self.se.get(cyclelist[i],'mass')[0])\n            else:\n                totalmass.append(self.se.get(cyclelist[i],'mass')[-1])\n            percent = int(i*100/len(cyclelist))\n            sys.stdout.flush()\n            sys.stdout.write(\"\\rcreating color map \" + \"...%d%%\" % percent)\n            d_coeff = self.se.get(cyclelist[i],'dcoeff')\n            massco = self.se.get(cyclelist[i],'mass')\n            plotlims = getlims(d_coeff,massco)\n            for k in range(0,len(plotlims),2):\n                ax.axvline(xx[i],ymin=old_div(plotlims[k],m_ini),ymax=old_div(plotlims[k+1],m_ini),color='b',linewidth=0.5)\n\n\n        ax.plot(xx, totalmass, color='black', linewidth=1)\n        if xaxis == 'log_time_left':\n            ax.axis([xx[0],xx[-1],0.,m_ini])\n        else:\n            ax.axis([min(xx),max(xx),0.,m_ini])\n        ax.set_ylabel('Mass [$M_{\\odot}$]',fontsize=fsize)\n\n        pl.show()", "response": "This function is used to plot a specific cycle and a specific diffusion coefficient."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef kip_cont(self, modstart, modstop, dcoeff_thresh=1.e12,\n                 xres=1000, ylims=[0., 0.], xlims=[0., 0.], yres=2000,\n                 ixaxis='log_time_left', outfile='',\n                 landscape_plot=False, codev='KEP', kepswitch=12555,\n                 outlines=False, write_preproc=False, hatching=False):\n        \"\"\"\n        This function creates a Kippenhahn diagram as a contour plot of\n        the se output using a convection flag or diffusion coefficient\n        threshold.\n\n        Parameters\n        ----------\n        modstart, modstop : integer\n            First and last cycle numbers to plot.\n        dcoeff_thresh : float, optional\n            Diffusion coefficient threshold, above which assume\n            convection is present (only for MESA, where\n            convection_indicator is not there)).  The default is 1.e12.\n        xres, yres : integer, optional\n            x and y resolution.  The default for xres is 1000, the\n            default for yres is 2000.\n        xlims, ylims : list, optional\n            x and y plot limits.  The default is [0., 0.].\n        ixaxis : string, optional\n            Choose one of 'age', 'model_number' or 'log_time_left'.  The\n            default is 'log_time_left'.\n        outfile : string, optional\n            Name of output file including extension, which will be saved\n            in 300 dpi.  The default is ''.\n        landscape_plot : boolean, optional\n            For a landscape plot.  The default is False.\n        codev : string, optional\n            Coose one of 'KEP', 'MES' or 'GNV'.  The default is 'KEP'.\n        kepswitch : integer, optional\n            The default is 12555.\n        outlines : boolean, optional\n            The default is False.\n        write_preproc : boolean, optional\n            The default is False.\n        hatching : boolean, optional\n            The default if False.\n\n        Examples\n        --------\n        >>> pt.kip_cont(0, -1, xres=1000, yres=1000, ixaxis='log_time_left')\n\n        Notes\n        -----\n        Unfortunately, although the implicit do loops are faster, I\n        cannot implement a % bar, but this example call should not take\n        more than 1 minute.\n\n        \"\"\"\n\n        tmp_cycles=self.se.cycles\n        original_cyclelist = [int(tmp_cycles[i]) for i in range(len(tmp_cycles))]\n        nmodels=len(self.se.cycles[modstart:modstop])\n        print('nmodels           = ', nmodels)\n        sparse = int(max(1,old_div(nmodels,xres)))\n        cyclelist = original_cyclelist[modstart:modstop:sparse]\n\n        age_unit=self.get('age_unit')\n        if codev == 'KEP':\n            oneyear = 365.*24.*3600.\n        elif codev == 'MES':\n            oneyear=self.get('one_year')\n        elif codev == 'GNV':\n            oneyear=1.e0\n\n\n        m_min=ylims[0]\n        m_max=ylims[1]\n        if m_min==0.:\n            m_min=0.\n            ylims[0] = m_min\n        if m_max==0.:\n            m_max=float(self.se.get('mini'))\n            ylims[1] = m_max\n\n\n        dy = old_div((m_max-m_min),float(yres))\n        y = np.arange(m_min, m_max, dy)\n\n        Z = np.zeros([len(y),len(cyclelist)],float)\n\n        datatype='convection'\n        if 'convection_indicator' not in self.se.dcols:\n            datatype='dcoeff'\n\n        def list_to_string(array):\n            string=''\n            for el in array:\n                string+='    '+str(el)+'    '\n            string+='\\n'\n            return string\n\n        if write_preproc==True:\n            if os.path.exists(self.sedir+'/conv_data_preproc.txt'):\n                print('Preprocessor already exists (conv_data_preproc.txt).')\n                print('Please remove this file if you want to create a new preprocessor file')\n                sys.exit()\n            print('write_preproc=True')\n            print('getting complete dataset')\n            print('getting mass coordinates')\n            allcycs=[int(self.se.cycles[i]) for i in range(len(self.se.cycles))]\n            mass=self.se.get(allcycs,'mass')\n            print('getting conv')\n            if datatype=='dcoeff':\n                conv=se.f.se.get(allcycs,'dcoeff')\n            else:\n                conv=self.se.get(allcycs,'convection_indicator')\n            print('getting cycles')\n            models=self.se.cycles\n            print('getting ages')\n            if codev=='KEP':\n                deltat=self.se.get(allcycs,'deltat')\n                ages=np.cumsum(deltat)\n            else:\n                ages=self.se.ages\n            print('writing preprocessor file')\n            f=open(self.sedir+'/conv_data_preproc.txt','w')\n            #f=open('./conv_data_preproc.txt','w')\n            f.write('FORMAT OF THIS FILE:\\n')\n            f.write('model_number\\n')\n            f.write('star_age/yr\\n')\n            f.write('mass/Mo\\n')\n            f.write('convection_indicator or dcoeff if unavailable \\n')\n            f.write('*************************************************************\\n')\n\n            for i in range(len(models)):\n                percent = int(i*100/len(self.se.cycles))\n                sys.stdout.flush()\n                sys.stdout.write(\"\\rprogress \" + \"...%d%%\" % percent)\n                f.write(str(models[i])+'\\n')\n                f.write(str(ages[i])+'\\n')\n                f.write(list_to_string(mass[i]))\n                f.write(list_to_string(conv[i]))\n\n            f.close()\n            print('preprocessor file written')\n            sys.exit()\n\n        def realarray(array):\n            \"\"\"\n            Parameters\n            ----------\n            array : list\n                Takes array of strings\n\n            Returns\n            --------\n            list\n                array of floats\n\n            \"\"\"\n            floatarray=np.array([float(el) for el in array])\n            return floatarray\n\n        print('getting data...')\n\n        if os.path.exists(self.sedir+'/conv_data_preproc.txt'):\n            print('... from preprocessor file ...')\n            lines=open(self.sedir+'/conv_data_preproc.txt','r').readlines()\n            #lines=open('./conv_data_preproc.txt','r').readlines()\n            lines=lines[6:]\n            mod=np.array([float(line.split()[0]) for line in lines[::4]])\n            age=old_div(np.array([float(line.split()[0]) for line in lines[1::4]]),oneyear)\n            # masses and mix types will be read just as an array of strings (each string is a profile)\n            # to be extracted later\n            masses=lines[2::4]\n            conv=lines[3::4]\n\n            tmp=[realarray(massco.split()) for massco in masses]\n            masses=tmp\n\n            tmp=[realarray(mixvec.split()) for mixvec in conv]\n            conv=tmp\n\n            print(len(age),len(mod),len(masses),len(conv))\n\n        else:\n            print('... from HDF5 data ...')\n            masses=self.se.get(cyclelist,'mass')\n            mod=cyclelist\n            if self.deltat == None:\n                print('getting deltat since not initialised')\n                self.deltat = self.se.get(self.se.cycles,'deltat')\n            age=old_div(np.cumsum(self.deltat), (3600.*24.*365.))\n\n            if datatype=='convection':\n                conv=self.se.get(cyclelist,'convection_indicator')\n            else:\n                conv=self.se.get(cyclelist,'dcoeff')\n\n        print('calculating convection matrix... ')\n\n        print(len(masses))\n        conv_i_vec_matrix=np.zeros([len(y),len(masses)],float)\n\n        for i in range(len(masses)):\n            percent = int(i*100/len(masses))\n            sys.stdout.flush()\n            sys.stdout.write(\"\\rcreating color map mix \" + \"...%d%%\" % percent)\n\n            mass = masses[i]\n            mix = conv[i]\n#            print i, len(mass),len(mix)\n            # rearrange centre to surface:\n            if mass[-1]<mass[0]:\n                mass=np.append(mass,[0.])[::-1]\n                mix=np.append(mix,[0.])[::-1]\n            else:\n                mass=np.append(mass[::-1],[0.])[::-1]\n                mix=np.append(mix[::-1],[0.])[::-1]\n            f = interpolate.interp1d(mass, mix, bounds_error=False, fill_value=0.)\n            mixnew = f(y)\n\n            for j in range(len(mixnew)):\n                conv_i_vec_matrix[j,i] = mixnew[j]\n\n\n        print('getting stellar mass...')\n        mtot = np.array([np.max(m) for m in masses])\n\n        #########################################################################\n        # PLOT:\n        fsize=20\n\n        params = {'axes.labelsize':  fsize,\n          'text.fontsize':   fsize,\n          'legend.fontsize': fsize,\n          'xtick.labelsize': fsize*0.8,\n          'ytick.labelsize': fsize*0.8,\n          'xtick.major.pad': 8,          # distance to major tick label in points\n          'ytick.major.pad': 6,          # distance to major tick label in points\n          'text.usetex': False}\n        pl.rcParams.update(params)\n        fig = pl.figure(1)\n        ax = pl.axes()\n        if landscape_plot == True:\n            fig.set_size_inches(9,4)\n            fsize=20\n            pl.gcf().subplots_adjust(bottom=0.15)\n            pl.gcf().subplots_adjust(right=0.85)\n\n        ax.set_ylabel('$\\mathrm{Mass }(M_\\odot)$',fontsize=fsize)\n\n        xxx=[]\n        age_array = age\n\n        if ixaxis == 'log_time_left':\n        # log of time left until core collapse\n            gage= np.array(age_array)\n            lage=np.zeros(len(gage))\n            agemin = max(old_div(abs(gage[-1]-gage[-2]),5.),1.e-10)\n            for i in np.arange(len(gage)):\n                if gage[-1]-gage[i]>agemin:\n                    lage[i]=np.log10(gage[-1]-gage[i]+agemin)\n                else :\n                    lage[i]=np.log10(agemin)\n            xxx = np.array([lage[int(i)] for i in cyclelist]) # np.array([lage[i] for i in cyclelist])\n            print(len(xxx))\n            print('plot versus time left')\n            ax.set_xlabel('$\\mathrm{log}_{10}(t^*/\\mathrm{yr})$',fontsize=fsize)\n            if xlims == [0.,0.]:\n                xlims = [xxx[0],xxx[-1]]\n        elif ixaxis =='model_number':\n            cyclelist=mod[modstart:modstop:sparse] # np.array([int(cycle) for cycle in cyclelist])\n            xxx= cyclelist\n            print('plot versus model number')\n            ax.set_xlabel('Model number',fontsize=fsize)\n            if xlims == [0.,0.]:\n                xlims = [cyclelist[0],cyclelist[-1]]\n        elif ixaxis =='age':\n            xxx = old_div(np.array([age_array[int(i)] for i in cyclelist]),1.e6)\n            print('plot versus age')\n            ax.set_xlabel('Age [Myr]',fontsize=fsize)\n            if xlims == [0.,0.]:\n                xlims = [xxx[0],xxx[-1]]\n\n        #cmapMIX=mpl.colors.ListedColormap(['w','#8B8386']) # rose grey\n        cmapMIX = mpl.colors.ListedColormap(['#C4C4C4']) # grey77\n        #cmap = mpl.colors.ListedColormap(['w','b'])\n\n        # some stuff for rasterizing only the contour part of the plot, for nice, but light, eps:\n        class ListCollection(Collection):\n            def __init__(self, collections, **kwargs):\n                Collection.__init__(self, **kwargs)\n                self.set_collections(collections)\n            def set_collections(self, collections):\n                self._collections = collections\n            def get_collections(self):\n                return self._collections\n            @allow_rasterization\n            def draw(self, renderer):\n                for _c in self._collections:\n                    _c.draw(renderer)\n\n        def insert_rasterized_contour_plot(c):\n            collections = c.collections\n            for _c in collections:\n                _c.remove()\n            cc = ListCollection(collections, rasterized=True)\n            ax = pl.gca()\n            ax.add_artist(cc)\n            return cc\n\n\n        print('plotting contours')\n        ax.autoscale(False)\n        low_level = dcoeff_thresh - old_div(dcoeff_thresh,10)\n        high_level= dcoeff_thresh + old_div(dcoeff_thresh,10)\n        if datatype=='dcoeff':\n            low_level = dcoeff_thresh - old_div(dcoeff_thresh,10)\n            high_level= dcoeff_thresh + old_div(dcoeff_thresh,10)\n            CMIX=ax.contourf(xxx,y,conv_i_vec_matrix, cmap=cmapMIX, alpha=1.0,levels=[low_level,1.e99])\n        else:\n            CMIX=ax.contourf(xxx,y,conv_i_vec_matrix, cmap=cmapMIX, alpha=1.0,levels=[0.5,1.5])\n\n        if outlines == True:\n            if datatype=='dcoeff':\n                CMIXoutlines=ax.contour(xxx,y,conv_i_vec_matrix, cmap=cmapMIX,levels=[low_level,high_level])\n            else:\n                CMIX_outlines=ax.contour(xxx,y,conv_i_vec_matrix, cmap=cmapMIX,levels=[0.5,1.5])\n        ax.plot(xxx,mtot,color='k')\n        ax.axis([xlims[0],xlims[-1],ylims[0],ylims[1]])\n\n        def contour_to_hatched_patches(cntrset, hatch_colors, hatch_patterns,\n                               remove_contour=True):\n            from itertools import cycle\n\n            patches_list = []\n            for pathcollection in cntrset.collections:\n                patches_list.append([PathPatch(p1) for p1 in  pathcollection.get_paths()])\n                if remove_contour:\n                    pathcollection.remove()\n\n            for patches, hc, hp  in zip(patches_list,\n                                        cycle(hatch_colors), cycle(hatch_patterns)):\n                for p in patches:\n                    p.set_fc(\"none\")\n                    p.set_ec(\"k\")\n                    p.set_hatch(hp)\n                    ax.add_patch(p)\n\n        hatch_colors = \"k\"\n        hatch_patterns = \"/\\|-+xoO.*\"\n        if hatching==True:\n            contour_to_hatched_patches(CMIX, hatch_colors, hatch_patterns,\n                    remove_contour=True)\n\n        # uncomment or rasterizing the contour - for making nice eps figures that aren't huge files:\n        #insert_rasterized_contour_plot(CMIX)\n        #if outlines==True:\n        #    insert_rasterized_contour_plot(CMIXoutlines)\n\n        if outfile!='':\n            if outfile[-4:] == '.png':\n                fig.savefig(outfile,dpi=300)\n            elif outfile[-4:] == '.eps':\n                fig.savefig(outfile,format='eps')\n            elif outfile[-3:] == '.ps':\n                fig.savefig(outfile,format='ps')\n            elif outfile[-4:] == '.pdf':\n                fig.savefig(outfile,format='pdf')\n            else:\n                print('file format not specified as .eps or .png, saving as eps:')\n                print(outfile+'.eps')\n                fig.savefig(outfile+'.eps',format='eps')\n\n        pl.show()", "response": "This function creates a Kippenhahn diagram of the base class. The Kippenhahn diagram is a contour plot of the base class. The Kippenhahn diagram is a contour plot of the base class."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _kip_cont2(self, sparse, cycle_start=0, cycle_end=0,\n                  plot=['dcoeff'], thresholds=[1.0E+12],\n                  xax='log_time_left', alphas=[1.0], yllim=0., yulim=0.,\n                  y_res=2000, xllim=0., xulim=0., age='seconds',\n                  sparse_intrinsic=20, engen=False,\n                  netnuc_name='eps_nuc', engenalpha=0.6,\n                  outfile='plot.pdf', annotation='',\n                  KEPLER=False):\n        \"\"\"\n        !! EXPERIMENTAL FEATURE (flagged as private) !!\n\n        This function creates a Kippenhahn diagram as a contour plot of\n        the .se.h5 or .out.h5 files using any continuous variable\n        (columns in the hdf5 cycle data). Multiple columns may be\n        plotted, their name indicated in the list \"plot\", and their\n        thresholds in the list \"thresholds\".\n\n        Currently, this is only designed to take one threshold for each\n        variable but future versions will hopefully be able to plot with\n        multiple thresholds, however you may circumvent this issue by\n        repeating the variable in \"plots\" and entering a second\n        threshold for it in \"thresholds\".\n\n        Parameters\n        ----------\n        sparse : integer\n            x-axis (timestep) sparsity.  The true sparsity is\n            sparse*sparse_intrinsic.  Try 100 or 500 for .se.h5 and 20\n            for .out.h5 files and for preliminaxllimry plots.\n        cycle_start : integer, optional\n            Cycle from which you wish to plot.  The default is 0.\n        cycle_end : integer, optional\n            Maximum cycle that you wish to plot.  If cycle_end is 0,\n            then it will plot up to the last cycle available.  The\n            default is 0.\n        plot : list, optional\n            1-D array containing the variables to be plotted (as\n            strings, e.g. plots=['dcoeff','C-13'].  I recommend always\n            plotting 'dcoeff' as plots[0]).  The default is ['dcoeff'].\n        thresholds : list, optional\n            1-D array containing the thresholds corresponding to the\n            variables in \"plots\".  The default is [1.0E+12].\n        xax : string, optional\n            x-axis quantity; either 'log_time_left' or 'cycles'.  The\n            default is 'log_time_left'.\n        alphas : list, optional\n            Array containing the opacity (0 to 1) of the contour for\n            each variable.  The default is [1.0].\n        yllim : float, optional\n            Lower plot limit for y-axis (mass co-ordinate).  The default\n            is 0..\n        yulim : float, optional\n            Upper plot limit for y-axis (mass co-ordinate).  The default\n            is 0..\n        y_res : integer, optional\n            y-axis resolution. Defaults to 2000 but increasing to as\n            much as 10000 does not significantly affect the plotting\n            time.  The default is 2000.\n        xllim : float, optional\n            Lower plot limit for x-axis.  The default is 0..\n        xulim : float, optional\n            Upper plot limit for x-axis.  The default is 0..\n        age : string, optional\n            Either 'years' or 'seconds', depending on the data.  The\n            default is 'seconds'.\n        sparse_intrinsic : integer, optional\n            Sparsity of timesteps in the data provided (usually 20 for\n            .out.h5 files and 1 for .se.h5 files).  The default is 20.\n        engen : boolean, optional\n            Whether the user would like to plot Kippenhahn of convective\n            zones and energy generation.  If True, please still include\n            plots=['dcoeff'] and thresholds=[1.0E+12'] in your call.\n            This will require the data to have an 'eps_nuc' column, so\n            the plot is only working for .se.h5 files from MESA in the\n            current se library.  This is the most recent addition, so\n            probably the most buggy.  The plot script will automatically\n            calculate and assign multiple thresholds according to the\n            model.  The default is False.\n        netnuc_name : string, optional\n            The name of the column containing (eps_nuc-eps_neu).  If you\n            do not have available eps_neu, then you can give\n            netnuc_name=\"eps_nuc\" to just plot energy generation.  The\n            default is \"eps_nuc\".\n        engenalpha : float, optional\n            Opacity of the energy generation contours.  The default\n            is 0.6.\n        outfile : string, optional\n            The name to save the plot as.  The default is 'plot.pdf'.\n        annotation : string, optional\n            Some optional annotation to add to the plot.   The default\n            is ''.\n        KEPLER : boolean, optional\n            The default is False.\n\n        \"\"\"\n\n        # Organize cycles and ages:\n        original_cyclelist = self.se.cycles\n        if cycle_end==0.:\n            cycle_end = original_cyclelist[-1]\n        cycle_end = old_div(int(cycle_end),sparse_intrinsic) - 1\n        if cycle_start==0:\n            pass\n        else:\n            cycle_start = old_div(int(cycle_start),sparse_intrinsic) - 1\n        cyclelist = original_cyclelist[cycle_start:cycle_end:sparse]\n        # fix for KEPLER restart counting at O burning:\n        original_ages= self.se.ages\n        age_at_restart = 0.\n        age_at_restart_idx = 0\n        if KEPLER == True:\n            for i in range(1,len(original_ages)):\n                if (original_ages[i]-original_ages[i-1]) < 0.:\n                    age_at_restart_idx = i-1\n                    age_at_restart = original_ages[i-1]\n                    print('age restart found at cycle = '+str(age_at_restart_idx)+', age = '+str(age_at_restart))\n                    KEPLER = True\n                    break\n\n            for i in range(age_at_restart_idx+1,len(original_ages)):\n                original_ages[i] = original_ages[i] + age_at_restart\n\n\n        # Figure:\n        fig = pl.figure()\n        ax = pl.axes()\n        params = {'axes.labelsize':  15,\n          'text.fontsize':   15,\n          'legend.fontsize': 15,\n          'xtick.labelsize': 15,\n          'ytick.labelsize': 15,\n          'text.usetex': False}\n        fsize=18\n        pl.rcParams.update(params)\n        # X-axis:\n        if xax == 'log_time_left':\n            if KEPLER == True:\n                xxtmp = original_ages[cycle_start:cycle_end:sparse]\n            else:\n                xxtmp = self.se.ages[cycle_start:cycle_end:sparse]\n            if age == 'years':\n                if KEPLER == True:\n                    pass\n                else:\n                    xxtmp = self.se.ages[cycle_start:cycle_end:sparse]\n            elif age == 'seconds':\n                if KEPLER == True:\n                    for i in range(len(cyclelist)):\n                        xxtmp[i] = old_div(original_ages[cycle_start:cycle_end:sparse][i],31558149.984)\n                else:\n                    for i in range(len(cyclelist)):\n                        xxtmp[i] = old_div(self.se.ages[cycle_start:cycle_end:sparse][i],31558149.984)\n        if xax == 'cycles':\n            xx = cyclelist\n            xxtmp = cyclelist\n        # Set up x-axis according to whether ages are in years or seconds and\n        # re-write as log(time left). The last entry will always be -inf in this\n        # way so we calculate it by extrapolating the anti-penultimate and\n        # penultimate entries.\n        # Modified from the GENEC gdic (R. Hirschi)\n        if xax == 'log_time_left':\n            xx=np.zeros(len(xxtmp))\n            agemin = max(old_div(abs(xxtmp[-1]-xxtmp[-2]),5.),1.e-10)\n            for i in np.arange(len(xxtmp)):\n                if xxtmp[-1]-xxtmp[i]>agemin:\n                    xx[i]=np.log10(xxtmp[-1]-xxtmp[i]+agemin)\n                else :\n                    xx[i]=np.log10(agemin)\n            ax.set_xlabel('$log_\\mathrm{10}(t_\\mathrm{end}-t)\\;[\\mathrm{yr}]$',fontsize=fsize-1)\n        if xax == 'cycles':\n            ax.set_xlabel('$\\mathrm{CYCLE}$',fontsize=fsize-1)\n        # Y-axis limits and resolution:\n        totalmass = []\n        try:\n            m_ini = float(self.se.get('mini'))\n        except:\n            mini=m.se.get(0,'total_mass')\n            mini=old_div(mini,constants.mass_sun)\n            print('getting Mini from 1st cycle')\n\n        if yulim==0.:\n            yulim = m_ini\n        dy = old_div(m_ini,float(y_res))\n        vlinetol = 1.0E-8\n        # Set up (y-axis) vector and a 3-D (hist) array to store all of the\n        # contours.\n        y = np.arange(0., m_ini, dy)\n        if engen == True:\n            Z = np.zeros([len(y),len(xxtmp),len(plot)+2],float)\n        else:\n            Z = np.zeros([len(y),len(xxtmp),len(plot)],float)\n\n        # Define function extracting the contour boundaries which will be\n        # called for every cycle in cyclelist, for every variable to be plotted\n        # along with its corresponding threshold(s).\n        def getlims(variable_array,thresh,massco_array):\n            \"\"\"This function returns the variable boundaries (in mass) for a cycle,\n            given the cycle's variable and mass columns, ensuring that the boundaries\n            are ordered centre to surface (as some .se.h5 files are the opposite).\"\"\"\n            plotlims = []\n            # Just a fix for some get problem I was having:\n            if len(massco_array) == 2:\n                massco_array = massco_array[0]\n            if len(variable_array) == 2:\n                variable_array = variable_array[0]\n            if massco_array[0] > massco_array[-1]:\n                for j in range(-1,-len(variable_array)-1,-1):\n                    if j == -1:\n                        if variable_array[j] >= thresh:\n                            plotlims.append(massco_array[j])\n                        else:\n                            pass\n                    elif (variable_array[j]-thresh)*(variable_array[j+1]-thresh) < 0:\n                        plotlims.append(massco_array[j])\n                    if j == -len(variable_array):\n                        if variable_array[j] >= thresh:\n                            plotlims.append(massco_array[j])\n                return plotlims\n            else:\n                for j in range(len(variable_array)):\n                    if j == 0:\n                        if variable_array[j] >= thresh:\n                            plotlims.append(massco_array[j])\n                        else:\n                            pass\n                    elif (variable_array[j]-thresh)*(variable_array[j-1]-thresh) < 0:\n                        plotlims.append(massco_array[j])\n                    if j == len(variable_array)-1:\n                        if variable_array[j] >= thresh:\n                            plotlims.append(massco_array[j])\n                return plotlims\n        # Flag preventing plotting any other variables on an energy generation\n        # Kippenhahn plot:\n        if engen == True:\n            plot = ['dcoeff']\n        # This loop gets the mass co-ordinate array and the variable arrays,\n        # calls to get the boundaries in order, and populates the contour array.\n        ypscoeff = [-1,-1,-1] # this should have same length as plot - quick fix for yps.\n        total_massco = []\n        for i in range(len(cyclelist)):\n#            print 'CYCLE: ', cyclelist[i]\n            massco = self.se.get(cyclelist[i],'mass')\n            total_massco.append(max(massco))\n            plotlimits=[]\n            for j in range(len(plot)):\n                if plot[j][1] == '-' or plot[j][2] == '-':\n                    # Assume file has yps, not iso_massf\n                    ypsthere = True\n                    try: variables = self.se.get(cyclelist[i],'yps')\n                    # If this is not the case, do the usual se calls for iso_massf\n                    except KeyError:\n                        variables = self.se.get(cyclelist[i],plot[j])\n                        ypsthere = False\n                    # If yps is there, ask which indices correspond to the\n                    # elements that are to be plotted, one by one.\n                    if ypsthere == True:\n                        if ypscoeff[j] == -1:\n                            ypscoeff[j] = int(input(\"What integer is your element \"+str(plot[j])+\" in the 'yps' array? \"))\n                        else:\n                            pass\n                        variables = self.se.get(cyclelist[i],'yps')[:,ypscoeff[j]]\n                else:\n                    variables = self.se.get(cyclelist[i],plot[j])\n                plotlims = getlims(variables,thresholds[j],massco)\n                plotlimits.append(plotlims)\n            percent = int(i*100/len(cyclelist))\n            sys.stdout.flush()\n            sys.stdout.write(\"\\rcreating color map \" + \"...%d%%\" % percent)\n            for g in range(len(plot)):\n                for k in range(0,len(plotlimits[g]),2):\n                    llimit = plotlimits[g][k]\n                    ulimit = plotlimits[g][k+1]\n                    #if xx[i] >= 0:\n                    for f in range(y_res):\n                        if llimit<=y[f] and ulimit>y[f]:\n                            Z[f,i,g]=1.\n                    #else:\n                    #   ax.axvline(xx[i],ymin=llimit/m_ini,ymax=ulimit/m_ini,color='#8B8386',alpha=alphas[0],linewidth=0.5)\n        # This function determines the adjacent two mass cells to a point in the\n        # y-vector (which contains mass co-ordinates centre to surface, split into\n        # y_res chunks), returning their index in the mass co-ordinate vector for\n        # that timestep/cycle.\n        def find_nearest(array,value):\n            \"\"\"\n            Returns [lower,upper] indexes locating adjacent mass cells\n            (in the massco vector) around y-value (one of y_res points\n            equally spaced between centre and surface).\n\n            \"\"\"\n            idx=(np.abs(array-value)).argmin()\n            lims=np.zeros([2],int)\n            if idx == len(array)-1: # SJONES post-mod\n                lims[0] = idx - 1   # SJONES post-mod\n                lims[1] = idx       # SJONES post-mod\n                return lims\n            if array[idx] < value:\n                if array[idx]-array[idx+1] < 0.:\n                    lims[0] = idx\n                    lims[1] = idx-1\n                    return lims\n                else:\n                    lims[0] = idx\n                    lims[1] = idx+1\n                    return lims\n            elif array[idx] > value:\n                if array[idx]-array[idx+1] < 0.:\n                    lims[0] = idx+1\n                    lims[1] = idx\n                    return lims\n                else:\n                    lims[0] = idx-1\n                    lims[1] = idx\n                    return lims\n        # This flag enebles the loop below it to populate the contour array for\n        # energy generation. It does not take threshold arguments, as the array\n        # contains the log of the energy generation rather than \"above\" or \"below\".\n        # Because of this, contour boundaries are automatically calculated\n        # according to the max energy generation in the model.\n        dummy_engen=[]\n        engen_signs = []\n        if engen == True:\n        # Requires eps_nuc array in the data. Produces energy generation contour\n        # by linearly interpolating eps_nuc between mass co-ordinates according\n        # to the y-resolution:\n            for i in range(len(cyclelist)):\n#                print 'CYCLE: ', cyclelist[i]\n                max_energy_gen = 0.\n                min_energy_gen = 0.\n                massco = self.se.get(cyclelist[i],'mass')\n                if len(massco) <= 10:\n                    massco=massco[0]\n                dummy_engen = self.se.get(cyclelist[i],netnuc_name)\n                if len(dummy_engen) <= 10:\n                    dummy_engen = dummy_engen[0]\n                for f in range(len(dummy_engen)):\n                    # make all values absolute, but note in engen_signs which were negative:\n                    if dummy_engen[f] == 0.:\n                        engen_signs.append(1.)\n                    else:\n                        engen_signs.append(old_div(dummy_engen[f],abs(dummy_engen[f])))\n                    if abs(engen_signs[f]) != 1.:\n                        print('engen sign not +/- 1!!')\n                        print('engen_signs['+str(f)+'] = ',engen_signs[f])\n                        print('dummy_engen[f] = ', dummy_engen[f])\n                        sys.exit()\n                    dummy_engen[f] = abs(dummy_engen[f])\n                log_epsnuc = np.log10(dummy_engen)\n                # now insert the correct signs again:\n                for f in range(len(log_epsnuc)):\n                    log_epsnuc[f] = log_epsnuc[f]*engen_signs[f]\n                #for f in range(len(log_epsnuc)):\n                    #if str(log_epsnuc[f]) == 'nan': log_epsnuc[f] = 0.\n#                print log_epsnuc\n                percent = int(i*100/len(cyclelist))\n                sys.stdout.flush()\n                sys.stdout.write(\"\\rcreating color map \" + \"...%d%%\" % percent)\n                for j in range(len(y)):\n                    if j == len(y)-1:\n                        energy_here = 0.\n                    elif j == 0:\n                        energy_here = log_epsnuc[-1]\n                    elif y[j] > max(massco):\n                        energy_here = 0.\n                    else:\n                        lims = find_nearest(massco,y[j])\n                        frac = old_div((y[j]-massco[lims[0]]),(massco[lims[1]]-massco[lims[0]]))\n                        energy_here = frac*(log_epsnuc[lims[1]]-log_epsnuc[lims[0]]) + log_epsnuc[lims[0]]\n                    if energy_here > max_energy_gen:\n                        max_energy_gen = energy_here\n                    if energy_here < min_energy_gen:\n                        min_energy_gen = energy_here\n                    if abs(max_energy_gen) > 100.:\n                        print(y[j])\n                        print(engen_signs[f], log_epsnuc[f], frac, lims[0], lims[1], massco[lims[0]], massco[lims[1]])\n                        print((massco[lims[1]]-massco[lims[0]]), (y[j]-massco[lims[0]]))\n                        print(max_energy_gen)\n                        print('exit due to energy generation > 100')\n                        sys.exit()\n#                    print energy_here\n#                    print max_energy_gen\n#                    if energy_here >= 0.:\n                    #Z[j,i,1] = 10**energy_here #SJONES comment\n                    if energy_here < 0.:\n                        energy_here = 0.\n                    Z[j,i,1] = energy_here\n#                    if energy_here < 0.:\n#                        Z[j,i,2] = 10**energy_here\n\n\n        # Here we define the colourmap for the energy generation and an array\n        # containing a list of colours in which to plot each variable (in the\n        # order that the variables appear in \"plots\") iso_colours is obsolete\n        # but was for when we tried plotting isotopes with just their boundary\n        # lines as opposed to shading (for clarity). Colourmaps of these choices\n        # are written to cmap (array).\n        engen_cmap=mpl.cm.get_cmap('Blues')\n        engen_cmap.set_under(color='w',alpha=engenalpha)\n\n        enloss_cmap=mpl.cm.get_cmap('Reds')\n        colours = ['#8B8386','m','g','b']\n        iso_colours = ['b','r','y']\n        cmap = []\n        for i in range(len(plot)):\n            cmap.append(mpl.colors.ListedColormap(['w',colours[i]]))\n\n        print('plotting contours')\n\n        if xllim==0. and xulim==0.:\n            ax.axis([float(xx[0]),float(xx[-1]),yllim,yulim])\n        else:\n            ax.axis([xllim,xulim,yllim,yulim])\n\n        # Plot all of the contours. Levels indicates to only plot the shaded\n        # regions and not plot the white regions, so that they are essentially\n        # transparent. If engen=True, then the energy generation levels\n        # (boundary values) are calculated (in dex) from 2 to the maximum in\n        # steps of 2.\n        for i in range(len(plot)):\n            ax.contourf(xx,y,Z[:,:,i],levels=[0.5,1.5],colors=colours[i], alpha=alphas[i])\n        if engen == True:\n            #ceiling = int(max_energy_gen+1)\n            #floor = int(min_energy_gen+1)\n            #cburn = ax.contourf(xx,y,Z[:,:,1],cmap=engen_cmap,locator=mpl.ticker.LogLocator(),alpha=engenalpha) # SJONES comment\n            cburn = ax.contourf(xx,y,Z[:,:,1],cmap=engen_cmap,alpha=engenalpha,levels=list(range(5,32,5)))\n            cbarburn = pl.colorbar(cburn)\n#            if min_energy_gen != 0:\n#                closs = ax.contourf(xx,y,Z[:,:,2],cmap=enloss_cmap,locator=mpl.ticker.LogLocator(),alpha=engenalpha)\n#                cbarloss = pl.colorbar(closs)\n\n#            cbarburn.set_label('$\\epsilon_\\mathrm{nuc}-\\epsilon_{\\\\nu} \\; (\\mathrm{erg\\,g}^{-1}\\mathrm{\\,s}^{-1})$, > 0',fontsize=fsize)\n            cbarburn.set_label('$log_{10}(\\epsilon_\\mathrm{nuc}) \\; (\\mathrm{erg\\,g}^{-1}\\mathrm{\\,s}^{-1})$, > 0',fontsize=fsize)\n\n\n        pl.plot(xx,total_massco,color='k')\n        pl.text(0.9,0.9,annotation,horizontalalignment='right',transform = ax.transAxes,fontsize=fsize)\n        pl.ylabel('$\\mathrm{Mass}\\;[M_\\odot]$',fontsize=fsize-1)\n        pl.savefig(outfile)\n        print(outfile+' is done.')\n        pl.show()", "response": "This function creates a contour plot of the Kippenhahn diagram of the variable containing the Kippenhahn variables."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef abup_se_plot(mod,species):\n\n        \"\"\"\n        plot species from one ABUPP file and the se file.\n\n        You must use this function in the directory where the ABP files\n        are and an ABUP file for model mod must exist.\n\n        Parameters\n        ----------\n        mod : integer\n            Model to plot, you need to have an ABUPP file for that\n            model.\n        species : string\n            The species to plot.\n\n        Notes\n        -----\n        The species is set to 'C-12'.\n\n        \"\"\"\n\n# Marco, you have already implemented finding headers and columns in\n# ABUP files. You may want to transplant that into here?\n        species='C-12'\n\n        filename = 'ABUPP%07d0000.DAT' % mod\n        print(filename)\n        mass,c12=np.loadtxt(filename,skiprows=4,usecols=[1,18],unpack=True)\n        c12_se=self.se.get(mod,'iso_massf','C-12')\n        mass_se=self.se.get(mod,'mass')\n\n        pyl.plot(mass,c12)\n        pyl.plot(mass_se,c12_se,'o',label='cycle '+str(mod))\n        pyl.legend()", "response": "This function plots the species from one ABUPP file and the se file."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nplot the abundance of all the chemical species Parameters ---------- mass_range : list A 1x2 array containing the lower and upper mass range. If None, it will plot over the entire range. cycle : string or integer A string/integer of the cycle of interest.", "response": "def _read_iso_abund_marco(self, mass_range, cycle):\n        \"\"\"\n        plot the abundance of all the chemical species\n\n        Parameters\n        ----------\n        mass_range : list\n            A 1x2 array containing the lower and upper mass range.  If\n            None, it will plot over the entire range.\n        cycle : string or integer\n            A string/integer of the cycle of interest.\n\n        \"\"\"\n\n        import nuutils as u\n\n        masses = []\n        #    Check the inputs\n        #if not self.se.cycles.count(str(cycle)):\n        #    print 'You entered an cycle that doesn\\'t exist in this dataset:', cycle\n        #    print 'I will try and correct your format.'\n        #    cyc_len = len(self.se.cycles[-1])\n\n        #    print cyc_len, len(str(cycle))\n        #\n        #    while len(str(cycle)) < cyc_len:\n        #        cycle = '0'+str(cycle)\n        #        print cycle\n\n        #    if not self.se.cycles.count(str(cycle)):\n        #        print 'I was unable to correct your cycle.  Please check that it exists in your dataset.'\n\n        masses = self.se.get(cycle,'mass')\n        if mass_range == None:\n            print('Using default mass range')\n            mass_range = [min(masses),max(masses)]\n        # what this was for??? Marco\n        #masses.sort()\n        #mass_range.sort()\n\n\n\n        print('Using The following conditions:')\n        print('\\tmass_range:', mass_range[0], mass_range[1])\n        print('\\tcycle:', cycle)\n\n        isotope_names = self.se.isotopes\n        u.convert_specie_naming_from_h5_to_ppn(isotope_names)\n        names_ppn_world = u.spe\n        number_names_ppn_world = u.n_array\n        u.define_zip_index_for_species(names_ppn_world,number_names_ppn_world)\n\n        # from here below I read the abundance.\n\n        #name_specie_in_file=self.se.dcols[5]\n        # I am using directly 'iso_massf' only because somehow m20 explosive do not have dcols....\n        name_specie_in_file='iso_massf'\n        abunds=self.se.get(cycle,name_specie_in_file)\n\n        global used_masses\n        used_masses = []\n        self.mass_frac = []\n        for i in range(len(masses)):\n            if mass_range[0] <=  masses[i]  and mass_range[1] >=  masses[i] :\n                used_masses.append(masses[i])\n                self.mass_frac.append(abunds[i])"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef burnstage(self, **keyw):\n\n        if (\"isoa\" in keyw) == False:\n            keyw[\"isoa\"] = \"A\"\n        if (\"isoz\" in keyw) == False:\n            keyw[\"isoz\"] = \"Z\"\n        if (\"mass\" in keyw) == False:\n            keyw[\"mass\"] = \"mass\"\n        if (\"age\" in keyw) == False:\n            keyw[\"age\"] = \"age\"\n        if (\"abund\" in keyw) == False:\n            keyw[\"abund\"] = \"iso_massf\"\n        if (\"cycle\" in keyw) == False:\n            keyw[\"cycle\"] = \"cycle\"\n        if (\"cyclefin\" in keyw) == False:\n            cyclefin = 1.e99\n        else:\n            cyclefin = keyw[\"cyclefin\"]\n\n        burn_cycles = []\n        burn_ages = []\n        burn_abun = []\n        burn_type = []\n\n        burn_lifetime = []\n\n        firstfile = True\n\n        hemax, cmax, nemax, omax = 0, 0, 0, 0\n\n\n        cycles_list = self.se.cycles\n        xm_list     = self.se.get(keyw[\"mass\"])\n        age_list    = self.se.get(keyw[\"age\"])\n        abund_list  = self.se.get(keyw[\"abund\"])\n        tables = self.se.Tables()\n        isoa_list   = tables[0]\n        isoz_list   = tables[1]\n\n        # Check the order of the input data\n        xm_init = xm_list[0]\n        centre = 0\n        if isinstance(xm_init, list) == True:\n            if xm_init[0] > xm_init[1]:\n                # mass is descending with shell number and the centre of the star\n                # is the last shell\n                centre = -1\n\n        # Determine yps indices for certain abundances\n        for i in range(len(isoa_list)):\n            try:\n                A = int(isoa_list[i])\n                Z = int(isoz_list[i])\n            except TypeError:\n                A = int(isoa_list[i][0])\n                Z = int(isoz_list[i][0])\n\n            if A == 1 and Z == 1:\n                h1index = i\n            elif A == 4 and Z == 2:\n                he4index = i\n            elif A == 12 and Z == 6:\n                c12index = i\n            elif A == 16 and Z == 8:\n                o16index = i\n            elif A == 20 and Z == 10:\n                ne20index = i\n            elif A == 28 and Z == 14:\n                si28index = i\n\n        if firstfile == True:\n            hmax = abund_list[0][centre][h1index]\n            firstfile = False\n\n        # Try and determine the location of a convective core using the central and\n        # next from central shells\n        for i in range(1, len(cycles_list)-1):\n            if cycles_list[i] > cyclefin and cyclefin != 0:\n                pair = False\n                age1 = -1\n                for i in range(len(burn_type)):\n                    if 'start' in burn_type[i] and pair == False:\n                        age1 = burn_ages[i]\n                        pair = True\n                    elif 'end' in burn_type[i] and pair == True:\n                        age2 = burn_ages[i]\n                        pair = False\n                        if age1 != -1:\n                            burn_lifetime.append(age2 - age1)\n                            age1 = -1\n\n                return [burn_cycles, burn_ages, burn_abun, burn_type,\n                burn_lifetime]\n\n            # H-burning\n            hcen  = abund_list[i][centre][h1index]\n            hcennext = abund_list[i+1][centre][h1index]\n            if hcen >1.e-10:\n                if hcennext < hmax-0.003 and hcen >= hmax-0.003:\n                    burn_cycles.append(cycles_list[i])\n                    burn_ages.append(age_list[i])\n                    burn_abun.append(hcen)\n                    burn_type.append('H_start')\n\n                if hcennext < 1.e-1 and hcen >= 1.e-1:\n                    burn_cycles.append(cycles_list[i])\n                    burn_ages.append(age_list[i])\n                    burn_abun.append(1.e-1)\n                    burn_type.append('H')\n\n                if hcennext < 1.e-2 and hcen >= 1.e-2:\n                    burn_cycles.append(cycles_list[i])\n                    burn_ages.append(age_list[i])\n                    burn_abun.append(1.e-2)\n                    burn_type.append('H')\n\n                if hcennext < 1.e-3 and hcen >= 1.e-3:\n                    burn_cycles.append(cycles_list[i])\n                    burn_ages.append(age_list[i])\n                    burn_abun.append(1.e-3)\n                    burn_type.append('H')\n\n                if hcennext < 1.e-4 and hcen >= 1.e-4:\n                    burn_cycles.append(cycles_list[i])\n                    burn_ages.append(age_list[i])\n                    burn_abun.append(1.e-4)\n                    burn_type.append('H')\n\n                if hcennext < 1.e-5 and hcen >= 1.e-5:\n                    burn_cycles.append(cycles_list[i])\n                    burn_ages.append(age_list[i])\n                    burn_abun.append(1.e-5)\n                    burn_type.append('H_end')\n                    hemax = abund_list[i][centre][he4index]\n\n                if hcennext < 1.e-6 and hcen >= 1.e-6:\n                    burn_cycles.append(cycles_list[i])\n                    burn_ages.append(age_list[i])\n                    burn_abun.append(1.e-6)\n                    burn_type.append('H')\n\n                if hcennext < 1.e-9 and hcen >= 1.e-9:\n                    burn_cycles.append(cycles_list[i])\n                    burn_ages.append(age_list[i])\n                    burn_abun.append(1.e-9)\n                    burn_type.append('H')\n\n            # He-burning\n            hecen  = abund_list[i][centre][he4index]\n            hecennext = abund_list[i+1][centre][he4index]\n            if hcen < 1.e-5 and hecen > 1.e-10:\n                if hecennext < hemax-0.003 and hecen >= hemax-0.003:\n                    burn_cycles.append(cycles_list[i])\n                    burn_ages.append(age_list[i])\n                    burn_abun.append(hecen)\n                    burn_type.append('He_start')\n\n                if hecennext < 1.e-1 and hecen >= 1.e-1:\n                    burn_cycles.append(cycles_list[i])\n                    burn_ages.append(age_list[i])\n                    burn_abun.append(1.e-1)\n                    burn_type.append('He')\n\n                if hecennext < 1.e-2 and hecen >= 1.e-2:\n                    burn_cycles.append(cycles_list[i])\n                    burn_ages.append(age_list[i])\n                    burn_abun.append(1.e-2)\n                    burn_type.append('He')\n\n                if hecennext < 1.e-3 and hecen >= 1.e-3:\n                    burn_cycles.append(cycles_list[i])\n                    burn_ages.append(age_list[i])\n                    burn_abun.append(1.e-3)\n                    burn_type.append('He')\n\n                if hecennext < 1.e-4 and hecen >= 1.e-4:\n                    burn_cycles.append(cycles_list[i])\n                    burn_ages.append(age_list[i])\n                    burn_abun.append(1.e-4)\n                    burn_type.append('He')\n\n                if hecennext < 1.e-5 and hecen >= 1.e-5:\n                    burn_cycles.append(cycles_list[i])\n                    burn_ages.append(age_list[i])\n                    burn_abun.append(1.e-5)\n                    burn_type.append('He_end')\n                    cmax = abund_list[i][centre][c12index]\n\n                if hecennext < 1.e-6 and hecen >= 1.e-6:\n                    burn_cycles.append(cycles_list[i])\n                    burn_ages.append(age_list[i])\n                    burn_abun.append(1.e-6)\n                    burn_type.append('He')\n\n                if hecennext < 1.e-9 and hecen >= 1.e-9:\n                    burn_cycles.append(cycles_list[i])\n                    burn_ages.append(age_list[i])\n                    burn_abun.append(1.e-9)\n                    burn_type.append('He')\n\n            # C-burning\n            ccen  = abund_list[i][centre][c12index]\n            ccennext = abund_list[i+1][centre][c12index]\n            if hcen < 1.e-5 and hecen < 1.e-5 and ccen > 1.e-10:\n                if ccennext < cmax-0.003 and ccen >= cmax-0.003:\n                    burn_cycles.append(cycles_list[i])\n                    burn_ages.append(age_list[i])\n                    burn_abun.append(ccen)\n                    burn_type.append('C_start')\n\n                if ccennext < 1.e-1 and ccen >= 1.e-1:\n                    burn_cycles.append(cycles_list[i])\n                    burn_ages.append(age_list[i])\n                    burn_abun.append(1.e-1)\n                    burn_type.append('C')\n\n                if ccennext < 1.e-2 and ccen >= 1.e-2:\n                    burn_cycles.append(cycles_list[i])\n                    burn_ages.append(age_list[i])\n                    burn_abun.append(1.e-2)\n                    burn_type.append('C')\n\n                if ccennext < 1.e-3 and ccen >= 1.e-3:\n                    burn_cycles.append(cycles_list[i])\n                    burn_ages.append(age_list[i])\n                    burn_abun.append(1.e-3)\n                    burn_type.append('C')\n\n                if ccennext < 1.e-4 and ccen >= 1.e-4:\n                    burn_cycles.append(cycles_list[i])\n                    burn_ages.append(age_list[i])\n                    burn_abun.append(1.e-4)\n                    burn_type.append('C')\n\n                if ccennext < 1.e-5 and ccen >= 1.e-5:\n                    burn_cycles.append(cycles_list[i])\n                    burn_ages.append(age_list[i])\n                    burn_abun.append(1.e-5)\n                    burn_type.append('C_end')\n                    nemax = abund_list[i][centre][ne20index]\n\n                if ccennext < 1.e-6 and ccen >= 1.e-6:\n                    burn_cycles.append(cycles_list[i])\n                    burn_ages.append(age_list[i])\n                    burn_abun.append(1.e-6)\n                    burn_type.append('C')\n\n                if ccennext < 1.e-9 and ccen >= 1.e-9:\n                    burn_cycles.append(cycles_list[i])\n                    burn_ages.append(age_list[i])\n                    burn_abun.append(1.e-9)\n                    burn_type.append('C')\n\n            # Ne-burning\n            necen  = abund_list[i][centre][ne20index]\n            necennext = abund_list[i+1][centre][ne20index]\n            if hcen < 1.e-5 and hecen < 1.e-5 and ccen < 1.e-3 and necen > 1.e-10:\n                if necennext < nemax-0.003 and necen >= nemax-0.003:\n                    burn_cycles.append(cycles_list[i])\n                    burn_ages.append(age_list[i])\n                    burn_abun.append(necen)\n                    burn_type.append('Ne_start')\n\n                if necennext < 1.e-1 and necen >= 1.e-1:\n                    burn_cycles.append(cycles_list[i])\n                    burn_ages.append(age_list[i])\n                    burn_abun.append(1.e-1)\n                    burn_type.append('Ne')\n\n                if necennext < 1.e-2 and necen >= 1.e-2:\n                    burn_cycles.append(cycles_list[i])\n                    burn_ages.append(age_list[i])\n                    burn_abun.append(1.e-2)\n                    burn_type.append('Ne')\n\n\n                if necennext < 1.e-3 and necen >= 1.e-3:\n                    burn_cycles.append(cycles_list[i])\n                    burn_ages.append(age_list[i])\n                    burn_abun.append(1.e-3)\n                    burn_type.append('Ne_end')\n                    omax = abund_list[i][centre][o16index]\n\n                if necennext < 1.e-4 and necen >= 1.e-4:\n                    burn_cycles.append(cycles_list[i])\n                    burn_ages.append(age_list[i])\n                    burn_abun.append(1.e-4)\n                    burn_type.append('Ne')\n\n                if necennext < 1.e-5 and necen >= 1.e-5:\n                    burn_cycles.append(cycles_list[i])\n                    burn_ages.append(age_list[i])\n                    burn_abun.append(1.e-5)\n                    burn_type.append('Ne')\n\n                if necennext < 1.e-6 and necen >= 1.e-6:\n                    burn_cycles.append(cycles_list[i])\n                    burn_ages.append(age_list[i])\n                    burn_abun.append(1.e-6)\n                    burn_type.append('Ne')\n\n                if necennext < 1.e-9 and necen >= 1.e-9:\n                    burn_cycles.append(cycles_list[i])\n                    burn_ages.append(age_list[i])\n                    burn_abun.append(1.e-9)\n                    burn_type.append('Ne')\n\n            # O-burning\n            ocen  = abund_list[i][centre][o16index]\n            ocennext = abund_list[i+1][centre][o16index]\n            if hcen < 1.e-5 and hecen < 1.e-5 and ccen < 1.e-3 and ocen > 1.e-10:\n                if ocennext < omax-0.003 and ocen >= omax-0.003:\n                    burn_cycles.append(cycles_list[i])\n                    burn_ages.append(age_list[i])\n                    burn_abun.append(ccen)\n                    burn_type.append('O_start')\n\n                if ocennext < 1.e-1 and ocen >= 1.e-1:\n                    burn_cycles.append(cycles_list[i])\n                    burn_ages.append(age_list[i])\n                    burn_abun.append(1.e-1)\n                    burn_type.append('O')\n\n                if ocennext < 1.e-2 and ocen >= 1.e-2:\n                    burn_cycles.append(cycles_list[i])\n                    burn_ages.append(age_list[i])\n                    burn_abun.append(1.e-2)\n                    burn_type.append('O')\n\n                if ocennext < 1.e-3 and ocen >= 1.e-3:\n                    burn_cycles.append(cycles_list[i])\n                    burn_ages.append(age_list[i])\n                    burn_abun.append(1.e-3)\n                    burn_type.append('O')\n\n                if ocennext < 1.e-4 and ocen >= 1.e-4:\n                    burn_cycles.append(cycles_list[i])\n                    burn_ages.append(age_list[i])\n                    burn_abun.append(1.e-4)\n                    burn_type.append('O')\n\n                if ocennext < 1.e-5 and ocen >= 1.e-5:\n                    burn_cycles.append(cycles_list[i])\n                    burn_ages.append(age_list[i])\n                    burn_abun.append(1.e-5)\n                    burn_type.append('O_end')\n\n                if ocennext < 1.e-6 and ocen >= 1.e-6:\n                    burn_cycles.append(cycles_list[i])\n                    burn_ages.append(age_list[i])\n                    burn_abun.append(1.e-6)\n                    burn_type.append('O')\n\n                if ocennext < 1.e-9 and ocen >= 1.e-9:\n                    burn_cycles.append(cycles_list[i])\n                    burn_ages.append(age_list[i])\n                    burn_abun.append(1.e-9)\n                    burn_type.append('O')\n\n\n        pair = False\n        age1 = -1\n        for i in range(len(burn_type)):\n            if 'start' in burn_type[i] and pair == False:\n                age1 = burn_ages[i]\n                pair = True\n            elif 'end' in burn_type[i] and pair == True:\n                age2 = burn_ages[i]\n                pair = False\n                if age1 != -1:\n                    burn_lifetime.append(age2 - age1)\n                    age1 = -1\n\n        return [burn_cycles, burn_ages, burn_abun, burn_type, burn_lifetime]", "response": "This function calculates the presence of burning stages and outputs the ages when key isotopes are depleted and outputs the lifetimes when key isotopes are depleted."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef cores(self, incycle, **keyw):\n\n        def infomod(core_opt, *inp):\n            \"\"\"\n            This calls the correct infomod function depending on the\n            value of core_opt.\n\n            \"\"\"\n            if core_opt == 0:\n                return infomod1(inp[0], inp[1], inp[2])\n            elif core_opt == 1:\n                return infomod2(inp[0], inp[1], inp[2], inp[3], inp[4])\n\n        def infomod1(shell, yps, isoindex):\n            \"\"\"\n            Function for defining data to print into a string.  This is\n            used for the case of core_opt = 0.\n\n            \"\"\"\n\n            xh = yps[shell][isoindex[0]]\n            xhe = yps[shell][isoindex[1]]\n            xc = yps[shell][isoindex[2]]\n            xo = yps[shell][isoindex[3]]\n            xsi = yps[shell][isoindex[4]]\n            xs = yps[shell][isoindex[5]]\n            xa = yps[shell][isoindex[6]]\n            xca = yps[shell][isoindex[7]]\n            xti = yps[shell][isoindex[8]]\n            xcr = yps[shell][isoindex[9]]\n            xfe = yps[shell][isoindex[10]]\n            xni = yps[shell][isoindex[11]]\n\n            xsicore = xsi + xs + xa + xca + xti\n            xfecore = xcr + xfe + xni\n\n            return ' h=' + \"%12.4e\"%(xh) + ' he=' + \"%12.4e\"%(xhe) + \\\n            ' c=' + \"%12.4e\"%(xc) + ' o=' + \"%12.4e\"%(xo) + \\\n            ' si=' + \"%12.4e\"%(xsicore) + ' fe=' + \"%12.4e\"%(xfecore)\n\n        def infomod2(shell, yps, isoindex, xsicore, xfecore):\n            \"\"\"\n            Function for defining data to print into a string.  This is\n            used for the case of core_opt = 1.\n\n            \"\"\"\n            xsicore = 0.\n            xsicoren = 0.\n            xfecore = 0.\n            xfecoren = 0.\n\n            xh = yps[shell][isoindex[0]]\n            xhe = yps[shell][isoindex[1]]\n            xc = yps[shell][isoindex[2]]\n            xo = yps[shell][isoindex[3]]\n\n            for j in iso_si:\n                xsicore += yps[i][j]\n                xsicoren += yps[i+iter][j]\n            for j in iso_fe:\n                xfecore += yps[i][j]\n                xfecoren += yps[i+iter][j]\n\n            return 'shellnb = ' + str(shell) + ' h=' + \"%12.4e\"%(xh) + \\\n            ' he=' + \"%12.4e\"%(xhe) + ' c=' + \"%12.4e\"%(xc) + \\\n            ' o=' + \"%12.4e\"%(xo) + ' si=' + \"%12.4e\"%(xsicore) + \\\n            ' fe=' + \"%12.4e\"%(xfecore)\n\n        if (\"isoa\" in keyw) == False:\n            keyw[\"isoa\"] = \"A\"\n        if (\"isoz\" in keyw) == False:\n            keyw[\"isoz\"] = \"Z\"\n        if (\"mass\" in keyw) == False:\n            keyw[\"mass\"] = \"mass\"\n        if (\"abund\" in keyw) == False:\n            keyw[\"abund\"] = \"iso_massf\"\n        if (\"coreopt\" in keyw) == False:\n            core_opt = 1\n        else:\n            core_opt = keyw[\"coreopt\"]\n\n        cores = [0,0,0,0,0,0]\n        core_type = [\"\",\"\",\"\",\"\",\"\",\"\"]\n        core_info = []\n        iso_si = []\n        iso_fe = []\n        first = True\n\n        xm_list     = self.se.get(incycle, keyw[\"mass\"])\n        abund_list  = self.se.get(incycle, keyw[\"abund\"])\n        tables = self.se.Tables\n        isoa_list   = tables[0]\n        isoz_list   = tables[1]\n\n        # Check the order of the input data\n        xmass = xm_list\n        yps = abund_list\n        centre = 0\n        surface = len(xmass)-1\n        iter = -1\n        if isinstance(xmass, list) == True:\n            if xmass[0] > xmass[1]:\n                # mass is descending with shell number and the centre of the star\n                # is the last shell\n                centre = len(xmass)-1\n                surface = 0\n                iter = 1\n\n        mco01 = 0.\n        na    = 0\n        nco   = 0\n\n        h1index = -1\n        he4index = -1\n        c12index = -1\n        o16index = -1\n        si28index = -1\n        s32index = -1\n        a36index = -1\n        ca40index = -1\n        ti44index = -1\n        cr48index = -1\n        fe52index = -1\n        ni56index = -1\n\n        # Determine yps indices for certain abundances\n        for i in range(len(isoa_list)):\n            try:\n                A = int(isoa_list[i])\n                Z = int(isoz_list[i])\n            except TypeError:\n                A = int(isoa_list[i][0])\n                Z = int(isoz_list[i][0])\n\n            if A == 1 and Z == 1:\n                h1index = i\n            elif A == 4 and Z == 2:\n                he4index = i\n            elif A == 12 and Z == 6:\n                c12index = i\n            elif A == 16 and Z == 8:\n                o16index = i\n\n            if core_opt == 0:\n                if A == 28 and Z == 14:\n                    si28index = i\n                elif A == 32 and Z == 16:\n                    s32index = i\n                elif A == 36 and Z == 18:\n                    a36index = i\n                elif A == 40 and Z == 20:\n                    ca40index = i\n                elif A == 44 and Z == 22:\n                    ti44index = i\n                elif A == 48 and Z == 24:\n                    cr48index = i\n                elif A == 52 and Z == 26:\n                    fe52index = i\n                elif A == 56 and Z == 38:\n                    ni56index = i\n\n        if h1index == -1 or he4index == -1 or c12index == -1 or o16index == -1:\n            print(\"A key isotope(s) is not found in network!  Please check for the \\\n            presence of H1, He4, C12 and O16.\")\n            os.sys.exit()\n\n        # Si_core = Si28+S32+Ar36+Ca40+Ti44\n        # Fe_core = Cr48+Fe52+Ni56\n        if core_opt == 0:\n            if si28index == -1 or s32index == -1 or a36index == -1 or ca40index == -1 \\\n            or ti44index == -1 or cr48index == -1 or fe52index == -1 or ni56index == -1:\n                print(\"Key isotopes for measuring the core mass with core_opt = 0 \\\n                are missing.  Setting core_opt = 1.\")\n                core_opt = 1\n\n        # Si_core = Sum of all isotopes with 14 <= Z <= 22\n        # Fe_core = Sum of all isotopes with 23 <= Z <= 28\n        if core_opt == 1:\n            for i in range(len(isoa_list)):\n                try:\n                    A = int(isoa_list[i])\n                    Z = int(isoz_list[i])\n                except TypeError:\n                    A = int(isoa_list[i][0])\n                    Z = int(isoz_list[i][0])\n                if Z >= 14 and Z <= 22:\n                    iso_si.append(i)\n                if Z >= 23 and Z <= 28:\n                    iso_fe.append(i)\n\n        isoindex = [h1index, he4index, c12index, o16index]\n        if core_opt == 0:\n            isoindex.extend([si28index, s32index, a36index, ca40index,\n            ti44index, cr48index, fe52index, ni56index])\n\n        if first == True:\n            first = False\n            cores[0] = xmass[surface]\n            core_type[0] = \"Final\"\n            core_info.append(infomod(core_opt, surface, yps, isoindex, iso_si, iso_fe))\n\n        # Iterate over shells to determine the core masses\n        for i in np.arange(surface, centre, iter):\n\n            xsicore = 0.\n            xfecore = 0.\n            xsicoren = 0.\n            xfecoren = 0.\n\n            # Abundances of key isotopes at this shell (and the next one)\n            xh = yps[i][h1index]\n            xhe = yps[i][he4index]\n            xc = yps[i][c12index]\n            xo = yps[i][o16index]\n\n            xhn = yps[i+iter][h1index]\n            xhen = yps[i+iter][he4index]\n            xcn = yps[i+iter][c12index]\n            xon = yps[i+iter][o16index]\n\n            xcocore = xc + xo\n            xcocoren = xcn + xon\n\n            if core_opt == 0:\n                xsi = yps[i][si28index]\n                xs = yps[i][s32index]\n                xa = yps[i][a36index]\n                xca = yps[i][ca40index]\n                xti = yps[i][ti44index]\n                xcr = yps[i][cr48index]\n                xfe = yps[i][fe52index]\n                xni = yps[i][ni56index]\n\n                xsin = yps[i+iter][si28index]\n                xsn = yps[i+iter][s32index]\n                xan = yps[i+iter][a36index]\n                xcan = yps[i+iter][ca40index]\n                xtin = yps[i+iter][ti44index]\n                xcrn = yps[i+iter][cr48index]\n                xfen = yps[i+iter][fe52index]\n                xnin = yps[i+iter][ni56index]\n\n                xsicore = xsi + xs + xa + xca + xti\n                xfecore = xcr + xfe + xni\n\n                xsicoren = xsin + xsn + xan + xcan + xtin\n                xfecoren = xcrn + xfen + xnin\n\n            elif core_opt == 1:\n                for j in iso_si:\n                    xsicore += yps[i][j]\n                    xsicoren += yps[i+iter][j]\n                for j in iso_fe:\n                    xfecore += yps[i][j]\n                    xfecoren += yps[i+iter][j]\n\n            # M_alpha:\n            if xh >= 1.e-9:\n                if xhen > 0.75 and xhe <= 0.75:\n                    if cores[1] == 0:\n                        cores[1] = xmass[i]\n                        core_type[1] = 'Malpha 75%'\n                        core_info.append('Malpha 75% '+str(xmass[i-iter])+ \\\n                        infomod(core_opt, i-iter, yps, isoindex, iso_si, iso_fe))\n                        core_info.append('Malpha 75% '+str(xmass[i])+ \\\n                        infomod(core_opt, i, yps, isoindex, iso_si, iso_fe))\n                        core_info.append('Malpha 75% '+str(xmass[i+iter])+ \\\n                        infomod(core_opt, i+iter, yps, isoindex, iso_si, iso_fe))\n                if xhen > 0.5 and xhe <= 0.5:\n                    core_info.append('Malpha 50% '+str(xmass[i])+ \\\n                    infomod(core_opt, i, yps, isoindex, iso_si, iso_fe))\n                if xhn < 1.e-2 and xh >= 1.e-2:\n                    na=i\n                    core_info.append('Malpha 1.e-2 '+str(xmass[i])+ \\\n                    infomod(core_opt, i, yps, isoindex, iso_si, iso_fe))\n                if xhn < 1.e-4 and xh >= 1.e-4:\n                    core_info.append('Malpha 1.e-4 '+str(xmass[i])+ \\\n                    infomod(core_opt, i, yps, isoindex, iso_si, iso_fe))\n                if xhn < 1.e-5 and xh >= 1.e-5:\n                    core_info.append('Malpha 1.e-5 '+str(xmass[i])+ \\\n                    infomod(core_opt, i, yps, isoindex, iso_si, iso_fe))\n\n            # M_CO:\n            if xhe >= 1.e-9 and xh < 1.e-9:\n                if xcocoren > 0.5 and xcocore <= 0.5:\n                    core_info.append('Mco 50% '+str(xmass[i])+ \\\n                    infomod(core_opt, i, yps, isoindex, iso_si, iso_fe))\n                if xcocoren > 0.75 and xcocore <= 0.75:\n                    core_info.append('Mco 75% '+str(xmass[i])+ \\\n                    infomod(core_opt, i, yps, isoindex, iso_si, iso_fe))\n                if xhen < 1.e-2 and xhe >= 1.e-2:\n                    if cores[2] == 0:\n                        mco01=xmass[i]\n                        nco=i\n                        cores[2] = xmass[i]\n                        core_type[2] = 'Mco'\n                        core_info.append('Mco 1.e-2 '+str(xmass[i-iter])+ \\\n                        infomod(core_opt, i-iter, yps, isoindex, iso_si, iso_fe))\n                        core_info.append('Mco 1.e-2 '+str(xmass[i])+ \\\n                        infomod(core_opt, i, yps, isoindex, iso_si, iso_fe))\n                        core_info.append('Mco 1.e-2 '+str(xmass[i+iter])+ \\\n                        infomod(core_opt, i+iter, yps, isoindex, iso_si, iso_fe))\n                if xhen < 1.e-4 and xhe >= 1.e-4:\n                    core_info.append('Mco 1.e-4 '+str(xmass[i])+ \\\n                    infomod(core_opt, i, yps, isoindex, iso_si, iso_fe))\n                if xhen < 1.e-5 and xhe >= 1.e-5:\n                    core_info.append('Mco 1.e-5 '+str(xmass[i])+ \\\n                    infomod(core_opt, i, yps, isoindex, iso_si, iso_fe))\n\n            # M_Si:\n            if xcocore >= 1.e-7:\n                if xsicoren > 0.5 and xsicore <= 0.5:\n                    if cores[3] == 0:\n                        core_info.append('Msi 50% '+str(xmass[i-iter])+ \\\n                        infomod(core_opt, i-iter, yps, isoindex, iso_si, iso_fe))\n                        core_info.append('Msi 50% '+str(xmass[i])+ \\\n                        infomod(core_opt, i, yps, isoindex, iso_si, iso_fe))\n                        core_info.append('Msi 50% '+str(xmass[i+iter])+ \\\n                        infomod(core_opt, i+iter, yps, isoindex, iso_si, iso_fe))\n                        cores[3] = xmass[i]\n                        core_type[3] = 'Msi 50%'\n                if xsicoren > 0.75 and xsicore <= 0.75:\n                    core_info.append('Msi 75% '+str(xmass[i])+ \\\n                    infomod(core_opt, i, yps, isoindex, iso_si, iso_fe))\n                if xcocoren > 1.e-2 and xcocore <= 1.e-2:\n                    core_info.append('Msi 1.e-2 '+str(xmass[i])+ \\\n                    infomod(core_opt, i, yps, isoindex, iso_si, iso_fe))\n\n            # M_fe:\n            if xfecoren > 0.5 and xfecore <= 0.5:\n                if cores[4] == 0:\n                    core_info.append('Mfe 50% '+str(xmass[i-iter])+ \\\n                    infomod(core_opt, i-iter, yps, isoindex, iso_si, iso_fe))\n                    core_info.append('Mfe 50% '+str(xmass[i])+ \\\n                    infomod(core_opt, i, yps, isoindex, iso_si, iso_fe))\n                    core_info.append('Mfe 50% '+str(xmass[i+iter])+ \\\n                    infomod(core_opt, i+iter, yps, isoindex, iso_si, iso_fe))\n                    cores[4] = xmass[i]\n                    core_type[4] = 'Mfe 50%'\n            if xfecoren > 0.75 and xfecore <= 0.75:\n                core_info.append('Mfe 75% '+str(xmass[i])+ \\\n                infomod(core_opt, i, yps, isoindex, iso_si, iso_fe))\n            if xsicoren > 1.e-2 and xsicore <= 1.e-2:\n                core_info.append('Mfe 1.e-2 '+str(xmass[i])+ \\\n                infomod(core_opt, i, yps, isoindex, iso_si, iso_fe))\n\n        mcof=mco01\n        i=na\n        while i < nco:\n            i+=1\n            xco = yps[i][c12index] + yps[i][o16index]\n            xcop = yps[i-iter][c12index] + yps[i-iter][o16index]\n            mcof+=(xco+xcop)/2.*(xmass[i-iter]-xmass[i])\n        cores[2] = mcof\n        core_type[2] = 'Mco int'\n\n        # M_rem vs M_CO relationship\n        xmco = np.array([0.72,1.01,1.38,2.10,2.97,4.94,7.20,13.88,24.75,38.12,58.73])\n        xmre = np.array([0.72,1.01,1.23,1.42,1.65,2.15,2.72,4.3,7.6,11.4,17.1])\n\n        if 'Mco' in core_type:\n            for i in np.arange(len(xmco)):\n                if cores[2] < xmco[i]:\n                    xco = yps[i][c12index] + yps[i][o16index]\n                    xcop = yps[i-iter][c12index] + yps[i-iter][o16index]\n                    cores[5] = xmre[i-1]+(xmre[i]-xmre[i-1])*(cores[j]-xmco[i-1])/(xmco[i]-xmco[i-1])\n                    core_type[5] = 'Mrem'\n                    break\n\n        return [cores, core_type, core_info]", "response": "This function returns the list of core masses for the given incycle and key word arguments."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef presnyields(self, *cycles, **keyw):\n        abund_list  = []\n        xm_list  = []\n\n        if (\"xm\" in keyw) == False:\n            keyw[\"xm\"] = \"mass\"\n        if (\"abund\" in keyw) == False:\n            keyw[\"abund\"] = \"iso_massf\"\n        if (\"mrem\" in keyw) == False:\n            mrem = 0.\n        else:\n            mrem = keyw[\"mrem\"]\n\n        # Only two cycles are required in this program.\n        # Any more will be ignored\n        cylen = len(cycles)\n        if cylen > 2:\n            cylen = 2\n        for i in range(cylen):\n            cycle = cycles[i]\n            abund_list.append(self.se.get(cycle, keyw['abund']))\n            xm_list.append(self.se.get(cycle, keyw['xm']))\n\n        isoX = abund_list[0]\n        xm = xm_list[0]\n        if cylen == 2:\n            isoXini = abund_list[1] # initial abundances\n\n        niso = len(isoX[0,:])\n        nshells = len(xm)\n\n        X_i = np.zeros([niso], float)\n        ybound = np.zeros([niso], float)\n        xarray = np.zeros([nshells+1], float)\n        yarray = np.zeros([nshells+1], float)\n\n        # This part determines the index of the mass coordinate array which\n        # is closest to the specified remnant mass.  This is used in the next\n        # part, which is used to interpolate the abundances at the remnant mass\n        for k in range(nshells):\n            k1 = k\n            if mrem<=xm[k]:\n                break\n\n        # This part is the interpolation of the isotopes found at the remnant\n        # mass.\n        for i in range(niso):\n            if k1>=1:\n                if isoX[k1-1,i]!=0.0:\n                    m=old_div((isoX[k1,i]-isoX[k1-1,i]),(xm[k1]-xm[k1-1]))\n                    ybound[i] = isoX[k1-1,i] +m*(mrem-xm[k1-1])\n                else:\n                    ybound[i]=1.e-99\n            if k1==0:\n                if isoX[k1,i]!=0.0:\n                    ybound[i]=isoX[k1,i]\n                else:\n                    ybound[i]=1.e-99\n\n        # This part merges the interpolated data and the existing arrays into\n        # the arrays xarray and yarray.  Once this is done, the summation is\n        # made.\n        xarray[0] = mrem\n        xarray[1:nshells-k1+1] = xm[k1:nshells]\n        for i in range(niso):\n            yarray[0] = ybound[i]\n            for j in range(nshells-k1):\n                if isoX[k1+j,i] != 0.0:\n                    yarray[j+1] = isoX[k1+j,i]\n                else:\n                    yarray[j+1] = 1.e-99\n\n            if cylen == 1:\n                # Calculate the ejected masses\n                for j in range(nshells-k1):\n                    X_i[i] = X_i[i] + ((0.5*(yarray[j+1] + yarray[j])) * \\\n                    (xarray[j+1] - xarray[j]))\n            elif cylen == 2:\n                # Calculate the SN yield.\n                for j in range(nshells-k1):\n                    X_i[i] = X_i[i] + ((0.5*(yarray[j+1] + yarray[j]) - isoXini[-1,i]) * \\\n                    (xarray[j+1] - xarray[j]))\n\n\n        return X_i", "response": "This function calculates the presupernova yields of a full structure profile from a remnant mass and mrem."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef windyields(self, ini, end, delta, **keyw):\n\n        if (\"tmass\" in keyw) == False:\n            keyw[\"tmass\"] = \"mass\"\n        if (\"abund\" in keyw) == False:\n            keyw[\"abund\"] = \"iso_massf\"\n        if (\"cycle\" in keyw) == False:\n            keyw[\"cycle\"] = \"cycle\"\n\n        print(\"Windyields() initialised.  Reading files...\")\n\n        ypsinit = []\n        niso = 0\n        X_i = []\n        E_i = []\n        totalmass = []\n        ypssurf  = []\n        cycles = []\n        first = True\n\n        # The following statements copy global functions into local memory,\n        # which is called faster, speeding up the code slightly\n        wc = self._windcalc\n        cycleret = self.se.cycles\n        retrieve = self.se.get\n        capp = cycles.extend\n        tapp = totalmass.extend\n        yapp = ypssurf.extend\n\n        # Retrieve the data from the files\n        for i in range(ini,end+1,delta):\n            step = int(i)\n            capp([int(cycleret[i-ini])])\n            tapp([retrieve(step,keyw[\"tmass\"])])\n            yapp([retrieve(step,keyw[\"abund\"])])\n\n        print(\"Reading complete.  Calculating yields and ejected masses...\")\n\n        nsteps = len(cycles)-1\n        niso = len(ypssurf[0])\n        X_i = np.zeros([niso], float)\n        E_i = np.zeros([niso], float)\n        # Call the windyields calculator\n        X_i, E_i = wc(first, totalmass, nsteps, niso, ypssurf, \\\n        ypsinit, X_i, E_i, cycles)\n        return X_i, E_i", "response": "This function initializes the entry point for the wind yields and ejected masses."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef average_iso_abund_marco(self,mass_range,cycle,stable,i_decay):\n\n\n        import nuutils as u\n\n        if not stable and i_decay == 2:\n            print('ERROR: choose i_decay = 1')\n            return\n\n        #data=mp.se(directory,name_h5_file)\n        self._read_iso_abund_marco(mass_range,cycle)\n        #print spe\n        if i_decay == 2:\n            u.stable_specie()\n            self.decay(self.mass_frac)\n\n        # here I am calculating average mass fraction for all isotopes in given mass range, and then\n        # if needed calculating average over decayed.\n        # warning: mass_range is bigger than used_masses range, by definition. Should I use it?\n        print('average over used_masses range, not over original mass_range')\n        print(used_masses[0],used_masses[len(used_masses)-1],'instead of',mass_range[0],mass_range[1])\n\n        global average_mass_frac\n        average_mass_frac = []\n\n        if len(used_masses) >= 2:\n            dm_tot = abs(used_masses[len(used_masses)-1]-used_masses[0])\n            for j in range(len(u.spe)-1):\n                temp = 0.\n                for i in range(len(used_masses)-1):\n                    dm_i = abs(used_masses[i+1]-used_masses[i])\n                    temp = float(self.mass_frac[i][j]*dm_i/dm_tot) + temp\n                average_mass_frac.append(temp)\n            #print average_mass_frac\n        elif  len(used_masses) == 1:\n            print('case with 1 mass zone only, not implemented yet')\n\n\n\n        somma = 0.\n        somma = sum(average_mass_frac)\n        print('departure from 1 of sum of average_mass_frac=',abs(1. - somma))\n\n        # not let's do it over decayed also, if i_decay = 2\n        if i_decay == 2:\n            global average_mass_frac_decay\n            average_mass_frac_decay = []\n            dm_tot = abs(used_masses[len(used_masses)-1]-used_masses[0])\n            #\n            #print len(decayed_multi_d[0]),decayed_multi_d[0]\n            for j in range(len(u.back_ind)):\n                temp = 0.\n                for i in range(len(used_masses)-1):\n                    dm_i = abs(used_masses[i+1]-used_masses[i])\n                    temp = float(decayed_multi_d[i][j]*dm_i/dm_tot) + temp\n                average_mass_frac_decay.append(temp)\n\n            somma = 0.\n            somma = sum(average_mass_frac_decay)\n            print('departure from 1 of sum of average_mass_frac_decay=',abs(1. - somma))", "response": "Function to plot the average mass fraction of all isotopes in a given mass range."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn for one cycle an element name dictionary.", "response": "def _get_elem_names(self):\n        \"\"\" returns for one cycle an element name dictionary.\"\"\"\n\n        import nuutils as u\n\n        # provide library for Z versus element names, and Z for elements\n        #element_name = self.se.elements\n        element_name = self.elements_names\n        u.give_zip_element_z_and_names(element_name)\n        self.z_of_element_name = u.index_z_for_elements"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the decayed stable isotopes. Parameters ---------- cycle : integer The cycle.", "response": "def get_abundance_iso_decay(self,cycle):\n        \"\"\"\n        returns the decayed stable isotopes.\n\n        Parameters\n        ----------\n        cycle : integer\n            The cycle.\n\n        \"\"\"\n\n        import nuutils as u\n\n        masses_for_this_cycle = self.se.get(cycle,'mass')\n        self._read_iso_abund_marco([min(masses_for_this_cycle),max(masses_for_this_cycle)],cycle)\n\n        u.stable_specie()\n        self.decay(self.mass_frac)\n\n        self.index_for_all_species = u.cl\n        self.index_for_stable_species = u.back_ind\n\n        self.decayed_stable_isotopes_per_cycle = decayed_multi_d\n\n        # from here read solar abundances\n        solar_factor = 2.\n        u.solar('iniab1.0E-02.ppn_GN93',solar_factor)\n\n        self.stable_isotope_identifier=u.jjdum\n        self.stable_isotope_list=u.stable\n\n        self.isotopic_production_factors=[]\n        for i in range(len(masses_for_this_cycle)):\n            pf_dum=[]\n            jj=0\n            for j in range(len(self.stable_isotope_identifier)):\n                if self.stable_isotope_identifier[j] == 1:\n                    pf_dum.append(float(old_div(self.mass_frac[i][self.index_for_all_species[self.stable_isotope_list\n[jj].capitalize()]],u.solar_abundance[self.stable_isotope_list[jj].lower()])))\n                    jj=jj+1\n                #elif self.stable_isotope_identifier[j] == 0:\n                #       pf_dum.append(float(0.))\n            self.isotopic_production_factors.append(pf_dum)\n\n        self.isotopic_production_factors_decayed=[]\n        for i in range(len(masses_for_this_cycle)):\n            pf_dum_d=[]\n            jj=0\n            for j in range(len(self.stable_isotope_identifier)):\n                if self.stable_isotope_identifier[j] == 1:\n                    pf_dum_d.append(float(old_div(self.decayed_stable_isotopes_per_cycle[i][self.index_for_stable_species[self.stable_isotope_list\n[jj].upper()]],u.solar_abundance[self.stable_isotope_list[jj].lower()])))\n                    jj=jj+1\n            self.isotopic_production_factors_decayed.append(pf_dum_d)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_abundance_elem(self,cycle):\n\n        import nuutils as u\n\n        masses_for_this_cycle = self.se.get(cycle,'mass')\n        self._read_iso_abund_marco([min(masses_for_this_cycle),max(masses_for_this_cycle)],cycle)\n\n        u.stable_specie()\n        self.decay(self.mass_frac)\n\n        # provide library for Z versus element names, and Z for elements\n        element_name = self.se.elements\n        u.give_zip_element_z_and_names(element_name)\n        # from here read solar abundances\n        solar_factor = 2.\n        u.solar('iniab1.0E-02.ppn_GN93',solar_factor)\n\n        self.stable_isotope_identifier=u.jjdum\n        self.stable_isotope_list=u.stable\n\n\n        self.element_abundance_not_decayed=[]\n        self.element_abundance_decayed =[]\n        self.element_production_factors=[]\n        self.element_production_factors_decayed=[]\n        for i in range(len(masses_for_this_cycle)):\n            mass_fractions_array_decayed = decayed_multi_d[i]\n            mass_fractions_array_not_decayed = self.mass_frac[i]\n            u.element_abund_marco(2,self.stable_isotope_list,self.stable_isotope_identifier,mass_fractions_array_not_decayed,mass_fractions_array_decayed)\n            self.element_abundance_not_decayed.append(u.elem_abund)\n            self.element_abundance_decayed.append(u.elem_abund_decayed)\n            self.element_production_factors.append(u.elem_prod_fac)\n            self.element_production_factors_decayed.append(u.elem_prod_fac_decayed)", "response": "returns the undecayed element profile for the given cycle"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef maximum_size_bytes(self):\n        return utils.max_safe(\n            [device.get('CapacityBytes') for device in self.devices\n             if device.get('CapacityBytes') is not None])", "response": "Gets the biggest disk drive\n\n       ."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngenerates a shared access signature for the account service.", "response": "def generate_account_shared_access_signature(self, resource_types, permission, \n                                        expiry, start=None, ip=None, protocol=None):\n        '''\n        Generates a shared access signature for the table service.\n        Use the returned signature with the sas_token parameter of TableService.\n\n        :param ResourceTypes resource_types:\n            Specifies the resource types that are accessible with the account SAS.\n        :param AccountPermissions permission:\n            The permissions associated with the shared access signature. The \n            user is restricted to operations allowed by the permissions. \n            Required unless an id is given referencing a stored access policy \n            which contains this field. This field must be omitted if it has been \n            specified in an associated stored access policy.\n        :param expiry:\n            The time at which the shared access signature becomes invalid. \n            Required unless an id is given referencing a stored access policy \n            which contains this field. This field must be omitted if it has \n            been specified in an associated stored access policy. Azure will always \n            convert values to UTC. If a date is passed in without timezone info, it \n            is assumed to be UTC.\n        :type expiry: date or str\n        :param start:\n            The time at which the shared access signature becomes valid. If \n            omitted, start time for this call is assumed to be the time when the \n            storage service receives the request. Azure will always convert values \n            to UTC. If a date is passed in without timezone info, it is assumed to \n            be UTC.\n        :type start: date or str\n        :param str ip:\n            Specifies an IP address or a range of IP addresses from which to accept requests.\n            If the IP address from which the request originates does not match the IP address\n            or address range specified on the SAS token, the request is not authenticated.\n            For example, specifying sip=168.1.5.65 or sip=168.1.5.60-168.1.5.70 on the SAS\n            restricts the request to those IP addresses.\n        :param str protocol:\n            Specifies the protocol permitted for a request made. The default value\n            is https,http. See :class:`~azure.storage.models.Protocol` for possible values.\n        :return: A Shared Access Signature (sas) token.\n        :rtype: str\n        '''\n        _validate_not_none('self.account_name', self.account_name)\n        _validate_not_none('self.account_key', self.account_key)\n\n        sas = SharedAccessSignature(self.account_name, self.account_key)\n        return sas.generate_account(Services.TABLE, resource_types, permission, \n                                    expiry, start=start, ip=ip, protocol=protocol)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef push_power_button(self, target_value):\n        if target_value not in mappings.PUSH_POWER_BUTTON_VALUE_MAP_REV:\n            msg = ('The parameter \"%(parameter)s\" value \"%(target_value)s\" is '\n                   'invalid. Valid values are: %(valid_power_values)s' %\n                   {'parameter': 'target_value', 'target_value': target_value,\n                    'valid_power_values': (\n                        mappings.PUSH_POWER_BUTTON_VALUE_MAP_REV.keys())})\n            raise exception.InvalidInputError(msg)\n\n        value = mappings.PUSH_POWER_BUTTON_VALUE_MAP_REV[target_value]\n        target_uri = (\n            self._get_hpe_push_power_button_action_element().target_uri)\n\n        self._conn.post(target_uri, data={'PushType': value})", "response": "Reset the system in hpe exclusive manner."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef update_persistent_boot(self, devices=[], persistent=False):\n        device = PERSISTENT_BOOT_DEVICE_MAP.get(devices[0].upper())\n        if device == sushy.BOOT_SOURCE_TARGET_UEFI_TARGET:\n            try:\n                uefi_devices = self.uefi_target_override_devices\n                iscsi_device = None\n                for uefi_device in uefi_devices:\n                    if uefi_device is not None and 'iSCSI' in uefi_device:\n                        iscsi_device = uefi_device\n                        break\n\n                if iscsi_device is None:\n                    msg = 'No UEFI iSCSI bootable device found on system.'\n                    raise exception.IloError(msg)\n\n            except sushy.exceptions.SushyError as e:\n                msg = ('Unable to get uefi target override devices. '\n                       'Error %s') % (str(e))\n                raise exception.IloError(msg)\n\n            uefi_boot_settings = {\n                'Boot': {'UefiTargetBootSourceOverride': iscsi_device}\n            }\n            self._conn.patch(self.path, data=uefi_boot_settings)\n        elif device is None:\n            device = sushy.BOOT_SOURCE_TARGET_NONE\n\n        tenure = (sushy.BOOT_SOURCE_ENABLED_CONTINUOUS\n                  if persistent else sushy.BOOT_SOURCE_ENABLED_ONCE)\n        self.set_system_boot_source(device, enabled=tenure)", "response": "Updates the persistent boot mode for the given list of boot devices."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef secure_boot(self):\n        return secure_boot.SecureBoot(\n            self._conn, utils.get_subresource_path_by(self, 'SecureBoot'),\n            redfish_version=self.redfish_version)", "response": "Property to provide reference to SecureBoot instance"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a reference to the ethernet interfaces collection instance", "response": "def ethernet_interfaces(self):\n        \"\"\"Provide reference to EthernetInterfacesCollection instance\"\"\"\n        return ethernet_interface.EthernetInterfaceCollection(\n            self._conn,\n            self._get_hpe_sub_resource_collection_path('EthernetInterfaces'),\n            redfish_version=self.redfish_version)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef smart_storage(self):\n        return hpe_smart_storage.HPESmartStorage(\n            self._conn, utils.get_subresource_path_by(\n                self, ['Oem', 'Hpe', 'Links', 'SmartStorage']),\n            redfish_version=self.redfish_version)", "response": "This property gets the object for smart storage. It returns an instance of HPESmartStorage"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_smart_storage_config(self, smart_storage_config_url):\n        return (smart_storage_config.\n                HPESmartStorageConfig(self._conn, smart_storage_config_url,\n                                      redfish_version=self.redfish_version))", "response": "Returns a SmartStorageConfig Instance for each controller."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _get_smart_storage_config_by_controller_model(self, controller_model):\n        ac = self.smart_storage.array_controllers.array_controller_by_model(\n            controller_model)\n        if ac:\n            for ssc_id in self.smart_storage_config_identities:\n                ssc_obj = self.get_smart_storage_config(ssc_id)\n                if ac.location == ssc_obj.location:\n                    return ssc_obj", "response": "Returns a SmartStorageConfig Instance for the given controller model."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncheck SmartStorageConfig controllers are there in hardware.", "response": "def check_smart_storage_config_ids(self):\n        \"\"\"Check SmartStorageConfig controllers is there in hardware.\n\n        :raises: IloError, on an error from iLO.\n        \"\"\"\n        if self.smart_storage_config_identities is None:\n            msg = ('The Redfish controller failed to get the '\n                   'SmartStorageConfig controller configurations.')\n            LOG.debug(msg)\n            raise exception.IloError(msg)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef delete_raid(self):\n        self.check_smart_storage_config_ids()\n        any_exceptions = []\n        ld_exc_count = 0\n        for config_id in self.smart_storage_config_identities:\n            try:\n                ssc_obj = self.get_smart_storage_config(config_id)\n                ssc_obj.delete_raid()\n            except exception.IloLogicalDriveNotFoundError as e:\n                ld_exc_count += 1\n            except sushy.exceptions.SushyError as e:\n                any_exceptions.append((config_id, str(e)))\n\n        if any_exceptions:\n            msg = ('The Redfish controller failed to delete the '\n                   'raid configuration in one or more controllers with '\n                   'Error: %(error)s' % {'error': str(any_exceptions)})\n            raise exception.IloError(msg)\n\n        if ld_exc_count == len(self.smart_storage_config_identities):\n            msg = ('No logical drives are found in any controllers. Nothing '\n                   'to delete.')\n            raise exception.IloLogicalDriveNotFoundError(msg)", "response": "Delete the raid configuration on the hardware."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _parse_raid_config_data(self, raid_config):\n        default = (\n            self.smart_storage.array_controllers.get_default_controller.model)\n        controllers = {default: []}\n        for ld in raid_config['logical_disks']:\n            if 'controller' not in ld.keys():\n                controllers[default].append(ld)\n            else:\n                ctrl = ld['controller']\n                if ctrl not in controllers:\n                    controllers[ctrl] = []\n                controllers[ctrl].append(ld)\n        return controllers", "response": "This function will parse the raid config data based on the raid controllers and logical drives."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating the raid configuration on the hardware.", "response": "def create_raid(self, raid_config):\n        \"\"\"Create the raid configuration on the hardware.\n\n        :param raid_config: A dictionary containing target raid configuration\n                            data. This data stucture should be as follows:\n                            raid_config = {'logical_disks': [{'raid_level': 1,\n                            'size_gb': 100, 'physical_disks': ['6I:1:5'],\n                            'controller': 'HPE Smart Array P408i-a SR Gen10'},\n                            <info-for-logical-disk-2>]}\n        :raises: IloError, on an error from iLO.\n        \"\"\"\n        self.check_smart_storage_config_ids()\n        any_exceptions = []\n        controllers = self._parse_raid_config_data(raid_config)\n        # Creating raid on rest of the controllers\n        for controller in controllers:\n            try:\n                config = {'logical_disks': controllers[controller]}\n                ssc_obj = (\n                    self._get_smart_storage_config_by_controller_model(\n                        controller))\n                if ssc_obj:\n                    ssc_obj.create_raid(config)\n                else:\n                    members = (\n                        self.smart_storage.array_controllers.get_members())\n                    models = [member.model for member in members]\n                    msg = ('Controller not found. Available controllers are: '\n                           '%(models)s' % {'models': models})\n                    any_exceptions.append((controller, msg))\n            except sushy.exceptions.SushyError as e:\n                any_exceptions.append((controller, str(e)))\n\n        if any_exceptions:\n            msg = ('The Redfish controller failed to create the '\n                   'raid configuration for one or more controllers with '\n                   'Error: %(error)s' % {'error': str(any_exceptions)})\n            raise exception.IloError(msg)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreads the logical drives from the system after a create raid.", "response": "def _post_create_read_raid(self, raid_config):\n        \"\"\"Read the logical drives from the system after post-create raid\n\n        :param raid_config: A dictionary containing target raid configuration\n                            data. This data stucture should be as follows:\n                            raid_config = {'logical_disks': [{'raid_level': 1,\n                            'size_gb': 100, 'physical_disks': ['6I:1:5'],\n                            'controller': 'HPE Smart Array P408i-a SR Gen10'},\n                            <info-for-logical-disk-2>]}\n        :raises: IloLogicalDriveNotFoundError, if no controllers are configured\n        :raises: IloError, if any error form iLO\n        :returns: A dictionary containing list of logical disks\n        \"\"\"\n        controllers = self._parse_raid_config_data(raid_config)\n        ld_exc_count = 0\n        any_exceptions = []\n        config = {'logical_disks': []}\n        for controller in controllers:\n            try:\n                ssc_obj = (\n                    self._get_smart_storage_config_by_controller_model(\n                        controller))\n                if ssc_obj:\n                    result = ssc_obj.read_raid(controller=controller)\n                    config['logical_disks'].extend(result['logical_disks'])\n            except exception.IloLogicalDriveNotFoundError as e:\n                ld_exc_count += 1\n            except sushy.exceptions.SushyError as e:\n                any_exceptions.append((controller, str(e)))\n\n        if ld_exc_count == len(controllers):\n            msg = 'No logical drives are found in any controllers.'\n            raise exception.IloLogicalDriveNotFoundError(msg)\n        if any_exceptions:\n            msg = ('The Redfish controller failed to read the '\n                   'raid configuration in one or more controllers with '\n                   'Error: %(error)s' % {'error': str(any_exceptions)})\n            raise exception.IloError(msg)\n        return config"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreads the logical drives from the system after the delete.", "response": "def _post_delete_read_raid(self):\n        \"\"\"Read the logical drives from the system after post-delete raid\n\n        :raises: IloError, if any error form iLO\n        :returns: Empty dictionary with format: {'logical_disks': []}\n        \"\"\"\n        any_exceptions = []\n        ssc_ids = self.smart_storage_config_identities\n        config = {'logical_disks': []}\n        for ssc_id in ssc_ids:\n            try:\n                ssc_obj = self.get_smart_storage_config(ssc_id)\n                ac_obj = (\n                    self.smart_storage.array_controllers.\n                    array_controller_by_location(ssc_obj.location))\n                if ac_obj:\n                    model = ac_obj.model\n                    result = ssc_obj.read_raid()\n                    if result:\n                        config['logical_disks'].extend(result['logical_disks'])\n            except sushy.exceptions.SushyError as e:\n                any_exceptions.append((model, str(e)))\n\n        if any_exceptions:\n            msg = ('The Redfish controller failed to read the '\n                   'raid configuration in one or more controllers with '\n                   'Error: %(error)s' % {'error': str(any_exceptions)})\n            raise exception.IloError(msg)\n        return config"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreading the logical drives from the system.", "response": "def read_raid(self, raid_config=None):\n        \"\"\"Read the logical drives from the system\n\n        :param raid_config: None or a dictionary containing target raid\n                            configuration data. This data stucture should be as\n                            follows:\n                            raid_config = {'logical_disks': [{'raid_level': 1,\n                            'size_gb': 100, 'physical_disks': ['6I:1:5'],\n                            'controller': 'HPE Smart Array P408i-a SR Gen10'},\n                            <info-for-logical-disk-2>]}\n        :returns: A dictionary containing list of logical disks\n        \"\"\"\n        self.check_smart_storage_config_ids()\n        if raid_config:\n            # When read called after create raid, user can pass raid config\n            # as a input\n            result = self._post_create_read_raid(raid_config=raid_config)\n        else:\n            # When read called after delete raid, there will be no input\n            # passed by user then\n            result = self._post_delete_read_raid()\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nperform the request and return response. Catches HTTPError and hands itto error handler.", "response": "def _perform_request(self, request, parser=None, parser_args=None, operation_context=None):\n        '''\n        Sends the request and return response. Catches HTTPError and hands it\n        to error handler\n        '''\n        operation_context = operation_context or _OperationContext()\n        retry_context = RetryContext()\n\n        # Apply the appropriate host based on the location mode\n        self._apply_host(request, operation_context, retry_context)\n\n        # Apply common settings to the request\n        _update_request(request)\n\n        while(True):\n            try:\n                try:\n                    # Execute the request callback \n                    if self.request_callback:\n                        self.request_callback(request)\n\n                    # Add date and auth after the callback so date doesn't get too old and \n                    # authentication is still correct if signed headers are added in the request \n                    # callback. This also ensures retry policies with long back offs \n                    # will work as it resets the time sensitive headers.\n                    _add_date_header(request)\n                    self.authentication.sign_request(request)\n\n                    # Set the request context\n                    retry_context.request = request\n\n                    # Perform the request\n                    response = self._httpclient.perform_request(request)\n\n                    # Execute the response callback\n                    if self.response_callback:\n                        self.response_callback(response)\n\n                    # Set the response context\n                    retry_context.response = response\n\n                    # Parse and wrap HTTP errors in AzureHttpError which inherits from AzureException\n                    if response.status >= 300:\n                        # This exception will be caught by the general error handler\n                        # and raised as an azure http exception\n                        _http_error_handler(HTTPError(response.status, response.message, response.headers, response.body))\n\n                    # Parse the response\n                    if parser:\n                        if parser_args:\n                            args = [response]\n                            args.extend(parser_args)\n                            return parser(*args)\n                        else:\n                            return parser(response)\n                    else:\n                        return\n                except AzureException as ex:\n                    raise ex\n                except Exception as ex:\n                    if sys.version_info >= (3,):\n                        # Automatic chaining in Python 3 means we keep the trace\n                        raise AzureException(ex.args[0])\n                    else:\n                        # There isn't a good solution in 2 for keeping the stack trace \n                        # in general, or that will not result in an error in 3\n                        # However, we can keep the previous error type and message\n                        # TODO: In the future we will log the trace\n                        msg = \"\"\n                        if len(ex.args) > 0:\n                            msg = ex.args[0]\n                        raise AzureException('{}: {}'.format(ex.__class__.__name__, msg))\n\n\n            except AzureException as ex:\n                # Decryption failures (invalid objects, invalid algorithms, data unencrypted in strict mode, etc)\n                # will not be resolved with retries.\n                if str(ex) == _ERROR_DECRYPTION_FAILURE:\n                    raise ex\n                # Determine whether a retry should be performed and if so, how \n                # long to wait before performing retry.\n                retry_interval = self.retry(retry_context)\n                if retry_interval is not None:\n                    # Execute the callback\n                    if self.retry_callback:\n                        self.retry_callback(retry_context)\n\n                    # Sleep for the desired retry interval\n                    sleep(retry_interval)\n                else:\n                    raise ex\n            finally:\n                # If this is a location locked operation and the location is not set, \n                # this is the first request of that operation. Set the location to \n                # be used for subsequent requests in the operation.\n                if operation_context.location_lock and not operation_context.host_location:\n                    operation_context.host_location = {retry_context.location_mode: request.host}"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _convert_json_to_entity(entry_element, property_resolver):\n    ''' Convert json response to entity.\n\n    The entity format is:\n    {\n       \"Address\":\"Mountain View\",\n       \"Age\":23,\n       \"AmountDue\":200.23,\n       \"CustomerCode@odata.type\":\"Edm.Guid\",\n       \"CustomerCode\":\"c9da6455-213d-42c9-9a79-3e9149a57833\",\n       \"CustomerSince@odata.type\":\"Edm.DateTime\",\n       \"CustomerSince\":\"2008-07-10T00:00:00\",\n       \"IsActive\":true,\n       \"NumberOfOrders@odata.type\":\"Edm.Int64\",\n       \"NumberOfOrders\":\"255\",\n       \"PartitionKey\":\"mypartitionkey\",\n       \"RowKey\":\"myrowkey\"\n    }\n    '''\n    entity = Entity()\n\n    properties = {}\n    edmtypes = {}\n    odata = {}\n\n    for name, value in entry_element.items():\n        if name.startswith('odata.'):\n            odata[name[6:]] = value\n        elif name.endswith('@odata.type'):\n            edmtypes[name[:-11]] = value\n        else:\n            properties[name] = value\n\n    # Partition key is a known property\n    partition_key = properties.pop('PartitionKey', None)\n    if partition_key:\n        entity['PartitionKey'] = partition_key\n\n    # Row key is a known property\n    row_key = properties.pop('RowKey', None)\n    if row_key:\n        entity['RowKey'] = row_key\n\n    # Timestamp is a known property\n    timestamp = properties.pop('Timestamp', None)\n    if timestamp:\n        entity['Timestamp'] = _from_entity_datetime(timestamp)\n        \n    for name, value in properties.items():\n        mtype = edmtypes.get(name);\n\n        # use the property resolver if present\n        if property_resolver:\n            mtype = property_resolver(partition_key, row_key, \n                                      name, value, mtype)\n\n            # throw if the type returned is not a valid edm type\n            if mtype and mtype not in _EDM_TYPES:\n                raise AzureException(_ERROR_TYPE_NOT_SUPPORTED.format(mtype))\n\n        # Add type for Int32\n        if type(value) is int:\n            mtype = EdmType.INT32\n\n        # no type info, property should parse automatically\n        if not mtype: \n            entity[name] = value\n        else:  # need an object to hold the property\n            conv = _ENTITY_TO_PYTHON_CONVERSIONS.get(mtype)\n            if conv is not None:\n                try:\n                    property = conv(value)\n                except Exception as e:\n                    # throw if the type returned by the property resolver\n                    # cannot be used in the conversion\n                    if property_resolver:\n                        raise AzureException(\n                            _ERROR_INVALID_PROPERTY_RESOLVER.format(name, value, mtype))\n                    else:\n                        raise e\n            else:\n                property = EntityProperty(mtype, value)\n            entity[name] = property\n\n    # extract etag from entry\n    etag = odata.get('etag')\n    if timestamp:\n         etag = 'W/\"datetime\\'' + url_quote(timestamp) + '\\'\"'\n    entity['etag'] = etag\n\n    return entity", "response": "Convert json response to entity."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nconvert the response from a JSON response to a list of tables class.", "response": "def _convert_json_response_to_tables(response):\n    ''' Converts the response to tables class.\n    '''\n    if response is None:\n        return response\n\n    tables = _list()\n\n    continuation = _get_continuation_from_response_headers(response)\n    tables.next_marker = continuation.get('NextTableName')\n\n    root = loads(response.body.decode('utf-8'))\n\n    if 'TableName' in root:\n        table = Table()\n        table.name = root['TableName']\n        tables.append(table)\n    else:\n        for element in root['value']:\n            table = Table()\n            table.name = element['TableName']\n            tables.append(table)\n\n    return tables"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _convert_json_response_to_entities(response, property_resolver):\n    ''' Converts the response to tables class.\n    '''\n    if response is None:\n        return response\n\n    entities = _list()\n\n    entities.next_marker = _get_continuation_from_response_headers(response)\n\n    root = loads(response.body.decode('utf-8'))\n\n    if 'value' in root:\n        for entity in root['value']:\n            entities.append(_convert_json_to_entity(entity, \n                                                 property_resolver))\n    else:\n        entities.append(_convert_json_to_entity(entity, \n                                             property_resolver))\n\n    return entities", "response": "Converts the response to tables class."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nextract the etag from the response headers.", "response": "def _extract_etag(response):\n    ''' Extracts the etag from the response headers. '''\n    if response and response.headers:\n        for name, value in response.headers:\n            if name.lower() == 'etag':\n                return value\n\n    return None"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef generate_table(self, table_name, permission=None, \n                        expiry=None, start=None, id=None,\n                        ip=None, protocol=None,\n                        start_pk=None, start_rk=None, \n                        end_pk=None, end_rk=None):\n        '''\n        Generates a shared access signature for the table.\n        Use the returned signature with the sas_token parameter of TableService.\n\n        :param str table_name:\n            Name of table.\n        :param TablePermissions permission:\n            The permissions associated with the shared access signature. The \n            user is restricted to operations allowed by the permissions. \n            Required unless an id is given referencing a stored access policy \n            which contains this field. This field must be omitted if it has been \n            specified in an associated stored access policy.\n        :param expiry:\n            The time at which the shared access signature becomes invalid. \n            Required unless an id is given referencing a stored access policy \n            which contains this field. This field must be omitted if it has \n            been specified in an associated stored access policy. Azure will always \n            convert values to UTC. If a date is passed in without timezone info, it \n            is assumed to be UTC.\n        :type expiry: date or str\n        :param start:\n            The time at which the shared access signature becomes valid. If \n            omitted, start time for this call is assumed to be the time when the \n            storage service receives the request. Azure will always convert values \n            to UTC. If a date is passed in without timezone info, it is assumed to \n            be UTC.\n        :type start: date or str\n        :param str id:\n            A unique value up to 64 characters in length that correlates to a \n            stored access policy. To create a stored access policy, use \n            set_blob_service_properties.\n        :param str ip:\n            Specifies an IP address or a range of IP addresses from which to accept requests.\n            If the IP address from which the request originates does not match the IP address\n            or address range specified on the SAS token, the request is not authenticated.\n            For example, specifying sip=168.1.5.65 or sip=168.1.5.60-168.1.5.70 on the SAS\n            restricts the request to those IP addresses.\n        :param str protocol:\n            Specifies the protocol permitted for a request made. The default value\n            is https,http. See :class:`~azure.storage.models.Protocol` for possible values.\n        :param str start_pk:\n            The minimum partition key accessible with this shared access \n            signature. startpk must accompany startrk. Key values are inclusive. \n            If omitted, there is no lower bound on the table entities that can \n            be accessed.\n        :param str start_rk:\n            The minimum row key accessible with this shared access signature. \n            startpk must accompany startrk. Key values are inclusive. If \n            omitted, there is no lower bound on the table entities that can be \n            accessed.\n        :param str end_pk:\n            The maximum partition key accessible with this shared access \n            signature. endpk must accompany endrk. Key values are inclusive. If \n            omitted, there is no upper bound on the table entities that can be \n            accessed.\n        :param str end_rk:\n            The maximum row key accessible with this shared access signature. \n            endpk must accompany endrk. Key values are inclusive. If omitted, \n            there is no upper bound on the table entities that can be accessed.\n        '''\n        sas = _SharedAccessHelper()\n        sas.add_base(permission, expiry, start, ip, protocol)\n        sas.add_id(id)\n        sas.add_table_access_ranges(table_name, start_pk, start_rk, end_pk, end_rk)\n        sas.add_resource_signature(self.account_name, self.account_key, 'table', table_name)\n\n        return sas.get_token()", "response": "Generates a shared access signature for a table."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ngenerate a shared access signature for a blob.", "response": "def generate_blob(self, container_name, blob_name, permission=None, \n                        expiry=None, start=None, id=None, ip=None, protocol=None,\n                        cache_control=None, content_disposition=None,\n                        content_encoding=None, content_language=None,\n                        content_type=None):\n        '''\n        Generates a shared access signature for the blob.\n        Use the returned signature with the sas_token parameter of any BlobService.\n\n        :param str container_name:\n            Name of container.\n        :param str blob_name:\n            Name of blob.\n        :param BlobPermissions permission:\n            The permissions associated with the shared access signature. The \n            user is restricted to operations allowed by the permissions.\n            Permissions must be ordered read, write, delete, list.\n            Required unless an id is given referencing a stored access policy \n            which contains this field. This field must be omitted if it has been \n            specified in an associated stored access policy.\n        :param expiry:\n            The time at which the shared access signature becomes invalid. \n            Required unless an id is given referencing a stored access policy \n            which contains this field. This field must be omitted if it has \n            been specified in an associated stored access policy. Azure will always \n            convert values to UTC. If a date is passed in without timezone info, it \n            is assumed to be UTC.\n        :type expiry: date or str\n        :param start:\n            The time at which the shared access signature becomes valid. If \n            omitted, start time for this call is assumed to be the time when the \n            storage service receives the request. Azure will always convert values \n            to UTC. If a date is passed in without timezone info, it is assumed to \n            be UTC.\n        :type start: date or str\n        :param str id:\n            A unique value up to 64 characters in length that correlates to a \n            stored access policy. To create a stored access policy, use \n            set_blob_service_properties.\n        :param str ip:\n            Specifies an IP address or a range of IP addresses from which to accept requests.\n            If the IP address from which the request originates does not match the IP address\n            or address range specified on the SAS token, the request is not authenticated.\n            For example, specifying sip=168.1.5.65 or sip=168.1.5.60-168.1.5.70 on the SAS\n            restricts the request to those IP addresses.\n        :param str protocol:\n            Specifies the protocol permitted for a request made. The default value\n            is https,http. See :class:`~azure.storage.models.Protocol` for possible values.\n        :param str cache_control:\n            Response header value for Cache-Control when resource is accessed\n            using this shared access signature.\n        :param str content_disposition:\n            Response header value for Content-Disposition when resource is accessed\n            using this shared access signature.\n        :param str content_encoding:\n            Response header value for Content-Encoding when resource is accessed\n            using this shared access signature.\n        :param str content_language:\n            Response header value for Content-Language when resource is accessed\n            using this shared access signature.\n        :param str content_type:\n            Response header value for Content-Type when resource is accessed\n            using this shared access signature.\n        '''\n        resource_path = container_name + '/' + blob_name\n\n        sas = _SharedAccessHelper()\n        sas.add_base(permission, expiry, start, ip, protocol)\n        sas.add_id(id)\n        sas.add_resource('b')\n        sas.add_override_response_headers(cache_control, content_disposition, \n                                          content_encoding, content_language, \n                                          content_type)\n        sas.add_resource_signature(self.account_name, self.account_key, 'blob', resource_path)\n\n        return sas.get_token()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a generator to list the tables in the account.", "response": "def list_tables(self, num_results=None, marker=None, timeout=None):\n        '''\n        Returns a generator to list the tables. The generator will lazily follow \n        the continuation tokens returned by the service and stop when all tables \n        have been returned or num_results is reached.\n\n        If num_results is specified and the account has more than that number of \n        tables, the generator will have a populated next_marker field once it \n        finishes. This marker can be used to create a new generator if more \n        results are desired.\n\n        :param int num_results:\n            The maximum number of tables to return.\n        :param marker:\n            An opaque continuation object. This value can be retrieved from the \n            next_marker field of a previous generator object if num_results was \n            specified and that generator has finished enumerating results. If \n            specified, this generator will begin returning results from the point \n            where the previous generator stopped.\n        :type marker: obj\n        :param int timeout:\n            The server timeout, expressed in seconds. This function may make multiple \n            calls to the service in which case the timeout value specified will be \n            applied to each individual call.\n        :return: A generator which produces :class:`~azure.storage.models.table.Table` objects.\n        :rtype: :class:`~azure.storage.models.ListGenerator`:\n        '''\n        kwargs = {'max_results': num_results, 'marker': marker, 'timeout': timeout}\n        resp = self._list_tables(**kwargs)\n\n        return ListGenerator(resp, self._list_tables, (), kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _list_tables(self, max_results=None, marker=None, timeout=None):\n        '''\n        Returns a list of tables under the specified account. Makes a single list \n        request to the service. Used internally by the list_tables method.\n\n        :param int max_results:\n            The maximum number of tables to return. A single list request may \n            return up to 1000 tables and potentially a continuation token which \n            should be followed to get additional resutls.\n        :param marker:\n            A dictionary which identifies the portion of the query to be\n            returned with the next query operation. The operation returns a\n            next_marker element within the response body if the list returned\n            was not complete. This value may then be used as a query parameter\n            in a subsequent call to request the next portion of the list of\n            queues. The marker value is opaque to the client.\n        :type marker: obj\n        :param int timeout:\n            The server timeout, expressed in seconds.\n        :return: A list of tables, potentially with a next_marker property.\n        :rtype: list of :class:`~azure.storage.models.table.Table`:  \n        '''\n        request = HTTPRequest()\n        request.method = 'GET'\n        request.host = self._get_host()\n        request.path = '/Tables'\n        request.headers = [('Accept', TablePayloadFormat.JSON_NO_METADATA)]\n        request.query = [\n            ('$top', _int_to_str(max_results)),\n            ('NextTableName', _to_str(marker)),\n            ('timeout', _int_to_str(timeout)),\n        ]\n\n        response = self._perform_request(request)\n        return _convert_json_response_to_tables(response)", "response": "Returns a list of tables under the specified account."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef create_table(self, table_name, fail_on_exist=False, timeout=None):\n        '''\n        Creates a new table in the storage account.\n\n        :param str table_name:\n            The name of the table to create. The table name may contain only\n            alphanumeric characters and cannot begin with a numeric character.\n            It is case-insensitive and must be from 3 to 63 characters long.\n        :param bool fail_on_exist:\n            Specifies whether to throw an exception if the table already exists.\n        :param int timeout:\n            The server timeout, expressed in seconds.\n        :return:\n            A boolean indicating whether the table was created. If fail_on_exist \n            was set to True, this will throw instead of returning false.\n        :rtype: bool\n        '''\n        _validate_not_none('table', table_name)\n        request = HTTPRequest()\n        request.method = 'POST'\n        request.host = self._get_host()\n        request.path = '/Tables'\n        request.query = [('timeout', _int_to_str(timeout))]\n        request.headers = [_DEFAULT_CONTENT_TYPE_HEADER,\n                           _DEFAULT_PREFER_HEADER,\n                           _DEFAULT_ACCEPT_HEADER]\n        request.body = _get_request_body(_convert_table_to_json(table_name))\n\n        if not fail_on_exist:\n            try:\n                self._perform_request(request)\n                return True\n            except AzureHttpError as ex:\n                _dont_fail_on_exist(ex)\n                return False\n        else:\n            self._perform_request(request)\n            return True", "response": "Creates a new table in the storage account."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef exists(self, table_name, timeout=None):\n        '''\n        Returns a boolean indicating whether the table exists.\n\n        :param str table_name:\n            The name of table to check for existence.\n        :param int timeout:\n            The server timeout, expressed in seconds.\n        :return: A boolean indicating whether the table exists.\n        :rtype: bool\n        '''\n        _validate_not_none('table_name', table_name)\n        request = HTTPRequest()\n        request.method = 'GET'\n        request.host = self._get_host()\n        request.path = '/Tables' + \"('\" + table_name + \"')\"\n        request.headers = [('Accept', TablePayloadFormat.JSON_NO_METADATA)]\n        request.query = [('timeout', _int_to_str(timeout))]\n\n        try:\n            self._perform_request(request)\n            return True\n        except AzureHttpError as ex:\n            _dont_fail_not_exist(ex)\n            return False", "response": "Returns a boolean indicating whether the table exists."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn details about any stored access policies associated with a table.", "response": "def get_table_acl(self, table_name, timeout=None):\n        '''\n        Returns details about any stored access policies specified on the\n        table that may be used with Shared Access Signatures.\n\n        :param str table_name:\n            The name of an existing table.\n        :param int timeout:\n            The server timeout, expressed in seconds.\n        :return: A dictionary of access policies associated with the table.\n        :rtype: dict of str to :class:`~azure.storage.models.AccessPolicy`:\n        '''\n        _validate_not_none('table_name', table_name)\n        request = HTTPRequest()\n        request.method = 'GET'\n        request.host = self._get_host()\n        request.path = '/' + _to_str(table_name)\n        request.query = [\n            ('comp', 'acl'),\n            ('timeout', _int_to_str(timeout)),\n        ]\n\n        response = self._perform_request(request)\n        return _convert_xml_to_signed_identifiers(response.body)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set_table_acl(self, table_name, signed_identifiers=None, timeout=None):\n        '''\n        Sets stored access policies for the table that may be used with Shared \n        Access Signatures. \n        \n        When you set permissions for a table, the existing permissions are replaced. \n        To update the table\u2019s permissions, call :func:`~get_table_acl` to fetch \n        all access policies associated with the table, modify the access policy \n        that you wish to change, and then call this function with the complete \n        set of data to perform the update.\n\n        When you establish a stored access policy on a table, it may take up to \n        30 seconds to take effect. During this interval, a shared access signature \n        that is associated with the stored access policy will throw an \n        :class:`AzureHttpError` until the access policy becomes active.\n\n        :param str table_name:\n            The name of an existing table.\n        :param signed_identifiers:\n            A dictionary of access policies to associate with the table. The \n            dictionary may contain up to 5 elements. An empty dictionary \n            will clear the access policies set on the service. \n        :type signed_identifiers: dict of str to :class:`~azure.storage.models.AccessPolicy`\n        :param int timeout:\n            The server timeout, expressed in seconds.\n        '''\n        _validate_not_none('table_name', table_name)\n        request = HTTPRequest()\n        request.method = 'PUT'\n        request.host = self._get_host()\n        request.path = '/' + _to_str(table_name)\n        request.query = [\n            ('comp', 'acl'),\n            ('timeout', _int_to_str(timeout)),\n        ]\n        request.body = _get_request_body(\n            _convert_signed_identifiers_to_xml(signed_identifiers))\n\n        self._perform_request(request)", "response": "Sets the permissions for a table."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef query_entities(self, table_name, filter=None, select=None, num_results=None,\n                       marker=None, accept=TablePayloadFormat.JSON_MINIMAL_METADATA,\n                       property_resolver=None, timeout=None):\n        '''\n        Returns a generator to list the entities in the table specified. The \n        generator will lazily follow the continuation tokens returned by the \n        service and stop when all entities have been returned or max_results is \n        reached.\n\n        If max_results is specified and the account has more than that number of \n        entities, the generator will have a populated next_marker field once it \n        finishes. This marker can be used to create a new generator if more \n        results are desired.\n\n        :param str table_name:\n            The name of the table to query.\n        :param str filter:\n            Returns only entities that satisfy the specified filter. Note that \n            no more than 15 discrete comparisons are permitted within a $filter \n            string. See http://msdn.microsoft.com/en-us/library/windowsazure/dd894031.aspx \n            for more information on constructing filters.\n        :param str select:\n            Returns only the desired properties of an entity from the set.\n        :param int num_results:\n            The maximum number of entities to return.\n        :param marker:\n            An opaque continuation object. This value can be retrieved from the \n            next_marker field of a previous generator object if max_results was \n            specified and that generator has finished enumerating results. If \n            specified, this generator will begin returning results from the point \n            where the previous generator stopped.\n        :type marker: obj\n        :param str accept:\n            Specifies the accepted content type of the response payload. See \n            :class:`~azure.storage.table.models.TablePayloadFormat` for possible \n            values.\n        :param property_resolver:\n            A function which given the partition key, row key, property name, \n            property value, and the property EdmType if returned by the service, \n            returns the EdmType of the property. Generally used if accept is set \n            to JSON_NO_METADATA.\n        :type property_resolver: callback function in format of func(pk, rk, prop_name, prop_value, service_edm_type)\n        :param int timeout:\n            The server timeout, expressed in seconds. This function may make multiple \n            calls to the service in which case the timeout value specified will be \n            applied to each individual call.\n        :return: A generator which produces :class:`~azure.storage.table.models.Entity` objects.\n        :rtype: :class:`~azure.storage.models.ListGenerator`\n        '''\n        args = (table_name,)\n        kwargs = {'filter': filter, 'select': select, 'max_results': num_results, 'marker': marker, \n                  'accept': accept, 'property_resolver': property_resolver, 'timeout': timeout}\n        resp = self._query_entities(*args, **kwargs)\n\n        return ListGenerator(resp, self._query_entities, args, kwargs)", "response": "Returns a generator to list the entities in the specified table."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _query_entities(self, table_name, filter=None, select=None, max_results=None,\n                       marker=None, accept=TablePayloadFormat.JSON_MINIMAL_METADATA,\n                       property_resolver=None, timeout=None):\n        '''\n        Returns a list of entities under the specified table. Makes a single list \n        request to the service. Used internally by the query_entities method.\n\n        :param str table_name:\n            The name of the table to query.\n        :param str filter:\n            Returns only entities that satisfy the specified filter. Note that \n            no more than 15 discrete comparisons are permitted within a $filter \n            string. See http://msdn.microsoft.com/en-us/library/windowsazure/dd894031.aspx \n            for more information on constructing filters.\n        :param str select:\n            Returns only the desired properties of an entity from the set.\n        :param int top:\n            The maximum number of entities to return.\n        :param marker:\n            A dictionary which identifies the portion of the query to be\n            returned with the next query operation. The operation returns a\n            next_marker element within the response body if the list returned\n            was not complete. This value may then be used as a query parameter\n            in a subsequent call to request the next portion of the list of\n            queues. The marker value is opaque to the client.\n        :type marker: obj\n        :param str accept:\n            Specifies the accepted content type of the response payload. See \n            :class:`~azure.storage.table.models.TablePayloadFormat` for possible \n            values.\n        :param property_resolver:\n            A function which given the partition key, row key, property name, \n            property value, and the property EdmType if returned by the service, \n            returns the EdmType of the property. Generally used if accept is set \n            to JSON_NO_METADATA.\n        :type property_resolver: callback function in format of func(pk, rk, prop_name, prop_value, service_edm_type)\n        :param int timeout:\n            The server timeout, expressed in seconds.\n        :return: A list of entities, potentially with a next_marker property.\n        :rtype: list of :class:`~azure.storage.table.models.Entity`\n        '''\n        _validate_not_none('table_name', table_name)\n        _validate_not_none('accept', accept)\n        next_partition_key = None if marker is None else marker.get('nextpartitionkey')\n        next_row_key = None if marker is None else marker.get('nextrowkey')\n\n        request = HTTPRequest()\n        request.method = 'GET'\n        request.host = self._get_host()\n        request.path = '/' + _to_str(table_name) + '()'\n        request.headers = [('Accept', _to_str(accept))]\n        request.query = [\n            ('$filter', _to_str(filter)),\n            ('$select', _to_str(select)),\n            ('$top', _int_to_str(max_results)),\n            ('NextPartitionKey', _to_str(next_partition_key)),\n            ('NextRowKey', _to_str(next_row_key)),\n            ('timeout', _int_to_str(timeout)),\n        ]\n\n        response = self._perform_request(request)\n        return _convert_json_response_to_entities(response, property_resolver)", "response": "Query the table for the specified entity."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef commit_batch(self, table_name, batch, timeout=None):\n        '''\n        Commits a :class:`~azure.storage.table.TableBatch` request.\n\n        :param str table_name:\n            The name of the table to commit the batch to.\n        :param TableBatch batch:\n            The batch to commit.\n        :param int timeout:\n            The server timeout, expressed in seconds.\n        :return: A list of the batch responses corresponding to the requests in the batch.\n        :rtype: list of response objects\n        '''\n        _validate_not_none('table_name', table_name)\n\n        # Construct the batch request\n        request = HTTPRequest()\n        request.method = 'POST'\n        request.host = self._get_host()\n        request.path = '/' + '$batch'\n        request.query = [('timeout', _int_to_str(timeout))]\n\n        # Update the batch operation requests with table and client specific info\n        for row_key, batch_request in batch._requests:\n            batch_request.host = self._get_host()\n            if batch_request.method == 'POST':\n                batch_request.path = '/' + _to_str(table_name)\n            else:\n                batch_request.path = _get_entity_path(table_name, batch._partition_key, row_key)\n            _update_request(batch_request)\n\n        # Construct the batch body\n        request.body, boundary = _convert_batch_to_json(batch._requests)\n        request.headers = [('Content-Type', boundary)]\n\n        # Perform the batch request and return the response\n        response = self._perform_request(request)\n        responses = _parse_batch_response(response.body)\n        return responses", "response": "Commits a batch operation."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating a batch object which can be used as a context manager. Commits the batch on exit. :param str table_name: The name of the table to commit the batch to. :param int timeout: The server timeout, expressed in seconds.", "response": "def batch(self, table_name, timeout=None):\n        '''\n        Creates a batch object which can be used as a context manager. Commits the batch on exit.\n\n        :param str table_name:\n            The name of the table to commit the batch to.\n        :param int timeout:\n            The server timeout, expressed in seconds.\n        '''\n        batch = TableBatch()\n        yield batch\n        self.commit_batch(table_name, batch, timeout=timeout)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets an entity from the specified table.", "response": "def get_entity(self, table_name, partition_key, row_key, select=None,\n                   accept=TablePayloadFormat.JSON_MINIMAL_METADATA,\n                   property_resolver=None, timeout=None):\n        '''\n        Get an entity from the specified table. Throws if the entity does not exist.\n\n        :param str table_name:\n            The name of the table to get the entity from.\n        :param str partition_key:\n            The PartitionKey of the entity.\n        :param str row_key:\n            The RowKey of the entity.\n        :param str select:\n            Returns only the desired properties of an entity from the set.\n        :param str accept:\n            Specifies the accepted content type of the response payload. See \n            :class:`~azure.storage.table.models.TablePayloadFormat` for possible \n            values.\n        :param property_resolver:\n            A function which given the partition key, row key, property name, \n            property value, and the property EdmType if returned by the service, \n            returns the EdmType of the property. Generally used if accept is set \n            to JSON_NO_METADATA.\n        :type property_resolver: callback function in format of func(pk, rk, prop_name, prop_value, service_edm_type)\n        :param int timeout:\n            The server timeout, expressed in seconds.\n        :return: The retrieved entity.\n        :rtype: :class:`~azure.storage.table.models.Entity`\n        '''\n        _validate_not_none('table_name', table_name)\n        request = _get_entity(partition_key, row_key, select, accept)\n        request.host = self._get_host()\n        request.path = _get_entity_path(table_name, partition_key, row_key)\n        request.query += [('timeout', _int_to_str(timeout))]\n\n        response = self._perform_request(request)\n        return _convert_json_response_to_entity(response, property_resolver)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ninserts a new entity into the specified table.", "response": "def insert_entity(self, table_name, entity, timeout=None):\n        '''\n        Inserts a new entity into the table. Throws if an entity with the same \n        PartitionKey and RowKey already exists.\n\n        When inserting an entity into a table, you must specify values for the \n        PartitionKey and RowKey system properties. Together, these properties \n        form the primary key and must be unique within the table. Both the \n        PartitionKey and RowKey values must be string values; each key value may \n        be up to 64 KB in size. If you are using an integer value for the key \n        value, you should convert the integer to a fixed-width string, because \n        they are canonically sorted. For example, you should convert the value \n        1 to 0000001 to ensure proper sorting.\n\n        :param str table_name:\n            The name of the table to insert the entity into.\n        :param entity:\n            The entity to insert. Could be a dict or an entity object. \n            Must contain a PartitionKey and a RowKey.\n        :type entity: a dict or :class:`~azure.storage.table.models.Entity`\n        :param int timeout:\n            The server timeout, expressed in seconds.\n        :return: The etag of the inserted entity.\n        :rtype: str\n        '''\n        _validate_not_none('table_name', table_name)\n        request = _insert_entity(entity)\n        request.host = self._get_host()\n        request.path = '/' + _to_str(table_name)\n        request.query += [('timeout', _int_to_str(timeout))]\n\n        response = self._perform_request(request)\n        return _extract_etag(response)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef update_entity(self, table_name, entity, if_match='*', timeout=None):\n        '''\n        Updates an existing entity in a table. Throws if the entity does not exist. \n        The update_entity operation replaces the entire entity and can be used to \n        remove properties.\n\n        :param str table_name:\n            The name of the table containing the entity to update.\n        :param entity:\n            The entity to update. Could be a dict or an entity object. \n            Must contain a PartitionKey and a RowKey.\n        :type entity: a dict or :class:`~azure.storage.table.models.Entity`\n        :param str if_match:\n            The client may specify the ETag for the entity on the \n            request in order to compare to the ETag maintained by the service \n            for the purpose of optimistic concurrency. The update operation \n            will be performed only if the ETag sent by the client matches the \n            value maintained by the server, indicating that the entity has \n            not been modified since it was retrieved by the client. To force \n            an unconditional update, set If-Match to the wildcard character (*).\n        :param int timeout:\n            The server timeout, expressed in seconds.\n        :return: The etag of the entity.\n        :rtype: str\n        '''\n        _validate_not_none('table_name', table_name)\n        request = _update_entity(entity, if_match)\n        request.host = self._get_host()\n        request.path = _get_entity_path(table_name, entity['PartitionKey'], entity['RowKey'])\n        request.query += [('timeout', _int_to_str(timeout))]\n\n        response = self._perform_request(request)\n        return _extract_etag(response)", "response": "Updates an existing entity in a table."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ndeleting an existing entity in a table.", "response": "def delete_entity(self, table_name, partition_key, row_key,\n                      if_match='*', timeout=None):\n        '''\n        Deletes an existing entity in a table. Throws if the entity does not exist.\n\n        When an entity is successfully deleted, the entity is immediately marked \n        for deletion and is no longer accessible to clients. The entity is later \n        removed from the Table service during garbage collection.\n\n        :param str table_name:\n            The name of the table containing the entity to delete.\n        :param str partition_key:\n            The PartitionKey of the entity.\n        :param str row_key:\n            The RowKey of the entity.\n        :param str if_match:\n            The client may specify the ETag for the entity on the \n            request in order to compare to the ETag maintained by the service \n            for the purpose of optimistic concurrency. The delete operation \n            will be performed only if the ETag sent by the client matches the \n            value maintained by the server, indicating that the entity has \n            not been modified since it was retrieved by the client. To force \n            an unconditional delete, set If-Match to the wildcard character (*).\n        :param int timeout:\n            The server timeout, expressed in seconds.\n        '''\n        _validate_not_none('table_name', table_name)\n        request = _delete_entity(partition_key, row_key, if_match)\n        request.host = self._get_host()\n        request.query += [('timeout', _int_to_str(timeout))]\n        request.path = _get_entity_path(table_name, partition_key, row_key)\n\n        self._perform_request(request)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ninsert an existing entity or replaces an existing entity if it does not exist in the table.", "response": "def insert_or_replace_entity(self, table_name, entity, timeout=None):\n        '''\n        Replaces an existing entity or inserts a new entity if it does not\n        exist in the table. Because this operation can insert or update an\n        entity, it is also known as an \"upsert\" operation.\n\n        If insert_or_replace_entity is used to replace an entity, any properties \n        from the previous entity will be removed if the new entity does not define \n        them.\n\n        :param str table_name:\n            The name of the table in which to insert or replace the entity.\n        :param entity:\n            The entity to insert or replace. Could be a dict or an entity object. \n            Must contain a PartitionKey and a RowKey.\n        :type entity: a dict or :class:`~azure.storage.table.models.Entity`\n        :param int timeout:\n            The server timeout, expressed in seconds.\n        :return: The etag of the entity.\n        :rtype: str\n        '''\n        _validate_not_none('table_name', table_name)\n        request = _insert_or_replace_entity(entity)\n        request.host = self._get_host()\n        request.query += [('timeout', _int_to_str(timeout))]\n        request.path = _get_entity_path(table_name, entity['PartitionKey'], entity['RowKey'])\n\n        response = self._perform_request(request)\n        return _extract_etag(response)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef insert_or_merge_entity(self, table_name, entity, timeout=None):\n        '''\n        Merges an existing entity or inserts a new entity if it does not exist\n        in the table. \n\n        If insert_or_merge_entity is used to merge an entity, any properties from \n        the previous entity will be retained if the request does not define or \n        include them.\n\n        :param str table_name:\n            The name of the table in which to insert or merge the entity.\n        :param entity:\n            The entity to insert or merge. Could be a dict or an entity object. \n            Must contain a PartitionKey and a RowKey.\n        :type entity: a dict or :class:`~azure.storage.table.models.Entity`\n        :param int timeout:\n            The server timeout, expressed in seconds.\n        :return: The etag of the entity.\n        :rtype: str\n        '''\n        _validate_not_none('table_name', table_name)\n        request = _insert_or_merge_entity(entity)\n        request.host = self._get_host()\n        request.query += [('timeout', _int_to_str(timeout))]\n        request.path = _get_entity_path(table_name, entity['PartitionKey'], entity['RowKey'])\n\n        response = self._perform_request(request)\n        return _extract_etag(response)", "response": "Inserts an existing entity or merges a new entity."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nextract the table name from the request. uri. The request. uri has either AttributeNames or \"/mytable(...)\" format.", "response": "def get_request_table(self, request):\n        '''\n        Extracts table name from request.uri. The request.uri has either\n        \"/mytable(...)\" or \"/mytable\" format.\n\n        request:\n            the request to insert, update or delete entity\n        '''\n        if '(' in request.path:\n            pos = request.path.find('(')\n            return request.path[1:pos]\n        else:\n            return request.path[1:]"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_request_partition_key(self, request):\n        '''\n        Extracts PartitionKey from request.body if it is a POST request or from\n        request.path if it is not a POST request. Only insert operation request\n        is a POST request and the PartitionKey is in the request body.\n\n        request:\n            the request to insert, update or delete entity\n        '''\n        if request.method == 'POST':\n            doc = ETree.fromstring(request.body)\n            part_key = doc.find('./atom:content/m:properties/d:PartitionKey', _etree_entity_feed_namespaces)\n            if part_key is None:\n                raise AzureBatchValidationError(_ERROR_CANNOT_FIND_PARTITION_KEY)\n            return _get_etree_text(part_key)\n        else:\n            uri = url_unquote(request.path)\n            pos1 = uri.find('PartitionKey=\\'')\n            pos2 = uri.find('\\',', pos1)\n            if pos1 == -1 or pos2 == -1:\n                raise AzureBatchValidationError(_ERROR_CANNOT_FIND_PARTITION_KEY)\n            return uri[pos1 + len('PartitionKey=\\''):pos2]", "response": "Extracts PartitionKey from request. body or from request. path. Only insert operation request. body is a POST request or from request. path is a DELETE request. Returns the PartitionKey."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nextract RowKey from request. body or from request. path. Only insert operation request. body is a POST request or from request. path is a DELETE request. Returns the RowKey of the entity that was inserted or deleted.", "response": "def get_request_row_key(self, request):\n        '''\n        Extracts RowKey from request.body if it is a POST request or from\n        request.path if it is not a POST request. Only insert operation request\n        is a POST request and the Rowkey is in the request body.\n\n        request:\n            the request to insert, update or delete entity\n        '''\n        if request.method == 'POST':\n            doc = ETree.fromstring(request.body)\n            row_key = doc.find('./atom:content/m:properties/d:RowKey', _etree_entity_feed_namespaces)\n            if row_key is None:\n                raise AzureBatchValidationError(_ERROR_CANNOT_FIND_ROW_KEY)\n            return _get_etree_text(row_key)\n        else:\n            uri = url_unquote(request.path)\n            pos1 = uri.find('RowKey=\\'')\n            pos2 = uri.find('\\')', pos1)\n            if pos1 == -1 or pos2 == -1:\n                raise AzureBatchValidationError(_ERROR_CANNOT_FIND_ROW_KEY)\n            row_key = uri[pos1 + len('RowKey=\\''):pos2]\n            return row_key"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nvalidates that all requests have the same table name. Set the table if it is the first request for the batch operation.", "response": "def validate_request_table(self, request):\n        '''\n        Validates that all requests have the same table name. Set the table\n        name if it is the first request for the batch operation.\n\n        request:\n            the request to insert, update or delete entity\n        '''\n        if self.batch_table:\n            if self.get_request_table(request) != self.batch_table:\n                raise AzureBatchValidationError(_ERROR_INCORRECT_TABLE_IN_BATCH)\n        else:\n            self.batch_table = self.get_request_table(request)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef validate_request_partition_key(self, request):\n        '''\n        Validates that all requests have the same PartitiionKey. Set the\n        PartitionKey if it is the first request for the batch operation.\n\n        request:\n            the request to insert, update or delete entity\n        '''\n        if self.batch_partition_key:\n            if self.get_request_partition_key(request) != \\\n                self.batch_partition_key:\n                raise AzureBatchValidationError(_ERROR_INCORRECT_PARTITION_KEY_IN_BATCH)\n        else:\n            self.batch_partition_key = self.get_request_partition_key(request)", "response": "Validates that all requests have the same PartitiionKey. Set the batch_partition_key if not set."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef validate_request_row_key(self, request):\n        '''\n        Validates that all requests have the different RowKey and adds RowKey\n        to existing RowKey list.\n\n        request:\n            the request to insert, update or delete entity\n        '''\n        if self.batch_row_keys:\n            if self.get_request_row_key(request) in self.batch_row_keys:\n                raise AzureBatchValidationError(_ERROR_DUPLICATE_ROW_KEY_IN_BATCH)\n        else:\n            self.batch_row_keys.append(self.get_request_row_key(request))", "response": "Validates that all requests have the same RowKey and adds RowKey\n            to existing RowKey list."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef begin_batch(self):\n        '''\n        Starts the batch operation. Intializes the batch variables\n\n        is_batch:\n            batch operation flag.\n        batch_table:\n            the table name of the batch operation\n        batch_partition_key:\n            the PartitionKey of the batch requests.\n        batch_row_keys:\n            the RowKey list of adding requests.\n        batch_requests:\n            the list of the requests.\n        '''\n        self.is_batch = True\n        self.batch_table = ''\n        self.batch_partition_key = ''\n        self.batch_row_keys = []\n        self.batch_requests = []", "response": "Starts the batch operation. Intializes the batch variables and sets the flag to True."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nadding request to batch operation.", "response": "def insert_request_to_batch(self, request):\n        '''\n        Adds request to batch operation.\n\n        request:\n            the request to insert, update or delete entity\n        '''\n        self.validate_request_table(request)\n        self.validate_request_partition_key(request)\n        self.validate_request_row_key(request)\n        self.batch_requests.append(request)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef commit_batch_requests(self):\n        ''' Commits the batch requests. '''\n\n        batch_boundary = b'batch_' + _new_boundary()\n        changeset_boundary = b'changeset_' + _new_boundary()\n\n        # Commits batch only the requests list is not empty.\n        if self.batch_requests:\n            request = HTTPRequest()\n            request.method = 'POST'\n            request.host = self.batch_requests[0].host\n            request.path = '/$batch'\n            request.headers = [\n                ('Content-Type', 'multipart/mixed; boundary=' + \\\n                    batch_boundary.decode('utf-8')),\n                ('Accept', 'application/atom+xml,application/xml'),\n                ('Accept-Charset', 'UTF-8')]\n\n            request.body = b'--' + batch_boundary + b'\\n'\n            request.body += b'Content-Type: multipart/mixed; boundary='\n            request.body += changeset_boundary + b'\\n\\n'\n\n            content_id = 1\n\n            # Adds each request body to the POST data.\n            for batch_request in self.batch_requests:\n                request.body += b'--' + changeset_boundary + b'\\n'\n                request.body += b'Content-Type: application/http\\n'\n                request.body += b'Content-Transfer-Encoding: binary\\n\\n'\n                request.body += batch_request.method.encode('utf-8')\n                request.body += b' http://'\n                request.body += batch_request.host.encode('utf-8')\n                request.body += batch_request.path.encode('utf-8')\n                request.body += b' HTTP/1.1\\n'\n                request.body += b'Content-ID: '\n                request.body += str(content_id).encode('utf-8') + b'\\n'\n                content_id += 1\n\n                # Add different headers for different type requests.\n                if not batch_request.method == 'DELETE':\n                    request.body += \\\n                        b'Content-Type: application/atom+xml;type=entry\\n'\n                    for name, value in batch_request.headers:\n                        if name == 'If-Match':\n                            request.body += name.encode('utf-8') + b': '\n                            request.body += value.encode('utf-8') + b'\\n'\n                            break\n                    request.body += b'Content-Length: '\n                    request.body += str(len(batch_request.body)).encode('utf-8')\n                    request.body += b'\\n\\n'\n                    request.body += batch_request.body + b'\\n'\n                else:\n                    for name, value in batch_request.headers:\n                        # If-Match should be already included in\n                        # batch_request.headers, but in case it is missing,\n                        # just add it.\n                        if name == 'If-Match':\n                            request.body += name.encode('utf-8') + b': '\n                            request.body += value.encode('utf-8') + b'\\n\\n'\n                            break\n                    else:\n                        request.body += b'If-Match: *\\n\\n'\n\n            request.body += b'--' + changeset_boundary + b'--' + b'\\n'\n            request.body += b'--' + batch_boundary + b'--'\n\n            request.path, request.query = _update_request_uri_query(request)\n            request.headers = _update_storage_table_header(request)\n            self.authentication.sign_request(request)\n\n            # Submit the whole request as batch request.\n            response = self.perform_request(request)\n            if response.status >= 300:\n                # This exception will be caught by the general error handler\n                # and raised as an azure http exception\n                raise HTTPError(response.status,\n                                _ERROR_BATCH_COMMIT_FAIL,\n                                self.respheader,\n                                response.body)\n\n            # http://www.odata.org/documentation/odata-version-2-0/batch-processing/\n            # The body of a ChangeSet response is either a response for all the\n            # successfully processed change request within the ChangeSet,\n            # formatted exactly as it would have appeared outside of a batch, \n            # or a single response indicating a failure of the entire ChangeSet.\n            responses = self._parse_batch_response(response.body)\n            if responses and responses[0].status >= 300:\n                self._report_batch_error(responses[0])", "response": "Commits the batch requests."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting the license on a redfish system", "response": "def set_license(self, key):\n        \"\"\"Set the license on a redfish system\n\n        :param key: license key\n        \"\"\"\n        data = {'LicenseKey': key}\n        license_service_uri = (utils.get_subresource_path_by(self,\n                               ['Oem', 'Hpe', 'Links', 'LicenseService']))\n        self._conn.post(license_service_uri, data=data)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting the iscsi details of the initiator system in uefi boot mode.", "response": "def set_iscsi_info(self, target_name, lun, ip_address,\n                       port='3260', auth_method=None, username=None,\n                       password=None):\n        \"\"\"Set iscsi details of the system in uefi boot mode.\n\n        The initiator system is set with the target details like\n        IQN, LUN, IP, Port etc.\n        :param target_name: Target Name for iscsi.\n        :param lun: logical unit number.\n        :param ip_address: IP address of the target.\n        :param port: port of the target.\n        :param auth_method : either None or CHAP.\n        :param username: CHAP Username for authentication.\n        :param password: CHAP secret.\n        :raises: IloError, on an error from iLO.\n        :raises: IloCommandNotSupportedInBiosError, if the system is\n                 in the bios boot mode.\n        \"\"\"\n        raise exception.IloCommandNotSupportedError(ERRMSG)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef writeGCE_table(filename,headers,data,dcols=['Isotopes','Yields','Z','A'],header_char='H',sldir='.',sep='&'):\n    '''\n    Method for writeing data in GCE format in Ascii files.\n    Reads either elements or isotopes\n    dcols[0] needs to contain either isotopes or elements\n\n    Note the attribute name at position i in dcols will be associated\n    with the column data at index i in data.\n    Also the number of data columns(in data) must equal the number\n    of data attributes (in dcols)\n    Also all the lengths of that columns must all be the same.\n    Input:\n    filename: The file where this data will be written.\n    Headers: A list of Header strings or if the file being written\n         is of type trajectory, this is a List of strings\n         that contain header attributes and their associated\n         values which are seperated by a '='.\n    dcols: A list of data attributes\n    data:  A list of lists (or of numpy arrays).\n    header_char  the character that indicates a header lines\n    sldir: Where this fill will be written.\n    sep: What seperatesa the data column attributes\n    trajectory: Boolean of if we are writeing a trajectory type file\n    '''\n\n    import re\n    from . import utils as u\n\n    #check if input are elements or isotopes\n    if not '-' in data[0][0]:\n        iso_inp=False\n        dcols=dcols+['Z']\n    else:\n        iso_inp=True\n        dcols=dcols+['Z','A']\n    #Attach Z and A\n    if iso_inp==True:\n        data.append([])\n        data.append([])\n        u.convert_specie_naming_from_h5_to_ppn(data[0])\n        Z=u.znum_int\n        A=u.amass_int\n        for i in range(len(data[0])):\n            zz=str(int(Z[i]))\n            aa=str(int(A[i]))\n            data[1][i]='{:.3E}'.format(data[1][i])+' '\n            data[-2].append(zz)\n            data[-1].append(aa)\n\n\n    else:\n        #in order to get Z , create fake isotope from element\n        fake_iso=[]\n        for k in range(len(data[0])):\n            fake_iso.append(data[0][k]+'-99')\n        #print fake_iso\n            data.append([])\n            u.convert_specie_naming_from_h5_to_ppn(fake_iso)\n            Z=u.znum_int\n        for i in range(len(data[0])):\n            zz=str(int(Z[i]))\n            data[1][i]='{:.3E}'.format(data[1][i])+' '\n            data[-1].append(zz)\n\n\n    if sldir.endswith(os.sep):\n        filename = str(sldir)+str(filename)\n    else:\n        filename = str(sldir)+os.sep+str(filename)\n    tmp=[] #temp variable\n    lines=[]#list of the data lines\n    lengthList=[]# list of the longest element (data or column name)\n             # in each column\n\n    if os.path.exists(filename):\n        print('This method will add table to existing file '+ filename)\n\n    if len(data)!=len(dcols):\n        print('The number of data columns does not equal the number of Data attributes')\n        print('returning none')\n        return None\n    for i in range(len(headers)):\n        tmp.append(header_char+' '+headers[i]+'\\n')\n    headers=tmp\n    tmp=''\n\n    for i in range(len(data)): #Line length stuff\n        length=len(dcols[i])+1\n        for j in range(len(data[i])):\n            tmp2=data[i][j]\n            if isinstance(data[i][j],float):\n                tmp2='{:.3E}'.format(data[i][j])+' '\n                data[i][j] = tmp2\n            if len(str(tmp2))>length:\n                length=len(str(tmp2))\n        lengthList.append(length)\n\n    tmp=''\n    tmp1=''\n    for i in range(len(dcols)):\n        tmp1=dcols[i]\n        if len(dcols[i]) < lengthList[i]:\n            j=lengthList[i]-len(dcols[i])\n            for k in range(j):\n                tmp1+=' '\n        tmp+=sep+tmp1\n    tmp+='\\n'\n    dcols=tmp\n    tmp=''\n    for i in range(len(data[0])):\n        for j in range(len(data)):\n            if type(data[j][i]) == str:\n                #match = re.match(r\"([a-z]+)([0-9]+)\",data[j][i], re.I)\n                                    #items = match.groups()\n                tmp1=data[j][i]#items[0].capitalize()+'-'+items[1]\n                if len(str(data[j][i])) < lengthList[j]:\n                        l=lengthList[j]-len(tmp1)\n                        for k in range(l):\n                                tmp1+=' '\n                extra=''\n            #else:\n                            #        tmp1=data[j][i]\n                            #        if len(data[j][i]) < lengthList[j]:\n                            #                l=lengthList[j]-len(data[j][i]))\n                            #                for k in xrange(l):\n                            #                        tmp1+=' '\n\n\n            tmp+=sep+tmp1\n        lines.append(tmp+'\\n')\n        tmp=''\n\n    f=open(filename,'a')\n    for i in range(len(headers)):\n        f.write(headers[i])\n    f.write(dcols)\n    for i in range(len(lines)):\n        f.write(lines[i])\n\n    f.close()\n    return None", "response": "Method for writing data in Ascii format in Ascii files."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get(self, attri):\n        '''\n        Method that dynamically determines the type of attribute that is\n        passed into this method. Also it then returns that attribute's\n        associated data.\n\n        Parameters\n        ----------\n        attri : string\n            The attribute we are looking for.\n\n        '''\n        isCol=False\n        isHead=False\n\n        if attri in self.dcols:\n            isCol=True\n        elif attri in self.hattrs:\n            isHead=True\n        else:\n            print(\"That attribute does not exist in this File\")\n            print('Returning None')\n\n        if isCol:\n            return self.getColData(attri)\n        elif isHead:\n            return hattrs", "response": "This method returns the associated data for the specified attribute."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef initial_finall_mass_relation(self,marker='o',linestyle='--'):\n\t\t'''\n\t\t\tINtiial to final mass relation\n\t\t'''\n\n\t\tfinal_m=[]\n                ini_m=[]\n                for i in range(len(self.runs_H5_surf)):\n\t\t\tsefiles=se(self.runs_H5_out[i])\n                        ini_m.append(sefiles.get(\"mini\")) \n\t\t\th1=sefiles.get(int(sefiles.se.cycles[-2]),'H-1')\n\t\t\tmass=sefiles.get(int(sefiles.se.cycles[-2]),'mass')\n\t\t\tidx=-1\n\t\t\tfor k in range(len(h1)):\n\t\t\t\tif h1[k]>0.1:\n\t\t\t\t\tidx=k\n\t\t\t\t\tbreak\n\t\t\tfinal_m.append(mass[idx])\n\t\tlabel='Z='+str(sefiles.get('zini'))\n\t\tplt.plot(ini_m,final_m,label=label,marker=marker,linestyle=linestyle)\n\t\tplt.xlabel('$M_{Initial} [M_{\\odot}]$',size=23)\n\t\tplt.ylabel('$M_{Final} [M_{\\odot}]$',size=23)", "response": "Plots the initial and final mass relation between the two surfaces."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nplots the composition of the surfaces in the H5.", "response": "def plot_surf_composition(self,hsfe_hsls = True,lsfe_hsls = False,rbsr_hsls = False,rbzr_hsls = False,sry_srzr = False,rbfe_sfe = False,iso_ratio= False,isotopes_x = ['Mg-25','Mg-24'],isotopes_y = ['Mg-26','Mg-24'],sparsity = 5000,marker1=['o'],symbols1=['k-'],color=['k']):\n\t\t'''\n\t\t\tSet only one of the vriables True to plot quantitie4s.\n\t\t\tIn case you set iso_ratio = True:\n\t\t\t\tisotooes_x and isototopes_y are used.  \n\t\t'''\n\n\t\timport nugridse as mp\n\t\timport matplotlib.pyplot as pl\n\t\timport sys\n\n\t\tplotting=True\n\n\t\t### SET THIS IF PLOTTING = TRUE ####################\n\t\t###>>>>!!!! ONLY ONE OPTION CAN BE TRUE !!!!<<<< ###\n\t\t#test=[hsfe_hsls,lsfe_hsls,\n\t\t#hsfe_hsls = False\n\t\t#lsfe_hsls = False\n\t\t#rbsr_hsls = False\n\t\t#rbzr_hsls = False\n\t\t#sry_srzr = False\n\t\t#rbfe_sfe = False\n\t\t#iso_ratio= True\n\t\t###################################\n\n                for i in range(len(self.runs_H5_surf)):\n                       \tm3z2m2=se(self.runs_H5_surf[i])\n\t\t\trun_mass=[m3z2m2]\n\n\t\t\tmarkers=[marker1[i]]#['ks']#,'r^','gh','bd','mv','cH','kD']\n\t\t\tsymbol=[symbols1[i]]#['k-']#,'r--','g-','b:','m-','c--','k-']\n\t\t\tcolor1=color[i]\n\t\t\tls_element = ['Sr-84','Sr-86','Sr-87','Sr-88','Y-89','Zr-90','Zr-91','Zr-92','Zr-94','Zr-96']\n\t\t\ths_element = ['Ba-130','Ba-132','Ba-134','Ba-135','Ba-136','Ba-137','Ba-138','La-138','La-139','Nd-142','Nd-143','Nd-144','Nd-145','Nd-146','Nd-148','Nd-150','Sm-144','Sm-147','Sm-148','Sm-149','Sm-150','Sm-152','Sm-154']\n\t\t\t# notice that Pb (3rd s-process index) is not included here.\n\t\t\ts_element =  ['Sr-84','Sr-86','Sr-87','Sr-88','Y-89','Zr-90','Zr-91','Zr-92','Zr-94','Zr-96','Ba-130','Ba-132','Ba-134','Ba-135','Ba-136','Ba-137','Ba-138','La-138','La-139','Nd-142','Nd-143','Nd-144','Nd-145','Nd-146','Nd-148','Nd-150','Sm-144','Sm-147','Sm-148','Sm-149','Sm-150','Sm-152','Sm-154']\t\n\n\t\t\tls_element = ['Sr-84','Sr-86','Sr-87','Sr-88','Y-89','Zr-90','Zr-91','Zr-92','Zr-94','Zr-96']\n\t\t\ths_element = ['Ba-130','Ba-132','Ba-134','Ba-135','Ba-136','Ba-137','Ba-138','La-138','La-139','Nd-142','Nd-143','Nd-144','Nd-145','Nd-146','Nd-148','Nd-150','Sm-144','Sm-147','Sm-148','Sm-149','Sm-150','Sm-152','Sm-154']\n\t\t\t# notice that Pb (3rd s-process index) is not included here.\n\t\t\ts_element =  ['Sr-84','Sr-86','Sr-87','Sr-88','Y-89','Zr-90','Zr-91','Zr-92','Zr-94','Zr-96','Ba-130','Ba-132','Ba-134','Ba-135','Ba-136','Ba-137','Ba-138','La-138','La-139','Nd-142','Nd-143','Nd-144','Nd-145','Nd-146','Nd-148','Nd-150','Sm-144','Sm-147','Sm-148','Sm-149','Sm-150','Sm-152','Sm-154']\t\n\n\t\t\ts_ini = []\n\t\t\tls_ini = []\n\t\t\ths_ini = []\n\t\t\tpb_ini = []\n\t\t\tfe_ini = []\n\t\t\trb_ini = []\n\t\t\tsr_ini = []\n\t\t\tzr_ini = []\n\t\t\ty_ini = []\n\t\t\tzra_ini = []\n\t\t\tzrb_ini = []\n\t\t\tgda_ini = []\n\t\t\tgdb_ini = []\n\n\t\t\tif plotting:\n\n\t\t\t\tif iso_ratio:\n\n\t\t\t\t\tisotopes_x = ['Mg-25','Mg-24']\n\t\t\t\t\tisotopes_y = ['Mg-26','Mg-24']\n\n\t\t\t\t\t#isotopes_x = ['Zr-96','Zr-94']\n\t\t\t\t\t#isotopes_y = ['Gd-152','Gd-154']\n\t\t\t\t\t#isotopes_y = ['Zr-90','Zr-94']\n\t\t\t\t\t#isotopes_y = ['Zr-91','Zr-94']\n\t\t\t\t\t#isotopes_y = ['Zr-92','Zr-94']\n\n\t\t\t\t\t#isotopes_x = ['Ba-135','Ba-136']\n\t\t\t\t\t#isotopes_y = ['Ba-138','Ba-136']\n\t\t\t\t\t#isotopes_y = ['Ba-134','Ba-136']\n\t\t\t\t\t#isotopes_y = ['Ba-137','Ba-136']\n\n\t\t\t\t\t#isotopes_x = ['Sr-84','Sr-86']\n\t\t\t\t\t#isotopes_y = ['Sr-87','Sr-86']\n\t\t\t\t\t#isotopes_y = ['Sr-88','Sr-86']\n\n\t\t\t\t\t# get initial value\n\t\t\t\t\tinitial_isotopic_ratio_x = float(run_mass[0].se.get(min(run_mass[0].se.cycles),'iso_massf',isotopes_x[0]))/float(run_mass[0].se.get(min(run_mass[0].se.cycles),'iso_massf',isotopes_x[1]))\n\t\t\t\t\tinitial_isotopic_ratio_y = float(run_mass[0].se.get(min(run_mass[0].se.cycles),'iso_massf',isotopes_y[0]))/float(run_mass[0].se.get(min(run_mass[0].se.cycles),'iso_massf',isotopes_y[1]))\n\n\t\t\t\t\t# sparcity for cycles I am looking at.\n\t\t\t\t\t#sparsity = 5000\n\n\t\t\t\t\tI_want_iso_ratio = False\n\t\t\t\t\tI_want_delta = True\n\n\t\t\t\t\tisotopic_ratio_x  = []\n\t\t\t\t\tisotopic_ratio_y = []\n\t\t\t\t\tisotopic_ratio_x_tps = []\n\t\t\t\t\tisotopic_ratio_y_tps = []\n\t\t\t\t\tisotopic_ratio_x_tps_co = []\n\t\t\t\t\tisotopic_ratio_y_tps_co = []\n\n\t\t\t\t\tk = 0\n\n\t\t\t\t\tfor i in run_mass:\n\t\t\t\t\t\tdum_isotopic_ratio_x = []\n\t\t\t\t\t\tdum_isotopic_ratio_y = []\n\t\t\t\t\t\tdumdum_isotopic_ratio_x = []\n\t\t\t\t\t\tdumdum_isotopic_ratio_y = []\n\t\t\t\t\t\tdum_isotopic_ratio_x_tps = []\n\t\t\t\t\t\tdum_isotopic_ratio_y_tps = []\n\t\t\t\t\t\tdum_isotopic_ratio_x_tps_co = []\n\t\t\t\t\t\tdum_isotopic_ratio_y_tps_co = []\n\t\t\t\t\t\tco_ratio=[]\n\t\t\t\t\t\tfor j in i.se.cycles[0::sparsity]:\n\t\t\t\t\t\t\tprint 'j= ', j\n\t\t\t\t\t\t\tdum_isotopic_ratio_x.append(float(i.se.get(j,'iso_massf',isotopes_x[0]))/float(i.se.get(j,'iso_massf',isotopes_x[1])))\n\t\t\t\t\t\t\tdum_isotopic_ratio_y.append(float(i.se.get(j,'iso_massf',isotopes_y[0]))/float(i.se.get(j,'iso_massf',isotopes_y[1])))\n\t\t\t\t\t\t\tco_ratio.append((float(i.se.get(j,'iso_massf','C-12')*4.))/(float(i.se.get(j,'iso_massf','O-16'))*3))\n\n\t\t\t\t\t\t\tif (len(co_ratio)>1):\n\t\t\t\t\t\t\t\tif (co_ratio[len(co_ratio)-1]>(co_ratio[len(co_ratio)-2]+0.02)):\n\t\t\t\t\t\t\t\t\tdum_isotopic_ratio_x_tps.append(float(i.se.get(j,'iso_massf',isotopes_x[0]))/float(i.se.get(j,'iso_massf',isotopes_x[1])))\n\t\t\t\t\t\t\t\t\tdum_isotopic_ratio_y_tps.append(float(i.se.get(j,'iso_massf',isotopes_y[0]))/float(i.se.get(j,'iso_massf',isotopes_y[1])))\n\n\t\t\t\t\t\t\t\t\tif (co_ratio[len(co_ratio)-1]>1.):\n\t\t\t\t\t\t\t\t\t\tdum_isotopic_ratio_x_tps_co.append(float(i.se.get(j,'iso_massf',isotopes_x[0]))/float(i.se.get(j,'iso_massf',isotopes_x[1])))\n\t\t\t\t\t\t\t\t\t\tdum_isotopic_ratio_y_tps_co.append(float(i.se.get(j,'iso_massf',isotopes_y[0]))/float(i.se.get(j,'iso_massf',isotopes_y[1])))\n\n\t\t\t\t\t\t\tif I_want_delta:\n\t\t\t\t\t\t\t\tdumdum_isotopic_ratio_x=(np.array(dum_isotopic_ratio_x)/initial_isotopic_ratio_x-1.)*1000.\n\t\t\t\t\t\t\t\tdumdum_isotopic_ratio_y=(np.array(dum_isotopic_ratio_y)/initial_isotopic_ratio_y-1.)*1000.\n\t\t\t\t\t\t\t\tdumdum_isotopic_ratio_x_tps=(np.array(dum_isotopic_ratio_x_tps)/initial_isotopic_ratio_x-1.)*1000.\n\t\t\t\t\t\t\t\tdumdum_isotopic_ratio_y_tps=(np.array(dum_isotopic_ratio_y_tps)/initial_isotopic_ratio_y-1.)*1000.\n\t\t\t\t\t\t\t\tdumdum_isotopic_ratio_x_tps_co=(np.array(dum_isotopic_ratio_x_tps_co)/initial_isotopic_ratio_x-1.)*1000.\n\t\t\t\t\t\t\t\tdumdum_isotopic_ratio_y_tps_co=(np.array(dum_isotopic_ratio_y_tps_co)/initial_isotopic_ratio_y-1.)*1000.\n\n\t\t\t\t\t\tif I_want_iso_ratio:\n\t\t\t\t\t\t\tisotopic_ratio_x.append(dum_isotopic_ratio_x)\n\t\t\t\t\t\t\tisotopic_ratio_y.append(dum_isotopic_ratio_y)\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\tisotopic_ratio_x.append(dumdum_isotopic_ratio_x)\n\t\t\t\t\t\t\tisotopic_ratio_y.append(dumdum_isotopic_ratio_y)\n\t\t\t\t\t\t\tisotopic_ratio_x_tps.append(dumdum_isotopic_ratio_x_tps)\n\t\t\t\t\t\t\tisotopic_ratio_y_tps.append(dumdum_isotopic_ratio_y_tps)\n\t\t\t\t\t\t\tisotopic_ratio_x_tps_co.append(dumdum_isotopic_ratio_x_tps_co)\n\t\t\t\t\t\t\tisotopic_ratio_y_tps_co.append(dumdum_isotopic_ratio_y_tps_co)\n\n\t\t\t\t\t\tk = k+1\n\n\t\t\t\t\tmarkersss=['ko','b^','rh','gd','mv','cH','kD']\n\t\t\t\t\tsymbol=['k-','b--','r-.','g:','m-','c--','k-']\n\n\t\t\t\t\tmass_label =[]\n\t\t\t\t\tfor i in run_mass:\n\t\t\t\t\t\tmini=float(i.se.get('mini'))\n\t\t\t\t\t\tzini=float(i.se.get('zini'))\n\t\t\t\t\t\tlabel=str(mini)+'$M_{\\odot}$, Z='+str(zini)\n\t\t\t\t\t\tmass_label.append(label)\n\n\t\t\t\t\tmetallicity_label=['M3z2m2','M3z2m2_nomol','M3z1m2','3 Msun, Z=0.02, PI13']\n\t\t\t\t\tmetallicity_label=[label]\n\n\t\t\t\t\tarray_to_plot_x = isotopic_ratio_x\n\t\t\t\t\tarray_to_plot_y = isotopic_ratio_y\n\t\t\t\t\tarray_to_plot_x_tps = isotopic_ratio_x_tps\n\t\t\t\t\tarray_to_plot_y_tps = isotopic_ratio_y_tps\n\t\t\t\t\tarray_to_plot_x_tps_co = isotopic_ratio_x_tps_co\n\t\t\t\t\tarray_to_plot_y_tps_co = isotopic_ratio_y_tps_co\n\n\t\t\t\t\tif I_want_delta:\n\t\t\t\t\t\tpl.axhline(y=0.,linewidth=2, color='k')\n\t\t\t\t\t\tpl.axvline(x=0.,linewidth=2, color='k')\n\t\t\t\t\telse:\n\t\t\t\t\t\t#\tpl.axhline(y=initial_isotopic_ratio_y/initial_isotopic_ratio_y,linewidth=2, color='k')\n\t\t\t\t\t\tpl.axhline(y=initial_isotopic_ratio_y,linewidth=2, color='k')\n\t\t\t\t\t\t#\tpl.axvline(x=initial_isotopic_ratio_x/initial_isotopic_ratio_x,linewidth=2, color='k')\n\t\t\t\t\t\tpl.axvline(x=initial_isotopic_ratio_x,linewidth=2, color='k')\n\n\t\t\t\t\tfor k in range(0,len(array_to_plot_x)):\n\t\t\t\t\t\tif I_want_delta:\n\t\t\t\t\t\t\tpl.plot(array_to_plot_x[k],array_to_plot_y[k],symbol[k],markersize=10.,linewidth=4.,label=str(metallicity_label[k]))\n\t\t\t\t\t\t\tpl.plot(array_to_plot_x_tps[k],array_to_plot_y_tps[k],markersss[k],markersize=10.,linewidth=4.)\n\t\t\t\t\t\t\tpl.plot(array_to_plot_x_tps_co[k],array_to_plot_y_tps_co[k],markersss[k],markersize=20.,linewidth=4.)\n\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\t#\t\tpl.loglog(array_to_plot_x[k],array_to_plot_y[k],symbol[k],markersize=10.,linewidth=2.,label=str(mass_label[k])+'Msun ')\n\t\t\t\t\t\t\tpl.loglog(array_to_plot_x[k],array_to_plot_y[k],symbol[k],markersize=10.,linewidth=2.,label=str(mass_label[k])+'Msun ')\n\n\t\t\t\t\tpl.legend(numpoints=1,loc=2,prop={'size':20})\n\t\t\t\t\tsize=20\n\t\t\t\t\tpl.xticks(size=size)\n\t\t\t\t\tpl.yticks(size=size)\n\t\t\t\t\t#pl.axis([0.08,0.5,0.1,1.])\n\t\t\t\t\t#pl.grid()\n\n\t\t\t\t\tif I_want_delta:\n\t\t\t\t\t\t#pl.xlabel(r'$\\delta$($^{25}$Mg/$^{24}$Mg)', fontsize=30)\n\t\t\t\t\t\t#pl.ylabel(r'$\\delta$($^{26}$Mg/$^{24}$Mg)', fontsize=30)\n\n\t\t\t\t\t\tpl.xlabel(r'$\\delta$($^{96}$Zr/$^{94}$Zr)', fontsize=20)\n\t\t\t\t\t\tpl.ylabel(r'$\\delta$($^{152}$Gd/$^{154}$Gd)', fontsize=20)\n\t\t\t\t\t\t#pl.ylabel(r'$\\delta$($^{90}$Zr/$^{94}$Zr)', fontsize=30)\n\t\t\t\t\t\t#pl.ylabel(r'$\\delta$($^{91}$Zr/$^{94}$Zr)', fontsize=30)\n\t\t\t\t\t\t#pl.ylabel(r'$\\delta$($^{92}$Zr/$^{94}$Zr)', fontsize=30)\n\t\t\t\t\t\n\t\t\t\t\t\t#pl.xlabel('d($^{135}$Ba/$^{136}$Ba)', fontsize=20)\n\t\t\t\t\t\t#pl.ylabel('d($^{138}$Ba/$^{136}$Ba)', fontsize=20)\n\t\t\t\t\t\t#pl.ylabel('d($^{134}$Ba/$^{136}$Ba)', fontsize=20)\n\t\t\t\t\t\t#pl.ylabel('d($^{137}$Ba/$^{136}$Ba)', fontsize=20)\n\n\t\t\t\t\t\t#pl.xlabel(r'$\\delta$($^{84}$Sr/$^{86}$Sr)', fontsize=20)\n\t\t\t\t\t\t#pl.ylabel(r'$\\delta$($^{87}$Sr/$^{86}$Sr)', fontsize=20)\n\t\t\t\t\t\t#pl.ylabel(r'$\\delta$($^{88}$Sr/$^{86}$Sr)', fontsize=20)\n\t\t\t\t\telse:\n\t\t\t\t\t\tpl.xlabel('$^{25}$Mg/$^{24}$Mg', fontsize=20)\n\t\t\t\t\t\tpl.ylabel('$^{26}$Mg/$^{24}$Mg', fontsize=20)\n\n\t\t\t\t\t\t#pl.xlabel('$^{96}$Zr/$^{94}$Zr', fontsize=30)\n\t\t\t\t\t\t#pl.ylabel('$^{152}$Gd/$^{154}$Gd', fontsize=30)\n\t\t\t\t\t\t#pl.ylabel('$^{90}$Zr/$^{94}$Zr', fontsize=30)\n\t\t\t\t\t\t#pl.ylabel('$^{91}$Zr/$^{94}$Zr', fontsize=30)\n\t\t\t\t\t\t#pl.ylabel('$^{92}$Zr/$^{94}$Zr', fontsize=30)\n\t\t\t\t\t\n\t\t\t\t\t\t#pl.xlabel('d($^{135}$Ba/$^{136}$Ba)', fontsize=20)\n\t\t\t\t\t\t#pl.ylabel('d($^{138}$Ba/$^{136}$Ba)', fontsize=20)\n\t\t\t\t\t\t#pl.ylabel('d($^{134}$Ba/$^{136}$Ba)', fontsize=20)\n\t\t\t\t\t\t#pl.ylabel('d($^{137}$Ba/$^{136}$Ba)', fontsize=20)\n\n\t\t\t\t\t\t#pl.xlabel('$^{84}$Sr/$^{86}$Sr', fontsize=20)\n\t\t\t\t\t\t#pl.ylabel('$^{87}$Sr/$^{86}$Sr', fontsize=20)\n\t\t\t\t\t\t#pl.ylabel('$^{88}$Sr/$^{86}$Sr', fontsize=20)\n\t\t\t\t\t\t\n\t\t\t\t\tsys.exit()             \n\n\t\t\tfor i in run_mass:\n\t\t\t\tdum_s_ini = 0.\n\t\t\t\tdum_ls_ini = 0.\n\t\t\t\tdum_hs_ini = 0.\n\t\t\t\tdum_pb_ini = 0.\n\t\t\t\tdum_fe_ini = 0.\n\t\t\t\tdum_rb_ini = 0.\n\t\t\t\tdum_sr_ini = 0.\n\t\t\t\tdum_zr_ini = 0.\t\n\t\t\t\tdum_pb_ini = float(i.se.get(min(i.se.cycles),'iso_massf','Pb-204'))+float(i.se.get(min(i.se.cycles),'iso_massf','Pb-206'))+float(i.se.get(min(i.se.cycles),'iso_massf','Pb-207'))+float(i.se.get(min(i.se.cycles),'iso_massf','Pb-208'))\n\t\t\t\t#\n\t\t\t\tdum_fe_ini = float(i.se.get(min(i.se.cycles),'iso_massf','Fe-54'))+float(i.se.get(min(i.se.cycles),'iso_massf','Fe-56'))+float(i.se.get(min(i.se.cycles),'iso_massf','Fe-57'))+float(i.se.get(min(i.se.cycles),'iso_massf','Fe-58'))\t\n\t\t\t\tdum_rb_ini = float(i.se.get(min(i.se.cycles),'iso_massf','Rb-85'))+float(i.se.get(min(i.se.cycles),'iso_massf','Rb-87'))\n\t\t\t\tdum_sr_ini = float(i.se.get(min(i.se.cycles),'iso_massf','Sr-84'))+float(i.se.get(min(i.se.cycles),'iso_massf','Sr-86'))+float(i.se.get(min(i.se.cycles),'iso_massf','Sr-87'))+float(i.se.get(min(i.se.cycles),'iso_massf','Sr-88'))\n\t\t\t\tdum_zr_ini = float(i.se.get(min(i.se.cycles),'iso_massf','Zr-90'))+float(i.se.get(min(i.se.cycles),'iso_massf','Zr-91'))+float(i.se.get(min(i.se.cycles),'iso_massf','Zr-92'))+float(i.se.get(min(i.se.cycles),'iso_massf','Zr-94'))+float(i.se.get(min(i.se.cycles),'iso_massf','Zr-96'))\n\t\t\t\tdum_y_ini = float(i.se.get(min(i.se.cycles),'iso_massf','Y-89'))\n\t\t\t\tdum_zra_ini = float(i.se.get(min(i.se.cycles),'iso_massf','Zr-96'))\n\t\t\t\tdum_gda_ini = float(i.se.get(min(i.se.cycles),'iso_massf','Gd-152'))\n\t\t\t\tdum_zrb_ini = float(i.se.get(min(i.se.cycles),'iso_massf','Zr-94'))\n\t\t\t\tdum_gdb_ini = float(i.se.get(min(i.se.cycles),'iso_massf','Gd-154'))\n\n\n\t\t\t\tfor j in ls_element:\n\t\t\t\t\tdum_ls_ini = dum_ls_ini + float(i.se.get(min(i.se.cycles),'iso_massf',j))\n\t\t\t\tfor j in hs_element:\n\t\t\t\t\tdum_hs_ini = dum_hs_ini + float(i.se.get(min(i.se.cycles),'iso_massf',j))\n\t\t\t\tfor j in s_element:\n\t\t\t\t\tdum_s_ini = dum_s_ini + float(i.se.get(min(i.se.cycles),'iso_massf',j))\n\t\t\t\tfe_ini.append(dum_fe_ini)\n\t\t\t\tpb_ini.append(dum_pb_ini)\n\t\t\t\tls_ini.append(dum_ls_ini)    #  /float(len(ls_element)))\n\t\t\t\ths_ini.append(dum_hs_ini)     #/float(len(hs_element)))\n\t\t\t\ts_ini.append(dum_s_ini)  #/float(len(s_element)))\t\t\t\t\n\t\t\t\trb_ini.append(dum_rb_ini)\n\t\t\t\tsr_ini.append(dum_sr_ini)\n\t\t\t\tzr_ini.append(dum_zr_ini)\n\t\t\t\ty_ini.append(dum_y_ini)\n\t\t\t\tzra_ini.append(dum_zra_ini)\n\t\t\t\tgda_ini.append(dum_gda_ini)\n\t\t\t\tzrb_ini.append(dum_zrb_ini)\n\t\t\t\tgdb_ini.append(dum_gdb_ini)\n\n\n\n\t\t\t# sparcity for cycles I am looking at.\n\t\t\tsparsity = 5000\n\t\t\ts_fe  = []\n\t\t\tls_fe = []\n\t\t\ths_fe = []\n\t\t\tpb_fe = []\n\t\t\ths_ls = []\n\t\t\trb_sr = []\n\t\t\trb_zr = []\n\t\t\trb_fe = []\n\t\t\tsr_y = []\n\t\t\tsr_zr = []\n\t\t\tsr_zr_tps=[]\n\t\t\tsr_y_tps=[]\n\t\t\tsr_zr_tps_co=[]\n\t\t\tsr_y_tps_co=[]\n\t\t\ts_fe_tps  = []\n\t\t\tls_fe_tps = []\n\t\t\ths_fe_tps = []\n\t\t\tpb_fe_tps = []\n\t\t\ths_ls_tps = []\n\t\t\trb_sr_tps = []\n\t\t\trb_zr_tps = []\n\t\t\trb_fe_tps = []\n\t\t\ts_fe_tps_co  = []\n\t\t\tls_fe_tps_co = []\n\t\t\ths_fe_tps_co = []\n\t\t\tpb_fe_tps_co = []\n\t\t\ths_ls_tps_co = []\n\t\t\trb_sr_tps_co = []\n\t\t\trb_zr_tps_co = []\n\t\t\trb_fe_tps_co = []\n\t\t\tgd=[]\n\t\t\tzr=[]\n\t\t\tgd_tps=[]\n\t\t\tzr_tps=[]\n\t\t\tgd_tps_co=[]\n\t\t\tzr_tps_co=[]\n\t\t\tco=[]\n\t\t\tk = 0\n\n\t\t\tfor i in run_mass:\n\n\t\t\t\tjjjj=0\n\t\t\t\tdum_s_fe = []\n\t\t\t\tdum_ls_fe = []\n\t\t\t\tdum_hs_fe = []\n\t\t\t\tdum_pb_fe = []\n\t\t\t\tdum_hs_ls = []\n\t\t\t\tdum_rb_sr = []\n\t\t\t\tdum_rb_zr = []\n\t\t\t\tdum_rb_fe = []\n\t\t\t\tdum_sr_y = []\n\t\t\t\tdum_sr_zr = []\n\t\t\t\tdum_sr_zr_tps=[]\n\t\t\t\tdum_sr_y_tps=[]\n\t\t\t\tdum_sr_zr_tps_co=[]\n\t\t\t\tdum_sr_y_tps_co=[]\n\t\t\t\tdum_s_fe_tps = []\n\t\t\t\tdum_ls_fe_tps = []\n\t\t\t\tdum_hs_fe_tps = []\n\t\t\t\tdum_pb_fe_tps = []\n\t\t\t\tdum_hs_ls_tps = []\n\t\t\t\tdum_rb_sr_tps = []\n\t\t\t\tdum_rb_fe_tps = []\n\t\t\t\tdum_rb_zr_tps = []\n\t\t\t\tdum_sr_y_tps = []\n\t\t\t\tdum_sr_zr_tps = []\n\t\t\t\tdum_s_fe_tps_co = []\n\t\t\t\tdum_ls_fe_tps_co = []\n\t\t\t\tdum_hs_fe_tps_co = []\n\t\t\t\tdum_pb_fe_tps_co = []\n\t\t\t\tdum_hs_ls_tps_co = []\n\t\t\t\tdum_rb_sr_tps_co = []\n\t\t\t\tdum_rb_zr_tps_co = []\n\t\t\t\tdum_rb_fe_tps_co = []\n\t\t\t\tdum_rb_sr_tps_co = []\n\t\t\t\tdum_sr_y_tps_co = []\n\t\t\t\tdum_sr_zr_tps_co = []\n\t\t\t\tdum_gd=[]\n\t\t\t\tdum_zrr=[]\n\t\t\t\tdum_gd_tps=[]\n\t\t\t\tdum_zr_tps=[]\n\t\t\t\tdum_gd_tps_co=[]\n\t\t\t\tdum_zr_tps_co=[]\n\t\t\t\tdum_co=[]\n\n\t\t\t\tfor j in i.se.cycles[0::sparsity]:\n\t\t\t\t\tdum_s = 0.\n\t\t\t\t\tdum_ls = 0.\n\t\t\t\t\tdum_hs = 0.\n\t\t\t\t\tdum_fe = 0.\n\t\t\t\t\tdum_pb = 0.\n\t\t\t\t\tdum_rb = 0.\n\t\t\t\t\tdum_sr = 0.\n\t\t\t\t\tdum_zr = 0.\n\t\t\t\t\tdum_y = 0.\n\t\t\t\t\tdum_c = 0.\n\t\t\t\t\tdum_o = 0.\n\t\t\t\t\tdum_gda = 0.\n\t\t\t\t\tdum_gdb = 0.\n\t\t\t\t\tdum_zra = 0.\n\t\t\t\t\tdum_zrb = 0.\n\n\t\t\t\t\tprint j\n\t\t\t\t\tdum_fe = float(i.se.get(j,'iso_massf','Fe-54'))+float(i.se.get(j,'iso_massf','Fe-56'))+float(i.se.get(j,'iso_massf','Fe-57'))+float(i.se.get(j,'iso_massf','Fe-58')) \n\t\t\t\t\tdum_pb = float(i.se.get(j,'iso_massf','Pb-204'))+float(i.se.get(j,'iso_massf','Pb-206'))+float(i.se.get(j,'iso_massf','Pb-207'))+float(i.se.get(j,'iso_massf','Pb-208'))\n\t\t\t\t\tdum_rb = float(i.se.get(j,'iso_massf','Rb-85'))+float(i.se.get(j,'iso_massf','Rb-87'))\n\t\t\t\t\tdum_sr = float(i.se.get(j,'iso_massf','Sr-84'))+float(i.se.get(j,'iso_massf','Sr-86'))+float(i.se.get(j,'iso_massf','Sr-87'))+float(i.se.get(j,'iso_massf','Sr-88'))\n\t\t\t\t\tdum_zr = float(i.se.get(j,'iso_massf','Zr-90'))+float(i.se.get(j,'iso_massf','Zr-91'))+float(i.se.get(j,'iso_massf','Zr-92'))+float(i.se.get(j,'iso_massf','Zr-94'))+float(i.se.get(j,'iso_massf','Zr-96'))\n\t\t\t\t\tdum_y = float(i.se.get(j,'iso_massf','Y-89'))\n\t\t\t\t\tdum_c = float(i.se.get(j,'iso_massf','C-12'))\n\t\t\t\t\tdum_o = float(i.se.get(j,'iso_massf','O-16'))\n\t\t\t\t\tdum_gda = float(i.se.get(j,'iso_massf','Gd-152'))\n\t\t\t\t\tdum_gdb = float(i.se.get(j,'iso_massf','Gd-154'))\n\t\t\t\t\tdum_zra = float(i.se.get(j,'iso_massf','Zr-96'))\n\t\t\t\t\tdum_zrb = float(i.se.get(j,'iso_massf','Zr-94'))\n\n\t\t\t\t\tdum_c=(float((i.se.get((int(j)),'iso_massf','C-12')))+float((i.se.get(j,'iso_massf','C-13'))))\n\t\t\t\t\tdum_o=(float((i.se.get((int(j)),'iso_massf','O-16')))+float((i.se.get(j,'iso_massf','O-17'))))\n\n\t\t\t\t\tdum_c12=(float((i.se.get((int(j)),'iso_massf','C-12'))))\n\t\t\t\t\tdum_c13=(float((i.se.get((int(j)),'iso_massf','C-13'))))\n\n\t\t\t\t\tdum_co.append(((dum_c/dum_o)*(16./12.)))\n\n\t\t\t\t\tfor jj in ls_element:\n\t\t\t\t\t\tdum_ls = dum_ls + float(i.se.get(j,'iso_massf',jj)) #/float(len(ls_element)))\n\t\t\t\t\tfor jj in hs_element:\n\t\t\t\t\t\tdum_hs = dum_hs + float(i.se.get(j,'iso_massf',jj))  #/float(len(hs_element)))\n\t\t\t\t\tfor jj in s_element:\n\t\t\t\t\t\tdum_s = dum_s + float(i.se.get(j,'iso_massf',jj)) #/float(len(s_element)))\n\t\t\t\t\t\n\t\t\t\t\tdum_s_fe.append(log10((dum_s/dum_fe)/(s_ini[k]/fe_ini[k])))\n\t\t\t\t\tdum_ls_fe.append(log10((dum_ls/dum_fe)/(ls_ini[k]/fe_ini[k])))\n\t\t\t\t\tdum_hs_fe.append(log10((dum_hs/dum_fe)/(hs_ini[k]/fe_ini[k])))\n\t\t\t\t\tdum_pb_fe.append(log10((dum_pb/dum_fe)/(pb_ini[k]/fe_ini[k])))\n\t\t\t\t\tdum_hs_ls.append(log10((dum_hs/dum_ls)/(hs_ini[k]/ls_ini[k])))\n\t\t\t\t\tdum_rb_sr.append(log10((dum_rb/dum_sr)/(rb_ini[k]/sr_ini[k])))\n\t\t\t\t\tdum_rb_zr.append(log10((dum_rb/dum_zr)/(rb_ini[k]/zr_ini[k])))\n\t\t\t\t\tdum_sr_y.append(log10((dum_sr/dum_y)/(sr_ini[k]/y_ini[k])))\n\t\t\t\t\tdum_sr_zr.append(log10((dum_sr/dum_zr)/(sr_ini[k]/zr_ini[k])))\n\t\t\t\t\tdum_gd.append((dum_gda/dum_gdb)/(gda_ini[k]/gdb_ini[k]))\n\t\t\t\t\tdum_zrr.append((dum_zra/dum_zrb)/(zra_ini[k]/zrb_ini[k]))\n\t\t\t#                dum_rb_fe.append(log10((dum_rb/dum_fe)/(rb_ini[k]/fe_ini[k]))-0.2) ## correction for Lambert 1995 data\n\t\t\t\t\tdum_rb_fe.append(log10((dum_rb/dum_fe)/(rb_ini[k]/fe_ini[k]))-0.068) ## correction for Zamora 2009 data\n\n\t\t\t\t\tif (len(dum_co)>1):\n\t\t\t\t\t\tif (dum_co[len(dum_co)-1]>(dum_co[len(dum_co)-2]+0.02)):\n\t\t\t\t\t\t\tdum_sr_zr_tps.append(log10((dum_sr/dum_zr)/(sr_ini[k]/zr_ini[k])))\n\t\t\t\t\t\t\tdum_sr_y_tps.append(log10((dum_sr/dum_y)/(sr_ini[k]/y_ini[k])))\n\t\t\t\t\t\t\tdum_s_fe_tps.append(log10((dum_s/dum_fe)/(s_ini[k]/fe_ini[k])))\n\t\t\t\t\t\t\tdum_ls_fe_tps.append(log10((dum_ls/dum_fe)/(ls_ini[k]/fe_ini[k])))\n\t\t\t\t\t\t\tdum_hs_fe_tps.append(log10((dum_hs/dum_fe)/(hs_ini[k]/fe_ini[k])))\n\t\t\t\t\t\t\tdum_pb_fe_tps.append(log10((dum_pb/dum_fe)/(pb_ini[k]/fe_ini[k])))\n\t\t\t\t\t\t\tdum_hs_ls_tps.append(log10((dum_hs/dum_ls)/(hs_ini[k]/ls_ini[k])))\n\t\t\t\t\t\t\tdum_rb_sr_tps.append(log10((dum_rb/dum_sr)/(rb_ini[k]/sr_ini[k])))\n\t\t\t\t\t\t\tdum_rb_zr_tps.append(log10((dum_rb/dum_zr)/(rb_ini[k]/zr_ini[k])))\n\t\t\t#                                dum_rb_fe_tps.append(log10((dum_rb/dum_fe)/(rb_ini[k]/fe_ini[k]))-0.2) ## correction for Lambert 1995 data\n\t\t\t\t\t\t\tdum_rb_fe_tps.append(log10((dum_rb/dum_fe)/(rb_ini[k]/fe_ini[k]))-0.068) ## correction for Zamora 2009 data\n\t\t\t\t\t\t\tdum_gd_tps.append((((dum_gda/dum_gdb)/(gda_ini[k]/gdb_ini[k]))-1)*1000.)\n\t\t\t\t\t\t\tdum_zr_tps.append((((dum_zra/dum_zrb)/(zra_ini[k]/zrb_ini[k]))-1)*1000.)\n\n\t\t\t\t\t\t\tif (dum_co[len(dum_co)-1]>1.):\n\t\t\t\t\t\t\t\tdum_sr_zr_tps_co.append(log10((dum_sr/dum_zr)/(sr_ini[k]/zr_ini[k])))\n\t\t\t\t\t\t\t\tdum_sr_y_tps_co.append(log10((dum_sr/dum_y)/(sr_ini[k]/y_ini[k])))\n\t\t\t\t\t\t\t\tdum_s_fe_tps_co.append(log10((dum_s/dum_fe)/(s_ini[k]/fe_ini[k])))\n\t\t\t\t\t\t\t\tdum_ls_fe_tps_co.append(log10((dum_ls/dum_fe)/(ls_ini[k]/fe_ini[k])))\n\t\t\t\t\t\t\t\tdum_hs_fe_tps_co.append(log10((dum_hs/dum_fe)/(hs_ini[k]/fe_ini[k])))\n\t\t\t\t\t\t\t\tdum_pb_fe_tps_co.append(log10((dum_pb/dum_fe)/(pb_ini[k]/fe_ini[k])))\n\t\t\t\t\t\t\t\tdum_hs_ls_tps_co.append(log10((dum_hs/dum_ls)/(hs_ini[k]/ls_ini[k])))\n\t\t\t\t\t\t\t\tdum_rb_sr_tps_co.append(log10((dum_rb/dum_sr)/(rb_ini[k]/sr_ini[k])))\n\t\t\t\t\t\t\t\tdum_rb_zr_tps_co.append(log10((dum_rb/dum_zr)/(rb_ini[k]/zr_ini[k])))\n\t\t\t###                                        dum_rb_fe_tps_co.append(log10((dum_rb/dum_fe)/(rb_ini[k]/fe_ini[k]))-0.2)\n\t\t\t\t\t\t\t\tdum_rb_zr_tps_co.append(log10((dum_rb/dum_zr)/(rb_ini[k]/zr_ini[k])))\n\t\t\t#                                        dum_rb_fe_tps_co.append(log10((dum_rb/dum_fe)/(rb_ini[k]/fe_ini[k]))-0.2) ## correction for Lambert 1995 data\n\t\t\t\t\t\t\t\tdum_rb_fe_tps_co.append(log10((dum_rb/dum_fe)/(rb_ini[k]/fe_ini[k]))-0.068) ## correction for Zamora 2009 data\n\t\t\t\t\t\t\t\tdum_gd_tps_co.append((((dum_gda/dum_gdb)/(gda_ini[k]/gdb_ini[k]))-1)*1000.)\n\t\t\t\t\t\t\t\tdum_zr_tps_co.append((((dum_zra/dum_zrb)/(zra_ini[k]/zrb_ini[k]))-1)*1000.)\n\t\t\t\t\t\t\tjjjj=jjjj+1\n\t\t\t\t\t\n\t\t\t\t\t#\n\t\t\t\ts_fe.append(dum_s_fe)\n\t\t\t\tls_fe.append(dum_ls_fe)\n\t\t\t\ths_fe.append(dum_hs_fe)\n\t\t\t\tpb_fe.append(dum_pb_fe)\n\t\t\t\ths_ls.append(dum_hs_ls)\n\t\t\t\trb_sr.append(dum_rb_sr)\n\t\t\t\trb_zr.append(dum_rb_zr)\n\t\t\t\trb_fe.append(dum_rb_fe)\n\t\t\t\tsr_y.append(dum_sr_y)\n\t\t\t\tsr_zr.append(dum_sr_zr)\n\t\t\t\tsr_zr_tps.append(dum_sr_zr_tps)\n\t\t\t\tsr_y_tps.append(dum_sr_y_tps)\n\t\t\t\tsr_zr_tps_co.append(dum_sr_zr_tps_co)\n\t\t\t\tsr_y_tps_co.append(dum_sr_y_tps_co)\n\t\t\t\ts_fe_tps.append(dum_s_fe_tps)\n\t\t\t\tls_fe_tps.append(dum_ls_fe_tps)\n\t\t\t\ths_fe_tps.append(dum_hs_fe_tps)\n\t\t\t\tpb_fe_tps.append(dum_pb_fe_tps)\n\t\t\t\ths_ls_tps.append(dum_hs_ls_tps)\n\t\t\t\trb_sr_tps.append(dum_rb_sr_tps)\n\t\t\t\trb_zr_tps.append(dum_rb_zr_tps)\n\t\t\t\trb_fe_tps.append(dum_rb_fe_tps)\n\t\t\t\ts_fe_tps_co.append(dum_s_fe_tps_co)\n\t\t\t\tls_fe_tps_co.append(dum_ls_fe_tps_co)\n\t\t\t\ths_fe_tps_co.append(dum_hs_fe_tps_co)\n\t\t\t\tpb_fe_tps_co.append(dum_pb_fe_tps_co)\n\t\t\t\ths_ls_tps_co.append(dum_hs_ls_tps_co)\n\t\t\t\trb_sr_tps_co.append(dum_rb_sr_tps_co)\n\t\t\t\trb_zr_tps_co.append(dum_rb_zr_tps_co)\n\t\t\t\trb_fe_tps_co.append(dum_rb_fe_tps_co)\n\t\t\t\tgd.append(dum_gd)\n\t\t\t\tzr.append(dum_zrr)\n\t\t\t\tgd_tps.append(dum_gd_tps)\n\t\t\t\tzr_tps.append(dum_zr_tps)\n\t\t\t\tgd_tps_co.append(dum_gd_tps_co)\n\t\t\t\tzr_tps_co.append(dum_zr_tps_co)\n\t\t\t\tco.append(dum_co)\n\t\t\t\tk = k+1\n\n\t\t\tif plotting:\n\n\t\t\t\tmass_label =[]\n\t\t\t\tfor i in run_mass:\n\t\t\t\t\tmini=float(i.se.get('mini'))\n\t\t\t\t\tzini=float(i.se.get('zini'))\n\t\t\t\t\tlabel=str(mini)+'$M_{\\odot}$, Z='+str(zini)\n\t\t\t\t\tmass_label.append(label)\n\n\t\t\t\tmetallicity_label=['3 Msun, Z=0.02','3 Msun, Z=0.02, no mol diff','3 Msun, Z=0.01','M3 set1.2']\n\n\t\t\t\tfig = plt.figure(0)            # Figure object\n\t\t\t\tax = fig.add_subplot(1,1,1)     # Axes object: one row, one column, first plot (one plot!)\n\n\t\t\t\tmpl.rcParams['xtick.major.size'] = 20\n\t\t\t\t#mpl.rcParams['xtick.major.width'] = 4\n\t\t\t\tmpl.rcParams['xtick.minor.size'] = 10\n\t\t\t\t#mpl.rcParams['xtick.minor.width'] = 2\n\t\t\t\t\n\t\t\t\tmpl.rcParams['ytick.major.size'] = 20\n\t\t\t\t#mpl.rcParams['ytick.major.width'] = 4\n\t\t\t\tmpl.rcParams['ytick.minor.size'] = 10\n\t\t\t\t#mpl.rcParams['ytick.minor.width'] = 2\n\t\t\t\t\n\t\t\t\tif hsfe_hsls:\n\t\t\t\t\tarray_to_plot_x = hs_ls\n\t\t\t\t\tarray_to_plot_x_tps = hs_ls_tps\n\t\t\t\t\tarray_to_plot_x_co = hs_ls_tps_co\n\t\t\t\t\t\n\t\t\t\t\tarray_to_plot_y = hs_fe\n\t\t\t\t\tarray_to_plot_y_tps = hs_fe_tps\n\t\t\t\t\tarray_to_plot_y_co = hs_fe_tps_co\n\n\t\t\t\t\tpl.axhline(y=0,linewidth=2, color='k')\n\t\t\t\t\tpl.axvline(x=0,linewidth=2, color='k')\n\t\t\t\t\tfor k in range(0,len(array_to_plot_x)):\n\t\t\t\t\t\t#if k > 0:\n\t\t\t\t\t\tpl.plot(array_to_plot_x[k],array_to_plot_y[k],symbol[k],markersize=10.,linewidth=3.,color=color1)\n\t\t\t\t\t\t#pl.plot(array_to_plot_x[k],array_to_plot_y[k],symbol[k],markersize=10.,linewidth=3.,label=str(metallicity_label[k]))\n\t\t\t\t\t\t#if k >= 1:\n\t\t\t\t\t\tpl.plot(array_to_plot_x_tps[k],array_to_plot_y_tps[k],markers[k],markersize=12.,color=color1)\n\t\t\t\t\t\tpl.plot(array_to_plot_x_co[k],array_to_plot_y_co[k],markers[k],markersize=20.,color=color1,label=str(mass_label[k]))\n\n\t\t\t\t\tpl.legend(numpoints=1,loc=2,prop={'size':20})\n\n\t\t\t\t\tpl.xlabel('[hs/ls]', fontsize=20)\n\t\t\t\t\tpl.ylabel('[hs/Fe]', fontsize=20)\n\t\t\t\t\ty_min = -0.1\n\t\t\t\t\ty_max = 1.0\n\t\t\t\t\tpl.ylim(y_min,y_max)\n\t\t\t\t\tpl.xlim(-0.1,0.5)\n\n\t\t\t\t\tsize=20\n\t\t\t\t\tpl.xticks(size=size)\n\t\t\t\t\tpl.yticks(size=size)\n\n\t\t\t\t\tax = pl.gca()\n\n\t\t\t\t\tfor line in ax.xaxis.get_ticklines():\n\t\t\t\t\t\tline.set_markersize(20)\n\t\t\t\t\t\tline.set_markeredgewidth(3)\n\n\t\t\t\t\tfor line in ax.yaxis.get_ticklines():\n\t\t\t\t\t\tline.set_markersize(20)\n\t\t\t\t\t\tline.set_markeredgewidth(3)\n\n\t\t\t\tif lsfe_hsls:\n\n\t\t\t\t\tarray_to_plot_x = hs_ls\n\t\t\t\t\tarray_to_plot_x_tps = hs_ls_tps\n\t\t\t\t\tarray_to_plot_x_co = hs_ls_tps_co\n\t\t\t\t\t\n\t\t\t\t\tarray_to_plot_y = ls_fe\n\t\t\t\t\tarray_to_plot_y_tps = ls_fe_tps\n\t\t\t\t\tarray_to_plot_y_co = ls_fe_tps_co\n\n\t\t\t\t\tpl.axhline(y=0,linewidth=2, color='k')\n\t\t\t\t\tpl.axvline(x=0,linewidth=2, color='k')\n\t\t\t\t\tfor k in range(0,len(array_to_plot_x)):\n\t\t\t\t\t\t#                if k > 0:\n\t\t\t\t\t\tpl.plot(array_to_plot_x[k],array_to_plot_y[k],symbol[k],markersize=10.,linewidth=4.,label=str(mass_label[k]))\n\t\t\t\t\t\tpl.plot(array_to_plot_x_tps[k],array_to_plot_y_tps[k],markers[k],markersize=12.)\n\t\t\t\t\t\tpl.plot(array_to_plot_x_co[k],array_to_plot_y_co[k],markers[k],markersize=20.)\n\n\t\t\t\t\tpl.legend(numpoints=1,loc='upper right',prop={'size':20})\n\n\t\t\t\t\tpl.xlabel('[hs/ls]', fontsize=20)\n\t\t\t\t\tpl.ylabel('[ls/Fe]', fontsize=20)\n\t\t\t\t\ty_min = -0.1\n\t\t\t\t\ty_max = 0.8\n\t\t\t\t\tpl.ylim(y_min,y_max)\n\t\t\t\t\tpl.xlim(-0.2,0.5)\n\n\t\t\t\t\tsize=20\n\t\t\t\t\tpl.xticks(size=size)\n\t\t\t\t\tpl.yticks(size=size)\n\n\t\t\t\t\tax = pl.gca()\n\n\t\t\t\t\tfor line in ax.xaxis.get_ticklines():\n\t\t\t\t\t\tline.set_markersize(20)\n\t\t\t\t\t\tline.set_markeredgewidth(3)\n\n\t\t\t\t\tfor line in ax.yaxis.get_ticklines():\n\t\t\t\t\t\tline.set_markersize(20)\n\t\t\t\t\t\tline.set_markeredgewidth(3)\n\n\t\t\t\tif rbsr_hsls:\n\t\t\t\t\tarray_to_plot_x = hs_ls\n\t\t\t\t\tarray_to_plot_y = rb_sr\n\n\t\t\t\t\tpl.axhline(y=0,linewidth=2, color='k')\n\t\t\t\t\tpl.axvline(x=0,linewidth=2, color='k')\n\t\t\t\t\tfor k in range(0,len(array_to_plot_x)):\n\t\t\t\t\t\t#                if k > 0:\n\t\t\t\t\t\tif k >= 1:\n\t\t\t\t\t\t\tpl.plot(array_to_plot_x[k],array_to_plot_y[k],symbol[k],markersize=10.,linewidth=4.,label=str(mass_label[k]))\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\tpl.plot(array_to_plot_x[k],array_to_plot_y[k],symbol[k],markersize=10.,linewidth=4.,label=str(mass_label[k]))\n\n\t\t\t\t\tpl.legend(numpoints=1,loc='upper right',prop={'size':20})\n\n\t\t\t\t\tpl.xlabel('[hs/ls]', fontsize=20)\n\t\t\t\t\tpl.ylabel('[Rb/Sr]', fontsize=20)\n\t\t\t\t\ty_min = -0.4\n\t\t\t\t\ty_max = 1.5\n\t\t\t\t\tx = ax.get_position()\n\n\t\t\t\t\tpl.ylim(y_min,y_max)\n\t\t\t\t\tpl.xlim(-0.7,0.4)\n\n\t\t\t\t\tsize=30\n\t\t\t\t\tpl.xticks(size=size)\n\t\t\t\t\tpl.yticks(size=size)\n\n\t\t\t\t\tax = pl.gca()\n\n\t\t\t\t\tfor line in ax.xaxis.get_ticklines():\n\t\t\t\t\t\tline.set_markersize(20)\n\t\t\t\t\t\tline.set_markeredgewidth(3)\n\t\t\t\t\tfor line in ax.yaxis.get_ticklines():\n\t\t\t\t\t\tline.set_markersize(20)\n\t\t\t\t\t\tline.set_markeredgewidth(3)\n\n\t\t\t\tif rbzr_hsls:\n\t\t\t\t\tarray_to_plot_x = hs_ls\n\t\t\t\t\tarray_to_plot_y = rb_zr\n\n\t\t\t\t\tpl.axhline(y=0,linewidth=2, color='k')\n\t\t\t\t\tpl.axvline(x=0,linewidth=2, color='k')\n\t\t\t\t\tfor k in range(0,len(array_to_plot_x)):\n\t\t\t#                if k > 0:\n\t\t\t\t\t\tif k >= 1:\n\t\t\t\t\t\t\tpl.plot(array_to_plot_x[k],array_to_plot_y[k],symbol[k],markersize=10.,linewidth=2.,label=str(mass_label[k]))\n\t\t\t\t\t\t\tpl.plot(hs_ls_tps[k],rb_zr_tps[k],markers[k],markersize=12.)\n\t\t\t\t\t\t\tpl.plot(hs_ls_tps_co[k],rb_zr_tps_co[k],markers[k],markersize=20.)\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\tpl.plot(array_to_plot_x[k],array_to_plot_y[k],symbol[k],markersize=10.,linewidth=2.,label=str(mass_label[k]))\n\t\t\t\t\t\t\tpl.plot(hs_ls_tps[k],rb_zr_tps[k],markers[k],markersize=12.)\n\t\t\t\t\t\t\tpl.plot(hs_ls_tps_co[k],rb_zr_tps_co[k],markers[k],markersize=20.)\n\n\t\t\t\t\tpl.legend(numpoints=1,loc='upper right',prop={'size':20})\n\n\t\t\t\t\tpl.xlabel('[hs/ls]', fontsize=20)\n\t\t\t\t\tpl.ylabel('[Rb/Zr]', fontsize=20)\n\t\t\t\t\ty_min = -0.4\n\t\t\t\t\ty_max = 0.4\n\t\t\t\t\tpl.ylim(y_min,y_max)\n\t\t\t\t\tpl.xlim(-0.5,0.5)\n\n\t\t\t\t\tsize=20\n\t\t\t\t\tpl.xticks(size=size)\n\t\t\t\t\tpl.yticks(size=size)\n\n\t\t\t\t\tax = pl.gca()\n\n\t\t\t\t\tfor line in ax.xaxis.get_ticklines():\n\t\t\t\t\t\tline.set_markersize(20)\n\t\t\t\t\t\tline.set_markeredgewidth(3)\n\n\t\t\t\t\tfor line in ax.yaxis.get_ticklines():\n\t\t\t\t\t\tline.set_markersize(20)\n\t\t\t\t\t\tline.set_markeredgewidth(3)\n\n\t\t\t\tif rbfe_sfe:\n\n\t\t\t\t\tarray_to_plot_x = s_fe\n\t\t\t\t\tarray_to_plot_y = rb_fe\n\n\t\t\t\t\tpl.axhline(y=0,linewidth=3, color='k')\n\t\t\t\t\tpl.axvline(x=0,linewidth=3, color='k')\n\t\t\t\t\tfor k in range(0,len(array_to_plot_x)):\n\t\t\t#                if k > 0:\n\t\t\t\t\t\tif k >= 1:\n\t\t\t#                        pl.plot(array_to_plot_x[k],array_to_plot_y[k],symbol[k],markersize=10.,linewidth=2.,label=str(mass_label[k])+'Msun '+str(metallicity_label[k]))\n\t\t\t\t\t\t\tpl.plot(array_to_plot_x[k],array_to_plot_y[k],symbol[k],markersize=10.,linewidth=2.,label=str(metallicity_label[k]))\n\t\t\t\t\t\t\tpl.plot(s_fe_tps[k],rb_fe_tps[k],markers[k],markersize=12.)\n\t\t\t\t\t\t\tpl.plot(s_fe_tps_co[k],rb_fe_tps_co[k],markers[k],markersize=20.)\n\t\t\t\t\t\telse:\n\t\t\t#                        pl.plot(array_to_plot_x[k],array_to_plot_y[k],symbol[k],markersize=10.,linewidth=2.,label=str(mass_label[k])+'Msun '+str(metallicity_label[k]))\n\t\t\t\t\t\t\tpl.plot(array_to_plot_x[k],array_to_plot_y[k],symbol[k],markersize=10.,linewidth=2.,label=str(metallicity_label[k]))\n\t\t\t\t\t\t\tpl.plot(s_fe_tps[k],rb_fe_tps[k],markers[k],markersize=12.)\n\t\t\t\t\t\t\tpl.plot(s_fe_tps_co[k],rb_fe_tps_co[k],markers[k],markersize=20.)\n\n\t\t\t\t\tpl.legend(numpoints=1,loc=4,prop={'size':20})\n\n\t\t\t\t\tpl.xlabel('[s/Fe]', fontsize=20)\n\t\t\t\t\tpl.ylabel('[Rb/Fe]', fontsize=20)\n\t\t\t\t\ty_min = -0.4\n\t\t\t\t\ty_max = 0.4\n\t\t\t\t\tpl.ylim(y_min,y_max)\n\t\t\t\t\tpl.xlim(-0.1,2.0)\n\n\t\t\t\t\tsize=20\n\t\t\t\t\tpl.xticks(size=size)\n\t\t\t\t\tpl.yticks(size=size)\n\n\t\t\t\t\tax = pl.gca()\n\n\t\t\t\t\tfor line in ax.xaxis.get_ticklines():\n\t\t\t\t\t\tline.set_markersize(25)\n\t\t\t\t\t\tline.set_markeredgewidth(3)\n\n\t\t\t\t\tfor line in ax.yaxis.get_ticklines():\n\t\t\t\t\t\tline.set_markersize(25)\n\t\t\t\t\t\tline.set_markeredgewidth(3)\n\n\t\t\t\tif sry_srzr:\n\t\t\t\t\tarray_to_plot_x = sr_zr\n\t\t\t\t\tarray_to_plot_y = sr_y\n\n\t\t\t\t\tpl.axhline(y=0,linewidth=2, color='k')\n\t\t\t\t\tpl.axvline(x=0,linewidth=2, color='k')\n\t\t\t\t\tfor k in range(0,len(array_to_plot_x)):\n\t\t\t\t\t\tif k >= 1:\n\t\t\t\t\t\t\t#                if k > 0:\n\t\t\t\t\t\t\tpl.plot(array_to_plot_x[k],array_to_plot_y[k],symbol[k],markersize=10.,linewidth=3.5,label=str(metallicity_label[k]))\n\t\t\t\t\t\t\tpl.plot(sr_zr_tps[k],sr_y_tps[k],markers[k],markersize=12.)\n\t\t\t\t\t\t\tpl.plot(sr_zr_tps_co[k],sr_y_tps_co[k],markers[k],markersize=20.)\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\tpl.plot(array_to_plot_x[k],array_to_plot_y[k],symbol[k],markersize=10.,linewidth=3.5,label=str(metallicity_label[k]))\n\t\t\t\t\t\t\tpl.plot(sr_zr_tps[k],sr_y_tps[k],markers[k],markersize=12.,label='C/O < 1')\n\t\t\t\t\t\t\tpl.plot(sr_zr_tps_co[k],sr_y_tps_co[k],markers[k],markersize=20.,label='C/O > 1')\n\n\t\t\t\t\tpl.xlabel('[Sr/Zr]', fontsize=20)\n\t\t\t\t\tpl.ylabel('[Sr/Y]', fontsize=20)\n\t\t\t\t\ty_min = -0.1\n\t\t\t\t\ty_max = 0.1\n\t\t\t\t\tpl.ylim(y_min,y_max)\n\t\t\t\t\tpl.xlim(-0.3,0.3)\n\t\t\t\t\t\n\t\t\t\t\tsize=20\n\t\t\t\t\tpl.xticks(size=size)\n\t\t\t\t\tpl.yticks(size=size)\n\n\t\t\t\t\tax = pl.gca()\n\n\t\t\t\t\tfor line in ax.xaxis.get_ticklines():\n\t\t\t\t\t\tline.set_markersize(25)\n\t\t\t\t\t\tline.set_markeredgewidth(3)\n\n\t\t\t\t\tfor line in ax.yaxis.get_ticklines():\n\t\t\t\t\t\tline.set_markersize(25)\n\t\t\t\t\t\tline.set_markeredgewidth(3)\n\n\t\t\t\t\tbox = ax.get_position()\n\n\t\t\t\t\tax.set_position([box.x0, box.y0, box.width * 0.9, box.height])\n\n\t\t\t\t\tpl.legend(loc=2, borderaxespad=1.0,prop={'size':25})\n\n\t\t\tbox = ax.get_position()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nplot the mass of the C - 12 and O - 16 surfaces.", "response": "def set_plot_CO_mass(self,fig=3123,xaxis='mass',linestyle=['-'],marker=['o'],color=['r'],age_years=True,sparsity=500,markersparsity=200,withoutZlabel=False,t0_model=[]):\n\t\t\n\t\t'''\n\t\t\tPLots C/O surface number fraction\n\t\t'''\n\n\t\tif len(t0_model)==0:\n\t\t\tt0_model = len(self.runs_H5_surf)*[0]\n\n\t\tplt.figure(fig)\n                for i in range(len(self.runs_H5_surf)):\n                        sefiles=se(self.runs_H5_surf[i])\n\t\t\tcycles=range(int(sefiles.se.cycles[0]),int(sefiles.se.cycles[-1]),sparsity)\n\t\t\tmini=sefiles.get(\"mini\")\n\t\t\tzini=sefiles.get(\"zini\")\n\t\t\tlabel=str(mini)+'$M_{\\odot}$, Z='+str(zini)\n\t\t\tif xaxis=='cycles':\n\t\t\t\tx=cycles\n\t\t\tif xaxis=='age':\n\t\t\t\tx=sefiles.get(cycles,'age')\n                        \tif age_years==True:\n                                \tx=np.array(x)*sefiles.get('age_unit')/(365*24*3600)\n\t\t\t\tx = x - x[t0_model[i]]\n\t\t\tif xaxis=='mass':\n\t\t\t\tx=sefiles.get(cycles,'mass')\n\t\t\tx=x[t0_model[i]:]\n\t\t\tc12=sefiles.get(cycles,'C-12')[t0_model[i]:]\n\t\t\to16=sefiles.get(cycles,'O-16')[t0_model[i]:]\n\t\t\tif withoutZlabel==True:\n\t\t\t\tplt.plot(x,4./3.*np.array(c12)/np.array(o16),label=label.split(',')[0],marker=marker[i],linestyle=linestyle[i],markevery=markersparsity,color=color[i])\n\n\t\t\telse:\n\t\t\t\tplt.plot(x,4./3.*np.array(c12)/np.array(o16),label=label,marker=marker[i],linestyle=linestyle[i],markevery=markersparsity,color=color[i])\n\t\t\tif xaxis=='mass':\n\t\t\t\tplt.xlim(7,0.5)\n\t\t\t\t#plt.gca().invert_xaxis()\t\n\t                        plt.xlabel('$M/M_{\\odot}$',fontsize=18)\n\t\n                        plt.ylabel('C/O Ratio', fontsize=18)\n\t\t\tplt.legend(loc=1)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef set_plot_surface_abu(self,fig=2,species=['Sr-88','Ba-136'],decay=False,number_frac=False,xaxis='cycles',age_years=False,ratio=False,sumiso=False,eps=False,samefigure=False,samefigureall=False,withkip=False,sparsity=200,linestyle=['--'],marker=['o'],color=['r'],label=[],markevery=100,t0_model=-1,savefig=''):\n\t\t\n\t\t'''\t\n\t\t\tSimply plots surface abundance versus model number or time\n\n\t\t'''\n\t\textralabel=False\n\t\tif len(label)>0:\n\t\t\textralabel=True\n                import nugridse as mp\n                import utils as u\n\t\tidx=0\n\t\tif eps==True:\n\t\t\tspecies= species + ['H-1']\n\t\tif samefigureall==True and ratio==False:\n\t\t\tplt.figure(fig)\n                for i in range(len(self.runs_H5_surf)):\n\t\t\tidx=0\n                        sefiles=mp.se(self.runs_H5_surf[i])\n\t\t\tif samefigure==True:\n\t\t\t\tplt.figure(i)\n\t\t\tcycles=range(int(sefiles.se.cycles[0]),int(sefiles.se.cycles[-1]),sparsity)\n\t\t\tmini=sefiles.get(\"mini\")\n\t\t\tzini=sefiles.get(\"zini\")\n\t\t\tif not extralabel:\n\t\t\t\tlabel1=str(mini)+'$M_{\\odot}$, Z='+str(zini)\n\t\t\tif xaxis=='cycles':\n\t\t\t\tx=cycles\n\t\t\tif xaxis=='age':\n\t\t\t\tx=sefiles.get(cycles,'age')\n\t\t\t\tif age_years==True:\n\t\t\t\t\tx=np.array(x)*sefiles.get('age_unit')/(365*24*3600)\n\t\t\t\t\tprint 'x is age'\n\t\t\t\tif t0_model>0:\n\t\t\t\t\t#print cycles\n\t\t\t\t\tidxt0=0\n\t\t\t\t\tfor kk in range(len(cycles)):\n\t\t\t\t\t\tprint int(cycles[kk]),t0_model\n\t\t\t\t\t\tif int(cycles[kk]) == t0_model:\n\t\t\t\t\t\t\tidxt0=kk\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\tprint 'found t0_model idx',idxt0\n\t\t\t\t\t#idxt0=cycles.index(t0_model)\n\t\t\t\t\tcycles=cycles[idxt0:]\n\t\t\t\t\tif idxt0==0:\n\t\t\t\t\t\tprint 'Warning, t0modle not found'\n\t\t\t\t\tx=x[idxt0:] - x[idxt0]\n\t\t\t\telse:\n\t\t\t\t\tidxt0=0\n\t\t\tif xaxis=='mass':\n\t\t\t\tx=sefiles.get(cycles,'mass')\n\t\t\tif decay==False:\n\t\t\t\t\n\t\t\t\tspecies_abu1=sefiles.get(cycles,species)\n\t\t\telse:\n\t\t\t\tspecies_abu11=sefiles.get(cycles,'iso_massf_decay')\n\t\t\t\tspecies_abu1=[]\n\t\t\t\tfor jj in range(len(cycles)):\n\t\t\t\t    species_abu1.append([])\t\n\t\t\t\t    for j in range(len(species)):\n\t\t\t\t\tspecies_abu1[-1].append(species_abu11[jj][sefiles.se.isotopes.index(species[j])])\n\n\t\t\tif len(species)==1:\n\t\t\t\tspecies_abu11=[]\n\t\t\t\tfor kk in range(len(species_abu1)):\n\t\t\t\t\tspecies_abu11.append([species_abu1[kk]])\n\t\t\t\tspecies_abu1=species_abu11\t\n\t\t\tspecies_abu=[]\n\t\t\tfor k in range(len(species)):\n\t\t\t\tprint 'species ',k\n\t\t\t\tspecies_abu.append([])\n\t\t\tfor k in range(len(species)):\n\t\t\t\tfor h in range(len(cycles)):\n\t\t\t\t\tspecies_abu[k].append(species_abu1[h][k])\n\t\t\t#print species_abu\n\t\t\t#if t0_model>0:\n\t\t#\t\tspecies_abu=species_abu[t0_model:]\n\t\t\tfor k in range(len(species)):\n\t\t\t\tif samefigure==False and ratio==False:\n\t\t\t\t\tfig=plt.figure(species[k])\n\t\t\t\tif xaxis=='cycles':\n\t\t\t\t\tplt.xlabel('model number')\n\t\t\t\tif xaxis=='age':\n\t\t\t\t\tplt.xlabel('Age [yrs]')\n\t\t\t\tif xaxis=='mass':\n\t\t\t\t\tplt.xlabel('$M/M_{\\odot}$')\n\t\t\t\tplt.ylabel('X$_i$')\n\t\t\t\tif ratio==True:\n\t\t\t\t\tcontinue\n\t\t\t\tif extralabel:\n\t\t\t\t\tlabel=label[k]\n\t\t\t\telse:\n\t\t\t\t\tlabel=label1\n\t\t\t\tif samefigure==True:\n\t\t\t\t\tif sumiso == True:\n\t\t\t\t\t\tsumiso_massfrac=np.array(species_abu[0])\n\t\t\t\t\t\tfor hh in range(1,len(species_abu)):\n\t\t\t\t\t\t\tsumiso_massfrac = sumiso_massfrac + np.array(species_abu[hh])\n\t\t\t\t\t\tplt.plot(x,sumiso_massfrac,linestyle=linestyle[idx],marker=marker[idx],label=species[k]+', '+label,color=color[idx],markevery=markevery)\n\t\t\t\t\t\tbreak #leave iso looop \n\t\t\t\t\t\n\t\t\t\t\telse:\n                                                if eps==True:\n                                                        species_abu[0]=np.log10(np.array(species_abu[0])/(np.array(species_abu[1])*7))   + 12.\n\n\t\t\t\t\t\tplt.plot(x,species_abu[k],linestyle=linestyle[idx],marker=marker[idx],label=species[k]+', '+label,color=color[idx],markevery=markevery)\n\t\t\t\t\tidx+=1\n\t\t\t\t\tif eps==True:\n\t\t\t\t\t\tbreak\n\n\t\t\t\telse:\n\t\t\t\t\tif withkip==True:\n\t\t\t\t\t\tprint 'test'\n\t\t\t\t\telse:\n\t\t\t\t\t\tplt.ylabel('X('+species[k]+')')\n                                                if eps==True:\n                                                        species_abu[0]=np.log10(np.array(species_abu[0])/(np.array(species_abu[1])*7))   + 12.\n\n\t\t\t\t\t\tplt.plot(x,species_abu[k],linestyle=linestyle[i],marker=marker[i],label=label,color=color[i],markevery=markevery)\n                                        if eps==True:\n                                                break\n\t\t\t\t\t\t\n\t\t\t\tplt.legend(loc=2)\n\t\t\t\tplt.yscale('log')\n\t\t\tif ratio==True:\n\t\t\t\tif number_frac==True:\n\t\t\t\t\tprint 'plot number frac'\n\t\t\t\t\tplt.plot(x,4./3.*np.array(species_abu[1])/np.array(species_abu[0]),linestyle=linestyle[i],marker=marker[i],label=label,color=color[i],markevery=markevery)\n\t\t\t\telse:\n\t\t\t\t\tplt.plot(x,np.array(species_abu[1])/np.array(species_abu[0]),linestyle=linestyle[i],marker=marker[i],label=label,color=color[i],markevery=markevery)\n                                plt.legend(loc=2)\n                                plt.yscale('log')\n\t\t\tname='M'+str(mini)+'Z'+str(zini)\n\t\t\tplt.legend(loc=4)\n\t\t\tplt.savefig(savefig+'/surf_'+name+'.png')", "response": "Set plot of the surface abundance versus model number or time."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsets the plot_profile_decay method for the HRDs run", "response": "def set_plot_profile_decay(self,cycles=20*[-1],mass_range=20*[[0,0]],ylim=20*[[0,0]],isotopes=[],linestyle=[],save_dir=''): \n\t\t'''\n\t\t\tPlots HRDs\n\n\n\t\t\tend_model - array, control how far in models a run is plottet, if -1 till end\n\t\t\tsymbs_1  - set symbols of runs\n\t\t'''\n\t\tif len(linestyle)==0:\n\t\t\tlinestyle=200*['-']\n\t\timport nugridse as mp\n\t\timport utils as u\n\t\t#print self.runs_H5_restart\n                for i in range(len(self.runs_H5_restart)):\n        \t\tsefiles=mp.se(self.runs_H5_restart[i])\n\t\t\tcycle=cycles[i]\n                        if cycle==-1:\n                                cycle=int(sefiles.se.cycles[-1])\t\t\t\n\t\t\tif mass_range[i][0] ==0 and mass_range[i][1]==0:\n\t\t\t\tmass_range[i][1]=sefiles.get(cycle,'mass')[-1]\t\t\t\t\n\t\t\tsefiles.read_iso_abund_marco(mass_range[i],cycle)\n\t\t    \tu.stable_specie()\n\t\t    \tsefiles.decay(sefiles.mass_frac)\n\t\t\tidx_species=[]\n\t\t\tfor k in range(len(isotopes)):\n\t\t\t\tother_name_scheme=isotopes[k].split(\"-\")[0].upper()+(5-len(isotopes[k])+1)*\" \"+isotopes[k].split(\"-\")[1]\n\t\t\t\t#other_name_scheme=other_name_scheme.capitalize()\n\n\t\t\t\tidx_specie=u.back_ind[other_name_scheme]\n\t\t\t\tidx_species.append(idx_specie)\n\t\t\tmass_abu_array=[]\n\t\t\tfor idx_specie in idx_species:\n\t\t\t\tmass_abu_array.append([])\n\t\t\t\tfor idx_mass in range(len(mp.decayed_multi_d)):\n\t\t\t\t\tmass_abu_array[-1].append(mp.decayed_multi_d[idx_mass][idx_specie])\n\t\t\t\t\t\n\t\t\t#plotting\n\t\t\tplt.figure(self.run_dirs_name[i])\n\t\t\t#print len(mp.used_masses),len(mass_abu_array[0])\n\t\t\t#print mass_abu_array[0]\n\t\t\tfor k in range(len(isotopes)):\n\t\t\t\tplt.plot(mp.used_masses,mass_abu_array[k],linestyle=linestyle[k],label=isotopes[k])\n\t\t\tplt.legend()\n\t\t\tplt.yscale('log')\n\t\t\t#print sefiles.get(cycle,'mass')[-1]\n\t\t\tplt.xlabel('M/Msun')\n\t\t\tplt.ylabel('$X_i$')\n\t\t\tplt.xlim(mass_range[i][0],mass_range[i][1])\n\t\t\tif (ylim[i][0]>0 or ylim[i][1]>0) or (ylim[i][0]>0 and ylim[i][1]>0):\n\t\t\t\tplt.ylim(ylim[i][0],ylim[i][1])\n\t\t\tif len(save_dir)>0:\n\t\t\t\tstar_mass=sefiles.get(\"mini\")\n\t\t\t\tstar_z=sefiles.get(\"zini\")\n\t\t\t\tplt.savefig(save_dir+'/'+self.run_dirs_name[i]+'_decay_profiles.png')"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef set_get_abu_distr_decay_old(self,cycles=20*[-1],mass_range=20*[[0,0]],ylim=20*[[0,0]],isotopes=['all'],linestyle=[],save_dir=''): \n\t\t'''\n\t\t\tPlots HRDs\n\n\n\t\t\tend_model - array, control how far in models a run is plottet, if -1 till end\n\t\t\tsymbs_1  - set symbols of runs\n\t\t'''\n\t\tif len(linestyle)==0:\n\t\t\tlinestyle=200*['-']\n\t\timport nugridse as mp\n\t\timport utils as u\n\t\tprint self.runs_H5_restart\n\t\tmassfrac_all=[]\n\t\tiso_all=[]\n                for i in range(len(self.runs_H5_restart)):\n        \t\tsefiles=mp.se(self.runs_H5_restart[i])\n\t\t\tcycle=cycles[i]\n                        if cycle==-1:\n                                cycle=int(sefiles.se.cycles[-1])\t\t\t\n\t\t\tif mass_range[i][0] ==0 and mass_range[i][1]==0:\n\t\t\t\tmass_range[i][1]=sefiles.get(cycle,'mass')[-1]\t\t\t\t\n\t\t\tsefiles.read_iso_abund_marco(mass_range[i],cycle)\n\t\t    \tu.stable_specie()\n\t\t    \tsefiles.decay(sefiles.mass_frac)\n\t\t\tidx_species=[]\n\t\t\tmassfrac=[]\n\t\t\tiso=[]\n\t\t\tif not isotopes[0]=='all':\n\t\t\t\tfor k in range(len(isotopes)):\n\t\t\t\t\tother_name_scheme=isotopes[k].split(\"-\")[0].upper()+(5-len(isotopes[k])+1)*\" \"+isotopes[k].split(\"-\")[1]\n\t\t\t\t\t#other_name_scheme=other_name_scheme.capitalize()\n\n\t\t\t\t\tidx_specie=u.back_ind[other_name_scheme]\n\t\t\t\t\tidx_species.append(idx_specie)\n\t\t\t\t\tmassfrac.append(average_massfrac_decay[idx_specie])\n\t\t\t\tiso=isotopes\n\t\t\telse:\n\t\t\t\tmassfrac=mp.average_mass_frac_decay\n\t\t\t\tother_name_scheme=u.back_ind\n\t\t\t\tiso=[]\n\t\t\t\timport re\n\t\t\t\tfor kk in range(len(other_name_scheme)):\n\t\t\t\t\tlist1=re.split('(\\d+)',other_name_scheme[kk])\n\t\t\t\t\tnewname=list1[0].capitalize()+'-'+list1[1]\n\t\t\t\t\tiso.append(newname)\n\t\t\tmassfrac_all.append(massfrac)\n\t\t\tiso_all.append(iso)\n\n\t\treturn iso_all,massfrac_all", "response": "set the get_abu_distr_decay_old method"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef set_cores_massive(self,filename='core_masses_massive.txt'):\n\n\t\t'''\n\t\t\tUesse function cores in nugridse.py\n\t\t'''\n\t\t\n\t\tcore_info=[]\n\t\tminis=[]\n                for i in range(len(self.runs_H5_surf)):\n                        sefiles=se(self.runs_H5_out[i])\n\t\t\tmini=sefiles.get('mini')\n\t\t\tminis.append(mini)\n\t\t\tincycle=int(sefiles.se.cycles[-1])\n\t\t\tcore_info.append(sefiles.cores(incycle=incycle))\n\t\tprint_info=''\n                for i in range(len(self.runs_H5_surf)):\n\t\t\tif i ==0:\n\t\t\t\tprint 'Following returned for each initial mass'\n\t\t\t\tprint core_info[i][1]\n                        #print '----Mini: ',minis[i],'------'\n\t\t\tprint_info+=(str(minis[i])+' & ')\n\t\t\tinfo=core_info[i][0]\n\t\t\tfor k in range(len(info)):\n\t\t\t\tprint_info+=('{:.3E}'.format(float(core_info[i][0][k]))+' & ')\n\t\t\tprint_info=(print_info+'\\n')\n\t\t\t#print core_info[i][2]\n\t\tf1=open(filename,'a')\n\t\tf1.write(print_info)\n\t\tf1.close()", "response": "set_cores_massive - Set the cores in nugridse. py"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_fallback_coord(self,isotope='Ni-56',masslimit=0.1,masscutlim=False,delay=True):\n\n\t\t'''\n\t\t\tReturns fallback mass coordinate so that the amount of masslimit\n\t\t\tof the isotope isotope is ejected. Explosion type chosen with delay option.\n\t\t\t\n\t\t\tmasscutlim: If true, new fallback coordinate can only as small as the original fallback\n\t\t\t\t  prescription by C. Fryer. Useful for more massive stars which would not eject any metals\n\t\t \t\twith Freyer's prescription.\n\t\t'''\n\n\t\tdef getmasscut(m_ini,z_ini,delay): \n\t\t\tif int(m_ini)==12:\n\t\t\t\tm_ini=15\n\t\t\tz_metal=z_ini/0.02\n\n\t\t\tprint 'MINI',m_ini,z_metal\n\t\t\tif ((m_ini>=11.) and (m_ini<30.)):\n\t\t\t\tif delay==True:\n\t\t\t\t\tmass_cut = 1.1 + 0.2*np.exp((m_ini-11.0)/4.) - (2.0 + z_metal)*np.exp(0.4*(m_ini -26.0))\n\t\t\t\t####rapid cc\n\t\t\t\telse:\n\t\t\t\t\tif m_ini<22.:\n\t\t\t\t\t\tmass_cut= 1.1 +0.2*np.exp((m_ini-11.0)/7.5) + 10*(1.0+z_metal)*np.exp(-(m_ini-23.5)**2/(1.0+z_metal)**2)\n\t\t\t\t\telif m_ini<30 :\n\t\t\t\t\t\tmass_cut=  1.1 + 0.2*np.exp((m_ini-11.0)/4.) - (2.0 + z_metal)*np.exp(0.4*(m_ini -26.0)) - 1.85 + 0.25*z_metal +10.0*(1.0+z_metal)*np.exp(-(m_ini-23.5)**2/(1.0+z_metal)**2)\n\t\t\t##at higher mass difference\n\t\t\telif ((m_ini>30) and (m_ini<50)):\n\t\t\t\t#delay\n\t\t\t\tif delay==True:\n\t\t\t\t\tmass_cut= min( 33.35 + (4.75 + 1.25*z_metal)*(m_ini-34.),m_ini-z_metal**0.5 *(1.3*m_ini - 18.35))\n\t\t\t\telse:\n\t\t\t\t\tmass_cut = min( 33.35 + (4.75 + 1.25*z_metal)*(m_ini-34.),m_ini-z_metal**0.5 *(1.3*m_ini - 18.35)) - 1.85 + z_metal*(75. -m_ini)/20.\n\t\t\telif m_ini>50:\n\t\t\t\t#Page 7, Fryer12, only at solar Z valid\n\t\t\t\tif z_metal==1:\n\t\t\t\t\tif m_ini<90.:\n\t\t\t\t\t\tmass_cut = 1.8 + 0.04*(90. - m_ini)\n\t\t\t\t\telse:\n\t\t\t\t\t\tmass_cut = 1.8 + np.log10(m_ini - 89.)\n\t\t\t\t#The part below will probably never be used\n\t\t\t\tif z_metal <1:\n\t\t\t\t\tif m_ini<90.:\n\t\t\t\t\t\tmass_cut = max(min( 33.35 + (4.75 + 1.25*z_metal)*(m_ini-34.),m_ini-z_metal**0.5 *(1.3*m_ini - 18.35)),1.8 + 0.04*(90. - m_ini))\n\t\t\t\t\telse:\n\t\t\t\t\t\tmass_cut = max(min( 33.35 + (4.75 + 1.25*z_metal)*(m_ini-34.),m_ini-z_metal**0.5 *(1.3*m_ini - 18.35)),1.8 + np.log10(m_ini - 89.))\n\n\t\t\tmass_cut=round(mass_cut,2)\n\t\t\t\t\t\t   \n\t\t\treturn mass_cut\t\n\t\n\t\tfallback_coords=[]\n\t\torig_fallback=[]\n\t\tminis=[]\n\t\tni56_mass_all=[]\n\t\to16_mass_all=[]\n                for i in range(len(self.runs_H5_surf)):\n                        sefiles=se(self.runs_H5_restart[i])\n\t\t\tm_ini=sefiles.get(\"mini\")\n\t\t\tz_ini=sefiles.get(\"zini\")\n\t\t\tminis.append(m_ini)\n\t\t\tmass_cut=getmasscut(m_ini,z_ini,delay)\n\t\t\tprint 'mass cut',mass_cut\t\t\n\t\t\tcycle=int(sefiles.se.cycles[-1])\n\t\t\tmass_cycle=sefiles.get(cycle,\"mass\")\n\t\t\tmass_limit=mass_cycle[-1] #maximum mass_test can be\n\t\t\tidx_start=min(range(len(mass_cycle)), key=lambda i: abs(mass_cycle[i]-mass_cut))\n\t\t\tni56_frac=sefiles.get(cycle,'Ni-56')\n\t\t\to16_frac=sefiles.get(cycle,'O-16')\n\t\t\tdeltam=mass_cycle[1:]-mass_cycle[:-1]\n\t\t\tni56_mass=0\n\t\t\to16_mass=0\n\t\t\tni56_mass_orig=0\n\t\t\tnewremnant=mass_cut\n\t\t\t#go fromm outside to the inside\n\t\t\tfor k in range(len(mass_cycle)-1)[::-1]:\n\t\t\t\tcellm=deltam[k]*ni56_frac[k]\n\t\t\t\t#in case fallback coordinate should not be smaller then mass_cut (fryer)\n\t\t\t\tif masscutlim==True:\n\t\t\t\t\tif mass_cycle[k]<mass_cut:\n\t\t\t\t\t\tbreak\n\t\t\t\tif ni56_mass>masslimit:\n\t\t\t\t\tnewremnant=mass_cycle[k]\n\t\t\t\t\tprint 'found new  remnant',newremnant,'ni56:',ni56_mass\n\t\t\t\t\tbreak\n\t\t\t\tni56_mass+=cellm\n\t\t\t\to16_mass+= (deltam[k]*o16_frac[k])\n\t\t\tif newremnant == mass_limit:\n\t\t\t\tprint 'Ni-56 does not reach 0.1Msun, take old remnant',newremnant\n\t\t\tfallback_coords.append(newremnant)\n\t\t\torig_fallback.append(mass_cut)\n\t\t\tni56_mass_all.append(ni56_mass)\n\t\t\to16_mass_all.append(o16_mass)\n\t\tprint '########Results:######'\n\t\tfor k in range(len(minis)):\n\t\t\tprint 'Initial mass: '+str(minis[k])+'Original fallback coord (fryer): '+str(orig_fallback[k])+',New fallback coord: '+str(fallback_coords[k])+'Ni-56 ejected: '+str(ni56_mass_all[k])+'O16: '+str(o16_mass_all[k])\n\n\n\t\treturn minis, fallback_coords", "response": "Returns the fallback mass coordinate for the given isotope."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nset burnstages_upgrade_massive to True for all burnstages in the H5 file.", "response": "def set_burnstages_upgrade_massive(self):\n\t\t'''\n\t\t\tOutputs burnign stages as done in burningstages_upgrade (nugridse)\n\t\t'''\n\t\tburn_info=[]\n\t\tburn_mini=[]\n                for i in range(len(self.runs_H5_surf)):\n                        sefiles=se(self.runs_H5_out[i])\n\t\t\tburn_info.append(sefiles.burnstage_upgrade())\n                        mini=sefiles.get('mini')\n                        #zini=sefiles.get('zini')\n\t\t\tburn_mini.append(mini)\n\t\tfor i in range(len(self.runs_H5_surf)):\n\t\t\tprint 'Following returned for each initial mass'\n\t\t\tprint '[burn_cycles,burn_ages, burn_abun, burn_type,burn_lifetime]'\n\t\t\tprint '----Mini: ',burn_mini[i],'------'\n\t\t\tprint burn_info[i]"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset plot_CC_T_rho_new - set temperature of new run", "response": "def set_plot_CC_T_rho_new(self,fig='CC evol',linestyle=['-'],burn_limit=0.997,color=['r'],marker=['o'],markevery=500): \n\t\t'''\n\t\t\tPlots \n\t\t\tend_model - array, control how far in models a run is plottet, if -1 till end\n\t\t\tsymbs_1  - set symbols of runs\n\t\t'''\n\t\tif len(linestyle)==0:\n\t\t\tlinestyle=200*['-']\n\t\tplt.figure(fig)\n                for i in range(len(self.runs_H5_surf)):\n                        sefiles=se(self.runs_H5_out[i])\n\t\t\tt1_model=-1\n                        mini=sefiles.get('mini')\n\t\t\tzini=sefiles.get('zini')\n\t\t\tlabel=str(mini)+'$M_{\\odot}$, Z='+str(zini)\n                        model=sefiles.se.cycles\n                        model_list=[]\n                        for k in range(0,len(model),1):\n                                model_list.append(model[k])\n\t\t\tprint 'REad Rho,T, this might take a while...'\n                        rho1=sefiles.get(model_list,'rho')   #[:(t1_model-t0_model)]\n                        T1=sefiles.get(model_list,'temperature')#[:(t1_model-t0_model)]\n\t\t\tprint 'finished'\n                        rho=[]\n                        T=[]\n\t\t\tT_unit=sefiles.get('temperature_unit')\n\t\t\tlabeldone=False\n\t\t\tfor k in range(len(model_list)):\n\t\t\t\t#print 'test model ',model_list[k]\n                                t9max=max(np.array(T1[k])*T_unit/1.e9)\n                                #T.append(max(t9))\n\t\t\t\trho1max=max(rho1[k])\n\t\t\t\tprint 'model',model_list[k]\n\t\t\t\tprint 'maxT, maxrho'\n\t\t\t\tprint t9max,rho1max\n\t\t\t\tif k==0:\n\t\t\t\t\tt9_prev=t9max\n\t\t\t\t\trho1_prev=rho1max\n\t\t\t\t\tidx_T=0\n\t\t\t\t\tidx_rho=0\n\t\t\t\t\tcontinue\n\t\t\t\tif t9max>t9_prev:\n\t\t\t\t\tidx_T=k\n\t\t\t\t\tt9_prev=t9max\n\t\t\t\tif rho1max>rho1_prev:\n\t\t\t\t\tidx_rho=k\n\t\t\t\t\trho1_prev=rho1max\n\t\t\tprint 'found highest rho',idx_rho,max(np.array(T1[idx_rho])*T_unit/1.0e9),max(rho1[idx_rho]),model_list[idx_rho]\n\t\t\tprint 'found highest T',idx_T,max(np.array(T1[idx_T])*T_unit/1.0e9),max(rho1[idx_T]),model_list[idx_T]\n\t\t\tif idx_T==idx_rho:\n\t\t\t\tx=np.array(T1[idx_T])*T_unit/1e9\n\t\t\t\ty=rho1[idx_T]\n\t\t\t\trho1=[]\t\n\t\t\t\tT1=[]\n\t\t\t\tfor k in range(len(x)):\n\t\t\t\t    if not y[k]==1.0:\n\t\t\t        \trho1.append(y[k])\n        \t\t\t\tT1.append(x[k])\n\t\t\t\tx=T1\n\t\t\t\ty=rho1\n\t\t\t\tplt.plot(x,y,label=label,color=color[i],marker=marker[i],linestyle=linestyle[i],markevery=markevery)\n                                #rhoi.append(max(rho1[k]))\t       \n\t\t\telse:\n\t\t\t\t#for max T\n\t\t\t\tx=np.array(T1[idx_T])*T_unit/1e9\n\t\t\t\ty=rho1[idx_T]\n                                rho_temp=[]\n                                T_temp=[]\n                                for k in range(len(x)):\n                                    if not y[k]==1.0:\n                                        rho_temp.append(y[k])\n                                        T_temp.append(x[k])\n                                x=T_temp\n                                y=rho_temp\n\t\t\t\tplt.plot(x,y,label=label,color=color[i],marker=marker[i],linestyle=linestyle[i],markevery=markevery)\n\t\t\t\t#for max rho\n        \t\t\tx=np.array(T1[idx_rho])*T_unit/1e9\n\t\t\t\ty=rho1[idx_rho]\n                                rho_temp=[]\n                                T_temp=[]\n                                for k in range(len(x)):\n                                    if not y[k]==1.0:\n                                        rho_temp.append(y[k])\n                                        T_temp.append(x[k])\n                                x=T_temp\n                                y=rho_temp\n\t\t\t\tplt.plot(x,y,color=color[i],marker=marker[i],linestyle=linestyle[i],markevery=markevery)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsetting plot_CC_T_rho_max - set temperature and density of runs in the SeFile object", "response": "def set_plot_CC_T_rho_max(self,linestyle=[],burn_limit=0.997,color=['r'],marker=['o'],markevery=500): \n\t\t'''\n\t\t\tPlots \n\t\t\tend_model - array, control how far in models a run is plottet, if -1 till end\n\t\t\tsymbs_1  - set symbols of runs\n\t\t'''\n\t\tif len(linestyle)==0:\n\t\t\tlinestyle=200*['-']\n\t\tplt.figure('CC evol')\n                for i in range(len(self.runs_H5_surf)):\n                        sefiles=se(self.runs_H5_out[i])\n\t\t\tt1_model=-1\n\t\t\tsefiles.get('temperature')\n\t\t\tsefiles.get('density')\n                        mini=sefiles.get('mini')\n\t\t\tzini=sefiles.get('zini')\n                        model=sefiles.se.cycles\n                        model_list=[]\n                        for k in range(0,len(model),1):\n                                model_list.append(model[k])\n                        rho1=sefiles.get(model_list,'rho')   #[:(t1_model-t0_model)]\n                        T1=sefiles.get(model_list,'temperature')#[:(t1_model-t0_model)]\n                        rho=[]\n                        T=[]\n\t\t\tT_unit=sefiles.get('temperature_unit')\n\t\t\tlabeldone=False\n                        for k in range(len(model_list)):\n\t\t\t\tt9=np.array(T1[k])*T_unit/1e9\n\t\t\t\tT.append(max(t9))\n\t\t\t\trho.append(max(rho1[k]))\n\t\t\tlabel=str(mini)+'$M_{\\odot}$, Z='+str(zini)\n\t\t\tplt.plot(T,rho,label=label,color=color[i],marker=marker[i],markevery=markevery)\t\t\t\t\t\n\t\tplt.xlabel('$T_{9,max} (GK)$')\n\t\tplt.ylabel(r'$\\rho [cm^{-3}]$')\n\t\tplt.yscale('log')\n\t\tplt.xscale('log')\n\t\tplt.legend(loc=2)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsets the temperature and density of the HRDs in the run.", "response": "def set_plot_CC_T_rho(self,linestyle=[],burn_limit=0.997,color=['r'],marker=['o'],nolabelZ=False,markevery=500): \n\t\t'''\n\t\t\tPlots HRDs\n\t\t\tend_model - array, control how far in models a run is plottet, if -1 till end\n\t\t\tsymbs_1  - set symbols of runs\n\t\t'''\n\t\tif len(linestyle)==0:\n\t\t\tlinestyle=200*['-']\n\t\tplt.figure('CC evol')\n                for i in range(len(self.runs_H5_surf)):\n                        sefiles=se(self.runs_H5_out[i])\n\t\t\tt1_model=-1\n\t\t\tsefiles.get('temperature')\n\t\t\tsefiles.get('density')\n                        mini=sefiles.get('mini')\n\t\t\tzini=sefiles.get('zini')\n                        model=sefiles.se.cycles\n                        model_list=[]\n                        for k in range(0,len(model),1):\n                               model_list.append(model[k])\n                        rho1=sefiles.get(model_list,'rho')   #[:(t1_model-t0_model)]\n                        T1=sefiles.get(model_list,'temperature')#[:(t1_model-t0_model)]\n                        rho=[]\n                        T=[]\n\t\t\tT_unit=sefiles.get('temperature_unit')\n\t\t\tlabeldone=False\n                        for k in range(len(model_list)):\n\t\t\t\tt9=np.array(T1[k])*T_unit/1e9\n\t\t\t\tT_delrem=[]\n\t\t\t\trho_delrem=[]\n\t\t\t\tif k ==0:\n\t\t\t\t\tT.append(max(t9))\n\t\t\t\t\trho.append(max(rho1[k]))\n\t\t\t\t\tfor h in range(len(rho1[k])):\n\t\t\t\t\t\tif rho1[k][h] < 1e3:\n\t\t\t\t\t\t\tT_delrem.append(t9[h])\n\t\t\t\t\t\t\trho_delrem.append(rho1[k][h])\n\t\t\t\t\tif nolabelZ==True:\n\t\t\t\t\t\tplt.plot(T_delrem,rho_delrem,label=self.extra_label[i].split(',')[0],color=color[i],marker=marker[i],markevery=markevery)\n\t\t\t\t\telse:\n\t\t\t\t\t\tplt.plot(T_delrem,rho_delrem,label=self.extra_label[i],color=color[i],marker=marker[i],markevery=markevery)\n\t\t\t\telse:\n\t\t\t\t\tif (max(rho)<max(rho1[k]) or max(T)<max(t9)):\n                                        \tfor h in range(len(rho1[k])):\n\t\t\t\t\t\t\tif rho1[k][h] > 1e3:\n                                                \t\tT_delrem.append(t9[h])\n                                        \t      \t\trho_delrem.append(rho1[k][h])\n\t\t\t\t\t\tif labeldone==True:\t\n\t\t\t\t\t\t\tplt.plot(T_delrem,rho_delrem,color=color[i],marker=marker[i],markevery=markevery)\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\tlabel=str(mini)+'$M_{\\odot}$, Z='+str(zini)\n\t\t\t\t\t\t\tif nolabelZ==True:\n\t\t\t\t\t\t\t\tplt.plot(T_delrem,rho_delrem,label=label.split(',')[0],color=color[i],marker=marker[i],markevery=markevery)\n\t\t\t\t\t\t\telse:\n\t\t\t\t\t\t\t\tplt.plot(T_delrem,rho_delrem,label=label,color=color[i],marker=marker[i],markevery=markevery)\n\t\t\t\t\t\t\tlabeldone=True\n\t\t\t\t\t\tT.append(max(t9))\n\t\t\t\t\t\trho.append(max(rho1[k]))\n\t\t\t\t\telse:\n\t\t\t\t\t\tbreak\n\t\t\t\t\t#else:\n\t\t\t\t\t\t\n\t\tplt.xlabel('$T_9 [GK]$',size=22)\n\t\tplt.ylabel(r'$\\rho [cm^{-3}]$',size=22)\n\t\tplt.yscale('log')\n\t\tplt.xscale('log')\n\t\tplt.legend(loc=2)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef set_plot_tcrhoc(self,linestyle=['-'],burn_limit=0.997,marker=['o'],markevery=500,end_model=[-1],deg_line=True): \n\t\t'''\n\t\t\tPlots HRDs\n\t\t\tend_model - array, control how far in models a run is plottet, if -1 till end\n\t\t\tsymbs_1  - set symbols of runs\n\t\t'''\n\t\tif len(linestyle)==0:\n\t\t\tlinestyle=200*['-']\n\n                for i in range(len(self.runs_H5_surf)):\n                        m1p65_last=se(self.runs_H5_out[i])\n\t\t\tt1_model=-1\n\t\t\tif end_model[i] != -1:\n\t\t\t\tt1_model=end_model[i]\n\n\t\t\tmodel=m1p65_last.se.cycles\n\t\t\tmodel_list=[]\n\t\t\tfor k in range(0,len(model),5):\n\t\t\t\tmodel_list.append(model[k])\n                        rho1=m1p65_last.get(model_list,'rho')   #[:(t1_model-t0_model)]\n                        T1=m1p65_last.get(model_list,'temperature')#[:(t1_model-t0_model)]\n\t\t\tT_unit=m1p65_last.get('temperature_unit')\n\t\t\tmass=m1p65_last.get(model_list,'mass')\n\t\t\tmini=m1p65_last.get('mini')\n\t\t\tzini=m1p65_last.get('zini')\n\t\t\t#info=m1p65_last.burnstage_upgrade()\n\t\t\t#burn_info=[]\n\t\t\t#burn_cycle=[]\n\t\t\t#for k in range(len(info[0])):\n\t\t\t#    if 'start' in info[3][k]:\n\t\t\t#\tburn_info.append( info[3][k])\n\t\t\t#\tburn_cycle.append(info[0][k])\n\t\t\t#print burn_info\n\t\t\t#print burn_cycle\n\t\t\t'''\n\t\t\t#H\n\t\t\t#Maybe use get_elemental_abunds(), too slow if individually taken\n\t\t\th=m1p65_last.get(model_list,'H-1')\n\t\t\th_ini=mini*h[0][-1]\n\t\t\th_limit=h_ini*burn_limit\n\t\t\tprint h_limit\n\t\t\t#He\n\t\t\the=m1p65_last.get(model_list,'He-4')\n\t\t\the+=m1p65_last.get(model_list,'He-3')\n\t\t\the_ini=mini*he[0][-1]\n\t\t\the_limit=he_ini*burn_limit\n\t\t\tprint he_limit\n\t\t\tif mini>5:\n\t\t\t\tc=m1p65_last.get(model_list,'C-12')\n\t\t\t\tc_ini=mini*c[0][-1]\n\t\t\t\tc_limit=c_ini*burn_limit\n\t\t\tif mini>10:\n\t\t\t\tne=m1p65_last.get(model_list,'Ne-20')\n\t\t\t\tne_ini=\tmini*ne[0][-1]\n\t\t\t\tne_limit=ne_ini*burn_limit\n\t\t\t\to=m1p65_last.get(model_list,'O-16')\n\t\t\t\to_ini=mini*o[0][-1]\n\t\t\t\to_limit=o_ini*burn_limit\n\t\t\t\tsi=m1p65_last.get(model_list,'Si-28')\n\t\t\t\tsi_ini=mini*si[0][-1]\n\t\t\t\tsi_limit=si_ini*burn_limit\n\t\t\tprint '#############################3'\n\t\t\tprint h_ini,he_ini\n\t\t\trho=[]\n\t\t\tT=[]\n\t\t\the_depl_idx=-1\n\t\t\th_depl_idx=-1\n\t\t\tc_depl_idx=-1\n\t\t\tne_depl_idx=-1\n\t\t\to_depl_idx=-1\n\t\t\tsi_depl_idx=-1\n\t\t\t'''\n\t\t\trho=[]\n\t\t\tT=[]\n\t\t\tfor k in range(len(model_list)):\n\t\t\t\trho_center=rho1[k][0]\n\t\t\t\tT_center=T1[k][0]\n\t\t\t\trho.append(rho_center)\n\t\t\t\tT.append(T_center)\n\t\t\t\t'''\n\t\t\t\tmass11=np.array([0]+list(mass[k]))\n\t\t\t\tdelta_mass=mass11[1:]-mass11[:-1]\n\t\t\t\t#for the low-mass + massive AGB\n\t\t\t\tif (sum(np.array(he[k])*np.array(delta_mass))<he_limit) and  (he_depl_idx==-1):\n\t\t\t\t\the_depl_idx=k\t\t\t\n                                if (sum(np.array(h[k])*np.array(delta_mass))<h_limit) and  (h_depl_idx==-1):\n                                        h_depl_idx=k\n\t\t\t\t#for the SAGB + massive\n\t\t\t\tif mini>5:\n\t\t\t\t\tif (sum(np.array(c[k])*np.array(delta_mass))<c_limit) and  (c_depl_idx==-1):\n                                        \tc_depl_idx=k\n\t\t\t\t#for the massive stars\n\t\t\t\tif mini>10:\n\t\t\t\t\tif (sum(np.array(ne[k])*np.array(delta_mass))<ne_limit) and  (ne_depl_idx==-1):\n                                        \tne_depl_idx=k\n\t\t\t\t\tif (sum(np.array(o[k])*np.array(delta_mass))<o_limit) and  (o_depl_idx==-1):\n                                        \to_depl_idx=k\n\t\t\t\t\tif (sum(np.array(si[k])*np.array(delta_mass))<si_limit) and  (si_depl_idx==-1):\n                                        \tsi_depl_idx=k\n\t\t\t\t'''\n\n\t\t\tT=np.log10(np.array(T)*T_unit)\n\t\t\t#T_degeneracy=np.log10(np.array(rho)**(2./3.))\n\t\t\trho=np.log10(np.array(rho))\n                        figure(1)\n                        #plot(logTeff,logL,marker=symbs[i],label=self.run_label[i],linestyle=linestyle[i],markevery=markevery)\n\t\t\t#pl.plot(rho,T,marker=symbs[i],label=self.run_label[i],linestyle=linestyle[i],markevery=markevery)\n\t\t\tlabel=str(mini)+'$M_{\\odot}$, Z='+str(zini)\n\t\t\tplt.plot(rho,T,label=label,linestyle=linestyle[i],marker=marker[i],markevery=markevery)\n\t\t\t'''\n\t\t\t#plt.plot(rho,T_degeneracy,color='b',linestyle='-',label='$P_e = P_{e,deg}$')\n\t\t\tprint burn_info\n\t\t\tprint burn_cycle\n\t\t\tburn_cycle=np.array(burn_cycle)/100.\n\t\t\tprint 'changed cycles:', burn_cycle\n\t\t\tprint len(rho)\n\t\t\t#For different burning stages:\n\t\t\tif 'H_start' in burn_info:\n\t\t\t\tplt.plot(rho[burn_cycle[0]],T[burn_cycle[0]],marker='o',color='b')\n\t\t\tif 'He_start' in burn_info:\n\t\t\t\tplt.plot(rho[burn_cycle[1]],T[burn_cycle[1]],marker='o',color='r')\n\t\t\tif 'C_start' in burn_info:\n\t\t\t\tplt.plot(rho[burn_cycle[2]],T[burn_cycle[2]],marker='o',color='g')\n\t\t\tif 'Ne_start' in burn_info:\n\t\t\t\tplt.plot(rho[burn_cycle[3]],T[burn_cycle[3]],marker='D',color='b')\n\t\t\tif 'O_start' in burn_info:\n\t\t\t\tplt.plot(rho[burn_cycle[4]],T[burn_cycle[4]],marker='D',color='r')\n\t\t\tif 'Si_start' in burn_info:\n\t\t\t\tplt.plot(rho[burn_cycle[5]],T[burn_cycle[5]],marker='D',color='g')\n\t\t\t'''\n\t\t\n\t\t\t#ax = plt.gca()\n\t\t\t#ax.invert_xaxis()\n\t\t\tplt.rcParams.update({'font.size': 16})\n\t\t\tplt.rc('xtick', labelsize=16)\n\t\t\tplt.rc('ytick', labelsize=16)\n\t\t\tlegend(loc=4)\n\t\t        plt.xlabel('log $\\\\rho_{\\\\rm c}$',fontsize=18)\n        \t\tplt.ylabel('log $T_{\\\\rm c}$',fontsize=18)\n\t\t\t'''\n\t\t\t#plt.gca().invert_xaxis()\t\n\t\t\tfigure(0)\n\t\t\t#pl.plot(rho,T,marker=symbs[i],label=self.run_label[i],linestyle=linestyle[i],markevery=markevery)\n                        plt.plot(rho,T,label=self.extra_label[i],linestyle=linestyle[i])\n\t\t\tplt.plot(rho,T_degeneracy,color='b',linestyle='-',label='$P_e = P_{e,deg}$')\n\t\t\t#For different burning stages:\n\t\t\tif not h_depl_idx ==-1:\n\t\t\t\tplt.plot(rho[h_depl_idx],T[h_depl_idx],marker='o',color='b')\n\t\t\tif not he_depl_idx ==-1:\n\t\t\t\tplt.plot(rho[he_depl_idx],T[he_depl_idx],marker='o',color='r')\n\t\t\tif not c_depl_idx ==-1:\n\t\t\t\tplt.plot(rho[c_depl_idx],T[c_depl_idx],marker='o',color='g')\n\t\t\tif not ne_depl_idx ==-1:\n\t\t\t\tplt.plot(rho[ne_depl_idx],T[ne_depl_idx],marker='D',color='b')\n\t\t\tif not o_depl_idx ==-1:\n\t\t\t\tplt.plot(rho[o_depl_idx],T[o_depl_idx],marker='D',color='r')\n\t\t\tif not si_depl_idx ==-1:\n\t\t\t\tplt.plot(rho[si_depl_idx],T[si_depl_idx],marker='D',color='g')\n\t\t\t\n\n\t\t\t#ax = plt.gca()\n\t\t\t#ax.invert_xaxis()\n\t\t\tplt.rcParams.update({'font.size': 16})\n                \tplt.rc('xtick', labelsize=16)\n                \tplt.rc('ytick', labelsize=16)\n                \tlegend(loc=4)\n\t\t        plt.xlabel('log $\\\\rho_{\\\\rm c}$',fontsize=18)\n        \t\tplt.ylabel('log $T_{\\\\rm c}$',fontsize=18)\n\t\t\t#plt.gca().invert_xaxis()\n\t\t\t'''\n\t\t\ti+=1\t\n\t\tif deg_line==True:\n\t\t\trho=np.arange(0,9,0.01)\n\t\t\tT_degeneracy=2./3. *rho +np.log10(1.207e5 * 1.8/(2.**(5./3.)))\n\t\t\t#T_degeneracy=np.log10( (10**np.array(rho))**(2./3.))\n\t\t\tplt.plot(rho,T_degeneracy,color='b',linestyle='-',label='$P_e = P_{e,deg}$')\n\t\tplt.legend(loc=2)", "response": "Set plottet to plottet in HRDs."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef prod_fac_massgrid_A_1(self,weighted=True,log=True,runs=[],isotopes=[],elements=[],cycles=[],plot_set_diagram=True,color=['r','b','g','k'],marker_type=['o','p','s','D'],line_style=['--','-','-.',':'],markersize=[6,6,6,6],line_width=[14,14,14,14],title='',withlabel=True,label='',plot_lines=True,exp_only=False,pre_exp=False,delay=True,exp_dir='',fontsizelabel='x-small',iniabupath='/astro/critter/critter/PPN/forum.astro.keele.ac.uk/frames/mppnp/USEEPP/iniab2.0E-02GN93.ppn',xlim=[0,0]):\n\t\t'''\n\t\t\tPlots behaviour star mass dependent yields of different isotopes - specify dirs at the beginning\n\t\t\tBeware  of different z,\n\n\t\t\truns : If array is empty function uses all available directories.\t\t\t\t\t\n\t\t\t\t\n\t\t\t!! If len of elements longer than zero, than isotopes will be ignored and elements used!!\n\n\t\t'''\n\t\truns=[]\n\n\t\tHDF5_surf=[]\n\t\tHDF5_out=[]\n\t\tHDF5_restart=[]\n\t\tfor i in range(len(self.run_dirs_name)):\n\t\t\tHDF5_surf.append(self.runs_H5_surf[i])\n\t\t\tHDF5_out.append(self.runs_H5_out[i])\n\t\t\tHDF5_restart.append(self.runs_H5_restart[i])\n\t\tlegend_k=0\n\t\tsefiles=[]\n\t\tsefiles_hout=[]\n\t\tsefiles_restart=[]\n\t\tfor i in range(len(HDF5_surf)):\n\t\t\t\tsefiles.append(se(HDF5_surf[i]))\t\t\n\t\t\t\tsefiles_hout.append(se(HDF5_out[i]))\n\t\t\t\tsefiles_restart.append(se(HDF5_restart[i]))\n\n\n\t\timport utils as u\n\t\tiniabu=u.iniabu(iniabupath)\n\t\tx_iniabu=[]\n\n\t\t\n\t\tisotopes11=sefiles[0].se.isotopes\n\t\tif len(isotopes)>0:\n\t\t\tif isotopes[0]=='allstable':\n\t\t\t\tisotopes=get_stable(isotopes11,get_elements=False)\n\t\t\t\tcolor=len(isotopes)*[color[0]]\n\t\t\t\tmarker_type=len(isotopes)*[marker_type[0]]\n\t\t\t\tline_style=len(isotopes)*[line_style[0]]\n\t\t\t\tmarkersize=len(isotopes)*[markersize[0]]\n\t\t\t\tline_width=len(isotopes)*[line_width[0]]\n\t\t\t\tprint isotopes\n\t\t\tx_iniabu=iniabu.iso_abundance(isotopes)\n\t\t\tmass_numbers=iniabu.a\n\t\t\tcharge=iniabu.z\n\n\t\t\t\n\n\n\t\tif len(elements)>0:\n\t\t\tif elements[0]=='allstable':\n\t\t\t\telements=get_stable(isotopes11,get_elements=True)\n\t\t\t\tcolor=len(elements)*[color[0]]\n\t\t\t\tmarker_type=len(elements)*[marker_type[0]]\n\t\t\t\tline_style=len(elements)*[line_style[0]]\n\t\t\t\tmarkersize=len(elements)*[markersize[0]]\n\t\t\t\tline_width=len(elements)*[line_width[0]]\n\t\t\t\tprint elements\n\t\t\tisotopes=get_stable(isotopes11,get_elements=False)\n\t\t\timport re\n\t\t\tx_iniabu=[0]*len(elements)\n\t\t\tx_iniabu_names=[]\n\t\t\tfor k in range(len(iniabu.names)):\n\t\t\t\tiso=iniabu.names[k].replace(' ','')\n\t\t\t\tcharge1=iniabu.z\n\t\t\t\tmass_numbers1=iniabu.a\n\t\t\t\tmatch = re.match(r\"([a-z]+)([0-9]+)\",iso, re.I)\n\t\t\t\tele1=match.groups()[0].upper()\n\t\t\t\tiso=ele1+'-'+match.groups()[1]\n\t\t\t\tfor r in range(len(elements)):\n\t\t\t\t\tif elements[r] == ele1:\n\t\t\t\t\t\tx_iniabu_names.append(iso)\n\t\t\t\t\t\tx_iniabu[r]+=iniabu.iso_abundance(iso)\n\t\t\tprint 'test ouptput',x_iniabu_names\t\n\n\t\t#import utils as u\n\n\t\t#iniabu=u.iniabu(iniabupath)\n\n\t\t#iniabu.iso_abundance(isotopes)\n\n\n\t\t####dealign with explosion pinput\n                #test to take right dir:\n                #\n                if delay:\n                        exp_type='delay'\n                else:\n                        exp_type='rapid'\n                slist = os.listdir(exp_dir)\n                expr = re.compile(exp_type)\n                slist=(filter(expr.search,slist))\n\n\n\t\texp_runs_H5_restart=[]\n\t\tsefiles_exp=[]\n\n\n\t\t#to dinstiungish between pre exp and exp sources\n\t\tif pre_exp==False:\n\n\t\t\tslist = os.listdir(exp_dir)\n\t\t\texpr = re.compile(exp_type)\n\t\t\tslist=(filter(expr.search,slist))\n\n\t\t\tfor element in slist:\n\t\t\t\trun_path=exp_dir+'/'+element\n\t\t\t\tif not os.path.isdir(run_path):\n\t\t\t\t\tcontinue\n\t\t\t\tif os.path.isdir(run_path+\"/H5_restart\"):\n\t\t\t\t\tsefiles1 = os.listdir(run_path+\"/H5_restart\")\n\t\t\t\t\tif (filter(expr.search,sefiles1)) <1:\n\t\t\t\t\t\tprint \"Warning: No hdf5 restart files found in \"+run_path+\"/H5_restart\"\n\t\t\t\t\telse:\n\t\t\t\t\t\texp_runs_H5_restart.append(run_path+\"/H5_restart\")\n\t\t\t\t\t\tsefiles_exp.append(se(run_path+\"/H5_restart\"))\n\t\telse:\n\t\n\t\t\texp_runs_H5_restart=HDF5_restart\n\t\t\tfor k in range(len(HDF5_restart)):\n\t\t\t\tsefiles_exp.append(se(HDF5_restart[k]))\n\n\n\t\tz_index_files=[]\n\t\tz_values=[]\n\t\tj=-1\n\t\tfor i in range(len(HDF5_surf)):\n\t\t\tj+=1\n\t\t\tstar_z=sefiles[i].get(\"zini\")\n\t\t\tif star_z not in z_values:\n\t\t\t\tz_values.append(star_z)\n\t\t\t\tz_index_files.append([])\n\t\t\tz_index_files[ z_values.index(star_z)].append(i)\n\t\tmax_yield=[]\n\t\tcolor_iso=-1\n\t\tyields_1=[]\n\t\tt=0\n\t\tif len(elements)>0:\n\t\t\tisotopes=elements\n\t\tlegend_k=0\n\t\tfor w in range(len(z_index_files)):\n\t\t\tstar_mass_array=[]\n\t\t\tyields=[]\n\t\t\tlegend_k+=1\n\t\t\t#iso_yields=[]\n\t\t\t#iniabu_yields_folded=[]\n\t\t\tproduction_factor=[]\n\t\t\tfor i in range(len(isotopes)):\n\t\t\t\t#iso_yields.append(np.zeros(len( z_index_files[w]   )))\n\t\t\t\t#iniabu_yields_folded.append(np.zeros(len( z_index_files[w]   )))\n\t\t\t\tif exp_only==False:\t\n\t\t\t\t\tproduction_factor.append(np.zeros(len( z_index_files[w]   )))\n\t\t\t\telse:\n\t\t\t\t\tproduction_factor.append([])\n\t\t\tttt=0\n\t\t\tfor k in z_index_files[w]:\n\t\t\t\tif type(sefiles[k].get(\"mini\")) == np.ndarray:\n\t\t\t\t\tstar_mass=sefiles[k].get(\"mini\")[0]\n\t\t\t\t\tstar_z=sefiles[k].get(\"zini\")[0]\n\t\t\t\telse:\n                                        star_mass=sefiles[k].get(\"mini\")\n                                        star_z=sefiles[k].get(\"zini\")\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t#star_mass=sefiles[k].get(\"mini\")[0]\n\t\t\t\t#star_z=sefiles[k].get(\"zini\")[0]\t\t\t\t\n\t\t\t\tif cycles[k][1]==-1:\n\t\t\t\t\tendcycle=int(sefiles[k].se.cycles[-1]) #+ cycles[k][2]  #1000\n\t\t\t\t\tendcycle= int( round( endcycle,-3) -2000 )\n\t\t\t\telse:\n\t\t\t\t\tendcycle=cycles[k][1]\n\t\t\t\tif exp_only==False:\n\t\t\t\t\tstar_mass_array.append(star_mass)\n\t\t\t\t\tprod_factor,isotopes_prod_fac,yields,iniabu,mass_frac_ini,remn_mass =self.weighted_yields(sefiles[k],sefiles_hout[k],sefiles_restart[k],isotopes,elements,cycles[k][0],endcycle,cycles[k][2])\n\t\t\t\t\t#print 'yield output###################################:'\n\t\t\t\t\t#print 'wind: ',yields,prod_factor,iniabu\n\t\t\t\t\tfor tt in range(len(prod_factor)):\n                                        \tprod_factor[tt]=yields[tt]/(star_mass-remn_mass)    #iniabu[tt]\n\n\n\t\t\t\telse:\n\t\t\t\t\tprod_factor=[]\n\t\t\t\t\tif star_mass<=8:\n\t\t\t\t\t\tcontinue\n\t\t\t\t\tfor pp in range(len(isotopes)): \n\t\t\t\t\t\tproduction_factor[pp].append([0])\n\t\t\t\t\t\t\t\n\t\t\t\t\tstar_mass_array.append(star_mass)\n\t\t\t\t\t\n\t\t\t\tmass=star_mass\n\t\t\t\tmetallicity=star_z\n\t\t\t\tif mass>8:\n\n\t\t\t\t\t#in case no ppn_exp run dir is available, skip explosion contribution\n\t\t\t\t\t#this is because mass cut is then larger then actual mass of star...no mass lost\n\n\t\t\t\t\tfor t in range(len(exp_runs_H5_restart)):\n\t\t\t\t\t\tif type(sefiles_exp[t].get(\"mini\")) == np.ndarray:\n\t\t\t\t\t\t\tmass1=sefiles_exp[t].get(\"mini\")[0]\n\t\t\t\t\t\t\tmetallicity1=sefiles_exp[t].get(\"zini\")[0]\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\tmass1=sefiles_exp[t].get(\"mini\")\n\t\t\t\t\t\t\tmetallicity1=sefiles_exp[t].get(\"zini\")\n\n\t\t\t\t\t\t###for currupted files\n\n\t\t\t\t\t\tcorrupt=False\n\t\t\t\t\t\tif type(mass1) == list:\n\t\t\t\t\t\t\tcorrupt=True\n\t\t\t\t\t\tif type(metallicity1) ==list:\n\t\t\t\t\t\t\tcorrupt=True\n\t\t\t\t\t\tif ((float(mass1) < 1) or  (float(mass1) >70 )) or type(mass1) == type(None):\n\t\t\t\t\t\t\tcorrupt=True\n\t\t\t\t\t\tif ((float(metallicity1) < 0.00001) or  (float(metallicity1) >1. )) or type(metallicity1) == type(None):\n\t\t\t\t\t\t\tcorrupt=True\n\n\n\t\t\t\t\t\tif corrupt == True:\n\t\t\t\t\t\t\tmetallicity1=0.02\n\t\t\t\t\t\t\trundir11=exp_runs_H5_restart[t].split('/')[-2]\n\t\t\t\t\t\t\tmass1=float(rundir11.split('.')[0][1:])\n\t\t\t\t\t\t\t#print 'corruption, assinge new values',mass1,metallicity1\n\t\t\t\t\t\tif mass1 == mass and metallicity1 == metallicity:\n\t\t\t\t\t\t\t#sefiles_re2=sefiles_exp[t]\n\t\t\t\t\t\t\t#calculate exp part\n\t\t\t\t\t\t\timport nugridse as mp\n\t\t\t\t\t\t\treload(mp)\n\t\t\t\t\t\t\t#Have to find the right cycle in restart file\n\t\t\t\t\t\t\t#.se.cycles does not work when reading all files\t\n\t\t\t\t\t\t\t#therefore identify file with last cycle and read it:\n\t\t\t\t\t\t\trefiles=sefiles_exp[t].se.files\n\t\t\t\t\t\t\ttosort=[]\n\t\t\t\t\t\t\trefiles1=[]\n\t\t\t\t\t\t\tfor i in range(len(refiles)):\n\t\t\t\t\t\t\t\tcycle_file=refiles[i][-18:-11]\n\t\t\t\t\t\t\t\tif cycle_file.isdigit():\n\t\t\t\t\t\t\t\t\ttosort.append(int(cycle_file))\n\t\t\t\t\t\t\t\t\trefiles1.append(refiles[i])\n\t\t\t\t\t\t\tidx_sorted=sorted(range(len(tosort)), key=lambda k: tosort[k])\n\t\t\t\t\t\t\tidx_file = idx_sorted[-1]\n\t\t\t\t\t\t\tsefiles_re_cycle=mp.se(exp_runs_H5_restart[t],refiles1[idx_file])\n\t\t\t\t\t\t\tif len(sefiles_re_cycle.se.cycles)==0:\n\t\t\t\t\t\t\t\t#in the case there is not cycle in the last file...set1.2 M2-\n\t\t\t\t\t\t\t\tsefiles_re_cycle=mp.se(exp_runs_H5_restart[t],refiles1[idx_sorted[-2]])\n\t\t\t\t\t\t\tprint 'tewststest',exp_cycle_inp\n\t\t\t\t\t\t\tif exp_cycle_inp>0:\n\t\t\t\t\t\t\t\tsefiles_re_cycle=mp.se(exp_runs_H5_restart[t],exp_cycle_inp)\n\t\t\t\t\t\t\tprint 'Use custom exp cycle ', exp_cycle_inp\n\t\t\t\t\t\t\t#print 'identifies as ',exp_runs_H5_restart[t],'with file',refiles1[idx_file]\n\t\t\t\t\t\t\tisotopes_exp,yields_exp,iniabu_exp,mass_cut_exp,first_cycle_exp=self.weighted_yields_explosion(mp,sefiles_re_cycle,sefiles[k],isotopes=isotopes,elements=elements,delay=delay)\n\n\t\t\t\t\t\t\tif exp_only==False:\t\n\t\t\t\t\t\t\t\t#add pre-exp yields\n\t\t\t\t\t\t\t\tfor tt in range(len(prod_factor)):\n\t\t\t\t\t\t\t\t\t#print 'star above 8M'\n\t\t\t\t\t\t\t\t\t#print isotopes_prod_fac[tt],yields[tt],yields_exp[tt]\n\t\t\t\t\t\t\t\t\t#the iniabu from the explosion is not added\n\t\t\t\t\t\t\t\t\t#because it is already in the iniabu from wind\n\t\t\t\t\t\t\t\t\tprod_factor[tt]=(yields[tt]+yields_exp[tt])/(star_mass-mass_cut_exp)     #(iniabu[tt])\n\t\t\t\t\t\t\t\t\t#print 'yields wind:',yields[tt]\n\t\t\t\t\t\t\t\t\t#print 'prodfac wind:',(yields[tt]/iniabu[tt])\n\t\t\t\t\t\t\t\t\t#print 'wind+exp yields : ',yields[tt]+yields_exp[tt]\t\n\t\t\t\t\t\t\telse:\n\t\t\t\t\t\t\t\tfor tt in range(len(isotopes_exp)):\t\t\n\t\t\t\t\t\t\t\t\tprod_factor.append((yields_exp[tt])/( (star_mass-mass_cut_exp) - (star_mass-remn_mass) ))   #(iniabu_exp[tt]))\n\t\t\t\t\t\t\tremn_mass=mass_cut_exp\n\t\t\t\t\t\t\t#print 'exp yield',yields_exp\n\t\t\t\t\t\t\t#print 'prodfac exp:',(yields_exp[tt]/iniabu_exp[tt])\n\t\t\t\t\t\t\t#print 'wind+exp prodfac:',prod_factor[tt]\n\t\t\t\t\t\t\tbreak\t\t\n\n\n\t\t\n\n\t\t\t\t#print 'iso exp',len(isotopes_exp)\n\t\t\t\t#prod_factor=np.log10(prod_factor)\n\t\t\t\tprint len(isotopes),len(prod_factor),len(production_factor)\n\t\t\t\t#Normalization to solar abundance\n\t\t\t\tfor i in range(len(isotopes)):\n                                        production_factor[i][ttt]=prod_factor[i]/x_iniabu[i]\n\t\t\t\tttt+=1\n\t\t\t\n\t\t\t###plotting\n\t\t\t#if plot_set_diagram==True:\n\t\t\t#if plot_set_diagram==True:\n\t\t\t#\tfig_2=plt.figure(isotopes[h])\n\t\t\t#\t#fig_2=plt.figure()\n\t\t\t#\tax_2 = fig_2.add_subplot(1,1,1)\n\t\t\t#\tplt.rcParams.update({'font.size': 16})\n\t\t\t#\tplt.rc('xtick', labelsize=16)\n\t\t\t#\tplt.rc('ytick', labelsize=16)\n\t\t\t#\tif log==True:\n\t\t\t#\t\tax_2.set_yscale('log')\n                        color_iso=0\n                        legend_k=0\n\n\n\t\t\tfor h in range(len(isotopes)):\n\t\t\t\t#yield_1=iso_yields[i]\n\t\t\t\t#mass_1=star_mass_array\n\t\t\t\tyield_1=[]\n\t\t\t\tmass_1=[]\t\t\t\n\t\t\t\tiniabu_folded=[]\n\t\t\t\tprod_fac_sorted=[]\t\n               \t\t\tindices_array=sorted(range(len(star_mass_array)),key=lambda x:star_mass_array[x])\n                \t\tfor i in indices_array:\n\t\t\t\t#\tyield_1.append(iso_yields[h][i])\n\t\t\t\t\tmass_1.append(star_mass_array[i])\n\t\t\t\t#\tiniabu_folded.append(iniabu_yields_folded[h][i])\n\t\t\t\t\tprod_fac_sorted.append(production_factor[h][i])\n\t\t\t\t####Plotting prodfactor\n\t\t\t\t#plt.figure(fig_2.number)\n\n\t\t\t\tfig_2=plt.figure(isotopes[h])\n\t\t\t\tax_2 = fig_2.add_subplot(1,1,1)\n\t\t\t\tplt.rcParams.update({'font.size': 16})\n\t\t\t\tplt.rc('xtick', labelsize=16)\n\t\t\t\tplt.rc('ytick', labelsize=16)\n\t\t\t\tif log==True:\n\t\t\t\t\tax_2.set_yscale('log')\n\t\t\t\tax_2.legend()\n\t\t\t\tax_2.set_xlabel(\"M/M$_{\\odot}$\",fontsize=16)\n\t\t\t\tax_2.minorticks_on()\n\t\t\t\tax_2.set_ylabel(\"Overproduction factor\",fontsize=16)\n\t\t\t\tax_2.set_title(title)\n\t\n\t\t\t\tif len(label)>0:\n\t\t\t\t\tlabel=\", \"+label\n\t\t\t\tif len(elements)==0:\n\t\t\t\t\tplot_quantity=isotopes[h]\n\t\t\t\t\tplot_quantity=\"$^{\"+plot_quantity.split(\"-\")[1]+\"}$\"+plot_quantity.split(\"-\")[0]\n\t\t\t\telse:\n\t\t\t\t\tplot_quantity=elements[h]\n\t\t\t\tif withlabel==True:\n                                \tplt.plot(mass_1,prod_fac_sorted,marker=marker_type[legend_k],color=color[color_iso],markersize=markersize[legend_k],mfc=color[color_iso],linewidth=line_width[legend_k],linestyle=line_style[color_iso],label=plot_quantity+\" , Z=\"+str(star_z)+label  )\t\t\t\t\n\t\t\t\telse:\n                                \tplt.plot(mass_1,prod_fac_sorted,marker=marker_type[legend_k],color=color[color_iso],markersize=markersize[legend_k],mfc=color[color_iso],linewidth=line_width[legend_k],linestyle=line_style[color_iso])\t\t\t\t\n\t\t\t\t\n\n\t\t\t\tm_max=max(star_mass_array)+2\n\t\t\t\t\n\t\t\t\tif plot_lines==True:\n\t\t\t\t\tplt.plot([0,m_max],[1,1],\"k--\",linewidth=3)\n\t\t\t\t\tplt.plot([0,m_max],[2,2],\"k--\",linewidth=1)\n\t\t\t\t\tplt.plot([0,m_max],[0.5,0.5],\"k--\",linewidth=1)\t\t\t\t\n\t\n\t\t\t\tcolor_iso+=1\n\t\t\t\tlegend_k+=1\n\t\t#####\n\t\tx_imf=[]\n\t\ty_imf=[]\n\t\tm_max=max(star_mass_array)+2.", "response": "This function is used to plot the multi - cell mass dependent yields of different isotopes."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _get_request_body_bytes_only(param_name, param_value):\n    '''Validates the request body passed in and converts it to bytes\n    if our policy allows it.'''\n    if param_value is None:\n        return b''\n\n    if isinstance(param_value, bytes):\n        return param_value\n\n    raise TypeError(_ERROR_VALUE_SHOULD_BE_BYTES.format(param_name))", "response": "Validates the request body passed in and converts it to bytes\n    if our policy allows it."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget the value of attribute_name from the resource object and returns default if no value is found.", "response": "def _get_attribute_value_of(resource, attribute_name, default=None):\n    \"\"\"Gets the value of attribute_name from the resource\n\n    It catches the exception, if any, while retrieving the\n    value of attribute_name from resource and returns default.\n\n    :param resource: The resource object\n    :attribute_name: Property of the resource\n    :returns the property value if no error encountered\n        else return 0.\n    \"\"\"\n    try:\n        return getattr(resource, attribute_name)\n    except (sushy.exceptions.SushyError,\n            exception.MissingAttributeError) as e:\n        msg = (('The Redfish controller failed to get the '\n                'attribute %(attribute)s from resource %(resource)s. '\n                'Error %(error)s') % {'error': str(e),\n                                      'attribute': attribute_name,\n                                      'resource':\n                                      resource.__class__.__name__})\n        LOG.debug(msg)\n        return default"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting the size in GB of the system.", "response": "def get_local_gb(system_obj):\n    \"\"\"Gets the largest volume or the largest disk\n\n    :param system_obj: The HPESystem object.\n    :returns the size in GB\n    \"\"\"\n    local_max_bytes = 0\n    logical_max_mib = 0\n    volume_max_bytes = 0\n    physical_max_mib = 0\n    drives_max_bytes = 0\n    simple_max_bytes = 0\n\n    # Gets the resources and properties\n    # its quite possible for a system to lack the resource, hence its\n    # URI may also be lacking.\n\n    # Check if smart_storage resource exist at the system\n    smart_resource = _get_attribute_value_of(system_obj, 'smart_storage')\n    # Check if storage resource exist at the system\n    storage_resource = _get_attribute_value_of(system_obj, 'storages')\n\n    if smart_resource is not None:\n        logical_max_mib = _get_attribute_value_of(\n            smart_resource, 'logical_drives_maximum_size_mib', default=0)\n    if storage_resource is not None:\n        volume_max_bytes = _get_attribute_value_of(\n            storage_resource, 'volumes_maximum_size_bytes', default=0)\n\n    # Get the largest volume from the system.\n    local_max_bytes = utils.max_safe([(logical_max_mib * 1024 * 1024),\n                                     volume_max_bytes])\n    # if volume is not found, then traverse through the possible disk drives\n    # and get the biggest disk.\n    if local_max_bytes == 0:\n        if smart_resource is not None:\n            physical_max_mib = _get_attribute_value_of(\n                smart_resource, 'physical_drives_maximum_size_mib', default=0)\n\n        if storage_resource is not None:\n            drives_max_bytes = _get_attribute_value_of(\n                storage_resource, 'drives_maximum_size_bytes', default=0)\n\n        # Check if the SimpleStorage resource exist at the system.\n        simple_resource = _get_attribute_value_of(system_obj,\n                                                  'simple_storages')\n        if simple_resource is not None:\n            simple_max_bytes = _get_attribute_value_of(\n                simple_resource, 'maximum_size_bytes', default=0)\n\n        local_max_bytes = utils.max_safe([(physical_max_mib * 1024 * 1024),\n                                         drives_max_bytes, simple_max_bytes])\n    # Convert the received size to GB and reduce the value by 1 Gb as\n    # ironic requires the local_gb to be returned 1 less than actual size.\n    local_gb = 0\n    if local_max_bytes > 0:\n        local_gb = int(local_max_bytes / (1024 * 1024 * 1024)) - 1\n    else:\n        msg = ('The maximum size for the hard disk or logical '\n               'volume could not be determined.')\n        LOG.debug(msg)\n    return local_gb"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets if the system has any SSD drive as SSD drive.", "response": "def has_ssd(system_obj):\n    \"\"\"Gets if the system has any drive as SSD drive\n\n    :param system_obj: The HPESystem object.\n    :returns True if system has SSD drives.\n    \"\"\"\n    smart_value = False\n    storage_value = False\n    smart_resource = _get_attribute_value_of(system_obj, 'smart_storage')\n    if smart_resource is not None:\n        smart_value = _get_attribute_value_of(\n            smart_resource, 'has_ssd', default=False)\n\n    if smart_value:\n        return smart_value\n\n    # Its returned before just to avoid hitting BMC if we have\n    # already got the SSD device above.\n    storage_resource = _get_attribute_value_of(system_obj, 'storages')\n    if storage_resource is not None:\n        storage_value = _get_attribute_value_of(\n            storage_resource, 'has_ssd', default=False)\n    return storage_value"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef has_nvme_ssd(system_obj):\n    storage_value = False\n    storage_resource = _get_attribute_value_of(system_obj, 'storages')\n    if storage_resource is not None:\n        storage_value = _get_attribute_value_of(\n            storage_resource, 'has_nvme_ssd', default=False)\n\n    return storage_value", "response": "Gets if the system has any drive as NVMe SSD drive."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_drive_rotational_speed_rpm(system_obj):\n    speed = set()\n    smart_resource = _get_attribute_value_of(system_obj, 'smart_storage')\n    if smart_resource is not None:\n        speed.update(_get_attribute_value_of(\n            smart_resource, 'drive_rotational_speed_rpm', default=set()))\n    storage_resource = _get_attribute_value_of(system_obj, 'storages')\n    if storage_resource is not None:\n        speed.update(_get_attribute_value_of(\n            storage_resource, 'drive_rotational_speed_rpm', default=set()))\n    return speed", "response": "Gets the set of rotational speed rpms of the HDD devices."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncreate the RAID configuration on the bare metal.", "response": "def create_configuration(self, node, ports):\n        \"\"\"Create RAID configuration on the bare metal.\n\n        This method creates the desired RAID configuration as read from\n        node['target_raid_config'].\n\n        :param node: A dictionary of the node object\n        :param ports: A list of dictionaries containing information of ports\n            for the node\n        :returns: The current RAID configuration of the below format.\n            raid_config = {\n                'logical_disks': [{\n                    'size_gb': 100,\n                    'raid_level': 1,\n                    'physical_disks': [\n                        '5I:0:1',\n                        '5I:0:2'],\n                    'controller': 'Smart array controller'\n                    },\n                ]\n            }\n        \"\"\"\n        target_raid_config = node.get('target_raid_config', {}).copy()\n        return hpssa_manager.create_configuration(\n            raid_config=target_raid_config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef erase_devices(self, node, port):\n        result = {}\n        result['Disk Erase Status'] = hpssa_manager.erase_devices()\n\n        result.update(super(ProliantHardwareManager,\n                            self).erase_devices(node, port))\n        return result", "response": "Erase the drives on the bare metal."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef init_model_based_tags(self, model):\n        self.model = model\n        if 'G7' in self.model:\n            self.MEMORY_SIZE_TAG = \"MEMORY_SIZE\"\n            self.MEMORY_SIZE_NOT_PRESENT_TAG = \"Not Installed\"\n            self.NIC_INFORMATION_TAG = \"NIC_INFOMATION\"\n        else:\n            self.MEMORY_SIZE_TAG = \"TOTAL_MEMORY_SIZE\"\n            self.MEMORY_SIZE_NOT_PRESENT_TAG = \"N/A\"\n            self.NIC_INFORMATION_TAG = \"NIC_INFORMATION\"", "response": "Initializes the model based memory and NIC information tags."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _request_ilo(self, root, extra_headers=None):\n        if self.port:\n            urlstr = 'https://%s:%d/ribcl' % (self.host, self.port)\n        else:\n            urlstr = 'https://%s/ribcl' % (self.host)\n        xml = self._serialize_xml(root)\n        headers = {\"Content-length\": str(len(xml))}\n        if extra_headers:\n            headers.update(extra_headers)\n\n        kwargs = {'headers': headers, 'data': xml}\n        if self.cacert is not None:\n            kwargs['verify'] = self.cacert\n        else:\n            kwargs['verify'] = False\n\n        try:\n            LOG.debug(self._(\"POST %(url)s with request data: \"\n                             \"%(request_data)s\"),\n                      {'url': urlstr,\n                       'request_data': MaskedRequestData(kwargs)})\n            response = requests.post(urlstr, **kwargs)\n            response.raise_for_status()\n        except Exception as e:\n            LOG.debug(self._(\"Unable to connect to iLO. %s\"), e)\n            raise exception.IloConnectionError(e)\n        return response.text", "response": "Send RIBCL XML data to the ILO and return the response."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _create_dynamic_xml(self, cmdname, tag_name, mode, subelements=None):\n        root = etree.Element('RIBCL', VERSION=\"2.0\")\n        login = etree.SubElement(\n            root, 'LOGIN', USER_LOGIN=self.login, PASSWORD=self.password)\n        tagname = etree.SubElement(login, tag_name, MODE=mode)\n        subelements = subelements or {}\n\n        etree.SubElement(tagname, cmdname)\n\n        if six.PY2:\n            root_iterator = root.getiterator(cmdname)\n        else:\n            root_iterator = root.iter(cmdname)\n\n        for cmd in root_iterator:\n            for key, value in subelements.items():\n                cmd.set(key, value)\n\n        return root", "response": "Create the dynamic XML for the RIBCL XML."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nserializes XML data into string", "response": "def _serialize_xml(self, root):\n        \"\"\"Serialize XML data into string\n\n        It serializes the dynamic xml created and converts\n        it to a string. This is done before sending the\n        xml to the ILO.\n\n        :param root: root of the dynamic xml.\n        \"\"\"\n        if hasattr(etree, 'tostringlist'):\n            if six.PY3:\n                xml_content_list = [\n                    x.decode(\"utf-8\") for x in etree.tostringlist(root)]\n            else:\n                xml_content_list = etree.tostringlist(root)\n\n            xml = '\\r\\n'.join(xml_content_list) + '\\r\\n'\n        else:\n            if six.PY3:\n                xml_content = etree.tostring(root).decode(\"utf-8\")\n            else:\n                xml_content = etree.tostring(root)\n            xml = xml_content + '\\r\\n'\n        return xml"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nparses the response from ILO and returns the dictionary representation of the ILO response.", "response": "def _parse_output(self, xml_response):\n        \"\"\"Parse the response XML from iLO.\n\n        This function parses the output received from ILO.\n        As the output contains multiple XMLs, it extracts\n        one xml at a time and loops over till all the xmls\n        in the response are exhausted.\n\n        It returns the data to APIs either in dictionary\n        format or as the string.\n        It creates the dictionary only if the Ilo response\n        contains the data under the requested RIBCL command.\n        If the Ilo response contains only the string,\n        then the string is returned back.\n        \"\"\"\n        count = 0\n        xml_dict = {}\n        resp_message = None\n        xml_start_pos = []\n        for m in re.finditer(r\"\\<\\?xml\", xml_response):\n            xml_start_pos.append(m.start())\n        while count < len(xml_start_pos):\n            if (count == len(xml_start_pos) - 1):\n                result = xml_response[xml_start_pos[count]:]\n            else:\n                start = xml_start_pos[count]\n                end = xml_start_pos[count + 1]\n                result = xml_response[start:end]\n            result = result.strip()\n            message = etree.fromstring(result)\n            resp = self._validate_message(message)\n            if hasattr(resp, 'tag'):\n                xml_dict = self._elementtree_to_dict(resp)\n            elif resp is not None:\n                resp_message = resp\n            count = count + 1\n\n        if xml_dict:\n            return xml_dict\n        elif resp_message is not None:\n            return resp_message"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nconverts XML elementtree to dictionary.", "response": "def _elementtree_to_dict(self, element):\n        \"\"\"Convert XML elementtree to dictionary.\n\n        Converts the actual response from the ILO for an API\n        to the dictionary.\n        \"\"\"\n        node = {}\n        text = getattr(element, 'text')\n        if text is not None:\n            text = text.strip()\n            if len(text) != 0:\n                node['text'] = text\n        node.update(element.items())  # element's attributes\n        child_nodes = {}\n        for child in element:  # element's children\n            child_nodes.setdefault(child.tag, []).append(\n                self._elementtree_to_dict(child))\n        # convert all single-element lists into non-lists\n        for key, value in child_nodes.items():\n            if len(value) == 1:\n                child_nodes[key] = value[0]\n        node.update(child_nodes.items())\n        return node"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _validate_message(self, message):\n        if message.tag != 'RIBCL':\n            # the true case shall be unreachable for response\n            # XML from Ilo as all messages are tagged with RIBCL\n            # but still raise an exception if any invalid\n            # XML response is returned by Ilo. Set status to some\n            # arbitary non-zero value.\n            status = -1\n            raise exception.IloClientInternalError(message, status)\n\n        for child in message:\n            if child.tag != 'RESPONSE':\n                return message\n            status = int(child.get('STATUS'), 16)\n            msg = child.get('MESSAGE')\n            if status == 0 and msg != 'No error':\n                return msg\n            if status != 0:\n                if 'syntax error' in msg or 'Feature not supported' in msg:\n                    for cmd in BOOT_MODE_CMDS:\n                        if cmd in msg:\n                            platform = self.get_product_name()\n                            msg = (\"%(cmd)s is not supported on %(platform)s\" %\n                                   {'cmd': cmd, 'platform': platform})\n                            LOG.debug(self._(\"Got invalid response with \"\n                                             \"message: '%(message)s'\"),\n                                      {'message': msg})\n                            raise (exception.IloCommandNotSupportedError\n                                   (msg, status))\n                    else:\n                        LOG.debug(self._(\"Got invalid response with \"\n                                         \"message: '%(message)s'\"),\n                                  {'message': msg})\n                        raise exception.IloClientInternalError(msg, status)\n                if (status in exception.IloLoginFailError.statuses or\n                        msg in exception.IloLoginFailError.messages):\n                    LOG.debug(self._(\"Got invalid response with \"\n                                     \"message: '%(message)s'\"),\n                              {'message': msg})\n                    raise exception.IloLoginFailError(msg, status)\n\n                LOG.debug(self._(\"Got invalid response with \"\n                                 \"message: '%(message)s'\"),\n                          {'message': msg})\n                raise exception.IloError(msg, status)", "response": "Validate the XML response from Ilo."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _execute_command(self, create_command, tag_info, mode, dic={}):\n        xml = self._create_dynamic_xml(\n            create_command, tag_info, mode, dic)\n        d = self._request_ilo(xml)\n        data = self._parse_output(d)\n        LOG.debug(self._(\"Received response data: %s\"), data)\n        return data", "response": "Execute a command on the iLO.\n           "}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nretrieves all license types key installation date etc.", "response": "def get_all_licenses(self):\n        \"\"\"Retrieve license type, key, installation date, etc.\"\"\"\n        data = self._execute_command('GET_ALL_LICENSES', 'RIB_INFO', 'read')\n        d = {}\n        for key, val in data['GET_ALL_LICENSES']['LICENSE'].items():\n            if isinstance(val, dict):\n                d[key] = data['GET_ALL_LICENSES']['LICENSE'][key]['VALUE']\n        return d"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_vm_status(self, device='FLOPPY'):\n        dic = {'DEVICE': device.upper()}\n        data = self._execute_command(\n            'GET_VM_STATUS', 'RIB_INFO', 'read', dic)\n        return data['GET_VM_STATUS']", "response": "Returns the virtual media drive status."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef set_host_power(self, power):\n        if power.upper() in POWER_STATE:\n            dic = {'HOST_POWER': POWER_STATE[power.upper()]}\n            data = self._execute_command(\n                'SET_HOST_POWER', 'SERVER_INFO', 'write', dic)\n            return data\n        else:\n            raise exception.IloInvalidInputError(\n                \"Invalid input. The expected input is ON or OFF.\")", "response": "Toggle the power button of server."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nconfigure a single boot from a specific device.", "response": "def set_one_time_boot(self, value):\n        \"\"\"Configures a single boot from a specific device.\n\n        :param value: specific device to which the boot option is set\n        \"\"\"\n        dic = {'value': value}\n        data = self._execute_command(\n            'SET_ONE_TIME_BOOT', 'SERVER_INFO', 'write', dic)\n        return data"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ninserting a virtual media diskette image.", "response": "def insert_virtual_media(self, url, device='FLOPPY'):\n        \"\"\"Notifies iLO of the location of a virtual media diskette image.\"\"\"\n        dic = {\n            'DEVICE': device.upper(),\n            'IMAGE_URL': url,\n        }\n        data = self._execute_command(\n            'INSERT_VIRTUAL_MEDIA', 'RIB_INFO', 'write', dic)\n        return data"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef eject_virtual_media(self, device='FLOPPY'):\n        vm_status = self.get_vm_status(device=device)\n        if vm_status['IMAGE_INSERTED'] == 'NO':\n            return\n\n        dic = {'DEVICE': device.upper()}\n        self._execute_command(\n            'EJECT_VIRTUAL_MEDIA', 'RIB_INFO', 'write', dic)", "response": "Ejects the Virtual Media image if one is inserted."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef set_vm_status(self, device='FLOPPY',\n                      boot_option='BOOT_ONCE', write_protect='YES'):\n        \"\"\"Sets the Virtual Media drive status\n\n        It also allows the boot options for booting from the virtual media.\n        \"\"\"\n        dic = {'DEVICE': device.upper()}\n        xml = self._create_dynamic_xml(\n            'SET_VM_STATUS', 'RIB_INFO', 'write', dic)\n\n        if six.PY2:\n            child_iterator = xml.getiterator()\n        else:\n            child_iterator = xml.iter()\n\n        for child in child_iterator:\n            if child.tag == 'SET_VM_STATUS':\n                etree.SubElement(child, 'VM_BOOT_OPTION',\n                                 VALUE=boot_option.upper())\n                etree.SubElement(child, 'VM_WRITE_PROTECT',\n                                 VALUE=write_protect.upper())\n\n        d = self._request_ilo(xml)\n        data = self._parse_output(d)\n        return data", "response": "Sets the Virtual Media drive status"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nretrieve the supported boot mode.", "response": "def get_supported_boot_mode(self):\n        \"\"\"Retrieves the supported boot mode.\n\n        :returns: any one of the following proliantutils.ilo.constants:\n\n            SUPPORTED_BOOT_MODE_LEGACY_BIOS_ONLY,\n            SUPPORTED_BOOT_MODE_UEFI_ONLY,\n            SUPPORTED_BOOT_MODE_LEGACY_BIOS_AND_UEFI\n\n        \"\"\"\n        data = self._execute_command(\n            'GET_SUPPORTED_BOOT_MODE', 'SERVER_INFO', 'read')\n        supported_boot_mode = (\n            data['GET_SUPPORTED_BOOT_MODE']['SUPPORTED_BOOT_MODE']['VALUE'])\n        return mappings.GET_SUPPORTED_BOOT_MODE_RIBCL_MAP.get(\n            supported_boot_mode)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nconfigure the boot mode of the system from a specific boot mode.", "response": "def set_pending_boot_mode(self, value):\n        \"\"\"Configures the boot mode of the system from a specific boot mode.\"\"\"\n        dic = {'value': value}\n        data = self._execute_command(\n            'SET_PENDING_BOOT_MODE', 'SERVER_INFO', 'write', dic)\n        return data"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_persistent_boot_device(self):\n        result = self._get_persistent_boot()\n        boot_mode = self._check_boot_mode(result)\n\n        if boot_mode == 'bios':\n            return result[0]['value']\n\n        value = result[0]['DESCRIPTION']\n        if 'HP iLO Virtual USB CD' in value:\n            return 'CDROM'\n\n        elif 'NIC' in value or 'PXE' in value:\n            return 'NETWORK'\n\n        elif common.isDisk(value):\n            return 'HDD'\n\n        else:\n            return None", "response": "Get the current persistent boot device set for the host."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _set_persistent_boot(self, values=[]):\n\n        xml = self._create_dynamic_xml(\n            'SET_PERSISTENT_BOOT', 'SERVER_INFO', 'write')\n\n        if six.PY2:\n            child_iterator = xml.getiterator()\n        else:\n            child_iterator = xml.iter()\n\n        for child in child_iterator:\n            for val in values:\n                if child.tag == 'SET_PERSISTENT_BOOT':\n                    etree.SubElement(child, 'DEVICE', VALUE=val)\n        d = self._request_ilo(xml)\n        data = self._parse_output(d)\n        return data", "response": "Configures a boot from a specific device."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _request_host(self):\n        urlstr = 'https://%s/xmldata?item=all' % (self.host)\n        kwargs = {}\n        if self.cacert is not None:\n            kwargs['verify'] = self.cacert\n        else:\n            kwargs['verify'] = False\n        try:\n            response = requests.get(urlstr, **kwargs)\n            response.raise_for_status()\n        except Exception as e:\n            raise IloConnectionError(e)\n\n        return response.text", "response": "Request host info from the server."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nrequesting host UUID of the server.", "response": "def get_host_uuid(self):\n        \"\"\"Request host UUID of the server.\n\n        :returns: the host UUID of the server\n        :raises: IloConnectionError if failed connecting to the iLO.\n        \"\"\"\n        xml = self._request_host()\n        root = etree.fromstring(xml)\n        data = self._elementtree_to_dict(root)\n        return data['HSI']['SPN']['text'], data['HSI']['cUUID']['text']"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nrequests host health data of the server.", "response": "def get_host_health_data(self, data=None):\n        \"\"\"Request host health data of the server.\n\n        :param: the data to retrieve from the server, defaults to None.\n        :returns: the dictionary containing the embedded health data.\n        :raises: IloConnectionError if failed connecting to the iLO.\n        :raises: IloError, on an error from iLO.\n        \"\"\"\n        if not data or data and \"GET_EMBEDDED_HEALTH_DATA\" not in data:\n            data = self._execute_command(\n                'GET_EMBEDDED_HEALTH', 'SERVER_INFO', 'read')\n        return data"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nrequest the health power supply information.", "response": "def get_host_health_power_supplies(self, data=None):\n        \"\"\"Request the health power supply information.\n\n        :param: the data to retrieve from the server, defaults to None.\n        :returns: the dictionary containing the power supply information.\n        :raises: IloConnectionError if failed connecting to the iLO.\n        :raises: IloError, on an error from iLO.\n        \"\"\"\n        data = self.get_host_health_data(data)\n        d = (data['GET_EMBEDDED_HEALTH_DATA']['POWER_SUPPLIES']['SUPPLY'])\n        if not isinstance(d, list):\n            d = [d]\n        return d"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets the health Temp Sensor report.", "response": "def get_host_health_temperature_sensors(self, data=None):\n        \"\"\"Get the health Temp Sensor report.\n\n        :param: the data to retrieve from the server, defaults to None.\n        :returns: the dictionary containing the temperature sensors\n            information.\n        :raises: IloConnectionError if failed connecting to the iLO.\n        :raises: IloError, on an error from iLO.\n        \"\"\"\n        data = self.get_host_health_data(data)\n        d = data['GET_EMBEDDED_HEALTH_DATA']['TEMPERATURE']['TEMP']\n        if not isinstance(d, list):\n            d = [d]\n        return d"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_host_health_fan_sensors(self, data=None):\n        data = self.get_host_health_data(data)\n        d = data['GET_EMBEDDED_HEALTH_DATA']['FANS']['FAN']\n        if not isinstance(d, list):\n            d = [d]\n        return d", "response": "Get the health Fan Sensor Report."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef reset_ilo_credential(self, password):\n\n        dic = {'USER_LOGIN': self.login}\n        root = self._create_dynamic_xml(\n            'MOD_USER', 'USER_INFO', 'write', dic)\n\n        element = root.find('LOGIN/USER_INFO/MOD_USER')\n        etree.SubElement(element, 'PASSWORD', VALUE=password)\n        d = self._request_ilo(root)\n        self._parse_output(d)", "response": "Resets the iLO password."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting essential scheduling properties as required by ironic", "response": "def get_essential_properties(self):\n        \"\"\"Gets essential scheduling properties as required by ironic\n\n        :returns: a dictionary of server properties like memory size,\n                  disk size, number of cpus, cpu arch, port numbers\n                  and mac addresses.\n        :raises:IloError if iLO returns an error in command execution.\n\n        \"\"\"\n        data = self.get_host_health_data()\n        properties = {\n            'memory_mb': self._parse_memory_embedded_health(data)\n        }\n        cpus, cpu_arch = self._parse_processor_embedded_health(data)\n        properties['cpus'] = cpus\n        properties['cpu_arch'] = cpu_arch\n        properties['local_gb'] = self._parse_storage_embedded_health(data)\n        macs = self._parse_nics_embedded_health(data)\n        return_value = {'properties': properties, 'macs': macs}\n        return return_value"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_server_capabilities(self):\n        capabilities = {}\n        data = self.get_host_health_data()\n        ilo_firmware = self._get_ilo_firmware_version(data)\n        if ilo_firmware:\n            capabilities.update(ilo_firmware)\n        rom_firmware = self._get_rom_firmware_version(data)\n        if rom_firmware:\n            capabilities.update(rom_firmware)\n        capabilities.update({'server_model': self.get_product_name()})\n        capabilities.update(self._get_number_of_gpu_devices_connected(data))\n        boot_modes = common.get_supported_boot_modes(\n            self.get_supported_boot_mode())\n        capabilities.update({\n            'boot_mode_bios': boot_modes.boot_mode_bios,\n            'boot_mode_uefi': boot_modes.boot_mode_uefi})\n        return capabilities", "response": "Gets the server properties which can be used for scheduling\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nparses the get_host_health_data method for essential properties", "response": "def _parse_memory_embedded_health(self, data):\n        \"\"\"Parse the get_host_health_data() for essential properties\n\n        :param data: the output returned by get_host_health_data()\n        :returns: memory size in MB.\n        :raises IloError, if unable to get the memory details.\n        \"\"\"\n        memory_mb = 0\n        memory = self._get_memory_details_value_based_on_model(data)\n\n        if memory is None:\n            msg = \"Unable to get memory data. Error: Data missing\"\n            raise exception.IloError(msg)\n\n        total_memory_size = 0\n        for memory_item in memory:\n            memsize = memory_item[self.MEMORY_SIZE_TAG][\"VALUE\"]\n            if memsize != self.MEMORY_SIZE_NOT_PRESENT_TAG:\n                memory_bytes = (\n                    strutils.string_to_bytes(\n                        memsize.replace(' ', ''), return_int=True))\n                memory_mb = int(memory_bytes / (1024 * 1024))\n                total_memory_size = total_memory_size + memory_mb\n        return total_memory_size"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _parse_processor_embedded_health(self, data):\n        processor = self.get_value_as_list((data['GET_EMBEDDED_HEALTH_DATA']\n                                           ['PROCESSORS']), 'PROCESSOR')\n        if processor is None:\n            msg = \"Unable to get cpu data. Error: Data missing\"\n            raise exception.IloError(msg)\n        cpus = 0\n        for proc in processor:\n            for val in proc.values():\n                processor_detail = val['VALUE']\n                proc_core_threads = processor_detail.split('; ')\n                for x in proc_core_threads:\n                    if \"thread\" in x:\n                        v = x.split()\n                        try:\n                            cpus = cpus + int(v[0])\n                        except ValueError:\n                            msg = (\"Unable to get cpu data. \"\n                                   \"The Value %s returned couldn't be \"\n                                   \"manipulated to get number of \"\n                                   \"actual processors\" % processor_detail)\n                            raise exception.IloError(msg)\n        cpu_arch = 'x86_64'\n        return cpus, cpu_arch", "response": "Parse the get_host_health_data method for essential properties\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _parse_storage_embedded_health(self, data):\n        local_gb = 0\n        storage = self.get_value_as_list(data['GET_EMBEDDED_HEALTH_DATA'],\n                                         'STORAGE')\n        if storage is None:\n            # We dont raise exception because this dictionary\n            # is available only when RAID is configured.\n            # If we raise error here then we will always fail\n            # inspection where this module is consumed. Hence\n            # as a workaround just return 0.\n            return local_gb\n\n        minimum = local_gb\n\n        for item in storage:\n            cntlr = self.get_value_as_list(item, 'CONTROLLER')\n            if cntlr is None:\n                continue\n            for s in cntlr:\n                drive = self.get_value_as_list(s, 'LOGICAL_DRIVE')\n                if drive is None:\n                    continue\n                for item in drive:\n                    for key, val in item.items():\n                        if key == 'CAPACITY':\n                            capacity = val['VALUE']\n                            local_bytes = (strutils.string_to_bytes(\n                                           capacity.replace(' ', ''),\n                                           return_int=True))\n                            local_gb = int(local_bytes / (1024 * 1024 * 1024))\n                            if minimum >= local_gb or minimum == 0:\n                                minimum = local_gb\n\n        # Return disk size 1 less than the actual disk size. This prevents\n        # the deploy to fail from Nova when root_gb is same as local_gb\n        # in Ironic. When the disk size is used as root_device hints,\n        # then it should be given as the actual size i.e.\n        # ironic (node.properties['local_gb'] + 1) else root device\n        # hint will fail.\n        if minimum:\n            minimum = minimum - 1\n        return minimum", "response": "Parses the get_embedded_health_data method for essential properties and returns the disk size in GB."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _parse_nics_embedded_health(self, data):\n        nic_data = self.get_value_as_list((data['GET_EMBEDDED_HEALTH_DATA']\n                                          [self.NIC_INFORMATION_TAG]), 'NIC')\n\n        if nic_data is None:\n            msg = \"Unable to get NIC details. Data missing\"\n            raise exception.IloError(msg)\n        nic_dict = {}\n        for item in nic_data:\n            try:\n                port = item['NETWORK_PORT']['VALUE']\n                mac = item['MAC_ADDRESS']['VALUE']\n                self._update_nic_data_from_nic_info_based_on_model(nic_dict,\n                                                                   item, port,\n                                                                   mac)\n\n            except KeyError:\n                msg = \"Unable to get NIC details. Data missing\"\n                raise exception.IloError(msg)\n\n        return nic_dict", "response": "Parses the get_embedded_health data for essential properties and updates the NIC details based on the model of the NIC."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _get_firmware_embedded_health(self, data):\n        firmware = self.get_value_as_list(data['GET_EMBEDDED_HEALTH_DATA'],\n                                          'FIRMWARE_INFORMATION')\n        if firmware is None:\n            return None\n        return dict((y['FIRMWARE_NAME']['VALUE'],\n                     y['FIRMWARE_VERSION']['VALUE'])\n                    for x in firmware for y in x.values())", "response": "Parse the get_host_health_data method for server capabilities\n       "}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _get_rom_firmware_version(self, data):\n        firmware_details = self._get_firmware_embedded_health(data)\n        if firmware_details:\n            try:\n                rom_firmware_version = (\n                    firmware_details['HP ProLiant System ROM'])\n                return {'rom_firmware_version': rom_firmware_version}\n            except KeyError:\n                return None", "response": "Gets the rom firmware version for server capabilities"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the iLO firmware version for server capabilities", "response": "def _get_ilo_firmware_version(self, data):\n        \"\"\"Gets the ilo firmware version for server capabilities\n\n        Parse the get_host_health_data() to retreive the firmware\n        details.\n\n        :param data: the output returned by get_host_health_data()\n        :returns: a dictionary of iLO firmware version.\n\n        \"\"\"\n        firmware_details = self._get_firmware_embedded_health(data)\n        if firmware_details:\n            try:\n                return {'ilo_firmware_version': firmware_details['iLO']}\n            except KeyError:\n                return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_ilo_firmware_version_as_major_minor(self):\n        data = self.get_host_health_data()\n        firmware_details = self._get_firmware_embedded_health(data)\n        if firmware_details:\n            ilo_version_str = firmware_details.get('iLO', None)\n            return common.get_major_minor(ilo_version_str)", "response": "Gets the ilo firmware version for server capabilities and returns the major and minor version as a string."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _get_number_of_gpu_devices_connected(self, data):\n        temp = self.get_value_as_list((data['GET_EMBEDDED_HEALTH_DATA']\n                                      ['TEMPERATURE']), 'TEMP')\n        count = 0\n        if temp is None:\n            return {'pci_gpu_devices': count}\n\n        for key in temp:\n            for name, value in key.items():\n                if name == 'LABEL' and 'GPU' in value['VALUE']:\n                    count = count + 1\n\n        return {'pci_gpu_devices': count}", "response": "Parse the get_host_health_data method and get the count of GPU devices connected to the server."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef activate_license(self, key):\n        root = self._create_dynamic_xml('LICENSE', 'RIB_INFO', 'write')\n        element = root.find('LOGIN/RIB_INFO/LICENSE')\n        etree.SubElement(element, 'ACTIVATE', KEY=key)\n        d = self._request_ilo(root)\n        self._parse_output(d)", "response": "Activates iLO license.\n\n        :param key: iLO license key.\n        :raises: IloError, on an error from iLO."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef update_firmware(self, filename, component_type):\n        fw_img_processor = firmware_controller.FirmwareImageUploader(filename)\n\n        LOG.debug(self._('Uploading firmware file: %s ...'), filename)\n        cookie = fw_img_processor.upload_file_to((self.host, self.port),\n                                                 self.timeout)\n        LOG.debug(self._('Uploading firmware file: %s ... done'), filename)\n\n        root = self._get_firmware_update_xml_for_file_and_component(\n            filename, component_type)\n        element = root.find('LOGIN/RIB_INFO')\n        etree.SubElement(element, 'TPM_ENABLED', VALUE='Yes')\n        extra_headers = {'Cookie': cookie}\n\n        LOG.debug(self._('Flashing firmware file: %s ...'), filename)\n        d = self._request_ilo(root, extra_headers=extra_headers)\n\n        # wait till the firmware update completes.\n        common.wait_for_ribcl_firmware_update_to_complete(self)\n        self._parse_output(d)\n        LOG.info(self._('Flashing firmware file: %s ... done'), filename)", "response": "Updates the given firmware on the server for the given component type."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating the dynamic xml for flashing the firmware via iLO.", "response": "def _get_firmware_update_xml_for_file_and_component(\n            self, filename, component):\n        \"\"\"Creates the dynamic xml for flashing the device firmware via iLO.\n\n        This method creates the dynamic xml for flashing the firmware, based\n        on the component type so passed.\n        :param filename: location of the raw firmware file.\n        :param component_type: Type of component to be applied to.\n        :returns: the etree.Element for the root of the RIBCL XML\n                  for flashing the device (component) firmware.\n        \"\"\"\n        if component == 'ilo':\n            cmd_name = 'UPDATE_RIB_FIRMWARE'\n        else:\n            # Note(deray): Not explicitly checking for all other supported\n            # devices (components), as those checks have already happened\n            # in the invoking methods and may seem redundant here.\n            cmd_name = 'UPDATE_FIRMWARE'\n\n        fwlen = os.path.getsize(filename)\n        root = self._create_dynamic_xml(cmd_name,\n                                        'RIB_INFO',\n                                        'write',\n                                        subelements={\n                                            'IMAGE_LOCATION': filename,\n                                            'IMAGE_LENGTH': str(fwlen)\n                                        })\n        return root"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the response body from gzipped content.", "response": "def _get_response_body_from_gzipped_content(self, url, response):\n        \"\"\"Get the response body from gzipped content\n\n        Try to decode as gzip (we should check the headers for\n        Content-Encoding=gzip)\n\n          if response.headers['content-encoding'] == \"gzip\":\n            ...\n\n        :param url: the url for which response was sent\n        :type url: str\n        :param response: response content object, probably gzipped\n        :type response: object\n        :returns: returns response body\n        :raises IloError: if the content is **not** gzipped\n        \"\"\"\n        try:\n            gzipper = gzip.GzipFile(fileobj=six.BytesIO(response.text))\n\n            LOG.debug(self._(\"Received compressed response for \"\n                             \"url %(url)s.\"), {'url': url})\n            uncompressed_string = (gzipper.read().decode('UTF-8'))\n            response_body = json.loads(uncompressed_string)\n\n        except Exception as e:\n            LOG.debug(\n                self._(\"Error occurred while decompressing body. \"\n                       \"Got invalid response '%(response)s' for \"\n                       \"url %(url)s: %(error)s\"),\n                {'url': url, 'response': response.text, 'error': e})\n            raise exception.IloError(e)\n\n        return response_body"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _rest_op(self, operation, suburi, request_headers, request_body):\n\n        url = urlparse.urlparse('https://' + self.host + suburi)\n        # Used for logging on redirection error.\n        start_url = url.geturl()\n\n        LOG.debug(self._(\"%(operation)s %(url)s\"),\n                  {'operation': operation, 'url': start_url})\n\n        if request_headers is None or not isinstance(request_headers, dict):\n            request_headers = {}\n\n        # Use self.login/self.password and Basic Auth\n        if self.login is not None and self.password is not None:\n            auth_data = self.login + \":\" + self.password\n            hr = \"BASIC \" + base64.b64encode(\n                auth_data.encode('ascii')).decode(\"utf-8\")\n            request_headers['Authorization'] = hr\n\n        if request_body is not None:\n            if (isinstance(request_body, dict)\n                    or isinstance(request_body, list)):\n                request_headers['Content-Type'] = 'application/json'\n            else:\n                request_headers['Content-Type'] = ('application/'\n                                                   'x-www-form-urlencoded')\n\n        \"\"\"Helper methods to retry and keep retrying on redirection - START\"\"\"\n\n        def retry_if_response_asks_for_redirection(response):\n            # NOTE:Do not assume every HTTP operation will return a JSON\n            # request_body. For example, ExtendedError structures are only\n            # required for HTTP 400 errors and are optional elsewhere as they\n            # are mostly redundant for many of the other HTTP status code.\n            # In particular, 200 OK responses should not have to return any\n            # request_body.\n\n            # NOTE:  this makes sure the headers names are all lower cases\n            # because HTTP says they are case insensitive\n            # Follow HTTP redirect\n            if response.status_code == 301 and 'location' in response.headers:\n                retry_if_response_asks_for_redirection.url = (\n                    urlparse.urlparse(response.headers['location']))\n                LOG.debug(self._(\"Request redirected to %s.\"),\n                          retry_if_response_asks_for_redirection.url.geturl())\n                return True\n            return False\n\n        @retrying.retry(\n            # Note(deray): Return True if we should retry, False otherwise.\n            # In our case, when the url response we receive asks for\n            # redirection then we retry.\n            retry_on_result=retry_if_response_asks_for_redirection,\n            # Note(deray): Return True if we should retry, False otherwise.\n            # In our case, when it's an IloConnectionError we don't retry.\n            # ``requests`` already takes care of issuing max number of\n            # retries if the URL service is unavailable.\n            retry_on_exception=(\n                lambda e: not isinstance(e, exception.IloConnectionError)),\n            stop_max_attempt_number=REDIRECTION_ATTEMPTS)\n        def _fetch_response():\n\n            url = retry_if_response_asks_for_redirection.url\n\n            kwargs = {'headers': request_headers,\n                      'data': json.dumps(request_body)}\n            if self.cacert is not None:\n                kwargs['verify'] = self.cacert\n            else:\n                kwargs['verify'] = False\n\n            LOG.debug(self._('\\n\\tHTTP REQUEST: %(restreq_method)s'\n                             '\\n\\tPATH: %(restreq_path)s'\n                             '\\n\\tBODY: %(restreq_body)s'\n                             '\\n'),\n                      {'restreq_method': operation,\n                       'restreq_path': url.geturl(),\n                       'restreq_body': request_body})\n\n            request_method = getattr(requests, operation.lower())\n            try:\n                response = request_method(url.geturl(), **kwargs)\n            except Exception as e:\n                LOG.debug(self._(\"Unable to connect to iLO. %s\"), e)\n                raise exception.IloConnectionError(e)\n\n            return response\n\n        \"\"\"Helper methods to retry and keep retrying on redirection - END\"\"\"\n\n        try:\n            # Note(deray): This is a trick to use the function attributes\n            # to overwrite variable/s (in our case ``url``) and use the\n            # modified one in nested functions, i.e. :func:`_fetch_response`\n            # and :func:`retry_if_response_asks_for_redirection`\n            retry_if_response_asks_for_redirection.url = url\n\n            response = _fetch_response()\n        except retrying.RetryError as e:\n            # Redirected for REDIRECTION_ATTEMPTS - th time. Throw error\n            msg = (self._(\"URL Redirected %(times)s times continuously. \"\n                          \"URL used: %(start_url)s More info: %(error)s\") %\n                   {'start_url': start_url, 'times': REDIRECTION_ATTEMPTS,\n                    'error': str(e)})\n            LOG.debug(msg)\n            raise exception.IloConnectionError(msg)\n\n        response_body = {}\n        if response.text:\n            try:\n                response_body = json.loads(response.text)\n            except (TypeError, ValueError):\n                # Note(deray): If it doesn't decode as json, then\n                # resources may return gzipped content.\n                # ``json.loads`` on python3 raises TypeError when\n                # ``response.text`` is gzipped one.\n                response_body = (\n                    self._get_response_body_from_gzipped_content(url,\n                                                                 response))\n\n        LOG.debug(self._('\\n\\tHTTP RESPONSE for %(restreq_path)s:'\n                         '\\n\\tCode: %(status_code)s'\n                         '\\n\\tResponse Body: %(response_body)s'\n                         '\\n'),\n                  {'restreq_path': url.geturl(),\n                   'status_code': response.status_code,\n                   'response_body': response_body})\n        return response.status_code, response.headers, response_body", "response": "Generic REST Operation handler."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nrests PATCH operation. HTTP response codes could be 500, 404, 202 etc.", "response": "def _rest_patch(self, suburi, request_headers, request_body):\n        \"\"\"REST PATCH operation.\n\n        HTTP response codes could be 500, 404, 202 etc.\n        \"\"\"\n        return self._rest_op('PATCH', suburi, request_headers, request_body)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nresting PUT operation. HTTP response codes could be 500, 404, 202 etc.", "response": "def _rest_put(self, suburi, request_headers, request_body):\n        \"\"\"REST PUT operation.\n\n        HTTP response codes could be 500, 404, 202 etc.\n        \"\"\"\n        return self._rest_op('PUT', suburi, request_headers, request_body)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _rest_post(self, suburi, request_headers, request_body):\n        return self._rest_op('POST', suburi, request_headers, request_body)", "response": "REST POST operation.\n\n        The response body after the operation could be the new resource, or\n        ExtendedError, or it could be empty."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get(self, cycle_list, dataitem=None, isotope=None, sparse=1):\n        '''\n        Get Data from HDF5 files.\n\n        There are three ways to call this function\n\n        1. get(dataitem)\n\n            Fetches the datatiem for all cycles. If dataitem is a header\n            attribute or list of attributes then the data is retured.\n            If detaitem an individulal or list of column attributes,\n            data columns or isotopes/elements the data is returned for\n            all cycles.\n\n        2. get(cycle_list, dataitem)\n\n            Fetches the dataitem or list of dataitems for the cycle\n            or list of cycles. The variable dataitems can contain column\n            attributes, data columns, and isotopes/elemnts.\n\n        3. get(cycle_list, dataitem, isotope)\n\n            Fetches the dataitems like the seccond method except that\n            one of the dataitems must be either \"iso_massf\" or \"yps\",\n            and in the data returned \"iso_massf\" and \"yps\" are replaced\n            with the data from the isotopes.  The isotopes must be in\n            the form given by se.isotopes or se.elements.\n\n        Parameters\n        ----------\n        cycle_list : list, integer or string\n            If cycle_list is a list or string and all of the entries\n            are header attributes then the attributes are returned.\n\n            If cycle_list is a list or string of dataitems then the\n            dataitems are fetched for all cycles.\n\n            If cycle_list is a list, integer or string of cycle numbers\n            then data is returned for those cycles.\n        dataitem: list or string, optional\n            If dataitem is not None then the data for each item is\n            returned for the cycle or list of cycles. dataitem may be an\n            individual or a mixed list of column attributes, column\n            data or isotopes/elements. If dataitem is None then\n            cycle_list must be a string.  The default is None.\n        isotope: list or string, optional\n            If one of the dataitems is \"iso_massf\" or \"yps\" then it is\n            replaced with the data from the individual isotopes/elements\n            listed in isotope.  The default is None.\n        sparse : int\n            Implements a sparsity factor on the fetched data i.e. only\n            the i th cycle in cycle_list data is returned,\n            where i = sparse.\n\n        '''\n\n#    Check out the inputs\n        t1=time.time()\n        isotopes_of_interest = []\n\n        nested_list = False\n        # if one of cycle_list, dataitem or isotope is given as a string convert it to a list\n        if isinstance(cycle_list, basestring):\n            cycle_list = [cycle_list]\n        else:\n            try:\n                if len(cycle_list) == 1:\n                    nested_list = True\n            except TypeError:\n                pass #leave nested_list as false\n        if isinstance(dataitem, basestring):\n            dataitem = [dataitem]\n        if isinstance(isotope, basestring):\n            isotope = [isotope]\n\n\n\n        if dataitem==None and isotope==None:\n            option_ind = 1\n            dataitem = cycle_list\n\n            if not any([item in self.hattrs for item in dataitem]):\n                cycle_list = self.cycles\n            else:\n                first_file = mrT.File(self.h5s[0].filename,'r')\n                dat = []\n                # get all dataitems from header attributes\n                for item in dataitem:\n                    tmp = first_file.attrs.get(item, None)\n                    try:\n                        if len(tmp) == 1:\n                            tmp = tmp[0]\n                    except TypeError: #if a scaler is returned do nothing\n                        pass\n                    dat.append(tmp)\n                # if only one header attribute is required dont return as a list\n                if (len(dat) == 1) and (not nested_list):\n                    dat = dat[0]\n                first_file.close()\n                return dat\n            if any([item.split('-')[0] in self.isos for item in dataitem]):\n                return self.get(cycle_list,dataitem,sparse=sparse)\n        elif isotope==None:\n            option_ind = 2\n            cycle_list = cycle_list\n            dataitem = dataitem\n            # if one dataitem is given as a string convert it to a list\n            if isinstance(dataitem, basestring):\n                dataitem = [dataitem]\n            new_dataitem = []\n            new_isotopes = []\n            for item in dataitem:\n                if item.split('-')[0] in self.isos:\n                    new_isotopes.append(item)\n                else:\n                    new_dataitem.append(item)\n            if len(new_isotopes) != 0:\n                tmp = []\n                try:\n                    tmp = self.get(cycle_list,new_dataitem + ['iso_massf'],new_isotopes,sparse=sparse)\n                except: # in some old se files there maybe still yps as the name for the abundance arrays\n                    tmp =  self.get(cycle_list,new_dataitem + ['yps'],new_isotopes,sparse=sparse)\n                # modify the dat list so dat is structured like dataitems\n                dat = []\n                #make sure tmp containes the data as a list of cycles\n                if isinstance(cycle_list, basestring):\n                    tmp = [tmp]\n                else:\n                    try:\n                        if len(cycle_list) == 1:\n                            tmp = [tmp]\n                    except TypeError:\n                        tmp = [tmp]\n                for cyc in tmp:\n                    temp_dataitem = []\n                    for item in dataitem:\n                        if item in new_dataitem:\n                            temp_dataitem.append(cyc[new_dataitem.index(item)])\n                        else:\n                            if len(new_dataitem) == 0:\n                                temp_dataitem = cyc\n                            else:\n                                if len(new_isotopes) == 1:\n                                    temp_dataitem.append(cyc[-1])\n                                else:\n                                    temp_dataitem.append(cyc[-1][new_isotopes.index(item)])\n                    dat.append(temp_dataitem)\n                if (len(dat) == 1) and (not nested_list):\n                    dat = dat[0]\n                return dat\n        else:\n# there is an implicite rule here that if you want 2D arrays you have\n# to give 3 args, or, in other words you have to give a cycle or cycle\n# array; there is no good reason for that, except the programmers\n# laziness\n            option_ind = 3\n            cycle_list = cycle_list\n            dataitem = dataitem\n            isotopes_of_interest = isotope\n# we need to find out the shellnb to know if any yps array may just be\n# a one row array, as - for example- in the surf.h5 files\n            # SJONES: I think here we only need to look at the first shellnb(!)\n            #shellnb=self.get(cycle_list,'shellnb')\n            try: #check if cycle_list is not a list\n                cycle_list[0]\n            except (TypeError,IndexError):\n                cycle_list = [cycle_list]\n            shellnb=self.get(cycle_list[0],'shellnb')\n\n        if sparse <1:\n            sparse=1\n\n        #    Just in case the user inputs integers\n        try:\n            for x in range(len(cycle_list)):\n                cycle_list[x] = str(cycle_list[x])\n        except TypeError:\n            cycle_list = [str(cycle_list)]\n\n        if option_ind != 1:\n\n            try: #if it is a single cycle make sure its formatted correctly\n                if cycle_list.isdigit():\n                    cycle_list = [cycle_list]\n                    for cycle in cycle_list:\n                        if len(cycle) != len(self.cycles[0]):\n                                #print \"a\"\n                            diff = len(self.cycles[0])-len(cycle)\n                            OO = ''\n                            while diff >=1:\n                                OO+='0'\n\n                            cycle = OO+cycle\n\n            except AttributeError: ##if it is a list of cycles make sure its formatted correctly\n                if cycle_list[0].isdigit():\n\n                    for x in range(len(cycle_list)):\n                        if len(str(cycle_list[x])) != len(str(self.cycles[0])):\n                            #print \"b\"\n                            diff = len(str(self.cycles[0]))-len(str(cycle_list[x]))\n\n                            OO = ''\n                            while diff >=1:\n                                OO+='0'\n                                diff-=1\n\n                            try:\n                                cycle_list[x] = OO+cycle_list[x]\n                            except TypeError:\n                                cycle_list[0] = OO+cycle_list[0]\n\n        dat = []\n        cycle_list.sort()\n\n        cyclelist=np.array(list(map(int, cycle_list)))\n\n        # cycles_requested is a list of indices from cyclelist\n        # The index of the larges and smallest indices should be stored\n        # in sorted order. As new requests are made if the requests\n        # border or over lap then only keep the index of the larges and\n        # smallest indices.\n        cycles_requested = []\n\n        # Sometimes bad data or last restart.h5 files contain no cycles,\n        # causing the code to crash. Do a simple try/except here:\n        file_min=[]\n        file_max=[]\n        try:\n            for h5 in self.h5s:\n                file_min.append(int(h5.cycle[0]))\n                file_max.append(int(h5.cycle[-1]))\n        except IndexError:\n            print('File '+h5.filename+' contains no data, please remove or rename it')\n            print('Once the file has been removed or renamed, the preprocessor file must be re-written. Do this by either removing the file h5Preproc.txt from the data directory or by invoking the se instance with rewrite=True')\n            print('At present, h5T cannot check for empty files since the overhead using the mounted VOSpace would be too great.')\n            raise IOError('Cycle-less file encountered')\n        file_min.sort()\n        file_max.sort()\n\n        for h5 in self.h5s:\n            #initalize file metadata\n            min_file = int(h5.cycle[0])\n            max_file = int(h5.cycle[-1])\n            min_list = int(cyclelist[0])\n            max_list = int(cyclelist[-1])\n            index_min = None #if None start at begining\n            index_max = None #if None finish at end\n\n            # SJONES Now we need to add the case that the set only contains one file:\n            if len(file_min) == 1:\n                min_file = min_list - 1\n                max_file = max_list + 1\n            else:\n                file_index = file_min.index(min_file)\n                if file_index == 0:\n                    if min_list - 1 < min_file:\n                        min_file = min_list - 1\n                    max_file = (file_min[file_index + 1] + max_file)//2\n                elif file_index == len(file_min) - 1:\n                    min_file = (file_max[file_index - 1] + min_file)//2 + 1\n                    if max_list + 1 > max_file:\n                        max_file = max_list + 1\n                else:\n                    min_file = (file_max[file_index - 1] + min_file)//2 + 1\n                    max_file = (file_min[file_index + 1] + max_file)//2\n\n            # calculate the left and right limits of the intersection\n            # of the lists h5.cycle and cyclelist\n            if (max_list < min_file) or (max_file < min_list):\n            # the lists do not intersect\n                continue\n            elif (min_list <= min_file) and (max_file <= max_list):\n                # all of h5.cycle is within cyclelist\n                index_min = bisect.bisect_left(cyclelist, min_file)\n                index_max = bisect.bisect_right(cyclelist, max_file)\n            elif (min_file <= min_list) and (max_list <= max_file):\n                # all of cyclelist is within h5.cycle\n                index_min = None\n                index_max = None\n            else:\n                if min_list > min_file:\n                # cyclelist overlaps the right edge of h5.cycle\n                    index_min = None\n                    index_max = bisect.bisect_right(cyclelist, max_file)\n                else:\n                    # cyclelist overlaps the left edge of h5.cylce\n                    index_min = bisect.bisect_left(cyclelist, min_file)\n                    index_max = None\n\n            # maintin list of all requested cycles by keeping trak of\n            # the maximum and minimum indices\n            imin = index_min\n            if index_min == None:\n                imin = 0\n\n            imax = index_max\n            if index_max == None:\n                imax = len(cyclelist)\n\n            request_min = bisect.bisect_left(cycles_requested, imin)\n            request_max = bisect.bisect_right(cycles_requested, imax)\n\n            # if the new request overlabs older request remove them\n            del cycles_requested[request_min:request_max]\n            if ((request_max-request_min) % 2) ==1:\n                # new and old request overlaped on one edge only\n                if request_min % 2 == 0:\n                    # add new starting index\n                    cycles_requested.insert(request_min, imin)\n                else:\n                    # add new ending index\n                    cycles_requested.insert(request_min, imax)\n            else:\n                # new and old requests overlaped on two edges\n                if request_min % 2 == 0:\n                    # old request was contained with in new request\n                    cycles_requested.insert(request_min, imin)\n                    cycles_requested.insert(request_min + 1, imax)\n                else:\n                    # new request wat contained within old request\n                    pass\n\n            if not self.h5sStarted[self.h5s.index(h5)]:\n                h5.start()\n                h5.join()\n                temp = h5.fetch_data_sam(dataitem,cycle_list[index_min:index_max],len(cycle_list),len(dat))\n                self.h5sStarted[self.h5s.index(h5)]=True\n            else:\n                temp = h5.fetch_data_sam(dataitem,cycle_list[index_min:index_max],len(cycle_list),len(dat))\n\n            temp_dat = []\n            for temp_num, temp_cycle in enumerate(temp):\n                temp_dataforcycle = []\n                for dataitem_num, temp_dataitem in enumerate(temp_cycle):\n                    # identify what cycle the temp data was collected from\n                    temp_dataitem=self.red_dim(temp_dataitem)\n#                    if option_ind == 3 and isotopes_of_interest != []:\n                    if (dataitem[dataitem_num] == 'iso_massf' or dataitem[dataitem_num] == 'yps') and isotopes_of_interest != []:\n                    #    Figure out the index\n                        index = []\n                        iso_tmp = []\n\n                        if 'iso' in dataitem[dataitem_num]: #if we are looking at an isotope\n                            iso_tmp = self.isotopes\n                        else:\n                            iso_tmp = self.elements\n\n                        for iso in isotopes_of_interest: #finds the location of the isotope\n                            x = iso_tmp.index(iso)\n                            index.append(x)\n\n                        if index == []:\n                            # if none of the isotopes of interest are found\n                            # then the index defaults to [0], so that the loop\n                            # will still try to acess the data in t.\n                            index = [0]\n                        islist=True\n\n                        if len(cycle_list)==1:\n                            islist=False\n\n#                        shellnb_index = 0\n#                        if index_min == None:\n#                            shellnb_index = temp_num\n#                        else:\n#                            shellnb_index = index_min + temp_num\n                        temp_multicyc = []\n                        for i in index:\n#                            if islist:\n#                                if shellnb[shellnb_index] == 1:    # again take care of 1-row 2D arrays\n                                if shellnb == 1:    # again take care of 1-row 2D arrays\n                                    temp_multicyc.append(temp_dataitem[i])\n                                else:\n                                    temp_multicyc.append(temp_dataitem[:,i])\n#                            else:\n#                                if shellnb == 1:    # again take care of 1-row 2D arrays\n#                                    temp_multicyc.append(temp_dataitem[i])\n#                                else:\n#                                    temp_multicyc.append(temp_dataitem[:,i])\n                        if len(temp_multicyc) == 1: # agian take care of 1-row arrays\n                            temp_multicyc = temp_multicyc[0]\n                        temp_dataitem = temp_multicyc\n                    temp_dataforcycle.append(temp_dataitem)\n                if len(temp_dataforcycle) == 1: # agian take care of 1-row arrays\n                    temp_dataforcycle = temp_dataforcycle[0]\n                # Now add the information to the list we pass back\n                temp_dat.append(temp_dataforcycle)\n            # calculate the proper insertion point for the data colected from\n            # the file h5 in self.h5s\n            insert_pnt = 0\n            if index_min is not None: #alex: in py2: x < None == False\n                for i in range(len(cycles_requested)):\n                    if i % 2 == 1:\n                        if cycles_requested[i] < index_min:\n                            insert_pnt += cycles_requested[i] - cycles_requested[i-1]\n                        elif cycles_requested[i - 1] < index_min:\n                            insert_pnt += index_min - cycles_requested[i - 1]\n            # insert the cycle data from the current file into the apropiat place\n            # in the output data.\n            dat[insert_pnt:insert_pnt] = temp_dat\n\n        #check if cycles were not requested from the file\n# SJONES comment\n#        missing_cycles = np.array([])\n#        if len(cycles_requested) != 2:\n#            if len(cycles_requested) == 0:\n#                missing_cycles = np.array([cycle_list])\n#            else:\n#                cycles_requested = [None] + cycles_requested + [None]\n#                for i in xrange(0, len(cycles_requested), 2):\n#                    min = cycles_requested[i]\n#                    max = cycles_requested[i + 1]\n#                    missing_cycles = np.append(missing_cycles, cycle_list[min:max])\n#            print \"The requested cycles: \" + str(missing_cycles) + \" are not available in this data set\"\n#        elif (cycles_requested[0] != 0) or (cycles_requested[1] != len(cyclelist)):\n#            min = cycles_requested[0]\n#            max = cycles_requested[1]\n#            missing_cycles = np.append(missing_cycles, cycle_list[0:min])\n#            missing_cycles = np.append(missing_cycles, cycle_list[max:])\n#            print \"The requested cycles: \" + str(missing_cycles) + \" are not available in this data set\"\n\n        if len(dat) < 2 and option_ind != 3 and (not nested_list):\n            try:\n                dat = dat[0]\n            except IndexError:\n                None\n            except TypeError:\n                None\n        try:\n            if len(dat) < 2 and isotopes_of_interest != []:\n                dat = dat[0]\n        except TypeError:\n            None\n        except IndexError:\n            None\n        t2=time.time()\n        return dat", "response": "Get the data from HDF5 files."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _perform_request(self, request, parser=None, parser_args=None, operation_context=None):\n        '''\n        Sends the request and return response. Catches HTTPError and hands it\n        to error handler\n        '''\n        operation_context = operation_context or _OperationContext()\n        retry_context = RetryContext()\n        retry_context.is_emulated = self.is_emulated\n\n        # Apply the appropriate host based on the location mode\n        self._apply_host(request, operation_context, retry_context)\n\n        # Apply common settings to the request\n        _update_request(request, self._X_MS_VERSION, self._USER_AGENT_STRING)\n        client_request_id_prefix = str.format(\"Client-Request-ID={0}\", request.headers['x-ms-client-request-id'])\n\n        while True:\n            try:\n                try:\n                    # Execute the request callback \n                    if self.request_callback:\n                        self.request_callback(request)\n\n                    # Add date and auth after the callback so date doesn't get too old and \n                    # authentication is still correct if signed headers are added in the request \n                    # callback. This also ensures retry policies with long back offs \n                    # will work as it resets the time sensitive headers.\n                    _add_date_header(request)\n                    self.authentication.sign_request(request)\n\n                    # Set the request context\n                    retry_context.request = request\n\n                    # Log the request before it goes out\n                    logger.info(\"%s Outgoing request: Method=%s, Path=%s, Query=%s, Headers=%s.\",\n                                client_request_id_prefix,\n                                request.method,\n                                request.path,\n                                request.query,\n                                str(request.headers).replace('\\n', ''))\n\n                    # Perform the request\n                    response = self._httpclient.perform_request(request)\n\n                    # Execute the response callback\n                    if self.response_callback:\n                        self.response_callback(response)\n\n                    # Set the response context\n                    retry_context.response = response\n\n                    # Log the response when it comes back\n                    logger.info(\"%s Receiving Response: \"\n                                \"%s, HTTP Status Code=%s, Message=%s, Headers=%s.\",\n                                client_request_id_prefix,\n                                self.extract_date_and_request_id(retry_context),\n                                response.status,\n                                response.message,\n                                str(request.headers).replace('\\n', ''))\n\n                    # Parse and wrap HTTP errors in AzureHttpError which inherits from AzureException\n                    if response.status >= 300:\n                        # This exception will be caught by the general error handler\n                        # and raised as an azure http exception\n                        _http_error_handler(\n                            HTTPError(response.status, response.message, response.headers, response.body))\n\n                    # Parse the response\n                    if parser:\n                        if parser_args:\n                            args = [response]\n                            args.extend(parser_args)\n                            return parser(*args)\n                        else:\n                            return parser(response)\n                    else:\n                        return\n                except AzureException as ex:\n                    retry_context.exception = ex\n                    raise ex\n                except Exception as ex:\n                    retry_context.exception = ex\n                    if sys.version_info >= (3,):\n                        # Automatic chaining in Python 3 means we keep the trace\n                        raise AzureException(ex.args[0])\n                    else:\n                        # There isn't a good solution in 2 for keeping the stack trace \n                        # in general, or that will not result in an error in 3\n                        # However, we can keep the previous error type and message\n                        # TODO: In the future we will log the trace\n                        msg = \"\"\n                        if len(ex.args) > 0:\n                            msg = ex.args[0]\n                        raise AzureException('{}: {}'.format(ex.__class__.__name__, msg))\n\n            except AzureException as ex:\n                # only parse the strings used for logging if logging is at least enabled for CRITICAL\n                if logger.isEnabledFor(logging.CRITICAL):\n                    exception_str_in_one_line = str(ex).replace('\\n', '')\n                    status_code = retry_context.response.status if retry_context.response is not None else 'Unknown'\n                    timestamp_and_request_id = self.extract_date_and_request_id(retry_context)\n\n                logger.info(\"%s Operation failed: checking if the operation should be retried. \"\n                            \"Current retry count=%s, %s, HTTP status code=%s, Exception=%s.\",\n                            client_request_id_prefix,\n                            retry_context.count if hasattr(retry_context, 'count') else 0,\n                            timestamp_and_request_id,\n                            status_code,\n                            exception_str_in_one_line)\n\n                # Decryption failures (invalid objects, invalid algorithms, data unencrypted in strict mode, etc)\n                # will not be resolved with retries.\n                if str(ex) == _ERROR_DECRYPTION_FAILURE:\n                    logger.error(\"%s Encountered decryption failure: this cannot be retried. \"\n                                 \"%s, HTTP status code=%s, Exception=%s.\",\n                                 client_request_id_prefix,\n                                 timestamp_and_request_id,\n                                 status_code,\n                                 exception_str_in_one_line)\n                    raise ex\n\n                # Determine whether a retry should be performed and if so, how \n                # long to wait before performing retry.\n                retry_interval = self.retry(retry_context)\n                if retry_interval is not None:\n                    # Execute the callback\n                    if self.retry_callback:\n                        self.retry_callback(retry_context)\n\n                    logger.info(\n                        \"%s Retry policy is allowing a retry: Retry count=%s, Interval=%s.\",\n                        client_request_id_prefix,\n                        retry_context.count,\n                        retry_interval)\n\n                    # Sleep for the desired retry interval\n                    sleep(retry_interval)\n                else:\n                    logger.error(\"%s Retry policy did not allow for a retry: \"\n                                 \"%s, HTTP status code=%s, Exception=%s.\",\n                                 client_request_id_prefix,\n                                 timestamp_and_request_id,\n                                 status_code,\n                                 exception_str_in_one_line)\n                    raise ex\n            finally:\n                # If this is a location locked operation and the location is not set, \n                # this is the first request of that operation. Set the location to \n                # be used for subsequent requests in the operation.\n                if operation_context.location_lock and not operation_context.host_location:\n                    # note: to cover the emulator scenario, the host_location is grabbed\n                    # from request.host_locations(which includes the dev account name)\n                    # instead of request.host(which at this point no longer includes the dev account name)\n                    operation_context.host_location = {retry_context.location_mode: request.host_locations[retry_context.location_mode]}", "response": "Perform a request and return the response. Catches HTTPError and hands it to error handler."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nplots a chart with fluxes Parameters ---------- file_name : string Name of the file of fluxes we are looking at. plotaxis : list [xmin, xmax, ymin, ymax], where on x axis there is neutron number and on y axis there is Z. plot_types : integer Set to 0 for standard flux plot. Set to 1 if fluxes focused on one specie. which_flux : integer, optional Set to 0 for nucleosynthesis flux plot. Set to 1 is for energy flux plot. Seting to None is the same a 0. The default is None. I_am_the_target : list, optional A 2xArray used only if plot_type=1, and is given by [neutron number, proton number]. The default is None. prange : integer, optional The range of fluxes to be considered. If prange is None, then 8 fluxes are consdered. The default is None. Notes ----- This script is terribly slow and needs to be improved. For now I put here in data_plot: [1]: import data_plot [2]: data_plot.flux_chart('file_name', [xmin, xmax, ymin, ymax], int, which_flux, I_am_the_target, prange) The pdf is created, but an error bumped up and the gui is empty. To avoid this, I had to set 'text.usetex': False. See below. Also, for the same reason no label in x axys is written using 'text.usetex': True. Note also that the GUI works really slow with this plot. So, we need to optimize from the graphic point of view. This need to be included in ppn.py I think, and set in multi option too, in case we want to read more flux files at the same time. Finally, you need to have stable.dat to read in to make it work ...", "response": "def flux_chart(file_name, plotaxis, plot_type, which_flux=None,\n               I_am_the_target=None, prange=None):\n    '''\n    Plots a chart with fluxes\n\n    Parameters\n    ----------\n    file_name : string\n        Name of the file of fluxes we are looking at.\n    plotaxis : list\n        [xmin, xmax, ymin, ymax], where on x axis there is neutron\n        number and on y axis there is Z.\n    plot_types : integer\n        Set to 0 for standard flux plot.  Set to 1 if fluxes focused\n        on one specie.\n    which_flux : integer, optional\n        Set to 0 for nucleosynthesis flux plot.  Set to 1 is for energy\n        flux plot.  Seting to None is the same a 0.  The default is\n        None.\n    I_am_the_target : list, optional\n        A 2xArray used only if plot_type=1, and is given by [neutron\n        number, proton number].  The default is None.\n    prange : integer, optional\n        The range of fluxes to be considered.  If prange is None, then\n        8 fluxes are consdered.  The default is None.\n\n    Notes\n    -----\n    This script is terribly slow and needs to be improved.  For now I\n    put here in data_plot:\n\n    [1]: import data_plot\n\n    [2]: data_plot.flux_chart('file_name', [xmin, xmax, ymin, ymax],\n                              int, which_flux, I_am_the_target, prange)\n\n    The pdf is created, but an error bumped up and the gui is empty.\n    To avoid this, I had to set 'text.usetex': False.  See below.  Also,\n    for the same reason no label in x axys is written using\n    'text.usetex': True.\n\n    Note also that the GUI works really slow with this plot.  So, we\n    need to optimize from the graphic point of view.  This need to be\n    included in ppn.py I think, and set in multi option too, in case\n    we want to read more flux files at the same time.\n\n    Finally, you need to have stable.dat to read in to make it work ...\n\n    '''\n\n    import numpy as np\n    import matplotlib.pyplot as plt\n    #from matplotlib.mpl import colors,cm # deppreciated in mpl ver 1.3\n                                          # use line below instead\n    from matplotlib import colors,cm\n    from matplotlib.patches import Rectangle, Arrow\n    from matplotlib.collections import PatchCollection\n    from matplotlib.offsetbox import AnchoredOffsetbox, TextArea\n    import sys\n\n    print_max_flux_in_plot =  True\n\n\n    f = open(file_name)\n    lines = f.readline()\n    lines = f.readlines()\n    f.close()\n\n    # starting point of arrow\n    coord_x_1 = []\n    coord_y_1 = []\n    # ending point of arrow (option 1)\n    coord_x_2 = []\n    coord_y_2 = []\n    # ending point of arrow (option 2)\n    coord_x_3 = []\n    coord_y_3 = []\n    # fluxes\n    flux_read = []\n    flux_log10 = []\n\n    if which_flux == None or which_flux == 0:\n        print('chart for nucleosynthesis fluxes [dYi/dt]')\n        line_to_read = 9\n    elif which_flux == 1:\n        print('chart for energy fluxes')\n        line_to_read = 10\n    elif which_flux == 2:\n        print('chart for timescales')\n        line_to_read = 11\n    elif which_flux > 2:\n        print(\"you have only option 0, 1 or 2, not larger than 2\")\n\n    single_line = []\n    for i in range(len(lines)):\n        single_line.append(lines[i].split())\n        coord_y_1.append(float(single_line[i][1]))\n        coord_x_1.append(float(single_line[i][2])-coord_y_1[i])\n        coord_y_2.append(float(single_line[i][5]))\n        coord_x_2.append(float(single_line[i][6])-coord_y_2[i])\n        coord_y_3.append(float(single_line[i][7]))\n        coord_x_3.append(float(single_line[i][8])-coord_y_3[i])\n        try:\n            flux_read.append(float(single_line[i][line_to_read]))\n        except ValueError: # this is done to avoid format issues like 3.13725-181...\n            flux_read.append(1.0E-99)\n        flux_log10.append(np.log10(flux_read[i]+1.0e-99))\n\n    print('file read!')\n\n    # I need to select smaller sample, with only fluxes inside plotaxis.\n    coord_y_1_small=[]\n    coord_x_1_small=[]\n    coord_y_2_small=[]\n    coord_x_2_small=[]\n    coord_y_3_small=[]\n    coord_x_3_small=[]\n    flux_log10_small = []\n    for i in range(len(flux_log10)):\n        I_am_in = 0\n        if coord_y_1[i] > plotaxis[2] and coord_y_1[i] < plotaxis[3] and coord_x_1[i] > plotaxis[0] and coord_x_1[i] < plotaxis[1]:\n            I_am_in = 1\n            coord_y_1_small.append(coord_y_1[i])\n            coord_x_1_small.append(coord_x_1[i])\n            coord_y_2_small.append(coord_y_2[i])\n            coord_x_2_small.append(coord_x_2[i])\n            coord_y_3_small.append(coord_y_3[i])\n            coord_x_3_small.append(coord_x_3[i])\n            flux_log10_small.append(flux_log10[i])\n        if coord_y_3[i] > plotaxis[2] and coord_y_3[i] < plotaxis[3] and coord_x_3[i] > plotaxis[0] and coord_x_3[i] < plotaxis[1] and I_am_in == 0:\n            I_am_in = 1\n            coord_y_1_small.append(coord_y_1[i])\n            coord_x_1_small.append(coord_x_1[i])\n            coord_y_2_small.append(coord_y_2[i])\n            coord_x_2_small.append(coord_x_2[i])\n            coord_y_3_small.append(coord_y_3[i])\n            coord_x_3_small.append(coord_x_3[i])\n            flux_log10_small.append(flux_log10[i])\n\n\n    if plot_type == 1:\n        print('I_am_the_target=',I_am_the_target)\n        #I_am_the_target = [56.-26.,26.]\n    # here below need for plotting\n    # plotaxis = [xmin,xmax,ymin,ymax]\n    #plotaxis=[1,20,1,20]\n    #plotaxis=[0,0,0,0]\n\n    # elemental labels off/on [0/1]\n    ilabel = 1\n\n    # label for isotopic masses off/on [0/1]\n    imlabel = 1\n\n    # turn lines for magic numbers off/on [0/1]\n    imagic = 0\n\n    # flow is plotted over \"prange\" dex. If flow < maxflow-prange it is not plotted\n    if prange == None:\n        print('plot range given by default')\n        prange = 8.\n\n    #############################################\n\n    # we should scale prange on plot_axis range, not on max_flux!\n    max_flux = max(flux_log10)\n    ind_max_flux = flux_log10.index(max_flux)\n    max_flux_small = max(flux_log10_small)\n    min_flux = min(flux_log10)\n    ind_min_flux = flux_log10.index(min_flux)\n    min_flux_small = min(flux_log10_small)\n\n    #nzmax = int(max(max(coord_y_1),max(coord_y_2),max(coord_y_3)))+1\n    #nnmax = int(max(max(coord_x_1),max(coord_x_2),max(coord_x_3)))+1\n    nzmax = int(max(max(coord_y_1_small),max(coord_y_2_small),max(coord_y_3_small)))+1\n    nnmax = int(max(max(coord_x_1_small),max(coord_x_2_small),max(coord_x_3_small)))+1\n\n\n    nzycheck = np.zeros([nnmax,nzmax,3])\n    #coord_x_out = np.zeros(len(coord_x_2))\n    #coord_y_out = np.zeros(len(coord_y_2))\n    #for i in range(len(flux_log10)):\n    #       nzycheck[coord_x_1[i],coord_y_1[i],0] = 1\n    #       nzycheck[coord_x_1[i],coord_y_1[i],1] = flux_log10[i]\n    #       if coord_x_2[i] >= coord_x_3[i]:\n    #                coord_x_out[i] = coord_x_2[i]\n    #                coord_y_out[i] = coord_y_2[i]\n    #               nzycheck[coord_x_out[i],coord_y_out[i],0] = 1\n    #               nzycheck[coord_x_out[i],coord_y_out[i],1] = flux_log10[i]\n    #        elif coord_x_2[i] < coord_x_3[i]:\n    #                coord_x_out[i] = coord_x_3[i]\n    #                coord_y_out[i] = coord_y_3[i]\n    #               nzycheck[coord_x_out[i],coord_y_out[i],0] = 1\n    #               nzycheck[coord_x_out[i],coord_y_out[i],1] = flux_log10[i]\n    #       if flux_log10[i]>max_flux-prange:\n    #               nzycheck[coord_x_1[i],coord_y_1[i],2] = 1\n    #               nzycheck[coord_x_out[i],coord_y_out[i],2] = 1\n    coord_x_out = np.zeros(len(coord_x_2_small))\n    coord_y_out = np.zeros(len(coord_y_2_small))\n    for i in range(len(flux_log10_small)):\n        nzycheck[coord_x_1_small[i],coord_y_1_small[i],0] = 1\n        nzycheck[coord_x_1_small[i],coord_y_1_small[i],1] = flux_log10_small[i]\n        if coord_x_2_small[i] >= coord_x_3_small[i]:\n            coord_x_out[i] = coord_x_2_small[i]\n            coord_y_out[i] = coord_y_2_small[i]\n            nzycheck[coord_x_out[i],coord_y_out[i],0] = 1\n            nzycheck[coord_x_out[i],coord_y_out[i],1] = flux_log10_small[i]\n        elif coord_x_2_small[i] < coord_x_3_small[i]:\n            coord_x_out[i] = coord_x_3_small[i]\n            coord_y_out[i] = coord_y_3_small[i]\n            nzycheck[coord_x_out[i],coord_y_out[i],0] = 1\n            nzycheck[coord_x_out[i],coord_y_out[i],1] = flux_log10_small[i]\n        if which_flux == None or which_flux < 2 and flux_log10_small[i]>max_flux_small-prange:\n            nzycheck[coord_x_1_small[i],coord_y_1_small[i],2] = 1\n            nzycheck[coord_x_out[i],coord_y_out[i],2] = 1\n        elif which_flux == 2 and flux_log10_small[i]<min_flux_small+prange:\n            nzycheck[coord_x_1_small[i],coord_y_1_small[i],2] = 1\n            nzycheck[coord_x_out[i],coord_y_out[i],2] = 1\n\n    #######################################################################\n    # elemental names: elname(i) is the name of element with Z=i\n    elname= ('none','H','He','Li','Be','B','C','N','O','F','Ne','Na','Mg','Al','Si','P','S','Cl','Ar','K','Ca','Sc','Ti','V','Cr','Mn','Fe',\n    'Co','Ni','Cu','Zn','Ga','Ge','As','Se','Br','Kr','Rb','Sr','Y','Zr','Nb','Mo','Tc','Ru','Rh','Pd','Ag','Cd','In','Sn','Sb',\n    'Te', 'I','Xe','Cs','Ba','La','Ce','Pr','Nd','Pm','Sm','Eu','Gd','Tb','Dy','Ho','Er','Tm','Yb','Lu','Hf','Ta','W','Re','Os',\n    'Ir','Pt','Au','Hg','Tl','Pb','Bi','Po','At','Rn','Fr','Ra','Ac','Th','Pa','U','Np','Pu')\n\n\n    #### create plot\n\n    ## define axis and plot style (colormap, size, fontsize etc.)\n    if plotaxis==[0,0,0,0]:\n        xdim=10\n        ydim=6\n    else:\n        dx = plotaxis[1]-plotaxis[0]\n        dy = plotaxis[3]-plotaxis[2]\n        ydim = 6\n        xdim = ydim*dx/dy\n\n    format = 'pdf'\n    # note that I had to set 'text.usetex': False, to avoid Exception in Tkinter callback.\n    # and to make the GUI work properly. Why? some missing package?\n    params = {'axes.labelsize':  15,\n      'text.fontsize':   15,\n      'legend.fontsize': 15,\n      'xtick.labelsize': 15,\n      'ytick.labelsize': 15,\n      'text.usetex': False}\n    plt.rcParams.update(params)\n    fig=plt.figure(figsize=(xdim,ydim),dpi=100)\n    axx = 0.10\n    axy = 0.10\n    axw = 0.85\n    axh = 0.8\n    ax=plt.axes([axx,axy,axw,axh])\n\n    # color map choice for abundances\n    cmapa = cm.jet\n    # color map choice for arrows\n    if which_flux == None or which_flux < 2:\n        cmapr = cm.autumn\n    elif  which_flux == 2:\n        cmapr = cm.autumn_r\n    # if a value is below the lower limit its set to white\n    cmapa.set_under(color='w')\n    cmapr.set_under(color='w')\n    # set value range for abundance colors (log10(Y))\n    norma = colors.Normalize(vmin=-20,vmax=0)\n    # set x- and y-axis scale aspect ratio to 1\n    ax.set_aspect('equal')\n    #print time,temp and density on top\n    #temp = '%8.3e' %ff['temp']\n    #time = '%8.3e' %ff['time']\n    #dens = '%8.3e' %ff['dens']\n\n    #box1 = TextArea(\"t : \" + time + \" s~~/~~T$_{9}$ : \" + temp + \"~~/~~$\\\\rho_{b}$ : \" \\\n    #      + dens + ' g/cm$^{3}$', textprops=dict(color=\"k\"))\n    #anchored_box = AnchoredOffsetbox(loc=3,\n    #        child=box1, pad=0.,\n    #        frameon=False,\n    #        bbox_to_anchor=(0., 1.02),\n    #        bbox_transform=ax.transAxes,\n    #        borderpad=0.,\n    #        )\n    #ax.add_artist(anchored_box)\n\n    # Add black frames for stable isotopes\n    f = open('stable.dat')\n\n    head = f.readline()\n    stable = []\n\n    for line in f.readlines():\n        tmp = line.split()\n        zz = int(tmp[2])\n        nn = int(tmp[3])\n        xy = nn-0.5,zz-0.5\n        rect = Rectangle(xy,1,1,ec='k',fc='None',fill='False',lw=3.)\n        rect.set_zorder(2)\n        ax.add_patch(rect)\n\n    apatches = []\n    acolor = []\n    m = old_div(0.8,prange)#0.8/prange\n    if which_flux == None or which_flux < 2:\n        vmax=np.ceil(max(flux_log10_small))\n        vmin=max(flux_log10_small)-prange\n        b=-vmin*m+0.1\n    elif which_flux == 2:\n        vmin=min(flux_log10_small)\n        vmax=np.ceil(min(flux_log10_small)+prange)\n        b=vmax*m+0.1\n    if which_flux == None or which_flux < 3:\n        normr = colors.Normalize(vmin=vmin,vmax=vmax)\n        print('vmin and vmax =',vmin,vmax)\n    ymax=0.\n    xmax=0.\n\n    for i in range(len(flux_log10_small)):\n        x = coord_x_1_small[i]\n        y = coord_y_1_small[i]\n        dx = coord_x_out[i]-coord_x_1_small[i]\n        dy = coord_y_out[i]-coord_y_1_small[i]\n        if plot_type == 0:\n            if which_flux == None or which_flux < 2:\n                if flux_log10_small[i]>=vmin:\n                    arrowwidth = flux_log10_small[i]*m+b\n                    arrow = Arrow(x,y,dx,dy, width=arrowwidth)\n                    if xmax<x:\n                        xmax=x\n                    if ymax<y:\n                        ymax=y\n                    acol = flux_log10_small[i]\n                    apatches.append(arrow)\n                    acolor.append(acol)\n            elif which_flux == 2:\n                if flux_log10_small[i]<=vmax:\n                    arrowwidth = -flux_log10_small[i]*m+b\n                    arrow = Arrow(x,y,dx,dy, width=arrowwidth)\n                    if xmax<x:\n                        xmax=x\n                    if ymax<y:\n                        ymax=y\n                    acol = flux_log10_small[i]\n                    apatches.append(arrow)\n                    acolor.append(acol)\n        elif plot_type == 1 and which_flux != 2:\n            if x==I_am_the_target[0] and y==I_am_the_target[1] and flux_log10_small[i]>=vmin:\n                arrowwidth = flux_log10_small[i]*m+b\n                arrow = Arrow(x,y,dx,dy, width=arrowwidth)\n                if xmax<x:\n                    xmax=x\n                if ymax<y:\n                    ymax=y\n                acol = flux_log10_small[i]\n                apatches.append(arrow)\n                acolor.append(acol)\n            if x+dx==I_am_the_target[0] and y+dy==I_am_the_target[1] and flux_log10_small[i]>=vmin:\n                arrowwidth = flux_log10_small[i]*m+b\n                arrow = Arrow(x,y,dx,dy, width=arrowwidth)\n                if xmax<x:\n                    xmax=x\n                if ymax<y:\n                    ymax=y\n                acol = flux_log10_small[i]\n                apatches.append(arrow)\n                acolor.append(acol)\n        elif plot_type == 1 and which_flux == 2:\n            if x==I_am_the_target[0] and y==I_am_the_target[1] and flux_log10_small[i]<=vmax:\n                arrowwidth = -flux_log10_small[i]*m+b\n                arrow = Arrow(x,y,dx,dy, width=arrowwidth)\n                if xmax<x:\n                    xmax=x\n                if ymax<y:\n                    ymax=y\n                acol = flux_log10_small[i]\n                apatches.append(arrow)\n                acolor.append(acol)\n            if x+dx==I_am_the_target[0] and y+dy==I_am_the_target[1] and flux_log10_small[i]<=vmax:\n                arrowwidth = -flux_log10_small[i]*m+b\n                arrow = Arrow(x,y,dx,dy, width=arrowwidth)\n                if xmax<x:\n                    xmax=x\n                if ymax<y:\n                    ymax=y\n                acol = flux_log10_small[i]\n                apatches.append(arrow)\n                acolor.append(acol)\n\n    #apatches = []\n    #acolor = []\n    #m = 0.8/prange\n    #vmax=np.ceil(max(flux_log10))\n    #vmin=max(flux_log10)-prange\n    #b=-vmin*m+0.1\n    #normr = colors.Normalize(vmin=vmin,vmax=vmax)\n    #ymax=0.\n    #xmax=0.\n\n    #for i in range(len(flux_log10)):\n    #       x = coord_x_1[i]\n    #       y = coord_y_1[i]\n    #       dx = coord_x_out[i]-coord_x_1[i]\n    #       dy = coord_y_out[i]-coord_y_1[i]\n    #       if plot_type == 0:\n    #               if flux_log10[i]>=vmin:\n    #                       arrowwidth = flux_log10[i]*m+b\n    #                       arrow = Arrow(x,y,dx,dy, width=arrowwidth)\n    #                       if xmax<x:\n    #                               xmax=x\n    #                       if ymax<y:\n    #                               ymax=y\n    #                       acol = flux_log10[i]\n    #                       apatches.append(arrow)\n    #                       acolor.append(acol)\n    #       elif plot_type == 1:\n    #               if x==I_am_the_target[0] and y==I_am_the_target[1] and flux_log10[i]>=vmin:\n    #                       arrowwidth = flux_log10[i]*m+b\n    #                       arrow = Arrow(x,y,dx,dy, width=arrowwidth)\n    #                       if xmax<x:\n    #                               xmax=x\n    #                       if ymax<y:\n    #                               ymax=y\n    #                       acol = flux_log10[i]\n    #                       apatches.append(arrow)\n    #                       acolor.append(acol)\n    #               if x+dx==I_am_the_target[0] and y+dy==I_am_the_target[1] and flux_log10[i]>=vmin:\n    #                       arrowwidth = flux_log10[i]*m+b\n    #                       arrow = Arrow(x,y,dx,dy, width=arrowwidth)\n    #                       if xmax<x:\n    #                               xmax=x\n    #                       if ymax<y:\n    #                               ymax=y\n    #                       acol = flux_log10[i]\n    #                       apatches.append(arrow)\n    #                       acolor.append(acol)\n    #\n\n\n        xy = x-0.5,y-0.5\n        rect = Rectangle(xy,1,1,ec='k',fc='None',fill='False',lw=1.)\n        rect.set_zorder(2)\n        ax.add_patch(rect)\n        xy = x+dx-0.5,y+dy-0.5\n        rect = Rectangle(xy,1,1,ec='k',fc='None',fill='False',lw=1.)\n        rect.set_zorder(2)\n        ax.add_patch(rect)\n\n\n    a = PatchCollection(apatches, cmap=cmapr, norm=normr)\n    a.set_array(np.array(acolor))\n    a.set_zorder(3)\n    ax.add_collection(a)\n    cb = plt.colorbar(a)\n\n    # colorbar label\n    if which_flux == None or which_flux == 0:\n        cb.set_label('log$_{10}$(f)')\n    elif which_flux ==1:\n        cb.set_label('log$_{10}$(E)')\n    elif which_flux ==2:\n        cb.set_label('log$_{10}$(timescale)')\n\n\n    # plot file name\n    graphname = 'flow-chart.'+format\n\n    # decide which array to take for label positions\n    iarr = 2\n\n    # plot element labels\n    for z in range(nzmax):\n        try:\n            nmin = min(np.argwhere(nzycheck[:,z,iarr-2]))[0]-1\n            ax.text(nmin,z,elname[z],horizontalalignment='center',verticalalignment='center',fontsize='medium',clip_on=True)\n        except ValueError:\n            continue\n\n    # plot mass numbers\n    if imlabel==1:\n        for z in range(nzmax):\n            for n in range(nnmax):\n                a = z+n\n                if nzycheck[n,z,iarr-2]==1:\n                    ax.text(n,z,a,horizontalalignment='center',verticalalignment='center',fontsize='small',clip_on=True)\n\n    # plot lines at magic numbers\n    if imagic==1:\n        ixymagic=[2, 8, 20, 28, 50, 82, 126]\n        nmagic = len(ixymagic)\n        for magic in ixymagic:\n            if magic<=nzmax:\n                try:\n                    xnmin = min(np.argwhere(nzycheck[:,magic,iarr-2]))[0]\n                    xnmax = max(np.argwhere(nzycheck[:,magic,iarr-2]))[0]\n                    line = ax.plot([xnmin,xnmax],[magic,magic],lw=3.,color='r',ls='-')\n                except ValueError:\n                    dummy=0\n            if magic<=nnmax:\n                try:\n                    yzmin = min(np.argwhere(nzycheck[magic,:,iarr-2]))[0]\n                    yzmax = max(np.argwhere(nzycheck[magic,:,iarr-2]))[0]\n                    line = ax.plot([magic,magic],[yzmin,yzmax],lw=3.,color='r',ls='-')\n                except ValueError:\n                    dummy=0\n\n    # set axis limits\n    if plotaxis==[0,0,0,0]:\n        ax.axis([-0.5,xmax+0.5,-0.5,ymax+0.5])\n    else:\n        ax.axis(plotaxis)\n\n    # set x- and y-axis label\n    ax.set_xlabel('neutron number')\n    ax.set_ylabel('proton number')\n    if which_flux == None or which_flux == 0:\n        max_flux_label=\"max flux = \"+str('{0:.4f}'.format(max_flux))\n    elif which_flux == 1:\n        max_flux_label=\"max energy flux = \"+str('{0:.4f}'.format(max_flux))\n    elif which_flux == 2:\n        min_flux_label=\"min timescale [s] = \"+str('{0:.4f}'.format(min_flux))\n    if print_max_flux_in_plot:\n        if which_flux == None or which_flux < 2:\n            ax.text(plotaxis[1]-1.8,plotaxis[2]+0.1,max_flux_label,fontsize=10.)\n        elif which_flux == 2:\n            ax.text(plotaxis[1]-1.8,plotaxis[2]+0.1,min_flux_label,fontsize=10.)\n\n\n\n    fig.savefig(graphname)\n    print(graphname,'is done')\n    if which_flux == None or which_flux < 2:\n        print(max_flux_label,'for reaction =',ind_max_flux+1)\n    elif which_flux == 2:\n        print(min_flux_label,'for reaction =',ind_min_flux+1)\n\n    plt.show()"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _sparse(self, x, y, sparse):\n        tmpX=[]\n        tmpY=[]\n\n        for i in range(len(x)):\n            if sparse == 1:\n                return x,y\n            if (i%sparse)==0:\n                tmpX.append(x[i])\n                tmpY.append(y[i])\n        return tmpX, tmpY", "response": "Method that removes every non - sparse th element from the list x and y."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef plotMulti(self, atrix, atriy, cyclist, title, path='/',\n                  legend=None, labelx=None, labely=None, logx=False,\n                  logy=False, base=10, sparse=1, pdf=False,\n                  limits=None):\n        '''\n        Method for plotting multiple plots and saving it to multiple\n        pngs or PDFs.\n\n        Parameters\n        ----------\n        atrix : string\n            The name of the attribute you want on the x axis.\n        atriy : string\n            The name of the attribute you want on the Y axis.\n        cyclist : list\n            List of cycles that you would like plotted.\n        title : string\n            The title of the graph and the name of the file.\n        path : string, optional\n            The file path. The default is '/'\n        Legend : list or intager, optional\n            A list of legends for each of your cycles, or one legend for\n            all of the cycles. The default is None.\n        labelx : string, optional\n            The label on the X axis. The default is None.\n        labely : string, optional\n            The label on the Y axis. The default is None.\n        logx : boolean, optional\n            A boolean of whether the user wants the x axis\n            logarithmically. The default is False.\n        logy : boolean, optional\n            A boolean of whether the user wants the Y axis\n            logarithmically. The default is False.\n        base : integer, optional\n            The base of the logarithm. The default is 10.\n        sparse : integer, optional\n            Argument that skips every so many data points.  For example\n            if this argument was 5, This method would plot the 0th,\n            5th, 10th ... elements. The default is 1.\n        pdf : boolean, optional\n            A boolean of if the image should be saved to a pdf file.\n            xMin, xMax, yMin, YMax:  plot coordinates.  The default is\n            False.\n        limits : list, optional\n            The length four list of the x and y limits.  The order of\n            the list is xmin, xmax, ymin, ymax. The default is None.\n\n        '''\n        if str(legend.__class__)!=\"<type 'list'>\":# Determines the legend is a list\n            legendList=False\n        else:\n            legendList=True\n\n        if legendList and len(cyclist) !=len(legend): #if it is a list, make sure there is an entry for each cycle\n            print('Please input a proper legend, with correct length, aborting plot')\n            return None\n        for i in range(len(cyclist)):\n            if legendList:\n                self.plot(atrix,atriy,cyclist[i],'ndump',legend[i],labelx,labely,base=base,sparse=sparse, \\\n                                  logx=logx,logy=logy,show=False,limits=limits)\n            else:\n                self.plot(atrix,atriy,cyclist[i],'ndump',legend,labelx,labely,base=base,sparse=sparse, \\\n                                  logx=logx,logy=logy,show=False,limits=limits)\n\n            pl.title(title)\n            if not pdf:\n                currentDir = os.getcwd()\n                os.chdir(path)\n                pl.savefig(title+str(cyclist[i])+'.png', dpi=400)\n                os.chdir(currentDir)\n            else:\n                currentDir = os.getcwd()\n                os.chdir(path)\n                pl.savefig(title+str(cyclist[i])+'.pdf', dpi=400)\n                os.chdir(currentDir)\n            pl.clf()\n        return None", "response": "Method for plotting multiple plots and saving it to multiple PDFs."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef plot_isoratios(self,xiso,yiso,fign=1,spec=None,deltax=True,deltay=True,logx=False,logy=False,\n                        title=None,legend=None,legloc='lower right',errbar=True,dcycle=500,addiso=None,\n                        co_toggle='c',cust_toggle=None,shift=0,weighting=None,zoneselect=None,iniabufile='iniab2.0E-02GN93.ppn',\n                        plt_sparse=1,plt_symb='o',plt_col='k',plt_lt='-',plt_lw=1.,alpha_dum=1.,plt_massrange=False,plt_show=True,\n                        figsave=False):\n        '''\n        This is the new routine to plot isotopic ratios for ALL input. rt, June 2014\n\n        Parameters:\n        -----------\n        xiso : np.array\n            x data to plot. This can be an array or a list of arrays, depending on who calls the routine\n        yiso : np.array\n            y data to plot. This can be an array or a list of arrays, depending on who calls the routine\n        fign : integer, optional\n            Figure number\n        spec : string, optional\n            What specifications do you want to do when coming from nugridse models. Choose 'surf' for\n            surface models or 'exp' for explosions (out files)\n        deltax : boolean, optional\n            X axis in delta values?\n        deltay : boolean, optional\n            Y axis in delta values?\n        logx : boolean, optional\n            Logarithmic x axis?\n        logy : boolean, optional\n            Logarithmic y axis?\n        title : string, optional\n            Title for your plot\n        legend : string, optional\n            Legend for your model / grains. For grains the legend is automatically taken from the\n            grain class\n        legloc : string / integer, optional\n            Location of the legend, use matplotlib standard. Use None to not plot legend if plotted\n            by default, e.g., from grain class routine.\n        errbar : boolean, optional\n            Error bars on grain data?\n        dcycle : integer, optional\n            Difference between cycles to take for thermal pulse searching, if searching is\n            deactivated, dcycle describes how often cycles are sampled.  The default is 500.\n        addiso : list, optional\n            For explosive models. Add an isotope.  Format ['C-12', 0.5 ,'N-12'] to add N12\n            to C12 and multiply it with a factor of 0.5.  Multiple isotopes can be added, the\n            factor is optional and does not have to be given.  Isotopes can be added to other\n            isotopes as well, i.e., [['C-12', 'N-12'], ['C-13', 'N-13']].  The default None.\n            Notice that while addiso = [['N-14','O-14'],['N-14',fractionation,'C-14']]\n            works, other options like addiso = [['N-14','O-14',fractionation,'C-14']] or\n            addiso = [['N-14',1,'O-14',fractionation,'C-14']] are not working and give Typerror.\n            CAREFUL, that for the option addiso = [['N-14',fractionation,'C-14','O-14']] there is\n            no error message, but the fractionation is applied to both O14 and C14!\n        co_toggle : string, optional\n            For explosive models, choose what shells you want to look for! Select 'c' for\n            selecting zones with C/O >= 1.  Select 'o' for C/O <= 1.  If 'a' takes the\n            whole star.  The defalut is 'c'. See cust_toggle (below) for an alternative!\n        cust_toggle : list, optional\n            This option is like co_toggle (and overwrites it when chosen) but lets you choose\n            your own comparison. For example you want to find zones that have a 10 fold\n            overabundance of Ti-46 and Ti-47 over O-16 and Zr-96, you can choose here\n            [['Ti-46','Ti-47'],['O-16','Zr-96'],100.] Assuming the first list is is x, the\n            second list y, and the comparator number is f, the statement only plots shells\n            in which the condition x/y>f is fulfilled. x and y are number sums of the chosen\n            isotopes, f has to be given as a float. This is only for explosive shells. Please\n            note, if this toggle is NOT None, then co_toggle is overwritten!\n        shift : integer, optional\n            For explosive models, how much do you want to shift the models back from the\n            last cycle? By default (0) the last cycle is taken.\n        weighting : string, optional\n            For explosive models. If None then, plot every profile separately.  If 'zone'\n            then, average each zone.  If 'all' then average all selected zones.  The\n            default is None.\n        zoneselect: string, optional\n            For explosive models. Select if you want to plot 'all' zones or outer most zone.\n            Arguments are 'all' and 'top', respectively. Default is None, then the user is\n            asked to provide this information during the routine as input.\n        iniabufile : string, optional\n            Initial abundance file. Use absolute path for your file or filename to choose a\n            given file in USEEPP. Attention: You need a standard tree checked out from SVN\n        plt_sparse : integer, optional\n            Every how many datapoints is the plot done? Not used for some routines!\n        plt_symb : string, optional\n            Symbol for the plot. In case of grains, this is handled automatically.\n        plt_col : string / float, optional\n            Color for plotted curve. In case of grains, this is handled automatically.\n        plt_lt : string, optional\n            line type for plot.\n        plt_lw : float, optional\n            Line width for plot.\n        alpha_dum : trasparency to apply to grains data, in case of many data are plotted.\n            This may be allpied also for theoretical curves.\n        plt_massrange : boolean, optional\n            For explosive models. Plot mass of shell with first and last datapoint of\n            each zone.  If list given, label those zones.  The default is False.\n        plt_show : boolean, optional\n            Do you want to show the plot or not?\n        figsave : string, optional\n            Give path and filename here, if you want to save the figure.\n        '''\n\n        from . import utils as u\n\n        ### WORK ON PATH ###\n        # define svn path form path where script runs, depending on standard input or not\n        if len(iniabufile.split('/')) == 1 :   # means not an absolute path!\n            scriptpathtmp = __file__\n            if len(scriptpathtmp.split('/')) == 1:   # in folder where nugridse is\n                scriptpathtmp = os.path.abspath('.') + '/nugridse.py'   # to get the current dir\n            svnpathtmp = '/'\n            for i in range(len(scriptpathtmp.split('/'))-3):   # -3 to go to folders up!\n                if scriptpathtmp.split('/')[i] != '':\n                    svnpathtmp += scriptpathtmp.split('/')[i] + '/'\n            iniabufile = svnpathtmp + 'frames/mppnp/USEEPP/' + iniabufile   # make absolute path for iniabufile\n\n\n        ### get solar system ratios for the isotopes that are specified in the input file ###\n        inut = u.iniabu(iniabufile)\n        try:\n            xrat_solsys = inut.isoratio_init(xiso)\n        except KeyError:   # if isotope not available, e.g., if plotting Ti-44 / Ti-48 ratio\n            xrat_solsys = 0.\n        try:\n            yrat_solsys = inut.isoratio_init(yiso)\n        except KeyError:\n            yrat_solsys = 0.\n\n        # number ratio for solar system ratio\n        xrat_solsys *= (old_div(float(xiso[1].split('-')[1]), float(xiso[0].split('-')[1])))\n        yrat_solsys *= (old_div(float(yiso[1].split('-')[1]), float(yiso[0].split('-')[1])))\n\n\n        # initialize xdataerr and ydataerr as None\n        xdataerr = None\n        ydataerr = None\n\n\n\n        ### DO PLOTS FROM NUGRIDSE CLASS ###\n        if self._classTest() == 'se':\n            if spec==None:\n                spec = str(eval(input('Please specify \\'surf\\' for surface models (AGB stars) or \\'exp\\' for explosive'\n                             'models and zone finding, etc., and press enter: ')))\n\n            ### SURFACE MODELS - PLOT AGB STAR STUFF ###\n            if spec == 'surf':\n                print('Plotting AGB star stuff')\n\n                # read in thermal pulse position and co ratio\n                tp_pos, co_return = self._tp_finder(dcycle)\n                tp_pos_tmp = []\n                co_return_tmp  = []\n                tp_pos_tmp.append(1)\n                co_return_tmp.append(co_return[0])\n                for i in range(len(tp_pos)):\n                    tp_pos_tmp.append(tp_pos[i])\n                    co_return_tmp.append(co_return[i])\n                tp_pos = tp_pos_tmp\n                co_return = co_return_tmp\n\n                # read in data\n                iso_alldata = self.get(tp_pos,[xiso[0],xiso[1],yiso[0],yiso[1]])\n                xrat = np.zeros(len(iso_alldata))\n                yrat = np.zeros(len(iso_alldata))\n                for i in range(len(iso_alldata)):\n                    xrat[i] = old_div(iso_alldata[i][0], iso_alldata[i][1])\n                    yrat[i] = old_div(iso_alldata[i][2], iso_alldata[i][3])\n\n                # make number ratios\n                for i in range(len(xrat)):\n                    xrat[i] *= old_div(float(xiso[1].split('-')[1]), float(xiso[0].split('-')[1]))\n                    yrat[i] *= old_div(float(yiso[1].split('-')[1]), float(yiso[0].split('-')[1]))\n\n                # if delta values are requested, need to calculate those now\n                if deltax:\n                    xrat = (old_div(xrat,xrat_solsys) -1.) * 1000.\n                if deltay:\n                    yrat = (old_div(yrat,yrat_solsys) -1.) * 1000.\n\n                # now we might have o and c rich zones. prepare stuff for plotting\n                xdata_o = []\n                ydata_o = []\n                xdata_c = []\n                ydata_c = []\n                for i in range(len(co_return)):\n                    if co_return[i] <= 1.:\n                        xdata_o.append(xrat[i])\n                        ydata_o.append(yrat[i])\n                    else:\n                        xdata_c.append(xrat[i])\n                        ydata_c.append(yrat[i])\n                if xdata_o != [] and xdata_c != []:\n                    xdata_o.append(xdata_c[0])\n                    ydata_o.append(ydata_c[0])\n                # now make the styles\n                style_o = [plt_symb + '--', plt_col, '1.', '4', '2',None]\n                style_c = [plt_symb + plt_lt,  plt_col, plt_col, '7.', '1', legend]\n\n                # now make data for plotting\n                xdata = []\n                ydata = []\n                style = []\n                if xdata_o != []:\n                    xdata.append(xdata_o)\n                    ydata.append(ydata_o)\n                    style.append(style_o)\n                if xdata_c != []:\n                    xdata.append(xdata_c)\n                    ydata.append(ydata_c)\n                    style.append(style_c)\n\n\n\n\n            ### EXPLOSIVE MODELS ###\n            elif spec == 'exp':\n                print('explosive models')\n                # compatibility\n                co_toggle = co_toggle.lower()\n                isotope_list = [xiso[0],xiso[1],yiso[0],yiso[1]]\n\n                # cycle\n                cyc_no = self.se.cycles[len(self.se.cycles)-1-shift]\n                mco_data = self.get(cyc_no,['mass','C-12','C-13','O-16','O-17','O-18',xiso[0],xiso[1],yiso[0],yiso[1]])\n                mass = mco_data[0]\n                # if no custom toggle for enrichment\n                if cust_toggle == None:\n                    c_elem = mco_data[1]+mco_data[2]\n                    o_elem = mco_data[3]+mco_data[4]+mco_data[5]\n                    co_ratio = c_elem / o_elem * (old_div(16., 12.))\n                    co_comp_val = 1.\n                else:\n                    co_data1 = self.get(cyc_no,cust_toggle[0])\n                    co_data2 = self.get(cyc_no,cust_toggle[1])\n                    for i in range(len(co_data1)):\n                        if i == 0:\n                            c_elem = co_data1[i]\n                        else:\n                            c_elem += co_data1[i]\n                    for i in range(len(co_data2)):\n                        if i == 0:\n                            o_elem = co_data2[i]\n                        else:\n                            o_elem += co_data2[i]\n                    # now we need to make the mass number of everything in here to make number ratios\n                    massn1 = 0.\n                    for i in range(len(co_data1)):\n                        massn1 += sum(co_data1[i]) * float(cust_toggle[0][i].split('-')[1])\n                    massn1 /= sum(c_elem)\n                    massn2 = 0.\n                    for i in range(len(co_data2)):\n                        massn2 += sum(co_data2[i]) * float(cust_toggle[1][i].split('-')[1])\n                    massn2 /= sum(o_elem)\n                    co_ratio = c_elem / o_elem * (old_div(massn2, massn1))   # this has nothing to do with a C/O ratio anymore! but keep name\n                    # comparator value\n                    co_comp_val = float(cust_toggle[2])\n\n                # get the data now\n                isotope_profile = []\n                for i in range(6,10):   # in mco_data\n                    isotope_profile.append(mco_data[i])\n\n                # add radioactive isotopes (if given)\n                if addiso != None:\n                    if type(addiso[0] == list):   # then list of lists\n                        for i in range(len(addiso)):\n                            for j in range(4):\n                                if isotope_list[j] == addiso[i][0]:\n                                    multiplicator_addiso = 1.\n                                    try:\n                                        multiplicator_addiso = float(addiso[i][1])\n                                        starter = 2\n                                    except ValueError:\n                                        starter = 1\n                                    for k in range(starter,len(addiso[i])):\n                                        isotope_profile[j] += array(self.get(cyc_no,addiso[i][k])) * multiplicator_addiso\n                    else:\n                        for j in range(4):\n                            if isotope_list[j] == addiso[0]:\n                                multiplicator_addiso = 1.\n                                try:\n                                    multiplicator_addiso = float(addiso[1])\n                                    starter = 2\n                                except ValueError:\n                                    starter = 1\n                                for k in range(starter,len(addiso)):\n                                    isotope_profile[j] += array(self.get(cyc_no,addiso[k])) * multiplicator_addiso\n\n                # search for carbon / oxygen rich layers\n                crich = []   # alternating start stop values. if odd number, then surface is c-rich, but add stop number\n                dumb = True\n                if cust_toggle != None:\n                    for i in range(len(co_ratio)):\n                        if dumb:\n                            if co_ratio[i] >= co_comp_val:\n                                crich.append(i)\n                                dumb = False\n                                continue\n                        else:\n                            if co_ratio[i] < co_comp_val:\n                                crich.append(i)\n                                dumb = True\n                elif co_toggle != 'a':\n                    for i in range(len(co_ratio)):\n                        if co_toggle == 'c':   # carbon rich\n                            if dumb:\n                                if co_ratio[i] >= 1:\n                                    crich.append(i)\n                                    dumb = False\n                                    continue\n                            else:\n                                if co_ratio[i] < 1:\n                                    crich.append(i)\n                                    dumb = True\n                        elif co_toggle == 'o':   # oxygen rich\n                            if dumb:\n                                if co_ratio[i] <= 1:\n                                    crich.append(i)\n                                    dumb = False\n                                    continue\n                            else:\n                                if co_ratio[i] > 1:\n                                    crich.append(i)\n                                    dumb = True\n                        else:\n                            print('Select your enrichment!')\n                            return None\n                else:   # take whole star\n                    print('Using all profiles to mix')\n                    crich.append(0)\n                    crich.append(len(co_toggle))\n\n                if len(crich)%2 == 1:\n                    crich.append(len(co_ratio)-1)\n\n                if len(crich) == 0:\n                    print('Star did not get rich in C or O, depending on what you specified')\n                    return None\n\n                # make isotope_profile into array and transpose\n                isotope_profile = array(isotope_profile).transpose()\n\n\n                # Ask user which zones to use\n                if co_toggle != 'a':\n                    if cust_toggle != None:\n                        print('\\n\\nI have found the following zones:\\n')\n                    elif co_toggle == 'c':\n                        print('\\n\\nI have found the following carbon rich zones:\\n')\n                    elif co_toggle == 'o':\n                        print('\\n\\nI have found the following oxygen rich zones:\\n')\n\n                    mass_tmp = zeros((len(crich)))\n                    for i in range(len(crich)):\n                        mass_tmp[i] = mass[crich[i]]\n\n                    j = 1\n                    for i in range(old_div(len(crich),2)):\n                        print('Mass range (' + str(j) + '):\\t' + str(mass_tmp[2*i]) + ' - ' + str(mass_tmp[2*i+1]))\n                        j += 1\n                    print('\\n')\n                    if zoneselect == 'all':\n                        usr_zones = 0\n                    elif zoneselect == 'top':\n                        usr_zones = [j-1]\n                    else:\n                        usr_zones = eval(input('Please select which mass range you want to use. Select 0 for all zones. Otherwise give one zone or a list of zones separated by comma (e.g.: 1, 2, 4): '))\n\n                    crich_dumb = crich\n                    if usr_zones == 0:\n                        print('I continue w/ all zones then')\n                    elif type(usr_zones) == int:   # only one zone selected\n                        tmp = int(usr_zones)-1\n                        crich = crich_dumb[2*tmp:2*tmp+2]\n                    else:\n                        crich = []\n                        for i in range(len(usr_zones)):\n                            tmp = int(usr_zones[i])-1\n                            crich.append(crich_dumb[2*tmp])\n                            crich.append(crich_dumb[2*tmp + 1])\n\n                # weight profiles according to weighting factor using the selected crich\n                # define isos_to_use variable for later\n                if weighting == None:\n                    isos_to_use = []\n                    for i in range(old_div(len(crich),2)):\n                        isos_dumb = []\n                        n = crich[2*i]\n                        while n <= crich[2*i+1]:\n                            isos_dumb.append(isotope_profile[n])\n                            n += 1\n                        isos_to_use.append(array(isos_dumb))\n\n\n                elif weighting.lower() == 'zone' or weighting.lower() == 'zones':\n                    # make array w/ mass weigted isotope ratio (4) for all mass zones\n                    isotope_profile_cweight = zeros((old_div(len(crich),2),4))\n                    mass_tot = []\n                    for i in range(len(isotope_profile_cweight)):   # 2*i is start, 2*i+1 is stop value\n                        if crich[2*i] == 0:\n                            print('C- / O-rich in first shell (core).')\n                        else:\n                            dumb = crich[2*i + 1]\n                            j = crich[2*i]\n                            mass_tmp = 0\n                            while j <= dumb:\n                                mass_shell = mass[j] - mass[j-1]\n                                mass_tmp += mass_shell\n                                for k in range(4):\n                                    isotope_profile_cweight[i][k] += isotope_profile[j][k]*mass_shell\n                                j += 1\n                            mass_tot.append(mass_tmp)\n                    for i in range(len(isotope_profile_cweight)):\n                        for j in range(4):\n                            isotope_profile_cweight[i][j] /= mass_tot[i]\n                    isos_to_use = [array(isotope_profile_cweight)]\n\n                elif weighting.lower() == 'all':   # average all zones by mass\n                    isos_tmp = zeros((1, len(isotope_profile[0])))\n                    for i in range(len(isotope_profile)-1):   # neglect surface effects\n                        for j in range(len(isos_tmp[0])):\n                            mass_shell = mass[i+1] - mass[i]\n                            isos_tmp[0][j] += isotope_profile[i][j]*mass_shell\n                    # weight all\n                    isos_tmp /= sum(mass)\n                    isos_to_use = [isos_tmp]\n\n\n                # change to isotope numbers from mass!\n                for i in range(len(isos_to_use)):\n                    for j in range(len(isos_to_use[i])):\n                        for k in range(len(isos_to_use[i][j])):\n                            # here we just divide 'iso_massf' output with the mass number\n                            # this means that in the end, the isotope ratios in number space are correc\n                            # but have to use ratios from here on for meaningful stuff\n                            isos_to_use[i][j][k] /= float(isotope_list[k].split('-')[1])\n\n                # do the ratios and stuff\n                ratiox = []\n                ratioy = []\n                for i in range(len(isos_to_use)):\n                    ratiox_dumb = []\n                    ratioy_dumb = []\n                    for j in range(len(isos_to_use[i])):\n                        ratiox_dumb.append(old_div(isos_to_use[i][j][0], isos_to_use[i][j][1]))\n                        ratioy_dumb.append(old_div(isos_to_use[i][j][2], isos_to_use[i][j][3]))\n                    ratiox.append(array(ratiox_dumb))\n                    ratioy.append(array(ratioy_dumb))\n\n                # make arrays for ratiox and ratioy\n                ratiox = array(ratiox)\n                ratioy = array(ratioy)\n\n                # make number ratio out of everything\n                for i in range(len(ratiox)):\n                    for j in range(len(ratiox[i])):\n                        ratiox[i][j] *= (old_div(float(xiso[1].split('-')[1]), float(xiso[0].split('-')[1])))\n                        ratioy[i][j] *= (old_div(float(yiso[1].split('-')[1]), float(yiso[0].split('-')[1])))\n\n                if deltax:\n                    ratiox_tmp = []\n                    for i in range(len(ratiox)):\n                        ratiox_tmp_tmp = []\n                        for j in range(len(ratiox[i])):\n                            ratiox_tmp_tmp.append((old_div(ratiox[i][j], xrat_solsys) - 1.) * 1000.)\n                        ratiox_tmp.append(ratiox_tmp_tmp)\n                    ratiox = array(ratiox_tmp)\n                if deltay:\n                    ratioy_tmp = []\n                    for i in range(len(ratioy)):\n                        ratioy_tmp_tmp = []\n                        for j in range(len(ratioy[i])):\n                            ratioy_tmp_tmp.append((old_div(ratioy[i][j], yrat_solsys) - 1.) * 1000.)\n                        ratioy_tmp.append(ratioy_tmp_tmp)\n                    ratioy = array(ratioy_tmp)\n\n                # create massrange array if necessary\n                plt_massrange_lst = []\n                if plt_massrange==True:   # use == True because otherwise the list enters here too... why?\n                    for i in range(len(ratiox)):\n                        plt_massrange_lst.append([ratiox[i][0], ratioy[i][0], mass[crich[2*i]]])\n                        plt_massrange_lst.append([ratiox[i][len(ratiox[i])-1], ratioy[i][len(ratioy[i])-1], mass[crich[2*i+1]]])   # start: x-ratio, y-ratio, mass label\n\n                elif plt_massrange != False:\n                    for plt_mr_val in plt_massrange:\n                        mrng_i = 0\n                        while plt_mr_val > mass[mrng_i] and mrng_i < len(mass):\n                            mrng_i += 1\n                        if mrng_i > 0:\n                            mrng_i -= 1\n                        mratx = old_div(isotope_profile[mrng_i][0],isotope_profile[mrng_i][1])\n                        mraty = old_div(isotope_profile[mrng_i][2],isotope_profile[mrng_i][3])\n                        if deltax:\n                            mratx = (old_div(mratx, ratiox_solsys) - 1.) * 1000.\n                        if deltay:\n                            mraty = (old_div(mraty, ratioy_solsys) - 1.) * 1000.\n                        plt_massrange_lst.append([mratx,mraty,mass[mrng_i]])\n\n                # make style and prepare for plotting here\n                xdata = ratiox\n                ydata = ratioy\n                style_tmp0= [plt_symb + plt_lt,  plt_col, plt_col, '13.', '1', legend]\n                style_tmp = [plt_symb + plt_lt,  plt_col, plt_col, '13.', '1', None]\n                style = []\n                for i in range(len(xdata)):\n                    if i == 0:\n                        style.append(style_tmp0)\n                    else:\n                        style.append(style_tmp)\n\n            else:\n                print('You did not specify a useful spec argument -> abort.')\n                return None\n\n        ### PLOTS FROM GRAIN CLASS ###\n        if self._classTest() == 'grain':\n            print('Presolar grains are cool!')\n            xdata,xdataerr,ydata,ydataerr,style = self.plot_ratio_return(xiso,yiso,deltax,deltay)\n            legend=True\n            plt_sparse=1   # to avoid monkey input\n            plt_lw = 0.\n\n        ### PLOT ###\n        # data is prepared now, make the plots. data must be in format\n        # [[data1],[data2],[data3],...]\n        # three arrays like this, for xdata, ydata, and style.\n        # style format: symbol, edge color, face color, symbol size, edge width, label\n        # this is then compatible with grain.py style definitions\n\n        # Size of font etc.\n        params = {'axes.labelsize':  20,\n                  'text.fontsize':   14,\n                  'legend.fontsize': 14,\n                  'xtick.labelsize': 14,\n                  'ytick.labelsize': 14}\n        pl.rcParams.update(params)\n\n        pl.figure(fign)\n        for i in range(len(xdata)):\n            if errbar:\n                if xdataerr != None or ydataerr != None:\n                    pl.errorbar(xdata[i],ydata[i],xerr=xdataerr[i],yerr=ydataerr[i],marker=style[i][0],\n                                color=style[i][1],linestyle='',lw=2,markevery=plt_sparse,alpha=alpha_dum)\n            pl.plot(xdata[i],ydata[i],style[i][0],c=style[i][1],mfc=style[i][2],ms=float(style[i][3]),\n                    mew=float(style[i][4]),label=style[i][5],markevery=plt_sparse,linewidth=plt_lw,alpha=alpha_dum)\n\n        # plot text labels if necessary\n        if plt_massrange != False:\n            for mrng_ind in range(len(plt_massrange_lst)):\n                pl.text(plt_massrange_lst[mrng_ind][0], plt_massrange_lst[mrng_ind][1],\n                        str(round(plt_massrange_lst[mrng_ind][2], 2)), ha='right', va='bottom', color=plt_col,fontsize=15.)\n\n\n        # log?\n        if logx and logy == False:\n            pl.semilogx()\n        elif logx == False and logy:\n            pl.semilogy()\n        elif logx and logy:\n            pl.loglog()\n\n        # legend\n        if legend != None and legloc != None:\n            pl.legend(loc=legloc)\n\n        # title and labels\n        if title != None:\n            pl.title(title)\n        if deltax:\n            pl.xlabel('$\\delta$($^{' + xiso[0].split('-')[1] + '}$' +xiso[0].split('-')[0] + '/$^{' + xiso[1].split('-')[1] + '}$' +xiso[1].split('-')[0] + ')' )\n        else:\n            pl.xlabel('$^{' + xiso[0].split('-')[1] + '}$' +xiso[0].split('-')[0] + '/$^{' + xiso[1].split('-')[1] + '}$' +xiso[1].split('-')[0])\n        if deltay:\n            pl.ylabel('$\\delta$($^{' + yiso[0].split('-')[1] + '}$' +yiso[0].split('-')[0] + '/$^{' + yiso[1].split('-')[1] + '}$' +yiso[1].split('-')[0] + ')' )\n        else:\n            pl.ylabel('$^{' + yiso[0].split('-')[1] + '}$' +yiso[0].split('-')[0] + '/$^{' + yiso[1].split('-')[1] + '}$' +yiso[1].split('-')[0])\n\n        # plot horizontal and vertical lines\n        print(xrat_solsys, yrat_solsys)\n        if deltay:\n            pl.axhline(0,color='k')\n        else:\n            pl.axhline(yrat_solsys,color='k')\n        if deltax:\n            pl.axvline(0,color='k')\n        else:\n            pl.axvline(xrat_solsys,color='k')\n\n        # borders of plot\n        pl.gcf().subplots_adjust(bottom=0.15)\n        pl.gcf().subplots_adjust(left=0.15)\n\n        # save and show\n        if figsave != False:\n            pl.savefig(figsave)\n\n        if plt_show:\n            pl.show()", "response": "This function is called by the plot_isoratios function of the nugridse class routine to plot isotopic ratios for all input data."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nplots an abundance chart Parameters ---------- cycle : string, integer or list The cycle we are looking in. If it is a list of cycles, this method will then do a plot for each of these cycles and save them all to a file. mass_range : list, optional A 1x2 array containing the lower and upper mass range. If this is an instance of abu_vector this will only plot isotopes that have an atomic mass within this range. This will throw an error if this range does not make sence ie [45,2] if None, it will plot over the entire range. The default is None. ilabel : boolean, optional Elemental labels off/on. The default is True. imlabel : boolean, optional Label for isotopic masses off/on. The default is True. imlabel_fontsize : integer, optional Fontsize for isotopic mass labels. The default is 8. imagic : boolean, optional Turn lines for magic numbers off/on. The default is False. boxstable : boolean, optional Plot the black boxes around the stable elements. The defaults is True. lbound : tuple, optional Boundaries for colour spectrum ploted. The default is (-12,0). plotaxis : list, optional Set axis limit. If [0, 0, 0, 0] the complete range in (N,Z) will be plotted. It equates to [xMin, xMax, Ymin, Ymax]. The default is [0, 0, 0, 0]. show : boolean, optional Boolean of if the plot should be displayed. Useful with saving multiple plots using abu_chartMulti. The default is True. color_map : string, optional Color map according to choices in matplotlib (e.g. www.scipy.org/Cookbook/Matplotlib/Show_colormaps). The default is 'jet'. ifig : integer, optional Figure number, if ifig is None it wiil be set to the cycle number. The defaults is None. savefig : boolean, optional Whether or not to save the figure. The default is False drawfig, drawax, mov : optional, not necessary for user to set these variables The figure and axes containers to be drawn on, and whether or not a movie is being made (only True when se.movie is called, which sets mov to True automatically path: path where to save figure", "response": "def abu_chart(self, cycle, mass_range=None ,ilabel=True,\n                  imlabel=True, imlabel_fontsize=8, imagic=False,\n                  boxstable=True, lbound=(-12, 0),\n                  plotaxis=[0, 0, 0, 0], show=True, color_map='jet',\n                  ifig=None,data_provided=False,thedata=None,\n                  savefig=False,drawfig=None,drawax=None,mov=False,\n                  path=None):\n        '''\n        Plots an abundance chart\n\n        Parameters\n        ----------\n        cycle : string, integer or list\n            The cycle we are looking in. If it is a list of cycles,\n            this method will then do a plot for each of these cycles\n            and save them all to a file.\n        mass_range : list, optional\n            A 1x2 array containing the lower and upper mass range.  If\n            this is an instance of abu_vector this will only plot\n            isotopes that have an atomic mass within this range.  This\n            will throw an error if this range does not make sence ie\n            [45,2] if None, it will plot over the entire range.  The\n            default is None.\n        ilabel : boolean, optional\n            Elemental labels off/on.  The default is True.\n        imlabel : boolean, optional\n            Label for isotopic masses off/on.  The default is True.\n        imlabel_fontsize : integer, optional\n            Fontsize for isotopic mass labels.  The default is 8.\n        imagic : boolean, optional\n            Turn lines for magic numbers off/on.  The default is False.\n        boxstable : boolean, optional\n            Plot the black boxes around the stable elements.  The\n            defaults is True.\n        lbound : tuple, optional\n            Boundaries for colour spectrum ploted.  The default is\n            (-12,0).\n        plotaxis : list, optional\n            Set axis limit.  If [0, 0, 0, 0] the complete range in (N,Z)\n            will be plotted.  It equates to [xMin, xMax, Ymin, Ymax].\n            The default is [0, 0, 0, 0].\n        show : boolean, optional\n            Boolean of if the plot should be displayed.  Useful with\n            saving multiple plots using abu_chartMulti.  The default is\n            True.\n        color_map : string, optional\n            Color map according to choices in matplotlib\n            (e.g. www.scipy.org/Cookbook/Matplotlib/Show_colormaps).\n            The default is 'jet'.\n        ifig : integer, optional\n            Figure number, if ifig is None it wiil be set to the cycle\n            number.  The defaults is None.\n        savefig : boolean, optional\n            Whether or not to save the figure.\n            The default is False\n        drawfig, drawax, mov : optional, not necessary for user to set these variables\n            The figure and axes containers to be drawn on, and whether or not a movie is\n            being made (only True when se.movie is called, which sets mov to True\n            automatically\n        path: path where to save figure\n\n        '''\n\n        if ifig == None and not mov:\n            ifig=cycle\n\n        if type(cycle)==type([]):\n            self.abu_chartMulti(cycle, mass_range,ilabel,imlabel,imlabel_fontsize,imagic,boxstable,\\\n                                lbound,plotaxis,color_map, path=path)\n            return\n        plotType=self._classTest()\n\n        if mass_range!=None and mass_range[0]>mass_range[1]:\n            raise IOError(\"Please input a proper mass range\")\n\n        if plotType=='se':\n            if not data_provided:\n                cycle=self.se.findCycle(cycle)\n#                nin=zeros(len(self.se.A))\n#                zin=zeros(len(self.se.Z))\n                yin=self.get(cycle, 'iso_massf')\n                isom=self.se.isomeric_states\n                masses = self.se.get(cycle,'mass')\n            else:\n                cycle=cycle # why so serious?\n                yin=thedata[0]\n                isom=self.se.isomeric_states\n                masses = thedata[1]\n\n#            for i in xrange(len(nin)):\n#                zin[i]=self.se.Z[i]\n#                nin[i]=self.se.A[i]-zin[i]\n            # SJONES implicit loop instead:\n            zin=array([el for el in self.se.Z])\n            nin=array([el for el in self.se.A])-zin\n\n            #Test if the mass cell order is inverted\n            #and hence mass[-1] the center.\n            if masses[0]>masses[-1]:\n                #invert\n                print('Inverted order of mass cells will be taken into account.')\n                yin=yin[::-1]\n                masses=masses[::-1]\n\n            if mass_range != None:\n                # trim out only the zones needed:\n                tmpyps=[]\n                masses.sort() # SJ: not sure why this sort if necessary\n#                for i in xrange(len(masses)):\n#                    if (masses[i] >mass_range[0] and masses[i]<mass_range[1]) or\\\n#                            (masses[i]==mass_range[0] or masses[i]==mass_range[1]):\n#                        tmpyps.append(yin[i])\n#                yin=tmpyps\n                # find lower and upper indices and slice instead:\n                idxl=np.abs(masses-mass_range[0]).argmin()\n                if masses[idxl] < mass_range[0]: idxl+=1\n                idxu=np.abs(masses-mass_range[1]).argmin()\n                if masses[idxu] > mass_range[1]: idxu-=1\n                yin=yin[idxl:idxu+1]\n\n\n\n\n            #tmp=zeros(len(yin[0]))\n            #for i in xrange(len(yin)):\n            #    for j in xrange(len(yin[i])):\n            #        tmp[j]+=yin[i][j]\n\n            tmp2=sum(yin,axis=0) # SJONES sum along axis instead of nested loop\n            tmp=old_div(tmp2,len(yin))\n\n            yin=tmp\n\n        elif plotType=='PPN':\n\n            ain=self.get('A',cycle)\n            zin=self.get('Z',cycle)\n            nin=ain-zin\n            yin=self.get('ABUNDANCE_MF',cycle)\n            isom=self.get('ISOM',cycle)\n\n            if mass_range != None:\n                tmpA=[]\n                tmpZ=[]\n                tmpIsom=[]\n                tmpyps=[]\n                for i in range(len(nin)):\n                    if (ain[i] >mass_range[0] and ain[i]<mass_range[1])\\\n                    or (ain[i]==mass_range[0] or ain[i]==mass_range[1]):\n                        tmpA.append(nin[i])\n                        tmpZ.append(zin[i])\n                        tmpIsom.append(isom[i])\n                        tmpyps.append(yin[i])\n                zin=tmpZ\n                nin=tmpA\n                yin=tmpyps\n                isom=tmpIsom\n\n        else:\n            raise IOError(\"This method, abu_chart, is not supported by this class\")\n\n        # in case we call from ipython -pylab, turn interactive on at end again\n        turnoff=False\n        if not show:\n            try:\n                ioff()\n                turnoff=True\n            except NameError:\n                turnoff=False\n\n        nnmax = int(max(nin))+1\n        nzmax = int(max(zin))+1\n        nzycheck = zeros([nnmax,nzmax,3])\n\n        for i in range(len(nin)):\n            if isom[i]==1:\n                ni = int(nin[i])\n                zi = int(zin[i])\n\n                nzycheck[ni,zi,0] = 1\n                nzycheck[ni,zi,1] = yin[i]\n\n        #######################################################################\n        # elemental names: elname(i) is the name of element with Z=i\n\n        elname=self.elements_names\n\n        #### create plot\n        ## define axis and plot style (colormap, size, fontsize etc.)\n        if plotaxis==[0,0,0,0]:\n            xdim=10\n            ydim=6\n        else:\n            dx = plotaxis[1]-plotaxis[0]\n            dy = plotaxis[3]-plotaxis[2]\n            ydim = 6\n            xdim = ydim*dx/dy\n\n\n        params = {'axes.labelsize':  12,\n                  'text.fontsize':   12,\n                  'legend.fontsize': 12,\n                  'xtick.labelsize': 12,\n                  'ytick.labelsize': 12,\n                  'text.usetex': True}\n        #pl.rcParams.update(params) #May cause Error, someting to do with tex\n        if mov:\n            fig=drawfig\n            fig.set_size_inches(xdim,ydim)\n            artists=[]\n        else:\n            fig=pl.figure(ifig,figsize=(xdim,ydim),dpi=100)\n        axx = 0.10\n        axy = 0.10\n        axw = 0.85\n        axh = 0.8\n        if mov:\n            ax=drawax\n        else:\n            ax=pl.axes([axx,axy,axw,axh])\n        # Tick marks\n        xminorlocator = MultipleLocator(1)\n        xmajorlocator = MultipleLocator(5)\n        ax.xaxis.set_major_locator(xmajorlocator)\n        ax.xaxis.set_minor_locator(xminorlocator)\n        yminorlocator = MultipleLocator(1)\n        ymajorlocator = MultipleLocator(5)\n        ax.yaxis.set_major_locator(ymajorlocator)\n        ax.yaxis.set_minor_locator(yminorlocator)\n\n        # color map choice for abundances\n\n        cmapa = cm.get_cmap(name=color_map)\n        # color map choice for arrows\n        cmapr = cm.autumn\n        # if a value is below the lower limit its set to white\n        cmapa.set_under(color='w')\n        cmapr.set_under(color='w')\n        # set value range for abundance colors (log10(Y))\n        norma = colors.Normalize(vmin=lbound[0],vmax=lbound[1])\n        # set x- and y-axis scale aspect ratio to 1\n        ax.set_aspect('equal')\n        #print time,temp and density on top\n        temp = ' '#'%8.3e' %ff['temp']\n        time = ' '#'%8.3e' %ff['time']\n        dens = ' '#'%8.3e' %ff['dens']\n\n        #May cause Error, someting to do with tex\n        '''\n        #box1 = TextArea(\"t : \" + time + \" s~~/~~T$_{9}$ : \" + temp + \"~~/~~$\\\\rho_{b}$ : \" \\\n        #             + dens + ' g/cm$^{3}$', textprops=dict(color=\"k\"))\n        anchored_box = AnchoredOffsetbox(loc=3,\n                        child=box1, pad=0.,\n                        frameon=False,\n                        bbox_to_anchor=(0., 1.02),\n                        bbox_transform=ax.transAxes,\n                        borderpad=0.,\n                        )\n        ax.add_artist(anchored_box)\n        '''\n        ## Colour bar plotted\n\n        patches = []\n        color = []\n        for i in range(nzmax):\n            for j in range(nnmax):\n                if nzycheck[j,i,0]==1:\n                    xy = j-0.5,i-0.5\n\n                    rect = Rectangle(xy,1,1,)\n\n                    # abundance\n                    yab = nzycheck[j,i,1]\n                    if yab == 0:\n\n                        yab=1e-99\n\n\n                    col =log10(yab)\n\n                    patches.append(rect)\n                    color.append(col)\n\n        p = PatchCollection(patches, cmap=cmapa, norm=norma)\n        p.set_array(array(color))\n        p.set_zorder(1)\n        if mov:\n            artist1=ax.add_collection(p)\n            artists.append(artist1)\n        else:\n            ax.add_collection(p)\n        if not mov:\n            cb = pl.colorbar(p)\n\n            # colorbar label\n            cb.set_label('log$_{10}$(X)')\n\n        # plot file name\n        graphname = 'abundance-chart'+str(cycle)\n\n        # Add black frames for stable isotopes\n        if boxstable:\n            for i in range(len(self.stable_el)):\n                if i == 0:\n                    continue\n\n\n                tmp = self.stable_el[i]\n                try:\n                    zz= self.elements_names.index(tmp[0]) #charge\n                except:\n                    continue\n\n                for j in range(len(tmp)):\n                    if j == 0:\n                        continue\n\n                    nn = int(tmp[j]) #atomic mass\n                    nn=nn-zz\n\n                    xy = nn-0.5,zz-0.5\n                    rect = Rectangle(xy,1,1,ec='k',fc='None',fill='False',lw=3.)\n                    rect.set_zorder(2)\n                    ax.add_patch(rect)\n\n\n        # decide which array to take for label positions\n        iarr = 0\n\n        # plot element labels\n        if ilabel:\n            for z in range(nzmax):\n                try:\n                    nmin = min(argwhere(nzycheck[:,z,iarr]))[0]-1\n                    ax.text(nmin,z,elname[z],horizontalalignment='center',verticalalignment='center',\\\n                            fontsize='x-small',clip_on=True)\n                except ValueError:\n                    continue\n\n        # plot mass numbers\n        if imlabel:\n            for z in range(nzmax):\n                for n in range(nnmax):\n                    a = z+n\n                    if nzycheck[n,z,iarr]==1:\n                        ax.text(n,z,a,horizontalalignment='center',verticalalignment='center',\\\n                                fontsize=imlabel_fontsize,clip_on=True)\n\n        # plot lines at magic numbers\n        if imagic:\n            ixymagic=[2, 8, 20, 28, 50, 82, 126]\n            nmagic = len(ixymagic)\n            for magic in ixymagic:\n                if magic<=nzmax:\n                    try:\n                        xnmin = min(argwhere(nzycheck[:,magic,iarr]))[0]\n                        xnmax = max(argwhere(nzycheck[:,magic,iarr]))[0]\n                        line = ax.plot([xnmin,xnmax],[magic,magic],lw=3.,color='r',ls='-')\n                    except ValueError:\n                        dummy=0\n                if magic<=nnmax:\n                    try:\n                        yzmin = min(argwhere(nzycheck[magic,:,iarr]))[0]\n                        yzmax = max(argwhere(nzycheck[magic,:,iarr]))[0]\n                        line = ax.plot([magic,magic],[yzmin,yzmax],lw=3.,color='r',ls='-')\n                    except ValueError:\n                        dummy=0\n\n        # set axis limits\n        if plotaxis==[0,0,0,0]:\n\n            xmax=max(nin)\n            ymax=max(zin)\n            ax.axis([-0.5,xmax+0.5,-0.5,ymax+0.5])\n        else:\n            ax.axis(plotaxis)\n\n        # set x- and y-axis label\n        ax.set_xlabel('neutron number (A-Z)')\n        ax.set_ylabel('proton number Z')\n        if not mov:\n            pl.title('Isotopic Chart for cycle '+str(int(cycle)))\n        if savefig:\n            if path is not None:\n                graphname = os.path.join(path, graphname)\n            fig.savefig(graphname)\n            print(graphname,'is done')\n        if show:\n            pl.show()\n        if turnoff:\n            ion()\n\n        if mov:\n            return p,artists\n        else:\n            return"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nplot an abundance and flux chart Parameters ---------- cycle : string, integer or list The cycle we are looking in. If it is a list of cycles, this method will then do a plot for each of these cycles and save them all to a file. ilabel : boolean, optional Elemental labels off/on. The default is True. imlabel : boolean, optional Label for isotopic masses off/on. The default is True. imagic : boolean, optional Turn lines for magic numbers off/on. The default is False. boxstable : boolean, optional Plot the black boxes around the stable elements. The defaults is True. lbound : tuple, optional Boundaries for colour spectrum ploted. The default is (-12,0). plotaxis : list, optional Set axis limit. If [0, 0, 0, 0] the complete range in (N,Z) will be plotted. It equates to [xMin, xMax, Ymin, Ymax]. The default is [0, 0, 0, 0]. which_flux : integer, optional Set to 0 for nucleosynthesis flux plot. Set to 1 for energy flux plot. Setting wich_flux to 0 is equivelent to setting it to 0. The default is None. prange : integer, optional Range of fluxes to be considered, if prange is None then the plot range is set to 8. The default is None. profile : string, optional 'charged' is ideal setting to show charged particle reactions flow. 'neutron' is ideal setting for neutron captures flows. The default is 'charged'. show : boolean, optional Boolean of if the plot should be displayed. Useful with saving multiple plots using abu_chartMulti. The default is True.", "response": "def abu_flux_chart(self, cycle, ilabel=True, imlabel=True,\n                       imagic=False, boxstable=True, lbound=(-12,0),\n                       plotaxis=[0,0,0,0], which_flux=None, prange=None,\n                       profile='charged', show=True):\n        '''\n        Plots an abundance and flux chart\n\n        Parameters\n        ----------\n        cycle : string, integer or list\n            The cycle we are looking in. If it is a list of cycles,\n            this method will then do a plot for each of these cycles\n            and save them all to a file.\n        ilabel : boolean, optional\n            Elemental labels off/on.  The default is True.\n        imlabel : boolean, optional\n            Label for isotopic masses off/on.  The default is True.\n        imagic : boolean, optional\n            Turn lines for magic numbers off/on.  The default is False.\n        boxstable : boolean, optional\n            Plot the black boxes around the stable elements.  The\n            defaults is True.\n        lbound : tuple, optional\n            Boundaries for colour spectrum ploted.  The default is\n            (-12,0).\n        plotaxis : list, optional\n            Set axis limit.  If [0, 0, 0, 0] the complete range in (N,Z)\n            will be plotted.  It equates to [xMin, xMax, Ymin, Ymax].\n            The default is [0, 0, 0, 0].\n        which_flux : integer, optional\n            Set to 0 for nucleosynthesis flux plot.  Set to 1 for\n            energy flux plot.  Setting wich_flux to 0 is equivelent to\n            setting it to 0.  The default is None.\n        prange : integer, optional\n            Range of fluxes to be considered, if prange is None then\n            the plot range is set to 8.  The default is None.\n        profile : string, optional\n            'charged' is ideal setting to show charged particle\n            reactions flow.  'neutron' is ideal setting for neutron\n            captures flows.  The default is 'charged'.\n        show : boolean, optional\n            Boolean of if the plot should be displayed.  Useful with\n            saving multiple plots using abu_chartMulti.  The default is\n            True.\n\n        '''\n        #######################################################################\n        #### plot options\n        # Set axis limit: If default [0,0,0,0] the complete range in (N,Z) will\n        # be plotted, i.e. all isotopes, else specify the limits in\n        # plotaxis = [xmin,xmax,ymin,ymax]\n\n        #######################################################################\n\n        # read data file\n        #inpfile = cycle\n        #ff = fdic.ff(inpfile)\n        # with the flux implementation I am not using mass range for now.\n        # It may be introduced eventually.\n        mass_range = None\n        if str(cycle.__class__)==\"<type 'list'>\":\n            self.abu_chartMulti(cycle, mass_range,ilabel,imlabel,imlabel_fontsize,imagic,boxstable,\\\n                                lbound,plotaxis)\n            return\n        plotType=self._classTest()\n\n        #if mass_range!=None and mass_range[0]>mass_range[1]:\n            #print 'Please input a proper mass range'\n            #print 'Returning None'\n            #return None\n\n        if plotType=='se':\n            cycle=self.se.findCycle(cycle)\n            nin=zeros(len(self.se.A))\n            zin=zeros(len(self.se.Z))\n            for i in range(len(nin)):\n                nin[i]=self.se.A[i]\n                zin[i]=self.se.Z[i]\n            for i in range(len(nin)):\n                nin[i]=nin[i]-zin[i]\n            yin=self.get(cycle, 'iso_massf')\n            isom=self.se.isomeric_states\n\n            masses = self.se.get(cycle,'mass')\n            if mass_range != None:\n                masses = self.se.get(cycle,'mass')\n                masses.sort()\n\n            if mass_range != None:\n                tmpyps=[]\n                masses = self.se.get(cycle,'mass')\n                masses = self.se.get(cycle,'mass')\n                masses.sort()\n                for i in range(len(masses)):\n                    if (masses[i] >mass_range[0] and masses[i]<mass_range[1]) or\\\n                            (masses[i]==mass_range[0] or masses[i]==mass_range[1]):\n                        tmpyps.append(yin[i])\n                yin=tmpyps\n\n\n            tmp=zeros(len(yin[0]))\n            for i in range(len(yin)):\n                for j in range(len(yin[i])):\n                    tmp[j]+=yin[i][j]\n\n            tmp=old_div(tmp,len(yin))\n\n            yin=tmp\n\n        elif plotType=='PPN':\n\n            ain=self.get('A',cycle)\n            zin=self.get('Z',cycle)\n            nin=ain-zin\n            yin=self.get('ABUNDANCE_MF',cycle)\n            isom=self.get('ISOM',cycle)\n\n            if mass_range != None:\n                tmpA=[]\n                tmpZ=[]\n                tmpIsom=[]\n                tmpyps=[]\n                for i in range(len(nin)):\n                    if (ain[i] >mass_range[0] and ain[i]<mass_range[1])\\\n                    or (ain[i]==mass_range[0] or ain[i]==mass_range[1]):\n                        tmpA.append(nin[i])\n                        tmpZ.append(zin[i])\n                        tmpIsom.append(isom[i])\n                        tmpyps.append(yin[i])\n                zin=tmpZ\n                nin=tmpA\n                yin=tmpyps\n                isom=tmpIsom\n\n        else:\n            print('This method, abu_chart, is not supported by this class')\n            print('Returning None')\n            return None\n        # in case we call from ipython -pylab, turn interactive on at end again\n        turnoff=False\n        if not show:\n            try:\n                ioff()\n                turnoff=True\n            except NameError:\n                turnoff=False\n\n        nnmax = int(max(nin))+1\n        nzmax = int(max(zin))+1\n        nnmax_plot = nnmax\n        nzmax_plot = nzmax\n        nzycheck = zeros([nnmax,nzmax,3])\n        nzycheck_plot = zeros([nnmax,nzmax,3])\n        for i in range(len(nin)):\n            if isom[i]==1:\n                ni = int(nin[i])\n                zi = int(zin[i])\n\n                nzycheck[ni,zi,0] = 1\n                nzycheck[ni,zi,1] = yin[i]\n                nzycheck_plot[ni,zi,0] = 1\n\n\n\n        #######################################################################\n        # elemental names: elname(i) is the name of element with Z=i\n\n        elname=self.elements_names\n\n        #### create plot\n        ## define axis and plot style (colormap, size, fontsize etc.)\n        if plotaxis==[0,0,0,0]:\n            xdim=10\n            ydim=6\n        else:\n            dx = plotaxis[1]-plotaxis[0]\n            dy = plotaxis[3]-plotaxis[2]\n            ydim = 6\n            xdim = ydim*dx/dy\n\n\n        params = {'axes.labelsize':  15,\n                  'text.fontsize':   12,\n                  'legend.fontsize': 15,\n                  'xtick.labelsize': 15,\n                  'ytick.labelsize': 15,\n                  'text.usetex': True}\n        #pl.rcParams.update(params) #May cause Error, someting to do with tex\n        #fig=pl.figure(figsize=(xdim,ydim),dpi=100)\n        fig=pl.figure()\n        if profile == 'charged':\n            ax1 = fig.add_subplot(1, 2, 1)\n        elif profile == 'neutron':\n            ax1 = fig.add_subplot(2, 1, 1)\n        #axx = 0.10\n        #axy = 0.10\n        #axw = 0.85\n        #axh = 0.8\n        #ax1=pl.axes([axx,axy,axw,axh])\n        # Tick marks\n        xminorlocator = MultipleLocator(1)\n        xmajorlocator = MultipleLocator(5)\n        ax1.xaxis.set_major_locator(xmajorlocator)\n        ax1.xaxis.set_minor_locator(xminorlocator)\n        yminorlocator = MultipleLocator(1)\n        ymajorlocator = MultipleLocator(5)\n        ax1.yaxis.set_major_locator(ymajorlocator)\n        ax1.yaxis.set_minor_locator(yminorlocator)\n\n        # color map choice for abundances\n        #cmapa = cm.jet\n        cmapa = cm.summer\n        # color map choice for arrows\n        cmapr = cm.summer\n        # if a value is below the lower limit its set to white\n        cmapa.set_under(color='w')\n        cmapr.set_under(color='w')\n        # set value range for abundance colors (log10(Y))\n        norma = colors.Normalize(vmin=lbound[0],vmax=lbound[1])\n        # set x- and y-axis scale aspect ratio to 1\n        #ax1.set_aspect('equal')\n        #print time,temp and density on top\n        temp = ' '#'%8.3e' %ff['temp']\n        time = ' '#'%8.3e' %ff['time']\n        dens = ' '#'%8.3e' %ff['dens']\n\n        #May cause Error, someting to do with tex\n        '''\n        #box1 = TextArea(\"t : \" + time + \" s~~/~~T$_{9}$ : \" + temp + \"~~/~~$\\\\rho_{b}$ : \" \\\n        #             + dens + ' g/cm$^{3}$', textprops=dict(color=\"k\"))\n        anchored_box = AnchoredOffsetbox(loc=3,\n                        child=box1, pad=0.,\n                        frameon=False,\n                        bbox_to_anchor=(0., 1.02),\n                        bbox_transform=ax.transAxes,\n                        borderpad=0.,\n                        )\n        ax.add_artist(anchored_box)\n        '''\n        ## Colour bar plotted\n\n        patches = []\n        color = []\n\n        for i in range(nzmax):\n            for j in range(nnmax):\n                if nzycheck[j,i,0]==1:\n                    xy = j-0.5,i-0.5\n\n                    rect = Rectangle(xy,1,1,)\n\n                    # abundance\n                    yab = nzycheck[j,i,1]\n                    if yab == 0:\n\n                        yab=1e-99\n\n\n                    col =log10(yab)\n\n                    patches.append(rect)\n                    color.append(col)\n\n\n        p = PatchCollection(patches, cmap=cmapa, norm=norma)\n        p.set_array(array(color))\n        p.set_zorder(1)\n        ax1.add_collection(p)\n        cb = pl.colorbar(p)\n\n        # colorbar label\n        if profile == 'neutron':\n            cb.set_label('log$_{10}$(X)')\n\n        # plot file name\n        graphname = 'abundance-flux-chart'+str(cycle)\n\n        # Add black frames for stable isotopes\n        if boxstable:\n            for i in range(len(self.stable_el)):\n                if i == 0:\n                    continue\n\n\n                tmp = self.stable_el[i]\n                try:\n                    zz= self.elements_names.index(tmp[0]) #charge\n                except:\n                    continue\n\n                for j in range(len(tmp)):\n                    if j == 0:\n                        continue\n\n                    nn = int(tmp[j]) #atomic mass\n                    nn=nn-zz\n\n                    xy = nn-0.5,zz-0.5\n                    rect = Rectangle(xy,1,1,ec='k',fc='None',fill='False',lw=4.)\n                    rect.set_zorder(2)\n                    ax1.add_patch(rect)\n\n\n\n\n        # decide which array to take for label positions\n        iarr = 0\n\n        # plot element labels\n        if ilabel:\n            for z in range(nzmax):\n                try:\n                    nmin = min(argwhere(nzycheck[:,z,iarr]))[0]-1\n                    nmax = max(argwhere(nzycheck[:,z,iarr]))[0]+1\n                    ax1.text(nmin,z,elname[z],horizontalalignment='center',verticalalignment='center',\\\n                            fontsize='small',clip_on=True)\n                    ax1.text(nmax,z,elname[z],horizontalalignment='center',verticalalignment='center',\\\n                            fontsize='small',clip_on=True)\n                except ValueError:\n                    continue\n\n        # plot mass numbers\n        if imlabel:\n            for z in range(nzmax):\n                for n in range(nnmax):\n                    a = z+n\n                    if nzycheck[n,z,iarr]==1:\n                        ax1.text(n,z,a,horizontalalignment='center',verticalalignment='center',\\\n                                fontsize='x-small',clip_on=True)\n\n\n        # plot lines at magic numbers\n        if imagic:\n            ixymagic=[2, 8, 20, 28, 50, 82, 126]\n            nmagic = len(ixymagic)\n            for magic in ixymagic:\n                if magic<=nzmax:\n                    try:\n                        xnmin = min(argwhere(nzycheck[:,magic,iarr]))[0]\n                        xnmax = max(argwhere(nzycheck[:,magic,iarr]))[0]\n                        line = ax1.plot([xnmin,xnmax],[magic,magic],lw=3.,color='r',ls='-')\n                    except ValueError:\n                        dummy=0\n                if magic<=nnmax:\n                    try:\n                        yzmin = min(argwhere(nzycheck[magic,:,iarr]))[0]\n                        yzmax = max(argwhere(nzycheck[magic,:,iarr]))[0]\n                        line = ax1.plot([magic,magic],[yzmin,yzmax],lw=3.,color='r',ls='-')\n                    except ValueError:\n                        dummy=0\n\n        # set axis limits\n        if plotaxis==[0,0,0,0]:\n\n            xmax=max(nin)\n            ymax=max(zin)\n            ax1.axis([-0.5,xmax+0.5,-0.5,ymax+0.5])\n        else:\n            ax1.axis(plotaxis)\n\n        # set x- and y-axis label\n        ax1.set_ylabel('Proton number')\n        if profile == 'charged':\n            ax1.set_xlabel('Neutron number')\n        #pl.title('Isotopic Chart for cycle '+str(int(cycle)))\n\n        #\n        # here below I read data from the flux_*****.DAT file.\n        #\n        file_name = 'flux_'+str(cycle).zfill(5)+'.DAT'\n        print(file_name)\n        f = open(file_name)\n        lines = f.readline()\n        lines = f.readlines()\n        f.close()\n\n        print_max_flux_in_plot =  False\n        # color map choice for fluxes\n        #cmapa = cm.jet\n        cmapa = cm.autumn\n        # color map choice for arrows\n        cmapr = cm.autumn\n        # starting point of arrow\n        coord_x_1 = []\n        coord_y_1 = []\n        # ending point of arrow (option 1)\n        coord_x_2 = []\n        coord_y_2 = []\n        # ending point of arrow (option 2)\n        coord_x_3 = []\n        coord_y_3 = []\n        # fluxes\n        flux_read = []\n        flux_log10 = []\n\n        if which_flux == None or which_flux == 0:\n            print('chart for nucleosynthesis fluxes [dYi/dt]')\n            line_to_read = 9\n        elif which_flux == 1:\n            print('chart for energy fluxes')\n            line_to_read = 10\n        elif which_flux > 1:\n            print(\"you have only option 0 or 1, not larger than 1\")\n\n        single_line = []\n        for i in range(len(lines)):\n            single_line.append(lines[i].split())\n            coord_y_1.append(int(single_line[i][1]))\n            coord_x_1.append(int(single_line[i][2])-coord_y_1[i])\n            coord_y_2.append(int(single_line[i][5]))\n            coord_x_2.append(int(single_line[i][6])-coord_y_2[i])\n            coord_y_3.append(int(single_line[i][7]))\n            coord_x_3.append(int(single_line[i][8])-coord_y_3[i])\n            try:\n                flux_read.append(float(single_line[i][line_to_read]))\n            except ValueError: # this is done to avoid format issues like 3.13725-181...\n                flux_read.append(1.0E-99)\n            flux_log10.append(log10(flux_read[i]+1.0e-99))\n\n        print(file_name,' read!')\n\n        # I need to select smaller sample, with only fluxes inside plotaxis.\n        if plotaxis!=[0,0,0,0]:\n            coord_y_1_small=[]\n            coord_x_1_small=[]\n            coord_y_2_small=[]\n            coord_x_2_small=[]\n            coord_y_3_small=[]\n            coord_x_3_small=[]\n            flux_log10_small = []\n            for i in range(len(flux_log10)):\n                I_am_in = 0\n                if coord_y_1[i] > plotaxis[2] and coord_y_1[i] < plotaxis[3] and coord_x_1[i] > plotaxis[0] and coord_x_1[i] < plotaxis[1]:\n                    I_am_in = 1\n                    coord_y_1_small.append(int(coord_y_1[i]))\n                    coord_x_1_small.append(int(coord_x_1[i]))\n                    coord_y_2_small.append(int(coord_y_2[i]))\n                    coord_x_2_small.append(int(coord_x_2[i]))\n                    coord_y_3_small.append(int(coord_y_3[i]))\n                    coord_x_3_small.append(int(coord_x_3[i]))\n                    flux_log10_small.append(flux_log10[i])\n                if coord_y_3[i] > plotaxis[2] and coord_y_3[i] < plotaxis[3] and coord_x_3[i] > plotaxis[0] and coord_x_3[i] < plotaxis[1] and I_am_in == 0:\n                    I_am_in = 1\n                    coord_y_1_small.append(int(coord_y_1[i]))\n                    coord_x_1_small.append(int(coord_x_1[i]))\n                    coord_y_2_small.append(int(coord_y_2[i]))\n                    coord_x_2_small.append(int(coord_x_2[i]))\n                    coord_y_3_small.append(int(coord_y_3[i]))\n                    coord_x_3_small.append(int(coord_x_3[i]))\n                    flux_log10_small.append(flux_log10[i])\n\n\n\n        # elemental labels off/on [0/1]\n        ilabel = 1\n\n        # label for isotopic masses off/on [0/1]\n        imlabel = 1\n\n        # turn lines for magic numbers off/on [0/1]\n        imagic = 0\n\n        # flow is plotted over \"prange\" dex. If flow < maxflow-prange it is not plotted\n        if prange == None:\n            print('plot range given by default')\n            prange = 8.\n\n        #############################################\n        #print flux_log10_small\n        # we should scale prange on plot_axis range, not on max_flux!\n        max_flux = max(flux_log10)\n        ind_max_flux = flux_log10.index(max_flux)\n        if plotaxis!=[0,0,0,0]:\n            max_flux_small = max(flux_log10_small)\n\n        if plotaxis==[0,0,0,0]:\n            nzmax = int(max(max(coord_y_1),max(coord_y_2),max(coord_y_3)))+1\n            nnmax = int(max(max(coord_x_1),max(coord_x_2),max(coord_x_3)))+1\n            coord_x_1_small = coord_x_1\n            coord_x_2_small = coord_x_2\n            coord_x_3_small = coord_x_3\n            coord_y_1_small = coord_y_1\n            coord_y_2_small = coord_y_2\n            coord_y_3_small = coord_y_3\n            flux_log10_small= flux_log10\n            max_flux_small  = max_flux\n        else:\n            nzmax = int(max(max(coord_y_1_small),max(coord_y_2_small),max(coord_y_3_small)))+1\n            nnmax = int(max(max(coord_x_1_small),max(coord_x_2_small),max(coord_x_3_small)))+1\n\n        for i in range(nzmax):\n            for j in range(nnmax):\n                if nzycheck[j,i,0]==1:\n                    xy = j-0.5,i-0.5\n                    rect = Rectangle(xy,1,1,)\n                    patches.append(rect)\n\n\n        nzycheck = zeros([nnmax_plot,nzmax,3])\n        coord_x_out = zeros(len(coord_x_2_small), dtype='int')\n        coord_y_out = zeros(len(coord_y_2_small),dtype='int')\n        for i in range(len(flux_log10_small)):\n            nzycheck[coord_x_1_small[i],coord_y_1_small[i],0] = 1\n            nzycheck[coord_x_1_small[i],coord_y_1_small[i],1] = flux_log10_small[i]\n            if coord_x_2_small[i] >= coord_x_3_small[i]:\n                coord_x_out[i] = coord_x_2_small[i]\n                coord_y_out[i] = coord_y_2_small[i]\n                nzycheck[coord_x_out[i],coord_y_out[i],0] = 1\n                nzycheck[coord_x_out[i],coord_y_out[i],1] = flux_log10_small[i]\n            elif coord_x_2_small[i] < coord_x_3_small[i]:\n                coord_x_out[i] = coord_x_3_small[i]\n                coord_y_out[i] = coord_y_3_small[i]\n                nzycheck[coord_x_out[i],coord_y_out[i],0] = 1\n                nzycheck[coord_x_out[i],coord_y_out[i],1] = flux_log10_small[i]\n            if flux_log10_small[i]>max_flux_small-prange:\n                nzycheck[coord_x_1_small[i],coord_y_1_small[i],2] = 1\n                nzycheck[coord_x_out[i],coord_y_out[i],2] = 1\n\n        #### create plot\n        if profile == 'charged':\n            ax2 = fig.add_subplot(1, 2, 2)\n        elif profile == 'neutron':\n            ax2 = fig.add_subplot(2, 1, 2)\n        # Tick marks\n        xminorlocator = MultipleLocator(1)\n        xmajorlocator = MultipleLocator(5)\n        ax2.xaxis.set_major_locator(xmajorlocator)\n        ax2.xaxis.set_minor_locator(xminorlocator)\n        yminorlocator = MultipleLocator(1)\n        ymajorlocator = MultipleLocator(5)\n        ax2.yaxis.set_major_locator(ymajorlocator)\n        ax2.yaxis.set_minor_locator(yminorlocator)\n        ## define axis and plot style (colormap, size, fontsize etc.)\n        if plotaxis==[0,0,0,0]:\n            xdim=10\n            ydim=6\n        else:\n            dx = plotaxis[1]-plotaxis[0]\n            dy = plotaxis[3]-plotaxis[2]\n            ydim = 6\n            xdim = ydim*dx/dy\n\n        format = 'pdf'\n        # set x- and y-axis scale aspect ratio to 1\n        #ax2.set_aspect('equal')\n\n        # Add black frames for stable isotopes\n        # Add black frames for stable isotopes\n        if boxstable:\n            for i in range(len(self.stable_el)):\n                if i == 0:\n                    continue\n\n\n                tmp = self.stable_el[i]\n                try:\n                    zz= self.elements_names.index(tmp[0]) #charge\n                except:\n                    continue\n\n                for j in range(len(tmp)):\n                    if j == 0:\n                        continue\n\n                    nn = int(tmp[j]) #atomic mass\n                    nn=nn-zz\n\n                    xy = nn-0.5,zz-0.5\n                    rect = Rectangle(xy,1,1,ec='k',fc='None',fill='False',lw=4.)\n                    rect.set_zorder(2)\n                    ax2.add_patch(rect)\n\n\n        apatches = []\n        acolor = []\n        m = old_div(0.8,prange)\n        vmax=ceil(max(flux_log10_small))\n        vmin=max(flux_log10_small)-prange\n        b=-vmin*m+0.1\n        normr = colors.Normalize(vmin=vmin,vmax=vmax)\n        ymax=0.\n        xmax=0.\n\n        for i in range(len(flux_log10_small)):\n            x = coord_x_1_small[i]\n            y = coord_y_1_small[i]\n            dx = coord_x_out[i]-coord_x_1_small[i]\n            dy = coord_y_out[i]-coord_y_1_small[i]\n            if flux_log10_small[i]>=vmin:\n                arrowwidth = flux_log10_small[i]*m+b\n                arrow = Arrow(x,y,dx,dy, width=arrowwidth)\n                if xmax<x:\n                    xmax=x\n                if ymax<y:\n                    ymax=y\n                acol = flux_log10_small[i]\n                apatches.append(arrow)\n                acolor.append(acol)\n            xy = x-0.5,y-0.5\n            rect = Rectangle(xy,1,1,ec='k',fc='None',fill='False',lw=1.)\n            patches.append(rect)\n            xy = x+dx-0.5,y+dy-0.5\n            rect = Rectangle(xy,1,1,ec='k',fc='None',fill='False',lw=1.)\n            patches.append(rect)\n\n\n        p = PatchCollection(patches,norm=0,facecolor='w')\n        p.set_zorder(1)\n        ax2.add_collection(p)\n\n\n\n\n        a = PatchCollection(apatches, cmap=cmapr, norm=normr)\n        a.set_array(array(acolor))\n        a.set_zorder(3)\n        ax2.add_collection(a)\n        cb = pl.colorbar(a)\n\n        # colorbar label\n        cb.set_label('log$_{10}$($x$)')\n        if profile == 'neutron':\n            cb.set_label('log$_{10}$(f)')\n\n        # decide which array to take for label positions\n        iarr = 2\n\n        # plot element labels\n        for z in range(nzmax):\n            try:\n                nmin = min(argwhere(nzycheck_plot[:,z,iarr-2]))[0]-1\n                nmax = max(argwhere(nzycheck_plot[:,z,iarr-2]))[0]+1\n                ax2.text(nmin,z,elname[z],horizontalalignment='center',verticalalignment='center',fontsize='small',clip_on=True)\n                ax2.text(nmax,z,elname[z],horizontalalignment='center',verticalalignment='center',fontsize='small',clip_on=True)\n            except ValueError:\n                continue\n\n        # plot mass numbers\n        if imlabel:\n            for z in range(nzmax):\n                for n in range(nnmax_plot):\n                    a = z+n\n                    if nzycheck_plot[n,z,iarr-2]==1:\n                        ax2.text(n,z,a,horizontalalignment='center',verticalalignment='center',fontsize='x-small',clip_on=True)\n\n        # plot lines at magic numbers\n        if imagic==1:\n            ixymagic=[2, 8, 20, 28, 50, 82, 126]\n            nmagic = len(ixymagic)\n            for magic in ixymagic:\n                if magic<=nzmax:\n                    try:\n                        xnmin = min(argwhere(nzycheck[:,magic,iarr-2]))[0]\n                        xnmax = max(argwhere(nzycheck[:,magic,iarr-2]))[0]\n                        line = ax2.plot([xnmin,xnmax],[magic,magic],lw=3.,color='r',ls='-')\n                    except ValueError:\n                        dummy=0\n                if magic<=nnmax:\n                    try:\n                        yzmin = min(argwhere(nzycheck[magic,:,iarr-2]))[0]\n                        yzmax = max(argwhere(nzycheck[magic,:,iarr-2]))[0]\n                        line = ax2.plot([magic,magic],[yzmin,yzmax],lw=3.,color='r',ls='-')\n                    except ValueError:\n                        dummy=0\n\n        # set axis limits\n        if plotaxis==[0,0,0,0]:\n            ax2.axis([-0.5,xmax+0.5,-0.5,ymax+0.5])\n        else:\n            ax2.axis(plotaxis)\n\n        # set x- and y-axis label\n        ax2.set_xlabel('Neutron number')\n        if profile == 'neutron':\n            ax2.set_ylabel('Proton number')\n        if which_flux == None or which_flux == 0:\n            max_flux_label=\"max flux = \"+str('{0:.4f}'.format(max_flux))\n        elif which_flux == 1:\n            max_flux_label=\"max energy flux = \"+str('{0:.4f}'.format(max_flux))\n        if print_max_flux_in_plot:\n            ax2.text(plotaxis[1]-1.8,plotaxis[2]+0.1,max_flux_label,fontsize=10.)\n\n        #fig.savefig(graphname)\n        print(graphname,'is done')\n        if show:\n            pl.show()\n        if turnoff:\n            ion()\n        return"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef iso_abund(self, cycle, stable=False, amass_range=None,\n                  mass_range=None, ylim=[0,0], ref=-1, show=True,\n                  log_logic=True, decayed=False, color_plot=True,\n                  grid=False, point_set=1, include_title=False,\n                  data_provided=False,thedata=None, verbose=True,\n                  mov=False,drawfig=None,drawax=None,show_names=True,\n                  label=None,colour=None,elemaburtn=False,mypoint=None,plot_type=['-','--','-.',':','-']):\n        '''\n        plot the abundance of all the chemical species\n\n        Parameters\n        ----------\n        cycle : string, integer or list\n            The cycle of interest.  If it is a list of cycles, this\n            method will do a plot for each cycle and save them to a\n            file.\n        stable : boolean, optional\n            A boolean of whether to filter out the unstables.  The\n            defaults is False.\n        amass_range : list, optional\n            A 1x2 array containing the lower and upper atomic mass\n            range.  If None plot entire available atomic mass range.\n            The default is None.\n        mass_range : list, optional\n            A 1x2 array containing the lower and upper mass range.  If\n            this is an instance of abu_vector this will only plot\n            isotopes that have an atominc mass within this range.  This\n            will throw an error if this range does not make sense ie\n            [45,2].  If None, it will plot over the entire range.  The\n            defaults is None.\n        ylim : list, optional\n            A 1x2 array containing the lower and upper Y limits.  If\n            it is [0,0], then ylim will be determined automatically.\n            The default is [0,0].\n        ref : integer or list, optional\n            reference cycle.  If it is not -1, this method will plot\n            the abundences of cycle devided by the cycle of the same\n            instance given in the ref variable.  If ref is a list it\n            will be interpreted to have two elements:\n            ref=['dir/of/ref/run',cycle] which uses a refernece cycle\n            from another run.  If any abundence in the reference cycle\n            is zero, it will replace it with 1e-99.  The default is -1.\n        show : boolean, optional\n            Boolean of if the plot should be displayed.  The default is\n            True.\n        log_logic : boolean, optional\n            Plot abundances in log scale or linear.  The default is\n            True.\n        decayed : boolean, optional\n            If True plot decayed distributions, else plot life\n            distribution.  The default is False.\n        color_plot : boolean, optional\n            Color dots and lines [True/False].  The default is True.\n        grid : boolean, optional\n            print grid.  The default is False.\n        point_set : integer, optional\n            Set to 0, 1 or 2 to select one of three point sets, useful\n            for multiple abundances or ratios in one plot.  The defalult\n            is 1.\n        include_title : boolean, optional\n            Include a title with the plot.  The default is False.\n        drawfig, drawax, mov : optional, not necessary for user to set these variables\n            The figure and axes containers to be drawn on, and whether or not a movie is\n            being made (only True when se.movie is called, which sets mov to True\n            automatically\n        elemaburtn : boolean, private\n            If true, iso_abund() returns after writing self.***_iso_to_plot for\n            use with other plotting routines.f\n        mypoint : string, optional\n            fix the marker style of all the points in this plot to one type, given\n            as a string. If None, multiple point styles are used as per point_set.\n            The default is None\n        '''\n\n        plotType=self._classTest()\n        if str(cycle.__class__)==\"<type 'list'>\":\n            self.iso_abundMulti(cycle, stable,amass_range,mass_range,ylim,ref,\n                 decayed,include_title,color_plot=color_plot,grid=False,point_set=point_set)\n            return\n\n        if mass_range!=None and mass_range[0]>mass_range[1]:\n            print('Please input a proper mass range')\n            print('Returning None')\n            return None\n        if amass_range!=None and amass_range[0]>amass_range[1]:\n            print('Please input a proper Atomic mass range')\n            print('Returning None')\n            return None\n        if plotType=='se':\n            if decayed:\n                print('Decay option not yet implemented for mppnp - but it is easy do! Consider investing the time!')\n                return None\n\n\n            # get things as arrays\n            if not data_provided:\n                cycle=self.se.findCycle(cycle)\n                a_iso_to_plot   = array(self.se.A)\n                abunds          = self.get(cycle,'iso_massf')\n                isotope_to_plot = array(self.se.isotopes)\n                z_iso_to_plot   = array(self.se.Z)\n                isomers_to_plot = array(self.se.isomeric_states)\n                if ref >-1:\n                    ref=self.se.findCycle(ref)\n                    abundsRef=self.se.get(ref,'iso_massf')\n                masses = self.se.get(cycle,'mass')\n            else:\n                cycle=cycle # why so serious?\n                a_iso_to_plot   = array(self.se.A)\n                abunds          = thedata[0]\n                isotope_to_plot = array(self.se.isotopes)\n                z_iso_to_plot   = array(self.se.Z)\n                isomers_to_plot = array(self.se.isomeric_states)\n\n                if ref >-1:\n                    raise IOError(\"No. It's not ready yet.\")\n                    #ref=self.se.findCycle(ref)\n                    #abundsRef=self.se.get(ref,'iso_massf')\n                masses = thedata[1]\n\n            if mass_range == None:\n                if verbose:\n                    print('Using default mass range')\n                mass_range = [min(masses),max(masses)]\n            masses.sort()\n            mass_range.sort()\n\n            if amass_range == None:\n                amass_range=[int(min(a_iso_to_plot)),int(max(a_iso_to_plot))]\n\n            # remove neutrons - this could move in the non- se/PPN specific part below\n            if 0 in z_iso_to_plot:\n                ind_neut        = where(z_iso_to_plot==0)[0][0]\n                a_iso_to_plot   = delete(a_iso_to_plot,ind_neut)\n                z_iso_to_plot   = delete(z_iso_to_plot,ind_neut)\n                isomers_to_plot = delete(isomers_to_plot,ind_neut)\n                isotope_to_plot = delete(isotope_to_plot,ind_neut)\n                abunds = delete(abunds,ind_neut,1)\n                if ref >-1:\n                    abundsRef = delete(abundsRef,ind_neut,1)\n\n            # extract amass_range\n            acon=(a_iso_to_plot>=amass_range[0]) & (a_iso_to_plot<=amass_range[1])\n            isomers_to_plot = isomers_to_plot[acon]\n            isotope_to_plot = isotope_to_plot[acon]\n            z_iso_to_plot   = z_iso_to_plot[acon]\n            abunds          = abunds.T[acon].T\n            if ref >-1:\n                abundsRef = abundsRef.T[acon].T\n            a_iso_to_plot   = a_iso_to_plot[acon]\n            el_iso_to_plot  = array([x.split('-')[0] for x in isotope_to_plot.tolist()])\n            # apply mass range\n            if mass_range == None:\n                if verbose:\n                    print('Using default mass range')\n                mass_range = [min(masses),max(masses)]\n            mass_range.sort()\n            aabs = []\n            if ref >-1:\n                cyc  = [cycle,ref]\n                abus = [abunds,abundsRef]\n            else:\n                cyc  = [cycle]\n                abus = [abunds]\n            for cc,aa in zip(cyc,abus):\n                if not data_provided:\n                    masses = self.se.get(cc,'mass')\n                else:\n                    masses=masses # why so serious?\n                masses.sort()\n                dmass  = masses[1:] - masses[:-1]    # I should check the grid definition\n                dmass  = append(dmass,0.)\n                mcon   = (masses>=mass_range[0]) & (masses<=mass_range[1])\n                dmass  = dmass[mcon]\n                aa = aa[mcon]\n\n                # average over mass range:\n                aa = (aa.T*dmass).T.sum(0)\n                aa = old_div(aa, (mass_range[1] - mass_range[0]))\n                # abunds has now length of isotope_to_plot\n                aabs.append(aa)\n            if ref >-1:\n                abunds = old_div(aabs[0],(aabs[1]+1.e-99))\n            else:\n                abunds = aabs[0]\n\n            self.a_iso_to_plot=a_iso_to_plot\n            self.isotope_to_plot=isotope_to_plot\n            self.z_iso_to_plot=z_iso_to_plot\n            self.el_iso_to_plot=el_iso_to_plot\n            self.abunds=abunds\n            self.isomers_to_plot=isomers_to_plot\n\n            if elemaburtn: return\n#                        self.isotopes = self.se.isotopes\n\n        elif plotType=='PPN':\n            print(\"This method adds the following variables to the instance:\")\n            print(\"a_iso_to_plot      mass number of plotted range of species\")\n            print(\"isotope_to_plot    corresponding list of isotopes\")\n            print(\"z_iso_to_plot      corresponding charge numbers\")\n            print(\"el_iso_to_plot     corresponding element names\")\n            print(\"abunds             corresponding abundances\")\n            print(\"isom               isomers and their abundance\")\n\n            self.get(cycle,decayed=decayed)\n            if ref is not -1:\n                if type(ref) is list: # reference cycle from other run\n                    import ppn\n                    pp=ppn.abu_vector(ref[0])\n                    abunds_pp=pp.get(ref[1],decayed=decayed)\n                    self.abunds=old_div(self.abunds,pp.abunds)\n                else:\n                    abunds=self.abunds\n                    self.get(ref,decayed=decayed)\n                    self.abunds=old_div(abunds,(self.abunds+1.e-99))\n            if amass_range == None:\n                amass_range=[min(self.a_iso_to_plot),max(self.a_iso_to_plot)]\n\n            aa=ma.masked_outside(self.a_iso_to_plot,amass_range[0],amass_range[1])\n            isotope_to_plot=ma.array(self.isotope_to_plot,mask=aa.mask).compressed()\n            z_iso_to_plot=ma.array(self.z_iso_to_plot,mask=aa.mask).compressed()\n            el_iso_to_plot=ma.array(self.el_iso_to_plot,mask=aa.mask).compressed()\n            abunds=ma.array(self.abunds,mask=aa.mask).compressed()\n            a_iso_to_plot=aa.compressed()\n            isomers_to_plot=[]\n            for i in range(len(self.isom)):\n                if int(self.isom[i][0].split('-')[1])>100:\n                    isomers_to_plot.append(self.isom[i])\n\n            self.a_iso_to_plot=a_iso_to_plot\n            self.isotope_to_plot=isotope_to_plot\n            self.z_iso_to_plot=z_iso_to_plot\n            self.el_iso_to_plot=el_iso_to_plot\n            self.abunds=abunds\n            self.isomers_to_plot=isomers_to_plot\n        else:\n            print('This method, iso_abund, is not supported by this class')\n            print('Returning None')\n            return None\n\n        if verbose:\n            print('Using the following conditions:')\n            if plotType=='se':\n                print('\\tmass_range:', mass_range[0], mass_range[1])\n            print('\\tAtomic mass_range:', amass_range[0], amass_range[1])\n            print('\\tcycle:           ',cycle)\n            print('\\tplot only stable:',stable)\n            print('\\tplot decayed:    ',decayed)\n\n\n        if stable: # remove unstables:\n            # For the element that belongs to the isotope at index 5 in isotope_to_plot\n            # (C-12) the following gives the mass numbers of stable elements:\n            # self.stable_el[self.stable_names.index(el_iso_to_plot[5])][1:]\n            ind_delete=[]\n            for i in range(len(isotope_to_plot)):\n                if a_iso_to_plot[i] not in self.stable_el[self.stable_names.index(el_iso_to_plot[i])][1:]:\n                    ind_delete.append(i)\n            a_iso_to_plot   = delete(a_iso_to_plot,  ind_delete)\n            z_iso_to_plot   = delete(z_iso_to_plot,  ind_delete)\n            isomers_to_plot = delete(isomers_to_plot,ind_delete)\n            isotope_to_plot = delete(isotope_to_plot,ind_delete)\n            el_iso_to_plot  = delete(el_iso_to_plot, ind_delete)\n            abunds          = delete(abunds,         ind_delete)\n\n#        el_list=[] # list of elements in el_iso_to_plot\n#\n#        for el in self.elements_names:\n#            if el in el_iso_to_plot:\n#                el_list.append(el)\n\n        # SJONES implicit loop:\n        el_list = [el for el in self.elements_names if el in el_iso_to_plot]\n\n        abund_plot = []  # extract for each element an abundance and associated\n        mass_num   = []  # mass number array, sorted by mass number\n\n        for el in el_list:\n            numbers = a_iso_to_plot[(el_iso_to_plot==el)]\n            abund_plot.append(abunds[(el_iso_to_plot==el)][argsort(numbers)])\n            mass_num.append(sort(numbers))\n        # now plot:\n        #plot_type = ['-','--','-.',':','-'] ##now implemented as an arg\n        print(plot_type)\n        while len(plot_type)<=4:\n            plot_type.append('')\n            print(plot_type)\n        pl_index = 0\n        if mypoint is None:\n            points = [['o','^','p','h','*'],['x','+','D','>','s'],['H','v','<','*','3']]\n        else:\n            points = [ [mypoint]*5 , [mypoint]*5 , [mypoint]*5]\n        if color_plot:\n            colors = ['g','r','c','m','k']\n        elif colour is not None:\n            colors = [colour]*5\n        else:\n            colors = ['k','k','k','k','k']\n\n        ylim1 =  1.e99\n        ylim2 = -1.e99\n\n        # initialise movie-related things:\n        if mov:\n            artists=[]\n            ax=drawax\n            fig=drawfig\n        elif drawax is not None:\n            ax=drawax\n        else:\n            ax=pl.axes()\n\n        if drawfig is not None:\n            fig=drawfig\n\n        for j in range(len(abund_plot)):        #Loop through the elements of interest\n#            for l in xrange(len(abund_plot[j])):\n#                if abund_plot[j][l] == 0:\n#                    abund_plot[j][l] = 1e-99\n\n            abund_plot[j] = np.maximum(abund_plot[j],1.e-99) # SJONES instead of looping\n\n#            a_dum=zeros(len(abund_plot[j]))   # this I (FH) have to do because for some\n            if log_logic == False:            # reason log10(abu_abund[j]) does not work\n                a_dum = abund_plot[j]         # although abu_abund[j] is a numpy array?!?\n            else:\n#                for ii in range(len(abund_plot[j])):\n#                    a_dum[ii]=log10(abund_plot[j][ii])\n                a_dum=np.log10(abund_plot[j]) # SJONES this seems to work fine for me\n            if type(colors[0]) is str:\n                this_label=str(colors[pl_index]+points[point_set][pl_index]+\\\n                           plot_type[pl_index])\n            else:\n                this_label=None\n            if mov:\n                artist1,=ax.plot(mass_num[j],a_dum,this_label,markersize=6,\n                                 markeredgecolor='None')\n            else:\n                if this_label is not None:\n                    if label is not None and j==0:\n                        pl.plot(mass_num[j],a_dum,this_label,markersize=6,\n                                label=label,markeredgecolor='None')\n                        pl.legend(loc='best').draw_frame(False)\n                    else:\n                        pl.plot(mass_num[j],a_dum,this_label,markersize=6,\n                                markeredgecolor='None')\n                else:\n                    if label is not None and j==0:\n                        pl.plot(mass_num[j],a_dum,\n                                color=colors[pl_index],\n                                marker=points[point_set][pl_index],\n                                linestyle=plot_type[pl_index],\n                                markersize=6,label=label,\n                                markeredgecolor='None')\n                        pl.legend(loc='best').draw_frame(False)\n                    else:\n                        pl.plot(mass_num[j],a_dum,\n                                color=colors[pl_index],\n                                marker=points[point_set][pl_index],\n                                linestyle=plot_type[pl_index],\n                                markersize=6,markeredgecolor='None')\n\n            abu_max = max(a_dum)\n            max_index=where(a_dum==abu_max)[0][0]\n            coordinates=[mass_num[j][max_index],abu_max]\n            if mov:\n                artist2=ax.text(coordinates[0]+0.1,1.05*coordinates[1],el_list[j],clip_on=True)\n            else:\n                if show_names:\n#                    pl.text(coordinates[0]+0.1,1.05*coordinates[1],el_list[j],clip_on=True)\n                    pl.text(coordinates[0],np.log10(2.2*10.**coordinates[1]),\n                            el_list[j],clip_on=True,\n                            horizontalalignment='center')\n\n            pl_index+=1\n            if pl_index > 4:\n                pl_index = 0\n            ylim1=min(ylim1,min(a_dum))\n            ylim2=max(ylim2,max(a_dum))\n\n            if mov:\n                artists.extend([artist1,artist2])\n\n        # now trimming the ylims\n        if log_logic:\n            dylim=0.05*(ylim2-ylim1)\n            ylim1 = ylim1 -dylim\n            ylim2 = ylim2 +dylim\n            if ref is not -1:\n                ylim2 = min(ylim2,4)\n                ylim1 = max(ylim1,-4)\n            else:\n                ylim2 = min(ylim2,0.2)\n                ylim1 = max(ylim1,-13)\n        else:\n            ylim1 = ylim1 *0.8\n            ylim2 = ylim2 *1.1\n        if include_title:\n            if plotType=='se':\n                if ref == -1:\n                    title = str('Range %4.2f' %mass_range[0]) + str('-%4.2f' %mass_range[1]) +\\\n                        str(' for cycle %d' %int(cycle))\n                else:\n                    title = str('Range %4.2f' %mass_range[0]) + \\\n                        str('-%4.2f' %mass_range[1]) + str(' for cycle %d' %int(cycle))+\\\n                        str(' relative to cycle %d'  %int(ref))\n            else:\n                if ref == -1:\n                    title = str('Cycle %d' %int(cycle))\n                else:\n                    title = str('Cycle %d' %int(cycle))+\\\n                            str(' relative to cycle %d'  %int(ref))\n            print(\"including title: ...\")\n            if mov:\n                artist1,=ax.title(title)\n                artists.append(artist1)\n            else:\n                pl.title(title)\n        if ylim[0] == 0 and ylim[1] == 0:\n            pl.ylim(ylim1,ylim2)\n        else:\n            pl.ylim(ylim[0],ylim[1])\n        pl.xlim([amass_range[0]-.5,amass_range[1]+.5])\n        pl.xlabel('mass number (A)',fontsize=14)\n        if ref is not -1:\n            if log_logic:\n                pl.ylabel(r'log abundance ratio',fontsize=14)\n            else:\n                pl.ylabel(r'abundance ratio',fontsize=14)\n        else:\n            if log_logic:\n                pl.ylabel(r'log mass fraction ',fontsize=14)\n            else:\n                pl.ylabel(r'mass fraction',fontsize=14)\n\n\n        if amass_range != None:\n            minimum_mass = amass_range[0]\n            maximum_mass = amass_range[1]\n\n        elif mass_range != None:\n            minimum_mass = mass_range[0]\n            maximum_mass = mass_range[1]\n\n        else:\n            minimum_mass = 0\n            maximum_mass = 200\n\n        if log_logic == False:\n            if mov:\n                artist1,=ax.plot([amass_range[0]-.5,amass_range[1]+.5],[1,1],'k-')\n                artists.append(artist1)\n            else:\n                pl.plot([amass_range[0]-.5,amass_range[1]+.5],[1,1],'k-')\n        else:\n            if mov:\n                artist1,=ax.plot([amass_range[0]-.5,amass_range[1]+.5],[0,0],'k-')\n                artists.append(artist1)\n            else:\n                pl.plot([amass_range[0]-.5,amass_range[1]+.5],[0,0],'k-')\n\n        labelsx=[]\n        if (maximum_mass-minimum_mass) > 100:\n            delta_labelsx = 10\n        else:\n            delta_labelsx = 5\n\n        iii = amass_range[0]%delta_labelsx\n        if iii == 0:\n            labelsx.append(str(amass_range[0]))\n        else:\n            labelsx.append(' ')\n        iii = iii+1\n        kkk = 0\n        for label1 in range(amass_range[1]-amass_range[0]):\n            if iii == 5:\n                kkk = kkk+1\n                labelsx.append(str((iii*kkk)+amass_range[0]-(amass_range[0]%5)))\n                iii = 0\n                iii = iii+1\n            else:\n                labelsx.append(' ')\n                iii = iii+1\n\n        if delta_labelsx == 5:\n            xticks = arange(amass_range[0],amass_range[1],1)\n            pl.xticks(xticks,labelsx)\n        else:\n            pl.xticks()\n\n        # SJONES moved the pl.grid and pl.show to the very end\n        if grid:\n            pl.grid()\n        if show:\n            pl.show()\n\n##!!FOR!!###### print 'LEN LABELS= ', len(labelsx)\n##DEBUGGING####\n####!!!######## for bbb in range (len(labelsx)):\n###############     print labelsx[bbb]\n        if mov:\n            return artists", "response": "This method will plot the abundance of all the chemical species in a specific cycle."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef elemental_abund(self,cycle,zrange=[1,85],ylim=[0,0],title_items=None,\n                        ref=-1,ref_filename=None,z_pin=None,pin=None,\n                        pin_filename=None,zchi2=None,logeps=False,dilution=None,show_names=True,label='',\n                        colour='black',plotlines=':',plotlabels=True,mark='x',**kwargs):\n        '''\n        Plot the decayed elemental abundance distribution (PPN).\n        Plot the elemental abundance distribution (nugridse).\n        (FH, 06/2014; SJ 07/2014)\n\n        Parameters\n        ----------\n        cycle : string, integer or list\n            The cycle of interest.  If it is a list of cycles, this\n            method will do a plot for each cycle and save them to a\n            file.\n        zrange : list, optional\n            A 1x2 array containing the lower and upper atomic number\n            limit\n        ylim : list, optional\n            A 1x2 array containing the lower and upper Y limits.  If\n            it is [0,0], then ylim will be determined automatically.\n            The default is [0,0].\n        title_items : list, optional\n            A list of cycle attributes that will be added to the title.\n            For possible cycle attributes see self.cattrs.\n        ref : integer, optional\n            ref = N:    plot abundaces relative to cycle N abundance, similar to the\n                        'ref_filename' option.\n                        Cannot be active at the same time as\n                        the 'ref_filename' option.\n        ref_filename : string, optional\n            plot abundances relative to solar abundance. For this option,\n            a cycle number for the 'ref' option must not be provided\n        z_pin : int, optional\n            Charge number for an element to be 'pinned'. An offset will be\n            calculated from the difference between the cycle value and the\n            value from the pinned reference.\n            Can be used with the 'pin_filename' option to import an external\n            abundance file in the same format as solar abundances.\n            If no file is given, the reference can be either cycle N='ref'\n            or the value from the 'ref_filename'.\n        pin : float, optional\n            A manually provided [X/Fe] abundance to pin the element selected with 'z_pin'\n        pin_filename: string, optional\n            use provided file to provide reference to pin an element to. An offset is\n            calculated and used to shift the plot.\n            The file requires header columns marked by '#', column spacing of '  ', and at minimum two columns\n            containing:\n                'Z': charge number\n                '[X/Fe]': metallicity\n        zchi2 : list, optional\n            A 1x2 array containing atomic numbers of the elements\n            for which chi2 test is done when plotType == 'PPN' and pin_filename != None\n        logeps : boolean, optional\n            Plots log eps instead of [X/Fe] charts.\n        dilution : float, optional\n            Provides the dilution factor for mixing nucleosynthesis products to the surface\n            Cannot be active at the same time as the 'z_pin' option.\n        label : string, optional\n            The label for the abundance distribution\n            The default is '' (i.e. do not show a label)\n        show_names : boolean, optional\n            Whether or not to show the element names on the figure.\n        colour : string, optional\n            In case you want to dictate marker and line colours. Takes cymkrgb\n            single-character colours or any other colour string accepted by\n            matplotlib. The default is '' (automatic colour selection)\n        plotlines : string, optional\n            In case you want to dictate line style. Takes MatPlotLib linestyles.\n        mark : string, optional\n            In case you want to dictate marker style. Takes MatPlotLib markers.\n            Default is 'x'.\n        kwargs : additional keyword arguments\n            These arguments are equivalent to those of iso_abund, e.g.\n            mass_range. Routines from iso_abund are called, to perform\n            averages and get elemental abundances in the correct form.\n\n        Output\n        ------\n        if plotType == 'PPN' and pin_filename != None\n        chi2 : float\n            chi-squared deviation of predicted abundances from observed ones\n        if plotType == 'se'\n        z_el : array\n            proton number of elements being returned\n        el_abu_plot : array\n            elemental abundances (as you asked for them, could be ref to something else)\n\n        This method adds the following data to the abu_vector instance:\n        self.el_abu_hash : elemental abundance, dictionary\n        self.el_name     : element names, can be used as keys in el_abu_hash\n        self.el_abu_log  : array of log10 of elemental abundance as plotted, including any ref scaling\n        '''\n        #from . import utils\n        from . import ascii_table as asci\n        plotType=self._classTest()\n        offset=0\n        if ref_filename!=None:\n            ref=-2\n        if logeps==True:\n            if zrange[0]!=1:\n                print(\"To use logeps, the z range must be [1,X], otherwise the program will exit.\")\n                sys.exit()\n            z_pin=1\n            ref=-3\n        if plotType=='PPN':\n            self.get(cycle,decayed=True)\n            z_el=unique(self.z_iso_to_plot)\n            zmin_ind=min(where(z_el>=zrange[0])[0])\n            zmax_ind=max(where(z_el<=zrange[1])[0])\n            # extract some elemental quantities:\n            a_el=[]; el_name=[]; el_abu=[]; el_abu_hash={}\n            for z in z_el[zmin_ind:zmax_ind]:\n                el=self.el_iso_to_plot[where(self.z_iso_to_plot==z)[0].tolist()[0]]\n                X_el=self.abunds[where(self.el_iso_to_plot==el)[0].tolist()].sum()  # take all iso abunds for one Z and sum\n                a_el.append(self.a_iso_to_plot[where(self.z_iso_to_plot==z)[0].tolist()[0]])\n                el_abu.append(X_el)\n                el_name.append(el)\n                el_abu_hash[el]=X_el\n            fe_abund=self.abunds[where(self.el_iso_to_plot=='Fe')[0].tolist()].sum()    # Fe abund is always needed to find [X/Fe]\n            self.el_abu_hash = el_abu_hash\n            self.el_name     = el_name\n            # if we have provided a solar abundance file\n            if ref==-2:\n                from . import utils\n                utils.solar(ref_filename,1)\n                el_abu_sun=np.array(utils.solar_elem_abund)\n                el_abu_plot=np.zeros(len(el_abu))\n                for zs in z_el[zmin_ind:zmax_ind]:\n                    zelidx=where(z_el[zmin_ind:zmax_ind]==zs)[0]\n                    zsolidx=int(zs-1)\n                    if el_abu_sun[zsolidx] > 0. :\n                        el_abu_plot[zelidx]=el_abu[zelidx[0]]/el_abu_sun[zsolidx]\n                    else:\n                        el_abu_plot[zelidx]=-1\n\n            # if we have provided a reference cycle number\n            elif ref>-1:\n                self.get(ref,decayed=True)\n                z_el_ref=unique(self.z_iso_to_plot)\n                zmin_ind=min(where(z_el_ref>=zrange[0])[0])\n                zmax_ind=max(where(z_el_ref<=zrange[1])[0])\n                # extract some elemental quantities:\n                a_el_ref=[]; el_name_ref=[]; el_abu_ref=[]; el_abu_hash_ref={}\n                el_abu_plot=np.zeros(len(el_abu))\n                for z_ref in z_el[zmin_ind:zmax_ind]:\n                    el_ref=self.el_iso_to_plot[where(self.z_iso_to_plot==z_ref)[0].tolist()[0]]\n                    X_el_ref=self.abunds[where(self.el_iso_to_plot==el_ref)[0].tolist()].sum()\n                    a_el_ref.append(self.a_iso_to_plot[where(self.z_iso_to_plot==z_ref)[0].tolist()[0]])\n                    el_abu_ref.append(X_el_ref)\n                    el_name_ref.append(el_ref)\n                    el_abu_hash_ref[el_ref]=X_el\n                for i in range(len(el_abu)):\n                    el_abu_plot[i-1]=el_abu[i-1]/el_abu_ref[i-1]\n\n            # if we want to include observation data\n            if pin_filename!=None:\n                print('using the pin filename')\n                obs_file=asci.readTable(pin_filename,header_char='#')\n                xfe_sigma=[]\n                el_abu_obs_log=[]\n                z_ul=[]\n                for z_i in z_el[zmin_ind:zmax_ind]:\n                    try:\n                        obs_file.data['[X/H]']\n                        x_over='[X/H]'\n                        sigma='sig_[X/H]'\n                    except:\n                        x_over='[X/Fe]'\n                        sigma='sig_[X/Fe]'\n                    zelidx=where(z_el[zmin_ind:zmax_ind]==z_i)[0]\n                    zpinidx=where(obs_file.data['Z']==z_i)[0] #str()\n                    if len(zpinidx)==0:\n                        el_abu_obs_log.append([None])\n                        xfe_sigma.append([None])\n                        z_ul.append([None])\n                    elif len(zpinidx)>1:\n                        '''if any(obs_file.data['ul'][zpinidx].astype(int))==1:\n                            print('hi')\n                            tmp=obs_file.data['[X/Fe]'][zpinidx].astype(float)\n                            z_ul.append(tmp.tolist())\n                            el_abu_obs_log.append([None]*len(zpinidx))\n                            xfe_sigma.append([None]*len(zpinidx))\n                        else:'''\n                        tmp=obs_file.data[x_over][zpinidx]#.astype(float) # array stores multiple values for a\n                        el_abu_obs_log.append(tmp.tolist())                            # single element\n                        tmp=obs_file.data[sigma][zpinidx]#.astype(float)\n                        xfe_sigma.append(tmp.tolist())\n                        z_ul.append([None])\n                    else:\n                        if obs_file.data['ul'][zpinidx]==1: #.astype(int)\n                            tmp=obs_file.data[x_over][zpinidx]#.astype(float)\n                            z_ul.append(tmp.tolist())\n                            tmp=obs_file.data[x_over][zpinidx]#.astype(float)\n                            el_abu_obs_log.append([None])\n                            xfe_sigma.append([None])\n                        else:\n                            tmp=obs_file.data[x_over][zpinidx][0]#.astype(float)\n                            el_abu_obs_log.append([tmp])\n                            tmp=obs_file.data[sigma][zpinidx][0]#.astype(float)\n                            xfe_sigma.append([tmp])\n                            z_ul.append([None])\n                el_abu_obs=[]\n\n\n            # set a pinned element for offset calculation and adjustment\n            if z_pin!=None:\n                print(\"Pinned element: \"+str(z_pin))\n\n                if pin_filename!=None:\n                    # converting obervation data from log to standard form for compatibility\n                    # with later code\n                    for i in range(len(el_abu_obs_log)):\n                       if all(el_abu_obs_log[i])==None:\n                           el_abu_obs.append(None)\n                       else:\n                           el_abu_obs.append(np.power(10,el_abu_obs_log[i]))\n                       el_abu_pin=el_abu_obs\n\n                elif pin!=None:\n                    print('using manual pin')\n                    pin=np.power(10,pin)\n                    el_abu_pin=np.zeros(len(el_abu))\n                    for i in range(len(el_abu)):\n                        el_abu_pin[i-1]=pin\n\n                elif logeps==True:\n                    print('finding log eps')\n                    atomic_mass=[1.008, 4.003, 6.94, 9.012, 10.81, 12.011, 14.007, 15.999, 18.998, 20.18, 22.99, 24.305, 26.982, 28.085, 30.74, 32.06, 35.45, 39.948, 39.098, 40.078, 44.956, 47.867, 50.942, 51.996, 54.938, 55.845, 58.933, 58.693, 6.46, 65.38, 69.723, 72.63, 74.922, 78.971, 79.904, 83.798, 85.468, 87.62, 88.906, 91.224, 92.906, 95.95, 97., 01.07, 102.906, 106.42, 107.868, 112.414, 114.818, 118.71, 121.76, 127.6, 126.904, 131.293, 132.905, 137.27, 138.905, 140.116, 140.908, 144.242, 145. , 150.36, 151.964, 157.25, 158.925, 162.5, 164.93, 167.259, 18.934, 173.045, 174.967, 178.49, 180.948, 183.84, 186.207, 190.23, 192.217, 195.084, 196.967, 200.592, 24.38, 207.2, 208.98, 209., 210., 222., 223., 226., 227., 232.038, 231.036, 238.029, 237., 244., 243., 247., 247., 251., 252., 257., 258., 259., 262., 267., 270., 269., 270., 270., 278., 281., 281., 285., 286., 289., 289., 293., 293., 294.]  # this belongs in utils! (FH)\n                    el_abu_pin=atomic_mass\n                    el_abu_plot=np.zeros(len(el_abu))\n                    for i in range(len(el_abu)):\n                        el_abu_plot[i-1]=el_abu[i-1]/el_abu_pin[i-1]\n\n                elif ref==-2:\n                    print('using solar pin')\n                    el_abu_pin=np.zeros(len(el_abu))\n                    for i in range(len(el_abu)):\n                        el_abu_pin[i-1]=el_abu[i-1]/el_abu_sun[i-1]\n                elif ref>=0:\n                    print(\"Error: A reference file or manual pin is required - the plot will fail\")\n                '''elif ref>=0:\n                    print('using ref pin')\n                    el_abu_pin=np.zeros(len(el_abu))\n                    for i in range(len(el_abu)):nacon\n                        el_abu_pin[i-1]=el_abu[i-1]/el_abu_ref[i-1]\n                    print(el_abu)\n                    print(el_abu_ref)\n                    print(el_abu_pin)\n                    print(el_abu_plot)'''\n\n            # calculating the offset value\n                zelidx=where(z_el[zmin_ind:zmax_ind]==z_pin)[0][0]\n                offset=np.log10(el_abu_pin[zelidx])-np.log10(el_abu_plot[zelidx])\n\n            if ref!=-1 and dilution==None:\n                el_abu=el_abu_plot\n\n            if dilution!=None:\n\n                self.get(0,decayed=True)\n                z_el_ini=unique(self.z_iso_to_plot)\n                zmin_ind=min(where(z_el>=zrange[0])[0])\n                zmax_ind=max(where(z_el<=zrange[1])[0])\n                # extract some elemental quantities:\n                a_el_ini=[]; el_name_ini=[]; el_abu_ini=[]; el_abu_hash_ini={}\n                for z in z_el_ini:\n                    el_ini=self.el_iso_to_plot[where(self.z_iso_to_plot==z)[0].tolist()[0]]\n                    X_el_ini=self.abunds[where(self.el_iso_to_plot==el_ini)[0].tolist()].sum()  # take all iso abunds for one Z and sum\n                    a_el_ini.append(self.a_iso_to_plot[where(self.z_iso_to_plot==z)[0].tolist()[0]])\n                    el_abu_ini.append(X_el_ini)\n                    el_name_ini.append(el_ini)\n                    el_abu_hash_ini[el]=X_el_ini\n\n                el_abu_dilution=[]\n                for i in range(len(el_abu)):\n                    el_adjusted=(dilution*el_abu[i])+((1-dilution)*el_abu_ini[zmin_ind+i])\n                    fe_adjusted=(dilution*fe_abund)+((1-dilution)*el_abu_ini[24])\n                    num=el_adjusted*el_abu_sun[25]\n                    iadd = 1\n                    if z_el[zmin_ind+i] > 43:\n                        iadd = 2\n                    if z_el[zmin_ind+i] > 61:\n                        iadd = 3\n                    denom=fe_adjusted*el_abu_sun[zmin_ind+iadd+i]\n                    el_abu_dilution.append(num/denom)\n                #print(el_abu_dilution)\n                el_abu=el_abu_dilution\n\n            # plot an elemental abundance distribution with labels:\n            self.el_abu_log = np.log10(el_abu)\n            chi2 = 0.\n            if pin_filename!=None:                                   # plotting the observation data\n                # using zip() to plot multiple values for a single element\n                # also calculate and return chi squared\n                for xi,yi,wi  in zip(z_el[zmin_ind:zmax_ind],el_abu_obs_log,xfe_sigma):\n                    #print(xi)\n                    pl.scatter([xi]*len(yi),yi,marker='o',s=25,color='black')\n                    if all(wi)!=None:\n                        pl.errorbar([xi]*len(yi),yi,wi,color='black',capsize=5)\n                        if zchi2 != None:\n                            #if zchi2[0] <= xi and xi <= zchi2[1]:\n                            if xi in zchi2:\n                                zelidx=where(z_el[zmin_ind:zmax_ind]==xi)[0][0]\n                                chi2 += (((sum(yi)/len(yi)) - (np.log10(el_abu[zelidx])+offset))/\\\n                                        (sum(wi)/len(wi)))**2\n                #pl.scatter(z_el[zmin_ind:zmax_ind],z_ul,label='Upper limits',marker='v',color='black')\n                pl.scatter(z_el[zmin_ind:zmax_ind],z_ul,marker='v',color='black')\n                # plotting simulation data\n            pl.plot(z_el[zmin_ind:zmax_ind],np.log10(el_abu)+offset,label=label,\\\n                   linestyle=plotlines,color=colour,marker=mark)#,np.log10(el_abu))#,**kwargs)\n            j=0        # add labels\n            if plotlabels==True:\n                for z in z_el[zmin_ind:zmax_ind]:\n                    pl.text(z+0.15,log10(el_abu[j])+offset+0.05,el_name[j])\n                    j += 1\n            if title_items is not None:\n                pl.title(self._do_title_string(title_items,cycle))\n            if ylim[0]==0 and ylim[1]==0:\n                ylim[0]=max(-15.0,min(np.log10(el_abu)+offset))\n                ylim[1]=max(ylim[0]+1.0,max(np.log10(el_abu)+offset))\n            pl.ylim(ylim[0],ylim[1])\n            pl.xlabel('Z')\n            #pl.legend()\n            pl.grid(True)\n            ylab=['log X/X$_{'+str(ref)+'}$','log mass fraction','log X/X$_{ref}$','log$\\epsilon$']\n            if ref==-2:\n                pl.ylabel(ylab[2])\n            elif ref>-1:\n                if plotlabels==True:\n                    pl.annotate('Offset: '+str(offset),xy=(0.05,0.95),xycoords='axes fraction')\n                pl.ylabel(ylab[0])\n            elif logeps==True:\n                pl.ylabel(ylab[3])\n            else:\n                pl.ylabel(ylab[1])\n            return chi2\n        elif plotType=='se':\n            # get self.***_iso_to_plot by calling iso_abund function, which writes them\n            self.iso_abund(cycle,elemaburtn=True,**kwargs)\n            z_el=unique(self.se.Z)\n            zmin_ind=min(where(z_el>=zrange[0])[0])\n            zmax_ind=max(where(z_el<=zrange[1])[0])\n            # extract some elemental quantities:\n            a_el=[]; el_name=[]; el_abu=[]; el_abu_hash={}\n            for z in z_el[zmin_ind:zmax_ind]:\n                el=self.el_iso_to_plot[where(self.se.Z==z)[0].tolist()[0]]\n                X_el=self.abunds[where(self.el_iso_to_plot==el)[0].tolist()].sum()\n                a_el.append(self.a_iso_to_plot[where(self.z_iso_to_plot==z)[0].tolist()[0]])\n                el_abu.append(X_el)\n                el_name.append(el)\n                el_abu_hash[el]=X_el\n            # plot an elemental abundance distribution with labels:\n            if ref==0:\n                el_abu_plot=el_abu\n                ylab='log mass fraction'\n            elif ref==1:\n                from . import utils\n                if ref_filename=='':\n                    raise IOError('You chose to plot relative to the solar abundance dist. However, you did not supply the solar abundance file!')\n                else:\n                    nuutils.solar(ref_filename,1)\n                    menow = where(unique(nuutils.z_sol)==44.)[0][0]\n                    print(1, menow, nuutils.solar_elem_abund[menow])\n                    el_abu_sun=np.array(nuutils.solar_elem_abund)\n                    print(2, el_abu_sun)\n                    print(3, el_abu_sun[42])\n                    el_abu_plot=np.zeros(len(el_abu))\n                    for zs in z_el[zmin_ind:zmax_ind]:\n                        zelidx=where(z_el[zmin_ind:zmax_ind]==zs)[0]\n                        zsolidx=zs-1\n                        if el_abu_sun[zsolidx] > 0. :\n                            el_abu_plot[zelidx]=old_div(el_abu[zelidx],el_abu_sun[zsolidx])\n                        else:\n                            el_abu_plot[zelidx]=-1\n\n                    ylab='log X/X$_\\odot$'\n            else:\n                raise IOError('Your choice of ref is not available yet. Please use another.')\n            if label != '':\n                if colour!='':\n                    print(\"Plotting without color and label:\")\n                    pl.plot(z_el[zmin_ind:zmax_ind],np.log10(el_abu_plot),\n                            'o-',label=label,color=colour,markeredgecolor='None')\n                else:\n                    pl.plot(z_el[zmin_ind:zmax_ind],np.log10(el_abu_plot)\n                            ,'o-',label=label,markeredgecolor='None')\n            else:\n                if colour!='':\n                    pl.plot(z_el[zmin_ind:zmax_ind],np.log10(el_abu_plot),\n                            'o-',color=colour,markeredgecolor='None')\n                else:\n                    pl.plot(z_el[zmin_ind:zmax_ind],np.log10(el_abu_plot),\n                            'o-',markeredgecolor='None')\n            if show_names:\n                j=0        # add labels\n                for z in z_el[zmin_ind:zmax_ind]:\n#                    pl.text(z+0.15,log10(el_abu_plot[j])+0.05,el_name[j])\n                    if el_abu_plot[j] > 0.:\n                        pl.text(z,log10(el_abu_plot[j])+0.5,el_name[j],\n                            horizontalalignment='center')\n                    j += 1\n            if title_items is not None:\n                pl.title(self._do_title_string(title_items,cycle))\n            if ylim[0]==0 and ylim[1]==0:\n                ylim[0]=max(-15.0,min(np.log10(el_abu_plot)))\n                ylim[1]=max(ylim[0]+1.0,max(np.log10(el_abu_plot)))\n            pl.ylim(ylim[0],ylim[1])\n            pl.xlabel('Z')\n            pl.ylabel(ylab)\n            if label != '':\n                pl.legend(loc='best').draw_frame(False)\n            return z_el[zmin_ind:zmax_ind],el_abu_plot\n        else:\n            print('This method is not supported for '+plotType)\n            return\n\n        self.el_abu_hash = el_abu_hash\n        self.el_name = el_name\n        self.el_abu_log = np.log10(el_abu)", "response": "This method plots the decayed elemental abundance distribution for a specific cycle."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _do_title_string(self,title_items,cycle):\n        '''\n        Create title string\n\n        Private method that creates a title string for a cycle plot\n        out of a list of title_items that are cycle attributes and can\n        be obtained with self.get\n\n        Parameters\n        ----------\n        title_items : list\n            A list of cycle attributes.\n        cycle : scalar\n            The cycle for which the title string should be created.\n\n        Returns\n        -------\n        title_string: string\n            Title string that can be used to decorate plot.\n\n        '''\n\n        title_string=[]\n        form_str='%4.1F'\n\n        for item in title_items:\n            num=self.get(item,fname=cycle)\n            if num > 999 or num < 0.1:\n                num=log10(num)\n                prefix='log '\n            else:\n                prefix=''\n            title_string.append(prefix+item+'='+form_str%num)\n        tt=''\n        for thing in title_string:\n            tt = tt+thing+\", \"\n        return tt.rstrip(', ')", "response": "Private method that creates a title string for a cycle plot."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef plotprofMulti(self, ini, end, delta, what_specie, xlim1, xlim2,\n                      ylim1, ylim2, symbol=None):\n\n        '''\n        create a movie with mass fractions vs mass coordinate between\n        xlim1 and xlim2, ylim1 and ylim2. Only works with instances of\n        se.\n\n        Parameters\n        ----------\n        ini : integer\n            Initial model i.e. cycle.\n        end : integer\n            Final model i.e. cycle.\n        delta : integer\n            Sparsity factor of the frames.\n        what_specie : list\n            Array with species in the plot.\n        xlim1, xlim2 : integer or float\n            Mass coordinate range.\n        ylim1, ylim2 : integer or float\n            Mass fraction coordinate range.\n        symbol : list, optional\n            Array indicating which symbol you want to use. Must be of\n            the same len of what_specie array.  The default is None.\n\n        '''\n        plotType=self._classTest()\n        if plotType=='se':\n            for i in range(ini,end+1,delta):\n                step = int(i)\n                #print step\n                if symbol==None:\n                    symbol_dummy = '-'\n                    for j in range(len(what_specie)):\n                        self.plot_prof_1(step,what_specie[j],xlim1,xlim2,ylim1,ylim2,symbol_dummy)\n                else:\n                    for j in range(len(what_specie)):\n                        symbol_dummy = symbol[j]\n                        self.plot_prof_1(step,what_specie[j],xlim1,xlim2,ylim1,ylim2,symbol_dummy)\n\n                #\n                filename = str('%03d' % step)+'_test.png'\n                pl.savefig(filename, dpi=400)\n                print('wrote file ', filename)\n                #\n                pl.clf()\n\n        else:\n            print('This method is not supported for '+str(self.__class__))\n            return", "response": "This method creates a movie with mass fractions vs mass coordinate between xlim1 and xlim2 and ylim1 and ylim2."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef movie(self, cycles, plotstyle='',movname='',fps=12,**kwargs):\n        from matplotlib import animation\n        '''\n            Make an interactive movie in the matplotlib window for a number of\n            different plot types:\n\n            Plot types\n            ----------\n            'iso_abund' : abundance distribution a la se.iso_abund()\n            'abu_chart' : abundance chart a la se.abu_chart()\n            'plot'      : plot any number of y_items against an x_item\n\n            Parameters\n            ----------\n            cycles : list\n                Which cycles do you want to plot as movie frames?\n            plotstyle : string\n                What type of plot should the movie show? Currently supported is\n                'iso_abund', 'abu_chart' and 'plot'\n            movname : string, optional\n                Name of movie (+ extension, e.g. .mp4 or .avi) if the movie is\n                to be saved\n                The default is ''\n            args : list\n                Arguments to should be passed to the plotting function. These are\n                the arguments of the respective methods that make the frames. See\n                the docstrings of those functions for details\n\n            'plot' Parameters\n            -----------------\n            'xlims'    : tuple, optional\n            'ylims'    : tuple, optional\n            'xlabel'   : string, optional\n            'ylabel'   : string, optional\n            'legend'   : boolean, optional\n                The default is False\n            'loc'      : string or integer, optional\n                Set the legend location if legend is True.\n                The default is 'best'\n            'interval' : frame interval in ms\n\n            FAQ:\n            ----\n            If ffmpeg is not installed on OSX (and you don't want to wait for port to do it) check out\n            these binaries:\n            http://stackoverflow.com/questions/18833731/how-to-set-ffmpeg-for-matplotlib-in-mac-os-x\n\n            '''\n\n        modelself=self\n        supported_styles=['iso_abund','abu_chart','plot']\n        class mov(object):\n\n            def __init__(self,cyc,style,movname,fps,**kwargs):\n                self.fig = None\n                self.ax = None\n                self.ani = None\n                self.cyc = cyc\n                self.movname=movname\n                self.fps = fps\n                self.style=style\n                if self.style in supported_styles:\n                    animateFunc=draw_frame\n                else:\n                    raise IOError(\"this type of movie is not available yet! Sorry!\")\n                if self.style=='plot':\n                    self.y_ditems=kwargs['y_items']\n                    self.data=kwargs['data']\n                self._init_animation(animateFunc)\n\n            def _init_animation(self, animateFunc):\n                if self.style=='plot':\n                    fsize=14\n                    params = {'axes.labelsize':  fsize,\n                        'text.fontsize':   fsize,\n                        'legend.fontsize': fsize*0.8,\n                        'xtick.labelsize': fsize,\n                        'ytick.labelsize': fsize,\n                        'text.usetex': False,\n                        'figure.facecolor': 'white',\n                        'ytick.minor.pad': 8,\n                        'ytick.major.pad': 8,\n                        'xtick.minor.pad': 8,\n                        'xtick.major.pad': 8,\n                        'figure.subplot.bottom' : 0.15,\n                        'lines.markersize': 8}\n                    matplotlib.rcParams.update(params)\n\n                    self.fig, self.ax = pl.subplots()\n                    tmp=[]\n                    for i in range(len(self.y_ditems)):\n                        tmp.append(self.data[0][0])\n                        tmp.append(self.data[0][i+1])\n                    self.lines = self.ax.plot(*tmp)\n                    if 'ylims' in kwargs:\n                        pl.ylim(kwargs['ylims'])\n                    if 'xlims' in kwargs:\n                        pl.xlim(kwargs['xlims'])\n                    if 'xlabel' in kwargs:\n                        pl.xlabel(kwargs['xlabel'])\n                    else:\n                        pl.xlabel(kwargs['x_item'])\n                    if 'ylabel' in kwargs:\n                        pl.ylabel(kwargs['ylabel'])\n                    else:\n                        if type(y_items) is str:\n                            lab=y_items\n                        elif type(y_items) is list and len(y_items) == 1:\n                            lab=y_items[0]\n                        else:\n                            lab=''\n                            for el in kwargs['y_items']:\n                                lab+=el+', '\n                            lab=lab[:-2]\n                        pl.ylabel(lab)\n                    if 'legend' in kwargs and kwargs['legend']:\n                        if 'loc' in kwargs:\n                            pl.legend([line for line in self.lines], self.y_ditems,\n                                      loc=kwargs['loc']).draw_frame(False)\n                        else:\n                            pl.legend([line for line in self.lines], self.y_ditems,\n                                      loc='best').draw_frame(False)\n\n                self._animation(animateFunc)\n\n            def _animation(self, animateFunc):\n                if plotstyle=='plot' and 'interval' in kwargs:\n                    self.ani = animation.FuncAnimation(self.fig, animateFunc, arange(0, len(self.cyc)), interval=kwargs['interval'], blit=False, fargs=[self])\n                elif plotstyle=='iso_abund':\n                    self.fig, self.ax = pl.subplots()\n                    ims=[]\n                    for i in arange(0,len(self.cyc)):\n                        im=draw_frame(i,self)\n                        ims.append(im)\n                    self.ani = animation.ArtistAnimation(self.fig,ims,interval=50,\n                                                             blit=False)\n                    self.fig.canvas.draw()\n                elif plotstyle=='abu_chart':\n                    self.fig=pl.figure()\n                    axx = 0.10\n                    axy = 0.10\n                    axw = 0.85\n                    axh = 0.8\n                    self.ax=pl.axes([axx,axy,axw,axh])\n                    ims=[]\n                    for i in arange(0,len(self.cyc)):\n                        im=draw_frame(i,self)\n                        # draw_frame here returns the patch for the abundance squares\n                        # im[0] as well as the artists im[1], so that the colorbar\n                        # can be plotted only once (on the first plot)\n                        ims.append(im[1])\n                        if i==0:\n                            cb=pl.colorbar(im[0])\n                            cb.set_label('log$_{10}$(X)',fontsize='x-large')\n                    self.ani = animation.ArtistAnimation(self.fig,ims,interval=50,\n                                                         blit=False)\n                    self.fig.canvas.draw()\n\n                if self.movname is not '':\n                    print('\\n generating animation: '+self.movname)\n                    self.ani.save(self.movname,fps=self.fps)\n                    print('animation '+self.movname+' saved with '+str(self.fps)+' frames per second')\n\n        plotType=self._classTest()\n\n        if plotType=='se':\n            if plotstyle == 'iso_abund':\n                data = self.se.get(cycles,['iso_massf','mass'])\n                def draw_frame(i,self=None):\n                    artists=modelself.iso_abund(self.cyc[i],stable=True,show=False,\n                                             data_provided=True,thedata=data[i],\n                                             verbose=False,drawfig=self.fig,drawax=self.ax,\n                                             mov=True,**kwargs)\n                    return artists\n            if plotstyle == 'abu_chart':\n                data = self.se.get(cycles,['iso_massf','mass'])\n                def draw_frame(i,self=None):\n                    artists=modelself.abu_chart(self.cyc[i],show=False,data_provided=True,\n                                        thedata=data[i],lbound=(-12, -6),drawfig=self.fig,\n                                        drawax=self.ax,mov=True,**kwargs)\n                    return artists\n            if plotstyle=='plot':\n                if 'x_item' not in kwargs or 'y_items' not in kwargs:\n                    raise IOError(\"Please specify both x_item and y_items\")\n                x_item = kwargs['x_item']\n                y_items = kwargs['y_items']\n                tx, ty = type(x_item), type(y_items)\n                if tx is list and ty is list:\n                    data=self.se.get(cycles,x_item+y_items)\n                elif tx is str and ty is list:\n                    data=self.se.get(cycles,[x_item]+y_items)\n                elif tx is str and ty is str:\n                    data=self.se.get(cycles,[x_item]+[y_items])\n                def draw_frame(i, self=None):\n#                    pl.title(\"cycle: \" + self.cyc[i])\n                    for j in range(len(self.lines)):\n                        if 'logy' in kwargs and kwargs['logy']:\n                            self.lines[j].set_data(self.data[i][0],\n                                                   np.log10(self.data[i][j+1]))\n                        else:\n                            self.lines[j].set_data(self.data[i][0],\n                                                   self.data[i][j+1])\n                    return  self.lines\n\n        if plotstyle=='plot':\n            return mov(cycles,plotstyle,movname,fps,data=data,**kwargs).ani\n        else:\n            return mov(cycles,plotstyle,movname,fps).ani", "response": "Function that creates an interactive movie with the given number of cycles and a specific plot type."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nplot one species for cycle between xlim1 and xlim2", "response": "def plot_prof_1(self, species, keystring, xlim1, xlim2, ylim1,\n                    ylim2, symbol=None, show=False):\n        '''\n        Plot one species for cycle between xlim1 and xlim2 Only works\n        with instances of se and mesa _profile.\n\n        Parameters\n        ----------\n        species : list\n            Which species to plot.\n        keystring : string or integer\n            Label that appears in the plot or in the case of se, a\n            cycle.\n        xlim1, xlim2 : integer or float\n            Mass coordinate range.\n        ylim1, ylim2 : integer or float\n            Mass fraction coordinate range.\n        symbol : string, optional\n            Which symbol you want to use.  If None symbol is set to '-'.\n            The default is None.\n        show : boolean, optional\n            Show the ploted graph.  The default is False.\n\n        '''\n        plotType=self._classTest()\n        if plotType=='se':\n            #tot_mass=self.se.get(keystring,'total_mass')\n            tot_mass=self.se.get('mini')\n            age=self.se.get(keystring,'age')\n            mass=self.se.get(keystring,'mass')\n            Xspecies=self.se.get(keystring,'iso_massf',species)\n\n            mod=keystring\n        elif plotType=='mesa_profile':\n            tot_mass=self.header_attr['star_mass']\n            age=self.header_attr['star_age']\n            mass=self.get('mass')\n            mod=self.header_attr['model_number']\n            Xspecies=self.get(species)\n        else:\n            print('This method is not supported for '+str(self.__class__))\n            return\n\n        if symbol == None:\n            symbol = '-'\n\n        x,y=self._logarithm(Xspecies,mass,True,False,10)\n        #print x\n        pl.plot(y,x,symbol,label=str(species))\n        pl.xlim(xlim1,xlim2)\n        pl.ylim(ylim1,ylim2)\n        pl.legend()\n\n        pl.xlabel('$Mass$ $coordinate$', fontsize=20)\n        pl.ylabel('$X_{i}$', fontsize=20)\n        #pl.title('Mass='+str(tot_mass)+', Time='+str(age)+' years, cycle='+str(mod))\n        pl.title('Mass='+str(tot_mass)+', cycle='+str(mod))\n        if show:\n            pl.show()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef density_profile(self,ixaxis='mass',ifig=None,colour=None,label=None,fname=None):\n        '''\n        Plot density as a function of either mass coordiate or radius.\n\n        Parameters\n        ----------\n        ixaxis : string\n            'mass' or 'radius'\n            The default value is 'mass'\n        ifig : integer or string\n            The figure label\n            The default value is None\n        colour : string\n            What colour the line should be\n            The default value is None\n        label : string\n            Label for the line\n            The default value is None\n        fname : integer\n            What cycle to plot from (if SE output)\n            The default value is None\n        '''\n\n        pT=self._classTest()\n\n        # Class-specific things:\n        if pT is 'mesa_profile':\n            x = self.get(ixaxis)\n            if ixaxis is 'radius':\n                x = x*ast.rsun_cm\n            y = self.get('logRho')\n        elif pT is 'se':\n            if fname is None:\n                raise IOError(\"Please provide the cycle number fname\")\n            x = self.se.get(fname,ixaxis)\n            y = np.log10(self.se.get(fname,'rho'))\n        else:\n            raise IOError(\"Sorry. the density_profile method is not available \\\n                          for this class\")\n\n        # Plot-specific things:\n        if ixaxis is 'radius':\n            x = np.log10(x)\n            xlab='$\\log_{10}(r\\,/\\,{\\\\rm cm})$'\n        else:\n            xlab='${\\\\rm Mass}\\,/\\,M_\\odot$'\n\n        if ifig is not None:\n            pl.figure(ifig)\n        if label is not None:\n            if colour is not None:\n                pl.plot(x,y,color=colour,label=label)\n            else:\n                pl.plot(x,y,label=label)\n            pl.legend(loc='best').draw_frame(False)\n        else:\n            if colour is not None:\n                pl.plot(x,y,color=colour)\n            else:\n                pl.plot(x,y)\n\n        pl.xlabel(xlab)\n        pl.ylabel('$\\log_{10}(\\\\rho\\,/\\,{\\\\rm g\\,cm}^{-3})$')", "response": "Plot density as a function of either mass coordiate or radius."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nplots common abundances as a function of either mass coordiate or radius.", "response": "def abu_profile(self,ixaxis='mass',isos=None,ifig=None,fname=None,logy=False,\n                    colourblind=False):\n        '''\n        Plot common abundances as a function of either mass coordiate or radius.\n\n        Parameters\n        ----------\n        ixaxis : string, optional\n            'mass',  'logradius' or 'radius'\n            The default value is 'mass'\n        isos : list, optional\n            list of isos to plot, i.e. ['h1','he4','c12'] for MESA or\n            ['H-1','He-4','C-12'] for SE output. If None, the code decides\n            itself what to plot.\n            The default is None.\n        ifig : integer or string, optional\n            The figure label\n            The default value is None\n        fname : integer, optional\n            What cycle to plot from (if SE output)\n            The default value is None\n        logy : boolean, optional\n            Should y-axis be logarithmic?\n            The default value is False\n        colourblind : boolean, optional\n            do you want to use the colourblind colour palette from the NuGrid\n            nuutils module?\n        '''\n\n        pT=self._classTest()\n        # Class-specific things:\n        if pT is 'mesa_profile':\n            x = self.get(ixaxis)\n            if ixaxis is 'radius':\n                x = x*ast.rsun_cm\n            if isos is None:\n                isos=['h1','he4','c12','c13','n14','o16','ne20','ne22','mg24','mg25',\n                      'al26','si28','si30','s32','s34','cl35','ar36','ar38','cr52',\n                      'cr56','fe56','ni56']\n            risos=[i for i in isos if i in self.cols]\n            abunds = [self.get(riso) for riso in risos]\n            names=risos\n        elif pT is 'se':\n            if fname is None:\n                raise IOError(\"Please provide the cycle number fname\")\n            x = self.se.get(fname,ixaxis)\n            if isos is None:\n                isos=['H-1','He-4','C-12','C-13','N-14','O-16','Ne-20','Ne-22','Mg-24','Mg-25',\n                      'Sl-26','Si-28','Si-30','S-32','S-34','Cl-35','Ar-36','Ar-38','Cr-52',\n                      'Cr-56','Fe-56','Ni-56']\n            risos=[i for i in isos if i in self.se.isotopes]\n            abunds = self.se.get(fname,'iso_massf',risos)\n            names=risos\n        else:\n            raise IOError(\"Sorry. the density_profile method is not available \\\n                          for this class\")\n\n        # Plot-specific things:\n        if ixaxis is 'logradius':\n            x = np.log10(x)\n            xlab='$\\log_{10}(r\\,/\\,{\\\\rm cm})$'\n        elif ixaxis is 'radius':\n            x = old_div(x, 1.e8)\n            xlab = 'r / Mm'\n        else:\n            xlab='${\\\\rm Mass}\\,/\\,M_\\odot$'\n\n        if ifig is not None:\n            pl.figure(ifig)\n        from . import utils as u\n        cb = u.colourblind\n        lscb = u.linestylecb # colourblind linestyle function\n        for i in range(len(risos)):\n            if logy:\n                y = np.log10(abunds if len(risos) < 2 else abunds[i])\n            else:\n                y = abunds if len(risos) < 2 else abunds[i]\n            if colourblind:\n                pl.plot(x,y,ls=lscb(i)[0],marker=lscb(i)[1],\n                        color=lscb(i)[2],markevery=u.linestyle(i)[1]*20,\n                        label=names[i],mec='None')\n            else:\n                pl.plot(x,y,u.linestyle(i)[0],markevery=u.linestyle(i)[1]*20,\n                        label=names[i],mec='None')\n\n        pl.legend(loc='best').draw_frame(False)\n        pl.xlabel(xlab)\n        pl.ylabel('$\\log(X)$')"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngiving the identity return a HPESystem object", "response": "def get_system(self, identity):\n        \"\"\"Given the identity return a HPESystem object\n\n        :param identity: The identity of the System resource\n        :returns: The System object\n        \"\"\"\n        return system.HPESystem(self._conn, identity,\n                                redfish_version=self.redfish_version)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngiving the identity return a HPEManager object", "response": "def get_manager(self, identity):\n        \"\"\"Given the identity return a HPEManager object\n\n        :param identity: The identity of the Manager resource\n        :returns: The Manager object\n        \"\"\"\n        return manager.HPEManager(self._conn, identity,\n                                  redfish_version=self.redfish_version)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a HPEUpdateService object containing the current object s related attributes", "response": "def get_update_service(self):\n        \"\"\"Return a HPEUpdateService object\n\n        :returns: The UpdateService object\n        \"\"\"\n        update_service_url = utils.get_subresource_path_by(self,\n                                                           'UpdateService')\n        return (update_service.\n                HPEUpdateService(self._conn, update_service_url,\n                                 redfish_version=self.redfish_version))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_account_service(self):\n        account_service_url = utils.get_subresource_path_by(self,\n                                                            'AccountService')\n\n        return (account_service.\n                HPEAccountService(self._conn, account_service_url,\n                                  redfish_version=self.redfish_version))", "response": "Return a HPEAccountService object"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nexecuting the SUM based firmware update command.", "response": "def _execute_sum(sum_file_path, mount_point, components=None):\n    \"\"\"Executes the SUM based firmware update command.\n\n    This method executes the SUM based firmware update command to update the\n    components specified, if not, it performs update on all the firmware\n    components on th server.\n\n    :param sum_file_path: A string with the path to the SUM binary to be\n        executed\n    :param components: A list of components to be updated. If it is None, all\n        the firmware components are updated.\n    :param mount_point: Location in which SPP iso is mounted.\n    :returns: A string with the statistics of the updated/failed components.\n    :raises: SUMOperationError, when the SUM based firmware update operation\n        on the node fails.\n    \"\"\"\n    cmd = ' --c ' + ' --c '.join(components) if components else ''\n\n    try:\n        if SUM_LOCATION in sum_file_path:\n            location = os.path.join(mount_point, 'packages')\n\n            # NOTE: 'launch_sum.sh' binary is part of SPP ISO and it is\n            # available in the SPP mount point (eg:'/mount/launch_sum.sh').\n            # 'launch_sum.sh' binary calls the 'smartupdate' binary by passing\n            # the arguments.\n            processutils.execute('./launch_sum.sh', '--s', '--romonly',\n                                 '--use_location', location, cmd,\n                                 cwd=mount_point)\n        else:\n            processutils.execute(sum_file_path, '--s', '--romonly', cmd)\n    except processutils.ProcessExecutionError as e:\n        result = _parse_sum_ouput(e.exit_code)\n        if result:\n            return result\n        else:\n            raise exception.SUMOperationError(reason=str(e))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _get_log_file_data_as_encoded_content():\n    with io.BytesIO() as fp:\n        with tarfile.open(fileobj=fp, mode='w:gz') as tar:\n            for f in OUTPUT_FILES:\n                if os.path.isfile(f):\n                    tar.add(f)\n\n        fp.seek(0)\n        return base64.encode_as_bytes(fp.getvalue())", "response": "This method gets the log files created by SUM based\n    firmware update and tar zip the files and BytesIO buffers."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nparse the SUM output log file. This method parses through the SUM log file in the default location to return the SUM update status. Sample return string: \"Summary: The installation of the component failed. Status of updated components: Total: 5 Success: 4 Failed: 1\" :param exit_code: A integer returned by the SUM after command execution. :returns: A string with the statistics of the updated/failed components and 'None' when the exit_code is not 0, 1, 3 or 253.", "response": "def _parse_sum_ouput(exit_code):\n    \"\"\"Parse the SUM output log file.\n\n    This method parses through the SUM log file in the\n    default location to return the SUM update status. Sample return\n    string:\n\n    \"Summary: The installation of the component failed. Status of updated\n     components: Total: 5 Success: 4 Failed: 1\"\n\n    :param exit_code: A integer returned by the SUM after command execution.\n    :returns: A string with the statistics of the updated/failed\n        components and 'None' when the exit_code is not 0, 1, 3 or 253.\n    \"\"\"\n    if exit_code == 3:\n        return \"Summary: %s\" % EXIT_CODE_TO_STRING.get(exit_code)\n\n    if exit_code in (0, 1, 253):\n        if os.path.exists(OUTPUT_FILES[0]):\n            with open(OUTPUT_FILES[0], 'r') as f:\n                output_data = f.read()\n\n            ret_data = output_data[(output_data.find('Deployed Components:') +\n                                    len('Deployed Components:')):\n                                   output_data.find('Exit status:')]\n\n            failed = 0\n            success = 0\n            for line in re.split('\\n\\n', ret_data):\n                if line:\n                    if 'Success' not in line:\n                        failed += 1\n                    else:\n                        success += 1\n\n            return {\n                'Summary': (\n                    \"%(return_string)s Status of updated components: Total: \"\n                    \"%(total)s Success: %(success)s Failed: %(failed)s.\" %\n                    {'return_string': EXIT_CODE_TO_STRING.get(exit_code),\n                     'total': (success + failed), 'success': success,\n                     'failed': failed}),\n                'Log Data': _get_log_file_data_as_encoded_content()\n            }\n\n        return \"UPDATE STATUS: UNKNOWN\""}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef update_firmware(node):\n    sum_update_iso = node['clean_step']['args'].get('url')\n\n    # Validates the http image reference for SUM update ISO.\n    try:\n        utils.validate_href(sum_update_iso)\n    except exception.ImageRefValidationFailed as e:\n        raise exception.SUMOperationError(reason=e)\n\n    # Ejects the CDROM device in the iLO and inserts the SUM update ISO\n    # to the CDROM device.\n    info = node.get('driver_info')\n    ilo_object = client.IloClient(info.get('ilo_address'),\n                                  info.get('ilo_username'),\n                                  info.get('ilo_password'))\n\n    ilo_object.eject_virtual_media('CDROM')\n    ilo_object.insert_virtual_media(sum_update_iso, 'CDROM')\n\n    # Waits for the OS to detect the disk and update the label file. SPP ISO\n    # is identified by matching its label.\n    time.sleep(WAIT_TIME_DISK_LABEL_TO_BE_VISIBLE)\n    vmedia_device_dir = \"/dev/disk/by-label/\"\n    for file in os.listdir(vmedia_device_dir):\n        if fnmatch.fnmatch(file, 'SPP*'):\n            vmedia_device_file = os.path.join(vmedia_device_dir, file)\n\n    if not os.path.exists(vmedia_device_file):\n        msg = \"Unable to find the virtual media device for SUM\"\n        raise exception.SUMOperationError(reason=msg)\n\n    # Validates the SPP ISO image for any file corruption using the checksum\n    # of the ISO file.\n    expected_checksum = node['clean_step']['args'].get('checksum')\n    try:\n        utils.verify_image_checksum(vmedia_device_file, expected_checksum)\n    except exception.ImageRefValidationFailed as e:\n        raise exception.SUMOperationError(reason=e)\n\n    # Mounts SPP ISO on a temporary directory.\n    vmedia_mount_point = tempfile.mkdtemp()\n    try:\n        try:\n            processutils.execute(\"mount\", vmedia_device_file,\n                                 vmedia_mount_point)\n        except processutils.ProcessExecutionError as e:\n            msg = (\"Unable to mount virtual media device %(device)s: \"\n                   \"%(error)s\" % {'device': vmedia_device_file, 'error': e})\n            raise exception.SUMOperationError(reason=msg)\n\n        # Executes the SUM based firmware update by passing the 'smartupdate'\n        # executable path if exists else 'hpsum' executable path and the\n        # components specified (if any).\n        sum_file_path = os.path.join(vmedia_mount_point, SUM_LOCATION)\n        if not os.path.exists(sum_file_path):\n            sum_file_path = os.path.join(vmedia_mount_point, HPSUM_LOCATION)\n\n        components = node['clean_step']['args'].get('components')\n        result = _execute_sum(sum_file_path, vmedia_mount_point,\n                              components=components)\n\n        processutils.trycmd(\"umount\", vmedia_mount_point)\n    finally:\n        shutil.rmtree(vmedia_mount_point, ignore_errors=True)\n\n    return result", "response": "This method updates the SPP image of the ISO and the label file of the SPP ISO."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a string with markup tags converted to ansi - escape sequences.", "response": "def parse(self, text):\n        '''Return a string with markup tags converted to ansi-escape sequences.'''\n        tags, results = [], []\n\n        text = self.re_tag.sub(lambda m: self.sub_tag(m, tags, results), text)\n\n        if self.strict and tags:\n            markup = \"%s%s%s\" % (self.tag_sep[0], tags.pop(0), self.tag_sep[1])\n            raise MismatchedTag('opening tag \"%s\" has no corresponding closing tag' % markup)\n\n        if self.always_reset:\n            if not text.endswith(Style.RESET_ALL):\n                text += Style.RESET_ALL\n\n        return text"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef ansiprint(self, *args, **kwargs):\n        '''Wrapper around builtins.print() that runs parse() on all arguments first.'''\n        args = (self.parse(str(i)) for i in args)\n        builtins.print(*args, **kwargs)", "response": "Wrapper around builtins. print that runs parse on all arguments first."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns string with markup tags removed.", "response": "def strip(self, text):\n        '''Return string with markup tags removed.'''\n        tags, results = [], []\n        return self.re_tag.sub(lambda m: self.clear_tag(m, tags, results), text)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a generator to list the shares under the specified account.", "response": "def list_shares(self, prefix=None, marker=None, num_results=None, \n                    include_metadata=False, timeout=None):\n        '''\n        Returns a generator to list the shares under the specified account.\n        The generator will lazily follow the continuation tokens returned by\n        the service and stop when all shares have been returned or num_results \n        is reached.\n\n        If num_results is specified and the account has more than that number of \n        shares, the generator will have a populated next_marker field once it \n        finishes. This marker can be used to create a new generator if more \n        results are desired.\n\n        :param str prefix:\n            Filters the results to return only shares whose names\n            begin with the specified prefix.\n        :param int num_results:\n            Specifies the maximum number of shares to return.\n        :param bool include_metadata:\n            Specifies that share metadata be returned in the response.\n        :param str marker:\n            An opaque continuation token. This value can be retrieved from the \n            next_marker field of a previous generator object if num_results was \n            specified and that generator has finished enumerating results. If \n            specified, this generator will begin returning results from the point \n            where the previous generator stopped.\n        :param int timeout:\n            The timeout parameter is expressed in seconds.\n        '''\n        include = 'metadata' if include_metadata else None\n        operation_context = _OperationContext(location_lock=True)\n        kwargs = {'prefix': prefix, 'marker': marker, 'max_results': num_results, \n                'include': include, 'timeout': timeout, '_context': operation_context}\n        resp = self._list_shares(**kwargs)\n\n        return ListGenerator(resp, self._list_shares, (), kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef list_directories_and_files(self, share_name, directory_name=None,\n                                   num_results=None, marker=None, timeout=None,\n                                   prefix=None):\n\n        '''\n        Returns a generator to list the directories and files under the specified share.\n        The generator will lazily follow the continuation tokens returned by\n        the service and stop when all directories and files have been returned or\n        num_results is reached.\n\n        If num_results is specified and the share has more than that number of \n        files and directories, the generator will have a populated next_marker \n        field once it finishes. This marker can be used to create a new generator \n        if more results are desired.\n\n        :param str share_name:\n            Name of existing share.\n        :param str directory_name:\n            The path to the directory.\n        :param int num_results:\n            Specifies the maximum number of files to return,\n            including all directory elements. If the request does not specify\n            num_results or specifies a value greater than 5,000, the server will\n            return up to 5,000 items. Setting num_results to a value less than\n            or equal to zero results in error response code 400 (Bad Request).\n        :param str marker:\n            An opaque continuation token. This value can be retrieved from the \n            next_marker field of a previous generator object if num_results was \n            specified and that generator has finished enumerating results. If \n            specified, this generator will begin returning results from the point \n            where the previous generator stopped.\n        :param int timeout:\n            The timeout parameter is expressed in seconds.\n        :param str prefix:\n            List only the files and/or directories with the given prefix.\n        '''\n        operation_context = _OperationContext(location_lock=True)\n        args = (share_name, directory_name)\n        kwargs = {'marker': marker, 'max_results': num_results, 'timeout': timeout,\n                  '_context': operation_context, 'prefix': prefix}\n\n        resp = self._list_directories_and_files(*args, **kwargs)\n\n        return ListGenerator(resp, self._list_directories_and_files, args, kwargs)", "response": "Returns a generator to list the directories and files under the specified share."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ndownloads a file from the specified share and directory.", "response": "def _get_file(self, share_name, directory_name, file_name,\n                 start_range=None, end_range=None, validate_content=False, \n                 timeout=None, _context=None):\n        '''\n        Downloads a file's content, metadata, and properties. You can specify a\n        range if you don't need to download the file in its entirety. If no range\n        is specified, the full file will be downloaded.\n\n        See get_file_to_* for high level functions that handle the download\n        of large files with automatic chunking and progress notifications.\n\n        :param str share_name:\n            Name of existing share.\n        :param str directory_name:\n            The path to the directory.\n        :param str file_name:\n            Name of existing file.\n        :param int start_range:\n            Start of byte range to use for downloading a section of the file.\n            If no end_range is given, all bytes after the start_range will be downloaded.\n            The start_range and end_range params are inclusive.\n            Ex: start_range=0, end_range=511 will download first 512 bytes of file.\n        :param int end_range:\n            End of byte range to use for downloading a section of the file.\n            If end_range is given, start_range must be provided.\n            The start_range and end_range params are inclusive.\n            Ex: start_range=0, end_range=511 will download first 512 bytes of file.\n        :param bool validate_content:\n            When this is set to True and specified together with the Range header, \n            the service returns the MD5 hash for the range, as long as the range \n            is less than or equal to 4 MB in size.\n        :param int timeout:\n            The timeout parameter is expressed in seconds.\n        :return: A File with content, properties, and metadata.\n        :rtype: :class:`~azure.storage.file.models.File`\n        '''\n        _validate_not_none('share_name', share_name)\n        _validate_not_none('file_name', file_name)\n        request = HTTPRequest()\n        request.method = 'GET'\n        request.host_locations = self._get_host_locations()\n        request.path = _get_path(share_name, directory_name, file_name)\n        request.query = { 'timeout': _int_to_str(timeout)}\n        _validate_and_format_range_headers(\n            request,\n            start_range,\n            end_range,\n            start_range_required=False,\n            end_range_required=False,\n            check_content_md5=validate_content)\n\n        return self._perform_request(request, _parse_file, \n                                     [file_name, validate_content],\n                                     operation_context=_context)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_file_to_path(self, share_name, directory_name, file_name, file_path,\n                         open_mode='wb', start_range=None, end_range=None,\n                         validate_content=False, progress_callback=None,\n                         max_connections=2, timeout=None):\n        '''\n        Downloads a file to a file path, with automatic chunking and progress\n        notifications. Returns an instance of File with properties and metadata.\n\n        :param str share_name:\n            Name of existing share.\n        :param str directory_name:\n            The path to the directory.\n        :param str file_name:\n            Name of existing file.\n        :param str file_path:\n            Path of file to write to.\n        :param str open_mode:\n            Mode to use when opening the file. Note that specifying append only \n            open_mode prevents parallel download. So, max_connections must be set \n            to 1 if this open_mode is used.\n        :param int start_range:\n            Start of byte range to use for downloading a section of the file.\n            If no end_range is given, all bytes after the start_range will be downloaded.\n            The start_range and end_range params are inclusive.\n            Ex: start_range=0, end_range=511 will download first 512 bytes of file.\n        :param int end_range:\n            End of byte range to use for downloading a section of the file.\n            If end_range is given, start_range must be provided.\n            The start_range and end_range params are inclusive.\n            Ex: start_range=0, end_range=511 will download first 512 bytes of file.\n        :param bool validate_content:\n            If set to true, validates an MD5 hash for each retrieved portion of \n            the file. This is primarily valuable for detecting bitflips on the wire \n            if using http instead of https as https (the default) will already \n            validate. Note that the service will only return transactional MD5s \n            for chunks 4MB or less so the first get request will be of size \n            self.MAX_CHUNK_GET_SIZE instead of self.MAX_SINGLE_GET_SIZE. If \n            self.MAX_CHUNK_GET_SIZE was set to greater than 4MB an error will be \n            thrown. As computing the MD5 takes processing time and more requests \n            will need to be done due to the reduced chunk size there may be some \n            increase in latency.\n        :param progress_callback:\n            Callback for progress with signature function(current, total) \n            where current is the number of bytes transfered so far, and total is \n            the size of the file if known.\n        :type progress_callback: callback function in format of func(current, total)\n        :param int max_connections:\n            If set to 2 or greater, an initial get will be done for the first \n            self.MAX_SINGLE_GET_SIZE bytes of the file. If this is the entire file, \n            the method returns at this point. If it is not, it will download the \n            remaining data parallel using the number of threads equal to \n            max_connections. Each chunk will be of size self.MAX_CHUNK_GET_SIZE.\n            If set to 1, a single large get request will be done. This is not \n            generally recommended but available if very few threads should be \n            used, network requests are very expensive, or a non-seekable stream \n            prevents parallel download. This may also be valuable if the file is \n            being concurrently modified to enforce atomicity or if many files are \n            expected to be empty as an extra request is required for empty files \n            if max_connections is greater than 1.\n        :param int timeout:\n            The timeout parameter is expressed in seconds. This method may make \n            multiple calls to the Azure service and the timeout will apply to \n            each call individually.\n        :return: A File with properties and metadata.\n        :rtype: :class:`~azure.storage.file.models.File`\n        '''\n        _validate_not_none('share_name', share_name)\n        _validate_not_none('file_name', file_name)\n        _validate_not_none('file_path', file_path)\n        _validate_not_none('open_mode', open_mode)\n\n        if max_connections > 1 and 'a' in open_mode:\n            raise ValueError(_ERROR_PARALLEL_NOT_SEEKABLE)\n\n        with open(file_path, open_mode) as stream:\n            file = self.get_file_to_stream(\n                share_name, directory_name, file_name, stream,\n                start_range, end_range, validate_content,\n                progress_callback, max_connections, timeout)\n\n        return file", "response": "Downloads a file to a file path."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_file_to_stream(\n        self, share_name, directory_name, file_name, stream,\n        start_range=None, end_range=None, validate_content=False,\n        progress_callback=None, max_connections=2, timeout=None):\n        '''\n        Downloads a file to a stream, with automatic chunking and progress\n        notifications. Returns an instance of :class:`File` with properties\n        and metadata.\n\n        :param str share_name:\n            Name of existing share.\n        :param str directory_name:\n            The path to the directory.\n        :param str file_name:\n            Name of existing file.\n        :param io.IOBase stream:\n            Opened file/stream to write to.\n        :param int start_range:\n            Start of byte range to use for downloading a section of the file.\n            If no end_range is given, all bytes after the start_range will be downloaded.\n            The start_range and end_range params are inclusive.\n            Ex: start_range=0, end_range=511 will download first 512 bytes of file.\n        :param int end_range:\n            End of byte range to use for downloading a section of the file.\n            If end_range is given, start_range must be provided.\n            The start_range and end_range params are inclusive.\n            Ex: start_range=0, end_range=511 will download first 512 bytes of file.\n        :param bool validate_content:\n            If set to true, validates an MD5 hash for each retrieved portion of \n            the file. This is primarily valuable for detecting bitflips on the wire \n            if using http instead of https as https (the default) will already \n            validate. Note that the service will only return transactional MD5s \n            for chunks 4MB or less so the first get request will be of size \n            self.MAX_CHUNK_GET_SIZE instead of self.MAX_SINGLE_GET_SIZE. If \n            self.MAX_CHUNK_GET_SIZE was set to greater than 4MB an error will be \n            thrown. As computing the MD5 takes processing time and more requests \n            will need to be done due to the reduced chunk size there may be some \n            increase in latency.\n        :param progress_callback:\n            Callback for progress with signature function(current, total) \n            where current is the number of bytes transfered so far, and total is \n            the size of the file if known.\n        :type progress_callback: callback function in format of func(current, total)\n        :param int max_connections:\n            If set to 2 or greater, an initial get will be done for the first \n            self.MAX_SINGLE_GET_SIZE bytes of the file. If this is the entire file, \n            the method returns at this point. If it is not, it will download the \n            remaining data parallel using the number of threads equal to \n            max_connections. Each chunk will be of size self.MAX_CHUNK_GET_SIZE.\n            If set to 1, a single large get request will be done. This is not \n            generally recommended but available if very few threads should be \n            used, network requests are very expensive, or a non-seekable stream \n            prevents parallel download. This may also be valuable if the file is \n            being concurrently modified to enforce atomicity or if many files are \n            expected to be empty as an extra request is required for empty files \n            if max_connections is greater than 1.\n        :param int timeout:\n            The timeout parameter is expressed in seconds. This method may make \n            multiple calls to the Azure service and the timeout will apply to \n            each call individually.\n        :return: A File with properties and metadata.\n        :rtype: :class:`~azure.storage.file.models.File`\n        '''\n        _validate_not_none('share_name', share_name)\n        _validate_not_none('file_name', file_name)\n        _validate_not_none('stream', stream)\n\n        # If the user explicitly sets max_connections to 1, do a single shot download\n        if max_connections == 1:\n            file = self._get_file(share_name,\n                                  directory_name,\n                                  file_name,\n                                  start_range=start_range,\n                                  end_range=end_range,\n                                  validate_content=validate_content,\n                                  timeout=timeout)\n\n            # Set the download size\n            download_size = file.properties.content_length\n\n        # If max_connections is greater than 1, do the first get to establish the \n        # size of the file and get the first segment of data\n        else:       \n            if sys.version_info >= (3,) and not stream.seekable():\n                raise ValueError(_ERROR_PARALLEL_NOT_SEEKABLE)\n                \n            # The service only provides transactional MD5s for chunks under 4MB.           \n            # If validate_content is on, get only self.MAX_CHUNK_GET_SIZE for the first \n            # chunk so a transactional MD5 can be retrieved.\n            first_get_size = self.MAX_SINGLE_GET_SIZE if not validate_content else self.MAX_CHUNK_GET_SIZE\n\n            initial_request_start = start_range if start_range else 0\n\n            if end_range and end_range - start_range < first_get_size:\n                initial_request_end = end_range\n            else:\n                initial_request_end = initial_request_start + first_get_size - 1\n\n            # Send a context object to make sure we always retry to the initial location\n            operation_context = _OperationContext(location_lock=True)\n            try:\n                file = self._get_file(share_name,\n                                      directory_name,\n                                      file_name,\n                                      start_range=initial_request_start,\n                                      end_range=initial_request_end,\n                                      validate_content=validate_content,\n                                      timeout=timeout,\n                                      _context=operation_context)\n\n                # Parse the total file size and adjust the download size if ranges \n                # were specified\n                file_size = _parse_length_from_content_range(file.properties.content_range)\n                if end_range:\n                    # Use the end_range unless it is over the end of the file\n                    download_size = min(file_size, end_range - start_range + 1)\n                elif start_range:\n                    download_size = file_size - start_range\n                else:\n                    download_size = file_size\n            except AzureHttpError as ex:\n                if not start_range and ex.status_code == 416:\n                    # Get range will fail on an empty file. If the user did not \n                    # request a range, do a regular get request in order to get \n                    # any properties.\n                    file = self._get_file(share_name,\n                                          directory_name,\n                                          file_name,\n                                          validate_content=validate_content,\n                                          timeout=timeout,\n                                          _context=operation_context)\n\n                    # Set the download size to empty\n                    download_size = 0\n                else:\n                    raise ex\n\n        # Mark the first progress chunk. If the file is small or this is a single \n        # shot download, this is the only call\n        if progress_callback:\n            progress_callback(file.properties.content_length, download_size)\n\n        # Write the content to the user stream  \n        # Clear file content since output has been written to user stream   \n        if file.content is not None:\n            stream.write(file.content)\n            file.content = None\n\n        # If the file is small or single shot download was used, the download is \n        # complete at this point. If file size is large, use parallel download.\n        if file.properties.content_length != download_size:       \n            # At this point would like to lock on something like the etag so that \n            # if the file is modified, we dont get a corrupted download. However, \n            # this feature is not yet available on the file service.\n            \n            end_file = file_size\n            if end_range:\n                # Use the end_range unless it is over the end of the file\n                end_file = min(file_size, end_range + 1)\n               \n            _download_file_chunks(\n                self,\n                share_name,\n                directory_name,\n                file_name,\n                download_size,\n                self.MAX_CHUNK_GET_SIZE,\n                first_get_size,\n                initial_request_end + 1, # start where the first download ended\n                end_file,\n                stream,\n                max_connections,\n                progress_callback,\n                validate_content,\n                timeout,\n                operation_context,\n            )\n\n            # Set the content length to the download size instead of the size of \n            # the last range\n            file.properties.content_length = download_size\n\n            # Overwrite the content range to the user requested range\n            file.properties.content_range = 'bytes {0}-{1}/{2}'.format(start_range, end_range, file_size)\n\n            # Overwrite the content MD5 as it is the MD5 for the last range instead \n            # of the stored MD5\n            # TODO: Set to the stored MD5 when the service returns this\n            file.properties.content_md5 = None\n\n        return file", "response": "Downloads a file from the server and writes it to the given stream."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ndownloading a file from the given share and returns an array of bytes.", "response": "def get_file_to_bytes(self, share_name, directory_name, file_name, \n                          start_range=None, end_range=None, validate_content=False,\n                          progress_callback=None, max_connections=2, timeout=None):\n        '''\n        Downloads a file as an array of bytes, with automatic chunking and\n        progress notifications. Returns an instance of :class:`File` with\n        properties, metadata, and content.\n\n        :param str share_name:\n            Name of existing share.\n        :param str directory_name:\n            The path to the directory.\n        :param str file_name:\n            Name of existing file.\n        :param int start_range:\n            Start of byte range to use for downloading a section of the file.\n            If no end_range is given, all bytes after the start_range will be downloaded.\n            The start_range and end_range params are inclusive.\n            Ex: start_range=0, end_range=511 will download first 512 bytes of file.\n        :param int end_range:\n            End of byte range to use for downloading a section of the file.\n            If end_range is given, start_range must be provided.\n            The start_range and end_range params are inclusive.\n            Ex: start_range=0, end_range=511 will download first 512 bytes of file.\n        :param bool validate_content:\n            If set to true, validates an MD5 hash for each retrieved portion of \n            the file. This is primarily valuable for detecting bitflips on the wire \n            if using http instead of https as https (the default) will already \n            validate. Note that the service will only return transactional MD5s \n            for chunks 4MB or less so the first get request will be of size \n            self.MAX_CHUNK_GET_SIZE instead of self.MAX_SINGLE_GET_SIZE. If \n            self.MAX_CHUNK_GET_SIZE was set to greater than 4MB an error will be \n            thrown. As computing the MD5 takes processing time and more requests \n            will need to be done due to the reduced chunk size there may be some \n            increase in latency.\n        :param progress_callback:\n            Callback for progress with signature function(current, total) \n            where current is the number of bytes transfered so far, and total is \n            the size of the file if known.\n        :type progress_callback: callback function in format of func(current, total)\n        :param int max_connections:\n            If set to 2 or greater, an initial get will be done for the first \n            self.MAX_SINGLE_GET_SIZE bytes of the file. If this is the entire file, \n            the method returns at this point. If it is not, it will download the \n            remaining data parallel using the number of threads equal to \n            max_connections. Each chunk will be of size self.MAX_CHUNK_GET_SIZE.\n            If set to 1, a single large get request will be done. This is not \n            generally recommended but available if very few threads should be \n            used, network requests are very expensive, or a non-seekable stream \n            prevents parallel download. This may also be valuable if the file is \n            being concurrently modified to enforce atomicity or if many files are \n            expected to be empty as an extra request is required for empty files \n            if max_connections is greater than 1.\n        :param int timeout:\n            The timeout parameter is expressed in seconds. This method may make \n            multiple calls to the Azure service and the timeout will apply to \n            each call individually.\n        :return: A File with properties, content, and metadata.\n        :rtype: :class:`~azure.storage.file.models.File`\n        '''\n        _validate_not_none('share_name', share_name)\n        _validate_not_none('file_name', file_name)\n\n        stream = BytesIO()\n        file = self.get_file_to_stream(\n            share_name,\n            directory_name,\n            file_name,\n            stream,\n            start_range,\n            end_range,\n            validate_content,\n            progress_callback,\n            max_connections,\n            timeout)\n\n        file.content = stream.getvalue()\n        return file"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ndownloading a file from the given share and returns it as unicode text.", "response": "def get_file_to_text(\n        self, share_name, directory_name, file_name, encoding='utf-8',\n        start_range=None, end_range=None, validate_content=False,\n        progress_callback=None, max_connections=2, timeout=None):\n        '''\n        Downloads a file as unicode text, with automatic chunking and progress\n        notifications. Returns an instance of :class:`File` with properties,\n        metadata, and content.\n\n        :param str share_name:\n            Name of existing share.\n        :param str directory_name:\n            The path to the directory.\n        :param str file_name:\n            Name of existing file.\n        :param str encoding:\n            Python encoding to use when decoding the file data.\n        :param int start_range:\n            Start of byte range to use for downloading a section of the file.\n            If no end_range is given, all bytes after the start_range will be downloaded.\n            The start_range and end_range params are inclusive.\n            Ex: start_range=0, end_range=511 will download first 512 bytes of file.\n        :param int end_range:\n            End of byte range to use for downloading a section of the file.\n            If end_range is given, start_range must be provided.\n            The start_range and end_range params are inclusive.\n            Ex: start_range=0, end_range=511 will download first 512 bytes of file.\n        :param bool validate_content:\n            If set to true, validates an MD5 hash for each retrieved portion of \n            the file. This is primarily valuable for detecting bitflips on the wire \n            if using http instead of https as https (the default) will already \n            validate. Note that the service will only return transactional MD5s \n            for chunks 4MB or less so the first get request will be of size \n            self.MAX_CHUNK_GET_SIZE instead of self.MAX_SINGLE_GET_SIZE. If \n            self.MAX_CHUNK_GET_SIZE was set to greater than 4MB an error will be \n            thrown. As computing the MD5 takes processing time and more requests \n            will need to be done due to the reduced chunk size there may be some \n            increase in latency.\n        :param progress_callback:\n            Callback for progress with signature function(current, total) \n            where current is the number of bytes transfered so far, and total is \n            the size of the file if known.\n        :type progress_callback: callback function in format of func(current, total)\n        :param int max_connections:\n            If set to 2 or greater, an initial get will be done for the first \n            self.MAX_SINGLE_GET_SIZE bytes of the file. If this is the entire file, \n            the method returns at this point. If it is not, it will download the \n            remaining data parallel using the number of threads equal to \n            max_connections. Each chunk will be of size self.MAX_CHUNK_GET_SIZE.\n            If set to 1, a single large get request will be done. This is not \n            generally recommended but available if very few threads should be \n            used, network requests are very expensive, or a non-seekable stream \n            prevents parallel download. This may also be valuable if the file is \n            being concurrently modified to enforce atomicity or if many files are \n            expected to be empty as an extra request is required for empty files \n            if max_connections is greater than 1.\n        :param int timeout:\n            The timeout parameter is expressed in seconds. This method may make \n            multiple calls to the Azure service and the timeout will apply to \n            each call individually.\n        :return: A File with properties, content, and metadata.\n        :rtype: :class:`~azure.storage.file.models.File`\n        '''\n        _validate_not_none('share_name', share_name)\n        _validate_not_none('file_name', file_name)\n        _validate_not_none('encoding', encoding)\n\n        file = self.get_file_to_bytes(\n            share_name,\n            directory_name,\n            file_name,\n            start_range,\n            end_range,\n            validate_content,\n            progress_callback,\n            max_connections,\n            timeout)\n\n        file.content = file.content.decode(encoding)\n        return file"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef process_firmware_image(compact_firmware_file, ilo_object):\n    fw_img_extractor = firmware_controller.get_fw_extractor(\n        compact_firmware_file)\n    LOG.debug('Extracting firmware file: %s ...', compact_firmware_file)\n    raw_fw_file_path, is_extracted = fw_img_extractor.extract()\n\n    # Note(deray): Need to check if this processing is for RIS or RIBCL\n    # based systems. For Gen9 machines (RIS based) the firmware file needs\n    # to be on a http store, and hence requires the upload to happen for the\n    # firmware file.\n    to_upload = False\n    m = re.search('Gen(\\d+)', ilo_object.model)\n    if int(m.group(1)) > 8:\n        to_upload = True\n\n    LOG.debug('Extracting firmware file: %s ... done', compact_firmware_file)\n    msg = ('Firmware file %(fw_file)s is %(msg)s. Need hosting (on an http '\n           'store): %(yes_or_no)s' %\n           {'fw_file': compact_firmware_file,\n            'msg': ('extracted. Extracted file: %s' % raw_fw_file_path\n                    if is_extracted else 'already in raw format'),\n            'yes_or_no': 'Yes' if to_upload else 'No'})\n    LOG.info(msg)\n    return raw_fw_file_path, to_upload, is_extracted", "response": "Processes the firmware image from the compact format and returns the core firmware file."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _get_hash_object(hash_algo_name):\n    algorithms = (hashlib.algorithms_guaranteed if six.PY3\n                  else hashlib.algorithms)\n    if hash_algo_name not in algorithms:\n        msg = (\"Unsupported/Invalid hash name '%s' provided.\"\n               % hash_algo_name)\n        raise exception.InvalidInputError(msg)\n\n    return getattr(hashlib, hash_algo_name)()", "response": "Create a hash object based on the given hashing algorithm."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef hash_file(file_like_object, hash_algo='md5'):\n    checksum = _get_hash_object(hash_algo)\n    for chunk in iter(lambda: file_like_object.read(32768), b''):\n        checksum.update(chunk)\n    return checksum.hexdigest()", "response": "Generate a hash for the contents of a file."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef verify_image_checksum(image_location, expected_checksum):\n    try:\n        with open(image_location, 'rb') as fd:\n            actual_checksum = hash_file(fd)\n    except IOError as e:\n        raise exception.ImageRefValidationFailed(image_href=image_location,\n                                                 reason=e)\n\n    if actual_checksum != expected_checksum:\n        msg = ('Error verifying image checksum. Image %(image)s failed to '\n               'verify against checksum %(checksum)s. Actual checksum is: '\n               '%(actual_checksum)s' %\n               {'image': image_location, 'checksum': expected_checksum,\n                'actual_checksum': actual_checksum})\n        raise exception.ImageRefValidationFailed(image_href=image_location,\n                                                 reason=msg)", "response": "Verifies checksum of image file against expected checksum."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nvalidates HTTP image reference.", "response": "def validate_href(image_href):\n        \"\"\"Validate HTTP image reference.\n\n        :param image_href: Image reference.\n        :raises: exception.ImageRefValidationFailed if HEAD request failed or\n            returned response code not equal to 200.\n        :returns: Response to HEAD request.\n        \"\"\"\n        try:\n            response = requests.head(image_href)\n            if response.status_code != http_client.OK:\n                raise exception.ImageRefValidationFailed(\n                    image_href=image_href,\n                    reason=(\"Got HTTP code %s instead of 200 in response to \"\n                            \"HEAD request.\" % response.status_code))\n        except requests.RequestException as e:\n            raise exception.ImageRefValidationFailed(image_href=image_href,\n                                                     reason=e)\n        return response"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef apply_bios_properties_filter(settings, filter_to_be_applied):\n    if not settings or not filter_to_be_applied:\n        return settings\n\n    return {k: settings[k] for k in filter_to_be_applied if k in settings}", "response": "Applies the filter to return the dict of filtered BIOS properties."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _insert_or_replace_entity(entity, require_encryption=False,\n                              key_encryption_key=None, encryption_resolver=None):\n    '''\n    Constructs an insert or replace entity request.\n    '''\n    _validate_entity(entity, key_encryption_key is not None)\n    _validate_encryption_required(require_encryption, key_encryption_key)\n\n    request = HTTPRequest()\n    request.method = 'PUT'\n    request.headers = {\n        _DEFAULT_CONTENT_TYPE_HEADER[0]: _DEFAULT_CONTENT_TYPE_HEADER[1],\n        _DEFAULT_ACCEPT_HEADER[0]: _DEFAULT_ACCEPT_HEADER[1],\n    }\n\n    if(key_encryption_key):\n        entity = _encrypt_entity(entity, key_encryption_key, encryption_resolver)\n    request.body = _get_request_body(_convert_entity_to_json(entity))\n\n    return request", "response": "Constructs an insert or replace entity request."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef accounts(self):\n        return account.HPEAccountCollection(\n            self._conn, utils.get_subresource_path_by(self, 'Accounts'),\n            redfish_version=self.redfish_version)", "response": "Property to provide instance of HPEAccountCollection"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nupdates the credentials of a redfish system", "response": "def update_credentials(self, password):\n        \"\"\"Update credentials of a redfish system\n\n        :param password: password to be updated\n        \"\"\"\n        data = {\n            'Password': password,\n        }\n        self._conn.patch(self.path, data=data)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the HPEAccount object if criterion matches username", "response": "def get_member_details(self, username):\n        \"\"\"Returns the HPEAccount object\n\n        :param username: username of account\n        :returns: HPEAccount object if criterion matches, None otherwise\n        \"\"\"\n        members = self.get_members()\n        for member in members:\n            if member.username == username:\n                return member"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _get_media(media_types):\n    get_mapped_media = (lambda x: maps.VIRTUAL_MEDIA_TYPES_MAP[x]\n                        if x in maps.VIRTUAL_MEDIA_TYPES_MAP else None)\n    return list(map(get_mapped_media, media_types))", "response": "Helper method to map the media types."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _get_action_element(self, action_type):\n        action = eval(\"self._hpe_actions.\" + action_type + \"_vmedia\")\n\n        if not action:\n            if action_type == \"insert\":\n                action_path = '#HpeiLOVirtualMedia.InsertVirtualMedia'\n            else:\n                action_path = '#HpeiLOVirtualMedia.EjectVirtualMedia'\n\n            raise exception.MissingAttributeError(\n                attribute=action_path,\n                resource=self._path)\n\n        return action", "response": "Helper method to return the action object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ninserting Virtual Media to the device.", "response": "def insert_media(self, url):\n        \"\"\"Inserts Virtual Media to the device\n\n        :param url: URL to image.\n        :raises: SushyError, on an error from iLO.\n        \"\"\"\n        try:\n            super(VirtualMedia, self).insert_media(url, write_protected=True)\n        except sushy_exceptions.SushyError:\n            target_uri = self._get_action_element('insert').target_uri\n            data = {'Image': url}\n            self._conn.post(target_uri, data=data)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef eject_media(self):\n        try:\n            super(VirtualMedia, self).eject_media()\n        except sushy_exceptions.SushyError:\n            target_uri = self._get_action_element('eject').target_uri\n            self._conn.post(target_uri, data={})", "response": "Ejects Virtual Media.\n\n        :raises: SushyError, on an error from iLO."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef set_vm_status(self, boot_on_next_reset):\n        data = {\n            \"Oem\": {\n                \"Hpe\": {\n                    \"BootOnNextServerReset\": boot_on_next_reset\n                    }\n                }\n            }\n        self._conn.patch(self.path, data=data)", "response": "Set the Virtual Media drive status."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the given virtual media device object.", "response": "def get_member_device(self, device):\n        \"\"\"Returns the given virtual media device object.\n\n        :param  device: virtual media device to be queried\n        :returns virtual media device object.\n        \"\"\"\n        for vmedia_device in self.get_members():\n            if device in vmedia_device.media_types:\n                return vmedia_device"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _get_entity(partition_key, row_key, select, accept):\n    '''\n    Constructs a get entity request.\n    '''\n    _validate_not_none('partition_key', partition_key)\n    _validate_not_none('row_key', row_key)\n    _validate_not_none('accept', accept)\n    request = HTTPRequest()\n    request.method = 'GET'\n    request.headers = [('Accept', _to_str(accept))]\n    request.query = [('$select', _to_str(select))]\n\n    return request", "response": "Constructs a get entity request."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _insert_entity(entity):\n    '''\n    Constructs an insert entity request.\n    '''\n    _validate_entity(entity)\n\n    request = HTTPRequest()\n    request.method = 'POST'\n    request.headers = [_DEFAULT_CONTENT_TYPE_HEADER,\n                        _DEFAULT_PREFER_HEADER,\n                        _DEFAULT_ACCEPT_HEADER]\n    request.body = _get_request_body(_convert_entity_to_json(entity))\n\n    return request", "response": "Constructs an insert entity request."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nconstruct a merge entity request.", "response": "def _merge_entity(entity, if_match):\n    '''\n    Constructs a merge entity request.\n    '''\n    _validate_not_none('if_match', if_match)\n    _validate_entity(entity)\n\n    request = HTTPRequest()\n    request.method = 'MERGE'\n    request.headers = [_DEFAULT_CONTENT_TYPE_HEADER,\n                        _DEFAULT_ACCEPT_HEADER,\n                        ('If-Match', _to_str(if_match))]\n    request.body = _get_request_body(_convert_entity_to_json(entity))\n\n    return request"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nconstruct a delete entity request.", "response": "def _delete_entity(partition_key, row_key, if_match):\n    '''\n     Constructs a delete entity request.\n    '''\n    _validate_not_none('if_match', if_match)\n    _validate_not_none('partition_key', partition_key)\n    _validate_not_none('row_key', row_key)\n    request = HTTPRequest()\n    request.method = 'DELETE'\n    request.headers = [_DEFAULT_ACCEPT_HEADER,\n                        ('If-Match', _to_str(if_match))]\n\n    return request"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nconstructs an insert or replace entity request.", "response": "def _insert_or_replace_entity(entity):\n    '''\n    Constructs an insert or replace entity request.\n    '''\n    _validate_entity(entity)\n\n    request = HTTPRequest()\n    request.method = 'PUT'\n    request.headers = [_DEFAULT_CONTENT_TYPE_HEADER,\n                        _DEFAULT_ACCEPT_HEADER]\n    request.body = _get_request_body(_convert_entity_to_json(entity))\n\n    return request"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ntrying to find the executable in PATH environment", "response": "def find_executable(executable_name):\n    \"\"\"Tries to find executable in PATH environment\n\n    It uses ``shutil.which`` method in Python3 and\n    ``distutils.spawn.find_executable`` method in Python2.7 to find the\n    absolute path to the 'name' executable.\n    :param executable_name: name of the executable\n    :returns: Returns the absolute path to the executable or None if not found.\n    \"\"\"\n    if six.PY3:\n        executable_abs = shutil.which(executable_name)\n    else:\n        import distutils.spawn\n        executable_abs = distutils.spawn.find_executable(executable_name)\n\n    return executable_abs"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef check_firmware_update_component(func):\n    @six.wraps(func)\n    def wrapper(self, filename, component_type):\n        \"\"\"Wrapper around ``update_firmware`` call.\n\n        :param filename: location of the raw firmware file.\n        :param component_type: Type of component to be applied to.\n        \"\"\"\n        component_type = component_type and component_type.lower()\n        if (component_type not in SUPPORTED_FIRMWARE_UPDATE_COMPONENTS):\n            msg = (\"Got invalid component type for firmware update: \"\n                   \"``update_firmware`` is not supported on %(component)s\" %\n                   {'component': component_type})\n            LOG.error(self._(msg))  # noqa\n            raise exception.InvalidInputError(msg)\n\n        return func(self, filename, component_type)\n\n    return wrapper", "response": "Decorator to check the firmware update component."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the FirmwareImageExtractor object fine - tuned for the specified type of compact firmware file.", "response": "def get_fw_extractor(fw_file):\n    \"\"\"Gets the firmware extractor object fine-tuned for specified type\n\n    :param fw_file: compact firmware file to be extracted from\n    :raises: InvalidInputError, for unsupported file types\n    :returns: FirmwareImageExtractor object\n    \"\"\"\n    fw_img_extractor = FirmwareImageExtractor(fw_file)\n    extension = fw_img_extractor.fw_file_ext.lower()\n\n    if extension == '.scexe':\n        # assign _do_extract attribute to refer to _extract_scexe_file\n        fw_img_extractor._do_extract = types.MethodType(\n            _extract_scexe_file, fw_img_extractor)\n    elif extension == '.rpm':\n        # assign _do_extract attribute to refer to _extract_rpm_file\n        fw_img_extractor._do_extract = types.MethodType(\n            _extract_rpm_file, fw_img_extractor)\n    elif extension in RAW_FIRMWARE_EXTNS:\n        # Note(deray): Assigning ``extract`` attribute to return\n        #     1. the firmware file itself\n        #     2. boolean (False) to indicate firmware file is not extracted\n        def dummy_extract(self):\n            \"\"\"Dummy (no-op) extract method\n\n            :returns: the same firmware file with the complete path\n            :returns: boolean(False) to indicate that a new file is not\n                      generated.\n            \"\"\"\n            return fw_img_extractor.fw_file, False\n\n        fw_img_extractor.extract = types.MethodType(\n            dummy_extract, fw_img_extractor)\n    else:\n        raise exception.InvalidInputError(\n            'Unexpected compact firmware file type: %s' % fw_file)\n\n    return fw_img_extractor"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _extract_scexe_file(self, target_file, extract_path):\n    # Command to extract the smart component file.\n    unpack_cmd = '--unpack=' + extract_path\n    # os.path.isfile(target_file)\n    cmd = [target_file, unpack_cmd]\n    out, err = utils.trycmd(*cmd)", "response": "Extracts the scexe file from the target file."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _extract_rpm_file(self, target_file, extract_path):\n    if not os.path.exists(extract_path):\n        os.makedirs(extract_path)\n    os.chdir(extract_path)\n\n    if find_executable('rpm2cpio') is None:\n        raise exception.ImageExtractionFailed(\n            image_ref=target_file, reason='Command `rpm2cpio` not found.')\n    if find_executable('cpio') is None:\n        raise exception.ImageExtractionFailed(\n            image_ref=target_file, reason='Command `cpio` not found.')\n    try:\n        rpm2cpio = subprocess.Popen('rpm2cpio ' + target_file,\n                                    shell=True,\n                                    stdout=subprocess.PIPE)\n        cpio = subprocess.Popen('cpio -idm', shell=True,\n                                stdin=rpm2cpio.stdout)\n        out, err = cpio.communicate()\n    except (OSError, ValueError) as e:\n        raise exception.ImageExtractionFailed(\n            image_ref=target_file,\n            reason='Unexpected error in extracting file. ' + str(e))", "response": "Extracts the rpm file from the specified path."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _get_firmware_file(path):\n    for dirpath, dirnames, filenames in os.walk(path):\n        for filename in filenames:\n            file_name, file_ext = os.path.splitext(os.path.basename(filename))\n            if file_ext in RAW_FIRMWARE_EXTNS:\n                # return filename\n                return os.path.join(dirpath, filename)", "response": "Gets the raw firmware file from the extracted directory structure\n   "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget the raw firmware file from the extracted directory structure creates a hard link to that file and cleans up the lookup extract path.", "response": "def _get_firmware_file_in_new_path(searching_path):\n    \"\"\"Gets the raw firmware file in a new path\n\n    Gets the raw firmware file from the extracted directory structure\n    and creates a hard link to that in a file path and cleans up the\n    lookup extract path.\n    :param searching_path: the directory structure to search for\n    :returns: the raw firmware file with the complete new path\n    \"\"\"\n    firmware_file_path = _get_firmware_file(searching_path)\n    if not firmware_file_path:\n        return None\n\n    # Note(deray): the path of the new firmware file will be of the form:\n    #\n    #    [TEMP_DIR]/xxx-xxx_actual_firmware_filename\n    #\n    # e.g. /tmp/77e8f689-f32c-4727-9fc3-a7dacefe67e4_ilo4_210.bin\n    file_name, file_ext_with_dot = common.get_filename_and_extension_of(\n        firmware_file_path)\n    new_firmware_file_path = os.path.join(\n        tempfile.gettempdir(), str(uuid.uuid4()) + '_' +\n        file_name + file_ext_with_dot)\n\n    # create a hard link to the raw firmware file\n    os.link(firmware_file_path, new_firmware_file_path)\n    return new_firmware_file_path"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef upload_file_to(self, addressinfo, timeout):\n        self.hostname, self.port = addressinfo\n        self.timeout = timeout\n        filename = self.fw_file\n\n        firmware = open(filename, 'rb').read()\n        # generate boundary\n        boundary = b('------hpiLO3t' +\n                     str(random.randint(100000, 1000000)) + 'z')\n\n        while boundary in firmware:\n            boundary = b('------hpiLO3t' +\n                         str(random.randint(100000, 1000000)) + 'z')\n        # generate body parts\n        parts = [\n            # body1\n            b(\"--\") + boundary +\n            b(\"\"\"\\r\\nContent-Disposition: form-data; \"\"\"\n              \"\"\"name=\"fileType\"\\r\\n\\r\\n\"\"\"),\n            # body2\n            b(\"\\r\\n--\") + boundary +\n            b('''\\r\\nContent-Disposition: form-data; name=\"fwimgfile\"; '''\n              '''filename=\"''') +\n            b(filename) +\n            b('''\"\\r\\nContent-Type: application/octet-stream\\r\\n\\r\\n'''),\n            # firmware image\n            firmware,\n            # body3\n            b(\"\\r\\n--\") + boundary + b(\"--\\r\\n\"),\n        ]\n        total_bytes = sum([len(x) for x in parts])\n        sock = self._get_socket()\n\n        # send the firmware image\n        sock.write(b(self.HTTP_UPLOAD_HEADER %\n                     (total_bytes, boundary.decode('ascii'))))\n        for part in parts:\n            sock.write(part)\n\n        data = ''\n        try:\n            while True:\n                d = sock.read()\n                data += d.decode('latin-1')\n                if not d:\n                    break\n        except socket.sslerror:  # Connection closed\n            e = sys.exc_info()[1]\n            if not data:\n                raise exception.IloConnectionError(\n                    \"Communication with %(hostname)s:%(port)d failed: \"\n                    \"%(error)s\" % {'hostname': self.hostname,\n                                   'port': self.port, 'error': str(e)})\n\n        # Received len(data) bytes\n        cookie_match = re.search('Set-Cookie: *(.*)', data)\n        if not cookie_match:\n            raise exception.IloError(\"Uploading of file: %s failed due \"\n                                     \"to unknown reason.\" % filename)\n        # return the cookie\n        return cookie_match.group(1)", "response": "Uploads the raw firmware file to iLO and returns the cookie so sent back to iLO."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _get_socket(self, sslversion=ssl.PROTOCOL_TLSv1):\n        err = None\n        sock = None\n        try:\n            for res in socket.getaddrinfo(\n                    self.hostname, self.port, 0, socket.SOCK_STREAM):\n                af, socktype, proto, canonname, sa = res\n                try:\n                    sock = socket.socket(af, socktype, proto)\n                    sock.settimeout(self.timeout)\n                    # Connecting to {self.hostname} at port {self.port}\n                    sock.connect(sa)\n                except socket.timeout:\n                    if sock is not None:\n                        sock.close()\n                    err = exception.IloConnectionError(\n                        \"Timeout connecting to %(hostname)s:%(port)d\"\n                        % {'hostname': self.hostname, 'port': self.port})\n                except socket.error:\n                    if sock is not None:\n                        sock.close()\n                    e = sys.exc_info()[1]\n                    err = exception.IloConnectionError(\n                        \"Error connecting to %(hostname)s:%(port)d : %(error)s\"\n                        % {'hostname': self.hostname, 'port': self.port,\n                           'error': str(e)})\n        except Exception:\n            raise exception.IloConnectionError(\n                \"Unable to resolve %s\" % self.hostname)\n\n        if err is not None:\n            raise err\n\n        # wrapping the socket over ssl session\n        try:\n            return ssl.wrap_socket(sock, ssl_version=sslversion)\n        except socket.sslerror:\n            e = sys.exc_info()[1]\n            msg = (getattr(e, 'reason', None) or\n                   getattr(e, 'message', None))\n            # Some older iLO s don't support TLSv1, retry with SSLv3\n            if ('wrong version number' in msg) and (\n                    sslversion == ssl.PROTOCOL_TLSv1):\n\n                return self._get_socket(ssl.PROTOCOL_SSLv3)\n\n            raise exception.IloConnectionError(\n                \"Cannot establish ssl session with %(hostname)s:%(port)d : \"\n                \"%(error)s\" % {'hostname': self.hostname, 'port': self.port,\n                               'error': str(e)})", "response": "Returns a ssl wrapped socket object for the current connection and SSLv1 protocol version."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nextract the raw firmware file from its compact format and returns the full path to the raw firmware file.", "response": "def extract(self):\n        \"\"\"Extracts the raw firmware file from its compact format\n\n        Extracts the raw firmware file from its compact file format (already\n        set as attribute in FirmwareImageControllerBase constructor).\n        :raises: InvalidInputError, if raw firmware file not found\n        :raises: ImageExtractionFailed, for extraction related issues\n        :returns: the raw firmware file with the complete path\n        :returns: boolean(True) to indicate that a new file got generated\n                  after successful extraction.\n        \"\"\"\n        target_file = self.fw_file\n        common.add_exec_permission_to(target_file)\n        # create a temp directory where the extraction will occur\n        temp_dir = tempfile.mkdtemp()\n        extract_path = os.path.join(temp_dir, self.fw_filename)\n\n        try:\n            self._do_extract(target_file, extract_path)\n        except exception.ImageExtractionFailed:\n            # clean up the partial extracted content, if any,\n            # along with temp dir and re-raise the exception\n            shutil.rmtree(temp_dir, ignore_errors=True)\n            raise\n\n        # creating a new hard link to the core firmware file\n        firmware_file_path = _get_firmware_file_in_new_path(extract_path)\n        # delete the entire extracted content along with temp dir.\n        shutil.rmtree(temp_dir, ignore_errors=True)\n\n        if not firmware_file_path:\n            raise exception.InvalidInputError(\n                \"Raw firmware file not found in: '%s'\" % target_file)\n\n        return firmware_file_path, True"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nconverts redfish data of current raid config to generic format.", "response": "def _generic_format(self, raid_config, controller=None):\n        \"\"\"Convert redfish data of current raid config to generic format.\n\n        :param raid_config: Raid configuration dictionary\n        :param controller: Array controller model in post_create read else\n                           None\n        :returns: current raid config.\n        \"\"\"\n        logical_drives = raid_config[\"LogicalDrives\"]\n        logical_disks = []\n        controller = controller\n        for ld in logical_drives:\n            prop = {'size_gb': ld['CapacityGiB'],\n                    'raid_level': ld['Raid'].strip('Raid'),\n                    'root_device_hint': {\n                        'wwn': '0x' + ld['VolumeUniqueIdentifier']},\n                    'controller': controller,\n                    'physical_disks': ld['DataDrives'],\n                    'volume_name': ld['LogicalDriveName']}\n            logical_disks.append(prop)\n        return logical_disks"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncheck for smart storage message.", "response": "def _check_smart_storage_message(self):\n        \"\"\"Check for smart storage message.\n\n        :returns: result, raid_message\n        \"\"\"\n        ssc_mesg = self.smart_storage_config_message\n        result = True\n        raid_message = \"\"\n        for element in ssc_mesg:\n            if \"Success\" not in element['MessageId']:\n                result = False\n                raid_message = element['MessageId']\n        return result, raid_message"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef read_raid(self, controller=None):\n        if controller:\n            if not self.logical_drives:\n                msg = ('No logical drives found on the controller')\n                LOG.debug(msg)\n                raise exception.IloLogicalDriveNotFoundError(msg)\n            raid_op = 'create_raid'\n        else:\n            raid_op = 'delete_raid'\n\n        result, raid_message = self._check_smart_storage_message()\n\n        if result:\n            configured_raid_settings = self._conn.get(self.settings_uri)\n            raid_data = {\n                'logical_disks': self._generic_format(\n                    configured_raid_settings.json(), controller=controller)}\n            return raid_data\n        else:\n            if self.physical_drives is None or not raid_message:\n                # This controller is not configured or controller\n                # not used in raid operation\n                return\n            else:\n                msg = ('Failed to perform the %(opr)s operation '\n                       'successfully. Error - %(error)s'\n                       % {'opr': raid_op, 'error': str(raid_message)})\n                raise exception.IloError(msg)", "response": "Get the current RAID configuration from the system."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef delete_raid(self):\n        if not self.logical_drives:\n            msg = ('No logical drives found on the controller '\n                   '%(controller)s' % {'controller': str(self.controller_id)})\n            LOG.debug(msg)\n            raise exception.IloLogicalDriveNotFoundError(msg)\n\n        lds = [{\n               'Actions': [{\"Action\": \"LogicalDriveDelete\"}],\n               'VolumeUniqueIdentifier':\n               logical_drive.volume_unique_identifier}\n               for logical_drive in self.logical_drives]\n\n        data = {'LogicalDrives': lds, 'DataGuard': 'Permissive'}\n        self._conn.put(self.settings_uri, data=data)", "response": "Clears the RAID configuration from the system."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates the raid configuration on the hardware.", "response": "def create_raid(self, raid_config):\n        \"\"\"Create the raid configuration on the hardware.\n\n        :param raid_config: A dictionary containing target raid configuration\n                            data. This data stucture should be as follows:\n                            raid_config = {'logical_disks': [{'raid_level': 1,\n                            'size_gb': 100, 'physical_disks': ['6I:1:5'],\n                            'controller': 'HPE Smart Array P408i-a SR Gen10'},\n                            <info-for-logical-disk-2>]}\n        \"\"\"\n        manager.validate(raid_config)\n        logical_drives = raid_config['logical_disks']\n        redfish_logical_disk = []\n        for ld in logical_drives:\n            ld_attr = {\"Raid\": \"Raid\" + ld[\"raid_level\"]}\n            ld_attr[\n                \"CapacityGiB\"] = -1 if ld[\n                    \"size_gb\"] == \"MAX\" else int(ld[\"size_gb\"])\n            if 'physical_disks' in ld:\n                ld_attr[\"DataDrives\"] = ld[\"physical_disks\"]\n            else:\n                datadrives = {}\n                if 'number_of_physical_disks' in ld:\n                    datadrives[\"DataDriveCount\"] = (\n                        ld[\"number_of_physical_disks\"])\n                else:\n                    datadrives[\"DataDriveCount\"] = (constants.\n                                                    RAID_LEVEL_MIN_DISKS\n                                                    [ld[\"raid_level\"]])\n                if 'disk_type' in ld:\n                    datadrives[\"DataDriveMediaType\"] = ld[\"disk_type\"]\n                if 'interface_type' in ld:\n                    datadrives[\"DataDriveInterfaceType\"] = ld[\"interface_type\"]\n                ld_attr[\"DataDrives\"] = datadrives\n            if 'volume_name' in ld:\n                ld_attr[\"LogicalDriveName\"] = ld[\"volume_name\"]\n            redfish_logical_disk.append(ld_attr)\n\n        data = {\n            \"DataGuard\": \"Disabled\",\n            \"LogicalDrives\": redfish_logical_disk\n        }\n        self._conn.put(self.settings_uri, data=data)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _readFile(self, fname, sldir):\n        '''\n        Private method that reads in the data file and organizes it\n        within this object.\n\n        '''\n        if sldir.endswith('/'):\n            fname = str(sldir)+str(fname)\n        else:\n            fname = str(sldir)+'/'+str(fname)\n        f=open(fname,'r')\n\n        # read header line\n        line=f.readline()\n        cols  = []\n        ispec = 0\n        for i in range(1,len(line.split('|'))):\n            col = line.split('|')[i].strip()\n            if '-' in col:\n                ispec += 1\n                col   = col.split('-')[1]\n            cols.append(col)\n            col_num={}\n        col_tot = len(cols)\n\n        print('number of species: ', str(ispec))\n        print('number of cols: ', str(col_tot))\n\n\n        col_num={}\n        for a,b in zip(cols,list(range(col_tot))):\n            col_num[a]=b\n\n        # read remainder of the file\n        lines=f.readlines()\n        data=[]\n        for i in range(len(lines)):\n            v=lines[i].split()\n            vv=array(v,dtype='float')\n            data.append(vv)\n        ilines=i\n        print(\"There are \"+str(ilines)+\" time steps found.\")\n        return data,col_num,cols,col_tot,ilines", "response": "Private method that reads in the data file and organizes it into a list of tuples."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get(self, col_str):\n        '''\n        get one data column with the data\n\n        Parameters\n        ----------\n        col_str : string\n            One of the column strings in self.cols.\n\n        '''\n        data_column=zeros(self.ilines)\n        for i in range(self.ilines):\n            data_column[i]=self.data[i][self.col_num[col_str]]\n        return data_column", "response": "get one data column with the data\n           "}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef plot_xtime(self, y, x='time', label='default', labelx=None,\n                   labely=None ,title=None, shape='.', logx=False,\n                   logy=True, base=10):\n        '''\n        make a simple plot of two columns against each other.\n\n        An example would be instance.plot_xtime('PB206', label='PB206 vs t_y'\n        Recomend using the plot function DataPlot.plot() it has more\n        functionality.\n\n        Parameters\n        ----------\n        Y : string\n            Column on Y-axis.\n        X : string, optional\n            Column on X-axis.  The default is \"time\".\n        label : string, optional\n            Legend label.  The default is \"default\".\n        labelX : string, optional\n            The label on the X axis.  The default is None.\n        labelY : string, optional\n            The label on the Y axis.  The default is None.\n        title : string, optional\n            The Title of the Graph.  The default is None.\n        shape : string, optional\n            What shape and colour the user would like their plot in.\n            The default is '.'.\n        logX : boolean, optional\n            A boolean of weather the user wants the x axis\n            logarithmically.  The default is False.\n        logY : boolean, optional\n            A boolean of weather the user wants the Y axis\n            logarithmically.  The default is True.\n        base : integer, optional\n            The base of the logarithm.  The default is 10.\n\n        Notes\n        -----\n        For all possable choices visit,\n        <http://matplotlib.sourceforge.net/api/pyplot_api.html#matplotlib.pyplot.plot>\n\n        '''\n        if label is 'default':\n            lab_str=y\n        else:\n            lab_str=label\n\n        try:\n            self.get(x)\n        except KeyError:\n            x='age'\n\n        DataPlot.plot(self,x,y,legend=lab_str,labelx=labelx, labely=labely,\n                      title=title, shape=shape,logx=logx, logy=logy, base=base)\n        '''\n        print X,Y\n        xdat=self.get(X)\n        ydat=self.get(Y)\n        self.xdat = xdat\n        self.ydat = ydat\n\n\n        plot(xdat,log10(ydat),label=lab_str)\n        legend()\n        '''", "response": "This function will plot two columns against each other."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef getColData(self, attri, fname, numtype='cycNum'):\n        fname=self.findFile(fname,numtype)\n        f=open(fname,'r')\n        for i in range(self.index+1):\n            f.readline()\n        lines=f.readlines()\n        for i in range(len(lines)):\n            lines[i]=lines[i].strip()\n            lines[i]=lines[i].split()\n        index=0\n        data=[]\n\n        while index < len (self.dcols):\n            if attri== self.dcols[index]:\n                break\n            index+=1\n\n        for i in range(len(lines)):\n\n            if index==5 and len(lines[i])==7:\n                data.append(str(lines[i][index].capitalize())+'-'\\\n                +str(lines[i][index+1]))\n            elif index==5 and len(lines[i])!=7:\n                tmp=str(lines[i][index])\n                if tmp[len(tmp)-1].isdigit():\n                    tmp1=tmp[0]+tmp[1]\n                    tmp1=tmp1.capitalize()\n                    tmp2=''\n                    for j in range(len(tmp)):\n                        if j == 0 or j == 1:\n                            continue\n                        tmp2+=tmp[j]\n                    data.append(tmp1+'-'+tmp2)\n                elif tmp=='PROT':\n                    data.append('H-1')\n                elif tmp==('NEUT'or'NEUTR'or'nn'or'N   1'or'N-1'):\n                    data.append('N-1')\n                else:\n                    data.append(tmp)\n            elif index==0:\n                data.append(int(lines[i][index]))\n            else:\n                data.append(float(lines[i][index]))\n\n        return array(data)", "response": "This method returns the column of data for the associated column."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef getElement(self, attri, fname, numtype='cycNum'):\n        '''\n        In this method instead of getting a particular column of data,\n        the program gets a particular row of data for a particular\n        element name.\n\n        attri : string\n            The name of the attribute we are looking for. A complete\n            list of them can be obtained by calling\n\n            >>> get('element_name')\n        fname : string\n            The name of the file we are getting the data from or the\n            cycle number found in the filename.\n        numtype : string, optional\n            Determines whether fname is the name of a file or, the\n            cycle number.  If it is 'file' it will then  interpret it as\n            a file, if it is 'cycNum' it will then  interpret it as a\n            cycle number.  The default is \"cycNum\".\n\n        Returns\n        -------\n        array\n            A numpy array of the four element attributes, number, Z, A\n            and abundance, in that order.\n\n        Notes\n        -----\n        Warning\n        '''\n        element=[] #Variable for holding the list of element names\n        number=[]  #Variable for holding the array of numbers\n        z=[]       #Variable for holding the array of z\n        a=[]       #Variable for holding the array of a\n        abd=[]     #Variable for holding the array of Abundance\n        data=[]    #variable for the final list of data\n\n        fname=self.findFile(fname,numtype)\n        f=open(fname,'r')\n        for i in range(self.index+1):\n            f.readline()\n        lines=f.readlines()\n        for i in range(len(lines)):\n            lines[i]=lines[i].strip()\n            lines[i]=lines[i].split()\n        index=0\n        data=[]\n\n        while index < len (self.dcols):\n            if attri== self.dcols[index]:\n                break\n            index+=1\n\n        element=self.get(self.dcols[5],fname,numtype)\n        number=[]\n        z=[]\n        a=[]\n        isom=[]\n        abd=[]\n        for i in range(len(lines)):\n            number.append(int(lines[i][0]))\n            z.append(float(lines[i][1]))\n            isom.append(float(lines[i][2]))\n            abd.append(float(lines[i][1]))\n        index=0 #Variable for determing the index in the data columns\n\n\n        while index < len(element):\n            if attri == element[index]:\n                break\n\n            index+=1\n\n        data.append(number[index])\n        data.append(z[index])\n        data.append(a[index])\n        data.append(isom[index])\n        data.append(abd[index])\n\n        return array(data)", "response": "This method gets the element name of a particular attribute from a file. This method will return a list of the four element attributes number Z and Arac."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _getcycle(self, cycle, decayed=False):\n        ''' Private method for getting a cycle, called from get.'''\n        yps=self.get('ABUNDANCE_MF', cycle)\n        z=self.get('Z', cycle) #charge\n        a=self.get('A', cycle) #mass\n        isomers=self.get('ISOM', cycle)\n\n        a_iso_to_plot,z_iso_to_plot,abunds,isotope_to_plot,el_iso_to_plot,isom=\\\n            self._process_abundance_vector(a,z,isomers,yps)\n        self.a_iso_to_plot=a_iso_to_plot\n        self.isotope_to_plot=isotope_to_plot\n        self.z_iso_to_plot=z_iso_to_plot\n        self.el_iso_to_plot=el_iso_to_plot\n        self.abunds=array(abunds)\n        self.isom=isom\n\n        if decayed:\n            try:\n                self.decay_idp\n            except AttributeError:\n                print(\"WARNING: decayed in _getcycle ignores isomers \" \\\n                    \"and will decay alpha-unstable p-rich nuclei as if they were beta+ stable.\")\n                print(\"Initialising decay index pointers ....\")\n                self.decay_indexpointer() # provides self.decay_idp and\n            ind_tmp=self.idp_to_stables_in_isostoplot\n\n            isotope_decay=array(isotope_to_plot)[ind_tmp]\n            z_iso_decay=array(z_iso_to_plot)[ind_tmp]\n            a_iso_decay=array(a_iso_to_plot)[ind_tmp]\n            el_iso_decay=array(el_iso_to_plot)[ind_tmp]\n            abunds_decay=zeros(len(ind_tmp), dtype='float64')\n            for i in range(len(isotope_to_plot)):\n                idp=where(isotope_decay==isotope_to_plot[self.decay_idp[i]])[0] # points from\n                # i on isotope_to_plot scale to decay target_on_decayed array scale\n                abunds_decay[idp] += abunds[i]\n\n            if self.debug:\n                print(\"Decayed array:\")\n                for i in range(len(ind_tmp)):\n                    print(isotope_decay[i], z_iso_decay[i], a_iso_decay[i], el_iso_decay[i], abunds_decay[i])\n\n            self.a_iso_to_plot=a_iso_decay\n            self.isotope_to_plot=isotope_decay\n            self.z_iso_to_plot=z_iso_decay\n            self.el_iso_to_plot=el_iso_decay\n            self.abunds=abunds_decay", "response": "Private method for getting a cycle."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _readFile(self, fname, sldir):\n        '''\n        private method that reads in and organizes the .DAT file\n        Loads the data of the .DAT File into the variables cattrs and cols.\n        In both these cases they are dictionaries, but in the case of cols,\n        it is a dictionary of numpy array exect for the element ,\n        element_name where it is just a list\n\n        '''\n        cattrs=[]\n        if sldir.endswith(os.sep):\n            #Making sure fname will be formatted correctly\n            fname = str(sldir)+str(fname)\n        else:\n            fname = str(sldir)+os.sep+str(fname)\n            self.sldir+=os.sep\n        f=open(fname,'r')\n        lines=f.readlines()\n        for i in range(len(lines)):\n            lines[i]=lines[i].strip()\n\n\n        cols=lines[0].strip('H')\n        cols=cols.strip()\n        cols=cols.split()\n        for i in range(len(lines)):\n            if lines[i].startswith('#'):\n                # if it is a cycle attribute line\n                lines[i]=lines[i].strip('#')\n                tmp=lines[i].split()\n                tmp1=[]\n                for j in range(len(tmp)):\n                    if tmp[j] != '=' or '':\n                        tmp1.append(tmp[j])\n                tmp=tmp1\n\n                j=0\n                while j <len(tmp):\n                    cattrs.append(tmp[j])\n                    j+=2\n\n\n            elif not lines[i].startswith('H'):\n                index = i-1\n                break\n\n\n        return cattrs,cols, index", "response": "Private method that reads in and organizes the. DAT file fname and returns a list of dictionaries where the keys are column names and the values are column names and the index is the index of the column."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef findFile(self, fname, numtype):\n        numType=numtype.upper()\n        if numType == 'FILE':\n                #do nothing\n            return fname\n        elif numType == 'CYCNUM':\n            try:\n                fname = int(fname)\n            except ValueError:\n                print('Improper choice:'+ str(fname))\n                print('Reselecting as 0')\n                fname = 0\n                print('Using '+self.files[fname])\n        try:\n            return self.files[self.indexp_cyc2filels[fname]]\n        except IndexError:\n            mods = array(self.get('mod'), dtype=int)\n            if fname not in mods:\n                print('You seem to try to plot a cycle that is not present: '+str(fname))\n                fname = mods[-1]\n                print('I will assume you want to plot the last cycle in the run: '+str(fname))\n                print('[I am not 100% sure this escape is debugged. You better do this again with')\n                print('the correct input.]')\n                return self.files[fname]", "response": "Function that finds the associated file for fname when Fname is not in the table."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nattempting to retry the given data in the given context.", "response": "def _retry(self, context, backoff):\n        '''\n        A function which determines whether and how to retry.\n\n        :param ~azure.storage.models.RetryContext context: \n            The retry context. This contains the request, response, and other data \n            which can be used to determine whether or not to retry.\n        :param function() backoff:\n            A function which returns the backoff time if a retry is to be performed.\n        :return: \n            An integer indicating how long to wait before retrying the request, \n            or None to indicate no retry should be performed.\n        :rtype: int or None\n        '''\n        # If the context does not contain a count parameter, this request has not \n        # been retried yet. Add the count parameter to track the number of retries.\n        if not hasattr(context, 'count'):\n            context.count = 0\n\n        # Determine whether to retry, and if so increment the count, modify the \n        # request as desired, and return the backoff.\n        if self._should_retry(context):\n            context.count += 1\n            \n            # If retry to secondary is enabled, attempt to change the host if the \n            # request allows it\n            if self.retry_to_secondary:\n                self._set_next_host_location(context)\n\n            return backoff(context)\n\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nconverting the response body of a storage service to a ServiceStats object.", "response": "def _convert_xml_to_service_stats(response):\n    '''\n    <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    <StorageServiceStats>\n      <GeoReplication>      \n          <Status>live|bootstrap|unavailable</Status>\n          <LastSyncTime>sync-time|<empty></LastSyncTime>\n      </GeoReplication>\n    </StorageServiceStats>\n    '''\n    if response is None or response.body is None:\n        return None\n\n    service_stats_element = ETree.fromstring(response.body)\n\n    geo_replication_element = service_stats_element.find('GeoReplication')\n\n    geo_replication = GeoReplication()\n    geo_replication.status = geo_replication_element.find('Status').text\n    geo_replication.last_sync_time = parser.parse(geo_replication_element.find('LastSyncTime').text)\n\n    service_stats = ServiceStats()\n    service_stats.geo_replication = geo_replication\n    return service_stats"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting the url for firmware update", "response": "def _get_firmware_update_element(self):\n        \"\"\"Get the url for firmware update\n\n        :returns: firmware update url\n        :raises: Missing resource error on missing url\n        \"\"\"\n        fw_update_action = self._actions.update_firmware\n        if not fw_update_action:\n            raise (sushy.exceptions.\n                   MissingActionError(action='#UpdateService.SimpleUpdate',\n                                      resource=self._path))\n        return fw_update_action"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nperforms firmware flashing on a redfish system.", "response": "def flash_firmware(self, redfish_inst,  file_url):\n        \"\"\"Perform firmware flashing on a redfish system\n\n        :param file_url: url to firmware bits.\n        :param redfish_inst: redfish instance\n        :raises: IloError, on an error from iLO.\n        \"\"\"\n        action_data = {\n            'ImageURI': file_url,\n        }\n        target_uri = self._get_firmware_update_element().target_uri\n        try:\n            self._conn.post(target_uri, data=action_data)\n        except sushy.exceptions.SushyError as e:\n            msg = (('The Redfish controller failed to update firmware '\n                    'with file %(file)s Error %(error)s') %\n                   {'file': file_url, 'error': str(e)})\n            LOG.debug(msg)  # noqa\n            raise exception.IloError(msg)\n\n        self.wait_for_redfish_firmware_update_to_complete(redfish_inst)\n        try:\n            state, percent = self.get_firmware_update_progress()\n        except sushy.exceptions.SushyError as e:\n            msg = ('Failed to get firmware progress update '\n                   'Error %(error)s' % {'error': str(e)})\n            LOG.debug(msg)\n            raise exception.IloError(msg)\n\n        if state == \"Error\":\n            msg = 'Unable to update firmware'\n            LOG.debug(msg)  # noqa\n            raise exception.IloError(msg)\n        elif state == \"Unknown\":\n            msg = 'Status of firmware update not known'\n            LOG.debug(msg)  # noqa\n        else:  # \"Complete\" | \"Idle\"\n            LOG.info('Flashing firmware file: %s ... done', file_url)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef wait_for_redfish_firmware_update_to_complete(self, redfish_object):\n        p_state = ['Idle']\n        c_state = ['Idle']\n\n        def has_firmware_flash_completed():\n            \"\"\"Checks for completion status of firmware update operation\n\n            The below table shows the conditions for which the firmware update\n            will be considered as DONE (be it success or error)::\n\n            +-----------------------------------+-----------------------------+\n            |    Previous state                 |   Current state             |\n            +===================================+=============================+\n            |    Idle                           |   Error, Complete           |\n            +-----------------------------------+-----------------------------+\n            |    Updating, Verifying,           |   Complete, Error,          |\n            |    Uploading, Writing             |   Unknown, Idle             |\n            +-----------------------------------+-----------------------------+\n\n            :returns: True upon firmware update completion otherwise False\n            \"\"\"\n            curr_state, curr_percent = self.get_firmware_update_progress()\n            p_state[0] = c_state[0]\n            c_state[0] = curr_state\n            if (((p_state[0] in ['Updating', 'Verifying',\n                                 'Uploading', 'Writing'])\n                    and (c_state[0] in ['Complete', 'Error',\n                                        'Unknown', 'Idle']))\n                    or (p_state[0] == 'Idle' and (c_state[0] in\n                                                  ['Complete', 'Error']))):\n                return True\n            return False\n\n        common.wait_for_operation_to_complete(\n            has_firmware_flash_completed,\n            delay_bw_retries=30,\n            failover_msg='iLO firmware update has failed.'\n        )\n        common.wait_for_ilo_after_reset(redfish_object)", "response": "This function polls for iLO firmware update to complete."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_firmware_update_progress(self):\n        # perform refresh\n        try:\n            self.refresh()\n        except sushy.exceptions.SushyError as e:\n            msg = (('Progress of firmware update not known. '\n                    'Error %(error)s') %\n                   {'error': str(e)})\n            LOG.debug(msg)\n            return \"Unknown\", \"Unknown\"\n\n        # NOTE: Percentage is returned None after firmware flash is completed.\n        return (self.firmware_state, self.firmware_percentage)", "response": "Get the progress of the firmware update."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef boot_settings(self):\n        return BIOSBootSettings(\n            self._conn, utils.get_subresource_path_by(\n                self, [\"Oem\", \"Hpe\", \"Links\", \"Boot\"]),\n            redfish_version=self.redfish_version)", "response": "Property to provide reference to bios boot instance\n           "}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef iscsi_resource(self):\n        return iscsi.ISCSIResource(\n            self._conn, utils.get_subresource_path_by(\n                self, [\"Oem\", \"Hpe\", \"Links\", \"iScsi\"]),\n            redfish_version=self.redfish_version)", "response": "Property to provide reference to bios iscsi resource instance"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef bios_mappings(self):\n        return BIOSMappings(\n            self._conn, utils.get_subresource_path_by(\n                self, [\"Oem\", \"Hpe\", \"Links\", \"Mappings\"]),\n            redfish_version=self.redfish_version)", "response": "Property to provide reference to bios mappings instance"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _get_base_configs(self):\n        return BIOSBaseConfigs(\n            self._conn, utils.get_subresource_path_by(\n                self, [\"Oem\", \"Hpe\", \"Links\", \"BaseConfigs\"]),\n            redfish_version=self.redfish_version)", "response": "Method that returns object of bios base configs."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef set_pending_boot_mode(self, boot_mode):\n        bios_properties = {\n            'BootMode': mappings.GET_BIOS_BOOT_MODE_MAP_REV.get(boot_mode)\n        }\n\n        if boot_mode == sys_cons.BIOS_BOOT_MODE_UEFI:\n            bios_properties['UefiOptimizedBoot'] = 'Enabled'\n\n        self.update_bios_data_by_patch(bios_properties)", "response": "Sets the boot mode of the system for next boot."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nupdates bios data by post", "response": "def update_bios_data_by_post(self, data):\n        \"\"\"Update bios data by post\n\n        :param data: default bios config data\n        \"\"\"\n        bios_settings_data = {\n            'Attributes': data\n        }\n        self._conn.post(self.path, data=bios_settings_data)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nupdates bios data by patch", "response": "def update_bios_data_by_patch(self, data):\n        \"\"\"Update bios data by patch\n\n        :param data: default bios config data\n        \"\"\"\n        bios_settings_data = {\n            'Attributes': data\n        }\n        self._conn.patch(self.path, data=bios_settings_data)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget the persistent boot device for the host.", "response": "def get_persistent_boot_device(self):\n        \"\"\"Get current persistent boot device set for the host\n\n        :returns: persistent boot device for the system\n        :raises: IloError, on an error from iLO.\n        \"\"\"\n        boot_string = None\n        if not self.persistent_boot_config_order or not self.boot_sources:\n            msg = ('Boot sources or persistent boot config order not found')\n            LOG.debug(msg)\n            raise exception.IloError(msg)\n\n        preferred_boot_device = self.persistent_boot_config_order[0]\n        for boot_source in self.boot_sources:\n            if ((boot_source.get(\"StructuredBootString\") is not None) and (\n                    preferred_boot_device ==\n                    boot_source.get(\"StructuredBootString\"))):\n                boot_string = boot_source[\"BootString\"]\n                break\n        else:\n            msg = (('Persistent boot device failed, as no matched boot '\n                    'sources found for device: %(persistent_boot_device)s')\n                   % {'persistent_boot_device': preferred_boot_device})\n            LOG.debug(msg)\n            raise exception.IloError(msg)\n\n        for key, value in BOOT_SOURCE_TARGET_TO_PARTIAL_STRING_MAP.items():\n            for val in value:\n                if val in boot_string:\n                    return key\n        return sushy.BOOT_SOURCE_TARGET_NONE"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_uefi_boot_string(self, mac):\n        boot_sources = self.boot_sources\n        if not boot_sources:\n            msg = ('Boot sources are not found')\n            LOG.debug(msg)\n            raise exception.IloError(msg)\n\n        for boot_source in boot_sources:\n            if (mac.upper() in boot_source['UEFIDevicePath'] and\n                    'iSCSI' in boot_source['UEFIDevicePath']):\n                return boot_source['StructuredBootString']\n        else:\n            msg = ('MAC provided \"%s\" is Invalid' % mac)\n            raise exception.IloInvalidInputError(msg)", "response": "Get uefi boot string for the host and system."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the viscosity of a single Molecular plasma.", "response": "def visc_mol_sol(T,rho,X):\n    '''\n    Molecular plasma viscosity (Spitzer 1962)\n    \n    Parameters\n    ----------\n    X : float\n       H mass fraction\n    T : float\n       temperature in K\n    rho : float\n       density in cgs\n\n    Returns\n    -------\n    nu : float\n       molecular diffusivity in [cm**2/s]\n\n    Notes\n    -----\n    According to Eq 22 in Schatzman (1977). Assume log Lambda = 15. \n    (see Table 5.1), a H/He mix (for different mix use Eq. 5.54 in\n    Spitzer text book)\n\n    Examples\n    --------\n    see astronomy.visc_rad_kap_sc\n\n    '''\n    visc_mol = 1.84e-17*(1.+7.*X)*(old_div(T**2.5,rho))\n    return visc_mol"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef visc_rad_kap_sc(T,rho,X):\n    '''\n    Radiative viscosity (Thomas, 1930) for e- scattering opacity\n\n    Parameters\n    ----------\n    X : float\n       H mass fraction\n    T : float\n       temperature in K\n    rho : float\n       density in cgs\n\n    Returns\n    -------\n    nu : float\n       radiative diffusivity in [cm**2/s]\n\n    Examples\n    --------\n    >>> In [1]: import astronomy as ast\n    >>> In [2]: l = 100*1.e5 # 100km\n    >>> In [3]: v = 1.e5     # typical velocity\n    >>> In [4]: T   = 90.e6  # temperature\n    >>> In [5]: X   = 0.001  # H mass fraction\n    >>> In [6]: rho = 100.   # density\n    >>> In [7]: nu = ast.visc_rad_kap_sc(T,rho,X)\n    >>> In [8]: Re=v*l/nu\n    >>> In [9]: print \"Re_rad = \"+str('%g'%Re)\n    >>> Re_rad = 4.43512e+08\n\n    Notes\n    -----\n    Eqn. 14' in Schatzman, 1977, assume electron scattering opacity\n    kappa_sc = 0.2*(1+X), Kippenhahn (2nd edn, Eqn 17.2)\n\n    '''\n    kappa = 0.2*(1.+X)\n    nu_rad = 6.88e-26*(old_div(T**4,(kappa*rho**2)))\n    return nu_rad", "response": "Radiative viscosity for electron scattering opacity in Schatzman 1930"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef Gamma1_gasrad(beta):\n    ''' \n    Gamma1 for a mix of ideal gas and radiation\n\n    Hansen & Kawaler, page 177, Eqn. 3.110\n    \n    Parameters\n    ----------\n    beta : float\n        Gas pressure fraction Pgas/(Pgas+Prad)\n\n    '''\n    Gamma3minus1 = (old_div(2.,3.))*(4.-3.*beta)/(8.-7.*beta) \n    Gamma1 = beta + (4.-3.*beta) * Gamma3minus1\n    return Gamma1", "response": "Returns the Gamma1 for a mix of ideal gas and radiation."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the Pas of a base - class resource with the given mean molecular weight rho T and mu.", "response": "def Pgas(rho,T,mu):\n    ''' \n    P = R/mu * rho * T\n\n    Parameters\n    ----------\n    mu : float\n        Mean molecular weight\n    rho : float\n        Density [cgs]\n    T : float\n        Temperature [K]\n\n    '''\n    R = old_div(boltzmann_constant, atomic_mass_unit)\n    return (old_div(R,mu)) * rho * T"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef mimf_ferrario(mi):\n    ''' Curvature MiMf from Ferrario etal. 2005MNRAS.361.1131.'''\n    \n    mf=-0.00012336*mi**6+0.003160*mi**5-0.02960*mi**4+\\\n      0.12350*mi**3-0.21550*mi**2+0.19022*mi+0.46575\n    return mf", "response": "Curvature MiMf from Ferrario etal. 2005MNRAS. 361. 1131."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef imf(m):\n    ''' \n    Returns\n    -------\n    N(M)dM\n        for given mass according to Kroupa IMF, vectorization\n        available via vimf() \n\n    '''\n\n    m1 = 0.08; m2 = 0.50\n    a1 = 0.30; a2 = 1.30; a3 = 2.3\n    const2 = m1**-a1 -m1**-a2 \n    const3 = m2**-a2 -m2**-a3 \n\n    if m < 0.08:\n        alpha = 0.3\n        const = -const2 -const3\n    elif m < 0.50:\n        alpha = 1.3\n        const = -const3\n    else:\n        alpha = 2.3\n        const = 0.0\n    # print m,alpha, const, m**-alpha + const \n    return m**-alpha + const", "response": "Returns N M according to Kroupa IMF"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef int_imf_dm(m1,m2,m,imf,bywhat='bymass',integral='normal'):\n    ''' \n    Integrate IMF between m1 and m2.\n\n    Parameters\n    ----------\n    m1 : float\n        Min mass\n    m2 : float\n        Max mass\n    m : float\n        Mass array\n    imf : float\n        IMF array\n    bywhat : string, optional\n        'bymass' integrates the mass that goes into stars of\n        that mass interval; or 'bynumber' which integrates the number\n        of stars in that mass interval.  The default is 'bymass'.\n    integrate : string, optional\n        'normal' uses sc.integrate.trapz; 'cum' returns cumulative\n        trapezoidal integral.  The default is 'normal'.\n\n    '''\n\n\n    ind_m = (m >= min(m1,m2)) & (m <= max(m1,m2))\n    if integral is 'normal':\n        int_func = sc.integrate.trapz\n    elif integral is 'cum':\n        int_func = sc.integrate.cumtrapz\n    else:\n        print(\"Error in int_imf_dm: don't know how to integrate\")\n        return 0\n       \n    if bywhat is 'bymass':\n        return int_func(m[ind_m]*imf[ind_m],m[ind_m])\n    elif bywhat is 'bynumber':\n        return int_func(imf[ind_m],m[ind_m])\n    else:\n        print(\"Error in int_imf_dm: don't know by what to integrate\")\n        return 0", "response": "Integrate IMF between m1 and m2."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncalculate the orbital angular momentum for two sets of species A and A and e. g Ge etal2010", "response": "def am_orb(m1,m2,a,e):\n    ''' \n    orbital angular momentum.\n\n    e.g Ge etal2010\n    \n    Parameters\n    ----------\n    m1, m2 : float\n        Masses of both stars in Msun.\n    A : float \n        Separation in Rsun.\n    e : float\n        Eccentricity\n        \n    '''\n\n    a_cm  = a * rsun_cm\n    m1_g = m1 * msun_g\n    m2_g = m2 * msun_g\n\n    J_orb=np.sqrt(grav_const*a_cm*(old_div((m1_g**2*m2_g**2),(m1_g+m2_g))))*(1-e**2)\n    return J_orb"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef mass_loss_loon05(L,Teff):\n    ''' \n    mass loss rate van Loon etal (2005).\n\n    Parameters\n    ----------\n    L : float\n        L in L_sun.\n    Teff : float\n        Teff in K.\n        \n    Returns\n    -------\n    Mdot\n        Mdot in Msun/yr\n    \n    Notes\n    -----\n    ref: van Loon etal 2005, A&A 438, 273\n    \n    '''\n    \n    Mdot = -5.65 + np.log10(old_div(L,10.**4)) -6.3*np.log10(old_div(Teff,3500.))\n    return Mdot", "response": "Returns the mass loss rate in Msun for a given log L and temperature."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef energ_orb(m1,m2,r):\n    ''' \n    Parameters\n    ----------\n    m1, m2 : float\n        M in Msun.\n    r : float\n        Distance in Rsun.\n        \n    Returns\n    -------\n    Epot\n        Epot in erg.\n        \n    '''\n    epo = -grav_const * m1 * m2 * msun_g**2 / (r * rsun_cm)\n    return epo", "response": "Calculates the Energ orbit of a set of species in the system."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncalculates the binary period from a separation A M1 and M2.", "response": "def period(A,M1,M2):\n    \"\"\" \n    calculate binary period from separation. \n\n    Parameters\n    ----------\n    A : float\n        separation A Rsun.\n    M1, M2 : float\n        M in Msun.\n\n    Returns\n    -------\n    p\n        period in days.\n\n    \"\"\"\n\n    A *= rsun_cm\n    print(A)\n    velocity = np.sqrt(grav_const*msun_g*(M1+M2)/A)\n    print(old_div(velocity,1.e5))\n    \n    p = 2.*np.pi * A / velocity\n\n    p  /= (60*60*24.)\n    return p"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the escape velocity of a single object in the solar masses and solar radiu.", "response": "def escape_velocity(M,R):\n    \"\"\" \n    escape velocity.\n    \n    Parameters\n    ----------\n    M : float\n        Mass in solar masses.\n    R : float\n        Radius in solar radiu.\n\n    Returns\n    -------\n    v_escape\n        in km/s.\n        \n    \"\"\"\n\n    ve = np.sqrt(2.*grav_const*M*msun_g/(R*rsun_cm))\n    ve = ve*1.e-5\n    return ve"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the total number of masses in a single node", "response": "def Nasv(macs,T):\n    ''' \n    Returns\n    -------\n    Na*<sigma v>\n        for MACS [mb] at T [K].\n        \n    '''\n\n    Na = avogadro_constant\n    k  = boltzmann_constant\n    vtherm=(2.*k*T/mass_H_atom)**0.5\n\n    s  = macs*1.e-27\n    Nasv = s*vtherm*Na\n    return Nasv"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the MACS of a single site at a given mass at a given time.", "response": "def macs(nasv,T):\n    ''' \n    Returns\n    -------\n    MACS\n        [mb] at T [K] from Na*<sigma v>.\n                                        \n    '''\n\n    Na = avogadro_constant\n    k  = boltzmann_constant\n    vtherm=(2.*k*T/mass_H_atom)**0.5\n\n    s      = old_div(nasv,(vtherm*Na))\n    macs   = s*1.e27\n    return macs"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the mean molecular weight per free electron assuming full ionisation and mu_i approximating mu_i / Z_i ~ 2 for all elements heavier then Helium.", "response": "def mu_e(X):\n    ''' \n    mean molecular weight per free electron, assuming full ionisation, and\n    approximating mu_i/Z_i ~ 2 for all elements heavier then Helium.\n    \n    (Kippenhahn & Weigert, Ch 13.1, Eq. 13.8)\n    \n    Parameters\n    ----------\n    X : float\n        Mass fraction of H.\n    \n    '''\n\n    try:\n        mu_e = old_div(2.,(1.+X))\n    except TypeError:\n        X=np.array([X])\n        mu_e = old_div(2.,(1.+X))\n\n    return mu_e"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef mu(X,Z,A):\n    ''' \n    mean molecular weight assuming full ionisation.\n\n    (Kippenhahn & Weigert, Ch 13.1, Eq. 13.6)\n    \n    Parameters\n    ----------\n    X : float\n        Mass fraction vector.\n    Z : float\n        Charge number vector.\n    A : float\n        Mass number vector.\n        \n    '''\n    \n    if not isinstance(Z,np.ndarray):\n        Z = np.array(Z)\n    if not isinstance(A,np.ndarray):\n        A = np.array(A)\n    if not isinstance(X,np.ndarray):\n        X = np.array(X)\n    \t\n    try:\n        mu = old_div(1.,sum(X*(1.+Z)/A))\n    except TypeError:\n        X=np.array([X])\n        A=np.array([A])\n        Z=np.array([Z])\n        mu = old_div(1.,sum(X*(1.+Z)/A))\n\n    return mu", "response": "returns the mean molecular weight assuming full ionisation."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef Trho_iddeg(rho,mu,mu_e):\n    ''' \n    T(rho) that separates ideal gas and degenerate pressure dominated regions.\n\n    Kippenhahn & Weigert, Eq. 16.6\n\n    Parameters\n    ----------\n    rho : float\n        Density array [cgs].\n    mu : float\n        Mean molecular weight.\n    mu_e : float\n        Mean molecular weight per free electron.\n        \n    '''\n\n    T = 1.207E5 * rho**(old_div(2.,3.)) * mu / mu_e**(old_div(5.,3.))\n    return T", "response": "Returns T that separates ideal gas and degenerate pressure dominated regions."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _get_criteria_matching_disks(logical_disk, physical_drives):\n    matching_physical_drives = []\n    criteria_to_consider = [x for x in FILTER_CRITERIA\n                            if x in logical_disk]\n\n    for physical_drive_object in physical_drives:\n        for criteria in criteria_to_consider:\n            logical_drive_value = logical_disk.get(criteria)\n            physical_drive_value = getattr(physical_drive_object, criteria)\n            if logical_drive_value != physical_drive_value:\n                break\n        else:\n            matching_physical_drives.append(physical_drive_object)\n\n    return matching_physical_drives", "response": "This method finds the physical drives matching the criteria of the logical disk."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef allocate_disks(logical_disk, server, raid_config):\n    size_gb = logical_disk['size_gb']\n    raid_level = logical_disk['raid_level']\n    number_of_physical_disks = logical_disk.get(\n        'number_of_physical_disks', constants.RAID_LEVEL_MIN_DISKS[raid_level])\n    share_physical_disks = logical_disk.get('share_physical_disks', False)\n\n    # Try to create a new independent array for this request.\n    for controller in server.controllers:\n        physical_drives = controller.unassigned_physical_drives\n        physical_drives = _get_criteria_matching_disks(logical_disk,\n                                                       physical_drives)\n\n        if size_gb != \"MAX\":\n            # If we want to allocate for a logical disk for which size_gb is\n            # mentioned, we take the smallest physical drives which is required\n            # to match the criteria.\n            reverse_sort = False\n            physical_drives = [x for x in physical_drives\n                               if x.size_gb >= size_gb]\n        else:\n            # If we want to allocate for a logical disk for which size_gb is\n            # MAX, we take the largest physical drives available.\n            reverse_sort = True\n\n        if len(physical_drives) >= number_of_physical_disks:\n            selected_drives = sorted(physical_drives, key=lambda x: x.size_gb,\n                                     reverse=reverse_sort)\n            selected_drive_ids = [x.id for x in selected_drives]\n            logical_disk['controller'] = controller.id\n            physical_disks = selected_drive_ids[:number_of_physical_disks]\n            logical_disk['physical_disks'] = physical_disks\n            return\n\n    # We didn't find physical disks to create an independent array.\n    # Check if we can get some shared arrays.\n    if share_physical_disks:\n        sharable_disk_wwns = []\n        for sharable_logical_disk in raid_config['logical_disks']:\n            if (sharable_logical_disk.get('share_physical_disks', False) and\n                    'root_device_hint' in sharable_logical_disk):\n                wwn = sharable_logical_disk['root_device_hint']['wwn']\n                sharable_disk_wwns.append(wwn)\n\n        for controller in server.controllers:\n            sharable_arrays = [x for x in controller.raid_arrays if\n                               x.logical_drives[0].wwn in sharable_disk_wwns]\n\n            for array in sharable_arrays:\n\n                # Check if criterias for the logical disk match the ones with\n                # physical disks in the raid array.\n                criteria_matched_disks = _get_criteria_matching_disks(\n                    logical_disk, array.physical_drives)\n\n                # Check if all disks in the array don't match the criteria\n                if len(criteria_matched_disks) != len(array.physical_drives):\n                    continue\n\n                # Check if raid array can accomodate the logical disk.\n                if array.can_accomodate(logical_disk):\n                    logical_disk['controller'] = controller.id\n                    logical_disk['array'] = array.id\n                    return\n\n    # We check both options and couldn't get any physical disks.\n    raise exception.PhysicalDisksNotFoundError(size_gb=size_gb,\n                                               raid_level=raid_level)", "response": "Allocate physical disks to a logical disk."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef trajectory_SgConst(Sg=0.1, delta_logt_dex=-0.01):\n    '''\n    setup trajectories for constant radiation entropy.\n\n    S_gamma/R where the radiation constant R = N_A*k\n    (Dave Arnett, Supernova book, p. 212)\n    This relates rho and T but the time scale for this\n    is independent.\n\n    Parameters\n    ----------\n    Sg : float\n        S_gamma/R, values between 0.1 and 10. reflect conditions in\n        massive stars.  The default is 0.1.\n    delta_logt_dex : float\n        Sets interval between time steps in dex of logtimerev.  The\n        default is -0.01.\n\n    '''\n\n    # reverse logarithmic time\n    logtimerev=np.arange(5.,-6.,delta_logt_dex)\n    logrho=np.linspace(0,8.5,len(logtimerev))\n    logT = (old_div(1.,3.))*(logrho + 21.9161 + np.log10(Sg))\n\n    #rho_6=10**logrho/(0.1213*1.e6)\n    #T9=rho_6**(1./3.)\n    #logT_T3=np.log10(T9*1.e9)\n\n\n    pl.close(3);pl.figure(3);pl.plot(logrho,logT,label='$S/\\mathrm{N_Ak}='+str(Sg)+'$')\n    pl.legend(loc=2);pl.xlabel('$\\log \\\\rho$'); pl.ylabel('$\\log T$')\n    pl.close(5);pl.figure(5);pl.plot(logtimerev, logrho)\n    pl.xlabel('$\\log (t_\\mathrm{final}-t)$'); pl.ylabel('$\\log \\\\rho$')\n    pl.xlim(8,-6)\n\n    pl.close(6);pl.figure(6);pl.plot(logtimerev)\n    pl.ylabel('$\\log (t_\\mathrm{final}-t)$'); pl.xlabel('cycle')\n\n    # [t] logtimerev yrs\n    # [rho] cgs\n    # [T]   K\n\n    T9=old_div(10**logT,1.e9)\n    data=[logtimerev,T9,logrho]\n    att.writeTraj(filename='trajectory.input', data=data, ageunit=2, tunit=1, rhounit=1, idNum=1)", "response": "setup trajectories for constant radiation entropy."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a list of lists of elements to plot.", "response": "def species_list(what_list):\n    '''\n    provide default lists of elements to plot.\n\n    what_list : string\n        String name of species lists provided.\n\n        If what_list is \"CNONe\", then C, N, O and some other light\n        elements.\n\n        If what_list is \"s-process\", then s-process indicators.\n\n    '''\n    if what_list is \"CNONe\":\n        list_to_print = ['H-1','He-4','C-12','N-14','O-16','Ne-20']\n    elif what_list is \"sprocess\":\n        list_to_print = ['Fe-56','Ge-70','Zn-70','Se-76','Kr-80','Kr-82','Kr-86','Sr-88','Ba-138','Pb-208']\n    elif what_list is \"burn_stages\":\n        list_to_print = ['H-1','He-4','C-12','O-16','Ne-20','Si-28']\n    elif what_list is \"list_marco_1\":\n        list_to_print = ['C-12','O-16','Ne-20','Ne-22','Na-23','Fe-54','Fe-56','Zn-70','Ge-70','Se-76','Kr-80','Kr-82','Sr-88','Y-89','Zr-96','Te-124','Xe-130','Xe-134','Ba-138']\n\n    return list_to_print"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef linestyle(i,a=5,b=3):\n    '''\n    provide one out of 25 unique combinations of style, color and mark\n\n    use in combination with markevery=a+mod(i,b) to add spaced points,\n    here a would be the base spacing that would depend on the data\n    density, modulated with the number of lines to be plotted (b)\n\n    Parameters\n    ----------\n    i : integer\n        Number of linestyle combination - there are many....\n    a : integer\n        Spacing of marks.  The default is 5.\n    b : integer\n        Modulation in case of plotting many nearby lines.  The default\n        is 3.\n\n    Examples\n    --------\n\n    >>> plot(x,sin(x),linestyle(7)[0], markevery=linestyle(7)[1])\n\n\n    (c) 2014 FH\n    '''\n\n    lines=['-','--','-.',':']\n    points=['v','^','<','>','1','2','3','4','s','p','*','h','H','+','x','D','d','o']\n    colors=['b','g','r','c','m','k']\n    ls_string = colors[sc.mod(i,6)]+lines[sc.mod(i,4)]+points[sc.mod(i,18)]\n    mark_i    = a+sc.mod(i,b)\n    return ls_string,int(mark_i)", "response": "This function returns a string and the number of lines that are plotted in a specific style."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef colourblind(i):\n    '''\n        colour pallete from http://tableaufriction.blogspot.ro/\n        allegedly suitable for colour-blind folk\n\n        SJ\n    '''\n\n    rawRGBs = [(162,200,236),\n               (255,128,14),\n               (171,171,171),\n               (95,158,209),\n               (89,89,89),\n               (0,107,164),\n               (255,188,121),\n               (207,207,207),\n               (200,82,0),\n               (137,137,137)]\n\n    scaledRGBs = []\n    for r in rawRGBs:\n        scaledRGBs.append((old_div(r[0],255.),old_div(r[1],255.),old_div(r[2],255.)))\n\n    idx = sc.mod(i,len(scaledRGBs))\n    return scaledRGBs[idx]", "response": "colour blinding for a single item in the base image"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets another colour pallete from http://www. sron. nl/~pault / allegedly suitable for colour - blend folk SJ", "response": "def colourblind2(i):\n    '''\n        another colour pallete from http://www.sron.nl/~pault/\n        allegedly suitable for colour-blind folk\n\n        SJ\n    '''\n\n    hexcols = ['#332288', '#88CCEE', '#44AA99', '#117733', '#999933', '#DDCC77',\n               '#CC6677', '#882255', '#AA4499']\n    idx = sc.mod(i,len(hexcols))\n    return hexcols[idx]"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef linestylecb(i,a=5,b=3):\n    '''\n        version of linestyle function with colourblind colour scheme\n\n        returns linetyle, marker, color (see example)\n\n        Parameters\n        ----------\n        i : integer\n        Number of linestyle combination - there are many....\n        a : integer\n        Spacing of marks.  The default is 5.\n        b : integer\n        Modulation in case of plotting many nearby lines.  The default\n        is 3.\n\n        Examples\n        --------\n\n        >>> plot(x,sin(x),ls=linestyle(7)[0], marker=linestyle(7)[1], \\\n                 color=linestyle(7)[2],markevery=linestyle(7)[3])\n\n\n        (c) 2014 FH\n        '''\n\n    lines=['-','--','-.',':']\n    points=['v','^','<','>','1','2','3','4','s','p','*','h','H','+','x','D','d','o']\n    colors=['b','g','r','c','m','k']\n    col=colourblind(i)\n    style=lines[sc.mod(i,4)]\n    point=points[sc.mod(i,18)]\n    mark_i    = a+sc.mod(i,b)\n    return style,point,col,mark_i", "response": "version of linestyle function with colourblind colour scheme"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a list of all possible symbol lists for the current language", "response": "def symbol_list(what_list):\n    '''\n    provide default symbol lists\n\n    Parameters\n    ----------\n    what_list : string\n        String name of symbol lists provided; \"list1\", \"list2\",\n        \"lines1\" or \"lines2\".\n\n    '''\n    if what_list is \"list1\":\n        symbol=['ro','bo','ko','go','mo'\\\n                ,'r-','b-','k-','g-','m-','r--','b--','k--'\\\n                ,'g--','r1']\n        #symbol=['r+','ro','r-']\n    elif what_list is \"list2\":\n        symbol=['r-','b--','g-.','k:','md','.','o','v','^','<','>','1','2',\\\n                '3','4','s','p','*','h','H','+']\n    elif what_list is \"lines1\":\n        symbol=['b--','k--','r--','c--','m--','g--','b-','k-','r-','c-','m-','g-','b.','b-.','k-.','r-.','c-.','m-.','g-.','b:','k:','r:','c:','m:','g:']\n    elif what_list is \"lines2\":\n        symbol=['g:','r-.','k-','b--','k-.','b+','r:','b-','c--','m--','g--','r-','c-','m-','g-','k-.','c-.','m-.','g-.','k:','r:','c:','m:','b-.','b:']\n    return symbol"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef make_list(default_symbol_list, len_list_to_print):\n    '''\n    provide the list of symbols to use according for the list of\n    species/arrays to plot.\n\n    Parameters\n    ----------\n    default_symbol_list : list\n        Symbols that the user choose to use.\n    len_list_to_print : integer\n        len of list of species/arrays to print.\n\n    '''\n\n    symbol_used = []\n    for i in range(len_list_to_print):\n        symbol_used.append(default_symbol_list[sc.mod(i,len(default_symbol_list))])\n\n    return symbol_used", "response": "This function creates a list of symbols that the user choose to use according for the list of species and arrays to plot."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef strictly_monotonic(bb):\n    '''\n    bb is an index array which may have numerous double or triple\n    occurrences of indices, such as for example the decay_index_pointer.\n    This method removes all entries <= -, then all dublicates and\n    finally returns a sorted list of indices.\n\n    '''\n    cc=bb[np.where(bb>=0)]\n    cc.sort()\n    dc=cc[1:]-cc[:-1] # subsequent equal entries have 0 in db\n    dc=np.insert(dc,0,1) # the first element is always unique (the second occurence is the dublicate)\n    dc_mask=np.ma.masked_equal(dc,0)\n    return np.ma.array(cc,mask=dc_mask.mask).compressed()", "response": "This method returns a sorted list of indices that are strictly monotonic."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef solar(filename_solar, solar_factor):\n    '''\n    read solar abundances from filename_solar.\n\n    Parameters\n    ----------\n    filename_solar : string\n        The file name.\n    solar_factor : float\n        The correction factor to apply, in case filename_solar is not\n        solar, but some file used to get initial abundances at\n        metallicity lower than solar. However, notice that this is\n        really rude, since alpha-enahncements and things like that are\n        not properly considered.  Only H and He4 are not multiplied. So,\n        for publications PLEASE use proper filename_solar at...solar,\n        and use solar_factor = 1. Marco\n\n    '''\n\n    f0=open(filename_solar)\n    sol=f0.readlines()\n    f0.close\n    sol[0].split(\"         \")\n\n    # Now read in the whole file and create a hashed array:\n    global names_sol\n    names_sol=[]\n    global z_sol\n    z_sol=[]\n    yps=np.zeros(len(sol))\n    mass_number=np.zeros(len(sol))\n    for i in range(len(sol)):\n        z_sol.append(int(sol[i][1:3]))\n        names_sol.extend([sol[i].split(\"         \")[0][4:]])\n        yps[i]=float(sol[i].split(\"         \")[1]) * solar_factor\n        try:\n            mass_number[i]=int(names_sol[i][2:5])\n        except ValueError:\n            print(\"WARNING:\")\n            print(\"This initial abundance file uses an element name that does\")\n            print(\"not contain the mass number in the 3rd to 5th position.\")\n            print(\"It is assumed that this is the proton and we will change\")\n            print(\"the name to 'h   1' to be consistent with the notation used in\")\n            print(\"iniab.dat files\")\n            names_sol[i]='h   1'\n            mass_number[i]=int(names_sol[i][2:5])\n        if mass_number[i] == 1 or mass_number[i] == 4:\n            yps[i] = old_div(yps[i],solar_factor)\n    #  convert 'h   1' in prot, not needed any more??\n    #names_sol[0] = 'prot '\n\n\n    # now zip them together:\n    global solar_abundance\n    solar_abundance={}\n    for a,b in zip(names_sol,yps):\n        solar_abundance[a] = b\n\n\n\n    z_bismuth = 83\n    global solar_elem_abund\n    solar_elem_abund = np.zeros(z_bismuth)\n\n\n    for i in range(z_bismuth):\n        dummy = 0.\n        for j in range(len(solar_abundance)):\n            if z_sol[j] == i+1:\n                dummy = dummy + float(solar_abundance[names_sol[j]])\n        solar_elem_abund[i] = dummy", "response": "Reads the solar abundances from filename_solar and creates a hashed array of solar abundances."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef convert_specie_naming_from_h5_to_ppn(isotope_names):\n    '''\n    read isotopes names from h5 files, and convert them\n    according to standard scheme used inside ppn and mppnp.  Also\n    Z and A are recalculated, for these species. Isomers are\n    excluded for now, since there were recent changes in isomers\n    name. As soon as the isomers names are settled, than Z and A\n    provided here will be obsolete, and can be changed by usual Z\n    and A.\n\n    '''\n\n    spe_rude1 = []\n    spe_rude2 = []\n    spe_rude3 = []\n    for i in range(len(isotope_names)):\n        spe_rude1.append(isotope_names[i].split('-')[0])\n        spe_rude2.append(isotope_names[i].split('-')[1])\n    # spe_rude1 is elem name and spe_rude2 is mass number.\n    #print spe_rude1,spe_rude2\n    k = 0\n    for i in range(len(spe_rude1)):\n        try:\n            if int(spe_rude2[i]) < 10:\n                spe_rude3.append(str(spe_rude1[i][0:2])+str('  ')+str(spe_rude2[i][0:3]))\n            elif int(spe_rude2[i]) >= 10 and int(spe_rude2[i]) < 100 :\n                spe_rude3.append(str(spe_rude1[i][0:2])+str(' ')+str(spe_rude2[i][0:3]))\n            elif int(spe_rude2[i]) >= 100 :\n                spe_rude3.append(str(spe_rude1[i][0:2])+str(spe_rude2[i][0:3]))\n        except ValueError:\n            k = k+1\n            None\n\n    global spe\n    spe = []\n    global n_array\n    n_array = []\n    for i in range(len(spe_rude3)):\n        if len(str(spe_rude1[i])) == 1:\n            spe.append(str(spe_rude3[i][0:1])+str(' ')+str(spe_rude3[i][1:4]))\n        else:\n            spe.append(spe_rude3[i])\n        n_array.append(i)\n    if spe[0]=='Ne  1':\n        spe[0] = 'N   1'\n\n    # spe_rude is the isotope name, in agreement with what we use in ppn, etc.\n    # need to do this to can use other functions without changing them drastically.\n\n\n\n    # here I skip isomers...\n    global amass_int\n    amass_int=np.zeros(len(spe_rude2))\n    for i in range(len(spe_rude2)-k):\n        amass_int[i]=int(spe_rude2[i])\n        #print amass_int\n\n\n    # here I have to create an array for the atomic numbers.\n    # I need to this when I calculate and plot element abundances\n\n    global znum_int\n    znum_int=np.zeros(len(spe))\n\n    for i in range(len(spe)):\n        znum_int[i] = Utils.elements_names.index(str(spe[i][0:2]).strip())\n        # changed by alex\n        # if str(spe[i][0:2]) == 'H ':\n        #     znum_int[i] = 1\n        # elif str(spe[i][0:2]) == 'He':\n        #     znum_int[i] = 2\n        # elif str(spe[i][0:2]) == 'Li':\n        #     znum_int[i] = 3\n        # elif str(spe[i][0:2]) == 'Be':\n        #     znum_int[i] = 4\n        # elif str(spe[i][0:2]) == 'B ':\n        #     znum_int[i] = 5\n        # elif str(spe[i][0:2]) == 'C ':\n        #     znum_int[i] = 6\n        # elif str(spe[i][0:2]) == 'N ':\n        #     znum_int[i] = 7\n        # elif str(spe[i][0:2]) == 'O ':\n        #     znum_int[i] = 8\n        # elif str(spe[i][0:2]) == 'F ':\n        #     znum_int[i] = 9\n        # elif str(spe[i][0:2]) == 'Ne':\n        #     znum_int[i] = 10\n        # elif str(spe[i][0:2]) == 'Na':\n        #     znum_int[i] = 11\n        # elif str(spe[i][0:2]) == 'Mg':\n        #     znum_int[i] = 12\n        # elif str(spe[i][0:2]) == 'Al':\n        #     znum_int[i] = 13\n        # elif str(spe[i][0:2]) == 'Si':\n        #     znum_int[i] = 14\n        # elif str(spe[i][0:2]) == 'P ':\n        #     znum_int[i] = 15\n        # elif str(spe[i][0:2]) == 'S ':\n        #     znum_int[i] = 16\n        # elif str(spe[i][0:2]) == 'Cl':\n        #     znum_int[i] = 17\n        # elif str(spe[i][0:2]) == 'Ar':\n        #     znum_int[i] = 18\n        # elif str(spe[i][0:2]) == 'K ':\n        #     znum_int[i] = 19\n        # elif str(spe[i][0:2]) == 'Ca':\n        #     znum_int[i] = 20\n        # elif str(spe[i][0:2]) == 'Sc':\n        #     znum_int[i] = 21\n        # elif str(spe[i][0:2]) == 'Ti':\n        #     znum_int[i] = 22\n        # elif str(spe[i][0:2]) == 'V ':\n        #     znum_int[i] = 23\n        # elif str(spe[i][0:2]) == 'Cr':\n        #     znum_int[i] = 24\n        # elif str(spe[i][0:2]) == 'Mn':\n        #     znum_int[i] = 25\n        # elif str(spe[i][0:2]) == 'Fe':\n        #     znum_int[i] = 26\n        # elif str(spe[i][0:2]) == 'Co':\n        #     znum_int[i] = 27\n        # elif str(spe[i][0:2]) == 'Ni':\n        #     znum_int[i] = 28\n        # elif str(spe[i][0:2]) == 'Cu':\n        #     znum_int[i] = 29\n        # elif str(spe[i][0:2]) == 'Zn':\n        #     znum_int[i] = 30\n        # elif str(spe[i][0:2]) == 'Ga':\n        #     znum_int[i] = 31\n        # elif str(spe[i][0:2]) == 'Ge':\n        #     znum_int[i] = 32\n        # elif str(spe[i][0:2]) == 'As':\n        #     znum_int[i] = 33\n        # elif str(spe[i][0:2]) == 'Se':\n        #     znum_int[i] = 34\n        # elif str(spe[i][0:2]) == 'Br':\n        #     znum_int[i] = 35\n        # elif str(spe[i][0:2]) == 'Kr':\n        #     znum_int[i] = 36\n        # elif str(spe[i][0:2]) == 'Rb':\n        #     znum_int[i] = 37\n        # elif str(spe[i][0:2]) == 'Sr':\n        #     znum_int[i] = 38\n        # elif str(spe[i][0:2]) == 'Y ':\n        #     znum_int[i] = 39\n        # elif str(spe[i][0:2]) == 'Zr':\n        #     znum_int[i] = 40\n        # elif str(spe[i][0:2]) == 'Nb':\n        #     znum_int[i] = 41\n        # elif str(spe[i][0:2]) == 'Mo':\n        #     znum_int[i] = 42\n        # elif str(spe[i][0:2]) == 'Tc':\n        #     znum_int[i] = 43\n        # elif str(spe[i][0:2]) == 'Ru':\n        #     znum_int[i] = 44\n        # elif str(spe[i][0:2]) == 'Rh':\n        #     znum_int[i] = 45\n        # elif str(spe[i][0:2]) == 'Pd':\n        #     znum_int[i] = 46\n        # elif str(spe[i][0:2]) == 'Ag':\n        #     znum_int[i] = 47\n        # elif str(spe[i][0:2]) == 'Cd':\n        #     znum_int[i] = 48\n        # elif str(spe[i][0:2]) == 'In':\n        #     znum_int[i] = 49\n        # elif str(spe[i][0:2]) == 'Sn':\n        #     znum_int[i] = 50\n        # elif str(spe[i][0:2]) == 'Sb':\n        #     znum_int[i] = 51\n        # elif str(spe[i][0:2]) == 'Te':\n        #     znum_int[i] = 52\n        # elif str(spe[i][0:2]) == 'I ':\n        #     znum_int[i] = 53\n        # elif str(spe[i][0:2]) == 'Xe':\n        #     znum_int[i] = 54\n        # elif str(spe[i][0:2]) == 'Cs':\n        #     znum_int[i] = 55\n        # elif str(spe[i][0:2]) == 'Ba':\n        #     znum_int[i] = 56\n        # elif str(spe[i][0:2]) == 'La':\n        #     znum_int[i] = 57\n        # elif str(spe[i][0:2]) == 'Ce':\n        #     znum_int[i] = 58\n        # elif str(spe[i][0:2]) == 'Pr':\n        #     znum_int[i] = 59\n        # elif str(spe[i][0:2]) == 'Nd':\n        #     znum_int[i] = 60\n        # elif str(spe[i][0:2]) == 'Pm':\n        #     znum_int[i] = 61\n        # elif str(spe[i][0:2]) == 'Sm':\n        #     znum_int[i] = 62\n        # elif str(spe[i][0:2]) == 'Eu':\n        #     znum_int[i] = 63\n        # elif str(spe[i][0:2]) == 'Gd':\n        #     znum_int[i] = 64\n        # elif str(spe[i][0:2]) == 'Tb':\n        #     znum_int[i] = 65\n        # elif str(spe[i][0:2]) == 'Dy':\n        #     znum_int[i] = 66\n        # elif str(spe[i][0:2]) == 'Ho':\n        #     znum_int[i] = 67\n        # elif str(spe[i][0:2]) == 'Er':\n        #     znum_int[i] = 68\n        # elif str(spe[i][0:2]) == 'Tm':\n        #     znum_int[i] = 69\n        # elif str(spe[i][0:2]) == 'Yb':\n        #     znum_int[i] = 70\n        # elif str(spe[i][0:2]) == 'Lu':\n        #     znum_int[i] = 71\n        # elif str(spe[i][0:2]) == 'Hf':\n        #     znum_int[i] = 72\n        # elif str(spe[i][0:2]) == 'Ta':\n        #     znum_int[i] = 73\n        # elif str(spe[i][0:2]) == 'W ':\n        #     znum_int[i] = 74\n        # elif str(spe[i][0:2]) == 'Re':\n        #     znum_int[i] = 75\n        # elif str(spe[i][0:2]) == 'Os':\n        #     znum_int[i] = 76\n        # elif str(spe[i][0:2]) == 'Ir':\n        #     znum_int[i] = 77\n        # elif str(spe[i][0:2]) == 'Pt':\n        #     znum_int[i] = 78\n        # elif str(spe[i][0:2]) == 'Au':\n        #     znum_int[i] = 79\n        # elif str(spe[i][0:2]) == 'Hg':\n        #     znum_int[i] = 80\n        # elif str(spe[i][0:2]) == 'Tl':\n        #     znum_int[i] = 81\n        # elif str(spe[i][0:2]) == 'Pb':\n        #     znum_int[i] = 82\n        # elif str(spe[i][0:2]) == 'Bi':\n        #     znum_int[i] = 83\n        # elif str(spe[i][0:2]) == 'Po':\n        #     znum_int[i] = 84\n        # elif str(spe[i][0:2]) == 'At':\n        #     znum_int[i] = 85\n        # elif str(spe[i][0:2]) == 'Rn':\n        #     znum_int[i] = 86\n        # elif str(spe[i][0:2]) == 'Fr':\n        #     znum_int[i] = 87\n        # elif str(spe[i][0:2]) == 'Ra':\n        #     znum_int[i] = 88\n        # elif str(spe[i][0:2]) == 'Ac':\n        #     znum_int[i] = 89\n        # elif str(spe[i][0:2]) == 'Th':\n        #     znum_int[i] = 90\n        # elif str(spe[i][0:2]) == 'Pa':\n        #     znum_int[i] = 91\n        # elif str(spe[i][0:2]) == 'U ':\n        #     znum_int[i] = 92\n        # elif str(spe[i][0:2]) == 'Np':\n        #     znum_int[i] = 93\n        # elif str(spe[i][0:2]) == 'Pu':\n        #     znum_int[i] = 94\n        # elif str(spe[i][0:2]) == 'Am':\n        #     znum_int[i] = 95\n        # elif str(spe[i][0:2]) == 'Cm':\n        #     znum_int[i] = 96\n        # elif str(spe[i][0:2]) == 'Bk':\n        #     znum_int[i] = 97\n        # elif str(spe[i][0:2]) == 'Cf':\n        #     znum_int[i] = 98\n\n    if spe[0] == 'N   1':\n        znum_int[0] = 0\n\n    # here the index to connect name and atomic numbers.\n    global index_atomic_number\n    index_atomic_number = {}\n    for a,b in zip(spe,znum_int):\n        index_atomic_number[a]=b", "response": "Convert the specie names from h5 files to ppn."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngiving an array of isotopic abundances not decayed and a similar array of isotopic abundances not decayed, here elements abundances, and production factors for elements are calculated", "response": "def element_abund_marco(i_decay, stable_isotope_list,\n                        stable_isotope_identifier,\n                        mass_fractions_array_not_decayed,\n                        mass_fractions_array_decayed):\n    '''\n    Given an array of isotopic abundances not decayed and a similar\n    array of isotopic abundances not decayed, here elements abundances,\n    and production factors for elements are calculated\n\n    '''\n\n\n    # this way is done in a really simple way. May be done better for sure, in a couple of loops.\n    # I keep this, since I have only to copy over old script. Falk will probably redo it.\n\n    #import numpy as np\n    #from NuGridPy import utils as u\n\n    global elem_abund\n    elem_abund = np.zeros(z_bismuth)\n    global elem_abund_decayed\n    elem_abund_decayed = np.zeros(z_bismuth)\n    global elem_prod_fac\n    elem_prod_fac = np.zeros(z_bismuth)\n    global elem_prod_fac_decayed\n    elem_prod_fac_decayed = np.zeros(z_bismuth)\n\n\n    # notice that elem_abund include all contribution, both from stables and unstables in\n    # that moment.\n    for i in range(z_bismuth):\n        dummy = 0.\n        for j in range(len(spe)):\n            if znum_int[j] == i+1 and stable_isotope_identifier[j] > 0.5:\n                dummy = dummy + float(mass_fractions_array_not_decayed[j])\n        elem_abund[i] = dummy\n\n\n    for i in range(z_bismuth):\n        if index_stable[i] == 1:\n            elem_prod_fac[i] = float(old_div(elem_abund[i],solar_elem_abund[i]))\n        elif index_stable[i] == 0:\n            elem_prod_fac[i] = 0.\n\n\n    if i_decay == 2:\n        for i in range(z_bismuth):\n            dummy = 0.\n            for j in range(len(mass_fractions_array_decayed)):\n                if znum_int[cl[stable_isotope_list[j].capitalize()]] == i+1:\n                #print znum_int[cl[stable[j].capitalize()]],cl[stable[j].capitalize()],stable[j]\n                    dummy = dummy + float(mass_fractions_array_decayed[j])\n            elem_abund_decayed[i] = dummy\n\n\n        for i in range(z_bismuth):\n            if index_stable[i] == 1:\n                elem_prod_fac_decayed[i] = float(old_div(elem_abund_decayed[i],solar_elem_abund[i]))\n            elif index_stable[i] == 0:\n                elem_prod_fac_decayed[i] = 0."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nproviding the list of stable species and decay path feeding stables", "response": "def stable_specie():\n    ''' provide the list of stable species, and decay path feeding stables '''\n\n\n    #import numpy as np\n\n\n    stable_raw=[]\n    stable_raw = ['H   1', 'H   2',\\\n    'HE  3', 'HE  4',\\\n    'LI  6', 'LI  7',\\\n    'BE  9',\\\n    'B  10', 'B  11',\\\n    'C  12', 'C  13',\\\n    'N  14', 'N  15',\\\n    'O  16', 'O  17', 'O  18',\\\n    'F  19',\\\n    'NE 20', 'NE 21', 'NE 22',\\\n    'NA 23',\\\n    'MG 24', 'MG 25', 'MG 26',\\\n    'AL 27',\\\n    'SI 28', 'SI 29', 'SI 30',\\\n    'P  31',\\\n    'S  32', 'S  33', 'S  34', 'S  36',\\\n    'CL 35', 'CL 37',\\\n    'AR 36', 'AR 38', 'AR 40',\\\n    'K  39', 'K  40', 'K  41',\\\n    'CA 40', 'CA 42', 'CA 43', 'CA 44', 'CA 46', 'CA 48',\\\n    'SC 45',\\\n    'TI 46', 'TI 47', 'TI 48', 'TI 49', 'TI 50',\\\n    'V  50', 'V  51',\\\n    'CR 50', 'CR 52', 'CR 53', 'CR 54',\\\n    'MN 55',\\\n    'FE 54', 'FE 56', 'FE 57', 'FE 58',\\\n    'CO 59',\\\n    'NI 58', 'NI 60', 'NI 61', 'NI 62', 'NI 64',\\\n    'CU 63', 'CU 65',\\\n    'ZN 64', 'ZN 66', 'ZN 67', 'ZN 68', 'ZN 70',\\\n    'GA 69', 'GA 71',\\\n    'GE 70', 'GE 72', 'GE 73', 'GE 74', 'GE 76',\\\n    'AS 75',\\\n    'SE 74', 'SE 76', 'SE 77', 'SE 78', 'SE 80', 'SE 82',\\\n    'BR 79', 'BR 81',\\\n    'KR 78', 'KR 80', 'KR 82', 'KR 83', 'KR 84', 'KR 86',\\\n    'RB 85', 'RB 87',\\\n    'SR 84', 'SR 86', 'SR 87', 'SR 88',\\\n    'Y  89',\\\n    'ZR 90', 'ZR 91', 'ZR 92', 'ZR 94', 'ZR 96',\\\n    'NB 93',\\\n    'MO 92', 'MO 94', 'MO 95', 'MO 96', 'MO 97', 'MO 98', 'MO100',\\\n    'RU 96', 'RU 98', 'RU 99', 'RU100', 'RU101', 'RU102', 'RU104',\\\n    'RH103',\\\n    'PD102', 'PD104', 'PD105', 'PD106', 'PD108', 'PD110',\\\n    'AG107', 'AG109',\\\n    'CD106', 'CD108', 'CD110', 'CD111', 'CD112', 'CD113', 'CD114', 'CD116',\\\n    'IN113',  'IN115',\\\n    'SN112', 'SN114', 'SN115', 'SN116', 'SN117', 'SN118', 'SN119', 'SN120', 'SN122', 'SN124',\\\n    'SB121', 'SB123',\\\n    'TE120', 'TE122', 'TE123', 'TE124', 'TE125', 'TE126', 'TE128', 'TE130',\\\n    'I 127',\\\n    'XE124', 'XE126', 'XE128', 'XE129', 'XE130', 'XE131', 'XE132', 'XE134', 'XE136',\\\n    'CS133',\\\n    'BA130', 'BA132', 'BA134', 'BA135', 'BA136', 'BA137', 'BA138',\\\n    'LA138', 'LA139',\\\n    'CE136', 'CE138', 'CE140', 'CE142',\\\n    'PR141',\\\n    'ND142', 'ND143', 'ND144', 'ND145', 'ND146', 'ND148', 'ND150',\\\n    'SM144', 'SM147', 'SM148', 'SM149', 'SM150', 'SM152', 'SM154',\\\n    'EU151', 'EU153',\\\n    'GD152', 'GD154', 'GD155', 'GD156', 'GD157', 'GD158', 'GD160',\\\n    'TB159',\\\n    'DY156', 'DY158', 'DY160', 'DY161', 'DY162', 'DY163', 'DY164',\\\n    'HO165',\\\n    'ER162', 'ER164', 'ER166', 'ER167', 'ER168', 'ER170',\\\n    'TM169',\\\n    'YB168', 'YB170', 'YB171', 'YB172', 'YB173', 'YB174', 'YB176',\\\n    'LU175', 'LU176',\\\n    'HF174', 'HF176', 'HF177', 'HF178', 'HF179', 'HF180',\\\n    'TA180', 'TA181',\\\n    'W 180', 'W 182', 'W 183', 'W 184', 'W 186',\\\n    'RE185', 'RE187',\\\n    'OS184', 'OS186', 'OS187', 'OS188', 'OS189', 'OS190', 'OS192',\\\n    'IR191', 'IR193',\\\n    'PT190', 'PT192', 'PT194', 'PT195', 'PT196', 'PT198',\\\n    'AU197',\\\n    'HG196', 'HG198', 'HG199', 'HG200', 'HG201', 'HG202', 'HG204',\\\n    'TL203', 'TL205',\\\n    'PB204', 'PB206', 'PB207', 'PB208',\\\n    'BI209',\\\n    'TH232',\\\n    'U 235','U 238']\n\n    jj=-1\n    global count_size_stable\n    count_size_stable=[]\n    global stable\n    stable=[]\n    global jdum\n    jdum=np.zeros(len(stable_raw))\n    global jjdum\n    jjdum=np.zeros(len(spe))\n    for i in range(len(stable_raw)):\n        dum_str = stable_raw[i]\n        for j in range(len(spe)):\n            if stable_raw[i].capitalize() == spe[j]:\n                stable.append(stable_raw[i])\n                jdum[i]=1\n                jjdum[j]=1\n                jj=jj+1\n                count_size_stable.append(int(jj))\n    #print stable\n    # back_ind is an index to go back, to use the order of stable\n    # useful for example for decayed yields.\n    global back_ind\n    back_ind={}\n    for a,b in zip(stable,count_size_stable):\n        back_ind[a]=b\n    #print 'in stable:',back_ind['SE 74']\n    # definition of decay paths\n    global decay_raw\n    decay_raw=[]\n    decay_raw=[['H   1'],\\\n    ['H   2'],\\\n    ['HE  3'],\\\n    ['HE  4','B   8'],\\\n    ['LI  6'],\\\n    ['LI  7','BE  7'],\\\n    ['BE  9'],\\\n    ['B  10','BE 10'],\\\n    ['B  11','C  11','BE 11'],\\\n    ['C  12'],\\\n    ['C  13','N  13','O  13'],\\\n    ['N  14','C  14','O  14'],\\\n    ['N  15','C  15','O  15','F  15'],\\\n    ['O  16'],\\\n    ['O  17','F  17'],\\\n    ['O  18','F  18','NE 18'],\\\n    ['F  19','O  19','NE 19'],\\\n    ['NE 20','F  20','NA 20'],\\\n    ['NE 21','F  21','NA 21'],\\\n    ['NE 22','NA 22','MG 22','F  22'],\\\n    ['NA 23','MG 23','NE 23'],\\\n    ['MG 24','AL 24','NA 24','NE 24',],\\\n    ['MG 25','NA 25','AL 25'],\\\n    ['MG 26','SI 26','AL 26','NA 26','AL*26'],\\\n    ['AL 27','SI 27','MG 27'],\\\n    ['SI 28','AL 28','MG 28'],\\\n    ['SI 29','P  29','AL 29','MG 29'],\\\n    ['SI 30','S  30','P  30','AL 30','MG 30'],\\\n    ['P  31','S  31','SI 31'],\\\n    ['S  32','P  32','SI 32'],\\\n    ['S  33','CL 33','P  33','SI 33'],\\\n    ['S  34','CL 34','P  34'],\\\n    ['S  36','P  36'],\\\n    ['CL 35','S  35','AR 35'],\\\n    ['CL 37','S  37','P  37','AR 37','K  37'],\\\n    ['AR 36','CL 36'],\\\n    ['AR 38','CL 38','S  38','P  38','K  38'],\\\n    ['AR 40','CL 40','S  40'],\\\n    ['K  39','AR 39','CL 39','S  39','CA 39'],\\\n    ['K  40'],\\\n    ['K  41','AR 41','CL 41','S  41','CA 41','SC 41'],\\\n    ['CA 40','SC 40'],\\\n    ['CA 42','K  42','AR 42','CL 42','S  42','SC 42','TI 42'],\\\n    ['CA 43','K  43','AR 43','CL 43','SC 43','TI 43','V  43'],\\\n    ['CA 44','K  44','AR 44','CL 44','SC 44','TI 44'],\\\n    ['CA 46','K  46','AR 46'],\\\n    ['CA 48','K  48','AR 48'],\\\n    ['SC 45','CA 45','K  45','AR 45','CL 45','TI 45','V  45'],\\\n    ['TI 46','SC 46','V  46','CR 46'],\\\n    ['TI 47','SC 47','CA 47','K  47','AR 47','V  47','CR 47'],\\\n    ['TI 48','SC 48','V  48','CR 48'],\\\n    ['TI 49','SC 49','CA 49','K  49','V  49','CR 49','MN 49'],\\\n    ['TI 50','SC 50','CA 50','K  50'],\\\n    ['V  50'],\\\n    ['V  51','CR 51','TI 51','SC 51','CA 51','MN 51'],\\\n    ['CR 50','MN 50'],\\\n    ['CR 52','MN 52','FE 52','V  52','TI 52','SC 52','CA 52'],\\\n    ['CR 53','MN 53','FE 53','V  53','TI 53','SC 53'],\\\n    ['CR 54','MN 54','V  54','TI 54','SC 54'],\\\n    ['MN 55','FE 55','CR 55','V  55','TI 55','CO 55'],\\\n    ['FE 54','CO 54'],\\\n    ['FE 56','NI 56','CO 56','MN 56','CR 56'],\\\n    ['FE 57','NI 57','CO 57','MN 57','CR 57'],\\\n    ['FE 58','CO 58','MN 58','CR 58'],\\\n    ['CO 59','FE 59','MN 59','CR 59','NI 59','CU 59'],\\\n    ['NI 58','CU 58'],\\\n    ['NI 60','CO 60','FE 60','MN 60','CR 60','CU 60','ZN 60'],\\\n    ['NI 61','CO 61','FE 61','MN 61','CU 61','ZN 61'],\\\n    ['NI 62','CO 62','FE 62','CU 62','ZN 62'],\\\n    ['NI 64','CO 64','FE 64','CU 64'],\\\n    ['CU 63','NI 63','CO 63','FE 63','MN 63','ZN 63','GA 63'],\\\n    ['CU 65','NI 65','CO 65','FE 65','ZN 65','GA 65','GE 65'],\\\n    ['ZN 64','CU 64','GA 64','GE 64'],\\\n    ['ZN 66','CU 66','NI 66','CO 66','FE 66','GA 66','GE 66'],\\\n    ['ZN 67','CU 67','NI 67','CO 67','FE 67','GA 67','GE 67','AS 77'],\\\n    ['ZN 68','NI 68','CO 68','GA 68','GE 68','CU 68','AS 68','SE 68'],\\\n    ['ZN 70','CU 70','NI 70','CO 70'],\\\n    ['GA 69','ZN 69','CU 69','NI 69','GE 69','AS 69','SE 69'],\\\n    ['GA 71','ZN 71','CU 71','NI 71','GE 71','AS 71','SE 71','BR 71'],\\\n    ['GE 70','GA 70','AS 70','SE 70','BR 70'],\\\n    ['GE 72','GA 72','ZN 72','CU 72','NI 72','AS 72','SE 72','BR 72','KR 72'],\\\n    ['GE 73','GA 73','ZN 73','CU 73','NI 73','AS 73','SE 73','BR 73','KR 73'],\\\n    ['GE 74','GA 74','ZN 74','CU 74','NI 74','AS 74'],\\\n    ['GE 76','GA 76','ZN 76','CU 76'],\\\n    ['AS 75','GE 75','GA 75','ZN 75','CU 75','SE 75','BR 75','KR 75','RB 75'],\\\n    ['SE 74','AS 74','BR 74','KR 74'],\\\n    ['SE 76','AS 76','BR 76','KR 76','RB 76','SR 76'],\\\n    ['SE 77','AS 77','GE 77','BR 77','GA 77','ZN 77','KR 77','RB 77','SR 77'],\\\n    ['SE 78','AS 78','GE 78','GA 78','ZN 78','BR 78'],\\\n    ['SE 80','AS 80','GE 80','GA 80','ZN 80'],\\\n    ['SE 82','AS 82','GE 82','GA 82'],\\\n    ['BR 79','SE 79','AS 79','GE 79','GA 79','ZN 79','KR 79','RB 79','SR 79','Y  79'],\\\n    ['BR 81','SE 81','KR 81','AS 81','GE 81','GA 81','RB 81','SR 81','Y  81','ZR 81'],\\\n    ['KR 78','RB 78','SR 78','Y  78'],\\\n    ['KR 80','BR 80','RB 80','SR 80','ZR 80'],\\\n    ['KR 82','BR 82','RB 82','SR 82','Y  82','ZR 82'],\\\n    ['KR 83','BR 83','SE 83','AS 83','GE 83','RB 83','SR 83','Y  83','ZR 83','NB 83'],\\\n    ['KR 84','BR 84','SE 84','AS 84','GE 84','RB 84'],\\\n    ['KR 86','BR 86','SE 86','AS 86'],\\\n    ['RB 85','KR 85','SR 85','KR*85','BR 85','SE 85','AS 85','Y  85','ZR 85','NB 85','MO 85'],\\\n    ['RB 87','KR 87','BR 87','SE 87','AS 87'],\\\n    ['SR 84','Y  84','ZR 84','NB 84','MO 84'],\\\n    ['SR 86','RB 86','Y  86','ZR 86','NB 86','MO 86'],\\\n    ['SR 87','Y  87','ZR 87','NB 87','MO 87','TC 87'],\\\n    ['SR 88','RB 88','KR 88','BR 88','SE 88','Y  88','ZR 88','NB 88','MO 88','TC 88'],\\\n    ['Y  89','SR 89','RB 89','KR 89','BR 89','ZR 89','NB 89','MO 89','TC 89','RU 89'],\\\n    ['ZR 90','Y  90','SR 90','RB 90','KR 90','BR 90','NB 90','MO 90','TC 90','RU 90'],\\\n    ['ZR 91','Y  91','SR 91','RB 91','KR 91','BR 91','SE 91','NB 91','MO 91','TC 91','RU 91','RH 91'],\\\n    ['ZR 92','Y  92','SR 92','RB 92','KR 92','BR 92','NB 92'],\\\n    ['ZR 94','Y  94','SR 94','RB 94','KR 94'],\\\n    ['ZR 96','Y  96','SR 96'],\\\n    ['NB 93','ZR 93','Y  93','SR 93','RB 93','KR 93','MO 93','TC 93','RU 93','RH 93','PD 93'],\\\n    ['MO 92','TC 92','RU 92','RH 92','PD 92'],\\\n    ['MO 94','NB 94','TC 94','RU 94','RH 94','PD 94'],\\\n    ['MO 95','NB 95','ZR 95','Y  95','SR 95','TC 95','RU 95','RH 95','PD 95','AG 95'],\\\n    ['MO 96','NB 96','TC 96'],\\\n    ['MO 97','NB 97','ZR 97','Y  97','SR 97','TC 97','RU 97','RH 97','PD 97','AG 97','CD 97'],\\\n    ['MO 98','NB 98','ZR 98','Y  98','SR 98'],\\\n    ['MO100','NB100','ZR100','Y 100'],\\\n    ['RU 96','RH 96','PD 96','AG 96'],\\\n    ['RU 98','TC 98','RH 98','PD 98','AG 98','CD 98'],\\\n    ['RU 99','TC 99','MO 99','NB 99','ZR 99','Y  99','RH 99','PD 99','AG 99','CD 99','IN 99'],\\\n    ['RU100','TC100','RH100','PD100','AG100','CD100','IN100','SN100'],\\\n    ['RU101','TC101','MO101','NB101','ZR101','Y 101','RH101','PD101','AG101','CD101','IN101','SN101'],\\\n    ['RU102','MO102','TC102','NB102','ZR102','Y 102','RH102'],\\\n    ['RU104','TC104','MO104','NB104'],\\\n    ['RH103','RU103','TC103','MO103','NB103','ZR103','Y 103','PD103','AG103','CD103','IN103','SN103'],\\\n    ['PD102','AG102','CD102','IN102','SN102'],\\\n    ['PD104','RH104','AG104','CD104','IN104','SN104','SB104'],\\\n    ['PD105','RH105','RU105','TC105','MO105','NB105','ZR105','AG105','CD105','IN105','SN105','SB105'],\\\n    ['PD106','RH106','RU106','TC106','MO106','NB106','AG106'],\\\n    ['PD108','RH108','RU108','TC108','MO108','NB108'],\\\n    ['PD110','RH110','RU110','TC110','MO110','NB110'],\\\n    ['AG107','PD107','RH107','RU107','TC107','MO107','CD107','IN107','SN107','SB107'],\\\n    ['AG109','PD109','RH109','RU109','TC109','MO109','NB109','CD109','IN109','SN109','SB109','TE109'],\\\n    ['CD106','IN106','SN106','SB106'],\\\n    ['CD108','AG108','IN108','SN108','SB108'],\\\n    ['CD110','AG110','IN110','SN110','SB110','TE110'],\\\n    ['CD111','AG111','PD111','RH111','RU111','TC111','IN111','SN111','SB111','TE111','I 111'],\\\n    ['CD112','AG112','PD112','RH112','RU112','TC112'],\\\n    ['CD113','AG113','PD113','RH113','RU113'],\\\n    ['CD114','AG114','PD114','RH114','RU114'],\\\n    ['CD116','AG116','PD116','RH116'],\\\n    ['IN113','SN113','SB113','TE113','I 113','XE113'],\\\n    ['IN115','CD115','AG115','PD115','RH115','RU115'],\\\n    ['SN112','IN112','SB112','TE112','I 112','XE112'],\\\n    ['SN114','IN114','SB114','TE114','I 114','XE114','CS114'],\\\n    ['SN115','SB115','TE115','I 115','XE115','CS115','BA115'],\\\n    ['SN116','IN116','SB116','TE116','I 116','XE116','CS116','BA116'],\\\n    ['SN117','IN117','AG117','PD117','RH117','SB117','CD117','TE117','I 117','XE117','CS117','BA117'],\\\n    ['SN118','IN118','CD118','AG118','PD118','SB118','TE118','XE118','CS118','BA118'],\\\n    ['SN119','IN119','CD119','AG119','PD119','SB119','TE119','XE119','CS119','BA119'],\\\n    ['SN120','SB120','IN120','CD120','AG120','PD120'],\\\n    ['SN122','IN122','CD122','AG122'],\\\n    ['SN124','IN124','CD124'],\\\n    ['SB121','SN121','IN121','CD121','AG121','TE121','I 121','XE121','CS121','XE121','CS121','BA121','LA121','CE121'],\n    ['SB123','SN123','IN123','CD123','AG123'],\\\n    ['TE120','I 120','XE120','CS120','BA120','LA120'],\\\n    ['TE122','SB122','I 122','XE122','CS122','BA122','LA122'],\\\n    ['TE123','I 123','XE123','CS123','BA123','LA123','CE123'],\\\n    ['TE124','SB124','I 124'],\\\n    ['TE125','SB125','SN125','IN125','CD125','I 125','XE125','CS125','BA125','LA125','CE125','PR125'],\\\n    ['TE126','SB126','SN126','IN126','CD126'],\\\n    ['TE128','SB128','SN128','IN128','CD128'],\\\n    ['TE130','SB130','SN130','IN130'],\\\n    ['I 127','TE127','SB127','SN127','IN127','CD127','XE127','CS127','BA127','LA127','CE127','PR127','ND127'],\\\n    ['XE124','CS124','BA124','LA124','CE124','PR124'],\\\n    ['XE126','I 126','CS126','BA126','LA126','CE126','PR126'],\\\n    ['XE128','I 128','CS128','BA128','LA128','CE128','PR128'],\\\n    ['XE129','I 129','TE129','SB129','SN129','IN129','CD129','CS129','BA129','LA129','CE129','PR129','ND129'],\\\n    ['XE130','I 130','CS130'],\\\n    ['XE131','I 131','TE131','SB131','SN131','IN131','CS131','BA131','LA131','CE131','PR131','ND131','PM131','SM131'],\\\n    ['XE132','I 132','TE132','SB132','SN132','IN132','CS132'],\n    ['XE134','I 134','TE134','SB134','SN134'],\\\n    ['XE136','I 136','TE136','SB136'],\\\n    ['CS133','XE133','I 133','TE133','SB133','SN133','BA133','LA133','CE133','PR133','ND133','PM133','SM133'],\\\n    ['BA130','LA130','CE130','PR130','ND130','PM130'],\\\n    ['BA132','LA132','CE132','PR132','ND132','PM132','SM132'],\\\n    ['BA134','CS134','LA134','CE134','PR134','ND134','PM134','SM134','EU134'],\\\n    ['BA135','CS135','XE135','I 135','TE135','SB135','SN135','LA135','CE135','PR135','ND135','PM135','SM135','EU135','GD135'],\\\n    ['BA136','CS136','LA136'],\\\n    ['BA137','CS137','XE137','I 137','TE137','SB137','LA137','CE137','PR137','ND137','PM137','SM137','EU137','GD137'],\\\n    ['BA138','CS138','XE138','I 138','TE138'],\\\n    ['LA138'],\\\n    ['LA139','BA139','CS139','XE139','I 139','CE139','PR139','ND139','PM139','SM139','EU139','GD139','TB139','DY139'],\\\n    ['CE136','PR136','ND136','PM136','SM136','EU136'],\\\n    ['CE138','PR138','ND138','PM138','SM138','EU138','GD138'],\\\n    ['CE140','LA140','BA140','CS140','XE140','I 140','PR140','ND140','PM140','SM140','EU140','GD140','TB140'],\\\n    ['CE142','LA142','BA142','CS142','XE142','I 142'],\\\n    ['PR141','CE141','LA141','BA141','CS141','XE141','I 141','ND141','PM141','SM141','EU141','GD141','TB141','DY141'],\\\n    ['ND142','PR142','PM142','SM142','EU142','GD142','TB142','DY142','HO142','SM146','EU146','GD146','TB146','DY146','HO146','ER146',\\\n'GD150','TB150','DY150','HO150','ER150','DY154','HO154','ER154'],\\\n    ['ND143','PR143','CE143','LA143','BA143','CS143','XE143','PM143','SM143','EU143','GD143','TB143','DY143'],\\\n    ['ND144','PR144','CE144','LA144','BA144','CS144','XE144','PM144'],\\\n    ['ND145','PR145','CE145','LA145','BA145','CS145','PM145','SM145','EU145','GD145','TB145','DY145','HO145','ER145'],\\\n    ['ND146','PR146','CE146','LA146','BA146','CS146','PM146'],\\\n    ['ND148','PR148','CE148','LA148','BA148'],\\\n    ['ND150','PR150','CE150','LA150','BA150'],\\\n    ['SM144','EU144','GD144','TB144','DY144','HO144','GD148','TB148','DY148','HO148','ER148','TM148'],\\\n    ['SM147','PM147','ND147','PR147','CE147','LA147','BA147','EU147','GD147','TB147','DY147','HO147','ER147'],\\\n    ['SM148','PM148','EU148'],\\\n    ['SM149','PM149','ND149','PR149','CE149','LA149','EU149','GD149','TB149','DY149','HO149','ER149','TM149','YB149'],\\\n    ['SM150','PM150','EU150'],\\\n    ['SM152','PM152','ND152','PR152','CE152','EU152'],\\\n    ['SM154','PM154','ND154','PR154'],\\\n    ['EU151','SM151','PM151','ND151','PR151','CE151','GD151','TB151'],\\\n    ['EU153','SM153','PM153','GD153','PR153','GD153','TB153','DY153','HO153'],\\\n    ['GD152','TB152','DY152','HO152'],\\\n    ['GD154','EU154','TB154'],\\\n    ['GD155','EU155','SM155','PM155','ND155','TB155','DY155','HO155','ER155','TM155'],\\\n    ['GD156','EU156','SM156','PM156','ND156','TB156'],\\\n    ['GD157','EU157','SM157','PM157','TB157','DY157','HO157','ER157','TM157','YB157'],\\\n    ['GD158','EU158','SM158','PM158','TB158'],\\\n    ['GD160','EU160','SM160'],\\\n    ['TB159','GD159','EU159','SM159','PM159','DY159','HO159','ER159','TM159','YB159','LU159'],\\\n    ['DY156','HO156','ER156','TM156','YB156','HO156','ER156','TM156','YB156'],\\\n    ['DY158','HO158','ER158','TM158','YB158','LU158'],\\\n    ['DY160','TB160','HO160','ER160','TM160','YB160','LU160','HF160'],\\\n    ['DY161','TB161','GD161','EU161','SM161','PM161','ND161','HO161','ER161','TM161','YB161','LU161','HF161','TA161'],\\\n    ['DY162','TB162','GD162','EU162','SM162','PM162','HO162'],\\\n    ['DY163','TB163','HO163','GD163','EU163','SM163','PM163','ND163','ER163','TM163','YB163','LU163','HF163','TA163'],\\\n    ['DY164','TB164','HO164','GD164','EU164','SM164','PM164','ND164','HO164'],\\\n    ['HO165','DY165','ER165','TB165','GD165','EU165','SM165','PM165','HO165','TM165','YB165','LU165','HF165','TA165','W 165'],\\\n    ['ER162','TM162','YB162','LU162','HF162','TA162'],\\\n    ['ER164','TM164','YB164','LU164','HF164','TA164','W 164'],\\\n    ['ER166','HO166','DY166','TB166','GD166','EU166','SM166','PM166','ND166','TM166','YB166','LU166','HF166','TA166','W 166','RE166'],\\\n    ['ER167','HO167','DY167','TB167','GD167','EU167','SM167','PM167','ND167','TM167','YB167','LU167','HF167','TA167','W 167','RE167'],\\\n    ['ER168','HO168','DY168','TB168','GD168','EU168','SM168','PM168','ND168','TM168'],\\\n    ['ER170','HO170','DY170','TB170','GD170','EU170','SM170','PM170','ND170'],\\\n    ['TM169','ER169','HO169','DY169','TB169','GD169','EU169','SM169','PM169','ND169','YB169','LU169','HF169','TA169','W 169','RE169'],\\\n    ['YB168','LU168','HF168','TA168','W 168','RE168'],\\\n    ['YB170','TM170','LU170','HF170','TA170','W 170','RE170','OS170'],\\\n    ['YB171','TM171','ER171','HO171','DY171','TB171','GD171','EU171','SM171','PM171','ND171','LU171','HF171','TA171','W 171','RE171','OS171'],\\\n    ['YB172','TM172','ER172','HO172','DY172','TB172','GD172','EU172','SM172','PM172','ND172','LU172','HF172','TA172','W 172','RE172','OS172','IR172'],\\\n    ['YB173','TM173','ER173','HO173','DY173','TB173','GD173','EU173','SM173','PM173','ND173','LU173','HF173','TA173','W 173','RE173','OS173','IR173'],\\\n    ['YB174','TM174','ER174','HO174','DY174','TB174','GD174','EU174','SM174','PM174','ND174','LU174'],\\\n    ['YB176','TM176','ER176','HO176','DY176','TB176','GD176','EU176','SM176','PM176','ND176'],\\\n    ['LU175','YB175','TM175','ER175','HO175','DY175','TB175','GD175','EU175','SM175','PM175','ND175','HF175','TA175','W 175','RE175','OS175','IR175'],\\\n    ['LU176','HF176','TA176','W 176','RE176','OS176','IR176'],\\\n    ['HF174','TA174','W 174','RE174','OS174','IR174'],\\\n    ['HF176','TA176','W 176','RE176','OS176','IR176'],\\\n    ['HF177','LU177','YB177','LU177','YB177','TM177','ER177','HO177','DY177','TB177','GD177','TA177','W 177','RE177','OS177','IR177'],\\\n    ['HF178','LU178','YB178','LU178','YB178','TM178','ER178','HO178','DY178','TB178','GD178','TA178','W 178','RE178','OS178','IR178'],\\\n    ['HF179','LU179','YB179','LU179','YB179','TM179','ER179','HO179','DY179','TB179','GD179','TA179','W 179','RE179','OS179','IR179','PT179'],\\\n    ['HF180','LU180','YB180','LU180','YB180','TM180','ER180','HO180','DY180','TB180','GD180','TA180','W 180','RE180','OS180','IR180','PT180','AU180'],\\\n    ['TA180'],\\\n    ['TA181','HF181','LU181','YB181','LU181','YB181','TM181','ER181','HO181','DY181','TB181','GD181','W 181','RE181','OS181','IR181','PT181','AU181'],\\\n    ['W 180','RE180','OS180','IR180','PT180','AU180'],\\\n    ['W 182','TA182','HF182','LU182','YB182','LU182','YB182','TM182','ER182','HO182','DY182','TB182','GD182','RE182','OS182','IR182','PT182','AU182'],\\\n    ['W 183','TA183','HF183','LU183','YB183','LU183','YB183','TM183','ER183','HO183','DY183','TB183','GD183','RE183','OS183','IR183','PT183','AU183'],\\\n    ['W 184','TA184','HF184','LU184','YB184','LU184','YB184','TM184','ER184','HO184','DY184','TB184','GD184','RE184'],\\\n    ['W 186','TA186','HF186','LU186','YB186','LU186','YB186','TM186','ER186','HO186','DY186','TB186','GD186'],\\\n    ['RE185','W 185','TA185','HF185','LU185','YB185','LU185','YB185','TM185','ER185','HO185','DY185','TB185','GD185','OS185','IR185','PT185','AU185','HG185','TL185'],\\\n    ['RE187','W 187','TA187','HF187','LU187','YB187','LU187','YB187','TM187','ER187','HO187','DY187','TB187','GD187'],\\\n    ['OS184','IR184','PT184','AU184','HG184','TL184'],\\\n    ['OS186','RE186','IR186','PT186','AU186','HG186','TL186'],\\\n    ['OS187','IR187','PT187','AU187','HG187','TL187','PB187'],\\\n    ['OS188','RE188','W 188','TA188','HF188','LU188','YB188','LU188','YB188','TM188','ER188','HO188','DY188','TB188','GD188','IR188','PT188','AU188','HG188','TL188','PB188'],\\\n    ['OS189','RE189','W 189','TA189','HF189','LU189','YB189','LU189','YB189','TM189','ER189','HO189','DY189','TB189','GD189','IR189','PT189','AU189','HG189','TL189','PB189'],\\\n    ['OS190','RE190','W 190','TA190','HF190','LU190','YB190','LU190','YB190','TM190','ER190','HO190','DY190','TB190','GD190','IR190'],\\\n    ['OS192','RE190','W 192','TA192','HF192','LU192','YB192','LU192','YB192','TM192','ER192','HO192','DY192','TB192','GD192'],\\\n    ['IR191','OS191','RE191','W 191','TA191','HF191','LU191','YB191','LU191','YB191','TM191','ER191','HO191','DY191','TB191','GD191','PT191','AU191','HG191','TL191','PB191'],\\\n    ['IR193','OS193','RE193','W 193','TA193','HF193','LU193','YB193','LU193','YB193','TM193','ER193','HO193','DY193','TB193','GD193','PT193','AU193','HG193','TL193','PB193'],\\\n    ['PT190','AU190','HG190','TL190','PB190'],\\\n    ['PT192','IR192','AU192','HG192','TL192','PB192'],\\\n    ['PT194','IR194','OS194','RE194','W 194','TA194','HF194','AU194','HG194','TL194','PB194','BI194'],\n    ['PT195','IR195','OS195','RE195','W 195','TA195','HF195','AU195','HG195','TL195','PB195','BI195'],\\\n    ['PT196','IR196','OS196','RE196','W 196','TA196','HF196','AU196'],\\\n    ['PT198','IR198','OS198','RE198','W 198','TA198','HF198'],\\\n    ['AU197','PT197','IR197','OS197','RE197','W 197','TA197','HF197','HG197','TL197','PB197','BI197'],\\\n    ['HG196','TL196','PB196','BI196'],\\\n    ['HG198','AU198','TL198','PB198','BI198'],\\\n    ['HG199','AU199','PT199','IR199','OS199','RE199','W 199','TA199','HF199','TL199','PB199','BI199'],\\\n    ['HG200','AU200','PT200','IR200','OS200','RE200','W 200','TA200','HF200','TL200','PB200','BI200'],\\\n    ['HG201','AU201','PT201','IR201','OS201','RE201','W 201','TA201','HF201','TL201','PB201','BI201','PO201'],\\\n    ['HG202','AU202','PT202','IR202','OS202','RE202','W 202','TA202','HF202','TL202','PB202','BI202','PO202'],\\\n    ['HG204','AU204','PT204','IR204','OS204','RE204','W 204','TA204','HF204'],\\\n    ['TL203','HG203','AU203','PT203','IR203','OS203','RE203','W 203','TA203','HF203','PB203','BI203','PO203'],\\\n    ['TL205','HG205','AU205','PT205','IR205','OS205','RE205','W 205','TA205','HF205','PB205','BI205','PO205'],\\\n    ['PB204','TL204','BI204','PO204'],\\\n    ['PB206','TL206','HG206','AU206','PT206','IR206','OS206','RE206','W 206','TA206','HF206','BI206','PO210'],\\\n    ['PB207','TL207','HG207','AU207','PT207','IR207','OS207','RE207','W 207','TA207','HF207','BI207','PO211','BI211'],\\\n    ['PB208','TL208','HG208','AU208','PT208','IR208','OS208','RE208','W 208','TA208','HF208','BI208','PO212','BI212'],\\\n    ['BI209','PB209','TL209','HG209','AU209','PT209','IR209','OS209','RE209','W 209','TA209','HF209'],\\\n    ['TH232','AC232','RA232','FR232','RN232'],\\\n    ['U 235','PA235','TH235','AC235','RA235','FR235','RN235'],\\\n    ['U 238','PA238','TH238','AC238','RA238','FR238','RN238']]"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating 2 indexes that given the name of the element and give the atomic number.", "response": "def give_zip_element_z_and_names(element_name):\n    ''' create 2 indexes that, given the name of the element/specie, give the atomic number.'''\n\n    #import numpy as np\n\n    global z_bismuth\n    z_bismuth = 83\n    global z_for_elem\n    z_for_elem = []\n    global index_stable\n    index_stable = []\n\n    i_for_stable = 1\n    i_for_unstable = 0\n    for i in range(z_bismuth):\n        z_for_elem.append(int(i+1))\n        # the only elements below bismuth with no stable isotopes are Tc and Pm\n        if i+1 == 43 or i+1 == 61:\n            index_stable.append(i_for_unstable)\n        else:\n            index_stable.append(i_for_stable)\n\n        dummy_index = np.zeros(len(element_name))\n        for i in range(len(element_name)):\n            if element_name[i] == 'Neutron':\n                dummy_index[i] = 0\n            elif element_name[i] == 'H':\n                dummy_index[i] = 1\n            elif element_name[i] == 'He':\n                dummy_index[i] = 2\n            elif element_name[i] == 'Li':\n                dummy_index[i] = 3\n            elif element_name[i] == 'Be':\n                dummy_index[i] = 4\n            elif element_name[i] == 'B':\n                dummy_index[i] = 5\n            elif element_name[i] == 'C':\n                dummy_index[i] = 6\n            elif element_name[i] == 'N':\n                dummy_index[i] = 7\n            elif element_name[i] == 'O':\n                dummy_index[i] = 8\n            elif element_name[i] == 'F':\n                dummy_index[i] = 9\n            elif element_name[i] == 'Ne':\n                dummy_index[i] = 10\n            elif element_name[i] == 'Na':\n                dummy_index[i] = 11\n            elif element_name[i] == 'Mg':\n                dummy_index[i] = 12\n            elif element_name[i] == 'Al':\n                dummy_index[i] = 13\n            elif element_name[i] == 'Si':\n                dummy_index[i] = 14\n            elif element_name[i] == 'P':\n                dummy_index[i] = 15\n            elif element_name[i] == 'S':\n                dummy_index[i] = 16\n            elif element_name[i] == 'Cl':\n                dummy_index[i] = 17\n            elif element_name[i] == 'Ar':\n                dummy_index[i] = 18\n            elif element_name[i] == 'K':\n                dummy_index[i] = 19\n            elif element_name[i] == 'Ca':\n                dummy_index[i] = 20\n            elif element_name[i] == 'Sc':\n                dummy_index[i] = 21\n            elif element_name[i] == 'Ti':\n                dummy_index[i] = 22\n            elif element_name[i] == 'V':\n                dummy_index[i] = 23\n            elif element_name[i] == 'Cr':\n                dummy_index[i] = 24\n            elif element_name[i] == 'Mn':\n                dummy_index[i] = 25\n            elif element_name[i] == 'Fe':\n                dummy_index[i] = 26\n            elif element_name[i] == 'Co':\n                dummy_index[i] = 27\n            elif element_name[i] == 'Ni':\n                dummy_index[i] = 28\n            elif element_name[i] == 'Cu':\n                dummy_index[i] = 29\n            elif element_name[i] == 'Zn':\n                dummy_index[i] = 30\n            elif element_name[i] == 'Ga':\n                dummy_index[i] = 31\n            elif element_name[i] == 'Ge':\n                dummy_index[i] = 32\n            elif element_name[i] == 'As':\n                dummy_index[i] = 33\n            elif element_name[i] == 'Se':\n                dummy_index[i] = 34\n            elif element_name[i] == 'Br':\n                dummy_index[i] = 35\n            elif element_name[i] == 'Kr':\n                dummy_index[i] = 36\n            elif element_name[i] == 'Rb':\n                dummy_index[i] = 37\n            elif element_name[i] == 'Sr':\n                dummy_index[i] = 38\n            elif element_name[i] == 'Y':\n                dummy_index[i] = 39\n            elif element_name[i] == 'Zr':\n                dummy_index[i] = 40\n            elif element_name[i] == 'Nb':\n                dummy_index[i] = 41\n            elif element_name[i] == 'Mo':\n                dummy_index[i] = 42\n            elif element_name[i] == 'Tc':\n                dummy_index[i] = 43\n            elif element_name[i] == 'Ru':\n                dummy_index[i] = 44\n            elif element_name[i] == 'Rh':\n                dummy_index[i] = 45\n            elif element_name[i] == 'Pd':\n                dummy_index[i] = 46\n            elif element_name[i] == 'Ag':\n                dummy_index[i] = 47\n            elif element_name[i] == 'Cd':\n                dummy_index[i] = 48\n            elif element_name[i] == 'In':\n                dummy_index[i] = 49\n            elif element_name[i] == 'Sn':\n                dummy_index[i] = 50\n            elif element_name[i] == 'Sb':\n                dummy_index[i] = 51\n            elif element_name[i] == 'Te':\n                dummy_index[i] = 52\n            elif element_name[i] == 'I':\n                dummy_index[i] = 53\n            elif element_name[i] == 'Xe':\n                dummy_index[i] = 54\n            elif element_name[i] == 'Cs':\n                dummy_index[i] = 55\n            elif element_name[i] == 'Ba':\n                dummy_index[i] = 56\n            elif element_name[i] == 'La':\n                dummy_index[i] = 57\n            elif element_name[i] == 'Ce':\n                dummy_index[i] = 58\n            elif element_name[i] == 'Pr':\n                dummy_index[i] = 59\n            elif element_name[i] == 'Nd':\n                dummy_index[i] = 60\n            elif element_name[i] == 'Pm':\n                dummy_index[i] = 61\n            elif element_name[i] == 'Sm':\n                dummy_index[i] = 62\n            elif element_name[i] == 'Eu':\n                dummy_index[i] = 63\n            elif element_name[i] == 'Gd':\n                dummy_index[i] = 64\n            elif element_name[i] == 'Tb':\n                dummy_index[i] = 65\n            elif element_name[i] == 'Dy':\n                dummy_index[i] = 66\n            elif element_name[i] == 'Ho':\n                dummy_index[i] = 67\n            elif element_name[i] == 'Er':\n                dummy_index[i] = 68\n            elif element_name[i] == 'Tm':\n                dummy_index[i] = 69\n            elif element_name[i] == 'Yb':\n                dummy_index[i] = 70\n            elif element_name[i] == 'Lu':\n                dummy_index[i] = 71\n            elif element_name[i] == 'Hf':\n                dummy_index[i] = 72\n            elif element_name[i] == 'Ta':\n                dummy_index[i] = 73\n            elif element_name[i] == 'W':\n                dummy_index[i] = 74\n            elif element_name[i] == 'Re':\n                dummy_index[i] = 75\n            elif element_name[i] == 'Os':\n                dummy_index[i] = 76\n            elif element_name[i] == 'Ir':\n                dummy_index[i] = 77\n            elif element_name[i] == 'Pt':\n                dummy_index[i] = 78\n            elif element_name[i] == 'Au':\n                dummy_index[i] = 79\n            elif element_name[i] == 'Hg':\n                dummy_index[i] = 80\n            elif element_name[i] == 'Tl':\n                dummy_index[i] = 81\n            elif element_name[i] == 'Pb':\n                dummy_index[i] = 82\n            elif element_name[i] == 'Bi':\n                dummy_index[i] = 83\n            elif element_name[i] == 'Po':\n                dummy_index[i] = 84\n            elif element_name[i] == 'At':\n                dummy_index[i] = 85\n\n        #if spe[0] == 'N   1':\n        #       znum_int[0] = 0\n\n        # here the index to connect name and atomic numbers.\n        global index_z_for_elements\n        index_z_for_elements = {}\n        for a,b in zip(element_name,dummy_index):\n            index_z_for_elements[a]=b"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_el_from_z(z):\n    '''\n    Very simple Vfunction that gives the atomic number AS A STRING when given the element symbol.\n    Uses predefined a dictionnary.\n    Parameter :\n    z : string or number\n    For the other way, see get_z_from_el\n    '''\n    if(type(z)==float):\n        z=int(z)\n    if(type(z)==int):\n        z=str(z)\n    dict_z={'24': 'Cr', '25': 'Mn', '26': 'Fe', '27': 'Co', '20': 'Ca', '21': 'Sc', '22': 'Ti', '23': 'V', '28': 'Ni', '29': 'Cu', '4': 'Be', '8': 'O', '59': 'Pr', '58': 'Ce', '55': 'Cs', '54': 'Xe', '57': 'La', '56': 'Ba', '51': 'Sb', '50': 'Sn', '53': 'I', '52': 'Te', '88': 'Ra', '89': 'Ac', '82': 'Pb', '83': 'Bi', '80': 'Hg', '81': 'Tl', '86': 'Rn', '87': 'Fr', '84': 'Po', '85': 'At', '3': 'Li', '7': 'N', '39': 'Y', '38': 'Sr', '33': 'As', '32': 'Ge', '31': 'Ga', '30': 'Zn', '37': 'Rb', '36': 'Kr', '35': 'Br', '34': 'Se', '60': 'Nd', '61': 'Pm', '62': 'Sm', '63': 'Eu', '64': 'Gd', '65': 'Tb', '66': 'Dy', '67': 'Ho', '68': 'Er', '69': 'Tm', '2': 'He', '6': 'C', '91': 'Pa', '90': 'Th', '92': 'U', '11': 'Na', '10': 'Ne', '13': 'Al', '12': 'Mg', '15': 'P', '14': 'Si', '17': 'Cl', '16': 'S', '19': 'K', '18': 'Ar', '48': 'Cd', '49': 'In', '46': 'Pd', '47': 'Ag', '44': 'Ru', '45': 'Rh', '42': 'Mo', '43': 'Tc', '40': 'Zr', '41': 'Nb', '1': 'H', '5': 'B', '9': 'F', '77': 'Ir', '76': 'Os', '75': 'Re', '74': 'W', '73': 'Ta', '72': 'Hf', '71': 'Lu', '70': 'Yb', '79': 'Au', '78': 'Pt'}\n    return dict_z[z]", "response": "This function returns the atomic number as a string when given the element symbol."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef fit(self, x, y, dcoef='none'):\n        '''\n        performs the fit\n\n        x, y : list\n            Matching data arrays that define a numerical function y(x),\n            this is the data to be fitted.\n        dcoef : list or string\n            You can provide a different guess for the coefficients, or\n            provide the string 'none' to use the inital guess.  The\n            default is 'none'.\n\n        Returns\n        -------\n        ierr\n            Values between 1 and 4 signal success.\n\n        Notes\n        -----\n        self.fcoef, contains the fitted coefficients.\n\n        '''\n        self.x = x\n        self.y = y\n\n        if dcoef is not 'none':\n            coef = dcoef\n        else:\n            coef = self.coef\n\n        fcoef=optimize.leastsq(self.residual,coef,args=(y,self.func,x))\n        self.fcoef = fcoef[0].tolist()\n        return fcoef[1]", "response": "Fits the fit function with the specified data arrays x and y."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef plot(self, ifig=1, data_label='data', fit_label='fit',\n             data_shape='o', fit_shape='-'):\n        '''\n        plot the data and the fitted function.\n\n        Parameters\n        ----------\n        ifig : integer\n            Figure window number.  The default is 1.\n        data_label : string\n            Legend for data.  The default is 'data'.\n        fit_label : string\n            Legend for fit.  If fit_lable is 'fit', then substitute fit\n            function type self.func_name.  The default is 'fit'.\n        data_shape : character\n            Shape for data.  The default is 'o'.\n        fit_shape : character\n            Shape for fit.  The default is '-'.\n\n        '''\n\n        if len(self.coef) is not len(self.fcoef):\n            print(\"Warning: the fitted coefficient list is not same\")\n            print(\"         length as guessed list - still I will try ...\")\n\n        pl.figure(ifig)\n        pl.plot(self.x,self.y,data_shape,label=data_label)\n        if fit_label is 'fit':\n            fit_label=self.__name__\n        pl.plot(self.x,self.func(self.fcoef,self.x),fit_shape,label=fit_label)\n        pl.legend()", "response": "Plot the data and the fitted function."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _stable_names(self):\n        '''\n        This private method extracts the element names from stable_el.\n        Note that stable_names is a misnomer as stable_el also contains\n        unstable element names with a number 999 for the *stable* mass\n        numbers. (?!??)\n\n        '''\n        stable_names=[]\n        for i in range(len(self.stable_el)):\n            stable_names.append(self.stable_el[i][0])\n        self.stable_names=stable_names", "response": "Private method to extract the element names from the stable_el attribute."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _process_abundance_vector(self, a, z, isomers, yps):\n        '''\n        This private method takes as input one vector definition and\n        processes it, including sorting by charge number and\n        mass number. It returns the processed input variables\n        plus an element and isotope vector and a list of\n        isomers.\n\n        '''\n        def cmp_to_key(mycmp):\n            'Convert a cmp= function into a key= function'\n            class K(object):\n                def __init__(self, obj, *args):\n                    self.obj = obj\n                def __lt__(self, other):\n                    return mycmp(self.obj, other.obj) < 0\n                def __gt__(self, other):\n                    return mycmp(self.obj, other.obj) > 0\n                def __eq__(self, other):\n                    return mycmp(self.obj, other.obj) == 0\n                def __le__(self, other):\n                    return mycmp(self.obj, other.obj) <= 0\n                def __ge__(self, other):\n                    return mycmp(self.obj, other.obj) >= 0\n                def __ne__(self, other):\n                    return mycmp(self.obj, other.obj) != 0\n            return K\n\n        tmp=[]\n        isom=[]\n        for i in range(len(a)):\n            if z[i]!=0 and isomers[i]==1: #if its not 'NEUt and not an isomer'\n                tmp.append([self.stable_names[int(z[i])]+'-'+str(int(a[i])),yps[i],z[i],a[i]])\n            elif isomers[i]!=1: #if it is an isomer\n                if yps[i]==0:\n                    isom.append([self.stable_names[int(z[i])]+'-'+str(int(a[i]))+'-'+str(int(isomers[i]-1)),1e-99])\n                else:\n                    isom.append([self.stable_names[int(z[i])]+'-'+str(int(a[i]))+'-'+str(int(isomers[i]-1)),yps[i]])\n        tmp.sort(key = cmp_to_key(self.compar))\n        tmp.sort(key = cmp_to_key(self.comparator))\n        abunds=[]\n        isotope_to_plot=[]\n        z_iso_to_plot=[]\n        a_iso_to_plot=[]\n        el_iso_to_plot=[]\n        for i in range(len(tmp)):\n            isotope_to_plot.append(tmp[i][0])\n            abunds.append(tmp[i][1])\n            z_iso_to_plot.append(int(tmp[i][2]))\n            a_iso_to_plot.append(int(tmp[i][3]))\n            el_iso_to_plot.append(self.stable_names[int(tmp[i][2])])\n\n        return a_iso_to_plot,z_iso_to_plot,abunds,isotope_to_plot,el_iso_to_plot,isom", "response": "This private method processes one vector definition and returns the processed input variables and isomers and z."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef write(self, outfile='initial_abundance.dat',\n              header_string='initial abundances for a PPN run'):\n        '''\n        Write initial abundance file (intended for use with ppn)\n\n        Parameters\n        ----------\n        outfile : string\n            Name of output file.  The default is\n            'initial_abundance.dat'.\n        header_string : string\n            A string with header line.  The default is\n            'initial abundances for a PPN run'.\n\n        '''\n\n        dcols=['Z', 'species','mass fraction']\n        data=[self.z,self.names,self.abu]\n        hd=[header_string]\n        att.write(outfile,hd,dcols,data)", "response": "Writes an initial abundance file for a PPN run."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nwrite initial abundance file, returns written abundances and mesa names. Parameters ---------- mesa_isos_file : string, optional List with isos copied from mesa network definition file in mesa/data/net_data/nets. The default is 'isos.txt'. add_excess_iso : string, optional Add 1.-sum(isos in mesa net) to this isotope. The defualt is 'fe56'. outfile : string, optional name of output file. The default file is 'xa_iniabu.dat'. header_string : string, optional Srting with header line. The default is 'initial abundances for a MESA run'. header_char : character, optional The default is '!'. Examples -------- >>> from NuGridPy import utils >>> !ls ~/PPN/forum.astro.keele.ac.uk/frames/mppnp/USEEPP/ # find ppn initial abundance file >>> !cat ~/mesa/data/net_data/nets/agb.net # find isos needed in mesa net >>> !cat > isos.txt # paste needed isos into file >>> help(utils.iniabu) # check documentation of method >>> x=utils.iniabu('path_to_here/forum.astro.keele.ac.uk/frames/mppnp/USEEPP/iniab2.0E-02GN93.ppn') >>> x.write_mesa? >>> mnames,mabus = x.write_mesa(add_excess_iso='ne22', ... header_string='mppnp/USEEPP/iniab2.0E-02GN93.ppn for mesa/agb.net', ... outfile='xa_2.0E-02GN93.mesa')", "response": "def write_mesa(self, mesa_isos_file='isos.txt',\n                   add_excess_iso='fe56', outfile='xa_iniabu.dat',\n                   header_string='initial abundances for a MESA run',\n                   header_char='!'):\n        '''\n        Write initial abundance file, returns written abundances and\n        mesa names.\n\n        Parameters\n        ----------\n        mesa_isos_file : string, optional\n            List with isos copied from mesa network definition file in\n            mesa/data/net_data/nets.  The default is 'isos.txt'.\n        add_excess_iso : string, optional\n            Add 1.-sum(isos in mesa net) to this isotope.  The defualt\n            is 'fe56'.\n        outfile : string, optional\n            name of output file.  The default file is 'xa_iniabu.dat'.\n        header_string : string, optional\n            Srting with header line.  The default is\n            'initial abundances for a MESA run'.\n        header_char : character, optional\n            The default is '!'.\n\n        Examples\n        --------\n\n        >>> from NuGridPy import utils\n        >>> !ls ~/PPN/forum.astro.keele.ac.uk/frames/mppnp/USEEPP/   # find ppn initial abundance file\n        >>> !cat ~/mesa/data/net_data/nets/agb.net                   # find isos needed in mesa net\n        >>> !cat > isos.txt                                          # paste needed isos into file\n        >>> help(utils.iniabu)                                       # check documentation of method\n        >>> x=utils.iniabu('path_to_here/forum.astro.keele.ac.uk/frames/mppnp/USEEPP/iniab2.0E-02GN93.ppn')\n        >>> x.write_mesa?\n        >>> mnames,mabus = x.write_mesa(add_excess_iso='ne22',\n        ...                header_string='mppnp/USEEPP/iniab2.0E-02GN93.ppn for mesa/agb.net',\n        ...                outfile='xa_2.0E-02GN93.mesa')\n\n        '''\n\n\n        f=open('isos.txt')\n        a=f.readlines()\n        isos=[]\n        for i in range(len(a)):\n            isos.append(a[i].strip().rstrip(','))\n\n        mesa_names=[]\n        abus=[]\n        for i in range(len(self.z)):\n            b=self.names[i].split()\n            a=''\n            a=a.join(b)\n            if a in isos:\n                mesa_names.append(a)\n                abus.append(self.abu[i])\n            # mesa_names.append(elements_names[int(x.z[i])].lower()+str(int(x.a[i])))\n\n        for i in range(len(isos)):\n            if isos[i] not in mesa_names:\n                mesa_names.append(isos[i])\n                abus.append(0.0)\n\n        excess=1.-np.sum(np.array(abus))\n        abus=np.array(abus)\n        abus[mesa_names.index(add_excess_iso)] += excess\n\n        dcols=['','']\n        data=[mesa_names,abus]\n        hd=[header_string]\n        att.write(outfile,hd,dcols,data,header_char=header_char)\n        return mesa_names,abus"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef set_and_normalize(self,species_hash):\n        '''\n        species_hash is a hash array in which you provide abundances\n        referenced by species names that you want to set to some\n        particular value; all other species are then normalised so that\n        the total sum is 1.\n\n        Examples\n        --------\n\n        You can set up the argument array for this method for example\n        in the following way.\n\n        >>> sp={}\n        >>> sp['he  4']=0.2\n        >>> sp['h   1']=0.5\n\n        '''\n\n        sum_before = sum(self.abu)\n        for i in range(len(species_hash)):\n            sum_before -= self.abu[self.hindex[list(species_hash.keys())[i]]]\n        print(\"sum_before = \"+str(sum_before))\n        normalization_factor=old_div(1.0-sum(species_hash.values()),sum_before)\n        print(\"normalizing the rest witih factor \"+str(normalization_factor))\n        self.abu *= normalization_factor\n        for i in range(len(species_hash)):\n            self.abu[self.hindex[list(species_hash.keys())[i]]]=list(species_hash.values())[i]\n\n        for l in range(len(self.abu)):\n            if self.abu[l] <= 1e-99:   #otherwise we might write e-100 which will be read as e-10 by ppn\n                self.abu[l] = 1.0e-99\n        for name in self.habu:\n            self.habu[name]=self.abu[self.hindex[name]]", "response": "This method sets the internal state of the object to the values of the abundances of the species names in the object."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef iso_abundance(self,isos):\n        '''\n        This routine returns the abundance of a specific isotope.\n        Isotope given as, e.g., 'Si-28' or as list\n        ['Si-28','Si-29','Si-30']\n\n        '''\n        if type(isos) == list:\n            dumb = []\n            for it in range(len(isos)):\n                dumb.append(isos[it].split('-'))\n            ssratio = []\n            isos = dumb\n            for it in range(len(isos)):\n                ssratio.append(self.habu[isos[it][0].ljust(2).lower() + str(int(isos[it][1])).rjust(3)])\n        else:\n            isos = isos.split('-')\n            ssratio = self.habu[isos[0].ljust(2).lower() + str(int(isos[1])).rjust(3)]\n        return ssratio", "response": "This routine returns the abundance of a specific isotope."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef drive_rotational_speed_rpm(self):\n        drv_rot_speed_rpm = set()\n        for member in self.get_members():\n            if member.rotational_speed_rpm is not None:\n                drv_rot_speed_rpm.add(member.rotational_speed_rpm)\n        return drv_rot_speed_rpm", "response": "Gets the set of rotational speed of the HDD drives"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nconverts the name of the isotope input e. g. N - 14 to 14N as used later to compare w / grain database.", "response": "def iso_name_converter(iso):\n    '''\n    Converts the name of the given isotope (input), e.g., 'N-14' to\n    14N as used later to compare w/ grain database.\n\n    '''\n    sp = iso.split('-')\n    output = sp[1] + sp[0]\n\n    return output.lower()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef reset_filter(self):\n        '''\n        Resets the filter and goes back to initialized value. This\n        routine also resets the style if you have changed it.\n\n        '''\n        self.header_desc = self._header_desc\n        self.header_data = self._header_data\n        self.header_style = self._header_style\n        self.desc = self._desc\n        self.data = self._data\n        self.style = self._style\n        self.descdict = self._descdict\n        self.datadict = self._datadict\n        self.styledict = self._styledict", "response": "Resets the filter and goes back to initialized value. This routine resets the style and the data and header dictionaries."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef filter_data(self, isos, limit, delta=True):\n        '''\n        This subroutine filters isotopic values according to the limit\n        you give.  You can filter in ratio or in delta space.\n\n        Parameters\n        ----------\n        isos : list\n            isotopes you want to filter for, e.g., give as\n            ['Si-28', 'Si-30'] for the 28/30 ratio.\n        limit : string\n            what do you want to filter for, e.g., ratio or delta > 100,\n            then give '>100'.\n        delta : boolean, optional\n            do you wanna filter in delta space, then set to True,\n            otherwise to False.  The default is True.\n\n        '''\n\n        # check availability\n        dat_index, delta_b, ratio_b = self.check_availability(isos)\n        if dat_index == -1:\n            print('Isotopes selected are not available. Check i.datadict (where i is your instance) for availability of isotopes.')\n            return None\n\n        # select if larger or smaller and define limit\n        if limit[0:1] == '>':\n            comperator = 'gt'\n        elif limit[0:1] == '<':\n            comperator = 'st'\n        else:\n            print('Comperator not specified. Limit must be given as \\'>5.\\' for example.')\n            return None\n\n        try:\n            limit = float(limit[1:len(limit)])\n        except ValueError:\n            print('Limit must be given as \\'>5.\\' for example.')\n            return None\n\n        # now calculate the actual limit to compare with, depending on if it delta or not or whatsoever\n        if delta == delta_b:   # input and available same\n            if ratio_b:   # one over\n                if delta:\n                    tmp = self.delta_to_ratio(isos,limit,oneover=True)\n                    comp_lim = self.ratio_to_delta(isos,tmp)   # check\n                else:\n                    comp_lim = old_div(1.,limit)   # check\n\n            else:   # all fine\n                comp_lim = limit\n\n        else:   # input and availability not the same\n            if ratio_b:   # one over\n                if delta:   # delta given, ratio one over wanted\n                    comp_lim = self.delta_to_ratio(isos,limit,oneover=True)\n                else:   # ratio given, delta one over wanted\n                    comp_lim = self.ratio_to_delta(isos,limit,oneover=True)\n            else:   # not one over\n                if delta:   # delta given, ratio wanted\n                    comp_lim = self.delta_to_ratio(isos,limit)\n                else:\n                    comp_lim = self.ratio_to_delta(isos,limit)\n\n        # indexing vector\n        indexing = []\n        for i in range(len(self.data)):\n            dat_val = self.data[i][dat_index]\n            if comperator == 'st':\n                if dat_val < comp_lim:\n                    indexing.append(i)\n            else:\n                if dat_val > comp_lim:\n                    indexing.append(i)\n\n        # now filter data\n        if len(indexing) > 0:\n            desc_tmp = np.zeros((len(indexing),len(self.header_desc)),dtype='|S1024')\n            data_tmp = np.zeros((len(indexing),len(self.header_data)))\n            for i in range(len(indexing)):\n                for j in range(len(self.header_desc)):\n                    desc_tmp[i][j] = self.desc[indexing[i]][j]\n                for k in range(len(self.header_data)):\n                    data_tmp[i][k] = self.data[indexing[i]][k]\n            self.desc = desc_tmp\n            self.data = data_tmp\n        else:\n            print('No filter selected!')", "response": "This method filters isotopic values according to the limit."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef style_chg_label(self,type,symb=None,edc=None,fac=None,smbsz=None,edw=None,lab=None):\n        '''\n        This routine changes the plotting style that is set by default.\n        The style is changed according the the label that you choose.\n        Changing according to reference, use style_chg_ref() function!\n        You can change it back to default by resetting the filter using\n        g.reset_filter() routine, assuming that g is your instance. The\n        format that is used here is:\n\n        ['Symbol', 'Edge color', 'Face color', 'Symbol size', 'Edge width'\n        ,'Label']\n\n        You can see the current styles by running\n\n        Attention: You have to give values to all variables that are\n        compatible with the python mathplotlib. If not, it's your fault\n        if nothing works.\n\n        g.style\n\n        Parameters\n        ----------\n        type : string\n            Select the label of the grains you want to change.\n        symb : string, optional\n            Select new symbol. None for no change.\n        edc : string, optional\n            Select new edge color. None for no change.\n        fac : string, optional\n            Select new face color. None for no change.\n        smbsz : string, optional\n            Select new symbol size. None for no change.\n        edw : string, optional\n            Select new edge width. None for no change.\n        lab : string, optional\n            Select new label. None for no change. Watch out, if you\n            want to do more specifications later, the type will\n            have changed to the new label.\n        '''\n\n        # do stuff for selected type\n        for i in range(len(self.style)):\n            # check if type is correct, otherwise continue directly\n            if self.style[i][self.styledict['Label']] == type:\n                # change symbol:\n                if symb != None:\n                    self.style[i][self.styledict['Symbol']] = symb\n                # change edge color\n                if edc != None:\n                    self.style[i][self.styledict['Edge color']] = edc\n                # change face color\n                if fac != None:\n                    self.style[i][self.styledict['Face color']] = fac\n                # change symbol size\n                if smbsz != None:\n                    self.style[i][self.styledict['Symbol size']] = smbsz\n                # change edge width\n                if edw != None:\n                    self.style[i][self.styledict['Edge width']] = edw\n                # change label\n                if lab != None:\n                    self.style[i][self.styledict['Label']] = lab", "response": "This routine changes the plotting style of the current object based on the label of the grains you want to change."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef plot_ratio_return(self, isox, isoy, deltax=True, deltay=True):\n        '''\n        This routine returns data isotopic data to plot from the\n        filtered list of data.\n\n        Parameters\n        ----------\n        isox : list\n            Isotopes for x axis in standard format ['Si-28','Si-30'].\n        isoy : list\n            Same as isox but for y axis.\n        deltax : boolean, optional\n            If true then x-axis values are in delta format.  The default\n            is True.\n        deltay : boolean, optional\n            Same as for x-axis but for y-axis.  The default is True.\n\n        Returns\n        -------\n        grpl_xdata\n            grain plot x-axis data.\n        grpl_xerr\n            x-axis error bars.\n        grpl_ydata\n            grain plot y-axis data.\n        grpl_yerr\n            y-axis error bars.\n        grpl_style\n            style data for the different symbols.\n\n        '''\n\n        # check availability\n        index_x, delta_b_x, ratio_b_x = self.check_availability(isox)\n        index_y, delta_b_y, ratio_b_y = self.check_availability(isoy)\n        if index_x == -1 or index_y == -1:\n            print('Following input data are not available in the database. Revise your input.')\n            if index_x == -1:\n                print('x axis data not available')\n            if index_y == -1:\n                print('y axis data not available')\n            return None\n\n        # create x and y data as 1d vectors, also error bars\n        xdata_vec = np.zeros((len(self.data)))\n        ydata_vec = np.zeros((len(self.data)))\n        xdata_err = np.zeros((len(self.data)))\n        ydata_err = np.zeros((len(self.data)))\n        for it in range(len(self.data)):\n            xdata_vec[it] = self.data[it][index_x]\n            ydata_vec[it] = self.data[it][index_y]\n            xdata_err[it] = self.data[it][index_x+1]\n            ydata_err[it] = self.data[it][index_y+1]\n\n        # index data that are nan\n        index_nan = []\n        for it in range(len(xdata_vec)):\n            if np.isnan(xdata_vec[it]) or np.isnan(ydata_vec[it]):\n                index_nan.append(it)\n\n        # make range of all incides\n        index_filtered = list(range(len(xdata_vec)))\n        for it in range(len(index_nan)):\n            index_filtered.remove(index_nan[it])\n\n        xdata_tmp = np.zeros((len(index_filtered)))\n        ydata_tmp = np.zeros((len(index_filtered)))\n        xerr_tmp  = np.zeros((len(index_filtered)))\n        yerr_tmp  = np.zeros((len(index_filtered)))\n        style_plt = np.zeros((len(index_filtered),len(self.header_style)),dtype='|S1024')\n\n        for i in range(len(index_filtered)):\n            xdata_tmp[i] = xdata_vec[index_filtered[i]]\n            ydata_tmp[i] = ydata_vec[index_filtered[i]]\n            xerr_tmp[i]  = xdata_err[index_filtered[i]]\n            yerr_tmp[i]  = ydata_err[index_filtered[i]]\n            for j in range(len(style_plt[i])):\n                style_plt[i][j] = self.style[index_filtered[i]][j]\n        xdata_vec = xdata_tmp\n        ydata_vec = ydata_tmp\n        xdata_err = xerr_tmp\n        ydata_err = yerr_tmp\n\n        # loop through error and set nans to 0\n        for i in range(len(xdata_err)):\n            if np.isnan(xdata_err[i]):\n                xdata_err[i] = 0.\n            if np.isnan(ydata_err[i]):\n                ydata_err[i] = 0.\n\n        # make start stop index for groups\n        start_stop = []\n        start = 0\n        for it in range(len(xdata_vec)-1):\n            if (style_plt[it] == style_plt[it+1]).all():\n                continue\n            else:\n                stop = it + 1\n                start_stop.append([start,stop])\n                start = stop\n        # last entry\n        if start_stop == []:\n            start_stop.append([0,len(xdata_vec)])\n        else:\n            start_stop.append([start_stop[len(start_stop)-1][1],len(xdata_vec)+1])\n\n        # now append things to return variables\n        grain_plt_xdata = []\n        grain_plt_ydata = []\n        grain_plt_xerr  = []\n        grain_plt_yerr  = []\n        grain_plt_style = []\n        for i in range(len(start_stop)):\n            grain_plt_xdata.append(xdata_vec[start_stop[i][0]:start_stop[i][1]])\n            grain_plt_ydata.append(ydata_vec[start_stop[i][0]:start_stop[i][1]])\n            grain_plt_xerr.append(xdata_err[start_stop[i][0]:start_stop[i][1]])\n            grain_plt_yerr.append(ydata_err[start_stop[i][0]:start_stop[i][1]])\n            grain_plt_style.append(style_plt[start_stop[i][0]])\n\n\n        return [grain_plt_xdata,grain_plt_xerr,grain_plt_ydata,grain_plt_yerr,grain_plt_style]", "response": "This routine returns data isotopic data from the current state of the object."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ntransform an isotope ratio into a delta value Parameters ---------- isos_ss: list or float list w/ isotopes, e.g., ['N-14','N-15'] OR the solar system ratio. ratio : float ratio of the isotopes to transform. oneover : boolean take the inverse of the ratio before transforming (never inverse of delta value!). The default is False. Returns ------- float delta value", "response": "def ratio_to_delta(self, isos_ss, ratio, oneover=False):\n        '''\n        Transforms an isotope ratio into a delta value\n\n        Parameters\n        ----------\n        isos_ss: list or float\n            list w/ isotopes, e.g., ['N-14','N-15'] OR the solar\n            system ratio.\n        ratio : float\n            ratio of the isotopes to transform.\n        oneover : boolean\n            take the inverse of the ratio before transforming (never\n            inverse of delta value!).  The default is False.\n\n        Returns\n        -------\n        float\n            delta value\n\n        '''\n        # define if isos_ss is the ratio or the isotopes\n        if type(isos_ss) == float:\n            ss_ratio = isos_ss\n        elif type(isos_ss) == list:\n            ss_ratio = self.inut.isoratio_init(isos_ss)\n        else:\n            print('Check input of isos_ss into ratio_to_delta routine')\n            return None\n\n        # check if one over is necessary or not\n        if oneover:\n            ratio = old_div(1,ratio)\n\n        # calculate delta value\n        delta = (old_div(ratio, ss_ratio) - 1.) * 1000.\n\n        return delta"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef with_filter(self, filter):\n        '''\n        Returns a new service which will process requests with the specified\n        filter. Filtering operations can include logging, automatic retrying,\n        etc... The filter is a lambda which receives the HTTPRequest and\n        another lambda. The filter can perform any pre-processing on the\n        request, pass it off to the next lambda, and then perform any\n        post-processing on the response.\n\n        :param function(request) filter: A filter function.\n        :return: A new service using the specified filter.\n        :rtype: a subclass of :class:`StorageClient`\n        '''\n        res = copy.deepcopy(self)\n        old_filter = self._filter\n\n        def new_filter(request):\n            return filter(request, old_filter)\n\n        res._filter = new_filter\n        return res", "response": "Returns a new service which will process requests with the specified filter."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nsend the request and returns the response. Catches HTTPError and hands itto error handler.", "response": "def _perform_request(self, request, encoding='utf-8'):\n        '''\n        Sends the request and return response. Catches HTTPError and hands it\n        to error handler\n        '''\n        try:\n            resp = self._filter(request)\n\n            if sys.version_info >= (3,) and isinstance(resp, bytes) and \\\n                encoding:\n                resp = resp.decode(encoding)\n\n        # Parse and wrap HTTP errors in AzureHttpError which inherits from AzureException\n        except HTTPError as ex:\n            _storage_error_handler(ex)\n\n        # Wrap all other exceptions as AzureExceptions to ease exception handling code\n        except Exception as ex:\n            if sys.version_info >= (3,):\n                # Automatic chaining in Python 3 means we keep the trace\n                raise AzureException\n            else:\n                # There isn't a good solution in 2 for keeping the stack trace \n                # in general, or that will not result in an error in 3\n                # However, we can keep the previous error type and message\n                # TODO: In the future we will log the trace\n                raise AzureException('{}: {}'.format(ex.__class__.__name__, ex.args[0]))\n\n        return resp"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _validate_snmp(self):\n        cred = self.snmp_credentials\n        if cred is not None:\n            if cred.get('snmp_inspection') is True:\n                if not all([cred.get('auth_user'),\n                           cred.get('auth_prot_pp'),\n                           cred.get('auth_priv_pp')]):\n                    msg = self._('Either few or all mandatory '\n                                 'SNMP credentials '\n                                 'are missing.')\n                    LOG.error(msg)\n                    raise exception.IloInvalidInputError(msg)\n                try:\n                    auth_protocol = cred['auth_protocol']\n                    if auth_protocol not in [\"SHA\", \"MD5\"]:\n                        msg = self._('Invalid SNMP auth protocol '\n                                     'provided. '\n                                     'Valid values are SHA or MD5')\n                        LOG.error(msg)\n                        raise exception.IloInvalidInputError(msg)\n                except KeyError:\n                    msg = self._('Auth protocol not provided by user. '\n                                 'The default value of MD5 will '\n                                 'be considered.')\n                    LOG.debug(msg)\n                    pass\n                try:\n                    priv_protocol = cred['priv_protocol']\n                    if priv_protocol not in [\"AES\", \"DES\"]:\n                        msg = self._('Invalid SNMP privacy protocol '\n                                     'provided. '\n                                     'Valid values are AES or DES')\n                        LOG.error(msg)\n                        raise exception.IloInvalidInputError(msg)\n                except KeyError:\n                    msg = self._('Privacy protocol not provided '\n                                 'by user. '\n                                 'The default value of DES will '\n                                 'be considered.')\n                    LOG.debug(msg)\n                    pass\n            else:\n                LOG.debug(self._('snmp_inspection set to False. SNMP'\n                                 'inspection will not be performed.'))\n        else:\n            LOG.debug(self._('SNMP credentials not provided. SNMP '\n                             'inspection will not be performed.'))", "response": "Validates SNMP credentials.\n\n        :raises exception.IloInvalidInputError"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _call_method(self, method_name, *args, **kwargs):\n        if self.use_redfish_only:\n            if method_name in SUPPORTED_REDFISH_METHODS:\n                the_operation_object = self.redfish\n            else:\n                raise NotImplementedError()\n        else:\n            the_operation_object = self.ribcl\n            if 'Gen10' in self.model:\n                if method_name in SUPPORTED_REDFISH_METHODS:\n                    the_operation_object = self.redfish\n                else:\n                    if (self.is_ribcl_enabled is not None\n                            and not self.is_ribcl_enabled):\n                        raise NotImplementedError()\n            elif ('Gen9' in self.model) and (method_name in\n                                             SUPPORTED_RIS_METHODS):\n                the_operation_object = self.ris\n\n        method = getattr(the_operation_object, method_name)\n\n        LOG.debug(self._(\"Using %(class)s for method %(method)s.\"),\n                  {'class': type(the_operation_object).__name__,\n                   'method': method_name})\n\n        return method(*args, **kwargs)", "response": "Call the corresponding method using RIBCL RIS or REDFISH way."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef set_iscsi_info(self, target_name, lun, ip_address,\n                       port='3260', auth_method=None, username=None,\n                       password=None):\n        \"\"\"Set iscsi details of the system in uefi boot mode.\n\n        The initiator system is set with the target details like\n        IQN, LUN, IP, Port etc.\n        :param target_name: Target Name for iscsi.\n        :param lun: logical unit number.\n        :param ip_address: IP address of the target.\n        :param port: port of the target.\n        :param auth_method : either None or CHAP.\n        :param username: CHAP Username for authentication.\n        :param password: CHAP secret.\n        :raises: IloError, on an error from iLO.\n        :raises: IloCommandNotSupportedInBiosError, if the system is\n                 in the bios boot mode.\n        \"\"\"\n        return self._call_method('set_iscsi_info', target_name, lun,\n                                 ip_address, port, auth_method, username,\n                                 password)", "response": "Set the iscsi details of the initiator system in uefi boot mode."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting the iSCSI boot information of the initiator system in uefi boot mode.", "response": "def set_iscsi_boot_info(self, mac, target_name, lun, ip_address,\n                            port='3260', auth_method=None, username=None,\n                            password=None):\n        \"\"\"Set iscsi details of the system in uefi boot mode.\n\n        The initiator system is set with the target details like\n        IQN, LUN, IP, Port etc.\n        :param mac: The MAC of the NIC to be set with iSCSI information\n        :param target_name: Target Name for iscsi.\n        :param lun: logical unit number.\n        :param ip_address: IP address of the target.\n        :param port: port of the target.\n        :param auth_method : either None or CHAP.\n        :param username: CHAP Username for authentication.\n        :param password: CHAP secret.\n        :raises: IloError, on an error from iLO.\n        :raises: IloCommandNotSupportedInBiosError, if the system is\n                 in the bios boot mode.\n        \"\"\"\n        LOG.warning(\"'set_iscsi_boot_info' is deprecated. The 'MAC' parameter\"\n                    \"passed in is ignored. Use 'set_iscsi_info' instead.\")\n        return self._call_method('set_iscsi_info', target_name, lun,\n                                 ip_address, port, auth_method, username,\n                                 password)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting the Virtual Media drive status and allows the virtual media to boot from the virtual media.", "response": "def set_vm_status(self, device='FLOPPY',\n                      boot_option='BOOT_ONCE', write_protect='YES'):\n        \"\"\"Sets the Virtual Media drive status and allows the\n\n        boot options for booting from the virtual media.\n        \"\"\"\n        return self._call_method('set_vm_status', device, boot_option,\n                                 write_protect)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_essential_properties(self):\n        data = self._call_method('get_essential_properties')\n        if (data['properties']['local_gb'] == 0):\n            cred = self.snmp_credentials\n            if cred and cred.get('snmp_inspection'):\n                disksize = snmp.get_local_gb(self.host, cred)\n                if disksize:\n                    data['properties']['local_gb'] = disksize\n                else:\n                    msg = self._('SNMP inspection failed to '\n                                 'get the disk size. Returning '\n                                 'local_gb as 0.')\n                    LOG.debug(msg)\n            else:\n                msg = self._(\"SNMP credentials were not set and \"\n                             \"RIBCL/Redfish failed to get the disk size. \"\n                             \"Returning local_gb as 0.\")\n                LOG.debug(msg)\n        return data", "response": "Get the essential scheduling properties of the current node."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting the server capabilities for the specified iLO entry.", "response": "def get_server_capabilities(self):\n        \"\"\"Get hardware properties which can be used for scheduling\n\n        :return: a dictionary of server capabilities.\n        :raises: IloError, on an error from iLO.\n        :raises: IloCommandNotSupportedError, if the command is not supported\n                 on the server.\n        \"\"\"\n        capabilities = self._call_method('get_server_capabilities')\n        # TODO(nisha): Assumption is that Redfish always see the pci_device\n        # member name field populated similarly to IPMI.\n        # If redfish is not able to get nic_capacity, we can fall back to\n        # IPMI way of retrieving nic_capacity in the future. As of now\n        # the IPMI is not tested on Gen10, hence assuming that\n        # Redfish will always be able to give the data.\n        if ('Gen10' not in self.model):\n            major_minor = (\n                self._call_method('get_ilo_firmware_version_as_major_minor'))\n\n            # NOTE(vmud213): Even if it is None, pass it on to get_nic_capacity\n            # as we still want to try getting nic capacity through ipmitool\n            # irrespective of what firmware we are using.\n            nic_capacity = ipmi.get_nic_capacity(self.ipmi_host_info,\n                                                 major_minor)\n            if nic_capacity:\n                capabilities.update({'nic_capacity': nic_capacity})\n\n        if capabilities:\n            return capabilities"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncleaning history.data or star.log file, e.g. to take care of repetitive restarts. private, should not be called by user directly Parameters ---------- file_in : string Typically the filename of the mesa output history.data or star.log file, creates a clean file called history.datasa or star.logsa. (thanks to Raphael for providing this tool)", "response": "def _cleanstarlog(file_in):\n    \"\"\"\n    cleaning history.data or star.log file, e.g. to take care of\n    repetitive restarts.\n\n    private, should not be called by user directly\n\n    Parameters\n    ----------\n    file_in : string\n        Typically the filename of the mesa output history.data or\n        star.log file, creates a clean file called history.datasa or\n        star.logsa.\n\n    (thanks to Raphael for providing this tool)\n\n    \"\"\"\n\n    file_out=file_in+'sa'\n    f = open(file_in)\n    lignes = f.readlines()\n    f.close()\n\n    nb    = np.array([],dtype=int)   # model number\n    nb    = np.concatenate((nb    ,[  int(lignes[len(lignes)-1].split()[ 0])]))\n    nbremove = np.array([],dtype=int)   # model number\n    i=-1\n\n    for i in np.arange(len(lignes)-1,0,-1):\n        line = lignes[i-1]\n\n        if i > 6 and line != \"\" :\n            if int(line.split()[ 0])>=nb[-1]:\n                nbremove = np.concatenate((nbremove,[i-1]))\n            else:\n                nb = np.concatenate((nb    ,[  int(line.split()[ 0])]))\n    i=-1\n    for j in nbremove:\n        lignes.remove(lignes[j])\n\n    fout = open(file_out,'w')\n    for j in np.arange(len(lignes)):\n        fout.write(lignes[j])\n    fout.close()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nplot the Mesa profile and returns a list of lists of the desired abundance plots.", "response": "def abu_profiles(p,ifig=1,xlm=xlm,ylm=(-8,0),show=False,abunds='All',xaxis=xaxis_type, figsize1=(8,8)):\n    '''Four panels of abundance plots\n\n    Parameters\n    ----------\n\n    p : instance\n      mesa_profile instance\n\n    xlm : tuple\n      xlimits: mass_min, mass_max\n      \n    abus : 'All' plots many 'commonly used' isotopes up to Fe if they are in your mesa output.\n    otherwise provide a list of lists of desired abus \n\n    show : Boolean\n      False  for batch use\n      True   for interactive use\n\n    xaxis : character\n      Lagrangian    mass is radial mass coordinate\n      Eulerian      radius is radial coordinate, in Mm\n    '''\n\n\n    matplotlib.rc('figure',facecolor='white',figsize=figsize1)\n   \n    # create subplot structure\n    f, ([ax1,ax2],[ax3,ax4]) = pl.subplots(2, 2, sharex=False, sharey=True, figsize=figsize1)\n    \n    \n    # define 4 groups of elements, one for each of the 4 subplots \n    all_isos=[['h1','he3','he4','li6','c12','c13','n13','n14','n15','o16','o17','o18','f19'],['ne20','ne21','ne22','na22','na23','mg24','mg25','mg26','al26','al27','si28','si29','si30'], ['p31', 's32','s33', 's34','s36','cl35','cl37','ar36', 'ar38','ar40', 'k39', 'k40','k41'],\n['ca40','ca42','ca48','sc45','ti46','ti48','ti50','v50','v51','cr52','cr54','mn55','fe56']]\n    \n    if abunds == 'All':\n        abus=[[],[],[],[]]\n        j=0\n        for i, row in enumerate(all_isos):\n            for iso in row:\n                if iso in p.cols:\n                    abus[i].append(iso)\n                    j+=1  \n                  \n                    \n        abus1=[]\n        abus2 =[[],[],[],[]]\n        for l in range(len(abus)):\n            for k in range(len(abus[l])):\n                abus1.append(abus[l][k])\n\n                \n        is_small_isos = False                \n        for i in range(len(abus)):\n            if len(abus[i]) < 5:\n                is_small_isos = True\n                print(\"Missing isotopes from the default list. Distributing the ones you have over the panels.\")\n        \n        if is_small_isos:\n            n=4\n            quo, rem = divmod(len(abus1), n)\n            for i in range(len(abus2)):\n                for k in range(i*quo,(i+1)*quo+rem):\n                    abus2[i].append(abus1[k])\n         \n                    abus = abus2\n        #print(abus)        \n                \n    else:\n        abus = abus    \n    ax = [ax1,ax2,ax3,ax4]\n    xxx = p.get('radius') if xaxis is \"Eulerian\" else p.get('mass') \n    mass = p.get('mass')                      # in units of Msun\n    radius = p.get('radius')*ast.rsun_cm/1.e8  # in units of Mm\n    if xaxis is \"Eulerian\":\n        xxx = radius\n\n        if xlm[0] == 0 and xlm[1] == 0:\n            indtop = 0\n            indbot = len(mass)-1\n        else: \n            indbot = np.where(radius>=xlm[0])[0][-1]\n            indtop = np.where(radius<xlm[1])[0][0]\n\t   \n\n        xll = (radius[indbot],radius[indtop])\n        xxlabel = \"Radius (Mm)\"\n   \n    elif xaxis is \"Lagrangian\": \n        xxx = mass\n        xll = xlm\n        xxlabel = \"$M / \\mathrm{M_{sun}}$\"\n    else:\n        print(\"Error: don't understand xaxis choice, must be Lagrangian or Eulerian\")\n\n\n    for i in range(4):\n        for thing in abus[i]:\n            ind = abus[i].index(thing)\n            ax[i].plot(xxx, np.log10(p.get(thing)), ls=u.linestylecb(ind,a,b)[0],\\\n            marker=u.linestylecb(ind,a,b)[1], color=u.linestylecb(ind,a,b)[2],\\\n            markevery=50,label=thing)\n    # set x and y lims and labels\n        ax[i].set_ylim(ylm)\n        ax[i].set_xlim(xll)\n        ax[i].legend(loc=1)\n        ax[i].set_xlabel(xxlabel)\n        if i%2 == 0:\n            ax[i].set_ylabel('log X')\n       # ax[i].set_aspect('equal')\n   \n    title_str = \"Abundance plot: \"+'t ='+str(title_format%p.header_attr['star_age'])\\\n              +' dt ='+str(title_format%p.header_attr['time_step'])\\\n              +'model number = '+str(int(p.header_attr['model_number']))\n    f.suptitle(title_str, fontsize=12)\n    f.tight_layout()\n    f.subplots_adjust(left=0.1, bottom=0.1, right=0.95, top=0.9, wspace=0, hspace=0.1)\n    f.savefig('abuprof'+str(int(p.header_attr['model_number'])).zfill(6)+'.png')"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef other_profiles(p,ifig=1,xlm=xlm,show=False,xaxis=xaxis_type, figsize2=(10,8)):\n    '''Four panels of other profile plots\n   \n   Parameters\n    ----------\n\n    p : instance\n      mesa_profile instance\n\n    xll : tuple\n      xlimits: mass_min, mass_max\n  \n\n    show : Boolean\n      False  for batch use\n      True   for interactive use\n    '''\n\n    matplotlib.rc('figure',facecolor='white',figsize=figsize2)\n\n    mass = p.get('mass')                      # in units of Msun\n    radius = p.get('radius')*ast.rsun_cm/1.e8  # in units of Mm\n    if xaxis is \"Eulerian\":\n        xxx = radius\n        if xlm[0]==0 and xlm[1] == 0:\n            indtop = 0\n            indbot = len(mass)-1\n        else: \n            indbot = np.where(radius>=xlm[0])[0][-1]\n            indtop = np.where(radius<xlm[1])[0][0]\n        xll = (radius[indbot],radius[indtop])\n        xxlabel = \"radius (Mm)\"\n    elif xaxis is \"Lagrangian\": \n        xxx = mass\n        xll = xlm\n        xxlabel = \"$M / \\mathrm{M_{sun}}$\"\n    else:\n        print(\"Error: don't understand xaxis choice, must be Lagrangian or Eulerian\")\n\n\n    # create subplot structure\n    t, ([ax1,ax2],[ax3, ax4],[ax5,ax6]) = matplotlib.pyplot.subplots(3, 2, sharex=True, sharey=False)\n    \n# panel 1: burns: pp, cno, burn_c\n# panel 2: convection and mixing: entropy, Tgrad\n\n\n    # which burning to show\n    Enuc = ['pp','cno','tri_alfa','burn_c','burn_o','burn_n','burn_si','burn_mg','burn_na','burn_ne','eps_nuc']\n    ax = ax1\n    for thing in Enuc:\n        ind = Enuc.index(thing)\n        ax.plot(xxx, np.log10(p.get(thing)), ls=u.linestylecb(ind,a,b)[0],\\\n             marker=u.linestylecb(ind,a,b)[1], color=u.linestylecb(ind,a,b)[2],\\\n             markevery=50,label=thing)\n        \n    # set x and y lims and labels\n    #ax.set_title('Nuclear Energy Production')\n    ax.set_ylim(0,15)\n    ax.set_xlim(xll)\n    ax.legend(loc=1, ncol=2, fontsize='small')\n    #ax.set_xlabel(xxlabel)\n    ax.set_ylabel('$ \\log \\epsilon $')\n#--------------------------------------------------------------------------------------------#\n\n    # gradients\n\n    mix = [['gradr']]\n    mix1 = [['grada']]\n    \n    for i in range(1):\n        for thing in mix[i]:\n            ind = mix[i].index(thing)\n    for i in range(1):\n        for thing1 in mix1[i]:\n            ind1 = mix1[i].index(thing1)\n            ax2.plot(xxx, (np.tanh(np.log10(p.get(thing))-np.log10(p.get(thing1))))\\\n            ,ls=u.linestylecb(ind,a,b)[0],\\\n             marker=u.linestylecb(ind,a,b)[1], color=u.linestylecb(ind,a,b)[2],\\\n             markevery=50,label=thing)\n    # set x and y lims and labels\n    ax2.axhline(ls='dashed',color='black',label=\"\")\n    #ax2.set_title('Mixing Regions')\n    ax2.yaxis.tick_right()\n    ax2.yaxis.set_label_position(\"right\")\n    ax2.set_ylim(-.1,.1)\n    ax2.set_xlim(xll)\n    ax2.legend(labels='Mixing',loc=1)\n    #ax2.set_xlabel(xxlabel)\n    ax2.set_ylabel('$\\\\tanh(\\\\log(\\\\frac{\\\\nabla_{rad}}{\\\\nabla_{ad}}))$')\n\n#--------------------------------------------------------------------------------------------#\n\n    # entropy\n    S = ['entropy']\n\n    ax = ax5\n    \n    for thing in S:\n        ind = 2\n        ax.plot(xxx, p.get(thing), ls=u.linestylecb(ind,a,b)[0],\\\n         marker=u.linestylecb(ind,a,b)[1], color=u.linestylecb(ind,a,b)[2],\\\n         markevery=50,label=thing)\n    # set x and y lims and labels\n    #ax.set_title('Specific Entropy (/A*kerg)')\n    ax.set_ylim(0,50)\n    ax.set_xlim(xll)\n    ax.legend(loc=1)\n    ax.set_xlabel(xxlabel)\n    ax.set_ylabel(' Specific Entropy')\n\n#--------------------------------------------------------------------------------------------#\n    # rho, mu, T\n    S = ['logRho','mu','temperature']\n    T8 = [False,False,True]\n    ax = ax6\n\n    for thing in S:\n        ind = S.index(thing)\n        thisy = p.get(thing)/1.e8 if T8[ind] else p.get(thing)\n        ax.plot(xxx, thisy, ls=u.linestylecb(ind,a,b)[0],\\\n         marker=u.linestylecb(ind,a,b)[1], color=u.linestylecb(ind,a,b)[2],\\\n         markevery=50,label=thing)\n    # set x and y lims and labels                                                              \n    #ax.set_title('Rho, mu, T')\n    ax.set_ylim(0.,9.)\n    ax.set_xlim(xll)\n    ax.legend(loc=0)\n    ax.set_xlabel(xxlabel)\n    ax.set_ylabel('log Rho, mu, T8')\n\n\n#--------------------------------------------------------------------------------------------#\n\n    \n    # gas pressure fraction and opacity\n    S = ['pgas_div_ptotal']\n    o = ['log_opacity']\n\n    ax = ax4\n    axo = ax.twinx()\n    \n    for thing in S:\n        ind = 5\n        ax.plot(xxx, p.get(thing), ls=u.linestylecb(ind,a,b)[0],\\\n         marker=u.linestylecb(ind,a,b)[1], color=u.linestylecb(ind,a,b)[2],\\\n         markevery=50,label=thing)\n\n    for thing in o:\n        ind = 3\n        axo.plot(xxx, p.get(thing), ls=u.linestylecb(ind,a,b)[0],\\\n         marker=u.linestylecb(ind,a,b)[1], color=u.linestylecb(ind,a,b)[2],\\\n         markevery=50,label=thing)\n\n   \n    # set x and y lims and labels\n   # ax.set_title('Pgas fraction + opacity')\n   # ax.set_ylim(0,60)\n    ax.set_xlim(xll)\n    axo.set_xlim(xll)\n    ax.legend(loc=0)\n    axo.legend(loc=(.15,.85))\n    #ax.set_xlabel(xxlabel)\n    ax.set_ylabel('$\\mathrm{ P_{gas} / P_{tot}}$')\n    axo.set_ylabel('$ log(Opacity)$')\n\n#--------------------------------------------------------------------------------------------#\n\n    # Diffusion coefficient\n    gT = ['log_D_mix','conv_vel_div_csound']\n    logy = [False,True]\n    \n    ax = ax3\n    ind = 0\n    for thing in gT:\n        ind = gT.index(thing)\n        thisx = np.log(p.get(thing))+16 if logy[ind] else p.get(thing)\n        ax.plot(xxx, thisx, ls=u.linestylecb(ind,a,b)[0],\\\n         marker=u.linestylecb(ind,a,b)[1], color=u.linestylecb(ind,a,b)[2],\\\n         markevery=50,label=thing)\n# set x and y lims and labels\n    ax.axhline(16,ls='dashed',color='black',label=\"$\\mathrm{Ma}=0$\")\n   # ax.set_title('Mixing')\n    ax.set_ylim(10,17)\n    ax.set_xlim(xll)\n    ax.legend(loc=0)\n   # ax.set_xlabel(xxlabel)\n    ax.set_ylabel('$\\\\log D / [cgs] \\\\log v_{\\mathrm{conv}}/c_s + 16 $ ')\n\n    title_str = \"Other profiles: \"+'t ='+str(title_format%p.header_attr['star_age'])\\\n              +', dt ='+str(title_format%p.header_attr['time_step'])\\\n              +', model number ='+str(int(p.header_attr['model_number']))\n    t.suptitle(title_str, fontsize=12)\n   # t.tight_layout()\n    t.subplots_adjust(left=0.1, bottom=0.1, right=0.9, top=0.9, wspace=0.15, hspace=0.1)\n    t.savefig('other'+str(int(p.header_attr['model_number'])).zfill(6)+'.png')", "response": "Plots the other profiles of a Msun object."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreads the profiles. index file and make hash array", "response": "def _profiles_index(self):\n        \"\"\"\n        read profiles.index and make hash array\n\n        Notes\n        -----\n        sets the attributes.\n\n        log_ind : hash array that returns profile.data or log.data\n        file number from model number.\n\n        model : the models for which profile.data or log.data is\n        available\n\n        \"\"\"\n\n        prof_ind_name = self.prof_ind_name\n\n        f = open(self.sldir+'/'+prof_ind_name,'r')\n        line = f.readline()\n        numlines=int(line.split()[0])\n        print(str(numlines)+' in profiles.index file ...')\n\n        model=[]\n        log_file_num=[]\n        for line in f:\n            model.append(int(line.split()[0]))\n            log_file_num.append(int(line.split()[2]))\n\n        log_ind={}    # profile.data number from model\n        for a,b in zip(model,log_file_num):\n            log_ind[a] = b\n\n        self.log_ind=log_ind\n        self.model=model"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _log_file_ind(self,inum):\n\n        self._profiles_index()\n        if inum <= 0:\n            print(\"Smallest argument is 1\")\n            return\n\n        inum_max = len(self.log_ind)\n        inum -= 1\n\n        if inum > inum_max:\n            print('There are only '+str(inum_max)+' profile file available.')\n            log_data_number = -1\n            return log_data_number\n        else:\n            log_data_number=self.log_ind[self.model[inum]]\n            print('The '+str(inum+1)+'. profile.data file is '+ \\\n                  str(log_data_number))\n            return log_data_number", "response": "Returns the number of profile. data files that are available for the specified inum."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets a column of data with the name str_name", "response": "def get(self,str_name):\n        \"\"\"\n        return a column of data with the name str_name.\n\n        Parameters\n        ----------\n        str_name : string\n            Is the name of the column as printed in the\n            profilennn.data or lognnn.data file; get the available\n            columns from self.cols (where you replace self with the\n            name of your instance)\n\n        \"\"\"\n\n        column_array = self.data[:,self.cols[str_name]-1].astype('float')\n        return column_array"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nwrites a PROMETHEUS HBOT supernova file for the specified class.", "response": "def write_PROM_HOTB_progenitor(self,name,description):\n        \"\"\"\n        Write a progenitor file for the PROMETHEUS/HBOT supernova code.\n\n        Parameters\n        ----------\n        name : string\n            File name for the progenitor file\n        description : string\n            Information to be written into the file header.\n        \"\"\"\n        try:\n            from ProgenitorHotb_new import ProgenitorHotb_new\n        except ImportError:\n            print('Module ProgenitorHotb_new not found.')\n            return\n        \n        nz=len(self.get('mass'))\n        prog=ProgenitorHotb_new(nz)\n\n        prog.header = '#'+description+'\\n'\n\n        prog.xzn    = self.get('rmid')[::-1]*ast.rsun_cm\n        prog.massb  = self.get('mass')[::-1]\n        prog.r_ob   = max(self.get('radius'))*ast.rsun_cm\n        prog.temp   = 10.**self.get('logT')[::-1]*8.620689655172413e-11 # in MeV\n        prog.stot   = self.get('entropy')[::-1]\n        prog.ye     = self.get('ye')[::-1]\n        prog.densty = 10.**self.get('logRho')[::-1]\n        prog.press  = 10.**self.get('logP')[::-1]\n        prog.eint   = self.get('energy')[::-1]\n        prog.velx   = self.get('velocity')[::-1]\n\n        nuclei=['neut','h1','he4','c12','o16','ne20','mg24','si28','s32',\n                'ar36','ca40','ti44','cr48','fe52','fake']\n\n        for i in range(len(nuclei)):\n            if nuclei[i] == 'fake':\n                ni56 = self.get('fe56')+self.get('cr56')\n                prog.xnuc[:,i] = ni56[::-1]\n            else:\n                prog.xnuc[:,i] = self.get(nuclei[i])[::-1]\n\n        prog.write(name)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nwrite an initial model in a format that may easily be read by the radiation hydrodynamics code STELLA. Parameters ---------- name : string an identifier for the model. There are two output files from this method, which will be <name>.hyd and <name>.abn, which contain the profiles for the hydro and abundance variables, respectively.", "response": "def write_STELLA_model(self,name):\n        \"\"\"\n        Write an initial model in a format that may easily be read by the\n        radiation hydrodynamics code STELLA.\n\n        Parameters\n        ----------\n        name : string\n            an identifier for the model. There are two output files from\n            this method, which will be <name>.hyd and <name>.abn, which\n            contain the profiles for the hydro and abundance variables,\n            respectively.\n\n        \"\"\"\n\n        # Hydro variables:\n        zn = np.array(self.get('zone'),np.int64)\n        Mr = self.get('mass')[::-1]\n        dM = 10. ** self.get('logdq')[::-1] * self.header_attr['star_mass']\n        R = self.get('radius')[::-1] * ast.rsun_cm\n        dR = np.insert( np.diff(R), 0, R[0] )\n        Rho = 10. ** self.get('logRho')[::-1]\n        PRE = 10. ** self.get('logP')[::-1]\n        T = 10. ** self.get('logT')[::-1]\n        V = self.get('velocity')[::-1]\n\n        # Abundances:\n        def make_list(element,lowA,highA):\n            l = []\n            for i in range(lowA,highA+1):\n                l.append(element+str(i))\n            return l\n\n        abun_avail = list(self.cols.keys())\n\n        def elemental_abund(ilist,abun_avail):\n            X = np.zeros(len(self.get('mass')))\n            for a in ilist:\n                if a in abun_avail:\n                    X += self.get(a)[::-1]\n\n            return X\n\n        iH = ['h1','h2','prot']\n        XH  = elemental_abund(iH, abun_avail)\n        XHe = elemental_abund(make_list('he',1,5), abun_avail)\n        XC  = elemental_abund(make_list('c',11,15), abun_avail)\n        XN  = elemental_abund(make_list('n',12,16), abun_avail)\n        XO  = elemental_abund(make_list('o',13,20), abun_avail)\n        XNe = elemental_abund(make_list('ne',17,25), abun_avail)\n        XNa = elemental_abund(make_list('na',20,25), abun_avail)\n        XMg = elemental_abund(make_list('mg',21,28), abun_avail)\n        XAl = elemental_abund(make_list('al',21,30), abun_avail)\n        XSi = elemental_abund(make_list('si',25,34), abun_avail)\n        XS  = elemental_abund(make_list('s',28,38), abun_avail)\n        XAr = elemental_abund(make_list('ar',32,46), abun_avail)\n        XCa = elemental_abund(make_list('ca',36,53), abun_avail)\n        XFe = elemental_abund(make_list('fe',50,65), abun_avail)\n        XCo = elemental_abund(make_list('co',52,66), abun_avail)\n        XNi = elemental_abund(make_list('ni',54,71), abun_avail)\n\n        XNi56 = self.get('ni56')\n\n        # Write the output files:\n        file_hyd = name+'.hyd'\n        file_abn = name+'.abn'\n\n        f = open(file_hyd,'w')\n        # write header:\n        f.write('  0.000E+00\\n')\n        f.write('# No.')\n        f.write('Mr'.rjust(28)+\n                'dM'.rjust(28)+\n                'R'.rjust(28)+\n                'dR'.rjust(28)+\n                'Rho'.rjust(28)+\n                'PRE'.rjust(28)+\n                'T'.rjust(28)+\n                'V'.rjust(28)+\n                '\\n')\n        # write data:\n        for i in range(len(zn)):\n            f.write( str(zn[i]).rjust(5) +\n                    '%.16E'.rjust(11) %Mr[i] +\n                    '%.16E'.rjust(11) %dM[i] +\n                    '%.16E'.rjust(11) %R[i] +\n                    '%.16E'.rjust(11) %dR[i] +\n                    '%.16E'.rjust(11) %Rho[i] +\n                    '%.16E'.rjust(11) %PRE[i] +\n                    '%.16E'.rjust(11) %T[i] +\n                    '%.16E'.rjust(11) %V[i] +\n                    '\\n')\n\n        f.close()\n\n        f = open(file_abn,'w')\n        # write header:\n        f.write('# No.')\n        f.write('Mr'.rjust(28)+\n                'H'.rjust(28)+\n                'He'.rjust(28)+\n                'C'.rjust(28)+\n                'N'.rjust(28)+\n                'O'.rjust(28)+\n                'Ne'.rjust(28)+\n                'Na'.rjust(28)+\n                'Mg'.rjust(28)+\n                'Al'.rjust(28)+\n                'Si'.rjust(28)+\n                'S'.rjust(28)+\n                'Ar'.rjust(28)+\n                'Ca'.rjust(28)+\n                'Fe'.rjust(28)+\n                'Co'.rjust(28)+\n                'Ni'.rjust(28)+\n                'X(56Ni)'.rjust(28)+\n                '\\n')\n        # write data:\n        for i in range(len(zn)):\n            f.write( str(zn[i]).rjust(5) +\n                    '%.16E'.rjust(11) %Mr[i] +\n                    '%.16E'.rjust(11) %XH[i] +\n                    '%.16E'.rjust(11) %XHe[i] +\n                    '%.16E'.rjust(11) %XC[i] +\n                    '%.16E'.rjust(11) %XN[i] +\n                    '%.16E'.rjust(11) %XO[i] +\n                    '%.16E'.rjust(11) %XNe[i] +\n                    '%.16E'.rjust(11) %XNa[i] +\n                    '%.16E'.rjust(11) %XMg[i] +\n                    '%.16E'.rjust(11) %XAl[i] +\n                    '%.16E'.rjust(11) %XSi[i] +\n                    '%.16E'.rjust(11) %XS[i] +\n                    '%.16E'.rjust(11) %XAr[i] +\n                    '%.16E'.rjust(11) %XCa[i] +\n                    '%.16E'.rjust(11) %XFe[i] +\n                    '%.16E'.rjust(11) %XCo[i] +\n                    '%.16E'.rjust(11) %XNi[i] +\n                    '%.16E'.rjust(11) %XNi56[i] +\n                    '\\n')"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nplots radial profile of key energy generations", "response": "def energy_profile(self,ixaxis):\n        \"\"\"\n            Plot radial profile of key energy generations eps_nuc,\n            eps_neu etc.\n\n            Parameters\n            ----------\n            ixaxis : 'mass' or 'radius'\n        \"\"\"\n\n        mass = self.get('mass')\n        radius = self.get('radius') * ast.rsun_cm\n        eps_nuc = self.get('eps_nuc')\n        eps_neu = self.get('non_nuc_neu')\n\n        if ixaxis == 'mass':\n            xaxis = mass\n            xlab = 'Mass / M$_\\odot$'\n        else:\n            xaxis = old_div(radius, 1.e8) # Mm\n            xlab = 'Radius (Mm)'\n\n        pl.plot(xaxis, np.log10(eps_nuc),\n                'k-',\n                label='$\\epsilon_\\mathrm{nuc}>0$')\n        pl.plot(xaxis, np.log10(-eps_nuc),\n                'k--',\n                label='$\\epsilon_\\mathrm{nuc}<0$')\n        pl.plot(xaxis, np.log10(eps_neu),\n                'r-',\n                label='$\\epsilon_\\\\nu$')\n\n        pl.xlabel(xlab)\n        pl.ylabel('$\\log(\\epsilon_\\mathrm{nuc},\\epsilon_\\\\nu)$')\n        pl.legend(loc='best').draw_frame(False)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreads history. data or star. log file again", "response": "def _read_starlog(self):\n        \"\"\" read history.data or star.log file again\"\"\"\n\n        sldir   = self.sldir\n        slname  = self.slname\n        slaname = slname+'sa'\n\n        if not os.path.exists(sldir+'/'+slaname):\n            print('No '+self.slname+'sa file found, create new one from '+self.slname)\n            _cleanstarlog(sldir+'/'+slname)\n        else:\n            if self.clean_starlog:\n                print('Requested new '+self.slname+'sa; create new from '+self.slname)\n                _cleanstarlog(sldir+'/'+slname)\n            else:\n                print('Using old '+self.slname+'sa file ...')\n\n        cmd=os.popen('wc '+sldir+'/'+slaname)\n        cmd_out=cmd.readline()\n        cnum_cycles=cmd_out.split()[0]\n        num_cycles=int(cnum_cycles) - 6\n\n        filename=sldir+'/'+slaname\n\n        header_attr,cols,data = _read_mesafile(filename,data_rows=num_cycles)\n\n        self.cols        = cols\n        self.header_attr = header_attr\n        self.data        = data"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nplot the surface C / O ratio in the specified x - axis.", "response": "def CO_ratio(self,ifig,ixaxis):\n        \"\"\"\n        plot surface C/O ratio in Figure ifig with x-axis quantity ixaxis\n\n        Parameters\n        ----------\n        ifig : integer\n            Figure number in which to plot\n        ixaxis : string\n            what quantity is to be on the x-axis, either 'time' or 'model'\n            The default is 'model'\n        \"\"\"\n\n        def C_O(model):\n            surface_c12=model.get('surface_c12')\n            surface_o16=model.get('surface_o16')\n            CORatio=old_div((surface_c12*4.),(surface_o16*3.))\n            return CORatio\n\n        if ixaxis=='time':\n            xax=self.get('star_age')\n        elif ixaxis=='model':\n            xax=self.get('model_number')\n        else:\n            raise IOError(\"ixaxis not recognised\")\n\n        pl.figure(ifig)\n        pl.plot(xax,C_O(self))"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nplots an HR diagram of the current state of the object.", "response": "def hrd(self,ifig=None,label=None,colour=None,s2ms=False,\n            dashes=None,**kwargs):\n        \"\"\"\n        Plot an HR diagram\n\n        Parameters\n        ----------\n        ifig : integer or string\n            Figure label, if None the current figure is used\n            The default value is None.\n        lims : list [x_lower, x_upper, y_lower, y_upper]\n        label : string\n            Label for the model\n            The default value is None\n        colour : string\n            The colour of the line\n            The default value is None\n        s2ms : boolean, optional\n            \"Skip to Main Sequence\"?\n            The default is False.\n        dashes : list, optional\n            Custom dashing style. If None, ignore.\n            The default is None.\n\n        \"\"\"\n\n#        fsize=18\n#\n#        params = {'axes.labelsize':  fsize,\n#        #    'font.family':       'serif',\n#        'font.family':        'Times New Roman',\n#        'figure.facecolor':  'white',\n#        'text.fontsize':     fsize,\n#        'legend.fontsize':   fsize,\n#        'xtick.labelsize':   fsize*0.8,\n#        'ytick.labelsize':   fsize*0.8,\n#        'text.usetex':       False}\n#\n#        try:\n#            pl.rcParams.update(params)\n#        except:\n#            pass\n\n        if ifig is not None:\n            pl.figure(ifig)\n\n        if s2ms:\n            h1=self.get('center_h1')\n            idx=np.where(h1[0]-h1>=3.e-3)[0][0]\n            skip=idx\n        else:\n            skip=0\n\n        x = self.get('log_Teff')[skip:]\n        y = self.get('log_L')[skip:]\n\n        if label is not None:\n            if colour is not None:\n                line,=pl.plot(x,y,label=label,color=colour,**kwargs)\n            else:\n                line,=pl.plot(x,y,label=label,**kwargs)\n        else:\n            if colour is not None:\n                line,=pl.plot(x,y,color=colour,**kwargs)\n            else:\n                line,=pl.plot(x,y,**kwargs)\n\n        if dashes is not None:\n            line.set_dashes(dashes)\n        if label is not None:\n            pl.legend(loc='best').draw_frame(False)\n\n\n#        pyl.plot(self.data[:,self.cols['log_Teff']-1],\\\n#                 self.data[:,self.cols['log_L']-1],\\\n#                 label = \"M=\"+str(self.header_attr['initial_mass'])+\", Z=\"\\\n#                 +str(self.header_attr['initial_z']))\n\n        pyl.xlabel('$\\log T_{\\\\rm eff}$')\n        pyl.ylabel('$\\log L$')\n        x1,x2=pl.xlim()\n        if x2 > x1:\n            ax=pl.gca()\n            ax.invert_xaxis()"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef hrd_key(self, key_str):\n\n        pyl.plot(self.data[:,self.cols['log_Teff']-1],\\\n                 self.data[:,self.cols['log_L']-1],label = key_str)\n        pyl.legend()\n        pyl.xlabel('log Teff')\n        pyl.ylabel('log L')\n        x1,x2=pl.xlim()\n        if x2 > x1:\n            self._xlimrev()", "response": "This function plots an HR diagram of the related class."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef hrd_new(self, input_label=\"\", skip=0):\n        xl_old=pyl.gca().get_xlim()\n        if input_label == \"\":\n            my_label=\"M=\"+str(self.header_attr['initial_mass'])+\", Z=\"+str(self.header_attr['initial_z'])\n        else:\n            my_label=\"M=\"+str(self.header_attr['initial_mass'])+\", Z=\"+str(self.header_attr['initial_z'])+\"; \"+str(input_label)\n\n        pyl.plot(self.data[skip:,self.cols['log_Teff']-1],self.data[skip:,self.cols['log_L']-1],label = my_label)\n        pyl.legend(loc=0)\n        xl_new=pyl.gca().get_xlim()\n        pyl.xlabel('log Teff')\n        pyl.ylabel('log L')\n        if any(array(xl_old)==0):\n            pyl.gca().set_xlim(max(xl_new),min(xl_new))\n        elif any(array(xl_new)==0):\n            pyl.gca().set_xlim(max(xl_old),min(xl_old))\n        else:\n            pyl.gca().set_xlim([max(xl_old+xl_new),min(xl_old+xl_new)])", "response": "Plot an HR diagram with options to skip the first N lines and add a label string"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef xche4_teff(self,ifig=None,lims=[1.,0.,3.4,4.7],label=None,colour=None,\n                   s2ms=True,dashes=None):\n        \"\"\"\n        Plot effective temperature against central helium abundance.\n\n        Parameters\n        ----------\n        ifig : integer or string\n            Figure label, if None the current figure is used\n            The default value is None.\n        lims : list [x_lower, x_upper, y_lower, y_upper]\n        label : string\n        Label for the model\n            The default value is None\n        colour : string\n            The colour of the line\n            The default value is None\n        s2ms : boolean, optional\n            \"Skip to Main Sequence\"\n            The default is True\n        dashes : list, optional\n            Custom dashing style. If None, ignore.\n            The default is None.\n\n        \"\"\"\n        fsize=18\n        params = {'axes.labelsize':  fsize,\n        #    'font.family':       'serif',\n        'font.family':        'Times New Roman',\n        'figure.facecolor':  'white',\n        'text.fontsize':     fsize,\n        'legend.fontsize':   fsize,\n        'xtick.labelsize':   fsize*0.8,\n        'ytick.labelsize':   fsize*0.8,\n        'text.usetex':       False}\n\n        try:\n            pl.rcParams.update(params)\n        except:\n            pass\n\n\n        if s2ms:\n            h1=self.get('center_h1')\n            idx=np.where(h1[0]-h1>=1.e-3)[0][0]\n            skip=idx\n        else:\n            skip=0\n\n        x = self.get('center_he4')[skip:]\n        y = self.get('log_Teff')[skip:]\n        if ifig is not None:\n            pl.figure(ifig)\n        if label is not None:\n            if colour is not None:\n                line,=pl.plot(x,y,label=label,color=colour)\n            else:\n                line,=pl.plot(x,y,label=label)\n            pl.legend(loc='best').draw_frame(False)\n        else:\n            if colour is not None:\n                line,=pl.plot(x,y,color=colour)\n            else:\n                line,=pl.plot(x,y)\n\n        if dashes is not None:\n            line.set_dashes(dashes)\n\n        if label is not None:\n            pl.legend(loc='best').draw_frame(False)\n\n        pl.xlim(lims[:2])\n        pl.ylim(lims[2:])\n        pl.xlabel('$X_{\\\\rm c}(\\,^4{\\\\rm He}\\,)$')\n        pl.ylabel('$\\log\\,T_{\\\\rm eff}$')", "response": "Plots effective temperature against central helium abundance."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef tcrhoc(self,ifig=None,lims=[3.,10.,8.,10.],label=None,colour=None,\n               dashes=None):\n        \"\"\"\n        Central temperature again central density plot\n\n        Parameters\n        ----------\n        ifig : integer or string\n            Figure label, if None the current figure is used\n            The default value is None.\n        lims : list [x_lower, x_upper, y_lower, y_upper]\n        label : string\n            Label for the model\n            The default value is None\n        colour : string\n            The colour of the line\n            The default value is None\n        dashes : list, optional\n            Custom dashing style. If None, ignore.\n            The default is None.\n\n        \"\"\"\n\n#        fsize=18\n#\n#        params = {'axes.labelsize':  fsize,\n#            #    'font.family':       'serif',\n#        'font.family':        'Times New Roman',\n#        'figure.facecolor':  'white',\n#        'text.fontsize':     fsize,\n#        'legend.fontsize':   fsize,\n#        'xtick.labelsize':   fsize*0.8,\n#        'ytick.labelsize':   fsize*0.8,\n#        'text.usetex':       False}\n#\n#        try:\n#            pl.rcParams.update(params)\n#        except:\n#            pass\n\n        if ifig is not None:\n            pl.figure(ifig)\n\n        if label is not None:\n            if colour is not None:\n                line,=pl.plot(self.get('log_center_Rho'),self.get('log_center_T'),label=label,\n                        color=colour)\n            else:\n                line,=pl.plot(self.get('log_center_Rho'),self.get('log_center_T'),label=label)\n\n        else:\n            if colour is not None:\n                line,=pl.plot(self.get('log_center_Rho'),self.get('log_center_T'),\n                        color=colour)\n            else:\n                line,=pl.plot(self.get('log_center_Rho'),self.get('log_center_T'))\n        if dashes is not None:\n            line.set_dashes(dashes)\n        if label is not None:\n            pl.legend(loc='best').draw_frame(False)\n\n        pl.xlim(lims[:2])\n        pl.ylim(lims[2:])\n        pl.xlabel('log $\\\\rho_{\\\\rm c}$')\n        pl.ylabel('log $T_{\\\\rm c}$')", "response": "Function to plot the current state of the object."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nplots mass loss history as a function of log - time - left.", "response": "def mdot_t(self,ifig=None,lims=[7.4,2.6,-8.5,-4.5],label=None,colour=None,s2ms=False,\n               dashes=None):\n        \"\"\"\n        Plot mass loss history as a function of log-time-left\n\n        Parameters\n        ----------\n        ifig : integer or string\n            Figure label, if None the current figure is used\n            The default value is None.\n        lims : list [x_lower, x_upper, y_lower, y_upper]\n        label : string\n            Label for the model\n            The default value is None\n        colour : string\n            The colour of the line\n            The default value is None\n        s2ms : boolean, optional\n            \"skip to main sequence\"\n        dashes : list, optional\n            Custom dashing style. If None, ignore.\n            The default is None.\n\n        \"\"\"\n\n        fsize=18\n\n        params = {'axes.labelsize':  fsize,\n        #    'font.family':       'serif',\n        'font.family':        'Times New Roman',\n        'figure.facecolor':  'white',\n        'text.fontsize':     fsize,\n        'legend.fontsize':   fsize,\n        'xtick.labelsize':   fsize*0.8,\n        'ytick.labelsize':   fsize*0.8,\n        'text.usetex':       False}\n\n        try:\n            pl.rcParams.update(params)\n        except:\n            pass\n\n        if ifig is not None:\n            pl.figure(ifig)\n\n        if s2ms:\n            h1=self.get('center_h1')\n            idx=np.where(h1[0]-h1>=3.e-3)[0][0]\n            skip=idx\n        else:\n            skip=0\n\n        gage= self.get('star_age')\n        lage=np.zeros(len(gage))\n        agemin = max(old_div(abs(gage[-1]-gage[-2]),5.),1.e-10)\n        for i in np.arange(len(gage)):\n            if gage[-1]-gage[i]>agemin:\n                lage[i]=np.log10(gage[-1]-gage[i]+agemin)\n            else :\n                lage[i]=np.log10(agemin)\n        x = lage[skip:]\n        y = self.get('log_abs_mdot')[skip:]\n\n        if ifig is not None:\n            pl.figure(ifig)\n        if label is not None:\n            if colour is not None:\n                line,=pl.plot(x,y,label=label,color=colour)\n            else:\n                line,=pl.plot(x,y,label=label)\n        else:\n            if colour is not None:\n                line,=pl.plot(x,y,color=colour)\n            else:\n                line,=pl.plot(x,y)\n\n        if dashes is not None:\n            line.set_dashes(dashes)\n        if label is not None:\n            pl.legend(loc='best').draw_frame(False)\n\n        pl.xlim(lims[:2])\n        pl.ylim(lims[2:])\n        pl.ylabel('$\\mathrm{log}_{10}(\\|\\dot{M}\\|/M_\\odot\\,\\mathrm{yr}^{-1})$')\n        pl.xlabel('$\\mathrm{log}_{10}(t^*/\\mathrm{yr})$')"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nplots mass of [ oclark01@scandium 15M_led_f_print_nets ]$ cp.. / 15M_led_f_ppcno.", "response": "def mcc_t(self,ifig=None,lims=[0,15,0,25],label=None,colour=None,\n              mask=False,s2ms=False,dashes=None):\n        \"\"\"\n        Plot mass of [oclark01@scandium 15M_led_f_print_nets]$ cp ../15M_led_f_ppcno/ective core as a function of time.\n\n        Parameters\n        ----------\n        ifig : integer or string\n            Figure label, if None the current figure is used\n            The default value is None.\n        lims : list [x_lower, x_upper, y_lower, y_upper]\n        label : string\n            Label for the model\n            The default value is None\n        colour : string\n            The colour of the line\n            The default value is None\n        mask : boolean, optional\n            Do you want to try to hide numerical spikes in the\n            plot?\n            The default is False\n        s2ms : boolean, optional\n            skip to main squence?\n        dashes : list, optional\n            Custom dashing style. If None, ignore.\n            The default is None.\n\n        \"\"\"\n\n        fsize=18\n\n        params = {'axes.labelsize':  fsize,\n        #    'font.family':       'serif',\n        'font.family':        'Times New Roman',\n        'figure.facecolor':  'white',\n        'text.fontsize':     fsize,\n        'legend.fontsize':   fsize,\n        'xtick.labelsize':   fsize*0.8,\n        'ytick.labelsize':   fsize*0.8,\n        'text.usetex':       False}\n\n        try:\n            pl.rcParams.update(params)\n        except:\n            pass\n\n        if ifig is not None:\n            pl.figure(ifig)\n\n        if s2ms:\n            h1=self.get('center_h1')\n            idx=np.where(h1[0]-h1>=3.e-3)[0][0]\n            skip=idx\n        else:\n            skip=0\n\n        age= self.get('star_age')\n        x1 = old_div(age, 1.e6)\n        x2 = old_div(age, 1.e6)\n        y1 = self.get('mix_qtop_1')*self.get('star_mass')\n        y2 = self.get('mix_qtop_2')*self.get('star_mass')\n        mt1 = self.get('mix_type_1')\n        mt2 = self.get('mix_type_2')\n\n        x1 = x1[skip:]\n        x2 = x2[skip:]\n        y1 = y1[skip:]\n        y2 = y2[skip:]\n        mt1 = mt1[skip:]\n        mt2 = mt2[skip:]\n\n        # Mask spikes...\n        if mask:\n            x1 = np.ma.masked_where(mt1 != 1, x1)\n            x2 = np.ma.masked_where(mt2 != 1, x2)\n            y1 = np.ma.masked_where(mt1 != 1, y1)\n            y2 = np.ma.masked_where(mt2 != 1, y2)\n\n        if ifig is not None:\n            pl.figure(ifig)\n        if label is not None:\n            if colour is not None:\n                line,=pl.plot(x1,y1,label=label,color=colour)\n                line,=pl.plot(x2,y2,color=colour)\n            else:\n                line,=pl.plot(x1,y1,label=label)\n                line,=pl.plot(x2,y2)\n        else:\n            if colour is not None:\n                line,=pl.plot(x1,y1,color=colour)\n                line,=pl.plot(x2,y2,color=colour)\n            else:\n                line,=pl.plot(x1,y1)\n                line,=pl.plot(x2,y2)\n\n        if dashes is not None:\n            line.set_dashes(dashes)\n\n        if label is not None:\n            pl.legend(loc='best').draw_frame(False)\n\n        pl.xlim(lims[:2])\n        pl.ylim(lims[2:])\n        pl.ylabel('$M/M_\\odot}$')\n        pl.xlabel('$t/{\\\\rm Myr}$')"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nfunction to plot a Kippenhahn diagram.", "response": "def kippenhahn_CO(self, num_frame, xax, t0_model=0,\n                      title='Kippenhahn diagram', tp_agb=0.,\n                      ylim_CO=[0,0]):\n        \"\"\"\n        Kippenhahn plot as a function of time or model with CO ratio\n\n        Parameters\n        ----------\n        num_frame : integer\n            Number of frame to plot this plot into.\n        xax : string\n            Either model or time to indicate what is to be used on the\n            x-axis.\n        t0_model : integer, optional\n            Model for the zero point in time, for AGB plots this would\n            be usually the model of the 1st TP, which can be found with\n            the Kippenhahn plot.  The default is 0.\n        title : string, optional\n            Figure title.  The defalut is \"Kippenhahn diagram\".\n        tp_agb : float, optional\n            If >= 0 then,\n            ylim=[h1_min*1.-tp_agb/100 : h1_max*1.+tp_agb/100] with\n            h1_min, h1_max the min and max H-free core mass coordinate.\n            The defalut is 0.\n        ylim_CO : list\n            if ylim_CO is [0,0], then it is automaticly set.  The\n            default is [0,0].\n\n        \"\"\"\n\n        pyl.figure(num_frame)\n\n        if xax == 'time':\n            xaxisarray = self.get('star_age')\n        elif xax == 'model':\n            xaxisarray = self.get('model_number')\n        else:\n            print('kippenhahn_error: invalid string for x-axis selction.'+\\\n                  ' needs to be \"time\" or \"model\"')\n\n        t0_mod=xaxisarray[t0_model]\n\n        plot_bounds=True\n        try:\n            h1_boundary_mass  = self.get('h1_boundary_mass')\n            he4_boundary_mass = self.get('he4_boundary_mass')\n        except:\n            try:\n                h1_boundary_mass  = self.get('he_core_mass')\n                he4_boundary_mass = self.get('c_core_mass')\n            except:\n                plot_bounds=False\n\n        star_mass         = self.get('star_mass')\n        mx1_bot           = self.get('mx1_bot')*star_mass\n        mx1_top           = self.get('mx1_top')*star_mass\n        mx2_bot           = self.get('mx2_bot')*star_mass\n        mx2_top           = self.get('mx2_top')*star_mass\n        surface_c12       = self.get('surface_c12')\n        surface_o16       = self.get('surface_o16')\n\n        COratio=old_div((surface_c12*4.),(surface_o16*3.))\n\n        pyl.plot(xaxisarray[t0_model:]-t0_mod,COratio[t0_model:],'-k',label='CO ratio')\n        pyl.ylabel('C/O ratio')\n        pyl.legend(loc=4)\n        if ylim_CO[0] is not 0 and  ylim_CO[1] is not 0:\n            pyl.ylim(ylim_CO)\n        if xax == 'time':\n            pyl.xlabel('t / yrs')\n        elif xax == 'model':\n            pyl.xlabel('model number')\n\n        pyl.twinx()\n        if plot_bounds:\n            pyl.plot(xaxisarray[t0_model:]-t0_mod,h1_boundary_mass[t0_model:],label='h1_boundary_mass')\n            pyl.plot(xaxisarray[t0_model:]-t0_mod,he4_boundary_mass[t0_model:],label='he4_boundary_mass')\n        pyl.plot(xaxisarray[t0_model:]-t0_mod,mx1_bot[t0_model:],',r',label='conv bound')\n        pyl.plot(xaxisarray[t0_model:]-t0_mod,mx1_top[t0_model:],',r')\n        pyl.plot(xaxisarray[t0_model:]-t0_mod,mx2_bot[t0_model:],',r')\n        pyl.plot(xaxisarray[t0_model:]-t0_mod,mx2_top[t0_model:],',r')\n        pyl.plot(xaxisarray[t0_model:]-t0_mod,star_mass[t0_model:],label='star_mass')\n        pyl.ylabel('mass coordinate')\n        pyl.legend(loc=2)\n        if tp_agb > 0.:\n            h1_min = min(h1_boundary_mass[t0_model:])\n            h1_max = max(h1_boundary_mass[t0_model:])\n            h1_min = h1_min*(1.-old_div(tp_agb,100.))\n            h1_max = h1_max*(1.+old_div(tp_agb,100.))\n            print('setting ylim to zoom in on H-burning:',h1_min,h1_max)\n            pyl.ylim(h1_min,h1_max)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef kippenhahn(self, num_frame, xax, t0_model=0,\n                   title='Kippenhahn diagram', tp_agb=0., t_eps=5.e2,\n                   plot_star_mass=True, symbol_size=8, c12_bm=False,\n                   print_legend=True):\n        \"\"\"Kippenhahn plot as a function of time or model.\n\n        Parameters\n        ----------\n        num_frame : integer\n            Number of frame to plot this plot into, if <0 open no new\n            figure.\n        xax : string\n            Either 'model', 'time' or 'logtimerev' to indicate what is\n            to be used on the x-axis.\n        t0_model : integer, optional\n            If xax = 'time' then model for the zero point in time, for\n            AGB plots this would be usually the model of the 1st TP,\n            which can be found with the Kippenhahn plot.  The default\n            is 0.\n        title : string, optional\n            The figure title.  The default is \"Kippenhahn diagram\".\n        tp_agb : float, optional\n            If > 0. then,\n            ylim=[h1_min*1.-tp_agb/100 : h1_max*1.+tp_agb/100] with\n            h1_min, h1_max the min and max H-free core mass coordinate.\n            The default is 0. .\n        t_eps : float, optional\n            Final time for logtimerev.  The default is '5.e2'.\n        plot_star_mass : boolean, optional\n            If True, then plot the stellar mass as a line as well.  The\n            default is True.\n        symbol_size : integer, optional\n            Size of convection boundary marker.  The default is 8.\n        c12_bm : boolean, optional\n            If we plot c12_boundary_mass or not.  The default is False.\n        print_legend : boolean, optionla\n            Show or do not show legend.  The defalut is True.\n\n        \"\"\"\n\n        if num_frame >= 0:\n            pyl.figure(num_frame)\n\n        t0_mod=[]\n\n        if xax == 'time':\n            xaxisarray = self.get('star_age')\n            if t0_model > 0:\n                ind=self.get('model_number')\n                t0_model=where(ind>t0_model)[0][0]\n                t0_mod=xaxisarray[t0_model]\n            else:\n                t0_mod = 0.\n            print('zero time is '+str(t0_mod))\n        elif xax == 'model':\n            xaxisarray = self.get('model_number')\n            #t0_mod=xaxisarray[t0_model]\n            t0_mod = 0.\n        elif xax == 'logtimerev':\n            xaxi    = self.get('star_age')\n            xaxisarray = np.log10(np.max(xaxi)+t_eps-xaxi)\n            t0_mod = 0.\n        else:\n            print('kippenhahn_error: invalid string for x-axis selction.'+\\\n                  ' needs to be \"time\" or \"model\"')\n\n\n        plot_bounds=True\n        try:\n            h1_boundary_mass  = self.get('h1_boundary_mass')\n            he4_boundary_mass = self.get('he4_boundary_mass')\n            if c12_bm:\n                c12_boundary_mass = self.get('c12_boundary_mass')\n        except:\n            try:\n                h1_boundary_mass  = self.get('he_core_mass')\n                he4_boundary_mass = self.get('c_core_mass')\n                if c12_bm:\n                    c12_boundary_mass = self.get('o_core_mass')\n            except:\n                plot_bounds=False\n\n        star_mass         = self.get('star_mass')\n        mx1_bot           = self.get('mx1_bot')*star_mass\n        mx1_top           = self.get('mx1_top')*star_mass\n        mx2_bot           = self.get('mx2_bot')*star_mass\n        mx2_top           = self.get('mx2_top')*star_mass\n\n\n        if xax == 'time':\n            if t0_model>0:\n                pyl.xlabel('$t - t_0$ $\\mathrm{[yr]}$')\n            else:\n                pyl.xlabel('t / yrs')\n        elif xax == 'model':\n            pyl.xlabel('model number')\n        elif xax == 'logtimerev':\n            pyl.xlabel('$\\log(t_{final} - t)$  $\\mathrm{[yr]}$')\n\n        pyl.plot(xaxisarray[t0_model:]-t0_mod,mx1_bot[t0_model:],linestyle='None',color='blue',alpha=0.3,marker='o',markersize=symbol_size,label='convection zones')\n        pyl.plot(xaxisarray[t0_model:]-t0_mod,mx1_top[t0_model:],linestyle='None',color='blue',alpha=0.3,marker='o',markersize=symbol_size)\n        pyl.plot(xaxisarray[t0_model:]-t0_mod,mx2_bot[t0_model:],linestyle='None',color='blue',alpha=0.3,marker='o',markersize=symbol_size)\n        pyl.plot(xaxisarray[t0_model:]-t0_mod,mx2_top[t0_model:],linestyle='None',color='blue',alpha=0.3,marker='o',markersize=symbol_size)\n\n        if plot_bounds:\n            pyl.plot(xaxisarray[t0_model:]-t0_mod,h1_boundary_mass[t0_model:],color='red',linewidth=2,label='H-free core')\n            pyl.plot(xaxisarray[t0_model:]-t0_mod,he4_boundary_mass[t0_model:],color='green',linewidth=2,linestyle='dashed',label='He-free core')\n            if c12_bm:\n                pyl.plot(xaxisarray[t0_model:]-t0_mod,c12_boundary_mass[t0_model:],color='purple',linewidth=2,linestyle='dotted',label='C-free core')\n        if plot_star_mass is True:\n            pyl.plot(xaxisarray[t0_model:]-t0_mod,star_mass[t0_model:],label='$M_\\star$')\n        pyl.ylabel('$m_\\mathrm{r}/\\mathrm{M}_\\odot$')\n        if print_legend:\n            pyl.legend(loc=2)\n        if tp_agb > 0.:\n            h1_min = min(h1_boundary_mass[t0_model:])\n            h1_max = max(h1_boundary_mass[t0_model:])\n            h1_min = h1_min*(1.-old_div(tp_agb,100.))\n            h1_max = h1_max*(1.+old_div(tp_agb,100.))\n            print('setting ylim to zoom in on H-burning:',h1_min,h1_max)\n            pyl.ylim(h1_min,h1_max)", "response": "Function to plot a new Kippenhahn plot."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nplotting the luminosity evolution of the current state of the entry.", "response": "def t_lumi(self,num_frame,xax):\n        \"\"\"\n        Luminosity evolution as a function of time or model.\n\n        Parameters\n        ----------\n        num_frame : integer\n            Number of frame to plot this plot into.\n        xax : string\n            Either model or time to indicate what is to be used on the\n            x-axis\n\n        \"\"\"\n\n        pyl.figure(num_frame)\n\n        if xax == 'time':\n            xaxisarray = self.get('star_age')\n        elif xax == 'model':\n            xaxisarray = self.get('model_number')\n        else:\n            print('kippenhahn_error: invalid string for x-axis selction. needs to be \"time\" or \"model\"')\n\n\n        logLH   = self.get('log_LH')\n        logLHe  = self.get('log_LHe')\n\n        pyl.plot(xaxisarray,logLH,label='L_(H)')\n        pyl.plot(xaxisarray,logLHe,label='L(He)')\n        pyl.ylabel('log L')\n        pyl.legend(loc=2)\n\n\n        if xax == 'time':\n            pyl.xlabel('t / yrs')\n        elif xax == 'model':\n            pyl.xlabel('model number')"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef t_surf_parameter(self, num_frame, xax):\n\n        pyl.figure(num_frame)\n\n        if xax == 'time':\n            xaxisarray = self.get('star_age')\n        elif xax == 'model':\n            xaxisarray = self.get('model_number')\n        else:\n            print('kippenhahn_error: invalid string for x-axis selction. needs to be \"time\" or \"model\"')\n\n\n        logL    = self.get('log_L')\n        logTeff    = self.get('log_Teff')\n\n        pyl.plot(xaxisarray,logL,'-k',label='log L')\n        pyl.plot(xaxisarray,logTeff,'-k',label='log Teff')\n        pyl.ylabel('log L, log Teff')\n        pyl.legend(loc=2)\n\n\n        if xax == 'time':\n            pyl.xlabel('t / yrs')\n        elif xax == 'model':\n            pyl.xlabel('model number')", "response": "This function plots the surfaces of the current state of the state of the state of the surfaces of the current state of the surfaces."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef kip_cont(self, ifig=110, modstart=0, modstop=-1,t0_model=0,\n                 outfile='out.png', xlims=None, ylims=None,\n                 xres=1000, yres=1000, ixaxis='model_number',\n                 mix_zones=20, burn_zones=20, plot_radius=False,\n                 engenPlus=True, engenMinus=False,\n                 landscape_plot=False, rad_lines=False, profiles=[],\n                 showfig=True, outlines=True, boundaries=True,\n                 c12_boundary=False, rasterise=False, yscale='1.',\n                 engenlevels=None,CBM=False,fsize=14):\n        \"\"\"\n        This function creates a Kippenhahn plot with energy flux using\n        contours.\n\n        This plot uses mixing_regions and burning_regions written to\n        your history.data or star.log. Set both variables in the\n        log_columns.list file to 20 as a start.\n\n        The output log file should then contain columns called\n        \"mix_type_n\", \"mix_qtop_n\", \"burn_type_n\" and \"burn_qtop_n\".\n        The number of columns (i.e. the biggest value of n) is what\n        goes in the arguments as mix_zones and burn_zones.  DO NOT\n        WORRY! if you do not have these columns, just leave the default\n        values alone and the script should recognise that you do not\n        have these columns and make the most detailed plot that is\n        available to you.\n\n        Defaults are set to get some plot, that may not look great if\n        you zoom in interactively. Play with xres and yres as well as\n        setting the xlims to ylims to the region you are interested in.\n\n        Parameters\n        ----------\n        ifig : integer, optional\n            Figure frame number.  The default is 110.\n        modstart : integer, optional\n            Model from which you want to plot (be careful if your\n            history.data or star.log output is sparse...).  If it is\n            0 then it starts from the beginning, works even if\n            log_cnt > 1.\n            The default is 0.\n        modstop : integer, optional\n            Model to which you wish to plot, -1 corresponds to end\n            [if log_cnt>1, devide modstart and modstop by log_cnt,\n            this needs to be improved! SJ: this should be ficed now].\n            The defalut is -1.\n        t0_model : integer, optional\n            Model number from which to reset the time to 0. Typically,\n            if modstart!=0, t0_model=modstart is a good choice, but we\n            leave the choice to the user in case the time is wished to\n            start from 0 at a different key point of the evolution.\n            The default value is 0.\n        outfile : sting, optional\n            'filename + extension' where you want to save the figure.\n            The defalut is \"out.png\".\n        xlims, ylims : list, optional\n            Plot limits, however these are somewhat obsolete now that\n            we have modstart and modstop.  Leaving them as 0. is\n            probably no slower, and you can always zoom in afterwards\n            in mpl.  ylims is important for well resolved thermal\n            pulse etc plots; it's best to get the upper and lower limits\n            of he-intershell using s.kippenhahn_CO(1,'model') first.\n            The default is [0., 0.].\n        xres, yres : integer, optional\n            plot resolution. Needless to say that increasing these\n            values will yield a nicer plot with some slow-down in\n            plotting time.  You will most commonly change xres.  For a\n            prelim plot, try xres~200, then bump it up to anywhere from\n            1000-10000 for real nicely resolved, publication quality\n            plots.  The default is 1000.\n        ixaxis : string, optional\n            Either 'log_time_left', 'age', or 'model_number'.  The\n            default is \"model_number\".\n        mix_zones, burn_zones : integer, optional\n            As described above, if you have more detailed output about\n            your convection and energy generation boundaries in columns\n            mix_type_n, mix_qtop_n, burn_type_n and burn_qtop_n, you\n            need to specify the total number of columns for mixing zones\n            and burning zones that you have.  Can't work this out from\n            your history.data or star.log file?  Check the\n            history_columns.list that you used, it'll be the number\n            after \"mixing regions\" and \"burning regions\".  Can't see\n            these columns?  leave it and 2 conv zones and 2 burn zones\n            will be drawn using other data that you certainly should\n            have in your history.data or star.log file.  The defalut for\n            both is 20.\n        plot_radius : boolean, optional\n            Whether on a second y-axis you want to plot the radius of\n            the surface and the he-free core.  The default is False.\n        engenPlus : boolean\n            Plot energy generation contours for eps_nuc>0.  The default\n            is True.\n        endgenMinus : boolean, optional\n            Plot energy generation contours for eos_nuc<0.  The default\n            is True.\n        landscape_plot : boolean, optionla\n            The default is False.\n        rad_lines : boolean, optional\n            The deafault is False.\n        profiles : list, optional\n            The default is [].\n        showfig : boolean, optional\n            The default is True.\n        outlines : boolean, optional\n            Whether or not to plot outlines of conv zones in darker\n            colour.\n        boundaries : boolean, optional\n            Whether or not to plot H-, He- and C-free boundaries.\n        c12_boundary : boolean, optional\n            The default is False.\n        rasterise : boolean, optional\n            Whether or not to rasterise the contour regions to make\n            smaller vector graphics figures.  The default is False.\n        yscale : string, optional\n            Re-scale the y-axis by this amount\n        engenlevels : list\n            Give cusstom levels to the engenPlus contour. If None,\n            the levels are chosen automatically.\n            The default is None.\n        CBM : boolean, optional\n            plot contours for where CBM is active?\n\n        fsize : integer\n            font size for labels\n\n        Notes\n        -----\n        The parameter xlims is depricated.\n\n        \"\"\"\n        if ylims is None:\n            ylims=[0.,0.]\n        if xlims is None:\n            xlims=[0.,0.]\n        \n        # Find correct modstart and modstop:\n        mod=np.array([int(i) for i in self.get('model_number')])\n        mod1=np.abs(mod-modstart).argmin()\n        mod2=np.abs(mod-modstop).argmin()\n        if modstart != 0 : modstart=mod1\n        if modstop != -1 : modstop=mod2\n\n        xxyy=[self.get('star_age')[modstart:modstop],self.get('star_age')[modstart:modstop]]\n        mup = max(float(self.get('star_mass')[0])*1.02,1.0)\n        nmodels=len(self.get('model_number')[modstart:modstop])\n\n        if ylims == [0.,0.]:\n            mup   = max(float(self.get('star_mass')[0])*1.02,1.0)\n            mDOWN = 0.\n        else:\n            mup = ylims[1]\n            mDOWN = ylims[0]\n\n        # y-axis resolution\n        ny=yres\n        #dy=mup/float(ny)\n        dy = old_div((mup-mDOWN),float(ny))\n\n        # x-axis resolution\n        maxpoints=xres\n        dx=int(max(1,old_div(nmodels,maxpoints)))\n\n        #y = np.arange(0., mup, dy)\n        y = np.arange(mDOWN, mup, dy)\n        x = np.arange(0, nmodels, dx)\n        Msol=1.98892E+33\n\n        engenstyle = 'full'\n\n        B1=np.zeros([len(y),len(x)],float)\n        B2=np.zeros([len(y),len(x)],float)\n        try:\n            self.get('burn_qtop_1')\n        except:\n            engenstyle = 'twozone'\n        if engenstyle == 'full' and (engenPlus == True or engenMinus == True):\n            ulimit_array = np.array([self.get('burn_qtop_'+str(j))[modstart:modstop:dx]*\\\n                           self.get('star_mass')[modstart:modstop:dx] for j in range(1,burn_zones+1)])\n            #ulimit_array = np.around(ulimit_array,decimals=len(str(dy))-2)\n            llimit_array = np.delete(ulimit_array,-1,0)\n            llimit_array = np.insert(ulimit_array,0,0.,0)\n            #llimit_array = np.around(llimit_array,decimals=len(str(dy))-2)\n            btype_array = np.array([self.get('burn_type_'+str(j))[modstart:modstop:dx] for j in range(1,burn_zones+1)])\n            old_percent = 0\n            for i in range(len(x)):\n                # writing status\n                percent = int(i*100/(len(x) - 1))\n                if percent >= old_percent + 5:\n                    sys.stdout.flush()\n                    sys.stdout.write(\"\\r creating color map burn \" + \"...%d%%\" % percent)\n                    old_percent = percent\n\n                for j in range(burn_zones):\n                    if btype_array[j,i] > 0. and abs(btype_array[j,i]) < 99.:\n                        B1[(np.abs(y-llimit_array[j][i])).argmin():(np.abs(y-ulimit_array[j][i])).argmin()+1,i] = 10.0**(btype_array[j,i])\n                    elif btype_array[j,i] < 0. and abs(btype_array[j,i]) < 99.:\n                        B2[(np.abs(y-llimit_array[j][i])).argmin():(np.abs(y-ulimit_array[j][i])).argmin()+1,i] = 10.0**(abs(btype_array[j,i]))\n            print(' \\n')\n\n        if engenstyle == 'twozone' and (engenPlus == True or engenMinus == True):\n            V=np.zeros([len(y),len(x)],float)\n            old_percent = 0\n            for i in range(len(x)):\n                # writing status\n                percent = int(i*100/(len(x) - 1))\n                if percent >= old_percent + 5:\n                    sys.stdout.flush()\n                    sys.stdout.write(\"\\r creating color map1 \" + \"...%d%%\" % percent)\n                    old_percent = percent\n                llimitl1=old_div(self.get('epsnuc_M_1')[modstart:modstop][i*dx],Msol)\n                ulimitl1=old_div(self.get('epsnuc_M_4')[modstart:modstop][i*dx],Msol)\n                llimitl2=old_div(self.get('epsnuc_M_5')[modstart:modstop][i*dx],Msol)\n                ulimitl2=old_div(self.get('epsnuc_M_8')[modstart:modstop][i*dx],Msol)\n                llimith1=old_div(self.get('epsnuc_M_2')[modstart:modstop][i*dx],Msol)\n                ulimith1=old_div(self.get('epsnuc_M_3')[modstart:modstop][i*dx],Msol)\n                llimith2=old_div(self.get('epsnuc_M_6')[modstart:modstop][i*dx],Msol)\n                ulimith2=old_div(self.get('epsnuc_M_7')[modstart:modstop][i*dx],Msol)\n                # lower thresh first, then upper thresh:\n                if llimitl1!=ulimitl1:\n                    for k in range(ny):\n                        if llimitl1<=y[k] and ulimitl1>y[k]:\n                            V[k,i]=10.\n                if llimitl2!=ulimitl2:\n                    for k in range(ny):\n                        if llimitl2<=y[k] and ulimitl2>y[k]:\n                            V[k,i]=10.\n                if llimith1!=ulimith1:\n                    for k in range(ny):\n                        if llimith1<=y[k] and ulimith1>y[k]:\n                            V[k,i]=30.\n                if llimith2!=ulimith2:\n                    for k in range(ny):\n                        if llimith2<=y[k] and ulimith2>y[k]:\n                            V[k,i]=30.\n            print(' \\n')\n\n        mixstyle = 'full'\n        try:\n            self.get('mix_qtop_1')\n        except:\n            mixstyle = 'twozone'\n        if mixstyle == 'full':\n            old_percent = 0\n            Z=np.zeros([len(y),len(x)],float)\n            if CBM:\n                Zcbm=np.zeros([len(y),len(x)],float)\n            ulimit_array = np.array([self.get('mix_qtop_'+str(j))[modstart:modstop:dx]*self.get('star_mass')[modstart:modstop:dx] for j in range(1,mix_zones+1)])\n            llimit_array = np.delete(ulimit_array,-1,0)\n            llimit_array = np.insert(ulimit_array,0,0.,0)\n            mtype_array = np.array([self.get('mix_type_'+str(j))[modstart:modstop:dx] for j in range(1,mix_zones+1)])\n            for i in range(len(x)):\n                # writing status\n                percent = int(i*100/(len(x) - 1))\n                if percent >= old_percent + 5:\n                    sys.stdout.flush()\n                    sys.stdout.write(\"\\r creating color map mix \" + \"...%d%%\" % percent)\n                    old_percent = percent\n                for j in range(mix_zones):\n                    if mtype_array[j,i] == 1.:\n                        Z[(np.abs(y-llimit_array[j][i])).argmin():(np.abs(y-ulimit_array[j][i])).argmin()+1,i] = 1.\n                    if CBM:\n                        if mtype_array[j,i] == 2.:\n                            Zcbm[(np.abs(y-llimit_array[j][i])).argmin():(np.abs(y-ulimit_array[j][i])).argmin()+1,i] = 1.\n            print(' \\n')\n\n        if mixstyle == 'twozone':\n            Z=np.zeros([len(y),len(x)],float)\n            old_percent = 0\n            for i in range(len(x)):\n            # writing reading status\n                # writing status\n                percent = int(i*100/(len(x) - 1))\n                if percent >= old_percent + 5:\n                    sys.stdout.flush()\n                    sys.stdout.write(\"\\r creating color map mix \" + \"...%d%%\" % percent)\n                    old_percent = percent\n\n                ulimit=self.get('conv_mx1_top')[modstart:modstop][i*dx]*self.get('star_mass')[modstart:modstop][i*dx]\n                llimit=self.get('conv_mx1_bot')[modstart:modstop][i*dx]*self.get('star_mass')[modstart:modstop][i*dx]\n                if llimit!=ulimit:\n                    for k in range(ny):\n                        if llimit<=y[k] and ulimit>y[k]:\n                            Z[k,i]=1.\n                ulimit=self.get('conv_mx2_top')[modstart:modstop][i*dx]*self.get('star_mass')[modstart:modstop][i*dx]\n                llimit=self.get('conv_mx2_bot')[modstart:modstop][i*dx]*self.get('star_mass')[modstart:modstop][i*dx]\n                if llimit!=ulimit:\n                    for k in range(ny):\n                        if llimit<=y[k] and ulimit>y[k]:\n                            Z[k,i]=1.\n            print(' \\n')\n\n        if rad_lines == True:\n            masses = np.arange(0.1,1.5,0.1)\n            rads=[[],[],[],[],[],[],[],[],[],[],[],[],[],[]]\n            modno=[]\n            for i in range(len(profiles)):\n                p=mesa_profile('./LOGS',profiles[i])\n                modno.append(p.header_attr['model_number'])\n                for j in range(len(masses)):\n                    idx=np.abs(p.get('mass')-masses[j]).argmin()\n                    rads[j].append(p.get('radius')[idx])\n\n        print('engenstyle was ', engenstyle)\n        print('mixstyle was ', mixstyle)\n        print('\\n finished preparing color map')\n\n        ########################################################################\n        #----------------------------------plot--------------------------------#\n        fig = pyl.figure(ifig)\n        #fsize=20\n        if landscape_plot == True:\n            fig.set_size_inches(9,4)\n            pl.gcf().subplots_adjust(bottom=0.2)\n            pl.gcf().subplots_adjust(right=0.85)\n\n        params = {'axes.labelsize':  fsize,\n          'axes.labelsize': fsize,\n          'font.size': fsize,\n          'legend.fontsize': fsize,\n          'xtick.labelsize': fsize,\n          'ytick.labelsize': fsize,\n                  'text.usetex': False}\n        pyl.rcParams.update(params)\n\n        #ax=pl.axes([0.1,0.1,0.9,0.8])\n\n        #fig=pl.figure()\n        ax=pl.axes()\n\n        if ixaxis == 'log_time_left':\n        # log of time left until core collapse\n            gage= self.get('star_age')\n            lage=np.zeros(len(gage))\n            agemin = max(old_div(abs(gage[-1]-gage[-2]),5.),1.e-10)\n            for i in np.arange(len(gage)):\n                if gage[-1]-gage[i]>agemin:\n                    lage[i]=np.log10(gage[-1]-gage[i]+agemin)\n                else :\n                    lage[i]=np.log10(agemin)\n            xxx = lage[modstart:modstop]\n            print('plot versus time left')\n            ax.set_xlabel('$ \\\\log_{10}(t-t_\\mathrm{end})\\ /\\  \\mathrm{[yr]}$',fontsize=fsize)\n            if xlims[1] == 0.:\n                xlims = [xxx[0],xxx[-1]]\n        elif ixaxis =='model_number':\n            xxx= self.get('model_number')[modstart:modstop]\n            print('plot versus model number')\n            ax.set_xlabel('Model number',fontsize=fsize)\n            if xlims[1] == 0.:\n                xlims = [self.get('model_number')[modstart],self.get('model_number')[modstop]]\n        elif ixaxis =='age':\n            if t0_model != 0:\n                t0_mod=np.abs(mod-t0_model).argmin()\n                xxx= self.get('star_age')[modstart:modstop] - self.get('star_age')[t0_mod]\n                print('plot versus age')\n                ax.set_xlabel('t - %.5e / [yr]' %self.get('star_age')[modstart],fontsize=fsize)\n            else:\n                xxx= old_div(self.get('star_age')[modstart:modstop],1.e6)\n                ax.set_xlabel('t [Myr]',fontsize=fsize)\n            if xlims[1] == 0.:\n                xlims = [xxx[0],xxx[-1]]\n\n        ax.set_ylabel('$\\mathrm{enclosed\\ mass\\ /\\ [M_\\odot]}$',fontsize=fsize)\n\n        # some stuff for rasterizing only the contour part of the plot, for nice, but light, eps:\n        class ListCollection(Collection):\n            def __init__(self, collections, **kwargs):\n                Collection.__init__(self, **kwargs)\n                self.set_collections(collections)\n            def set_collections(self, collections):\n                self._collections = collections\n            def get_collections(self):\n                return self._collections\n            @allow_rasterization\n            def draw(self, renderer):\n                for _c in self._collections:\n                    _c.draw(renderer)\n\n        def insert_rasterized_contour_plot(c):\n            collections = c.collections\n            for _c in collections:\n                _c.remove()\n            cc = ListCollection(collections, rasterized=True)\n            ax = pl.gca()\n            ax.add_artist(cc)\n            return cc\n\n        cmapMIX = matplotlib.colors.ListedColormap(['w','#8B8386']) # rose grey\n        if CBM:\n            cmapCBM = matplotlib.colors.ListedColormap(['w','g']) # green\n        cmapB1  = pyl.cm.get_cmap('Blues')\n        cmapB2  = pl.cm.get_cmap('Reds')\n\n        ylims1=[0.,0.]\n        ylims1[0]=ylims[0]\n        ylims1[1]=ylims[1]\n        if ylims == [0.,0.]:\n            ylims[0] = 0.\n            ylims[1] = mup\n            #print(\"Setting ylims[1] to mup=\"+str(mup))\n        if ylims[0] != 0.:\n            ylab='$(\\mathrm{Mass }$ - '+str(ylims[0])\n            if yscale!='1.':\n                ylab+=') / '+yscale+' $M_\\odot$'\n            else:\n                ylab+=') / $M_\\odot$'\n            ax.set_ylabel(ylab)\n            y = y - ylims[0]\n            y = y*float(yscale) # SJONES tweak\n            ylims[0] = y[0]\n            ylims[1] = y[-1]\n\n        print('plotting contours')\n        CMIX    = ax.contourf(xxx[::dx],y,Z, cmap=cmapMIX,alpha=0.6,levels=[0.5,1.5])\n        #CMIX    = ax.pcolor(xxx[::dx],y,Z, cmap=cmapMIX,alpha=0.6,vmin=0.5,vmax=1.5)\n        if rasterise==True:\n            insert_rasterized_contour_plot(CMIX)\n        if outlines == True:\n            CMIX_outlines    = ax.contour(xxx[::dx],y,Z, cmap=cmapMIX)\n            if rasterise==True:\n                insert_rasterized_contour_plot(CMIX_outlines)\n\n        if CBM:\n            CCBM    = ax.contourf(xxx[::dx],y,Zcbm, cmap=cmapCBM,alpha=0.6,levels=[0.5,1.5])\n            if rasterise==True:\n                insert_rasterized_contour_plot(CCBM)\n            if outlines == True:\n                CCBM_outlines    = ax.contour(xxx[::dx],y,Zcbm, cmap=cmapCBM)\n                if rasterise==True:\n                    insert_rasterized_contour_plot(CCBM_outlines)\n\n        if engenstyle == 'full' and engenPlus == True:\n            if engenlevels!= None:\n                CBURN1  = ax.contourf(xxx[::dx],y,B1, cmap=cmapB1, alpha=0.5,\\\n                        locator=matplotlib.ticker.LogLocator(),levels=engenlevels)\n                if outlines:\n                    CB1_outlines  = ax.contour(xxx[::dx],y,B1, cmap=cmapB1, alpha=0.7, \\\n                        locator=matplotlib.ticker.LogLocator(),levels=engenlevels)\n            else:\n                CBURN1  = ax.contourf(xxx[::dx],y,B1, cmap=cmapB1, alpha=0.5, \\\n                                      locator=matplotlib.ticker.LogLocator())\n                if outlines:\n                    CB1_outlines  = ax.contour(xxx[::dx],y,B1, cmap=cmapB1, alpha=0.7, \\\n                                               locator=matplotlib.ticker.LogLocator())\n            CBARBURN1 = pyl.colorbar(CBURN1)\n            CBARBURN1.set_label('$|\\epsilon_\\mathrm{nuc}-\\epsilon_{\\\\nu}| \\; (\\mathrm{erg\\,g}^{-1}\\mathrm{\\,s}^{-1})$',fontsize=fsize)\n            if rasterise==True:\n                insert_rasterized_contour_plot(CBURN1)\n                if outlines:\n                    insert_rasterized_contour_plot(CB1_outlines)\n\n        if engenstyle == 'full' and engenMinus == True:\n            CBURN2  = ax.contourf(xxx[::dx],y,B2, cmap=cmapB2, alpha=0.5, locator=matplotlib.ticker.LogLocator())\n            if outlines:\n                CBURN2_outlines  = ax.contour(xxx[::dx],y,B2, cmap=cmapB2, alpha=0.7, locator=matplotlib.ticker.LogLocator())\n            CBARBURN2 = pl.colorbar(CBURN2)\n            if engenPlus == False:\n                CBARBURN2.set_label('$|\\epsilon_\\mathrm{nuc}-\\epsilon_{\\\\nu}| \\; (\\mathrm{erg\\,g}^{-1}\\mathrm{\\,s}^{-1})$',fontsize=fsize)\n            if rasterise==True:\n                insert_rasterized_contour_plot(CBURN2)\n                if outlines:\n                    insert_rasterized_contour_plot(CB2_outlines)\n\n        if engenstyle == 'twozone' and (engenPlus == True or engenMinus == True):\n            ax.contourf(xxx[::dx],y,V, cmap=cmapB1, alpha=0.5)\n\n        print('plotting patches')\n        mtot=self.get('star_mass')[modstart:modstop][::dx]\n        mtot1=(mtot-ylims1[0])*float(yscale)\n        ax.plot(xxx[::dx],mtot1,'k-')\n\n        if boundaries == True:\n            print('plotting abund boundaries')\n            try:\n                bound=self.get('h1_boundary_mass')[modstart:modstop]\n                bound1=(bound-ylims1[0])*float(yscale)\n                ax.plot(xxx,bound1,label='H boundary',linestyle='-')\n\n                bound=self.get('he4_boundary_mass')[modstart:modstop]\n                bound1=(bound-ylims1[0])*float(yscale)\n                ax.plot(xxx,bound1,label='He boundary',linestyle='--')\n\n                bound=self.get('c12_boundary_mass')[modstart:modstop]\n                bound1=(bound-ylims1[0])*float(yscale)\n                ax.plot(xxx,bound1,label='C boundary',linestyle='-.')\n\n            except:\n                try:\n                    bound=self.get('he_core_mass')[modstart:modstop]\n                    bound1=(bound-ylims1[0])*float(yscale)\n                    ax.plot(xxx,bound1,label='H boundary',linestyle='-')\n\n                    bound=self.get('c_core_mass')[modstart:modstop]-ylims[0]\n                    bound1=(bound-ylims1[0])*float(yscale)\n                    ax.plot(xxx,bound1,label='He boundary',linestyle='--')\n\n                    bound=self.get('o_core_mass')[modstart:modstop]-ylims[0]\n                    bound1=(bound-ylims1[0])*float(yscale)\n                    ax.plot(xxx,bound1,label='C boundary',linestyle='-.')\n\n                    bound=self.get('si_core_mass')[modstart:modstop]-ylims[0]\n                    bound1=(bound-ylims1[0])*float(yscale)\n                    ax.plot(xxx,bound1,label='C boundary',linestyle='-.')\n\n                    bound=self.get('fe_core_mass')[modstart:modstop]-ylims[0]\n                    bound1=(bound-ylims1[0])*float(yscale)\n                    ax.plot(xxx,bound1,label='C boundary',linestyle='-.')\n\n                except:\n#                    print 'problem to plot boundaries for this plot'\n                    pass\n\n        ax.axis([xlims[0],xlims[1],ylims[0],ylims[1]])\n\n        if plot_radius == True:\n            ax2=pyl.twinx()\n            ax2.plot(xxx,np.log10(self.get('he4_boundary_radius')[modstart:modstop]),label='He boundary radius',color='k',linewidth=1.,linestyle='-.')\n            ax2.plot(xxx,self.get('log_R')[modstart:modstop],label='radius',color='k',linewidth=1.,linestyle='-.')\n            ax2.set_ylabel('log(radius)')\n        if rad_lines == True:\n            ax2=pyl.twinx()\n            for i in range(len(masses)):\n                ax2.plot(modno,np.log10(rads[i]),color='k')\n\n        if outfile[-3:]=='png':\n            fig.savefig(outfile,dpi=300)\n        elif outfile[-3:]=='eps':\n            fig.savefig(outfile,format='eps')\n        elif outfile[-3:]=='pdf':\n            fig.savefig(outfile,format='pdf')\n        if showfig == True:\n            pyl.show()", "response": "This function creates a Kippenhahn plot with energy flux using the specified contour parameters."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nfinds the first TP of the TPAGB phase and returns the model that is at its LHe maximum.", "response": "def find_first_TP(self):\n\n        \"\"\"\n        Find first TP of the TPAGB phase and returns the model\n        number at its LHe maximum.\n\n        Parameters\n        ----------\n\n        \"\"\"\n\n        star_mass         = self.get('star_mass')\n        he_lumi           = self.get('log_LHe')\n        h_lumi            = self.get('log_LH')\n        mx2_bot           = self.get('mx2_bot')*star_mass\n        try:\n           h1_boundary_mass  = self.get('h1_boundary_mass')\n           he4_boundary_mass = self.get('he4_boundary_mass')\n        except:\n           try:\n                h1_boundary_mass  = self.get('he_core_mass')\n                he4_boundary_mass = self.get('c_core_mass')\n           except:\n                pass\n\n\n        TP_bot=np.array(self.get('conv_mx2_bot'))*np.array(self.get('star_mass'))\n        TP_top=np.array(self.get('conv_mx2_top'))*np.array(self.get('star_mass'))\n        lum_array=[]\n        activate=False\n        models=[]\n        pdcz_size=[]\n        for i in range(len(h1_boundary_mass)):\n            if (h1_boundary_mass[i]-he4_boundary_mass[i] <0.2) and (he4_boundary_mass[i]>0.2):\n                if (mx2_bot[i]>he4_boundary_mass[i]) and (he_lumi[i]>h_lumi[i]):\n                        if TP_top[i]>he4_boundary_mass[i]:\n                                pdcz_size.append(TP_top[i]-TP_bot[i])\n                                activate=True\n                                lum_array.append(he_lumi[i])\n                                models.append(i)\n                                #print(TP_bot[i],TP_top[i])\n                if (activate == True) and (he_lumi[i]<h_lumi[i]):\n                        #if fake tp\n                        if max(pdcz_size)<1e-5:\n                                active=False\n                                lum_array=[]\n                                models=[]\n                                print('fake tp')\n                        else:\n                                break\n        t0_model = models[np.argmax(lum_array)]\n        return t0_model"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nfunctioning which finds TPs and uses the calc_DUP_parameter function. To calculate DUP parameter evolution dependent of the star or core mass. Parameters ---------- fig : integer Figure number to plot. t0_model : integer First he-shell lum peak. percent : float dredge-up is defined as when the mass dredged up is a certain percent of the total mass dredged up during that event, which is set by the user in this variable. The default is 5. makefig : do you want a figure to be made? Returns ------- TPmods : array model numbers at the peak of each thermal pulse DUPmods : array model numbers at the dredge-up, where dredge-up is defined as when the mass dredged up is a certain percent of the total mass dredged up during that event, which is set by the user TPend : array model numbers at the end of the PDCZ for each TP lambda : array DUP efficiency for each pulse", "response": "def find_TPs_and_DUPs(self, percent=5., makefig=False):\n        \"\"\"\n        Function which finds TPs and uses the calc_DUP_parameter\n        function.  To calculate DUP parameter evolution dependent of\n        the star or core mass.\n\n        Parameters\n        ----------\n        fig : integer\n            Figure number to plot.\n        t0_model : integer\n            First he-shell lum peak.\n        percent : float\n            dredge-up is defined as when the mass dredged up is a certain\n            percent of the total mass dredged up during that event, which\n            is set by the user in this variable.\n            The default is 5.\n        makefig :\n            do you want a figure to be made?\n\n        Returns\n        -------\n        TPmods : array\n            model numbers at the peak of each thermal pulse\n        DUPmods : array\n            model numbers at the dredge-up, where dredge-up is defined as\n            when the mass dredged up is a certain percent of the total mass\n            dredged up during that event, which is set by the user\n        TPend : array\n            model numbers at the end of the PDCZ for each TP\n        lambda : array\n            DUP efficiency for each pulse\n        \"\"\"\n\n        t0_model=self.find_first_TP()\n        t0_idx=(t0_model-self.get(\"model_number\")[0])\n        first_TP_he_lum=10**(self.get(\"log_LHe\")[t0_idx])\n        he_lum=10**(self.get(\"log_LHe\")[t0_idx:])\n        h_lum=10**(self.get(\"log_LH\")[t0_idx:])\n        model=self.get(\"model_number\")[t0_idx:]\n\n        try:\n           h1_bndry=self.get(\"h1_boundary_mass\")[t0_idx:]\n        except:\n           try:\n                h1_bndry=self.get('he_core_mass')[t0_idx:]\n           except:\n                pass\n        # SJ find TPs by finding local maxima in He-burning luminosity and\n        # checking that the he_lum is greater than the h_lum:\n        maxima=[0]\n        for i in range(2,len(model)-1):\n            if he_lum[i] > he_lum[i-1] and he_lum[i] > he_lum[i+1]:\n                if he_lum[i-1] > he_lum[i-2] and he_lum[i+1] > he_lum[i+2]:\n                    if he_lum[i] > h_lum[i]:\n                        maxima.append(i)\n\n        # find DUPs when h-boundary first decreases by more than XX% of the total DUP\n        # depth:\n        DUPs=[]\n        TPend=[]\n        maxDUPs=[]\n        for i in range(len(maxima)):\n            idx1=maxima[i]\n            try:\n                idx2=maxima[i+1]\n            except IndexError:\n                idx2=-1\n            bound=h1_bndry[idx1:idx2]\n            bound0=bound[0]\n            if bound0==min(bound) or bound0 < min(bound): # then no DUP\n                DUP=idx1\n                DUPs.append(DUP)\n                maxDUPs.append(DUP)\n            else:\n                maxDUPs.append(idx1+bound.argmin()) # model number of deepest extend of 3DUP\n                maxDUP=bound0-min(bound) # total mass dredged up in DUP\n                db=bound - bound[0]\n                db_maxDUP = old_div(db, maxDUP)\n                DUP=np.where(db_maxDUP <= old_div(-float(percent),100.))[0][0]\n                DUPs.append(DUP+idx1)\n#                # Alternative definition, where envelope reaches mass coordinate\n#                # where top of PDCZ had resided during the TP:\n#                top=self.get('mx2_top')[idx1]\n#                DUP=np.abs(bound-top).argmin()\n#                DUPs.append(DUP+idx1)\n\n        # find end of PDCZ by seeking from TP peak and checking mx2_bot:\n            mx2b=self.get('mx2_bot')[t0_idx:][idx1:idx2]\n            for i in range(len(mx2b)):\n                if mx2b[i]==0.:\n                    endTP=i+idx1\n                    TPend.append(endTP)\n                    break\n\n        # 3DUP efficiency:\n        lambd=[0.]\n        for i in range(1,len(maxima)):\n            dmenv = h1_bndry[maxima[i]] - h1_bndry[maxDUPs[i-1]]\n            dmdredge = h1_bndry[maxima[i]] - h1_bndry[maxDUPs[i]]\n            lambd.append(old_div(dmdredge,dmenv))\n\n        TPmods = maxima + t0_idx\n        DUPmods = DUPs + t0_idx\n        TPend = TPend + t0_idx\n\n        return TPmods, DUPmods, TPend, lambd"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a list of all properties which are TPAGB parameters which are defined in the nugrid_set. py file.", "response": "def TPAGB_properties(self):\n\n        \"\"\"\n        Temporary, use for now same function in nugrid_set.py!\n        Returns many TPAGB parameters which are\n        TPstart,TPmods,TP_max_env,TPend,min_m_TP,max_m_TP,DUPmods,DUPm_min_h\n        Same function in nugrid_set.py.\n\n        Parameters\n        ----------\n\n        \"\"\"\n\n        peak_lum_model,h1_mass_min_DUP_model=self.find_TP_attributes( 3, t0_model=self.find_first_TP(), color='r', marker_type='o')\n\n        print('first tp')\n        print(self.find_first_TP())\n        print('peak lum mmmodel')\n        print(peak_lum_model)\n        print(h1_mass_min_DUP_model)\n\n        TPmods=peak_lum_model\n\n        DUPmods=h1_mass_min_DUP_model\n        DUPmods1=[]\n        for k in range(len(DUPmods)):\n                DUPmods1.append(int(float(DUPmods[k]))+100) #to exclude HBB? effects\n\n        DUPmods=DUPmods1\n\n\n\n        TPstart=[]\n        #find beginning of TP, goes from TP peak backwards\n        # find end of PDCZ by seeking from TP peak and checking mx2_bot:\n        models=self.get('model_number')\n        mx2b_array=self.get('conv_mx2_bot')\n        mx2t_array=self.get('conv_mx2_top')\n        massbot=mx2b_array#*self.header_attr['initial_mass']\n        masstop=mx2t_array#*self.header_attr['initial_mass']\n        massenv=np.array(self.get('conv_mx1_bot'))*np.array(self.get('star_mass'))   #*self.header_attr['initial_mass']\n\n        #h1_bdy=self.get('h1_boundary_mass')\n\n        for k in range(len(TPmods)):\n                idx=list(models).index(TPmods[k])\n                mx2b=mx2b_array[:idx]\n                for i in range(len(mx2b)-1,0,-1):\n                        if mx2b[i]==0.:\n                            startTP=models[i]\n                            TPstart.append(int(float(startTP)))\n                            break\n        #Find end of TP, goes from TP forwards:\n        TPend=[]\n        max_m_TP=[]\n        min_m_TP=[]\n        DUP_m=[]\n        TP_max_env=[]\n        DUPm_min_h=[]\n        flagdecline=False\n        for k in range(len(TPmods)):\n            idx=list(models).index(TPmods[k])\n            mx2b=mx2b_array[idx:]\n            mx2t=mx2t_array[idx:]\n            refsize=mx2t[0]-mx2b[0]\n            for i in range(len(mx2b)):\n                if i==0:\n                    continue\n                if ((mx2t[i]-mx2b[i])<(0.5*refsize)) and (flagdecline==False):\n                    flagdecline=True\n                    refmasscoord=mx2t[i]\n                    print('flagdecline to true')\n                    continue\n                if flagdecline==True:\n                    if (mx2t[i]-mx2b[i])<(0.1*refsize):\n                        #for the massive and HDUP AGB's where PDCZ conv zone becomes the Hdup CONV ZONE\n                        if refmasscoord<mx2t[i]:\n                            endTP=models[idx+i-1]\n                            TPend.append(int(float(endTP)))\n                            print('HDUp, TP end',endTP)\n                            break\n                        if (mx2t[i]-mx2b[i])<1e-5:\n                            endTP=models[idx+i-1]\n                            TPend.append(int(float(endTP)))\n                            print('normal TPend',endTP)\n                            break\n\n                # if max(mx2t[0:(i-1)])>mx2t[i]:\n                #         (max(mx2t[0:(i-1)]) - min(mx2b[0:(i-1)]))\n                #         flag=True\n                #         continue\n                # if flag==True:\n                #     endidx=idx+i\n                #     endTP=models[endidx]\n                #     TPend.append(int(float(endTP)))\n\n                # if (mx2t[i]-mx2b[i])<1e-5:                        #mx2b[i])==0.:\n                #     endidx=idx+i\n                #     endTP=models[endidx]\n                #     TPend.append(int(float(endTP)))\n                #     break\n\n            print('found TP boundaries',TPstart[-1],TPend[-1])\n        #find max and minimum mass coord of TP at max Lum\n            mtot=self.get('star_mass')\n            masstop_tot=np.array(masstop)*np.array(mtot)\n            idx_tpext=list(masstop_tot).index(max(masstop_tot[TPstart[k]:(TPend[k]-10)]))\n            print('TP',k+1,TPmods[k])\n            print(TPstart[k],TPend[k])\n            print('INDEX',idx_tpext,models[idx_tpext])\n            print(max(masstop_tot[TPstart[k]:(TPend[k]-10)]))\n            mtot=self.get('star_mass')[idx_tpext]\n            max_m_TP.append(masstop[idx_tpext]*mtot)\n            min_m_TP.append(massbot[idx_tpext]*mtot)\n\n            TP_max_env.append(massenv[idx_tpext])#*mtot)\n            if k> (len(DUPmods)-1):\n                    continue\n            idx=list(models).index(DUPmods[k])\n            mtot=self.get('star_mass')[idx]\n            #DUP_m.append(h1_bdy[idx])#*mtot)\n        #######identify if it is really a TDUP, Def.\n            try:\n                h1_bndry=self.get(\"h1_boundary_mass\")[t0_idx:]\n            except:\n                try:\n                    h1_bndry=self.get('he_core_mass')[t0_idx:]\n                except:\n                    pass\n\n            if h1_bndry[idx]>=max_m_TP[-1]:\n                print('Pulse',k+1,'model',TPmods[k],'skip')\n                print(h1_bndry[idx],max_m_TP[-1])\n                DUPmods[k] = -1\n                DUPm_min_h.append( -1)\n                continue\n\n            DUPm_min_h.append(h1_bdy[idx])\n        for k in range(len(TPmods)):\n            print('#############')\n            print('TP ',k+1)\n            print('Start: ',TPstart[k])\n            print('Peak' , TPmods[k],TP_max_env[k])\n            print('(conv) PDCZ size: ',min_m_TP[k],' till ',max_m_TP[k])\n            print('End',TPend[k])\n            if k <=(len(DUPmods)-1):\n                print(len(DUPmods),k)\n                print('DUP max',DUPmods[k])\n                print(DUPm_min_h[k])\n            else:\n                print('no DUP')\n\n            return TPstart,TPmods,TP_max_env,TPend,min_m_TP,max_m_TP,DUPmods,DUPm_min_h"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef calc_DUP_parameter(self, modeln, label, fig=10, color='r', marker_type='*',\n                           h_core_mass=False):\n        \"\"\"\n        Method to calculate the DUP parameter evolution for different\n        TPs specified specified by their model number.\n\n        Parameters\n        ----------\n        fig : integer\n            Figure number to plot.\n        modeln : list\n            Array containing pairs of models each corresponding to a\n            TP. First model where h boundary mass will be taken before\n            DUP, second model where DUP reaches lowest mass.\n        leg : string\n            Plot label.\n        color : string\n            Color of the plot.\n        marker_type : string\n            marker type.\n        h_core_mass : boolean, optional\n            If True: plot dependence from h free core , else star mass.\n            The default is False.\n\n        \"\"\"\n        number_DUP=(old_div(len(modeln),2) -1) #START WITH SECOND\n        try:\n           h1_bnd_m=self.get('h1_boundary_mass')\n        except:\n           try:\n                h1_bnd_m=self.get('he_core_mass')\n           except:\n                pass\n        star_mass=self.get('star_mass')\n        age=self.get(\"star_age\")\n        firstTP=h1_bnd_m[modeln[0]]\n        first_m_dredge=h1_bnd_m[modeln[1]]\n        DUP_parameter=np.zeros(number_DUP)\n        DUP_xaxis=np.zeros(number_DUP)\n        j=0\n        for i in np.arange(2,len(modeln),2):\n            TP=h1_bnd_m[modeln[i]]\n            m_dredge=h1_bnd_m[modeln[i+1]]\n            if i ==2:\n                last_m_dredge=first_m_dredge\n            #print \"testest\"\n            #print modeln[i]\n            if h_core_mass==True:\n                DUP_xaxis[j]=h1_bnd_m[modeln[i]]                        #age[modeln[i]] - age[modeln[0]]\n            else:\n                DUP_xaxis[j]=star_mass[modeln[i]]\n            #DUP_xaxis[j]=modeln[i]\n            DUP_parameter[j]=old_div((TP-m_dredge),(TP-last_m_dredge))\n            last_m_dredge=m_dredge\n            j+=1\n\n        pl.figure(fig)\n        pl.rcParams.update({'font.size': 18})\n        pl.rc('xtick', labelsize=18)\n        pl.rc('ytick', labelsize=18)\n\n        pl.plot(DUP_xaxis,DUP_parameter,marker=marker_type,markersize=12,mfc=color,color='k',linestyle='-',label=label)\n        if h_core_mass==True:\n            pl.xlabel(\"$M_H$\",fontsize=20)\n        else:\n            pl.xlabel(\"M/M$_{\\odot}$\",fontsize=24)\n        pl.ylabel(\"$\\lambda_{DUP}$\",fontsize=24)\n        pl.minorticks_on()\n        pl.legend()", "response": "Method to calculate the DUP parameter evolution for different types of a single duplicate TPs."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating the UsmUserData object for the given credentials.", "response": "def _create_usm_user_obj(snmp_cred):\n    \"\"\"Creates the UsmUserData obj for the given credentials.\n\n    This method creates an instance for the method hlapi.UsmUserData.\n    The UsmUserData() allows the 'auth_protocol' and 'priv_protocol'\n    to be undefined by user if their pass phrases are provided.\n\n    :param snmp_cred: Dictionary of SNMP credentials.\n           auth_user: SNMP user\n           auth_protocol: Auth Protocol\n           auth_prot_pp: Pass phrase value for AuthProtocol.\n           priv_protocol:Privacy Protocol.\n           auth_priv_pp: Pass phrase value for Privacy Protocol.\n    :returns UsmUserData object as per given credentials.\n    \"\"\"\n    auth_protocol = snmp_cred.get('auth_protocol')\n    priv_protocol = snmp_cred.get('priv_protocol')\n    auth_user = snmp_cred.get('auth_user')\n    auth_prot_pp = snmp_cred.get('auth_prot_pp')\n    auth_priv_pp = snmp_cred.get('auth_priv_pp')\n\n    if ((not auth_protocol) and priv_protocol):\n        priv_protocol = (\n            MAPPED_SNMP_ATTRIBUTES['privProtocol'][priv_protocol])\n        usm_user_obj = hlapi.UsmUserData(auth_user, auth_prot_pp,\n                                         auth_priv_pp,\n                                         privProtocol=priv_protocol)\n    elif ((not priv_protocol) and auth_protocol):\n        auth_protocol = (\n            MAPPED_SNMP_ATTRIBUTES['authProtocol'][auth_protocol])\n        usm_user_obj = hlapi.UsmUserData(auth_user, auth_prot_pp,\n                                         auth_priv_pp,\n                                         authProtocol=auth_protocol)\n    elif not all([priv_protocol and auth_protocol]):\n        usm_user_obj = hlapi.UsmUserData(auth_user, auth_prot_pp,\n                                         auth_priv_pp)\n    else:\n        auth_protocol = (\n            MAPPED_SNMP_ATTRIBUTES['authProtocol'][auth_protocol])\n        priv_protocol = (\n            MAPPED_SNMP_ATTRIBUTES['privProtocol'][priv_protocol])\n        usm_user_obj = hlapi.UsmUserData(auth_user, auth_prot_pp,\n                                         auth_priv_pp,\n                                         authProtocol=auth_protocol,\n                                         privProtocol=priv_protocol)\n    return usm_user_obj"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _parse_mibs(iLOIP, snmp_credentials):\n    result = {}\n    usm_user_obj = _create_usm_user_obj(snmp_credentials)\n    try:\n        for(errorIndication,\n            errorStatus,\n            errorIndex,\n            varBinds) in hlapi.nextCmd(\n                hlapi.SnmpEngine(),\n                usm_user_obj,\n                hlapi.UdpTransportTarget((iLOIP, 161), timeout=3, retries=3),\n                hlapi.ContextData(),\n                # cpqida cpqDaPhyDrvTable Drive Array Physical Drive Table\n                hlapi.ObjectType(\n                    hlapi.ObjectIdentity('1.3.6.1.4.1.232.3.2.5.1')),\n                # cpqscsi SCSI Physical Drive Table\n                hlapi.ObjectType(\n                    hlapi.ObjectIdentity('1.3.6.1.4.1.232.5.2.4.1')),\n                # cpqscsi SAS Physical Drive Table\n                hlapi.ObjectType(\n                    hlapi.ObjectIdentity('1.3.6.1.4.1.232.5.5.2.1')),\n                lexicographicMode=False,\n                ignoreNonIncreasingOid=True):\n\n            if errorIndication:\n                LOG.error(errorIndication)\n                msg = \"SNMP failed to traverse MIBs %s\", errorIndication\n                raise exception.IloSNMPInvalidInputFailure(msg)\n            else:\n                if errorStatus:\n                    msg = ('Parsing MIBs failed. %s at %s' % (\n                        errorStatus.prettyPrint(),\n                        errorIndex and varBinds[-1][int(errorIndex)-1]\n                        or '?'\n                        )\n                    )\n                    LOG.error(msg)\n                    raise exception.IloSNMPInvalidInputFailure(msg)\n                else:\n                    for varBindTableRow in varBinds:\n                        name, val = tuple(varBindTableRow)\n                        oid, label, suffix = (\n                            mibViewController.getNodeName(name))\n                        key = name.prettyPrint()\n                        # Don't traverse outside the tables we requested\n                        if not (key.find(\"SNMPv2-SMI::enterprises.232.3\") >= 0\n                                or (key.find(\n                                    \"SNMPv2-SMI::enterprises.232.5\") >= 0)):\n                            break\n                        if key not in result:\n                            result[key] = {}\n                            result[key][label[-1]] = {}\n                        result[key][label[-1]][suffix] = val\n    except Exception as e:\n        msg = \"SNMP library failed with error %s\", e\n        LOG.error(msg)\n        raise exception.IloSNMPExceptionFailure(msg)\n    return result", "response": "Parses the MIBs from the given iLOIP and returns a dictionary of the parsed MIBs."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nread the dictionary of parsed MIBs and gets the disk size.", "response": "def _get_disksize_MiB(iLOIP, cred):\n    \"\"\"Reads the dictionary of parsed MIBs and gets the disk size.\n\n    :param iLOIP: IP address of the server on which SNMP discovery\n                  has to be executed.\n    :param snmp_credentials in a dictionary having following mandatory\n           keys.\n           auth_user: SNMP user\n           auth_protocol: Auth Protocol\n           auth_prot_pp: Pass phrase value for AuthProtocol.\n           priv_protocol:Privacy Protocol.\n           auth_priv_pp: Pass phrase value for Privacy Protocol.\n\n    :returns the dictionary of disk sizes of all physical drives.\n    \"\"\"\n    # '1.3.6.1.4.1.232.5.5.1.1',  # cpqscsi SAS HBA Table\n    # '1.3.6.1.4.1.232.3.2.3.1',  # cpqida Drive Array Logical Drive Table\n    result = _parse_mibs(iLOIP, cred)\n    disksize = {}\n    for uuid in sorted(result):\n        for key in result[uuid]:\n            # We only track the Physical Disk Size\n            if key.find('PhyDrvSize') >= 0:\n                disksize[uuid] = dict()\n                for suffix in sorted(result[uuid][key]):\n                    size = result[uuid][key][suffix]\n                    disksize[uuid][key] = str(size)\n    return disksize"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_local_gb(iLOIP, snmp_credentials):\n    disk_sizes = _get_disksize_MiB(iLOIP, snmp_credentials)\n    max_size = 0\n    for uuid in disk_sizes:\n        for key in disk_sizes[uuid]:\n            if int(disk_sizes[uuid][key]) > max_size:\n                max_size = int(disk_sizes[uuid][key])\n    max_size_gb = max_size/1024\n    return max_size_gb", "response": "Gets the maximum disk size among all disks."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _http_error_handler(http_error):\n    ''' Simple error handler for azure.'''\n    message = str(http_error)\n    if http_error.respbody is not None:\n        message += '\\n' + http_error.respbody.decode('utf-8-sig')\n    raise AzureHttpError(message, http_error.status)", "response": "Simple error handler for azure."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef summary(self):\n        mac_dict = {}\n        for eth in self.get_members():\n            if eth.mac_address is not None:\n                if (eth.status is not None and\n                        eth.status.health == sys_cons.HEALTH_OK\n                        and eth.status.state ==\n                        sys_cons.HEALTH_STATE_ENABLED):\n                    mac_dict.update(\n                        {'Port ' + eth.identity: eth.mac_address})\n        return mac_dict", "response": "property to return the summary MAC addresses and state"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nupdating the RAID configuration with the details of the physical disks.", "response": "def _update_physical_disk_details(raid_config, server):\n    \"\"\"Adds the physical disk details to the RAID configuration passed.\"\"\"\n    raid_config['physical_disks'] = []\n    physical_drives = server.get_physical_drives()\n    for physical_drive in physical_drives:\n        physical_drive_dict = physical_drive.get_physical_drive_dict()\n        raid_config['physical_disks'].append(physical_drive_dict)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef validate(raid_config):\n    raid_schema_fobj = open(RAID_CONFIG_SCHEMA, 'r')\n    raid_config_schema = json.load(raid_schema_fobj)\n    try:\n        jsonschema.validate(raid_config, raid_config_schema)\n    except json_schema_exc.ValidationError as e:\n        raise exception.InvalidInputError(e.message)\n\n    for logical_disk in raid_config['logical_disks']:\n\n        # If user has provided 'number_of_physical_disks' or\n        # 'physical_disks', validate that they have mentioned at least\n        # minimum number of physical disks required for that RAID level.\n        raid_level = logical_disk['raid_level']\n        min_disks_reqd = constants.RAID_LEVEL_MIN_DISKS[raid_level]\n\n        no_of_disks_specified = None\n        if 'number_of_physical_disks' in logical_disk:\n            no_of_disks_specified = logical_disk['number_of_physical_disks']\n        elif 'physical_disks' in logical_disk:\n            no_of_disks_specified = len(logical_disk['physical_disks'])\n\n        if (no_of_disks_specified and\n                no_of_disks_specified < min_disks_reqd):\n            msg = (\"RAID level %(raid_level)s requires at least %(number)s \"\n                   \"disks.\" % {'raid_level': raid_level,\n                               'number': min_disks_reqd})\n            raise exception.InvalidInputError(msg)", "response": "Validates the RAID configuration provided against the RAID specification."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nfilter out the controllers which satisfy the condition.", "response": "def _select_controllers_by(server, select_condition, msg):\n    \"\"\"Filters out the hpssa controllers based on the condition.\n\n    This method updates the server with only the controller which satisfies\n    the condition. The controllers which doesn't satisfies the selection\n    condition will be removed from the list.\n\n    :param server: The object containing all the supported hpssa controllers\n        details.\n    :param select_condition: A lambda function to select the controllers based\n        on requirement.\n    :param msg: A String which describes the controller selection.\n    :raises exception.HPSSAOperationError, if all the controller are in HBA\n        mode.\n    \"\"\"\n    all_controllers = server.controllers\n    supported_controllers = [c for c in all_controllers if select_condition(c)]\n\n    if not supported_controllers:\n        reason = (\"None of the available SSA controllers %(controllers)s \"\n                  \"have %(msg)s\"\n                  % {'controllers': ', '.join([c.id for c in all_controllers]),\n                     'msg': msg})\n        raise exception.HPSSAOperationError(reason=reason)\n\n    server.controllers = supported_controllers"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating a RAID configuration on this server based on the input passed.", "response": "def create_configuration(raid_config):\n    \"\"\"Create a RAID configuration on this server.\n\n    This method creates the given RAID configuration on the\n    server based on the input passed.\n    :param raid_config: The dictionary containing the requested\n        RAID configuration. This data structure should be as follows:\n        raid_config = {'logical_disks': [{'raid_level': 1, 'size_gb': 100},\n                                         <info-for-logical-disk-2>\n                                        ]}\n    :returns: the current raid configuration. This is same as raid_config\n        with some extra properties like root_device_hint, volume_name,\n        controller, physical_disks, etc filled for each logical disk\n        after its creation.\n    :raises exception.InvalidInputError, if input is invalid.\n    :raises exception.HPSSAOperationError, if all the controllers are in HBA\n        mode.\n    \"\"\"\n    server = objects.Server()\n\n    select_controllers = lambda x: not x.properties.get('HBA Mode Enabled',\n                                                        False)\n    _select_controllers_by(server, select_controllers, 'RAID enabled')\n\n    validate(raid_config)\n\n    # Make sure we create the large disks first.  This is avoid the\n    # situation that we avoid giving large disks to smaller requests.\n    # For example, consider this:\n    #   - two logical disks - LD1(50), LD(100)\n    #   - have 4 physical disks - PD1(50), PD2(50), PD3(100), PD4(100)\n    #\n    # In this case, for RAID1 configuration, if we were to consider\n    # LD1 first and allocate PD3 and PD4 for it, then allocation would\n    # fail. So follow a particular order for allocation.\n    #\n    # Also make sure we create the MAX logical_disks the last to make sure\n    # we allot only the remaining space available.\n    logical_disks_sorted = (\n        sorted((x for x in raid_config['logical_disks']\n                if x['size_gb'] != \"MAX\"),\n               reverse=True,\n               key=lambda x: x['size_gb']) +\n        [x for x in raid_config['logical_disks'] if x['size_gb'] == \"MAX\"])\n\n    if any(logical_disk['share_physical_disks']\n            for logical_disk in logical_disks_sorted\n            if 'share_physical_disks' in logical_disk):\n        logical_disks_sorted = _sort_shared_logical_disks(logical_disks_sorted)\n\n    # We figure out the new disk created by recording the wwns\n    # before and after the create, and then figuring out the\n    # newly found wwn from it.\n    wwns_before_create = set([x.wwn for x in\n                              server.get_logical_drives()])\n\n    for logical_disk in logical_disks_sorted:\n\n        if 'physical_disks' not in logical_disk:\n            disk_allocator.allocate_disks(logical_disk, server,\n                                          raid_config)\n\n        controller_id = logical_disk['controller']\n\n        controller = server.get_controller_by_id(controller_id)\n        if not controller:\n            msg = (\"Unable to find controller named '%(controller)s'.\"\n                   \" The available controllers are '%(ctrl_list)s'.\" %\n                   {'controller': controller_id,\n                    'ctrl_list': ', '.join(\n                        [c.id for c in server.controllers])})\n            raise exception.InvalidInputError(reason=msg)\n\n        if 'physical_disks' in logical_disk:\n            for physical_disk in logical_disk['physical_disks']:\n                disk_obj = controller.get_physical_drive_by_id(physical_disk)\n                if not disk_obj:\n                    msg = (\"Unable to find physical disk '%(physical_disk)s' \"\n                           \"on '%(controller)s'\" %\n                           {'physical_disk': physical_disk,\n                            'controller': controller_id})\n                    raise exception.InvalidInputError(msg)\n\n        controller.create_logical_drive(logical_disk)\n\n        # Now find the new logical drive created.\n        server.refresh()\n        wwns_after_create = set([x.wwn for x in\n                                 server.get_logical_drives()])\n\n        new_wwn = wwns_after_create - wwns_before_create\n\n        if not new_wwn:\n            reason = (\"Newly created logical disk with raid_level \"\n                      \"'%(raid_level)s' and size %(size_gb)s GB not \"\n                      \"found.\" % {'raid_level': logical_disk['raid_level'],\n                                  'size_gb': logical_disk['size_gb']})\n            raise exception.HPSSAOperationError(reason=reason)\n\n        new_logical_disk = server.get_logical_drive_by_wwn(new_wwn.pop())\n        new_log_drive_properties = new_logical_disk.get_logical_drive_dict()\n        logical_disk.update(new_log_drive_properties)\n\n        wwns_before_create = wwns_after_create.copy()\n\n    _update_physical_disk_details(raid_config, server)\n    return raid_config"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _sort_shared_logical_disks(logical_disks):\n    is_shared = (lambda x: True if ('share_physical_disks' in x and\n                                    x['share_physical_disks']) else False)\n    num_of_disks = (lambda x: x['number_of_physical_disks']\n                    if 'number_of_physical_disks' in x else\n                    constants.RAID_LEVEL_MIN_DISKS[x['raid_level']])\n\n    # Separate logical disks based on share_physical_disks value.\n    # 'logical_disks_shared' when share_physical_disks is True and\n    # 'logical_disks_nonshared' when share_physical_disks is False\n    logical_disks_shared = []\n    logical_disks_nonshared = []\n    for x in logical_disks:\n        target = (logical_disks_shared if is_shared(x)\n                  else logical_disks_nonshared)\n        target.append(x)\n\n    # Separete logical disks with raid 1 from the 'logical_disks_shared' into\n    # 'logical_disks_shared_raid1' and remaining as\n    # 'logical_disks_shared_excl_raid1'.\n    logical_disks_shared_raid1 = []\n    logical_disks_shared_excl_raid1 = []\n    for x in logical_disks_shared:\n        target = (logical_disks_shared_raid1 if x['raid_level'] == '1'\n                  else logical_disks_shared_excl_raid1)\n        target.append(x)\n\n    # Sort the 'logical_disks_shared' in reverse order based on\n    # 'number_of_physical_disks' attribute, if provided, otherwise minimum\n    # disks required to create the logical volume.\n    logical_disks_shared = sorted(logical_disks_shared_excl_raid1,\n                                  reverse=True,\n                                  key=num_of_disks)\n\n    # Move RAID 1+0 to first in 'logical_disks_shared' when number of physical\n    # disks needed to create logical volume cannot be shared with odd number of\n    # disks and disks higher than that of RAID 1+0.\n    check = True\n    for x in logical_disks_shared:\n        if x['raid_level'] == \"1+0\":\n            x_num = num_of_disks(x)\n            for y in logical_disks_shared:\n                if y['raid_level'] != \"1+0\":\n                    y_num = num_of_disks(y)\n                    if x_num < y_num:\n                        check = (True if y_num % 2 == 0 else False)\n                        if check:\n                            break\n        if not check:\n            logical_disks_shared.remove(x)\n            logical_disks_shared.insert(0, x)\n            check = True\n\n    # Final 'logical_disks_sorted' list should have non shared logical disks\n    # first, followed by shared logical disks with RAID 1, and finally by the\n    # shared logical disks sorted based on number of disks and RAID 1+0\n    # condition.\n    logical_disks_sorted = (logical_disks_nonshared +\n                            logical_disks_shared_raid1 +\n                            logical_disks_shared)\n    return logical_disks_sorted", "response": "Sort the logical disks based on the conditions that are set in the RAID1 and RAID2."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef delete_configuration():\n    server = objects.Server()\n\n    select_controllers = lambda x: not x.properties.get('HBA Mode Enabled',\n                                                        False)\n    _select_controllers_by(server, select_controllers, 'RAID enabled')\n\n    for controller in server.controllers:\n        # Trigger delete only if there is some RAID array, otherwise\n        # hpssacli/ssacli will fail saying \"no logical drives found.\".\n        if controller.raid_arrays:\n            controller.delete_all_logical_drives()\n    return get_configuration()", "response": "Delete a RAID configuration on this server."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_configuration():\n    server = objects.Server()\n    logical_drives = server.get_logical_drives()\n    raid_config = {}\n    raid_config['logical_disks'] = []\n\n    for logical_drive in logical_drives:\n        logical_drive_dict = logical_drive.get_logical_drive_dict()\n        raid_config['logical_disks'].append(logical_drive_dict)\n\n    _update_physical_disk_details(raid_config, server)\n    return raid_config", "response": "Get the current RAID configuration."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef erase_devices():\n    server = objects.Server()\n\n    for controller in server.controllers:\n        drives = [x for x in controller.unassigned_physical_drives\n                  if (x.get_physical_drive_dict().get('erase_status', '')\n                      == 'OK')]\n        if drives:\n            controller.erase_devices(drives)\n\n    while not has_erase_completed():\n        time.sleep(300)\n\n    server.refresh()\n\n    status = {}\n    for controller in server.controllers:\n        drive_status = {x.id: x.erase_status\n                        for x in controller.unassigned_physical_drives}\n        sanitize_supported = controller.properties.get(\n            'Sanitize Erase Supported', 'False')\n        if sanitize_supported == 'False':\n            msg = (\"Drives overwritten with zeros because sanitize erase \"\n                   \"is not supported on the controller.\")\n        else:\n            msg = (\"Sanitize Erase performed on the disks attached to \"\n                   \"the controller.\")\n\n        drive_status.update({'Summary': msg})\n        status[controller.id] = drive_status\n\n    return status", "response": "Erase all the drives on this server."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _parse_metadata_and_message_count(response):\n    '''\n    Extracts approximate messages count header.\n    '''\n    metadata = _parse_metadata(response)\n\n    headers = _parse_response_for_dict(response)\n    metadata.approximate_message_count = _int_to_str(headers.get('x-ms-approximate-messages-count'))\n\n    return metadata", "response": "Extracts approximate messages count header."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nextracting pop receipt and time next visible from headers.", "response": "def _parse_queue_message_from_headers(response):\n    '''\n    Extracts pop receipt and time next visible from headers.\n    '''\n    headers = _parse_response_for_dict(response)\n\n    message = QueueMessage()\n    message.pop_receipt = headers.get('x-ms-popreceipt')\n    message.time_next_visible = parser.parse(headers.get('x-ms-time-next-visible'))\n    \n    return message"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nconvert XML response to QueueMessagesList", "response": "def _convert_xml_to_queue_messages(response, decode_function):\n    '''\n    <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    <QueueMessagesList>\n        <QueueMessage>\n          <MessageId>string-message-id</MessageId>\n          <InsertionTime>insertion-time</InsertionTime>\n          <ExpirationTime>expiration-time</ExpirationTime>\n          <PopReceipt>opaque-string-receipt-data</PopReceipt>\n          <TimeNextVisible>time-next-visible</TimeNextVisible>\n          <DequeueCount>integer</DequeueCount>\n          <MessageText>message-body</MessageText>\n        </QueueMessage>\n    </QueueMessagesList>\n    '''\n    if response is None or response.body is None:\n        return response\n\n    messages = list()\n    list_element = ETree.fromstring(response.body)\n\n    for message_element in list_element.findall('QueueMessage'):\n        message = QueueMessage()\n\n        message.id = message_element.findtext('MessageId')\n        message.dequeue_count = message_element.findtext('DequeueCount')\n\n        message.content = decode_function(message_element.findtext('MessageText'))\n\n        message.insertion_time = parser.parse(message_element.findtext('InsertionTime'))\n        message.expiration_time = parser.parse(message_element.findtext('ExpirationTime'))\n        \n        message.pop_receipt = message_element.findtext('PopReceipt')\n\n        time_next_visible = message_element.find('TimeNextVisible')\n        if time_next_visible is not None:\n            message.time_next_visible = parser.parse(time_next_visible.text)\n\n        # Add message to list\n        messages.append(message)\n\n    return messages"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the list of drives.", "response": "def _drives_list(self):\n        \"\"\"Gets the list of drives\n\n        :return a list of drives.\n        \"\"\"\n        drives_list = []\n        for member in self.drives:\n            drives_list.append(sys_drives.Drive(\n                self._conn, member.get('@odata.id'), self.redfish_version))\n        return drives_list"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn true if any of the drives is ssd", "response": "def has_ssd(self):\n        \"\"\"Return true if any of the drive is ssd\"\"\"\n        for member in self._drives_list():\n            if member.media_type == constants.MEDIA_TYPE_SSD:\n                return True\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef has_rotational(self):\n        for member in self._drives_list():\n            if member.media_type == constants.MEDIA_TYPE_HDD:\n                return True\n        return False", "response": "Return True if any of the drives is HDD."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns True if the drive is SSD and protocol is NVMe", "response": "def has_nvme_ssd(self):\n        \"\"\"Return True if the drive is SSD and protocol is NVMe\"\"\"\n        for member in self._drives_list():\n            if (member.media_type == constants.MEDIA_TYPE_SSD and\n                    member.protocol == constants.PROTOCOL_NVMe):\n                return True\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef drive_rotational_speed_rpm(self):\n\n        drv_rot_speed_rpm = set()\n        for member in self._drives_list():\n            if member.rotation_speed_rpm is not None:\n                drv_rot_speed_rpm.add(member.rotation_speed_rpm)\n        return drv_rot_speed_rpm", "response": "Gets the set of rotational speed of the disks"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef volumes_maximum_size_bytes(self):\n        return utils.max_safe([member.volumes.maximum_size_bytes\n                               for member in self.get_members()])", "response": "Gets the biggest logical drive node s maximum size in MiB."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef drive_rotational_speed_rpm(self):\n        drv_rot_speed_rpm = set()\n        for member in self.get_members():\n            drv_rot_speed_rpm.update(member.drive_rotational_speed_rpm)\n        return drv_rot_speed_rpm", "response": "Gets the set of rotational speed of the disks"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef create_table_service(self):\n        '''\n        Creates a TableService object with the settings specified in the \n        CloudStorageAccount.\n\n        :return: A service object.\n        :rtype: :class:`~azure.storage.table.tableservice.TableService`\n        '''\n        try:\n            from ..table.tableservice import TableService\n            return TableService(self.account_name, self.account_key,\n                                sas_token=self.sas_token,\n                                is_emulated=self.is_emulated)\n        except ImportError:\n            raise Exception('The package azure-storage-table is required. '\n                            + 'Please install it using \"pip install azure-storage-table\"')", "response": "Creates a TableService object with the settings specified in the \n        CloudStorageAccount."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nretrieve the properties of a storage account s Queue service including Azure Storage Account s Queue service logging analytics and CORS rules.", "response": "def get_queue_service_properties(self, timeout=None):\n        '''\n        Gets the properties of a storage account's Queue service, including\n        logging, analytics and CORS rules.\n\n        :param int timeout:\n            The server timeout, expressed in seconds.\n        :return: The queue service properties.\n        :rtype: :class:`~azure.storage.models.ServiceProperties`\n        '''\n        request = HTTPRequest()\n        request.method = 'GET'\n        request.host = self._get_host()\n        request.path = _get_path()\n        request.query = [\n            ('restype', 'service'),\n            ('comp', 'properties'),\n            ('timeout', _int_to_str(timeout)),\n        ]\n        response = self._perform_request(request)\n\n        return _convert_xml_to_service_properties(response.body)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef list_queues(self, prefix=None, num_results=None, include_metadata=False, \n                    marker=None, timeout=None):\n        '''\n        Returns a generator to list the queues. The generator will lazily follow \n        the continuation tokens returned by the service and stop when all queues \n        have been returned or num_results is reached.\n\n        If num_results is specified and the account has more than that number of \n        queues, the generator will have a populated next_marker field once it \n        finishes. This marker can be used to create a new generator if more \n        results are desired.\n\n        :param str prefix:\n            Filters the results to return only queues with names that begin\n            with the specified prefix.\n        :param int num_results:\n            The maximum number of queues to return.\n        :param bool include_metadata:\n            Specifies that container metadata be returned in the response.\n        :param str marker:\n            An opaque continuation token. This value can be retrieved from the \n            next_marker field of a previous generator object if num_results was \n            specified and that generator has finished enumerating results. If \n            specified, this generator will begin returning results from the point \n            where the previous generator stopped.\n        :param int timeout:\n            The server timeout, expressed in seconds. This function may make multiple \n            calls to the service in which case the timeout value specified will be \n            applied to each individual call.\n        '''\n        include = 'metadata' if include_metadata else None\n        kwargs = {'prefix': prefix, 'max_results': num_results, 'include': include, \n                  'marker': marker, 'timeout': timeout}\n        resp = self._list_queues(**kwargs)\n\n        return ListGenerator(resp, self._list_queues, (), kwargs)", "response": "Returns a generator to list the queues in the specified prefix."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _list_queues(self, prefix=None, marker=None, max_results=None,\n                    include=None, timeout=None):\n        '''\n        Returns a list of queues under the specified account. Makes a single list \n        request to the service. Used internally by the list_queues method.\n\n        :param str prefix:\n            Filters the results to return only queues with names that begin\n            with the specified prefix.\n        :param str marker:\n            A token which identifies the portion of the query to be\n            returned with the next query operation. The operation returns a\n            next_marker element within the response body if the list returned\n            was not complete. This value may then be used as a query parameter\n            in a subsequent call to request the next portion of the list of\n            queues. The marker value is opaque to the client.\n        :param int max_results:\n            The maximum number of queues to return. A single list request may \n            return up to 1000 queues and potentially a continuation token which \n            should be followed to get additional resutls.\n        :param str include:\n            Include this parameter to specify that the container's\n            metadata be returned as part of the response body.\n        :param int timeout:\n            The server timeout, expressed in seconds.\n        '''\n        request = HTTPRequest()\n        request.method = 'GET'\n        request.host = self._get_host()\n        request.path = _get_path()\n        request.query = [\n            ('comp', 'list'),\n            ('prefix', _to_str(prefix)),\n            ('marker', _to_str(marker)),\n            ('maxresults', _int_to_str(max_results)),\n            ('include', _to_str(include)),\n            ('timeout', _int_to_str(timeout))\n        ]\n        response = self._perform_request(request)\n\n        return _convert_xml_to_queues(response)", "response": "Returns a list of queues under the specified account."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef create_queue(self, queue_name, metadata=None, fail_on_exist=False, timeout=None):\n        '''\n        Creates a queue under the given account.\n\n        :param str queue_name:\n            The name of the queue to create. A queue name must be from 3 through \n            63 characters long and may only contain lowercase letters, numbers, \n            and the dash (-) character. The first and last letters in the queue \n            must be alphanumeric. The dash (-) character cannot be the first or \n            last character. Consecutive dash characters are not permitted in the \n            queue name.\n        :param metadata:\n            A dict containing name-value pairs to associate with the queue as \n            metadata. Note that metadata names preserve the case with which they \n            were created, but are case-insensitive when set or read. \n        :type metadata: a dict mapping str to str \n        :param bool fail_on_exist:\n            Specifies whether to throw an exception if the queue already exists.\n        :param int timeout:\n            The server timeout, expressed in seconds.\n        :return:\n            A boolean indicating whether the queue was created. If fail_on_exist \n            was set to True, this will throw instead of returning false.\n        :rtype: bool\n        '''\n        _validate_not_none('queue_name', queue_name)\n        request = HTTPRequest()\n        request.method = 'PUT'\n        request.host = self._get_host()\n        request.path = _get_path(queue_name)\n        request.query = [('timeout', _int_to_str(timeout))]\n        request.headers = [('x-ms-meta-name-values', metadata)]\n        if not fail_on_exist:\n            try:\n                response = self._perform_request(request)\n                if response.status == _HTTP_RESPONSE_NO_CONTENT:\n                    return False\n                return True\n            except AzureHttpError as ex:\n                _dont_fail_on_exist(ex)\n                return False\n        else:\n            response = self._perform_request(request)\n            if response.status == _HTTP_RESPONSE_NO_CONTENT:\n                raise AzureConflictHttpError(\n                    _ERROR_CONFLICT.format(response.message), response.status)\n            return True", "response": "Creates a queue under the given account."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_queue_metadata(self, queue_name, timeout=None):\n        '''\n        Retrieves user-defined metadata and queue properties on the specified\n        queue. Metadata is associated with the queue as name-value pairs.\n\n        :param str queue_name:\n            The name of an existing queue.\n        :param int timeout:\n            The server timeout, expressed in seconds.\n        :return:\n            A dictionary representing the queue metadata with an \n            approximate_message_count int property on the dict estimating the \n            number of messages in the queue.\n        :rtype: a dict mapping str to str\n        '''\n        _validate_not_none('queue_name', queue_name)\n        request = HTTPRequest()\n        request.method = 'GET'\n        request.host = self._get_host()\n        request.path = _get_path(queue_name)\n        request.query = [\n            ('comp', 'metadata'),\n            ('timeout', _int_to_str(timeout)),\n        ]\n        response = self._perform_request(request)\n\n        return _parse_metadata_and_message_count(response)", "response": "Retrieves user - defined metadata and queue properties on the specified queue."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set_queue_metadata(self, queue_name, metadata=None, timeout=None):\n        '''\n        Sets user-defined metadata on the specified queue. Metadata is\n        associated with the queue as name-value pairs.\n\n        :param str queue_name:\n            The name of an existing queue.\n        :param dict metadata:\n            A dict containing name-value pairs to associate with the\n            queue as metadata.\n        :param int timeout:\n            The server timeout, expressed in seconds.\n        '''\n        _validate_not_none('queue_name', queue_name)\n        request = HTTPRequest()\n        request.method = 'PUT'\n        request.host = self._get_host()\n        request.path = _get_path(queue_name)\n        request.query = [\n            ('comp', 'metadata'),\n            ('timeout', _int_to_str(timeout)),\n        ]\n        request.headers = [('x-ms-meta-name-values', metadata)]\n        self._perform_request(request)", "response": "Sets user - defined metadata on the specified queue."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn details about any stored access policies associated with the specified queue.", "response": "def get_queue_acl(self, queue_name, timeout=None):\n        '''\n        Returns details about any stored access policies specified on the\n        queue that may be used with Shared Access Signatures.\n\n        :param str queue_name:\n            The name of an existing queue.\n        :param int timeout:\n            The server timeout, expressed in seconds.\n        :return: A dictionary of access policies associated with the queue.\n        :rtype: dict of str to :class:`~azure.storage.models.AccessPolicy`\n        '''\n        _validate_not_none('queue_name', queue_name)\n        request = HTTPRequest()\n        request.method = 'GET'\n        request.host = self._get_host()\n        request.path = _get_path(queue_name)\n        request.query = [\n            ('comp', 'acl'),\n            ('timeout', _int_to_str(timeout)),\n        ]\n        response = self._perform_request(request)\n\n        return _convert_xml_to_signed_identifiers(response.body)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef set_queue_acl(self, queue_name, signed_identifiers=None, timeout=None):\n        '''\n        Sets stored access policies for the queue that may be used with Shared \n        Access Signatures. \n        \n        When you set permissions for a queue, the existing permissions are replaced. \n        To update the queue\u2019s permissions, call :func:`~get_queue_acl` to fetch \n        all access policies associated with the queue, modify the access policy \n        that you wish to change, and then call this function with the complete \n        set of data to perform the update.\n\n        When you establish a stored access policy on a queue, it may take up to \n        30 seconds to take effect. During this interval, a shared access signature \n        that is associated with the stored access policy will throw an \n        :class:`AzureHttpError` until the access policy becomes active.\n\n        :param str queue_name:\n            The name of an existing queue.\n        :param signed_identifiers:\n            A dictionary of access policies to associate with the queue. The \n            dictionary may contain up to 5 elements. An empty dictionary \n            will clear the access policies set on the service. \n        :type signed_identifiers: dict of str to :class:`~azure.storage.models.AccessPolicy`\n        :param int timeout:\n            The server timeout, expressed in seconds.\n        '''\n        _validate_not_none('queue_name', queue_name)\n        request = HTTPRequest()\n        request.method = 'PUT'\n        request.host = self._get_host()\n        request.path = _get_path(queue_name)\n        request.query = [\n            ('comp', 'acl'),\n            ('timeout', _int_to_str(timeout)),\n        ]\n        request.body = _get_request_body(\n            _convert_signed_identifiers_to_xml(signed_identifiers))\n        self._perform_request(request)", "response": "Sets the permissions for a queue."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef put_message(self, queue_name, content, visibility_timeout=None,\n                    time_to_live=None, timeout=None):\n        '''\n        Adds a new message to the back of the message queue. \n\n        The visibility timeout specifies the time that the message will be \n        invisible. After the timeout expires, the message will become visible. \n        If a visibility timeout is not specified, the default value of 0 is used.\n\n        The message time-to-live specifies how long a message will remain in the \n        queue. The message will be deleted from the queue when the time-to-live \n        period expires.\n\n        :param str queue_name:\n            The name of the queue to put the message into.\n        :param obj content:\n            Message content. Allowed type is determined by the encode_function \n            set on the service. Default is str. The encoded message can be up to \n            64KB in size.\n        :param int visibility_timeout:\n            If not specified, the default value is 0. Specifies the\n            new visibility timeout value, in seconds, relative to server time.\n            The value must be larger than or equal to 0, and cannot be\n            larger than 7 days. The visibility timeout of a message cannot be\n            set to a value later than the expiry time. visibility_timeout\n            should be set to a value smaller than the time-to-live value.\n        :param int time_to_live:\n            Specifies the time-to-live interval for the message, in\n            seconds. The maximum time-to-live allowed is 7 days. If this\n            parameter is omitted, the default time-to-live is 7 days.\n        :param int timeout:\n            The server timeout, expressed in seconds.\n        '''\n        _validate_not_none('queue_name', queue_name)\n        _validate_not_none('content', content)\n        request = HTTPRequest()\n        request.method = 'POST'\n        request.host = self._get_host()\n        request.path = _get_path(queue_name, True)\n        request.query = [\n            ('visibilitytimeout', _to_str(visibility_timeout)),\n            ('messagettl', _to_str(time_to_live)),\n            ('timeout', _int_to_str(timeout))\n        ]\n        request.body = _get_request_body(_convert_queue_message_xml(content, self.encode_function))\n        self._perform_request(request)", "response": "Adds a new message into the back of the message queue."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nretrieves one or more messages from the front of a queue.", "response": "def get_messages(self, queue_name, num_messages=None,\n                     visibility_timeout=None, timeout=None):\n        '''\n        Retrieves one or more messages from the front of the queue.\n\n        When a message is retrieved from the queue, the response includes the message \n        content and a pop_receipt value, which is required to delete the message. \n        The message is not automatically deleted from the queue, but after it has \n        been retrieved, it is not visible to other clients for the time interval \n        specified by the visibility_timeout parameter.\n\n        :param str queue_name:\n            The name of the queue to get messages from.\n        :param int num_messages:\n            A nonzero integer value that specifies the number of\n            messages to retrieve from the queue, up to a maximum of 32. If\n            fewer are visible, the visible messages are returned. By default,\n            a single message is retrieved from the queue with this operation.\n        :param int visibility_timeout:\n            Specifies the new visibility timeout value, in seconds, relative\n            to server time. The new value must be larger than or equal to 1\n            second, and cannot be larger than 7 days. The visibility timeout of \n            a message can be set to a value later than the expiry time.\n        :param int timeout:\n            The server timeout, expressed in seconds.\n        :return: A list of :class:`~azure.storage.queue.models.QueueMessage` objects.\n        :rtype: list of :class:`~azure.storage.queue.models.QueueMessage`\n        '''\n        _validate_not_none('queue_name', queue_name)\n        request = HTTPRequest()\n        request.method = 'GET'\n        request.host = self._get_host()\n        request.path = _get_path(queue_name, True)\n        request.query = [\n            ('numofmessages', _to_str(num_messages)),\n            ('visibilitytimeout', _to_str(visibility_timeout)),\n            ('timeout', _int_to_str(timeout))\n        ]\n        response = self._perform_request(request)\n\n        return _convert_xml_to_queue_messages(response, self.decode_function)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef clear_messages(self, queue_name, timeout=None):\n        '''\n        Deletes all messages from the specified queue.\n\n        :param str queue_name:\n            The name of the queue whose messages to clear.\n        :param int timeout:\n            The server timeout, expressed in seconds.\n        '''\n        _validate_not_none('queue_name', queue_name)\n        request = HTTPRequest()\n        request.method = 'DELETE'\n        request.host = self._get_host()\n        request.path = _get_path(queue_name, True)\n        request.query = [('timeout', _int_to_str(timeout))]\n        self._perform_request(request)", "response": "Deletes all messages from the specified queue."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef update_message(self, queue_name, message_id, pop_receipt, visibility_timeout, \n                       content=None, timeout=None):\n        '''\n        Updates the visibility timeout of a message. You can also use this\n        operation to update the contents of a message.\n\n        This operation can be used to continually extend the invisibility of a \n        queue message. This functionality can be useful if you want a worker role \n        to \u201clease\u201d a queue message. For example, if a worker role calls get_messages \n        and recognizes that it needs more time to process a message, it can \n        continually extend the message\u2019s invisibility until it is processed. If \n        the worker role were to fail during processing, eventually the message \n        would become visible again and another worker role could process it.\n\n        :param str queue_name:\n            The name of the queue containing the message to update.\n        :param str message_id:\n            The message id identifying the message to update.\n        :param str pop_receipt:\n            A valid pop receipt value returned from an earlier call\n            to the :func:`~get_messages` or :func:`~update_message` operation.\n        :param int visibility_timeout:\n            Specifies the new visibility timeout value, in seconds,\n            relative to server time. The new value must be larger than or equal\n            to 0, and cannot be larger than 7 days. The visibility timeout of a\n            message cannot be set to a value later than the expiry time. A\n            message can be updated until it has been deleted or has expired.\n        :param obj content:\n            Message content. Allowed type is determined by the encode_function \n            set on the service. Default is str.\n        :param int timeout:\n            The server timeout, expressed in seconds.\n        :return: \n            A list of :class:`~azure.storage.queue.models.QueueMessage` objects. Note that \n            only time_next_visible and pop_receipt will be populated.\n        :rtype: list of :class:`~azure.storage.queue.models.QueueMessage`\n        '''\n        _validate_not_none('queue_name', queue_name)\n        _validate_not_none('message_id', message_id)\n        _validate_not_none('pop_receipt', pop_receipt)\n        _validate_not_none('visibility_timeout', visibility_timeout)\n        request = HTTPRequest()\n        request.method = 'PUT'\n        request.host = self._get_host()\n        request.path = _get_path(queue_name, True, message_id)\n        request.query = [\n            ('popreceipt', _to_str(pop_receipt)),\n            ('visibilitytimeout', _int_to_str(visibility_timeout)),\n            ('timeout', _int_to_str(timeout))\n        ]\n\n        if content is not None:\n            request.body = _get_request_body(_convert_queue_message_xml(content, self.encode_function))\n\n        response = self._perform_request(request)\n        return _parse_queue_message_from_headers(response)", "response": "Updates the visibility timeout of a message."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nenabling or disable secure boot on the server.", "response": "def enable_secure_boot(self, secure_boot_enable):\n        \"\"\"Enable/Disable secure boot on the server.\n\n        Caller needs to reset the server after issuing this command\n        to bring this into effect.\n        :param secure_boot_enable: True, if secure boot needs to be\n               enabled for next boot, else False.\n        :raises: InvalidInputError, if the validation of the input fails\n        :raises: SushyError, on an error from iLO.\n        \"\"\"\n        if not isinstance(secure_boot_enable, bool):\n            msg = ('The parameter \"%(parameter)s\" value \"%(value)s\" is '\n                   'invalid. Valid values are: True/False.' %\n                   {'parameter': 'secure_boot_enable',\n                    'value': secure_boot_enable})\n            raise exception.InvalidInputError(msg)\n\n        self._conn.patch(self.path,\n                         data={'SecureBootEnable': secure_boot_enable})"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_allowed_reset_keys_values(self):\n        reset_keys_action = self._get_reset_keys_action_element()\n\n        if not reset_keys_action.allowed_values:\n            LOG.warning('Could not figure out the allowed values for the '\n                        'reset keys in secure boot %s', self.path)\n            return set(mappings.SECUREBOOT_RESET_KEYS_MAP_REV)\n\n        return set([mappings.SECUREBOOT_RESET_KEYS_MAP[v] for v in\n                    set(mappings.SECUREBOOT_RESET_KEYS_MAP).\n                    intersection(reset_keys_action.allowed_values)])", "response": "Get the allowed values for resetting the system."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef reset_keys(self, target_value):\n        valid_keys_resets = self.get_allowed_reset_keys_values()\n        if target_value not in valid_keys_resets:\n            msg = ('The parameter \"%(parameter)s\" value \"%(target_value)s\" is '\n                   'invalid. Valid values are: %(valid_keys_reset_values)s' %\n                   {'parameter': 'target_value', 'target_value': target_value,\n                    'valid_keys_reset_values': valid_keys_resets})\n            raise exception.InvalidInputError(msg)\n\n        value = mappings.SECUREBOOT_RESET_KEYS_MAP_REV[target_value]\n        target_uri = (\n            self._get_reset_keys_action_element().target_uri)\n\n        self._conn.post(target_uri, data={'ResetKeysType': value})", "response": "Resets the secure boot keys."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nextract out resource properties and metadata information.", "response": "def _parse_properties(response, result_class):\n    '''\n    Extracts out resource properties and metadata information.\n    Ignores the standard http headers.\n    '''\n\n    if response is None or response.headers is None:\n        return None\n\n    props = result_class()\n    for key, value in response.headers:\n        info = GET_PROPERTIES_ATTRIBUTE_MAP.get(key)\n        if info:\n            if info[0] is None:\n                setattr(props, info[1], info[2](value))\n            else:\n                attr = getattr(props, info[0])\n                setattr(attr, info[1], info[2](value))\n\n    return props"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nextracting name - values from response header. Filter out the standard http headers.", "response": "def _parse_response_for_dict(response):\n    ''' Extracts name-values from response header. Filter out the standard\n    http headers.'''\n\n    if response is None:\n        return None\n    http_headers = ['server', 'date', 'location', 'host',\n                    'via', 'proxy-connection', 'connection']\n    return_dict = _HeaderDict()\n    if response.headers:\n        for name, value in response.headers:\n            if not name.lower() in http_headers:\n                return_dict[name] = value\n\n    return return_dict"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _convert_xml_to_service_properties(xml):\n    '''\n    <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    <StorageServiceProperties>\n        <Logging>\n            <Version>version-number</Version>\n            <Delete>true|false</Delete>\n            <Read>true|false</Read>\n            <Write>true|false</Write>\n            <RetentionPolicy>\n                <Enabled>true|false</Enabled>\n                <Days>number-of-days</Days>\n            </RetentionPolicy>\n        </Logging>\n        <HourMetrics>\n            <Version>version-number</Version>\n            <Enabled>true|false</Enabled>\n            <IncludeAPIs>true|false</IncludeAPIs>\n            <RetentionPolicy>\n                <Enabled>true|false</Enabled>\n                <Days>number-of-days</Days>\n            </RetentionPolicy>\n        </HourMetrics>\n        <MinuteMetrics>\n            <Version>version-number</Version>\n            <Enabled>true|false</Enabled>\n            <IncludeAPIs>true|false</IncludeAPIs>\n            <RetentionPolicy>\n                <Enabled>true|false</Enabled>\n                <Days>number-of-days</Days>\n            </RetentionPolicy>\n        </MinuteMetrics>\n        <Cors>\n            <CorsRule>\n                <AllowedOrigins>comma-separated-list-of-allowed-origins</AllowedOrigins>\n                <AllowedMethods>comma-separated-list-of-HTTP-verb</AllowedMethods>\n                <MaxAgeInSeconds>max-caching-age-in-seconds</MaxAgeInSeconds>\n                <ExposedHeaders>comma-seperated-list-of-response-headers</ExposedHeaders>\n                <AllowedHeaders>comma-seperated-list-of-request-headers</AllowedHeaders>\n            </CorsRule>\n        </Cors>\n    </StorageServiceProperties>\n    '''\n    service_properties_element = ETree.fromstring(xml)\n    service_properties = ServiceProperties()\n    \n    # Logging\n    logging = service_properties_element.find('Logging')\n    if logging is not None:\n        service_properties.logging = Logging()\n        service_properties.logging.version = logging.find('Version').text\n        service_properties.logging.delete = _bool(logging.find('Delete').text)\n        service_properties.logging.read = _bool(logging.find('Read').text)\n        service_properties.logging.write = _bool(logging.find('Write').text)\n\n        _convert_xml_to_retention_policy(logging.find('RetentionPolicy'), \n                                            service_properties.logging.retention_policy)\n    # HourMetrics\n    hour_metrics_element = service_properties_element.find('HourMetrics')\n    if hour_metrics_element is not None:\n        service_properties.hour_metrics = Metrics()\n        _convert_xml_to_metrics(hour_metrics_element, service_properties.hour_metrics)\n\n    # MinuteMetrics\n    minute_metrics_element = service_properties_element.find('MinuteMetrics')\n    if minute_metrics_element is not None:\n        service_properties.minute_metrics = Metrics()\n        _convert_xml_to_metrics(minute_metrics_element, service_properties.minute_metrics)\n\n    # CORS\n    cors = service_properties_element.find('Cors')\n    if cors is not None:\n        service_properties.cors = list()\n        for rule in cors.findall('CorsRule'):\n            allowed_origins = rule.find('AllowedOrigins').text.split(',')\n\n            allowed_methods = rule.find('AllowedMethods').text.split(',')\n\n            max_age_in_seconds = int(rule.find('MaxAgeInSeconds').text)\n\n            cors_rule = CorsRule(allowed_origins, allowed_methods, max_age_in_seconds)\n\n            exposed_headers = rule.find('ExposedHeaders').text\n            if exposed_headers is not None:\n                cors_rule.exposed_headers = exposed_headers.split(',')\n\n            allowed_headers = rule.find('AllowedHeaders').text\n            if allowed_headers is not None:\n                cors_rule.allowed_headers = allowed_headers.split(',')\n\n            service_properties.cors.append(cors_rule)\n\n    # Target version\n    target_version = service_properties_element.find('DefaultServiceVersion')\n    if target_version is not None:\n        service_properties.target_version = target_version.text\n\n    return service_properties", "response": "Convert XML to ServiceProperties."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nadd an insert entity operation to the BatchService.", "response": "def insert_entity(self, entity):\n        '''\n        Adds an insert entity operation to the batch. See \n        :func:`~azure.storage.table.tableservice.TableService.insert_entity` for more \n        information on inserts.\n        \n        The operation will not be executed until the batch is committed.\n\n        :param entity:\n            The entity to insert. Could be a dict or an entity object. \n            Must contain a PartitionKey and a RowKey.\n        :type entity: a dict or :class:`azure.storage.table.models.Entity`\n        '''\n        request = _insert_entity(entity)\n        self._add_to_batch(entity['PartitionKey'], entity['RowKey'], request)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nupdates the metadata of an entity in the table.", "response": "def update_entity(self, entity, if_match='*'):\n        '''\n        Adds an update entity operation to the batch. See \n        :func:`~azure.storage.table.tableservice.TableService.update_entity` for more \n        information on updates.\n        \n        The operation will not be executed until the batch is committed.\n\n        :param entity:\n            The entity to update. Could be a dict or an entity object. \n            Must contain a PartitionKey and a RowKey.\n        :type entity: a dict or :class:`azure.storage.table.models.Entity`\n        :param str if_match:\n            The client may specify the ETag for the entity on the \n            request in order to compare to the ETag maintained by the service \n            for the purpose of optimistic concurrency. The update operation \n            will be performed only if the ETag sent by the client matches the \n            value maintained by the server, indicating that the entity has \n            not been modified since it was retrieved by the client. To force \n            an unconditional update, set If-Match to the wildcard character (*).\n        '''\n        request = _update_entity(entity, if_match)\n        self._add_to_batch(entity['PartitionKey'], entity['RowKey'], request)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding a merge entity operation to the BatchService.", "response": "def merge_entity(self, entity, if_match='*'):\n        '''\n        Adds a merge entity operation to the batch. See \n        :func:`~azure.storage.table.tableservice.TableService.merge_entity` for more \n        information on merges.\n        \n        The operation will not be executed until the batch is committed.\n\n        :param entity:\n            The entity to merge. Could be a dict or an entity object. \n            Must contain a PartitionKey and a RowKey.\n        :type entity: a dict or :class:`azure.storage.table.models.Entity`\n        :param str if_match:\n            The client may specify the ETag for the entity on the \n            request in order to compare to the ETag maintained by the service \n            for the purpose of optimistic concurrency. The merge operation \n            will be performed only if the ETag sent by the client matches the \n            value maintained by the server, indicating that the entity has \n            not been modified since it was retrieved by the client. To force \n            an unconditional merge, set If-Match to the wildcard character (*).\n        '''\n        request = _merge_entity(entity, if_match)\n        self._add_to_batch(entity['PartitionKey'], entity['RowKey'], request)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef insert_or_replace_entity(self, entity):\n        '''\n        Adds an insert or replace entity operation to the batch. See \n        :func:`~azure.storage.table.tableservice.TableService.insert_or_replace_entity` for more \n        information on insert or replace operations.\n\n        The operation will not be executed until the batch is committed.\n\n        :param entity:\n            The entity to insert or replace. Could be a dict or an entity object. \n            Must contain a PartitionKey and a RowKey.\n        :type entity: a dict or :class:`azure.storage.table.models.Entity`\n       '''\n        request = _insert_or_replace_entity(entity)\n        self._add_to_batch(entity['PartitionKey'], entity['RowKey'], request)", "response": "Adds an insert or replace entity operation to the batch."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nadds an insert or merge entity operation to the Batch.", "response": "def insert_or_merge_entity(self, entity):\n        '''\n        Adds an insert or merge entity operation to the batch. See \n        :func:`~azure.storage.table.tableservice.TableService.insert_or_merge_entity` for more \n        information on insert or merge operations.\n\n        The operation will not be executed until the batch is committed.\n\n        :param entity:\n            The entity to insert or merge. Could be a dict or an entity object. \n            Must contain a PartitionKey and a RowKey.\n        :type entity: a dict or :class:`azure.storage.table.models.Entity`\n        '''\n        request = _insert_or_merge_entity(entity)\n        self._add_to_batch(entity['PartitionKey'], entity['RowKey'], request)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nupdate iscsi data :param data: default iscsi config data", "response": "def update_iscsi_settings(self, iscsi_data):\n        \"\"\"Update iscsi data\n\n        :param data: default iscsi config data\n        \"\"\"\n        self._conn.patch(self.path, data=iscsi_data)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef array_controllers(self):\n        return array_controller.HPEArrayControllerCollection(\n            self._conn, utils.get_subresource_path_by(\n                self, ['Links', 'ArrayControllers']),\n            redfish_version=self.redfish_version)", "response": "This property gets the list of instances of array controllers"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef wait_for_operation_to_complete(\n        has_operation_completed, retries=10, delay_bw_retries=5,\n        delay_before_attempts=10, failover_exc=exception.IloError,\n        failover_msg=(\"Operation did not complete even after multiple \"\n                      \"attempts.\"), is_silent_loop_exit=False):\n    \"\"\"Attempts the provided operation for a specified number of times.\n\n    If it runs out of attempts, then it raises an exception. On success,\n    it breaks out of the loop.\n    :param has_operation_completed: the method to retry and it needs to return\n                                    a boolean to indicate success or failure.\n    :param retries: number of times the operation to be (re)tried, default 10\n    :param delay_bw_retries: delay in seconds before attempting after\n                             each failure, default 5.\n    :param delay_before_attempts: delay in seconds before beginning any\n                                  operation attempt, default 10.\n    :param failover_exc: the exception which gets raised in case of failure\n                         upon exhausting all the attempts, default IloError.\n    :param failover_msg: the msg with which the exception gets raised in case\n                         of failure upon exhausting all the attempts.\n    :param is_silent_loop_exit: decides if exception has to be raised (in case\n                                of failure upon exhausting all the attempts)\n                                or not, default False (will be raised).\n    :raises: failover_exc, if failure happens even after all the attempts,\n             default IloError.\n    \"\"\"\n    retry_count = retries\n    # Delay for ``delay_before_attempts`` secs, before beginning any attempt\n    time.sleep(delay_before_attempts)\n\n    while retry_count:\n        try:\n            LOG.debug(\"Calling '%s', retries left: %d\",\n                      has_operation_completed.__name__, retry_count)\n            if has_operation_completed():\n                break\n        except exception.IloError:\n            pass\n        time.sleep(delay_bw_retries)\n        retry_count -= 1\n    else:\n        LOG.debug(\"Max retries exceeded with: '%s'\",\n                  has_operation_completed.__name__)\n        if not is_silent_loop_exit:\n            raise failover_exc(failover_msg)", "response": "Waits until the operation is completed."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_filename_and_extension_of(target_file):\n    base_target_filename = os.path.basename(target_file)\n    file_name, file_ext_with_dot = os.path.splitext(base_target_filename)\n    return file_name, file_ext_with_dot", "response": "Gets the base filename and extension of the target file."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef add_exec_permission_to(target_file):\n    mode = os.stat(target_file).st_mode\n    os.chmod(target_file, mode | stat.S_IXUSR)", "response": "Add executable permissions to the file\n   "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nextract the major and minor number from the passed string", "response": "def get_major_minor(ilo_ver_str):\n    \"\"\"Extract the major and minor number from the passed string\n\n    :param ilo_ver_str: the string that contains the version information\n    :returns: String of the form \"<major>.<minor>\" or None\n    \"\"\"\n    if not ilo_ver_str:\n        return None\n    try:\n        # Note(vmud213):This logic works for all strings\n        # that contain the version info as <major>.<minor>\n        # Formats of the strings:\n        #    Release version ->  \"2.50 Feb 18  2016\"\n        #    Debug version   ->  \"iLO 4 v2.50\"\n        #    random version  ->  \"XYZ ABC 2.30\"\n        pattern = re.search(ILO_VER_STR_PATTERN, ilo_ver_str)\n        if pattern:\n            matched = pattern.group(0)\n            if matched:\n                return matched\n            return None\n    except Exception:\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_supported_boot_modes(supported_boot_mode_constant):\n    boot_mode_bios = 'false'\n    boot_mode_uefi = 'false'\n    if (supported_boot_mode_constant ==\n            constants.SUPPORTED_BOOT_MODE_LEGACY_BIOS_ONLY):\n        boot_mode_bios = 'true'\n    elif (supported_boot_mode_constant ==\n            constants.SUPPORTED_BOOT_MODE_UEFI_ONLY):\n        boot_mode_uefi = 'true'\n    elif (supported_boot_mode_constant ==\n            constants.SUPPORTED_BOOT_MODE_LEGACY_BIOS_AND_UEFI):\n        boot_mode_bios = 'true'\n        boot_mode_uefi = 'true'\n\n    return SupportedBootModes(boot_mode_bios=boot_mode_bios,\n                              boot_mode_uefi=boot_mode_uefi)", "response": "Retrieves the server supported boot modes as a namedtuple containing boot_mode_bios and boot_mode_uefi as true/'false."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _get_key_value(string):\n    # Normally all properties look like this:\n    #   Unique Identifier: 600508B1001CE4ACF473EE9C826230FF\n    #   Disk Name: /dev/sda\n    #   Mount Points: None\n    key = ''\n    value = ''\n    try:\n        key, value = string.split(': ')\n    except ValueError:\n        # This handles the case when the property of a logical drive\n        # returned is as follows. Here we cannot split by ':' because\n        # the disk id has colon in it. So if this is about disk,\n        # then strip it accordingly.\n        #   Mirror Group 0: physicaldrive 6I:1:5\n        string = string.lstrip(' ')\n        if string.startswith('physicaldrive'):\n            fields = string.split(' ')\n            # Include fields[1] to key to avoid duplicate pairs\n            # with the same 'physicaldrive' key\n            key = fields[0] + \" \" + fields[1]\n            value = fields[1]\n        else:\n            # TODO(rameshg87): Check if this ever occurs.\n            return string.strip(' '), None\n\n    return key.strip(' '), value.strip(' ')", "response": "Return the key and value from a string."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nwrapping function for parsing hpssacli command.", "response": "def _convert_to_dict(stdout):\n    \"\"\"Wrapper function for parsing hpssacli/ssacli command.\n\n    This function gets the output from hpssacli/ssacli command\n    and calls the recursive function _get_dict to return\n    the complete dictionary containing the RAID information.\n    \"\"\"\n\n    lines = stdout.split(\"\\n\")\n    lines = list(filter(None, lines))\n    info_dict, j = _get_dict(lines, 0, 0, 0)\n    return info_dict"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nwrap function for executing the ssacli command.", "response": "def _ssacli(*args, **kwargs):\n    \"\"\"Wrapper function for executing hpssacli/ssacli command.\n\n    This function executes ssacli command if it exists, else it\n    falls back to hpssacli.\n    :param args: args to be provided to hpssacli/ssacli command\n    :param kwargs: kwargs to be sent to processutils except the\n        following:\n        - dont_transform_to_hpssa_exception - Set to True if this\n          method shouldn't transform other exceptions to hpssa\n          exceptions only when hpssa controller is available. This is\n          useful when the return code from hpssacli/ssacli is useful for\n          analysis.\n    :returns: a tuple containing the stdout and stderr after running\n        the process.\n    :raises: HPSSAOperationError, if some error was encountered and\n        dont_dont_transform_to_hpssa_exception was set to False.\n    :raises: OSError or processutils.ProcessExecutionError if execution\n        failed and dont_transform_to_hpssa_exception was set to True.\n    \"\"\"\n\n    dont_transform_to_hpssa_exception = kwargs.get(\n        'dont_transform_to_hpssa_exception', False)\n    kwargs.pop('dont_transform_to_hpssa_exception', None)\n\n    try:\n        if os.path.exists(\"/usr/sbin/ssacli\"):\n            stdout, stderr = processutils.execute(\"ssacli\",\n                                                  *args, **kwargs)\n        else:\n            stdout, stderr = processutils.execute(\"hpssacli\",\n                                                  *args, **kwargs)\n    except (OSError, processutils.ProcessExecutionError) as e:\n        if 'No controllers detected' in str(e):\n            msg = (\"SSA controller not found. Enable ssa controller\"\n                   \" to continue with the desired operation\")\n            raise exception.HPSSAOperationError(reason=msg)\n        elif not dont_transform_to_hpssa_exception:\n            raise exception.HPSSAOperationError(reason=e)\n        else:\n            raise\n\n    return stdout, stderr"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nrefreshing the server and it s child objects.", "response": "def refresh(self):\n        \"\"\"Refresh the server and it's child objects.\n\n        This method removes all the cache information in the server\n        and it's child objects, and fetches the information again from\n        the server using hpssacli/ssacli command.\n\n        :raises: HPSSAOperationError, if hpssacli/ssacli operation failed.\n        \"\"\"\n        config = self._get_all_details()\n\n        raid_info = _convert_to_dict(config)\n        self.controllers = []\n\n        for key, value in raid_info.items():\n            self.controllers.append(Controller(key, value, self))\n\n        self.last_updated = time.time()"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_controller_by_id(self, id):\n        for controller in self.controllers:\n            if controller.id == id:\n                return controller\n        return None", "response": "Get the controller object given the id."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_logical_drives(self):\n        logical_drives = []\n        for controller in self.controllers:\n            for array in controller.raid_arrays:\n                for logical_drive in array.logical_drives:\n                    logical_drives.append(logical_drive)\n        return logical_drives", "response": "Get all the RAID logical drives in the Server."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_physical_drives(self):\n        physical_drives = []\n        for controller in self.controllers:\n            # First add unassigned physical drives.\n            for physical_drive in controller.unassigned_physical_drives:\n                physical_drives.append(physical_drive)\n            # Now add physical drives part of RAID arrays.\n            for array in controller.raid_arrays:\n                for physical_drive in array.physical_drives:\n                    physical_drives.append(physical_drive)\n\n        return physical_drives", "response": "Get all the RAID physical drives on the Server."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the logical drive object given the wwn. This method returns the logical drive object with the given wwn. :param wwn: wwn of the logical drive :returns: LogicalDrive object which has the wwn or None if logical drive is not found.", "response": "def get_logical_drive_by_wwn(self, wwn):\n        \"\"\"Get the logical drive object given the wwn.\n\n        This method returns the logical drive object with the given wwn.\n\n        :param wwn: wwn of the logical drive\n        :returns: LogicalDrive object which has the wwn or None if\n            logical drive is not found.\n        \"\"\"\n        disk = [x for x in self.get_logical_drives() if x.wwn == wwn]\n        if disk:\n            return disk[0]\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_physical_drive_by_id(self, id):\n        for phy_drive in self.unassigned_physical_drives:\n            if phy_drive.id == id:\n                return phy_drive\n        for array in self.raid_arrays:\n            for phy_drive in array.physical_drives:\n                if phy_drive.id == id:\n                    return phy_drive\n        return None", "response": "Get a PhysicalDrive object for given id."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nexecute a given hpssacli command on the controller.", "response": "def execute_cmd(self, *args, **kwargs):\n        \"\"\"Execute a given hpssacli/ssacli command on the controller.\n\n        This method executes a given command on the controller.\n\n        :params args: a tuple consisting of sub-commands to be appended\n            after specifying the controller in hpssacli/ssacli command.\n        :param kwargs: kwargs to be passed to execute() in processutils\n        :raises: HPSSAOperationError, if hpssacli/ssacli operation failed.\n        \"\"\"\n        slot = self.properties['Slot']\n        base_cmd = (\"controller\", \"slot=%s\" % slot)\n        cmd = base_cmd + args\n        return _ssacli(*cmd, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates a logical drive on the controller. This method creates a logical drive on the controller when the logical drive details and physical drive ids are passed to it. :param logical_drive_info: a dictionary containing the details of the logical drive as specified in raid config. :raises: HPSSAOperationError, if hpssacli/ssacli operation failed.", "response": "def create_logical_drive(self, logical_drive_info):\n        \"\"\"Create a logical drive on the controller.\n\n        This method creates a logical drive on the controller when the\n        logical drive details and physical drive ids are passed to it.\n\n        :param logical_drive_info: a dictionary containing the details\n            of the logical drive as specified in raid config.\n        :raises: HPSSAOperationError, if hpssacli/ssacli operation failed.\n        \"\"\"\n        cmd_args = []\n        if 'array' in logical_drive_info:\n            cmd_args.extend(['array', logical_drive_info['array']])\n\n        cmd_args.extend(['create', \"type=logicaldrive\"])\n\n        if 'physical_disks' in logical_drive_info:\n            phy_drive_ids = ','.join(logical_drive_info['physical_disks'])\n            cmd_args.append(\"drives=%s\" % phy_drive_ids)\n\n        raid_level = logical_drive_info['raid_level']\n        # For RAID levels (like 5+0 and 6+0), HPSSA names them differently.\n        # Check if we have mapping stored, otherwise use the same.\n        raid_level = constants.RAID_LEVEL_INPUT_TO_HPSSA_MAPPING.get(\n            raid_level, raid_level)\n        cmd_args.append(\"raid=%s\" % raid_level)\n\n        # If size_gb is MAX, then don't pass size argument.  HPSSA will\n        # automatically allocate the maximum # disks size possible to the\n        # logical disk.\n        if logical_drive_info['size_gb'] != \"MAX\":\n            size_mb = logical_drive_info['size_gb'] * 1024\n            cmd_args.append(\"size=%s\" % size_mb)\n\n        self.execute_cmd(*cmd_args, process_input='y')"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the command arguments based on the pattern.", "response": "def _get_erase_command(self, drive, pattern):\n        \"\"\"Return the command arguments based on the pattern.\n\n        Erase command examples:\n        1) Sanitize: \"ssacli ctrl slot=0 pd 1I:1:1 modify erase\n                      erasepattern=overwrite unrestricted=off forced\"\n        2) Zeros: \"ssacli ctrl slot=0 pd 1I:1:1 modify erase\n                   erasepattern=zero forced\"\n\n        :param drive: A string with comma separated list of drives.\n        :param pattern: A string which defines the type of erase.\n        :returns: A list of ssacli command arguments.\n        \"\"\"\n        cmd_args = []\n        cmd_args.append(\"pd %s\" % drive)\n        cmd_args.extend(['modify', 'erase', pattern])\n\n        if pattern != 'erasepattern=zero':\n            cmd_args.append('unrestricted=off')\n\n        cmd_args.append('forced')\n        return cmd_args"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nerase all the HDD and SSD drives in the controller.", "response": "def erase_devices(self, drives):\n        \"\"\"Perform Erase on all the drives in the controller.\n\n        This method erases all the hdd and ssd drives in the controller\n        by overwriting the drives with patterns for hdd and erasing storage\n        blocks for ssd drives. The drives would be unavailable until\n        successful completion or failure of erase operation.\n\n        If the sanitize erase is not supported on any disk it will try to\n        populate zeros on disk drives.\n\n        :param drives: A list of drive objects in the controller.\n        :raises: HPSSAOperationError, if sanitize erase is not supported.\n        \"\"\"\n        for drive in drives:\n            pattern = 'overwrite' if (\n                drive.disk_type == constants.DISK_TYPE_HDD) else 'block'\n            cmd_args = self._get_erase_command(\n                drive.id, 'erasepattern=%s' % pattern)\n            stdout = self.execute_cmd(*cmd_args)\n            LOG.debug(\"Sanitize disk erase invoked with erase pattern as \"\n                      \"'%(pattern)s' on disk type: %(disk_type)s.\"\n                      % {'pattern': pattern, 'disk_type': drive.disk_type})\n\n            if \"not supported\" in str(stdout):\n                new_pattern = 'zero'\n                cmd_args = self._get_erase_command(drive.id,\n                                                   'erasepattern=zero')\n                self.execute_cmd(*cmd_args)\n                LOG.debug(\"Sanitize disk erase invoked with erase pattern as \"\n                          \"'%(pattern)s' is not supported on disk type: \"\n                          \"%(disk_type)s. Now its invoked with erase pattern \"\n                          \"as %(new_pattern)s.\"\n                          % {'pattern': pattern, 'disk_type': drive.disk_type,\n                             'new_pattern': new_pattern})"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef can_accomodate(self, logical_disk):\n        raid_level = constants.RAID_LEVEL_INPUT_TO_HPSSA_MAPPING.get(\n            logical_disk['raid_level'], logical_disk['raid_level'])\n        args = (\"array\", self.id, \"create\", \"type=logicaldrive\",\n                \"raid=%s\" % raid_level, \"size=?\")\n\n        if logical_disk['size_gb'] != \"MAX\":\n            desired_disk_size = logical_disk['size_gb']\n        else:\n            desired_disk_size = constants.MINIMUM_DISK_SIZE\n\n        try:\n            stdout, stderr = self.parent.execute_cmd(\n                *args, dont_transform_to_hpssa_exception=True)\n        except processutils.ProcessExecutionError as ex:\n            # hpssacli/ssacli returns error code 1 when RAID level of the\n            # logical disk is not supported on the array.\n            # If that's the case, just return saying the logical disk\n            # cannot be accomodated in the array.\n            # If exist_code is not 1, then it's some other error that we\n            # don't expect to appear and hence raise it back.\n            if ex.exit_code == 1:\n                return False\n            else:\n                raise exception.HPSSAOperationError(reason=ex)\n        except Exception as ex:\n            raise exception.HPSSAOperationError(reason=ex)\n\n        # TODO(rameshg87): This always returns in MB, but confirm with\n        # HPSSA folks.\n        match = re.search('Max: (\\d+)', stdout)\n        if not match:\n            return False\n\n        max_size_gb = int(match.group(1)) / 1024\n        return desired_disk_size <= max_size_gb", "response": "Check if this RAID array can accomodate the logical disk."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_physical_drive_dict(self):\n\n        if isinstance(self.parent, RaidArray):\n            controller = self.parent.parent.id\n            status = 'active'\n        else:\n            controller = self.parent.id\n            status = 'ready'\n\n        return {'size_gb': self.size_gb,\n                'controller': controller,\n                'id': self.id,\n                'disk_type': self.disk_type,\n                'interface_type': self.interface_type,\n                'model': self.model,\n                'firmware': self.firmware,\n                'status': status,\n                'erase_status': self.erase_status}", "response": "Returns a dictionary of with the details of the physical drive."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the set of raid levels for each logical volume", "response": "def logical_raid_levels(self):\n        \"\"\"Gets the raid level for each logical volume\n\n        :returns the set of list of raid levels configured.\n        \"\"\"\n        lg_raid_lvls = set()\n        for member in self.get_members():\n            lg_raid_lvls.add(mappings.RAID_LEVEL_MAP_REV.get(member.raid))\n        return lg_raid_lvls"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsends a file to the client.", "response": "def send_stream(stream, filename, size, mtime, mimetype=None, restricted=True,\n                as_attachment=False, etag=None, content_md5=None,\n                chunk_size=None, conditional=True, trusted=False):\n    \"\"\"Send the contents of a file to the client.\n\n    .. warning::\n\n        It is very easy to be exposed to Cross-Site Scripting (XSS) attacks if\n        you serve user uploaded files. Here are some recommendations:\n\n            1. Serve user uploaded files from a separate domain\n               (not a subdomain). This way a malicious file can only attack\n               other user uploaded files.\n            2. Prevent the browser from rendering and executing HTML files (by\n               setting ``trusted=False``).\n            3. Force the browser to download the file as an attachment\n               (``as_attachment=True``).\n\n    :param stream: The file stream to send.\n    :param filename: The file name.\n    :param size: The file size.\n    :param mtime: A Unix timestamp that represents last modified time (UTC).\n    :param mimetype: The file mimetype. If ``None``, the module will try to\n        guess. (Default: ``None``)\n    :param restricted: If the file is not restricted, the module will set the\n        cache-control. (Default: ``True``)\n    :param as_attachment: If the file is an attachment. (Default: ``False``)\n    :param etag: If defined, it will be set as HTTP E-Tag.\n    :param content_md5: If defined, a HTTP Content-MD5 header will be set.\n    :param chunk_size: The chunk size.\n    :param conditional: Make the response conditional to the request.\n        (Default: ``True``)\n    :param trusted: Do not enable this option unless you know what you are\n        doing. By default this function will send HTTP headers and MIME types\n        that prevents your browser from rendering e.g. a HTML file which could\n        contain a malicious script tag.\n        (Default: ``False``)\n    :returns: A Flask response instance.\n    \"\"\"\n    chunk_size = chunk_size_or_default(chunk_size)\n\n    # Guess mimetype from filename if not provided.\n    if mimetype is None and filename:\n        mimetype = mimetypes.guess_type(filename)[0]\n    if mimetype is None:\n        mimetype = 'application/octet-stream'\n\n    # Construct headers\n    headers = Headers()\n    headers['Content-Length'] = size\n    if content_md5:\n        headers['Content-MD5'] = content_md5\n\n    if not trusted:\n        # Sanitize MIME type\n        mimetype = sanitize_mimetype(mimetype, filename=filename)\n        # See https://www.owasp.org/index.php/OWASP_Secure_Headers_Project\n        # Prevent JavaScript execution\n        headers['Content-Security-Policy'] = \"default-src 'none';\"\n        # Prevent MIME type sniffing for browser.\n        headers['X-Content-Type-Options'] = 'nosniff'\n        # Prevent opening of downloaded file by IE\n        headers['X-Download-Options'] = 'noopen'\n        # Prevent cross domain requests from Flash/Acrobat.\n        headers['X-Permitted-Cross-Domain-Policies'] = 'none'\n        # Prevent files from being embedded in frame, iframe and object tags.\n        headers['X-Frame-Options'] = 'deny'\n        # Enable XSS protection (IE, Chrome, Safari)\n        headers['X-XSS-Protection'] = '1; mode=block'\n\n    # Force Content-Disposition for application/octet-stream to prevent\n    # Content-Type sniffing.\n    if as_attachment or mimetype == 'application/octet-stream':\n        # See https://github.com/pallets/flask/commit/0049922f2e690a6d\n        try:\n            filenames = {'filename': filename.encode('latin-1')}\n        except UnicodeEncodeError:\n            filenames = {'filename*': \"UTF-8''%s\" % url_quote(filename)}\n            encoded_filename = (unicodedata.normalize('NFKD', filename)\n                                .encode('latin-1', 'ignore'))\n            if encoded_filename:\n                filenames['filename'] = encoded_filename\n        headers.add('Content-Disposition', 'attachment', **filenames)\n    else:\n        headers.add('Content-Disposition', 'inline')\n\n    # Construct response object.\n    rv = current_app.response_class(\n        FileWrapper(stream, buffer_size=chunk_size),\n        mimetype=mimetype,\n        headers=headers,\n        direct_passthrough=True,\n    )\n\n    # Set etag if defined\n    if etag:\n        rv.set_etag(etag)\n\n    # Set last modified time\n    if mtime is not None:\n        rv.last_modified = int(mtime)\n\n    # Set cache-control\n    if not restricted:\n        rv.cache_control.public = True\n        cache_timeout = current_app.get_send_file_max_age(filename)\n        if cache_timeout is not None:\n            rv.cache_control.max_age = cache_timeout\n            rv.expires = int(time() + cache_timeout)\n\n    if conditional:\n        rv = rv.make_conditional(request)\n\n    return rv"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsanitizing a MIME type so the browser does not render the file.", "response": "def sanitize_mimetype(mimetype, filename=None):\n    \"\"\"Sanitize a MIME type so the browser does not render the file.\"\"\"\n    # Allow some few mime type like plain text, images and audio.\n    if mimetype in MIMETYPE_WHITELIST:\n        return mimetype\n    # Rewrite HTML, JavaScript, CSS etc to text/plain.\n    if mimetype in MIMETYPE_PLAINTEXT or \\\n            (filename and filename.lower() in MIMETYPE_TEXTFILES):\n        return 'text/plain'\n    # Default\n    return 'application/octet-stream'"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef make_path(base_uri, path, filename, path_dimensions, split_length):\n    assert len(path) > path_dimensions * split_length\n\n    uri_parts = []\n    for i in range(path_dimensions):\n        uri_parts.append(path[0:split_length])\n        path = path[split_length:]\n    uri_parts.append(path)\n    uri_parts.append(filename)\n\n    return os.path.join(base_uri, *uri_parts)", "response": "Generates a path as base location for a file instance."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncomputes checksum from a file - like object.", "response": "def compute_checksum(stream, algo, message_digest, chunk_size=None,\n                     progress_callback=None):\n    \"\"\"Get helper method to compute checksum from a stream.\n\n    :param stream: File-like object.\n    :param algo: Identifier for checksum algorithm.\n    :param messsage_digest: A message digest instance.\n    :param chunk_size: Read at most size bytes from the file at a time.\n    :param progress_callback: Function accepting one argument with number\n        of bytes read. (Default: ``None``)\n    :returns: The checksum.\n    \"\"\"\n    chunk_size = chunk_size_or_default(chunk_size)\n\n    bytes_read = 0\n    while 1:\n        chunk = stream.read(chunk_size)\n        if not chunk:\n            if progress_callback:\n                progress_callback(bytes_read)\n            break\n        message_digest.update(chunk)\n        bytes_read += len(chunk)\n        if progress_callback:\n            progress_callback(bytes_read)\n    return \"{0}:{1}\".format(algo, message_digest.hexdigest())"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef populate_from_path(bucket, source, checksum=True, key_prefix='',\n                       chunk_size=None):\n    \"\"\"Populate a ``bucket`` from all files in path.\n\n    :param bucket: The bucket (instance or id) to create the object in.\n    :param source: The file or directory path.\n    :param checksum: If ``True`` then a MD5 checksum will be computed for each\n        file. (Default: ``True``)\n    :param key_prefix: The key prefix for the bucket.\n    :param chunk_size: Chunk size to read from file.\n    :returns: A iterator for all\n        :class:`invenio_files_rest.models.ObjectVersion` instances.\n    \"\"\"\n    from .models import FileInstance, ObjectVersion\n\n    def create_file(key, path):\n        \"\"\"Create new ``ObjectVersion`` from path or existing ``FileInstance``.\n\n        It checks MD5 checksum and size of existing ``FileInstance``s.\n        \"\"\"\n        key = key_prefix + key\n\n        if checksum:\n            file_checksum = compute_md5_checksum(\n                    open(path, 'rb'), chunk_size=chunk_size)\n            file_instance = FileInstance.query.filter_by(\n                checksum=file_checksum, size=os.path.getsize(path)\n            ).first()\n            if file_instance:\n                return ObjectVersion.create(\n                    bucket, key, _file_id=file_instance.id\n                )\n        return ObjectVersion.create(bucket, key, stream=open(path, 'rb'))\n\n    if os.path.isfile(source):\n        yield create_file(os.path.basename(source), source)\n    else:\n        for root, dirs, files in os.walk(source, topdown=False):\n            for name in files:\n                filename = os.path.join(root, name)\n                assert filename.startswith(source)\n                parts = [p for p in filename[len(source):].split(os.sep) if p]\n                yield create_file('/'.join(parts), os.path.join(root, name))", "response": "Populate a list of objects from a file or directory path."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset instance variables based on an options dict.", "response": "def set_options(self, options):\n        \"\"\"\n        Sets instance variables based on an options dict\n        \"\"\"\n        # COMMAND LINE OPTIONS\n        self.wipe = options.get(\"wipe\")\n        self.test_run = options.get(\"test_run\")\n        self.quiet = options.get(\"test_run\")\n        self.container_name = options.get(\"container\")\n        self.verbosity = int(options.get(\"verbosity\"))\n        self.syncmedia = options.get(\"syncmedia\")\n        self.syncstatic = options.get(\"syncstatic\")\n        if self.test_run:\n            self.verbosity = 2\n        cli_includes = options.get(\"includes\")\n        cli_excludes = options.get(\"excludes\")\n\n        # CUMULUS CONNECTION AND SETTINGS FROM SETTINGS.PY\n        if self.syncmedia and self.syncstatic:\n            raise CommandError(\"options --media and --static are mutually exclusive\")\n        if not self.container_name:\n            if self.syncmedia:\n                self.container_name = CUMULUS[\"CONTAINER\"]\n            elif self.syncstatic:\n                self.container_name = CUMULUS[\"STATIC_CONTAINER\"]\n            else:\n                raise CommandError(\"must select one of the required options, either --media or --static\")\n        settings_includes = CUMULUS[\"INCLUDE_LIST\"]\n        settings_excludes = CUMULUS[\"EXCLUDE_LIST\"]\n\n        # PATH SETTINGS\n        if self.syncmedia:\n            self.file_root = os.path.abspath(settings.MEDIA_ROOT)\n            self.file_url = settings.MEDIA_URL\n        elif self.syncstatic:\n            self.file_root = os.path.abspath(settings.STATIC_ROOT)\n            self.file_url = settings.STATIC_URL\n        if not self.file_root.endswith(\"/\"):\n            self.file_root = self.file_root + \"/\"\n        if self.file_url.startswith(\"/\"):\n            self.file_url = self.file_url[1:]\n\n        # SYNCSTATIC VARS\n        # combine includes and excludes from the cli and django settings file\n        self.includes = list(set(cli_includes + settings_includes))\n        self.excludes = list(set(cli_excludes + settings_excludes))\n        # transform glob patterns to regular expressions\n        self.local_filenames = []\n        self.create_count = 0\n        self.upload_count = 0\n        self.update_count = 0\n        self.skip_count = 0\n        self.delete_count = 0"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the cloud objects that match the include and exclude patterns.", "response": "def match_cloud(self, includes, excludes):\n        \"\"\"\n        Returns the cloud objects that match the include and exclude patterns.\n        \"\"\"\n        cloud_objs = [cloud_obj.name for cloud_obj in self.container.get_objects()]\n        includes_pattern = r\"|\".join([fnmatch.translate(x) for x in includes])\n        excludes_pattern = r\"|\".join([fnmatch.translate(x) for x in excludes]) or r\"$.\"\n        excludes = [o for o in cloud_objs if re.match(excludes_pattern, o)]\n        includes = [o for o in cloud_objs if re.match(includes_pattern, o)]\n        return [o for o in includes if o not in excludes]"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef upload_files(self, abspaths, relpaths, remote_objects):\n        for relpath in relpaths:\n            abspath = [p for p in abspaths if p[len(self.file_root):] == relpath][0]\n            cloud_datetime = remote_objects[relpath] if relpath in remote_objects else None\n            local_datetime = datetime.datetime.utcfromtimestamp(os.stat(abspath).st_mtime)\n\n            if cloud_datetime and local_datetime < cloud_datetime:\n                self.skip_count += 1\n                if not self.quiet:\n                    print(\"Skipped {0}: not modified.\".format(relpath))\n                continue\n            if relpath in remote_objects:\n                self.update_count += 1\n            else:\n                self.create_count += 1\n            self.upload_file(abspath, relpath)", "response": "Determines files to be uploaded and call upload_file on each."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nuploading a file to the container.", "response": "def upload_file(self, abspath, cloud_filename):\n        \"\"\"\n        Uploads a file to the container.\n        \"\"\"\n        if not self.test_run:\n            content = open(abspath, \"rb\")\n            content_type = get_content_type(cloud_filename, content)\n            headers = get_headers(cloud_filename, content_type)\n\n            if headers.get(\"Content-Encoding\") == \"gzip\":\n                content = get_gzipped_contents(content)\n                size = content.size\n            else:\n                size = os.stat(abspath).st_size\n            self.container.create(\n                obj_name=cloud_filename,\n                data=content,\n                content_type=content_type,\n                content_length=size,\n                content_encoding=headers.get(\"Content-Encoding\", None),\n                headers=headers,\n                ttl=CUMULUS[\"FILE_TTL\"],\n                etag=None,\n            )\n\n        self.upload_count += 1\n        if not self.quiet or self.verbosity > 1:\n            print(\"Uploaded: {0}\".format(cloud_filename))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ndeleting any extra files from the container that do not exist locally.", "response": "def delete_extra_files(self, relpaths, cloud_objs):\n        \"\"\"\n        Deletes any objects from the container that do not exist locally.\n        \"\"\"\n        for cloud_obj in cloud_objs:\n            if cloud_obj not in relpaths:\n                if not self.test_run:\n                    self.delete_cloud_obj(cloud_obj)\n                self.delete_count += 1\n                if not self.quiet or self.verbosity > 1:\n                    print(\"Deleted: {0}\".format(cloud_obj))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef delete_cloud_obj(self, cloud_obj):\n        self._connection.delete_object(\n            container=self.container_name,\n            obj=cloud_obj,\n        )", "response": "Deletes an object from the container."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nprinting the final tally to stdout.", "response": "def print_tally(self):\n        \"\"\"\n        Prints the final tally to stdout.\n        \"\"\"\n        self.update_count = self.upload_count - self.create_count\n        if self.test_run:\n            print(\"Test run complete with the following results:\")\n        print(\"Skipped {0}. Created {1}. Updated {2}. Deleted {3}.\".format(\n            self.skip_count, self.create_count, self.update_count, self.delete_count))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nlisting all the items in a container to stdout.", "response": "def handle(self, *args, **options):\n        \"\"\"\n        Lists all the items in a container to stdout.\n        \"\"\"\n        self._connection = Auth()._get_connection()\n\n        if len(args) == 0:\n            containers = self._connection.list_containers()\n            if not containers:\n                print(\"No containers were found for this account.\")\n        elif len(args) == 1:\n            containers = self._connection.list_container_object_names(args[0])\n            if not containers:\n                print(\"No matching container found.\")\n        else:\n            raise CommandError(\"Pass one and only one [container_name] as an argument\")\n\n        for container in containers:\n            print(container)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nprogress reporter for checksum verification.", "response": "def progress_updater(size, total):\n    \"\"\"Progress reporter for checksum verification.\"\"\"\n    current_task.update_state(\n        state=state('PROGRESS'),\n        meta=dict(size=size, total=total)\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef verify_checksum(file_id, pessimistic=False, chunk_size=None, throws=True,\n                    checksum_kwargs=None):\n    \"\"\"Verify checksum of a file instance.\n\n    :param file_id: The file ID.\n    \"\"\"\n    f = FileInstance.query.get(uuid.UUID(file_id))\n\n    # Anything might happen during the task, so being pessimistic and marking\n    # the file as unchecked is a reasonable precaution\n    if pessimistic:\n        f.clear_last_check()\n        db.session.commit()\n    f.verify_checksum(\n        progress_callback=progress_updater, chunk_size=chunk_size,\n        throws=throws, checksum_kwargs=checksum_kwargs)\n    db.session.commit()", "response": "Verify checksum of a file instance."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nschedule a batch of files for checksum verification.", "response": "def schedule_checksum_verification(frequency=None, batch_interval=None,\n                                   max_count=None, max_size=None,\n                                   files_query=None,\n                                   checksum_kwargs=None):\n    \"\"\"Schedule a batch of files for checksum verification.\n\n    The purpose of this task is to be periodically called through `celerybeat`,\n    in order achieve a repeated verification cycle of all file checksums, while\n    following a set of constraints in order to throttle the execution rate of\n    the checks.\n\n    :param dict frequency: Time period over which a full check of all files\n        should be performed. The argument is a dictionary that will be passed\n        as arguments to the `datetime.timedelta` class. Defaults to a month (30\n        days).\n    :param dict batch_interval: How often a batch is sent. If not supplied,\n        this information will be extracted, if possible, from the\n        celery.conf['CELERYBEAT_SCHEDULE'] entry of this task. The argument is\n        a dictionary that will be passed as arguments to the\n        `datetime.timedelta` class.\n    :param int max_count: Max count of files of a single batch. When set to `0`\n        it's automatically calculated to be distributed equally through the\n        number of total batches.\n    :param int max_size: Max size of a single batch in bytes. When set to `0`\n        it's automatically calculated to be distributed equally through the\n        number of total batches.\n    :param str files_query: Import path for a function returning a\n        FileInstance query for files that should be checked.\n    :param dict checksum_kwargs: Passed to ``FileInstance.verify_checksum``.\n    \"\"\"\n    assert max_count is not None or max_size is not None\n    frequency = timedelta(**frequency) if frequency else timedelta(days=30)\n    if batch_interval:\n        batch_interval = timedelta(**batch_interval)\n    else:\n        celery_schedule = current_celery.conf.get('CELERYBEAT_SCHEDULE', {})\n        batch_interval = batch_interval or next(\n            (v['schedule'] for v in celery_schedule.values()\n             if v.get('task') == schedule_checksum_verification.name), None)\n    if not batch_interval or not isinstance(batch_interval, timedelta):\n        raise Exception(u'No \"batch_interval\" could be decided')\n\n    total_batches = int(\n        frequency.total_seconds() / batch_interval.total_seconds())\n\n    files = obj_or_import_string(\n        files_query, default=default_checksum_verification_files_query)()\n    files = files.order_by(\n        sa.func.coalesce(FileInstance.last_check_at, date.min))\n\n    if max_count is not None:\n        all_files_count = files.count()\n        min_count = int(math.ceil(all_files_count / total_batches))\n        max_count = min_count if max_count == 0 else max_count\n        if max_count < min_count:\n            current_app.logger.warning(\n                 u'The \"max_count\" you specified ({0}) is smaller than the '\n                 'minimum batch file count required ({1}) in order to achieve '\n                 'the file checks over the specified period ({2}).'\n                 .format(max_count, min_count, frequency))\n        files = files.limit(max_count)\n\n    if max_size is not None:\n        all_files_size = db.session.query(\n            sa.func.sum(FileInstance.size)).scalar()\n        min_size = int(math.ceil(all_files_size / total_batches))\n        max_size = min_size if max_size == 0 else max_size\n        if max_size < min_size:\n            current_app.logger.warning(\n                 u'The \"max_size\" you specified ({0}) is smaller than the '\n                 'minimum batch total file size required ({1}) in order to '\n                 'achieve the file checks over the specified period ({2}).'\n                 .format(max_size, min_size, frequency))\n\n    files = files.yield_per(1000)\n    scheduled_file_ids = []\n    total_size = 0\n    for f in files:\n        # Add at least the first file, since it might be larger than \"max_size\"\n        scheduled_file_ids.append(str(f.id))\n        total_size += f.size\n        if max_size and max_size <= total_size:\n            break\n    group(\n        verify_checksum.s(\n            file_id, pessimistic=True, throws=False,\n            checksum_kwargs=(checksum_kwargs or {}))\n        for file_id in scheduled_file_ids\n    ).apply_async()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ntask to migrate a file instance to a new location. .. note:: If something goes wrong during the content copy, the destination file instance is removed. :param src_id: The :class:`invenio_files_rest.models.FileInstance` ID. :param location_name: Where to migrate the file. :param post_fixity_check: Verify checksum after migration. (Default: ``False``)", "response": "def migrate_file(src_id, location_name, post_fixity_check=False):\n    \"\"\"Task to migrate a file instance to a new location.\n\n    .. note:: If something goes wrong during the content copy, the destination\n        file instance is removed.\n\n    :param src_id: The :class:`invenio_files_rest.models.FileInstance` ID.\n    :param location_name: Where to migrate the file.\n    :param post_fixity_check: Verify checksum after migration.\n        (Default: ``False``)\n    \"\"\"\n    location = Location.get_by_name(location_name)\n    f_src = FileInstance.get(src_id)\n\n    # Create destination\n    f_dst = FileInstance.create()\n    db.session.commit()\n\n    try:\n        # Copy contents\n        f_dst.copy_contents(\n            f_src,\n            progress_callback=progress_updater,\n            default_location=location.uri,\n        )\n        db.session.commit()\n    except Exception:\n        # Remove destination file instance if an error occurred.\n        db.session.delete(f_dst)\n        db.session.commit()\n        raise\n\n    # Update all objects pointing to file.\n    ObjectVersion.relink_all(f_src, f_dst)\n    db.session.commit()\n\n    # Start a fixity check\n    if post_fixity_check:\n        verify_checksum.delay(str(f_dst.id))"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nremoves the file instance and associated data.", "response": "def remove_file_data(file_id, silent=True):\n    \"\"\"Remove file instance and associated data.\n\n    :param file_id: The :class:`invenio_files_rest.models.FileInstance` ID.\n    :param silent: It stops propagation of a possible arised IntegrityError\n        exception. (Default: ``True``)\n    :raises sqlalchemy.exc.IntegrityError: Raised if the database removal goes\n        wrong and silent is set to ``False``.\n    \"\"\"\n    try:\n        # First remove FileInstance from database and commit transaction to\n        # ensure integrity constraints are checked and enforced.\n        f = FileInstance.get(file_id)\n        if not f.writable:\n            return\n        f.delete()\n        db.session.commit()\n        # Next, remove the file on disk. This leaves the possibility of having\n        # a file on disk dangling in case the database removal works, and the\n        # disk file removal doesn't work.\n        f.storage().delete()\n    except IntegrityError:\n        if not silent:\n            raise"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef merge_multipartobject(upload_id, version_id=None):\n    mp = MultipartObject.query.filter_by(upload_id=upload_id).one_or_none()\n    if not mp:\n        raise RuntimeError('Upload ID does not exists.')\n    if not mp.completed:\n        raise RuntimeError('MultipartObject is not completed.')\n\n    try:\n        obj = mp.merge_parts(\n            version_id=version_id,\n            progress_callback=progress_updater\n        )\n        db.session.commit()\n        return str(obj.version_id)\n    except Exception:\n        db.session.rollback()\n        raise", "response": "Merge a multipart object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef remove_expired_multipartobjects():\n    delta = current_app.config['FILES_REST_MULTIPART_EXPIRES']\n    expired_dt = datetime.utcnow() - delta\n\n    file_ids = []\n    for mp in MultipartObject.query_expired(expired_dt):\n        file_ids.append(str(mp.file_id))\n        mp.delete()\n\n    for fid in file_ids:\n        remove_file_data.delay(fid)", "response": "Remove expired multipart objects."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef pyfs_storage_factory(fileinstance=None, default_location=None,\n                         default_storage_class=None,\n                         filestorage_class=PyFSFileStorage, fileurl=None,\n                         size=None, modified=None, clean_dir=True):\n    \"\"\"Get factory function for creating a PyFS file storage instance.\"\"\"\n    # Either the FileInstance needs to be specified or all filestorage\n    # class parameters need to be specified\n    assert fileinstance or (fileurl and size)\n\n    if fileinstance:\n        # FIXME: Code here should be refactored since it assumes a lot on the\n        # directory structure where the file instances are written\n        fileurl = None\n        size = fileinstance.size\n        modified = fileinstance.updated\n\n        if fileinstance.uri:\n            # Use already existing URL.\n            fileurl = fileinstance.uri\n        else:\n            assert default_location\n            # Generate a new URL.\n            fileurl = make_path(\n                default_location,\n                str(fileinstance.id),\n                'data',\n                current_app.config['FILES_REST_STORAGE_PATH_DIMENSIONS'],\n                current_app.config['FILES_REST_STORAGE_PATH_SPLIT_LENGTH'],\n            )\n\n    return filestorage_class(\n        fileurl, size=size, modified=modified, clean_dir=clean_dir)", "response": "Returns a factory function for creating a PyFS file storage instance."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _get_fs(self, create_dir=True):\n        filedir = dirname(self.fileurl)\n        filename = basename(self.fileurl)\n\n        return (\n            opener.opendir(filedir, writeable=True, create_dir=create_dir),\n            filename\n        )", "response": "Return tuple with filesystem and filename."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nopens file. The caller is responsible for closing the file.", "response": "def open(self, mode='rb'):\n        \"\"\"Open file.\n\n        The caller is responsible for closing the file.\n        \"\"\"\n        fs, path = self._get_fs()\n        return fs.open(path, mode=mode)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ndelete a file. The base directory is also removed, as it is assumed that only one file exists in the directory.", "response": "def delete(self):\n        \"\"\"Delete a file.\n\n        The base directory is also removed, as it is assumed that only one file\n        exists in the directory.\n        \"\"\"\n        fs, path = self._get_fs(create_dir=False)\n        if fs.exists(path):\n            fs.remove(path)\n        if self.clean_dir and fs.exists('.'):\n            fs.removedir('.')\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ninitializing file on storage and truncate to given size.", "response": "def initialize(self, size=0):\n        \"\"\"Initialize file on storage and truncate to given size.\"\"\"\n        fs, path = self._get_fs()\n\n        # Required for reliably opening the file on certain file systems:\n        if fs.exists(path):\n            fp = fs.open(path, mode='r+b')\n        else:\n            fp = fs.open(path, mode='wb')\n\n        try:\n            fp.truncate(size)\n        except Exception:\n            fp.close()\n            self.delete()\n            raise\n        finally:\n            fp.close()\n\n        self._size = size\n\n        return self.fileurl, size, None"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsaving file in the file system.", "response": "def save(self, incoming_stream, size_limit=None, size=None,\n             chunk_size=None, progress_callback=None):\n        \"\"\"Save file in the file system.\"\"\"\n        fp = self.open(mode='wb')\n        try:\n            bytes_written, checksum = self._write_stream(\n                incoming_stream, fp, chunk_size=chunk_size,\n                progress_callback=progress_callback,\n                size_limit=size_limit, size=size)\n        except Exception:\n            fp.close()\n            self.delete()\n            raise\n        finally:\n            fp.close()\n\n        self._size = bytes_written\n\n        return self.fileurl, bytes_written, checksum"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nupdate a file in the file system.", "response": "def update(self, incoming_stream, seek=0, size=None, chunk_size=None,\n               progress_callback=None):\n        \"\"\"Update a file in the file system.\"\"\"\n        fp = self.open(mode='r+b')\n        try:\n            fp.seek(seek)\n            bytes_written, checksum = self._write_stream(\n                incoming_stream, fp, chunk_size=chunk_size,\n                size=size, progress_callback=progress_callback)\n        finally:\n            fp.close()\n\n        return bytes_written, checksum"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets default permission factory.", "response": "def permission_factory(obj, action):\n    \"\"\"Get default permission factory.\n\n    :param obj: An instance of :class:`invenio_files_rest.models.Bucket` or\n        :class:`invenio_files_rest.models.ObjectVersion` or\n        :class:`invenio_files_rest.models.MultipartObject` or ``None`` if\n        the action is global.\n    :param action: The required action.\n    :raises RuntimeError: If the object is unknown.\n    :returns: A :class:`invenio_access.permissions.Permission` instance.\n    \"\"\"\n    need_class = _action2need_map[action]\n\n    if obj is None:\n        return Permission(need_class(None))\n\n    arg = None\n    if isinstance(obj, Bucket):\n        arg = str(obj.id)\n    elif isinstance(obj, ObjectVersion):\n        arg = str(obj.bucket_id)\n    elif isinstance(obj, MultipartObject):\n        arg = str(obj.bucket_id)\n    else:\n        raise RuntimeError('Unknown object')\n\n    return Permission(need_class(arg))"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nchecks if the target file should be deleted if it already exists and if it should be deleted if it should be skipped if it should be deleted if it already exists", "response": "def delete_file(self, path, prefixed_path, source_storage):\n        \"\"\"\n        Checks if the target file should be deleted if it already exists\n        \"\"\"\n        if isinstance(self.storage, CumulusStorage):\n            if self.storage.exists(prefixed_path):\n                try:\n                    etag = self.storage._get_object(prefixed_path).etag\n                    digest = \"{0}\".format(hashlib.md5(source_storage.open(path).read()).hexdigest())\n                    if etag == digest:\n                        self.log(u\"Skipping '{0}' (not modified based on file hash)\".format(path))\n                        return False\n                except:\n                    raise\n        return super(Command, self).delete_file(path, prefixed_path, source_storage)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncreates new bucket from all files in directory.", "response": "def cp(source, bucket, checksum, key_prefix):\n    \"\"\"Create new bucket from all files in directory.\"\"\"\n    from .models import Bucket\n    from .helpers import populate_from_path\n    for object_version in populate_from_path(\n            Bucket.get(bucket), source, checksum=checksum,\n            key_prefix=key_prefix):\n        click.secho(str(object_version))\n    db.session.commit()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_content_type(name, content):\n    if hasattr(content, \"content_type\"):\n        content_type = content.content_type\n    else:\n        mime_type, encoding = mimetypes.guess_type(name)\n        content_type = mime_type\n    return content_type", "response": "Returns the content type of the given name."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef sync_headers(cloud_obj, headers=None, header_patterns=HEADER_PATTERNS):\n    if headers is None:\n        headers = {}\n\n    # don't set headers on directories\n    content_type = getattr(cloud_obj, \"content_type\", None)\n    if content_type == \"application/directory\":\n        return\n    matched_headers = {}\n    for pattern, pattern_headers in header_patterns:\n        if pattern.match(cloud_obj.name):\n            matched_headers.update(pattern_headers.copy())\n    # preserve headers already set\n    matched_headers.update(cloud_obj.headers)\n    # explicitly set headers overwrite matches and already set headers\n    matched_headers.update(headers)\n    if matched_headers != cloud_obj.headers:\n        cloud_obj.headers = matched_headers\n        cloud_obj.sync_metadata()", "response": "Synchronizes the given cloud_obj s headers with the ones given as headers."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a gzipped version of a previously opened file s buffer.", "response": "def get_gzipped_contents(input_file):\n    \"\"\"\n    Returns a gzipped version of a previously opened file's buffer.\n    \"\"\"\n    zbuf = StringIO()\n    zfile = GzipFile(mode=\"wb\", compresslevel=6, fileobj=zbuf)\n    zfile.write(input_file.read())\n    zfile.close()\n    return ContentFile(zbuf.getvalue())"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef schema_from_context(context):\n    item_class = context.get('class')\n    return (\n        serializer_mapping[item_class] if item_class else BaseSchema,\n        context.get('many', False)\n    )", "response": "Determine which schema to use based on context."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef wait_for_taskresult(task_result, content, interval, max_rounds):\n    assert max_rounds > 0\n\n    def _whitespace_waiting():\n        current = 0\n        while current < max_rounds and current != -1:\n            if task_result.ready():\n                # Task is done and we return\n                current = -1\n                if task_result.successful():\n                    yield content\n                else:\n                    yield FilesException(\n                        description='Job failed.'\n                    ).get_body()\n            else:\n                # Send whitespace to prevent connection from closing.\n                current += 1\n                sleep(interval)\n                yield b' '\n\n        # Timed-out reached\n        if current == max_rounds:\n            yield FilesException(\n                description='Job timed out.'\n            ).get_body()\n\n    return _whitespace_waiting()", "response": "Get helper to wait for async task result to finish."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef json_serializer(data=None, code=200, headers=None, context=None,\n                    etag=None, task_result=None):\n    \"\"\"Build a json flask response using the given data.\n\n    :param data: The data to serialize. (Default: ``None``)\n    :param code: The HTTP status code. (Default: ``200``)\n    :param headers: The HTTP headers to include. (Default: ``None``)\n    :param context: The schema class context. (Default: ``None``)\n    :param etag: The ETag header. (Default: ``None``)\n    :param task_result: Optionally you can pass async task to wait for.\n        (Default: ``None``)\n    :returns: A Flask response with json data.\n    :rtype: :py:class:`flask.Response`\n    \"\"\"\n    schema_class, many = schema_from_context(context or {})\n\n    if data is not None:\n        # Generate JSON response\n        data = json.dumps(\n            schema_class(context=context).dump(data, many=many).data,\n            **_format_args()\n        )\n\n        interval = current_app.config['FILES_REST_TASK_WAIT_INTERVAL']\n        max_rounds = int(\n            current_app.config['FILES_REST_TASK_WAIT_MAX_SECONDS'] // interval\n        )\n\n        response = current_app.response_class(\n            # Stream response if waiting for task result.\n            data if task_result is None else wait_for_taskresult(\n                task_result, data, interval, max_rounds, ),\n            mimetype='application/json'\n        )\n    else:\n        response = current_app.response_class(mimetype='application/json')\n\n    response.status_code = code\n    if headers is not None:\n        response.headers.extend(headers)\n\n    if etag:\n        response.set_etag(etag)\n\n    return response", "response": "Builds a json flask response using the given data."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ndumping links for a specific object.", "response": "def dump_links(self, o):\n        \"\"\"Dump links.\"\"\"\n        return {\n            'self': url_for('.bucket_api', bucket_id=o.id, _external=True),\n            'versions': url_for(\n                '.bucket_api', bucket_id=o.id, _external=True) + '?versions',\n            'uploads': url_for(\n                '.bucket_api', bucket_id=o.id, _external=True) + '?uploads',\n        }"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef wrap(self, data, many):\n        if not many:\n            return data\n        else:\n            data = {'contents': data}\n            bucket = self.context.get('bucket')\n            if bucket:\n                data.update(BucketSchema().dump(bucket).data)\n            return data", "response": "Wrap response in envelope."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef wrap(self, data, many):\n        if not many:\n            return data\n        else:\n            data = {'parts': data}\n            multipart = self.context.get('multipart')\n            if multipart:\n                data.update(MultipartObjectSchema(context={\n                    'bucket': multipart.bucket}).dump(multipart).data)\n            return data", "response": "Wrap response in envelope."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget directions between locations in a specific language.", "response": "def directions(self, origin, destination, mode=None, alternatives=None,\n                   waypoints=None, optimize_waypoints=False,\n                   avoid=None, language=None, units=None,\n                   region=None, departure_time=None,\n                   arrival_time=None, sensor=None):\n        \"\"\"Get directions between locations\n\n        :param origin: Origin location - string address; (latitude, longitude)\n            two-tuple, dict with (\"lat\", \"lon\") keys or object with (lat, lon)\n            attributes\n        :param destination: Destination location - type same as origin\n        :param mode: Travel mode as string, defaults to \"driving\".\n            See `google docs details <https://developers.google.com/maps/documentation/directions/#TravelModes>`_\n        :param alternatives: True if provide it has to return more then one\n            route alternative\n        :param waypoints: Iterable with set of intermediate stops,\n            like (\"Munich\", \"Dallas\")\n            See `google docs details <https://developers.google.com/maps/documentation/javascript/reference#DirectionsRequest>`_\n        :param optimize_waypoints: if true will attempt to re-order supplied\n            waypoints to minimize overall cost of the route. If waypoints are\n            optimized, the route returned will show the optimized order under\n            \"waypoint_order\". See `google docs details <https://developers.google.com/maps/documentation/javascript/reference#DirectionsRequest>`_\n        :param avoid: Iterable with set of restrictions,\n            like (\"tolls\", \"highways\"). For full list refer to\n            `google docs details <https://developers.google.com/maps/documentation/directions/#Restrictions>`_\n        :param language: The language in which to return results.\n            See `list of supported languages <https://developers.google.com/maps/faq#languagesupport>`_\n        :param units: Unit system for result. Defaults to unit system of\n            origin's country.\n            See `google docs details <https://developers.google.com/maps/documentation/directions/#UnitSystems>`_\n        :param region: The region code. Affects geocoding of origin and\n            destination (see `gmaps.Geocoding.geocode` region parameter)\n        :param departure_time: Desired time of departure as\n            seconds since midnight, January 1, 1970 UTC\n        :param arrival_time: Desired time of arrival for transit directions as\n            seconds since midnight, January 1, 1970 UTC.\n        \"\"\"  # noqa\n        if optimize_waypoints:\n            waypoints.insert(0, \"optimize:true\")\n        parameters = dict(\n            origin=self.assume_latlon_or_address(origin),\n            destination=self.assume_latlon_or_address(destination),\n            mode=mode,\n            alternatives=alternatives,\n            waypoints=waypoints or [],\n            avoid=avoid,\n            language=language,\n            units=units,\n            region=region,\n            departure_time=departure_time,\n            arrival_time=arrival_time,\n            sensor=sensor,\n        )\n        return self._make_request(self.DIRECTIONS_URL, parameters, \"routes\")"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef upgrade():\n    # Variant types:\n    def created():\n        \"\"\"Return instance of a column.\"\"\"\n        return sa.Column(\n            'created',\n            sa.DateTime().with_variant(mysql.DATETIME(fsp=6), 'mysql'),\n            nullable=False\n        )\n\n    def updated():\n        \"\"\"Return instance of a column.\"\"\"\n        return sa.Column(\n            'updated',\n            sa.DateTime().with_variant(mysql.DATETIME(fsp=6), 'mysql'),\n            nullable=False\n        )\n\n    def uri():\n        \"\"\"Return instance of a column.\"\"\"\n        return sa.Column(\n            'uri',\n            sa.Text().with_variant(mysql.VARCHAR(255), 'mysql'),\n            nullable=True\n        )\n\n    def key(nullable=True):\n        \"\"\"Return instance of a column.\"\"\"\n        return sa.Column(\n            'key',\n            sa.Text().with_variant(mysql.VARCHAR(255), 'mysql'),\n            nullable=nullable\n        )\n\n    op.create_table(\n        'files_files',\n        created(),\n        updated(),\n        sa.Column(\n            'id',\n            sqlalchemy_utils.types.uuid.UUIDType(),\n            nullable=False),\n        uri(),\n        sa.Column('storage_class', sa.String(length=1), nullable=True),\n        sa.Column('size', sa.BigInteger(), nullable=True),\n        sa.Column('checksum', sa.String(length=255), nullable=True),\n        sa.Column('readable', sa.Boolean(name='readable'), nullable=False),\n        sa.Column('writable', sa.Boolean(name='writable'), nullable=False),\n        sa.Column('last_check_at', sa.DateTime(), nullable=True),\n        sa.Column('last_check', sa.Boolean(name='last_check'), nullable=False),\n        sa.PrimaryKeyConstraint('id'),\n        sa.UniqueConstraint('uri')\n    )\n    op.create_table(\n        'files_location',\n        created(),\n        updated(),\n        sa.Column('id', sa.Integer(), nullable=False),\n        sa.Column('name', sa.String(length=20), nullable=False),\n        sa.Column('uri', sa.String(length=255), nullable=False),\n        sa.Column('default', sa.Boolean(name='default'), nullable=False),\n        sa.PrimaryKeyConstraint('id'),\n        sa.UniqueConstraint('name')\n    )\n    op.create_table(\n        'files_bucket',\n        created(),\n        updated(),\n        sa.Column(\n            'id',\n            sqlalchemy_utils.types.uuid.UUIDType(),\n            nullable=False),\n        sa.Column('default_location', sa.Integer(), nullable=False),\n        sa.Column(\n            'default_storage_class',\n            sa.String(length=1),\n            nullable=False\n        ),\n        sa.Column('size', sa.BigInteger(), nullable=False),\n        sa.Column('quota_size', sa.BigInteger(), nullable=True),\n        sa.Column('max_file_size', sa.BigInteger(), nullable=True),\n        sa.Column('locked', sa.Boolean(name='locked'), nullable=False),\n        sa.Column('deleted', sa.Boolean(name='deleted'), nullable=False),\n        sa.ForeignKeyConstraint(\n            ['default_location'],\n            [u'files_location.id'],\n            ondelete='RESTRICT'),\n        sa.PrimaryKeyConstraint('id')\n    )\n    op.create_table(\n        'files_buckettags',\n        sa.Column(\n            'bucket_id',\n            sqlalchemy_utils.types.uuid.UUIDType(),\n            nullable=False),\n        sa.Column('key', sa.String(length=255), nullable=False),\n        sa.Column('value', sa.Text(), nullable=False),\n        sa.ForeignKeyConstraint(\n            ['bucket_id'],\n            [u'files_bucket.id'],\n            ondelete='CASCADE'),\n        sa.PrimaryKeyConstraint('bucket_id', 'key')\n    )\n    op.create_table(\n        'files_multipartobject',\n        created(),\n        updated(),\n        sa.Column(\n            'upload_id',\n            sqlalchemy_utils.types.uuid.UUIDType(),\n            nullable=False),\n        sa.Column(\n            'bucket_id',\n            sqlalchemy_utils.types.uuid.UUIDType(),\n            nullable=True),\n        key(),\n        sa.Column(\n            'file_id',\n            sqlalchemy_utils.types.uuid.UUIDType(),\n            nullable=False),\n        sa.Column('chunk_size', sa.Integer(), nullable=True),\n        sa.Column('size', sa.BigInteger(), nullable=True),\n        sa.Column('completed', sa.Boolean(name='completed'), nullable=False),\n        sa.ForeignKeyConstraint(\n            ['bucket_id'],\n            [u'files_bucket.id'],\n            ondelete='RESTRICT'),\n        sa.ForeignKeyConstraint(\n            ['file_id'],\n            [u'files_files.id'],\n            ondelete='RESTRICT'),\n        sa.PrimaryKeyConstraint('upload_id'),\n        sa.UniqueConstraint('upload_id', 'bucket_id', 'key', name='uix_item')\n    )\n    op.create_table(\n        'files_object',\n        created(),\n        updated(),\n        sa.Column(\n            'bucket_id',\n            sqlalchemy_utils.types.uuid.UUIDType(),\n            nullable=False),\n        key(nullable=False),\n        sa.Column(\n            'version_id',\n            sqlalchemy_utils.types.uuid.UUIDType(),\n            nullable=False),\n        sa.Column(\n            'file_id',\n            sqlalchemy_utils.types.uuid.UUIDType(),\n            nullable=True),\n        sa.Column(\n            '_mimetype', sa.String(\n                length=255), nullable=True),\n        sa.Column('is_head', sa.Boolean(name='is_head'), nullable=False),\n        sa.ForeignKeyConstraint(\n            ['bucket_id'],\n            [u'files_bucket.id'],\n            ondelete='RESTRICT'),\n        sa.ForeignKeyConstraint(\n            ['file_id'],\n            [u'files_files.id'],\n            ondelete='RESTRICT'),\n        sa.PrimaryKeyConstraint('bucket_id', 'key', 'version_id')\n    )\n    op.create_index(\n        op.f('ix_files_object__mimetype'),\n        'files_object',\n        ['_mimetype'],\n        unique=False\n    )\n    op.create_table(\n        'files_multipartobject_part',\n        created(),\n        updated(),\n        sa.Column(\n            'upload_id',\n            sqlalchemy_utils.types.uuid.UUIDType(),\n            nullable=False),\n        sa.Column(\n            'part_number',\n            sa.Integer(),\n            autoincrement=False,\n            nullable=False),\n        sa.Column('checksum', sa.String(length=255), nullable=True),\n        sa.ForeignKeyConstraint(\n            ['upload_id'],\n            [u'files_multipartobject.upload_id'],\n            ondelete='RESTRICT'),\n        sa.PrimaryKeyConstraint('upload_id', 'part_number')\n    )", "response": "Upgrade database to version 1. 0."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef guess_mimetype(filename):\n    m, encoding = mimetypes.guess_type(filename)\n    if encoding:\n        m = ENCODING_MIMETYPES.get(encoding, None)\n    return m or 'application/octet-stream'", "response": "Map extra mimetype with the encoding provided."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef link(text, link_func):\n    def object_formatter(v, c, m, p):\n        \"\"\"Format object view link.\"\"\"\n        return Markup('<a href=\"{0}\">{1}</a>'.format(\n            link_func(m), text))\n    return object_formatter", "response": "Generate a formatter for links."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nvalidating a tag. Keys must be less than 128 chars and values must be less than 256 chars.", "response": "def validate_tag(key, value):\n    \"\"\"Validate a tag.\n\n    Keys must be less than 128 chars and values must be less than 256 chars.\n    \"\"\"\n    # Note, parse_sql does not include a keys if the value is an empty string\n    # (e.g. 'key=&test=a'), and thus technically we should not get strings\n    # which have zero length.\n    klen = len(key)\n    vlen = len(value)\n\n    return klen > 0 and klen < 256 and vlen > 0 and vlen < 256"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef parse_header_tags():\n    # Get the value of the custom HTTP header and interpret it as an query\n    # string\n    qs = request.headers.get(\n        current_app.config['FILES_REST_FILE_TAGS_HEADER'], '')\n\n    tags = {}\n    for key, value in parse_qsl(qs):\n        # Check for duplicate keys\n        if key in tags:\n            raise DuplicateTagError()\n        # Check for too short/long keys and values.\n        if not validate_tag(key, value):\n            raise InvalidTagError()\n        tags[key] = value\n    return tags or None", "response": "Parse tags specified in the HTTP request header."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef default_partfactory(part_number=None, content_length=None,\n                        content_type=None, content_md5=None):\n    \"\"\"Get default part factory.\n\n    :param part_number: The part number. (Default: ``None``)\n    :param content_length: The content length. (Default: ``None``)\n    :param content_type: The HTTP Content-Type. (Default: ``None``)\n    :param content_md5: The content MD5. (Default: ``None``)\n    :returns: The content length, the part number, the stream, the content\n        type, MD5 of the content.\n    \"\"\"\n    return content_length, part_number, request.stream, content_type, \\\n        content_md5, None", "response": "Get default part factory."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets default put factory.", "response": "def stream_uploadfactory(content_md5=None, content_length=None,\n                         content_type=None):\n    \"\"\"Get default put factory.\n\n    If Content-Type is ``'multipart/form-data'`` then the stream is aborted.\n\n    :param content_md5: The content MD5. (Default: ``None``)\n    :param content_length: The content length. (Default: ``None``)\n    :param content_type: The HTTP Content-Type. (Default: ``None``)\n    :returns: The stream, content length, MD5 of the content.\n    \"\"\"\n    if content_type.startswith('multipart/form-data'):\n        abort(422)\n\n    return request.stream, content_length, content_md5, parse_header_tags()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef ngfileupload_partfactory(part_number=None, content_length=None,\n                             uploaded_file=None):\n    \"\"\"Part factory for ng-file-upload.\n\n    :param part_number: The part number. (Default: ``None``)\n    :param content_length: The content length. (Default: ``None``)\n    :param uploaded_file: The upload request. (Default: ``None``)\n    :returns: The content length, part number, stream, HTTP Content-Type\n        header.\n    \"\"\"\n    return content_length, part_number, uploaded_file.stream, \\\n        uploaded_file.headers.get('Content-Type'), None, None", "response": "Part factory for ng - file - upload."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef ngfileupload_uploadfactory(content_length=None, content_type=None,\n                               uploaded_file=None):\n    \"\"\"Get default put factory.\n\n    If Content-Type is ``'multipart/form-data'`` then the stream is aborted.\n\n    :param content_length: The content length. (Default: ``None``)\n    :param content_type: The HTTP Content-Type. (Default: ``None``)\n    :param uploaded_file: The upload request. (Default: ``None``)\n    :param file_tags_header: The file tags. (Default: ``None``)\n    :returns: A tuple containing stream, content length, and empty header.\n    \"\"\"\n    if not content_type.startswith('multipart/form-data'):\n        abort(422)\n\n    return uploaded_file.stream, content_length, None, parse_header_tags()", "response": "Get default put factory."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef pass_bucket(f):\n    @wraps(f)\n    def decorate(*args, **kwargs):\n        bucket_id = kwargs.pop('bucket_id')\n        bucket = Bucket.get(as_uuid(bucket_id))\n        if not bucket:\n            abort(404, 'Bucket does not exist.')\n        return f(bucket=bucket, *args, **kwargs)\n    return decorate", "response": "Decorate to retrieve a bucket."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef pass_multipart(with_completed=False):\n    def decorate(f):\n        @wraps(f)\n        def inner(self, bucket, key, upload_id, *args, **kwargs):\n            obj = MultipartObject.get(\n                bucket, key, upload_id, with_completed=with_completed)\n            if obj is None:\n                abort(404, 'uploadId does not exists.')\n            return f(self, obj, *args, **kwargs)\n        return inner\n    return decorate", "response": "Decorate to retrieve an object."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef check_permission(permission, hidden=True):\n    if permission is not None and not permission.can():\n        if hidden:\n            abort(404)\n        else:\n            if current_user.is_authenticated:\n                abort(403,\n                      'You do not have a permission for this action')\n            abort(401)", "response": "Check if permission is allowed."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef need_permissions(object_getter, action, hidden=True):\n    def decorator_builder(f):\n        @wraps(f)\n        def decorate(*args, **kwargs):\n            check_permission(current_permission_factory(\n                object_getter(*args, **kwargs),\n                action(*args, **kwargs) if callable(action) else action,\n\n            ), hidden=hidden)\n            return f(*args, **kwargs)\n        return decorate\n    return decorator_builder", "response": "Decorator for functions that need permissions for buckets or aborts."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef multipart_listuploads(self, bucket):\n        return self.make_response(\n            data=MultipartObject.query_by_bucket(bucket).limit(1000).all(),\n            context={\n                'class': MultipartObject,\n                'bucket': bucket,\n                'many': True,\n            }\n        )", "response": "List objects in a bucket."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nlist objects in a bucket.", "response": "def listobjects(self, bucket, versions):\n        \"\"\"List objects in a bucket.\n\n        :param bucket: A :class:`invenio_files_rest.models.Bucket` instance.\n        :returns: The Flask response.\n        \"\"\"\n        if versions is not missing:\n            check_permission(\n                current_permission_factory(bucket, 'bucket-read-versions'),\n                hidden=False\n            )\n        return self.make_response(\n            data=ObjectVersion.get_by_bucket(\n                bucket.id, versions=versions is not missing).limit(1000).all(),\n            context={\n                'class': ObjectVersion,\n                'bucket': bucket,\n                'many': True,\n            }\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get(self, bucket=None, versions=missing, uploads=missing):\n        if uploads is not missing:\n            return self.multipart_listuploads(bucket)\n        else:\n            return self.listobjects(bucket, versions)", "response": "Get list of objects in the bucket."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nretrieves object and abort if it doesn t exist.", "response": "def check_object_permission(obj):\n        \"\"\"Retrieve object and abort if it doesn't exists.\"\"\"\n        check_permission(current_permission_factory(\n            obj,\n            'object-read'\n        ))\n        if not obj.is_head:\n            check_permission(\n                current_permission_factory(obj, 'object-read-version'),\n                hidden=False\n            )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_object(cls, bucket, key, version_id):\n        obj = ObjectVersion.get(bucket, key, version_id=version_id)\n        if not obj:\n            abort(404, 'Object does not exists.')\n\n        cls.check_object_permission(obj)\n\n        return obj", "response": "Retrieve object and abort if it doesn t exist."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate a new object in the specified bucket.", "response": "def create_object(self, bucket, key):\n        \"\"\"Create a new object.\n\n        :param bucket: The bucket (instance or id) to get the object from.\n        :param key: The file key.\n        :returns: A Flask response.\n        \"\"\"\n        # Initial validation of size based on Content-Length.\n        # User can tamper with Content-Length, so this is just an initial up\n        # front check. The storage subsystem must validate the size limit as\n        # well.\n        stream, content_length, content_md5, tags = \\\n            current_files_rest.upload_factory()\n\n        size_limit = bucket.size_limit\n        if content_length and size_limit and content_length > size_limit:\n            desc = 'File size limit exceeded.' \\\n                if isinstance(size_limit, int) else size_limit.reason\n            raise FileSizeError(description=desc)\n\n        with db.session.begin_nested():\n            obj = ObjectVersion.create(bucket, key)\n            obj.set_contents(\n                stream, size=content_length, size_limit=size_limit)\n            # Check add tags\n            if tags:\n                for key, value in tags.items():\n                    ObjectVersionTag.create(obj, key, value)\n\n        db.session.commit()\n        return self.make_response(\n            data=obj,\n            context={\n                'class': ObjectVersion,\n                'bucket': bucket,\n            },\n            etag=obj.file.checksum\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef delete_object(self, bucket, obj, version_id):\n        if version_id is None:\n            # Create a delete marker.\n            with db.session.begin_nested():\n                ObjectVersion.delete(bucket, obj.key)\n            db.session.commit()\n        else:\n            # Permanently delete specific object version.\n            check_permission(\n                current_permission_factory(bucket, 'object-delete-version'),\n                hidden=False,\n            )\n            obj.remove()\n            db.session.commit()\n            if obj.file_id:\n                remove_file_data.delay(str(obj.file_id))\n\n        return self.make_response('', 204)", "response": "Delete an existing object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsending an object to a given bucket.", "response": "def send_object(bucket, obj, expected_chksum=None,\n                    logger_data=None, restricted=True, as_attachment=False):\n        \"\"\"Send an object for a given bucket.\n\n        :param bucket: The bucket (instance or id) to get the object from.\n        :param obj: A :class:`invenio_files_rest.models.ObjectVersion`\n            instance.\n        :params expected_chksum: Expected checksum.\n        :param logger_data: The python logger.\n        :param kwargs: Keyword arguments passed to ``Object.send_file()``\n        :returns: A Flask response.\n        \"\"\"\n        if not obj.is_head:\n            check_permission(\n                current_permission_factory(obj, 'object-read-version'),\n                hidden=False\n            )\n\n        if expected_chksum and obj.file.checksum != expected_chksum:\n            current_app.logger.warning(\n                'File checksum mismatch detected.', extra=logger_data)\n\n        file_downloaded.send(current_app._get_current_object(), obj=obj)\n        return obj.send_file(restricted=restricted,\n                             as_attachment=as_attachment)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a Flask response for listing the parts of a multipart upload.", "response": "def multipart_listparts(self, multipart):\n        \"\"\"Get parts of a multipart upload.\n\n        :param multipart: A :class:`invenio_files_rest.models.MultipartObject`\n            instance.\n        :returns: A Flask response.\n        \"\"\"\n        return self.make_response(\n            data=Part.query_by_multipart(\n                multipart).order_by(Part.part_number).limit(1000).all(),\n            context={\n                'class': Part,\n                'multipart': multipart,\n                'many': True,\n            }\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ninitialize a multipart upload.", "response": "def multipart_init(self, bucket, key, size=None, part_size=None):\n        \"\"\"Initialize a multipart upload.\n\n        :param bucket: The bucket (instance or id) to get the object from.\n        :param key: The file key.\n        :param size: The total size.\n        :param part_size: The part size.\n        :raises invenio_files_rest.errors.MissingQueryParameter: If size or\n            part_size are not defined.\n        :returns: A Flask response.\n        \"\"\"\n        if size is None:\n            raise MissingQueryParameter('size')\n        if part_size is None:\n            raise MissingQueryParameter('partSize')\n        multipart = MultipartObject.create(bucket, key, size, part_size)\n        db.session.commit()\n        return self.make_response(\n            data=multipart,\n            context={\n                'class': MultipartObject,\n                'bucket': bucket,\n            }\n        )"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef multipart_uploadpart(self, multipart):\n        content_length, part_number, stream, content_type, content_md5, tags =\\\n            current_files_rest.multipart_partfactory()\n\n        if content_length:\n            ck = multipart.last_part_size if \\\n                part_number == multipart.last_part_number \\\n                else multipart.chunk_size\n\n            if ck != content_length:\n                raise MultipartInvalidChunkSize()\n\n        # Create part\n        try:\n            p = Part.get_or_create(multipart, part_number)\n            p.set_contents(stream)\n            db.session.commit()\n        except Exception:\n            # We remove the Part since incomplete data may have been written to\n            # disk (e.g. client closed connection etc.) so it must be\n            # reuploaded.\n            db.session.rollback()\n            Part.delete(multipart, part_number)\n            raise\n        return self.make_response(\n            data=p,\n            context={\n                'class': Part,\n            },\n            etag=p.checksum\n        )", "response": "Upload a part.\n\n        :param multipart: A :class:`invenio_files_rest.models.MultipartObject`\n            instance.\n        :returns: A Flask response."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef multipart_complete(self, multipart):\n        multipart.complete()\n        db.session.commit()\n\n        version_id = str(uuid.uuid4())\n\n        return self.make_response(\n            data=multipart,\n            context={\n                'class': MultipartObject,\n                'bucket': multipart.bucket,\n                'object_version_id': version_id,\n            },\n            # This will wait for the result, and send whitespace on the\n            # connection until the task has finished (or max timeout reached).\n            task_result=merge_multipartobject.delay(\n                str(multipart.upload_id),\n                version_id=version_id,\n            ),\n        )", "response": "Complete a multipart upload."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef multipart_delete(self, multipart):\n        multipart.delete()\n        db.session.commit()\n        if multipart.file_id:\n            remove_file_data.delay(str(multipart.file_id))\n        return self.make_response('', 204)", "response": "Abort a multipart upload."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget object or list parts of a multpart upload.", "response": "def get(self, bucket=None, key=None, version_id=None, upload_id=None,\n            uploads=None, download=None):\n        \"\"\"Get object or list parts of a multpart upload.\n\n        :param bucket: The bucket (instance or id) to get the object from.\n            (Default: ``None``)\n        :param key: The file key. (Default: ``None``)\n        :param version_id: The version ID. (Default: ``None``)\n        :param upload_id: The upload ID. (Default: ``None``)\n        :param download: The download flag. (Default: ``None``)\n        :returns: A Flask response.\n        \"\"\"\n        if upload_id:\n            return self.multipart_listparts(bucket, key, upload_id)\n        else:\n            obj = self.get_object(bucket, key, version_id)\n            # If 'download' is missing from query string it will have\n            # the value None.\n            return self.send_object(bucket, obj,\n                                    as_attachment=download is not None)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nuploading a new object or start a multipart upload.", "response": "def post(self, bucket=None, key=None, uploads=missing, upload_id=None):\n        \"\"\"Upload a new object or start/complete a multipart upload.\n\n        :param bucket: The bucket (instance or id) to get the object from.\n            (Default: ``None``)\n        :param key: The file key. (Default: ``None``)\n        :param upload_id: The upload ID. (Default: ``None``)\n        :returns: A Flask response.\n        \"\"\"\n        if uploads is not missing:\n            return self.multipart_init(bucket, key)\n        elif upload_id is not None:\n            return self.multipart_complete(bucket, key, upload_id)\n        abort(403)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nupdates a new object or upload a part of a multipart upload.", "response": "def put(self, bucket=None, key=None, upload_id=None):\n        \"\"\"Update a new object or upload a part of a multipart upload.\n\n        :param bucket: The bucket (instance or id) to get the object from.\n            (Default: ``None``)\n        :param key: The file key. (Default: ``None``)\n        :param upload_id: The upload ID. (Default: ``None``)\n        :returns: A Flask response.\n        \"\"\"\n        if upload_id is not None:\n            return self.multipart_uploadpart(bucket, key, upload_id)\n        else:\n            return self.create_object(bucket, key)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndelete an object or abort a multipart upload.", "response": "def delete(self, bucket=None, key=None, version_id=None, upload_id=None,\n               uploads=None):\n        \"\"\"Delete an object or abort a multipart upload.\n\n        :param bucket: The bucket (instance or id) to get the object from.\n            (Default: ``None``)\n        :param key: The file key. (Default: ``None``)\n        :param version_id: The version ID. (Default: ``None``)\n        :param upload_id: The upload ID. (Default: ``None``)\n        :returns: A Flask response.\n        \"\"\"\n        if upload_id is not None:\n            return self.multipart_delete(bucket, key, upload_id)\n        else:\n            obj = self.get_object(bucket, key, version_id)\n            return self.delete_object(bucket, obj, version_id)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _get_container(self):\n        if not hasattr(self, \"_container\"):\n            if self.use_pyrax:\n                self._container = self.connection.create_container(self.container_name)\n            else:\n                self._container = None\n        return self._container", "response": "Gets or creates the container."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset the container and makes it publicly available.", "response": "def _set_container(self, container):\n        \"\"\"\n        Sets the container (and, if needed, the configured TTL on it), making\n        the container publicly available.\n        \"\"\"\n        if self.use_pyrax:\n            if container.cdn_ttl != self.ttl or not container.cdn_enabled:\n                container.make_public(ttl=self.ttl)\n            if hasattr(self, \"_container_public_uri\"):\n                delattr(self, \"_container_public_uri\")\n        self._container = container"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _get_object(self, name):\n        if self.use_pyrax:\n            try:\n                return self.container.get_object(name)\n            except pyrax.exceptions.NoSuchObject:\n                return None\n        elif swiftclient:\n            try:\n                return self.container.get_object(name)\n            except swiftclient.exceptions.ClientException:\n                return None\n        else:\n            return self.container.get_object(name)", "response": "Helper function to retrieve the requested object."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef as_object_version(value):\n    return value if isinstance(value, ObjectVersion) \\\n        else ObjectVersion.query.filter_by(version_id=value).one_or_none()", "response": "Get an object version object from an object version ID or an object version."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ndecorating to update bucket size after operation.", "response": "def update_bucket_size(f):\n    \"\"\"Decorate to update bucket size after operation.\"\"\"\n    @wraps(f)\n    def inner(self, *args, **kwargs):\n        res = f(self, *args, **kwargs)\n        self.bucket.size += self.file.size\n        return res\n    return inner"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef ensure_state(default_getter, exc_class, default_msg=None):\n    def decorator(getter=default_getter, msg=default_msg):\n        def ensure_decorator(f):\n            @wraps(f)\n            def inner(self, *args, **kwargs):\n                if not getter(self):\n                    raise exc_class(msg) if msg else exc_class()\n                return f(self, *args, **kwargs)\n            return inner\n        return ensure_decorator\n    return decorator", "response": "Create a decorator factory function that ensures that the state of the current user is in the correct state."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef size_limit(self):\n        limits = [\n            lim for lim in current_files_rest.file_size_limiters(\n                self)\n            if lim.limit is not None\n        ]\n        return min(limits) if limits else None", "response": "Get the size limit for this bucket."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef snapshot(self, lock=False):\n        with db.session.begin_nested():\n            bucket = Bucket(\n                default_location=self.default_location,\n                default_storage_class=self.default_storage_class,\n                quota_size=self.quota_size,\n            )\n            db.session.add(bucket)\n\n        for o in ObjectVersion.get_by_bucket(self):\n            o.copy(bucket=bucket)\n\n        bucket.locked = True if lock else self.locked\n\n        return bucket", "response": "Create a snapshot of latest objects in bucket."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef create(cls, location=None, storage_class=None, **kwargs):\n        with db.session.begin_nested():\n            if location is None:\n                location = Location.get_default()\n            elif isinstance(location, six.string_types):\n                location = Location.get_by_name(location)\n\n            obj = cls(\n                default_location=location.id,\n                default_storage_class=storage_class or current_app.config[\n                    'FILES_REST_DEFAULT_STORAGE_CLASS'],\n                **kwargs\n            )\n            db.session.add(obj)\n        return obj", "response": "r Create a new bucket."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets a bucket object.", "response": "def get(cls, bucket_id):\n        \"\"\"Get a bucket object (excluding deleted).\n\n        :param bucket_id: Bucket identifier.\n        :returns: Bucket instance.\n        \"\"\"\n        return cls.query.filter_by(\n            id=bucket_id,\n            deleted=False\n        ).one_or_none()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ndeleting a bucket. Does not actually delete the Bucket, just marks it as deleted.", "response": "def delete(cls, bucket_id):\n        \"\"\"Delete a bucket.\n\n        Does not actually delete the Bucket, just marks it as deleted.\n        \"\"\"\n        bucket = cls.get(bucket_id)\n        if not bucket or bucket.deleted:\n            return False\n\n        bucket.deleted = True\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate a new tag for a bucket.", "response": "def create(cls, bucket, key, value):\n        \"\"\"Create a new tag for bucket.\"\"\"\n        with db.session.begin_nested():\n            obj = cls(\n                bucket_id=as_bucket_id(bucket),\n                key=key,\n                value=value\n            )\n            db.session.add(obj)\n        return obj"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef create_or_update(cls, bucket, key, value):\n        obj = cls.get(bucket, key)\n        if obj:\n            obj.value = value\n            db.session.merge(obj)\n        else:\n            obj = cls.create(bucket, key, value)\n        return obj", "response": "Create or update a new tag for bucket."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_by_uri(cls, uri):\n        assert uri is not None\n        return cls.query.filter_by(uri=uri).one_or_none()", "response": "Get a file instance by URI."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating a file instance.", "response": "def create(cls):\n        \"\"\"Create a file instance.\n\n        Note, object is only added to the database session.\n        \"\"\"\n        obj = cls(\n            id=uuid.uuid4(),\n            writable=True,\n            readable=False,\n            size=0,\n        )\n        db.session.add(obj)\n        return obj"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef delete(self):\n        self.query.filter_by(id=self.id).delete()\n        return self", "response": "Delete a file instance."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef update_checksum(self, progress_callback=None, chunk_size=None,\n                        checksum_kwargs=None, **kwargs):\n        \"\"\"Update checksum based on file.\"\"\"\n        self.checksum = self.storage(**kwargs).checksum(\n            progress_callback=progress_callback, chunk_size=chunk_size,\n            **(checksum_kwargs or {}))", "response": "Update checksum based on file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef clear_last_check(self):\n        with db.session.begin_nested():\n            self.last_check = None\n            self.last_check_at = datetime.utcnow()\n        return self", "response": "Clear the checksum of the file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef verify_checksum(self, progress_callback=None, chunk_size=None,\n                        throws=True, checksum_kwargs=None, **kwargs):\n        \"\"\"Verify checksum of file instance.\n\n        :param bool throws: If `True`, exceptions raised during checksum\n            calculation will be re-raised after logging. If set to `False`, and\n            an exception occurs, the `last_check` field is set to `None`\n            (`last_check_at` of course is updated), since no check actually was\n            performed.\n        :param dict checksum_kwargs: Passed as `**kwargs`` to\n            ``storage().checksum``.\n        \"\"\"\n        try:\n            real_checksum = self.storage(**kwargs).checksum(\n                progress_callback=progress_callback, chunk_size=chunk_size,\n                **(checksum_kwargs or {}))\n        except Exception as exc:\n            current_app.logger.exception(str(exc))\n            if throws:\n                raise\n            real_checksum = None\n        with db.session.begin_nested():\n            self.last_check = (None if real_checksum is None\n                               else (self.checksum == real_checksum))\n            self.last_check_at = datetime.utcnow()\n        return self.last_check", "response": "Verify checksum of file instance."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef update_contents(self, stream, seek=0, size=None, chunk_size=None,\n                        progress_callback=None, **kwargs):\n        \"\"\"Save contents of stream to this file.\n\n        :param obj: ObjectVersion instance from where this file is accessed\n            from.\n        :param stream: File-like stream.\n        \"\"\"\n        self.checksum = None\n        return self.storage(**kwargs).update(\n            stream, seek=seek, size=size, chunk_size=chunk_size,\n            progress_callback=progress_callback\n        )", "response": "Save contents of stream to this file."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nsave contents of the object version to this file.", "response": "def set_contents(self, stream, chunk_size=None, size=None, size_limit=None,\n                     progress_callback=None, **kwargs):\n        \"\"\"Save contents of stream to this file.\n\n        :param obj: ObjectVersion instance from where this file is accessed\n            from.\n        :param stream: File-like stream.\n        \"\"\"\n        self.set_uri(\n            *self.storage(**kwargs).save(\n                stream, chunk_size=chunk_size, size=size,\n                size_limit=size_limit, progress_callback=progress_callback))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncopy this file instance into another file instance.", "response": "def copy_contents(self, fileinstance, progress_callback=None,\n                      chunk_size=None, **kwargs):\n        \"\"\"Copy this file instance into another file instance.\"\"\"\n        if not fileinstance.readable:\n            raise ValueError('Source file instance is not readable.')\n        if not self.size == 0:\n            raise ValueError('File instance has data.')\n\n        self.set_uri(\n            *self.storage(**kwargs).copy(\n                fileinstance.storage(**kwargs),\n                chunk_size=chunk_size,\n                progress_callback=progress_callback))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nsend file to the client.", "response": "def send_file(self, filename, restricted=True, mimetype=None,\n                  trusted=False, chunk_size=None, as_attachment=False,\n                  **kwargs):\n        \"\"\"Send file to client.\"\"\"\n        return self.storage(**kwargs).send_file(\n            filename,\n            mimetype=mimetype,\n            restricted=restricted,\n            checksum=self.checksum,\n            trusted=trusted,\n            chunk_size=chunk_size,\n            as_attachment=as_attachment,\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef set_uri(self, uri, size, checksum, readable=True, writable=False,\n                storage_class=None):\n        \"\"\"Set a location of a file.\"\"\"\n        self.uri = uri\n        self.size = size\n        self.checksum = checksum\n        self.writable = writable\n        self.readable = readable\n        self.storage_class = \\\n            current_app.config['FILES_REST_DEFAULT_STORAGE_CLASS'] \\\n            if storage_class is None else \\\n            storage_class\n        return self", "response": "Set a location of a file."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set_contents(self, stream, chunk_size=None, size=None, size_limit=None,\n                     progress_callback=None):\n        \"\"\"Save contents of stream to file instance.\n\n        If a file instance has already been set, this methods raises an\n        ``FileInstanceAlreadySetError`` exception.\n\n        :param stream: File-like stream.\n        :param size: Size of stream if known.\n        :param chunk_size: Desired chunk size to read stream in. It is up to\n            the storage interface if it respects this value.\n        \"\"\"\n        if size_limit is None:\n            size_limit = self.bucket.size_limit\n\n        self.file = FileInstance.create()\n        self.file.set_contents(\n            stream, size_limit=size_limit, size=size, chunk_size=chunk_size,\n            progress_callback=progress_callback,\n            default_location=self.bucket.location.uri,\n            default_storage_class=self.bucket.default_storage_class,\n        )\n\n        return self", "response": "Save contents of stream to file instance."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsets only URI location of for object.", "response": "def set_location(self, uri, size, checksum, storage_class=None):\n        \"\"\"Set only URI location of for object.\n\n        Useful to link files on externally controlled storage. If a file\n        instance has already been set, this methods raises an\n        ``FileInstanceAlreadySetError`` exception.\n\n        :param uri: Full URI to object (which can be interpreted by the storage\n            interface).\n        :param size: Size of file.\n        :param checksum: Checksum of file.\n        :param storage_class: Storage class where file is stored ()\n        \"\"\"\n        self.file = FileInstance()\n        self.file.set_uri(\n            uri, size, checksum, storage_class=storage_class\n        )\n        db.session.add(self.file)\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nwraps around FileInstance s send file method.", "response": "def send_file(self, restricted=True, trusted=False, **kwargs):\n        \"\"\"Wrap around FileInstance's send file.\"\"\"\n        return self.file.send_file(\n            self.basename,\n            restricted=restricted,\n            mimetype=self.mimetype,\n            trusted=trusted,\n            **kwargs\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef copy(self, bucket=None, key=None):\n        new_ob = ObjectVersion.create(\n            self.bucket if bucket is None else as_bucket(bucket),\n            key or self.key,\n            _file_id=self.file_id\n        )\n\n        for tag in self.tags:\n            ObjectVersionTag.create_or_update(object_version=new_ob,\n                                              key=tag.key,\n                                              value=tag.value)\n\n        return new_ob", "response": "Copy an object version to a given bucket + object key."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef create(cls, bucket, key, _file_id=None, stream=None, mimetype=None,\n               version_id=None, **kwargs):\n        \"\"\"Create a new object in a bucket.\n\n        The created object is by default created as a delete marker. You must\n        use ``set_contents()`` or ``set_location()`` in order to change this.\n\n        :param bucket: The bucket (instance or id) to create the object in.\n        :param key: Key of object.\n        :param _file_id: For internal use.\n        :param stream: File-like stream object. Used to set content of object\n            immediately after being created.\n        :param mimetype: MIME type of the file object if it is known.\n        :param kwargs: Keyword arguments passed to ``Object.set_contents()``.\n        \"\"\"\n        bucket = as_bucket(bucket)\n\n        if bucket.locked:\n            raise BucketLockedError()\n\n        with db.session.begin_nested():\n            latest_obj = cls.query.filter(\n                cls.bucket == bucket, cls.key == key, cls.is_head.is_(True)\n            ).one_or_none()\n            if latest_obj is not None:\n                latest_obj.is_head = False\n                db.session.add(latest_obj)\n\n            # By default objects are created in a deleted state (i.e.\n            # file_id is null).\n            obj = cls(\n                bucket=bucket,\n                key=key,\n                version_id=version_id or uuid.uuid4(),\n                is_head=True,\n                mimetype=mimetype,\n            )\n            if _file_id:\n                file_ = _file_id if isinstance(_file_id, FileInstance) else \\\n                    FileInstance.get(_file_id)\n                obj.set_file(file_)\n            db.session.add(obj)\n        if stream:\n            obj.set_contents(stream, **kwargs)\n        return obj", "response": "Create a new object in a bucket."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nfetch a specific object from the database.", "response": "def get(cls, bucket, key, version_id=None):\n        \"\"\"Fetch a specific object.\n\n        By default the latest object version is returned, if\n        ``version_id`` is not set.\n\n        :param bucket: The bucket (instance or id) to get the object from.\n        :param key: Key of object.\n        :param version_id: Specific version of an object.\n        \"\"\"\n        filters = [\n            cls.bucket_id == as_bucket_id(bucket),\n            cls.key == key,\n        ]\n\n        if version_id:\n            filters.append(cls.version_id == version_id)\n        else:\n            filters.append(cls.is_head.is_(True))\n            filters.append(cls.file_id.isnot(None))\n\n        return cls.query.filter(*filters).one_or_none()"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nfetches all versions of a specific object.", "response": "def get_versions(cls, bucket, key, desc=True):\n        \"\"\"Fetch all versions of a specific object.\n\n        :param bucket: The bucket (instance or id) to get the object from.\n        :param key: Key of object.\n        :param desc: Sort results desc if True, asc otherwise.\n        :returns: The query to execute to fetch all versions.\n        \"\"\"\n        filters = [\n            cls.bucket_id == as_bucket_id(bucket),\n            cls.key == key,\n        ]\n\n        order = cls.created.desc() if desc else cls.created.asc()\n\n        return cls.query.filter(*filters).order_by(cls.key, order)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ndeleting an object. Technically works by creating a new version which works as a delete marker. :param bucket: The bucket (instance or id) to delete the object from. :param key: Key of object. :returns: Created delete marker object if key exists else ``None``.", "response": "def delete(cls, bucket, key):\n        \"\"\"Delete an object.\n\n        Technically works by creating a new version which works as a delete\n        marker.\n\n        :param bucket: The bucket (instance or id) to delete the object from.\n        :param key: Key of object.\n        :returns: Created delete marker object if key exists else ``None``.\n        \"\"\"\n        bucket_id = as_bucket_id(bucket)\n\n        obj = cls.get(bucket_id, key)\n        if obj:\n            return cls.create(as_bucket(bucket), key)\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_by_bucket(cls, bucket, versions=False, with_deleted=False):\n        bucket_id = bucket.id if isinstance(bucket, Bucket) else bucket\n\n        filters = [\n            cls.bucket_id == bucket_id,\n        ]\n\n        if not versions:\n            filters.append(cls.is_head.is_(True))\n\n        if not with_deleted:\n            filters.append(cls.file_id.isnot(None))\n\n        return cls.query.filter(*filters).order_by(cls.key, cls.created.desc())", "response": "Return a query that fetches all the objects in a given bucket."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef relink_all(cls, old_file, new_file):\n        assert old_file.checksum == new_file.checksum\n        assert old_file.id\n        assert new_file.id\n\n        with db.session.begin_nested():\n            ObjectVersion.query.filter_by(file_id=str(old_file.id)).update({\n                ObjectVersion.file_id: str(new_file.id)})", "response": "Relink all object versions for a given file to a new file."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncopies a tag to a given object version.", "response": "def copy(self, object_version=None, key=None):\n        \"\"\"Copy a tag to a given object version.\n\n        :param object_version: The object version instance to copy the tag to.\n            Default: current object version.\n        :param key: Key of destination tag.\n            Default: current tag key.\n        :return: The copied object version tag.\n        \"\"\"\n        return ObjectVersionTag.create(\n            self.object_version if object_version is None else object_version,\n            key or self.key,\n            self.value\n        )"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget the tag object.", "response": "def get(cls, object_version, key):\n        \"\"\"Get the tag object.\"\"\"\n        return cls.query.filter_by(\n            version_id=as_object_version_id(object_version),\n            key=key,\n        ).one_or_none()"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates a new tag for a given object version.", "response": "def create(cls, object_version, key, value):\n        \"\"\"Create a new tag for a given object version.\"\"\"\n        assert len(key) < 256\n        assert len(value) < 256\n        with db.session.begin_nested():\n            obj = cls(version_id=as_object_version_id(object_version),\n                      key=key,\n                      value=value)\n            db.session.add(obj)\n        return obj"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate or update a new tag for a given object version.", "response": "def create_or_update(cls, object_version, key, value):\n        \"\"\"Create or update a new tag for a given object version.\"\"\"\n        assert len(key) < 256\n        assert len(value) < 256\n        obj = cls.get(object_version, key)\n        if obj:\n            obj.value = value\n            db.session.merge(obj)\n        else:\n            obj = cls.create(object_version, key, value)\n        return obj"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting the tag value.", "response": "def get_value(cls, object_version, key):\n        \"\"\"Get the tag value.\"\"\"\n        obj = cls.get(object_version, key)\n        return obj.value if obj else None"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ndeletes tags. :param object_version: The object version instance or id. :param key: Key of the tag to delete. Default: delete all tags.", "response": "def delete(cls, object_version, key=None):\n        \"\"\"Delete tags.\n\n        :param object_version: The object version instance or id.\n        :param key: Key of the tag to delete.\n            Default: delete all tags.\n        \"\"\"\n        with db.session.begin_nested():\n            q = cls.query.filter_by(\n                version_id=as_object_version_id(object_version))\n            if key:\n                q = q.filter_by(key=key)\n            q.delete()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef last_part_number(self):\n        return int(self.size / self.chunk_size) \\\n            if self.size % self.chunk_size else \\\n            int(self.size / self.chunk_size) - 1", "response": "Get last part number."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef is_valid_chunksize(chunk_size):\n        min_csize = current_app.config['FILES_REST_MULTIPART_CHUNKSIZE_MIN']\n        max_csize = current_app.config['FILES_REST_MULTIPART_CHUNKSIZE_MAX']\n        return chunk_size >= min_csize and chunk_size <= max_csize", "response": "Check if size is valid."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nvalidating max theoretical size.", "response": "def is_valid_size(size, chunk_size):\n        \"\"\"Validate max theoretical size.\"\"\"\n        min_csize = current_app.config['FILES_REST_MULTIPART_CHUNKSIZE_MIN']\n        max_size = \\\n            chunk_size * current_app.config['FILES_REST_MULTIPART_MAX_PARTS']\n        return size > min_csize and size <= max_size"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef expected_part_size(self, part_number):\n        last_part = self.multipart.last_part_number\n\n        if part_number == last_part:\n            return self.multipart.last_part_size\n        elif part_number >= 0 and part_number < last_part:\n            return self.multipart.chunk_size\n        else:\n            raise MultipartInvalidPartNumber()", "response": "Get the expected part size for a particular part number."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nmarks a multipart object as complete.", "response": "def complete(self):\n        \"\"\"Mark a multipart object as complete.\"\"\"\n        if Part.count(self) != self.last_part_number + 1:\n            raise MultipartMissingParts()\n\n        with db.session.begin_nested():\n            self.completed = True\n            self.file.readable = True\n            self.file.writable = False\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nmerging parts into object version.", "response": "def merge_parts(self, version_id=None, **kwargs):\n        \"\"\"Merge parts into object version.\"\"\"\n        self.file.update_checksum(**kwargs)\n        with db.session.begin_nested():\n            obj = ObjectVersion.create(\n                self.bucket,\n                self.key,\n                _file_id=self.file_id,\n                version_id=version_id\n            )\n            self.delete()\n        return obj"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ndeleting a multipart object.", "response": "def delete(self):\n        \"\"\"Delete a multipart object.\"\"\"\n        # Update bucket size.\n        self.bucket.size -= self.size\n        # Remove parts\n        Part.query_by_multipart(self).delete()\n        # Remove self\n        self.query.filter_by(upload_id=self.upload_id).delete()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating a new object in a bucket.", "response": "def create(cls, bucket, key, size, chunk_size):\n        \"\"\"Create a new object in a bucket.\"\"\"\n        bucket = as_bucket(bucket)\n\n        if bucket.locked:\n            raise BucketLockedError()\n\n        # Validate chunk size.\n        if not cls.is_valid_chunksize(chunk_size):\n            raise MultipartInvalidChunkSize()\n\n        # Validate max theoretical size.\n        if not cls.is_valid_size(size, chunk_size):\n            raise MultipartInvalidSize()\n\n        # Validate max bucket size.\n        bucket_limit = bucket.size_limit\n        if bucket_limit and size > bucket_limit:\n            desc = 'File size limit exceeded.' \\\n                if isinstance(bucket_limit, int) else bucket_limit.reason\n            raise FileSizeError(description=desc)\n\n        with db.session.begin_nested():\n            file_ = FileInstance.create()\n            file_.size = size\n            obj = cls(\n                upload_id=uuid.uuid4(),\n                bucket=bucket,\n                key=key,\n                chunk_size=chunk_size,\n                size=size,\n                completed=False,\n                file=file_,\n            )\n            bucket.size += size\n            db.session.add(obj)\n        file_.init_contents(\n            size=size,\n            default_location=bucket.location.uri,\n            default_storage_class=bucket.default_storage_class,\n        )\n        return obj"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nfetching a specific multipart object.", "response": "def get(cls, bucket, key, upload_id, with_completed=False):\n        \"\"\"Fetch a specific multipart object.\"\"\"\n        q = cls.query.filter_by(\n            upload_id=upload_id,\n            bucket_id=as_bucket_id(bucket),\n            key=key,\n        )\n        if not with_completed:\n            q = q.filter(cls.completed.is_(False))\n\n        return q.one_or_none()"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nqueries all uncompleted multipart uploads.", "response": "def query_expired(cls, dt, bucket=None):\n        \"\"\"Query all uncompleted multipart uploads.\"\"\"\n        q = cls.query.filter(cls.created < dt).filter_by(completed=True)\n        if bucket:\n            q = q.filter(cls.bucket_id == as_bucket_id(bucket))\n        return q"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nquerying all uncompleted multipart uploads.", "response": "def query_by_bucket(cls, bucket):\n        \"\"\"Query all uncompleted multipart uploads.\"\"\"\n        return cls.query.filter(cls.bucket_id == as_bucket_id(bucket))"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets the end byte of the file for this part.", "response": "def end_byte(self):\n        \"\"\"Get end byte in file for this part.\"\"\"\n        return min(\n            (self.part_number + 1) * self.multipart.chunk_size,\n            self.multipart.size\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating a new part object in a multipart object.", "response": "def create(cls, mp, part_number, stream=None, **kwargs):\n        \"\"\"Create a new part object in a multipart object.\"\"\"\n        if part_number < 0 or part_number > mp.last_part_number:\n            raise MultipartInvalidPartNumber()\n\n        with db.session.begin_nested():\n            obj = cls(\n                multipart=mp,\n                part_number=part_number,\n            )\n            db.session.add(obj)\n        if stream:\n            obj.set_contents(stream, **kwargs)\n        return obj"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting or create a new instance of the class based on the given part number.", "response": "def get_or_none(cls, mp, part_number):\n        \"\"\"Get part number.\"\"\"\n        return cls.query.filter_by(\n            upload_id=mp.upload_id,\n            part_number=part_number\n        ).one_or_none()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget or create a part.", "response": "def get_or_create(cls, mp, part_number):\n        \"\"\"Get or create a part.\"\"\"\n        obj = cls.get_or_none(mp, part_number)\n        if obj:\n            return obj\n        return cls.create(mp, part_number)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ndelete a single entry from the database.", "response": "def delete(cls, mp, part_number):\n        \"\"\"Get part number.\"\"\"\n        return cls.query.filter_by(\n            upload_id=mp.upload_id,\n            part_number=part_number\n        ).delete()"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a QuerySet of Part objects for a specific multipart upload.", "response": "def query_by_multipart(cls, multipart):\n        \"\"\"Get all parts for a specific multipart upload.\n\n        :param multipart: A :class:`invenio_files_rest.models.MultipartObject`\n            instance.\n        :returns: A :class:`invenio_files_rest.models.Part` instance.\n        \"\"\"\n        upload_id = multipart.upload_id \\\n            if isinstance(multipart, MultipartObject) else multipart\n        return cls.query.filter_by(\n            upload_id=upload_id\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef set_contents(self, stream, progress_callback=None):\n        size, checksum = self.multipart.file.update_contents(\n            stream, seek=self.start_byte, size=self.part_size,\n            progress_callback=progress_callback,\n        )\n        self.checksum = checksum\n        return self", "response": "Save contents of stream to part of file instance."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef cdn_url(request):\n    cdn_url, ssl_url = _get_container_urls(CumulusStorage())\n    static_url = settings.STATIC_URL\n\n    return {\n        \"CDN_URL\": cdn_url + static_url,\n        \"CDN_SSL_URL\": ssl_url + static_url,\n    }", "response": "A context processor that exposes the full CDN URL in templates."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef static_cdn_url(request):\n    cdn_url, ssl_url = _get_container_urls(CumulusStaticStorage())\n    static_url = settings.STATIC_URL\n\n    return {\n        \"STATIC_URL\": cdn_url + static_url,\n        \"STATIC_SSL_URL\": ssl_url + static_url,\n        \"LOCAL_STATIC_URL\": static_url,\n    }", "response": "A context processor that exposes the full static CDN URL as static URL in templates."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nserializing some parameters to match python native types with formats", "response": "def _serialize_parameters(parameters):\n        \"\"\"Serialize some parameters to match python native types with formats\n        specified in google api docs like:\n        * True/False -> \"true\"/\"false\",\n        * {\"a\": 1, \"b\":2} -> \"a:1|b:2\"\n\n        :type parameters: dict oif query parameters\n        \"\"\"\n\n        for key, value in parameters.items():\n            if isinstance(value, bool):\n                parameters[key] = \"true\" if value else \"false\"\n            elif isinstance(value, dict):\n                parameters[key] = \"|\".join(\n                    (\"%s:%s\" % (k, v) for k, v in value.items()))\n            elif isinstance(value, (list, tuple)):\n                parameters[key] = \"|\".join(value)\n        return parameters"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _make_request(self, url, parameters, result_key):\n        url = urlparse.urljoin(urlparse.urljoin(self.base, url), \"json\")\n\n        # drop all None values and use defaults if not set\n        parameters = {key: value for key, value in parameters.items() if\n                      value is not None}\n        parameters.setdefault(\"sensor\", self.sensor)\n        parameters = self._serialize_parameters(parameters)\n        if self.api_key:\n            parameters[\"key\"] = self.api_key\n\n        raw_response = requests.get(url, params=parameters)\n        response = raw_response.json()\n\n        if response[\"status\"] == status.OK and result_key is not None:\n            return response[result_key]\n        elif response[\"status\"] == status.OK:\n            del response[\"status\"]\n            return response\n        else:\n            response[\"url\"] = raw_response.url\n            raise errors.EXCEPTION_MAPPING.get(\n                response[\"status\"],\n                errors.GmapException\n            )(response)", "response": "Make http request to Google API."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef reverse(self, lat, lon, result_type=None, location_type=None,\n                language=None, sensor=None):\n        \"\"\"Reverse geocode with given latitude and longitude.\n\n        :param lat: latitude of queried point\n        :param lon: longitude of queried point\n        :param result_type: list of result_type for filtered search.\n             Accepted values:\n             https://developers.google.com/maps/documentation/geocoding/intro#Types\n             **Important**: this feature may require using API key to work.\n        :param location_type: list of location_type for filtered search.\n        :param language: the language in which to return results. For full\n             list of laguages go to Google Maps API docs\n        :param sensor: override default client sensor parameter\n\n        .. note:: Google API allows to specify both latlng and address params\n            but it makes no sense and would not reverse geocode your query, so\n            here geocoding and reverse geocoding are separated\n        \"\"\"\n        parameters = dict(\n            latlng=\"%f,%f\" % (lat, lon),\n            result_type=result_type,\n            location_type=location_type,\n            language=language,\n            sensor=sensor,\n        )\n        return self._make_request(self.GEOCODE_URL, parameters, \"results\")", "response": "Reverse geocoding with given latitude and longitude."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef check_sizelimit(size_limit, bytes_written, total_size):\n    if size_limit is not None and bytes_written > size_limit:\n        desc = 'File size limit exceeded.' \\\n            if isinstance(size_limit, int) else size_limit.reason\n        raise FileSizeError(description=desc)\n\n    # Never write more than advertised\n    if total_size is not None and bytes_written > total_size:\n        raise UnexpectedFileSizeError(\n            description='File is bigger than expected.')", "response": "Checks if the size limit is exceeded."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef send_file(self, filename, mimetype=None, restricted=True,\n                  checksum=None, trusted=False, chunk_size=None,\n                  as_attachment=False):\n        \"\"\"Send the file to the client.\"\"\"\n        try:\n            fp = self.open(mode='rb')\n        except Exception as e:\n            raise StorageError('Could not send file: {}'.format(e))\n\n        try:\n            md5_checksum = None\n            if checksum:\n                algo, value = checksum.split(':')\n                if algo == 'md5':\n                    md5_checksum = value\n\n            # Send stream is responsible for closing the file.\n            return send_stream(\n                fp,\n                filename,\n                self._size,\n                self._modified,\n                mimetype=mimetype,\n                restricted=restricted,\n                etag=checksum,\n                content_md5=md5_checksum,\n                chunk_size=chunk_size,\n                trusted=trusted,\n                as_attachment=as_attachment,\n            )\n        except Exception as e:\n            fp.close()\n            raise StorageError('Could not send file: {}'.format(e))", "response": "Send a file to the client."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncomputing checksum of file.", "response": "def checksum(self, chunk_size=None, progress_callback=None, **kwargs):\n        \"\"\"Compute checksum of file.\"\"\"\n        fp = self.open(mode='rb')\n        try:\n            value = self._compute_checksum(\n                fp, size=self._size, chunk_size=None,\n                progress_callback=progress_callback)\n        except StorageError:\n            raise\n        finally:\n            fp.close()\n        return value"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncopy data from another file instance.", "response": "def copy(self, src, chunk_size=None, progress_callback=None):\n        \"\"\"Copy data from another file instance.\n\n        :param src: Source stream.\n        :param chunk_size: Chunk size to read from source stream.\n        \"\"\"\n        fp = src.open(mode='rb')\n        try:\n            return self.save(\n                fp, chunk_size=chunk_size, progress_callback=progress_callback)\n        finally:\n            fp.close()"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncompute checksum of a file.", "response": "def _compute_checksum(self, stream, size=None, chunk_size=None,\n                          progress_callback=None, **kwargs):\n        \"\"\"Get helper method to compute checksum from a stream.\n\n        Naive implementation that can be overwritten by subclasses in order to\n        provide more efficient implementation.\n        \"\"\"\n        if progress_callback and size:\n            progress_callback = partial(progress_callback, size)\n        else:\n            progress_callback = None\n\n        try:\n            algo, m = self._init_hash()\n            return compute_checksum(\n                stream, algo, m,\n                chunk_size=chunk_size,\n                progress_callback=progress_callback,\n                **kwargs\n            )\n        except Exception as e:\n            raise StorageError(\n                'Could not compute checksum of file: {0}'.format(e))"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets helper to save stream from src to dest + compute checksum. :param src: Source stream. :param dst: Destination stream. :param size: If provided, this exact amount of bytes will be written to the destination file. :param size_limit: ``FileSizeLimit`` instance to limit number of bytes to write.", "response": "def _write_stream(self, src, dst, size=None, size_limit=None,\n                      chunk_size=None, progress_callback=None):\n        \"\"\"Get helper to save stream from src to dest + compute checksum.\n\n        :param src: Source stream.\n        :param dst: Destination stream.\n        :param size: If provided, this exact amount of bytes will be\n            written to the destination file.\n        :param size_limit: ``FileSizeLimit`` instance to limit number of bytes\n            to write.\n        \"\"\"\n        chunk_size = chunk_size_or_default(chunk_size)\n\n        algo, m = self._init_hash()\n        bytes_written = 0\n\n        while 1:\n            # Check that size limits aren't bypassed\n            check_sizelimit(size_limit, bytes_written, size)\n\n            chunk = src.read(chunk_size)\n\n            if not chunk:\n                if progress_callback:\n                    progress_callback(bytes_written, bytes_written)\n                break\n\n            dst.write(chunk)\n\n            bytes_written += len(chunk)\n\n            if m:\n                m.update(chunk)\n\n            if progress_callback:\n                progress_callback(None, bytes_written)\n\n        check_size(bytes_written, size)\n\n        return bytes_written, '{0}:{1}'.format(\n            algo, m.hexdigest()) if m else None"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting unix time stamp from that given datetime.", "response": "def unixtimestamp(datetime):\n    \"\"\"Get unix time stamp from that given datetime. If datetime\n    is not tzaware then it's assumed that it is UTC\n    \"\"\"\n    epoch = UTC.localize(datetime.utcfromtimestamp(0))\n    if not datetime.tzinfo:\n        dt = UTC.localize(datetime)\n    else:\n        dt = UTC.normalize(datetime)\n    delta = dt - epoch\n    return total_seconds(delta)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting time offset data for given location.", "response": "def timezone(self, lat, lon, datetime,\n                 language=None, sensor=None):\n        \"\"\"Get time offset data for given location.\n\n        :param lat: Latitude of queried point\n        :param lon: Longitude of queried point\n        :param language: The language in which to return results. For full list\n             of laguages go to Google Maps API docs\n        :param datetime: Desired time. The Time Zone API uses the timestamp to\n             determine whether or not Daylight Savings should be applied.\n             datetime should be timezone aware. If it isn't the UTC timezone\n             is assumed.\n        :type datetime: datetime.datetime\n        :param sensor: Override default client sensor parameter\n        \"\"\"\n\n        parameters = dict(\n            location=\"%f,%f\" % (lat, lon),\n            timestamp=unixtimestamp(datetime),\n            language=language,\n            sensor=sensor,\n        )\n        return self._make_request(self.TIMEZONE_URL, parameters, None)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef encode(locations):\n    encoded = (\n        (_encode_value(lat, prev_lat), _encode_value(lon, prev_lon))\n        for (prev_lat, prev_lon), (lat, lon)\n        in _iterate_with_previous(locations, first=(0, 0))\n    )\n    encoded = chain.from_iterable(encoded)\n    return ''.join(c for r in encoded for c in r)", "response": "Encodes a list of locations into a polyline string."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _writable(method):\n    @wraps(method)\n    def wrapper(self, *args, **kwargs):\n        \"\"\"Send record for indexing.\n\n        :returns: Execution result of the decorated method.\n\n        :raises InvalidOperationError: It occurs when the bucket is locked or\n            deleted.\n        \"\"\"\n        if self.bucket.locked or self.bucket.deleted:\n            raise InvalidOperationError()\n        return method(self, *args, **kwargs)\n    return wrapper", "response": "Decorator for methods that check that record is in defined status."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_version(self, version_id=None):\n        return ObjectVersion.get(bucket=self.obj.bucket, key=self.obj.key,\n                                 version_id=version_id)", "response": "Return specific version of the object."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef dumps(self):\n        self.data.update({\n            'bucket': str(self.obj.bucket_id),\n            'checksum': self.obj.file.checksum,\n            'key': self.obj.key,  # IMPORTANT it must stay here!\n            'size': self.obj.file.size,\n            'version_id': str(self.obj.version_id),\n        })\n        return self.data", "response": "Create a dump of the metadata associated to the record."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nflushing changes to record.", "response": "def flush(self):\n        \"\"\"Flush changes to record.\"\"\"\n        files = self.dumps()\n        # Do not create `_files` when there has not been `_files` field before\n        # and the record still has no files attached.\n        if files or '_files' in self.record:\n            self.record['_files'] = files"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef sort_by(self, *ids):\n        # Support sorting by file_ids or keys.\n        files = {str(f_.file_id): f_.key for f_ in self}\n        # self.record['_files'] = [{'key': files.get(id_, id_)} for id_ in ids]\n        self.filesmap = OrderedDict([\n            (files.get(id_, id_), self[files.get(id_, id_)].dumps())\n            for id_ in ids\n        ])\n        self.flush()", "response": "Update files order.\n\n        :param ids: List of ids specifying the final status of the list."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef rename(self, old_key, new_key):\n        assert new_key not in self\n        assert old_key != new_key\n\n        file_ = self[old_key]\n        old_data = self.filesmap[old_key]\n\n        # Create a new version with the new name\n        obj = ObjectVersion.create(\n            bucket=self.bucket, key=new_key,\n            _file_id=file_.obj.file_id\n        )\n\n        # Delete old key\n        self.filesmap[new_key] = self.file_cls(obj, old_data).dumps()\n        del self[old_key]\n\n        return obj", "response": "Rename an object in the object store."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef dumps(self, bucket=None):\n        return [\n            self.file_cls(o, self.filesmap.get(o.key, {})).dumps()\n            for o in sorted_files_from_bucket(bucket or self.bucket, self.keys)\n        ]", "response": "Serialize files from a bucket."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting files iterator. :returns: Files iterator.", "response": "def files(self):\n        \"\"\"Get files iterator.\n\n        :returns: Files iterator.\n        \"\"\"\n        if self.model is None:\n            raise MissingModelError()\n\n        records_buckets = RecordsBuckets.query.filter_by(\n            record_id=self.id).first()\n\n        if not records_buckets:\n            bucket = self._create_bucket()\n            if not bucket:\n                return None\n            RecordsBuckets.create(record=self.model, bucket=bucket)\n        else:\n            bucket = records_buckets.bucket\n\n        return self.files_iter_cls(self, bucket=bucket, file_cls=self.file_cls)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef files(self, data):\n        current_files = self.files\n        if current_files:\n            raise RuntimeError('Can not update existing files.')\n        for key in data:\n            current_files[key] = data[key]", "response": "Set files from data."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef delete(self, force=False):\n        if force:\n            RecordsBuckets.query.filter_by(\n                record=self.model,\n                bucket=self.files.bucket\n            ).delete()\n        return super(Record, self).delete(force)", "response": "Delete a record and also remove the RecordsBuckets if necessary."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef create(cls, record, bucket):\n        rb = cls(record=record, bucket=bucket)\n        db.session.add(rb)\n        return rb", "response": "Create a new RecordsBuckets and adds it to the session."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns files from bucket sorted by given keys.", "response": "def sorted_files_from_bucket(bucket, keys=None):\n    \"\"\"Return files from bucket sorted by given keys.\n\n    :param bucket: :class:`~invenio_files_rest.models.Bucket` containing the\n        files.\n    :param keys: Keys order to be used.\n    :returns: Sorted list of bucket items.\n    \"\"\"\n    keys = keys or []\n    total = len(keys)\n    sortby = dict(zip(keys, range(total)))\n    values = ObjectVersion.get_by_bucket(bucket).all()\n    return sorted(values, key=lambda x: sortby.get(x.key, total))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a file from a record.", "response": "def record_file_factory(pid, record, filename):\n    \"\"\"Get file from a record.\n\n    :param pid: Not used. It keeps the function signature.\n    :param record: Record which contains the files.\n    :param filename: Name of the file to be returned.\n    :returns: File object or ``None`` if not found.\n    \"\"\"\n    try:\n        if not (hasattr(record, 'files') and record.files):\n            return None\n    except MissingModelError:\n        return None\n\n    try:\n        return record.files[filename]\n    except KeyError:\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nfile download view for a given record.", "response": "def file_download_ui(pid, record, _record_file_factory=None, **kwargs):\n    \"\"\"File download view for a given record.\n\n    Plug this method into your ``RECORDS_UI_ENDPOINTS`` configuration:\n\n    .. code-block:: python\n\n        RECORDS_UI_ENDPOINTS = dict(\n            recid=dict(\n                # ...\n                route='/records/<pid_value/files/<filename>',\n                view_imp='invenio_records_files.utils:file_download_ui',\n                record_class='invenio_records_files.api:Record',\n            )\n        )\n\n    If ``download`` is passed as a querystring argument, the file is sent as an\n    attachment.\n\n    :param pid: The :class:`invenio_pidstore.models.PersistentIdentifier`\n        instance.\n    :param record: The record metadata.\n    \"\"\"\n    _record_file_factory = _record_file_factory or record_file_factory\n    # Extract file from record.\n    fileobj = _record_file_factory(\n        pid, record, kwargs.get('filename')\n    )\n\n    if not fileobj:\n        abort(404)\n\n    obj = fileobj.obj\n\n    # Check permissions\n    ObjectResource.check_object_permission(obj)\n\n    # Send file.\n    return ObjectResource.send_object(\n        obj.bucket, obj,\n        expected_chksum=fileobj.get('checksum'),\n        logger_data={\n            'bucket_id': obj.bucket_id,\n            'pid_type': pid.pid_type,\n            'pid_value': pid.pid_value,\n        },\n        as_attachment=('download' in request.args)\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef default_bucket_link_factory(pid):\n    try:\n        record = Record.get_record(pid.get_assigned_object())\n        bucket = record.files.bucket\n\n        return url_for('invenio_files_rest.bucket_api',\n                       bucket_id=bucket.id, _external=True)\n    except AttributeError:\n        return None", "response": "Factory for record bucket generation."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nprinting an error message to stdout.", "response": "def flake(self, message):\n        \"\"\"Print an error message to stdout.\"\"\"\n        self.stdout.write(str(message))\n        self.stdout.write('\\n')"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn node. id or node. name", "response": "def node_name(node):\n    \"\"\"\n        Convenience function: Returns node.id, or node.name, or None\n    \"\"\"\n    return hasattr(node, 'id') and node.id or hasattr(node, 'name') and node.name"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef names(self):\n        names = []\n        if isinstance(self.source, ast.List):\n            for node in self.source.elts:\n                if isinstance(node, ast.Str):\n                    names.append(node.s)\n        return names", "response": "Return a list of the names referenced by this binding."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef unusedAssignments(self):\n        for name, binding in self.items():\n            if (not binding.used and name not in self.globals\n                    and not self.uses_locals\n                    and isinstance(binding, Assignment)):\n                yield name, binding", "response": "Return a generator for the assignments which have not been used."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncollect plugins from entry point frosted. plugins and run their check method passing the filename SetException", "response": "def check_plugins(self):\n        \"\"\" collect plugins from entry point 'frosted.plugins'\n\n        and run their check() method, passing the filename\n        \"\"\"\n        checkers = {}\n        for ep in pkg_resources.iter_entry_points(group='frosted.plugins'):\n            checkers.update({ep.name: ep.load()})\n\n        for plugin_name, plugin in checkers.items():\n            if self.filename != '(none)':\n                messages = plugin.check(self.filename)\n                for message, loc, args, kwargs in messages:\n                    self.report(message, loc, *args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef defer_function(self, callable):\n        self._deferred_functions.append((callable, self.scope_stack[:], self.offset))", "response": "Schedule a function handler to be called just before completion."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef defer_assignment(self, callable):\n        self._deferred_assignments.append((callable, self.scope_stack[:], self.offset))", "response": "Schedule an assignment handler to be called just after deferred\n        function handlers."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef run_deferred(self, deferred):\n        for handler, scope, offset in deferred:\n            self.scope_stack = scope\n            self.offset = offset\n            handler()", "response": "Run the callables in deferred using their associated scope stack and offset."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef check_dead_scopes(self):\n        for scope in self.dead_scopes:\n            export = isinstance(scope.get('__all__'), ExportBinding)\n            if export:\n                all = scope['__all__'].names()\n                # Look for possible mistakes in the export list\n                if not scope.importStarred and os.path.basename(self.filename) != '__init__.py':\n                    undefined = set(all) - set(scope)\n                    for name in undefined:\n                        self.report(messages.UndefinedExport, scope['__all__'].source, name)\n            else:\n                all = []\n\n            # Look for imported names that aren't used without checking imports in namespace definition\n            for importation in scope.values():\n                if isinstance(importation, Importation) and not importation.used and importation.name not in all:\n                    self.report(messages.UnusedImport, importation.source, importation.name)", "response": "Look at scopes which have been fully examined and report names in\n            they which were imported but unused."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ntruing if lnode and rnode are located on different forks of IF or TRY.", "response": "def different_forks(self, lnode, rnode):\n        \"\"\"True, if lnode and rnode are located on different forks of\n        IF/TRY.\"\"\"\n        ancestor = self.get_common_ancestor(lnode, rnode)\n        if isinstance(ancestor, ast.If):\n            for fork in (ancestor.body, ancestor.orelse):\n                if self.on_fork(ancestor, lnode, rnode, fork):\n                    return True\n        elif isinstance(ancestor, ast.Try):\n            body = ancestor.body + ancestor.orelse\n            for fork in [body] + [[hdl] for hdl in ancestor.handlers]:\n                if self.on_fork(ancestor, lnode, rnode, fork):\n                    return True\n        elif isinstance(ancestor, ast.TryFinally):\n            if self.on_fork(ancestor, lnode, rnode, ancestor.body):\n                return True\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef add_binding(self, node, value, report_redef=True):\n        redefinedWhileUnused = False\n        if not isinstance(self.scope, ClassScope):\n            for scope in self.scope_stack[::-1]:\n                existing = scope.get(value.name)\n                if (isinstance(existing, Importation)\n                        and not existing.used\n                        and (not isinstance(value, Importation) or\n                             value.fullName == existing.fullName)\n                        and report_redef\n                        and not self.different_forks(node, existing.source)):\n                    redefinedWhileUnused = True\n                    self.report(messages.RedefinedWhileUnused,\n                                node, value.name, existing.source)\n\n        existing = self.scope.get(value.name)\n        if not redefinedWhileUnused and self.has_parent(value.source, ast.ListComp):\n            if (existing and report_redef\n                    and not self.has_parent(existing.source, (ast.For, ast.ListComp))\n                    and not self.different_forks(node, existing.source)):\n                self.report(messages.RedefinedInListComp,\n                            node, value.name, existing.source)\n\n        if (isinstance(existing, Definition)\n                and not existing.used\n                and not self.different_forks(node, existing.source)):\n            self.report(messages.RedefinedWhileUnused,\n                        node, value.name, existing.source)\n        else:\n            self.scope[value.name] = value", "response": "Called when a binding is added to the current scope."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef is_docstring(self, node):\n        return isinstance(node, ast.Str) or (isinstance(node, ast.Expr) and\n                                             isinstance(node.value, ast.Str))", "response": "Determine if the given node is a docstring."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef find_return_with_argument(self, node):\n        for item in node.body:\n            if isinstance(item, ast.Return) and item.value:\n                return item\n            elif not isinstance(item, ast.FunctionDef) and hasattr(item, 'body'):\n                return_with_argument = self.find_return_with_argument(item)\n                if return_with_argument:\n                    return return_with_argument", "response": "Finds and returns a return statment that has an argument."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncheck whether a function is a generator by looking for a yield statement or expression.", "response": "def is_generator(self, node):\n        \"\"\"Checks whether a function is a generator by looking for a yield\n        statement or expression.\"\"\"\n        if not isinstance(node.body, list):\n            # lambdas can not be generators\n            return False\n        for item in node.body:\n            if isinstance(item, (ast.Assign, ast.Expr)):\n                if isinstance(item.value, ast.Yield):\n                    return True\n            elif not isinstance(item, ast.FunctionDef) and hasattr(item, 'body'):\n                if self.is_generator(item):\n                    return True\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef GLOBAL(self, node):\n        if isinstance(self.scope, FunctionScope):\n            self.scope.globals.update(node.names)", "response": "Keep track of globals declarations."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef FOR(self, node):\n        vars = []\n\n        def collectLoopVars(n):\n            if isinstance(n, ast.Name):\n                vars.append(n.id)\n            elif isinstance(n, ast.expr_context):\n                return\n            else:\n                for c in ast.iter_child_nodes(n):\n                    collectLoopVars(c)\n\n        collectLoopVars(node.target)\n        for varn in vars:\n            if (isinstance(self.scope.get(varn), Importation)\n                    # unused ones will get an unused import warning\n                    and self.scope[varn].used):\n                self.report(messages.ImportShadowedByLoopVar,\n                            node, varn, self.scope[varn].source)\n\n        self.handle_children(node)", "response": "Process bindings for loop variables."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nhandle occurrence of Name in function or globals.", "response": "def NAME(self, node):\n        \"\"\"Handle occurrence of Name (which can be a load/store/delete\n        access.)\"\"\"\n        # Locate the name in locals / function / globals scopes.\n        if isinstance(node.ctx, (ast.Load, ast.AugLoad)):\n            self.handle_node_load(node)\n            if (node.id == 'locals' and isinstance(self.scope, FunctionScope)\n                    and isinstance(node.parent, ast.Call)):\n                # we are doing locals() call in current scope\n                self.scope.uses_locals = True\n        elif isinstance(node.ctx, (ast.Store, ast.AugStore)):\n            self.handle_node_store(node)\n        elif isinstance(node.ctx, ast.Del):\n            self.handle_node_delete(node)\n        else:\n            # must be a Param context -- this only happens for names in function\n            # arguments, but these aren't dispatched through here\n            raise RuntimeError(\"Got impossible expression context: %r\" % (node.ctx,))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef CLASSDEF(self, node):\n        for deco in node.decorator_list:\n            self.handleNode(deco, node)\n        for baseNode in node.bases:\n            self.handleNode(baseNode, node)\n        if not PY2:\n            for keywordNode in node.keywords:\n                self.handleNode(keywordNode, node)\n        self.push_scope(ClassScope)\n        if self.settings.get('run_doctests', False):\n            self.defer_function(lambda: self.handle_doctests(node))\n        for stmt in node.body:\n            self.handleNode(stmt, node)\n        self.pop_scope()\n        self.add_binding(node, ClassDefinition(node.name, node))", "response": "Check names used in a class definition."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef check(codeString, filename, reporter=modReporter.Default, settings_path=None, **setting_overrides):\n\n    if not settings_path and filename:\n        settings_path = os.path.dirname(os.path.abspath(filename))\n    settings_path = settings_path or os.getcwd()\n\n    active_settings = settings.from_path(settings_path).copy()\n    for key, value in itemsview(setting_overrides):\n        access_key = key.replace('not_', '').lower()\n        if type(active_settings.get(access_key)) in (list, tuple):\n            if key.startswith('not_'):\n                active_settings[access_key] = list(set(active_settings[access_key]).difference(value))\n            else:\n                active_settings[access_key] = list(set(active_settings[access_key]).union(value))\n        else:\n            active_settings[key] = value\n    active_settings.update(setting_overrides)\n\n    if _should_skip(filename, active_settings.get('skip', [])):\n        if active_settings.get('directly_being_checked', None) == 1:\n            reporter.flake(FileSkipped(filename))\n            return 1\n        elif active_settings.get('verbose', False):\n            ignore = active_settings.get('ignore_frosted_errors', [])\n            if(not \"W200\" in ignore and not \"W201\" in ignore):\n                reporter.flake(FileSkipped(filename, None, verbose=active_settings.get('verbose')))\n        return 0\n\n    # First, compile into an AST and handle syntax errors.\n    try:\n        tree = compile(codeString, filename, \"exec\", _ast.PyCF_ONLY_AST)\n    except SyntaxError:\n        value = sys.exc_info()[1]\n        msg = value.args[0]\n\n        (lineno, offset, text) = value.lineno, value.offset, value.text\n\n        # If there's an encoding problem with the file, the text is None.\n        if text is None:\n            # Avoid using msg, since for the only known case, it contains a\n            # bogus message that claims the encoding the file declared was\n            # unknown.\n            reporter.unexpected_error(filename, 'problem decoding source')\n        else:\n            reporter.flake(PythonSyntaxError(filename, msg, lineno, offset, text,\n                                             verbose=active_settings.get('verbose')))\n        return 1\n    except Exception:\n        reporter.unexpected_error(filename, 'problem decoding source')\n        return 1\n    # Okay, it's syntactically valid.  Now check it.\n    w = checker.Checker(tree, filename, None, ignore_lines=_noqa_lines(codeString), **active_settings)\n    w.messages.sort(key=lambda m: m.lineno)\n    for warning in w.messages:\n        reporter.flake(warning)\n    return len(w.messages)", "response": "Check the Python source given by codeString for unfrosted flakes."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncheck the given path and print out any warnings detected.", "response": "def check_path(filename, reporter=modReporter.Default, settings_path=None, **setting_overrides):\n    \"\"\"Check the given path, printing out any warnings detected.\"\"\"\n    try:\n        with open(filename, 'U') as f:\n            codestr = f.read() + '\\n'\n    except UnicodeError:\n        reporter.unexpected_error(filename, 'problem decoding source')\n        return 1\n    except IOError:\n        msg = sys.exc_info()[1]\n        reporter.unexpected_error(filename, msg.args[1])\n        return 1\n    return check(codestr, filename, reporter, settings_path, **setting_overrides)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef check_recursive(paths, reporter=modReporter.Default, settings_path=None, **setting_overrides):\n    warnings = 0\n    for source_path in iter_source_code(paths):\n        warnings += check_path(source_path, reporter, settings_path=None, **setting_overrides)\n    return warnings", "response": "Recursively check all source files defined in paths."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_files_from_storage(paths):\n        for path in paths:\n            f = default_storage.open(path)\n            f.name = os.path.basename(path)\n            try:\n                yield f\n            except ClientError:\n                logger.exception(\"File not found: %s\", path)", "response": "Return S3 files where the name does not include the path."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nechoes the user message.", "response": "def echo(bot, update):\n    \"\"\"Echo the user message.\"\"\"\n    message = update.get_effective_message()\n    bot.reply(update, message)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef error(bot, update, error):\n    logger.error('Update {} caused error {}'.format(update, error), extra={\"tag\": \"err\"})", "response": "Log Errors caused by Updates."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef server_from_config(config=None, server_class=None, additional_kwargs=None):\n    global global_config\n    if not config:\n        config = global_config\n\n    queue_store_factory = resolve_name(config.get('coilmq', 'qstore.factory'))\n    subscriber_scheduler_factory = resolve_name(config.get(\n            'coilmq', 'scheduler.subscriber_priority_factory'))\n    queue_scheduler_factory = resolve_name(config.get(\n            'coilmq', 'scheduler.queue_priority_factory'))\n\n    if config.has_option('coilmq', 'auth.factory'):\n        authenticator_factory = resolve_name(\n                config.get('coilmq', 'auth.factory'))\n        authenticator = authenticator_factory()\n    else:\n        authenticator = None\n\n    server = ThreadedStompServer((config.get('coilmq', 'listen_addr'), config.getint('coilmq', 'listen_port')),\n                                 queue_manager=QueueManager(store=queue_store_factory(),\n                                                            subscriber_scheduler=subscriber_scheduler_factory(),\n                                                            queue_scheduler=queue_scheduler_factory()),\n                                 topic_manager=TopicManager(),\n                                 authenticator=authenticator,\n                                 protocol=STOMP11)\n    logger.info(\"Created server:%r\" % server)\n    return server", "response": "Returns a configured StompServer from a config file."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nstarting a server within a context.", "response": "def context_serve(context, configfile, listen_addr, listen_port, logfile,\n                  debug, daemon, uid, gid, pidfile, umask, rundir):\n    \"\"\"\n    Takes a context object, which implements the __enter__/__exit__ \"with\" interface \n    and starts a server within that context.\n\n    This method is a refactored single-place for handling the server-run code whether\n    running in daemon or non-daemon mode.  It is invoked with a dummy (passthrough) \n    context object for the non-daemon use case. \n\n    @param options: The compiled collection of options that need to be parsed. \n    @type options: C{ConfigParser}\n\n    @param context: The context object that implements __enter__/__exit__ \"with\" methods.\n    @type context: C{object}\n\n    @raise Exception: Any underlying exception will be logged but then re-raised.\n    @see: server_from_config()\n    \"\"\"\n    global global_config\n\n    server = None\n    try:\n        with context:\n            # There's a possibility here that init_logging() will throw an exception.  If it does,\n            # AND we're in a daemon context, then we're not going to be able to do anything with it.\n            # We've got no stderr/stdout here; and so (to my knowledge) no reliable (& cross-platform),\n            # way to display errors.\n            level = logging.DEBUG if debug else logging.INFO\n            init_logging(logfile=logfile, loglevel=level,\n                         configfile=configfile)\n\n            server = server_from_config()\n            logger.info(\"Stomp server listening on %s:%s\" % server.server_address)\n\n            if debug:\n                poll_interval = float(global_config.get(\n                        'coilmq', 'debug.stats_poll_interval'))\n                if poll_interval:  # Setting poll_interval to 0 effectively disables it.\n                    def diagnostic_loop(server):\n                        log = logger\n                        while True:\n                            log.debug(\n                                    \"Stats heartbeat -------------------------------\")\n                            store = server.queue_manager.store\n                            for dest in store.destinations():\n                                log.debug(\"Queue %s: size=%s, subscribers=%s\" % (\n                                    dest, store.size(dest), server.queue_manager.subscriber_count(dest)))\n\n                            # TODO: Add number of subscribers?\n\n                            time.sleep(poll_interval)\n\n                    diagnostic_thread = threading.Thread(\n                            target=diagnostic_loop, name='DiagnosticThread', args=(server,))\n                    diagnostic_thread.daemon = True\n                    diagnostic_thread.start()\n\n            server.serve_forever()\n\n    except (KeyboardInterrupt, SystemExit):\n        logger.info(\"Stomp server stopped by user interrupt.\")\n        raise SystemExit()\n    except Exception as e:\n        logger.error(\"Stomp server stopped due to error: %s\" % e)\n        logger.exception(e)\n        raise SystemExit()\n    finally:\n        if server:\n            server.server_close()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef main(config, host, port, logfile, debug, daemon, uid, gid, pidfile, umask, rundir):\n\n    _main(**locals())", "response": "This is the main function for the socket server."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a SQLAlchemy queue store", "response": "def make_sa():\n    \"\"\"\n    Factory to creates a SQLAlchemy queue store, pulling config values from the CoilMQ configuration.\n    \"\"\"\n    configuration = dict(config.items('coilmq'))\n    engine = engine_from_config(configuration, 'qstore.sqlalchemy.')\n    init_model(engine)\n    store = SAQueue()\n    return store"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef init_model(engine, create=True, drop=False):\n    meta.engine = engine\n    meta.metadata = MetaData(bind=meta.engine)\n    meta.Session = scoped_session(sessionmaker(bind=meta.engine))\n    model.setup_tables(create=create, drop=drop)", "response": "Initializes the shared SQLAlchemy model."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef enqueue(self, destination, frame):\n        session = meta.Session()\n        message_id = frame.headers.get('message-id')\n        if not message_id:\n            raise ValueError(\"Cannot queue a frame without message-id set.\")\n        ins = model.frames_table.insert().values(\n            message_id=message_id, destination=destination, frame=frame)\n        session.execute(ins)\n        session.commit()", "response": "Enqueue a message to the queue for this destination."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nremoves and returns an item from the queue.", "response": "def dequeue(self, destination):\n        \"\"\"\n        Removes and returns an item from the queue (or C{None} if no items in queue).\n\n        @param destination: The queue name (destinationination).\n        @type destination: C{str}\n\n        @return: The first frame in the specified queue, or C{None} if there are none.\n        @rtype: C{stompclient.frame.Frame} \n        \"\"\"\n        session = meta.Session()\n\n        try:\n\n            selstmt = select(\n                [model.frames_table.c.message_id, model.frames_table.c.frame])\n            selstmt = selstmt.where(\n                model.frames_table.c.destination == destination)\n            selstmt = selstmt.order_by(\n                model.frames_table.c.queued, model.frames_table.c.sequence)\n\n            result = session.execute(selstmt)\n\n            first = result.fetchone()\n            if not first:\n                return None\n\n            delstmt = model.frames_table.delete().where(model.frames_table.c.message_id ==\n                                                        first[model.frames_table.c.message_id])\n            session.execute(delstmt)\n\n            frame = first[model.frames_table.c.frame]\n\n        except:\n            session.rollback()\n            raise\n        else:\n            session.commit()\n            return frame"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning C { bool } if the specified queue has any frames in the specified queue.", "response": "def has_frames(self, destination):\n        \"\"\"\n        Whether specified queue has any frames.\n\n        @param destination: The queue name (destinationination).\n        @type destination: C{str}\n\n        @return: Whether there are any frames in the specified queue.\n        @rtype: C{bool}\n        \"\"\"\n        session = meta.Session()\n        sel = select([model.frames_table.c.message_id]).where(\n            model.frames_table.c.destination == destination)\n        result = session.execute(sel)\n\n        first = result.fetchone()\n        return first is not None"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the number of frames in the specified queue.", "response": "def size(self, destination):\n        \"\"\"\n        Size of the queue for specified destination.\n\n        @param destination: The queue destination (e.g. /queue/foo)\n        @type destination: C{str}\n\n        @return: The number of frames in specified queue.\n        @rtype: C{int}\n        \"\"\"\n        session = meta.Session()\n        sel = select([func.count(model.frames_table.c.message_id)]).where(\n            model.frames_table.c.destination == destination)\n        result = session.execute(sel)\n        first = result.fetchone()\n        if not first:\n            return 0\n        else:\n            return int(first[0])"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nprovide a list of destinations available.", "response": "def destinations(self):\n        \"\"\"\n        Provides a list of destinations (queue \"addresses\") available.\n\n        @return: A list of the detinations available.\n        @rtype: C{set}\n        \"\"\"\n        session = meta.Session()\n        sel = select([distinct(model.frames_table.c.destination)])\n        result = session.execute(sel)\n        return set([r[0] for r in result.fetchall()])"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef setup_tables(create=True, drop=False):\n    global frames_table\n    frames_table = Table('frames', meta.metadata,\n                         Column('message_id', String(255), primary_key=True),\n                         Column('sequence', BigInteger,\n                                primary_key=False, autoincrement=True),\n                         Column('destination', String(255), index=True),\n                         Column('frame', PickleType),\n                         Column('queued', DateTime, default=func.now()))\n\n    if drop:\n        meta.metadata.drop_all()\n\n    if drop or create:\n        meta.metadata.create_all()", "response": "Create and drop the tables in the database."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef subscribe(self, connection, destination):\n        self.log.debug(\"Subscribing %s to %s\" % (connection, destination))\n        self._topics[destination].add(connection)", "response": "Subscribes a connection to the specified topic destination."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef unsubscribe(self, connection, destination):\n        self.log.debug(\"Unsubscribing %s from %s\" % (connection, destination))\n        if connection in self._topics[destination]:\n            self._topics[destination].remove(connection)\n\n        if not self._topics[destination]:\n            del self._topics[destination]", "response": "Unsubscribes a connection from the specified topic destination."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ndisconnects a subscriber connection from all topics.", "response": "def disconnect(self, connection):\n        \"\"\"\n        Removes a subscriber connection.\n\n        @param connection: The client connection to unsubscribe.\n        @type connection: L{coilmq.server.StompConnection}\n        \"\"\"\n        self.log.debug(\"Disconnecting %s\" % connection)\n        for dest in list(self._topics.keys()):\n            if connection in self._topics[dest]:\n                self._topics[dest].remove(connection)\n            if not self._topics[dest]:\n                # This won't trigger RuntimeError, since we're using keys()\n                del self._topics[dest]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsending a message to all subscribers of destination.", "response": "def send(self, message):\n        \"\"\"\n        Sends a message to all subscribers of destination.\n\n        @param message: The message frame.  (The frame will be modified to set command \n                            to MESSAGE and set a message id.)\n        @type message: L{stompclient.frame.Frame}\n        \"\"\"\n        dest = message.headers.get('destination')\n        if not dest:\n            raise ValueError(\n                \"Cannot send frame with no destination: %s\" % message)\n\n        message.cmd = 'message'\n\n        message.headers.setdefault('message-id', str(uuid.uuid4()))\n\n        bad_subscribers = set()\n        for subscriber in self._topics[dest]:\n            try:\n                subscriber.send_frame(message)\n            except:\n                self.log.exception(\n                    \"Error delivering message to subscriber %s; client will be disconnected.\" % subscriber)\n                # We queue for deletion so we are not modifying the topics dict\n                # while iterating over it.\n                bad_subscribers.add(subscriber)\n\n        for subscriber in bad_subscribers:\n            self.disconnect(subscriber)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef unbind(self):\n        self.connected = False\n        self.queue_manager.disconnect(self.connection)\n        self.topic_manager.disconnect(self.connection)", "response": "Unbinds this connection from queue and topic managers."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef close(self):\n        self.log.info(\"Shutting down queue manager.\")\n        if hasattr(self.store, 'close'):\n            self.store.close()\n\n        if hasattr(self.subscriber_scheduler, 'close'):\n            self.subscriber_scheduler.close()\n\n        if hasattr(self.queue_scheduler, 'close'):\n            self.queue_scheduler.close()", "response": "Closes all resources and backends associated with this queue manager."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef subscriber_count(self, destination=None):\n        if destination:\n            return len(self._queues[destination])\n        else:\n            # total them up\n            total = 0\n            for k in self._queues.keys():\n                total += len(self._queues[k])\n            return total", "response": "Returns a count of the number of subscribers."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsubscribing a connection to the specified destination.", "response": "def subscribe(self, connection, destination):\n        \"\"\"\n        Subscribes a connection to the specified destination (topic or queue). \n\n        @param connection: The connection to subscribe.\n        @type connection: L{coilmq.server.StompConnection}\n\n        @param destination: The topic/queue destination (e.g. '/queue/foo')\n        @type destination: C{str} \n        \"\"\"\n        self.log.debug(\"Subscribing %s to %s\" % (connection, destination))\n        self._queues[destination].add(connection)\n        self._send_backlog(connection, destination)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ndisconnecting a subscriber connection from the server.", "response": "def disconnect(self, connection):\n        \"\"\"\n        Removes a subscriber connection, ensuring that any pending commands get requeued.\n\n        @param connection: The client connection to unsubscribe.\n        @type connection: L{coilmq.server.StompConnection}\n        \"\"\"\n        self.log.debug(\"Disconnecting %s\" % connection)\n        if connection in self._pending:\n            pending_frame = self._pending[connection]\n            self.store.requeue(pending_frame.headers.get(\n                'destination'), pending_frame)\n            del self._pending[connection]\n\n        for dest in list(self._queues.keys()):\n            if connection in self._queues[dest]:\n                self._queues[dest].remove(connection)\n            if not self._queues[dest]:\n                # This won't trigger RuntimeError, since we're using keys()\n                del self._queues[dest]"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef send(self, message):\n        dest = message.headers.get('destination')\n        if not dest:\n            raise ValueError(\n                \"Cannot send frame with no destination: %s\" % message)\n\n        message.cmd = 'message'\n\n        message.headers.setdefault('message-id', str(uuid.uuid4()))\n\n        # Grab all subscribers for this destination that do not have pending\n        # frames\n        subscribers = [s for s in self._queues[dest]\n                       if s not in self._pending]\n\n        if not subscribers:\n            self.log.debug(\n                \"No eligible subscribers; adding message %s to queue %s\" % (message, dest))\n            self.store.enqueue(dest, message)\n        else:\n            selected = self.subscriber_scheduler.choice(subscribers, message)\n            self.log.debug(\"Delivering message %s to subscriber %s\" %\n                           (message, selected))\n            self._send_frame(selected, message)", "response": "Sends a MESSAGE frame to an eligible subscriber connection."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nacknowledges receipt of a message.", "response": "def ack(self, connection, frame, transaction=None):\n        \"\"\"\n        Acknowledge receipt of a message.\n\n        If the `transaction` parameter is non-null, the frame being ack'd\n        will be queued so that it can be requeued if the transaction\n        is rolled back. \n\n        @param connection: The connection that is acknowledging the frame.\n        @type connection: L{coilmq.server.StompConnection}\n\n        @param frame: The frame being acknowledged.\n\n        \"\"\"\n        self.log.debug(\"ACK %s for %s\" % (frame, connection))\n\n        if connection in self._pending:\n            pending_frame = self._pending[connection]\n            # Make sure that the frame being acknowledged matches\n            # the expected frame\n            if pending_frame.headers.get('message-id') != frame.headers.get('message-id'):\n                self.log.warning(\n                    \"Got a ACK for unexpected message-id: %s\" % frame.message_id)\n                self.store.requeue(pending_frame.destination, pending_frame)\n                # (The pending frame will be removed further down)\n\n            if transaction is not None:\n                self._transaction_frames[connection][\n                    transaction].append(pending_frame)\n\n            del self._pending[connection]\n            self._send_backlog(connection)\n\n        else:\n            self.log.debug(\"No pending messages for %s\" % connection)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nresend the messages that were ACK'd in specified transaction.", "response": "def resend_transaction_frames(self, connection, transaction):\n        \"\"\"\n        Resend the messages that were ACK'd in specified transaction.\n\n        This is called by the engine when there is an abort command.\n\n        @param connection: The client connection that aborted the transaction.\n        @type connection: L{coilmq.server.StompConnection}\n\n        @param transaction: The transaction id (which was aborted).\n        @type transaction: C{str}\n        \"\"\"\n        for frame in self._transaction_frames[connection][transaction]:\n            self.send(frame)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _send_backlog(self, connection, destination=None):\n        if destination is None:\n            # Find all destinations that have frames and that contain this\n            # connection (subscriber).\n            eligible_queues = dict([(dest, q) for (dest, q) in self._queues.items()\n                                    if connection in q and self.store.has_frames(dest)])\n            destination = self.queue_scheduler.choice(\n                eligible_queues, connection)\n            if destination is None:\n                self.log.debug(\n                    \"No eligible queues (with frames) for subscriber %s\" % connection)\n                return\n\n        self.log.debug(\"Sending backlog to %s for destination %s\" %\n                       (connection, destination))\n        if connection.reliable_subscriber:\n            # only send one message (waiting for ack)\n            frame = self.store.dequeue(destination)\n            if frame:\n                try:\n                    self._send_frame(connection, frame)\n                except Exception as x:\n                    self.log.error(\n                        \"Error sending message %s (requeueing): %s\" % (frame, x))\n                    self.store.requeue(destination, frame)\n                    raise\n        else:\n            for frame in self.store.frames(destination):\n                try:\n                    self._send_frame(connection, frame)\n                except Exception as x:\n                    self.log.error(\n                        \"Error sending message %s (requeueing): %s\" % (frame, x))\n                    self.store.requeue(destination, frame)\n                    raise", "response": "Sends any queued - up messages to the specified destination."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _send_frame(self, connection, frame):\n        assert connection is not None\n        assert frame is not None\n\n        self.log.debug(\"Delivering frame %s to connection %s\" %\n                       (frame, connection))\n\n        if connection.reliable_subscriber:\n            if connection in self._pending:\n                raise RuntimeError(\"Connection already has a pending frame.\")\n            self.log.debug(\n                \"Tracking frame %s as pending for connection %s\" % (frame, connection))\n            self._pending[connection] = frame\n\n        connection.send_frame(frame)", "response": "Sends a frame to a specific subscriber connection."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef make_dbm():\n    try:\n        data_dir = config.get('coilmq', 'qstore.dbm.data_dir')\n        cp_ops = config.getint('coilmq', 'qstore.dbm.checkpoint_operations')\n        cp_timeout = config.getint('coilmq', 'qstore.dbm.checkpoint_timeout')\n    except ConfigParser.NoOptionError as e:\n        raise ConfigError('Missing configuration parameter: %s' % e)\n\n    if not os.path.exists(data_dir):\n        raise ConfigError('DBM directory does not exist: %s' % data_dir)\n    # FIXME: how do these get applied? Is OR appropriate?\n    if not os.access(data_dir, os.W_OK | os.R_OK):\n        raise ConfigError('Cannot read and write DBM directory: %s' % data_dir)\n\n    store = DbmQueue(data_dir, checkpoint_operations=cp_ops,\n                     checkpoint_timeout=cp_timeout)\n    return store", "response": "Creates a DBM queue store for the current node."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef enqueue(self, destination, frame):\n        message_id = frame.headers.get('message-id')\n        if not message_id:\n            raise ValueError(\"Cannot queue a frame without message-id set.\")\n\n        if not destination in self.queue_metadata:\n            self.log.info(\n                \"Destination %s not in metadata; creating new entry and queue database.\" % destination)\n            self.queue_metadata[destination] = {\n                'frames': deque(), 'enqueued': 0, 'dequeued': 0, 'size': 0}\n\n        self.queue_metadata[destination]['frames'].appendleft(message_id)\n        self.queue_metadata[destination]['enqueued'] += 1\n\n        self.frame_store[message_id] = frame\n\n        self._opcount += 1\n        self._sync()", "response": "Enqueue a message to the specified destination."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef dequeue(self, destination):\n        if not self.has_frames(destination):\n            return None\n\n        message_id = self.queue_metadata[destination]['frames'].pop()\n        self.queue_metadata[destination]['dequeued'] += 1\n\n        frame = self.frame_store[message_id]\n        del self.frame_store[message_id]\n\n        self._opcount += 1\n        self._sync()\n\n        return frame", "response": "Removes and returns an item from the queue."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndetermine if the specified queue has any frames in the specified queue.", "response": "def has_frames(self, destination):\n        \"\"\"\n        Whether specified queue has any frames.\n\n        @param destination: The queue name (destinationination).\n        @type destination: C{str}\n\n        @return: Whether there are any frames in the specified queue.\n        @rtype: C{bool}\n        \"\"\"\n        return (destination in self.queue_metadata) and bool(self.queue_metadata[destination]['frames'])"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the size of the queue for the specified destination.", "response": "def size(self, destination):\n        \"\"\"\n        Size of the queue for specified destination.\n\n        @param destination: The queue destination (e.g. /queue/foo)\n        @type destination: C{str}\n\n        @return: The number of frames in specified queue.\n        @rtype: C{int}\n        \"\"\"\n        if not destination in self.queue_metadata:\n            return 0\n        else:\n            return len(self.queue_metadata[destination]['frames'])"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _sync(self):\n        if (self._opcount > self.checkpoint_operations or\n                datetime.now() > self._last_sync + self.checkpoint_timeout):\n            self.log.debug(\"Synchronizing queue metadata.\")\n            self.queue_metadata.sync()\n            self._last_sync = datetime.now()\n            self._opcount = 0\n        else:\n            self.log.debug(\"NOT synchronizing queue metadata.\")", "response": "Synchronize the cache with the underlyind database."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef read(config_values):\n    if not config_values:\n        raise RheaError('Cannot read config_value: `{}`'.format(config_values))\n\n    config_values = to_list(config_values)\n\n    config = {}\n    for config_value in config_values:\n        config_value = ConfigSpec.get_from(value=config_value)\n        config_value.check_type()\n        config_results = config_value.read()\n        if config_results and isinstance(config_results, Mapping):\n            config = deep_update(config, config_results)\n        elif config_value.check_if_exists:\n            raise RheaError('Cannot read config_value: `{}`'.format(config_value))\n\n    return config", "response": "Reads an ordered list of configuration values and deep merge the values in reverse order."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef parse_headers(buff):\n    preamble_lines = list(map(\n        lambda x: six.u(x).decode(),\n        iter(lambda: buff.readline().strip(), b''))\n    )\n    if not preamble_lines:\n        raise EmptyBuffer()\n    return preamble_lines[0], OrderedDict([l.split(':') for l in preamble_lines[1:]])", "response": "Parses buffer and returns command and headers as strings\n   "}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate a string representation of this object state.", "response": "def pack(self):\n        \"\"\"\n        Create a string representation from object state.\n\n        @return: The string (bytes) for this stomp frame.\n        @rtype: C{str}\n        \"\"\"\n\n        self.headers.setdefault('content-length', len(self.body))\n\n        # Convert and append any existing headers to a string as the\n        # protocol describes.\n        headerparts = (\"{0}:{1}\\n\".format(key, value)\n                       for key, value in self.headers.items())\n\n        # Frame is Command + Header + EOF marker.\n        return six.b(\"{0}\\n{1}\\n\".format(self.cmd, \"\".join(headerparts))) + (self.body if isinstance(self.body, six.binary_type) else six.b(self.body)) + six.b('\\x00')"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nextracts one complete frame off the buffer and returns it.", "response": "def extract_frame(self):\n        \"\"\"\n        Pulls one complete frame off the buffer and returns it.\n\n        If there is no complete message in the buffer, returns None.\n\n        Note that the buffer can contain more than once message. You\n        should therefore call this method in a loop (or use iterator\n        functionality exposed by class) until None returned.\n\n        @return: The next complete frame in the buffer.\n        @rtype: L{stomp.frame.Frame}\n        \"\"\"\n        # (mbytes, hbytes) = self._find_message_bytes(self.buffer)\n        # if not mbytes:\n        #     return None\n        #\n        # msgdata = self.buffer[:mbytes]\n        # self.buffer = self.buffer[mbytes:]\n        # hdata = msgdata[:hbytes]\n        # # Strip off any leading whitespace from headers; this is necessary, because\n        # # we do not (any longer) expect a trailing \\n after the \\x00 byte (which means\n        # # it will become a leading \\n to the next frame).\n        # hdata = hdata.lstrip()\n        # elems = hdata.split('\\n')\n        # cmd = elems.pop(0)\n        # headers = {}\n        #\n        # for e in elems:\n        #     try:\n        #         (k,v) = e.split(':', 1) # header values may contain ':' so specify maxsplit\n        #     except ValueError:\n        #         continue\n        #     headers[k.strip()] = v.strip()\n        #\n        # # hbytes points to the start of the '\\n\\n' at the end of the header,\n        # # so 2 bytes beyond this is the start of the body. The body EXCLUDES\n        # # the final byte, which is  '\\x00'.\n        # body = msgdata[hbytes + 2:-1]\n        self._buffer.seek(self._pointer, 0)\n        try:\n            f = Frame.from_buffer(self._buffer)\n            self._pointer = self._buffer.tell()\n        except (IncompleteFrame, EmptyBuffer):\n            self._buffer.seek(self._pointer, 0)\n            return None\n\n        return f"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef choice(self, subscribers, message):\n        if not subscribers:\n            return None\n        reliable_subscribers = [\n            s for s in subscribers if s.reliable_subscriber]\n        if reliable_subscribers:\n            return random.choice(reliable_subscribers)\n        else:\n            return random.choice(subscribers)", "response": "Choose a random connection favoring those that are reliable from\n        subscriber pool to deliver specified message."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a random queue destination for messages to specified connection.", "response": "def choice(self, queues, connection):\n        \"\"\"\n        Chooses a random queue for messages to specified connection.\n\n        @param queues: A C{dict} mapping queue name to queues (sets of frames) to which \n                        specified connection is subscribed.\n        @type queues:  C{dict} of C{str} to C{set} of L{stompclient.frame.Frame}\n\n        @param connection: The connection that is going to be delivered the frame(s).\n        @type connection: L{coilmq.server.StompConnection}\n\n        @return: A random queue destination or None if list is empty.\n        @rtype: C{str}\n        \"\"\"\n        if not queues:\n            return None\n        return random.choice(list(queues.keys()))"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets a value corresponding to the key and converts it to int.", "response": "def get_int(self,\n                key,\n                is_list=False,\n                is_optional=False,\n                is_secret=False,\n                is_local=False,\n                default=None,\n                options=None):\n        \"\"\"\n        Get a the value corresponding to the key and converts it to `int`/`list(int)`.\n\n        Args:\n            key: the dict key.\n            is_list: If this is one element or a list of elements.\n            is_optional: To raise an error if key was not found.\n            is_secret: If the key is a secret.\n            is_local: If the key is a local to this service.\n            default: default value if is_optional is True.\n            options: list/tuple if provided, the value must be one of these values.\n\n        Returns:\n             `int`: value corresponding to the key.\n        \"\"\"\n        if is_list:\n            return self._get_typed_list_value(key=key,\n                                              target_type=int,\n                                              type_convert=int,\n                                              is_optional=is_optional,\n                                              is_secret=is_secret,\n                                              is_local=is_local,\n                                              default=default,\n                                              options=options)\n\n        return self._get_typed_value(key=key,\n                                     target_type=int,\n                                     type_convert=int,\n                                     is_optional=is_optional,\n                                     is_secret=is_secret,\n                                     is_local=is_local,\n                                     default=default,\n                                     options=options)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget a value corresponding to the key and converts it to float.", "response": "def get_float(self,\n                  key,\n                  is_list=False,\n                  is_optional=False,\n                  is_secret=False,\n                  is_local=False,\n                  default=None,\n                  options=None):\n        \"\"\"\n        Get a the value corresponding to the key and converts it to `float`/`list(float)`.\n\n        Args:\n            key: the dict key.\n            is_list: If this is one element or a list of elements.\n            is_optional: To raise an error if key was not found.\n            is_secret: If the key is a secret.\n            is_local: If the key is a local to this service.\n            default: default value if is_optional is True.\n            options: list/tuple if provided, the value must be one of these values.\n\n        Returns:\n             `float`: value corresponding to the key.\n        \"\"\"\n        if is_list:\n            return self._get_typed_list_value(key=key,\n                                              target_type=float,\n                                              type_convert=float,\n                                              is_optional=is_optional,\n                                              is_secret=is_secret,\n                                              is_local=is_local,\n                                              default=default,\n                                              options=options)\n\n        return self._get_typed_value(key=key,\n                                     target_type=float,\n                                     type_convert=float,\n                                     is_optional=is_optional,\n                                     is_secret=is_secret,\n                                     is_local=is_local,\n                                     default=default,\n                                     options=options)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting a boolean value corresponding to the key and converts it to bool or list ( str.", "response": "def get_boolean(self,\n                    key,\n                    is_list=False,\n                    is_optional=False,\n                    is_secret=False,\n                    is_local=False,\n                    default=None,\n                    options=None):\n        \"\"\"\n        Get a the value corresponding to the key and converts it to `bool`/`list(str)`.\n\n        Args:\n            key: the dict key.\n            is_list: If this is one element or a list of elements.\n            is_optional: To raise an error if key was not found.\n            is_secret: If the key is a secret.\n            is_local: If the key is a local to this service.\n            default: default value if is_optional is True.\n            options: list/tuple if provided, the value must be one of these values.\n\n        Returns:\n            `bool`: value corresponding to the key.\n        \"\"\"\n        if is_list:\n            return self._get_typed_list_value(key=key,\n                                              target_type=bool,\n                                              type_convert=lambda x: bool(strtobool(x)),\n                                              is_optional=is_optional,\n                                              is_secret=is_secret,\n                                              is_local=is_local,\n                                              default=default,\n                                              options=options)\n\n        return self._get_typed_value(key=key,\n                                     target_type=bool,\n                                     type_convert=lambda x: bool(strtobool(x)),\n                                     is_optional=is_optional,\n                                     is_secret=is_secret,\n                                     is_local=is_local,\n                                     default=default,\n                                     options=options)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting a value corresponding to the key and converts it to str.", "response": "def get_string(self,\n                   key,\n                   is_list=False,\n                   is_optional=False,\n                   is_secret=False,\n                   is_local=False,\n                   default=None,\n                   options=None):\n        \"\"\"\n        Get a the value corresponding to the key and converts it to `str`/`list(str)`.\n\n        Args:\n            key: the dict key.\n            is_list: If this is one element or a list of elements.\n            is_optional: To raise an error if key was not found.\n            is_secret: If the key is a secret.\n            is_local: If the key is a local to this service.\n            default: default value if is_optional is True.\n            options: list/tuple if provided, the value must be one of these values.\n\n        Returns:\n            `str`: value corresponding to the key.\n        \"\"\"\n        if is_list:\n            return self._get_typed_list_value(key=key,\n                                              target_type=str,\n                                              type_convert=str,\n                                              is_optional=is_optional,\n                                              is_secret=is_secret,\n                                              is_local=is_local,\n                                              default=default,\n                                              options=options)\n\n        return self._get_typed_value(key=key,\n                                     target_type=str,\n                                     type_convert=str,\n                                     is_optional=is_optional,\n                                     is_secret=is_secret,\n                                     is_local=is_local,\n                                     default=default,\n                                     options=options)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_dict(self,\n                 key,\n                 is_list=False,\n                 is_optional=False,\n                 is_secret=False,\n                 is_local=False,\n                 default=None,\n                 options=None):\n        \"\"\"\n        Get a the value corresponding to the key and converts it to `dict`.\n\n        Args:\n            key: the dict key.\n            is_list: If this is one element or a list of elements.\n            is_optional: To raise an error if key was not found.\n            is_secret: If the key is a secret.\n            is_local: If the key is a local to this service.\n            default: default value if is_optional is True.\n            options: list/tuple if provided, the value must be one of these values.\n\n        Returns:\n            `str`: value corresponding to the key.\n        \"\"\"\n\n        def convert_to_dict(x):\n            x = json.loads(x)\n            if not isinstance(x, Mapping):\n                raise RheaError(\"Cannot convert value `{}` (key: `{}`) to `dict`\".format(x, key))\n            return x\n\n        if is_list:\n            return self._get_typed_list_value(key=key,\n                                              target_type=Mapping,\n                                              type_convert=convert_to_dict,\n                                              is_optional=is_optional,\n                                              is_secret=is_secret,\n                                              is_local=is_local,\n                                              default=default,\n                                              options=options)\n        value = self._get_typed_value(key=key,\n                                      target_type=Mapping,\n                                      type_convert=convert_to_dict,\n                                      is_optional=is_optional,\n                                      is_secret=is_secret,\n                                      is_local=is_local,\n                                      default=default,\n                                      options=options)\n\n        if not value:\n            return default\n\n        if not isinstance(value, Mapping):\n            raise RheaError(\"Cannot convert value `{}` (key: `{}`) \"\n                            \"to `dict`\".format(value, key))\n        return value", "response": "Get a value corresponding to the key and converts it to dict."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting a dict corresponding to the key and converts it to dict.", "response": "def get_dict_of_dicts(self,\n                          key,\n                          is_optional=False,\n                          is_secret=False,\n                          is_local=False,\n                          default=None,\n                          options=None):\n        \"\"\"\n        Get a the value corresponding to the key and converts it to `dict`.\n\n        Add an extra validation that all keys have a dict as values.\n\n        Args:\n            key: the dict key.\n            is_optional: To raise an error if key was not found.\n            is_secret: If the key is a secret.\n            is_local: If the key is a local to this service.\n            default: default value if is_optional is True.\n            options: list/tuple if provided, the value must be one of these values.\n\n        Returns:\n            `str`: value corresponding to the key.\n        \"\"\"\n        value = self.get_dict(\n            key=key,\n            is_optional=is_optional,\n            is_secret=is_secret,\n            is_local=is_local,\n            default=default,\n            options=options,\n        )\n        if not value:\n            return default\n\n        for k in value:\n            if not isinstance(value[k], Mapping):\n                raise RheaError(\n                    \"`{}` must be an object. \"\n                    \"Received a non valid configuration for key `{}`.\".format(value[k], key))\n\n        return value"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_uri(self,\n                key,\n                is_list=False,\n                is_optional=False,\n                is_secret=False,\n                is_local=False,\n                default=None,\n                options=None):\n        \"\"\"\n        Get a the value corresponding to the key and converts it to `UriSpec`.\n\n        Args\n            key: the dict key.\n            is_list: If this is one element or a list of elements.\n            is_optional: To raise an error if key was not found.\n            is_secret: If the key is a secret.\n            is_local: If the key is a local to this service.\n            default: default value if is_optional is True.\n            options: list/tuple if provided, the value must be one of these values.\n\n        Returns:\n             `str`: value corresponding to the key.\n        \"\"\"\n        if is_list:\n            return self._get_typed_list_value(key=key,\n                                              target_type=UriSpec,\n                                              type_convert=self.parse_uri_spec,\n                                              is_optional=is_optional,\n                                              is_secret=is_secret,\n                                              is_local=is_local,\n                                              default=default,\n                                              options=options)\n\n        return self._get_typed_value(key=key,\n                                     target_type=UriSpec,\n                                     type_convert=self.parse_uri_spec,\n                                     is_optional=is_optional,\n                                     is_secret=is_secret,\n                                     is_local=is_local,\n                                     default=default,\n                                     options=options)", "response": "Get a value corresponding to the key and converts it to UriSpec."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_auth(self,\n                 key,\n                 is_list=False,\n                 is_optional=False,\n                 is_secret=False,\n                 is_local=False,\n                 default=None,\n                 options=None):\n        \"\"\"\n        Get a the value corresponding to the key and converts it to `AuthSpec`.\n\n        Args\n            key: the dict key.\n            is_list: If this is one element or a list of elements.\n            is_optional: To raise an error if key was not found.\n            is_secret: If the key is a secret.\n            is_local: If the key is a local to this service.\n            default: default value if is_optional is True.\n            options: list/tuple if provided, the value must be one of these values.\n\n        Returns:\n             `str`: value corresponding to the key.\n        \"\"\"\n        if is_list:\n            return self._get_typed_list_value(key=key,\n                                              target_type=AuthSpec,\n                                              type_convert=self.parse_auth_spec,\n                                              is_optional=is_optional,\n                                              is_secret=is_secret,\n                                              is_local=is_local,\n                                              default=default,\n                                              options=options)\n\n        return self._get_typed_value(key=key,\n                                     target_type=AuthSpec,\n                                     type_convert=self.parse_auth_spec,\n                                     is_optional=is_optional,\n                                     is_secret=is_secret,\n                                     is_local=is_local,\n                                     default=default,\n                                     options=options)", "response": "Get a value corresponding to the key and converts it to AuthSpec."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting a the value corresponding to the key and converts comma separated values to a list.", "response": "def get_list(self,\n                 key,\n                 is_optional=False,\n                 is_secret=False,\n                 is_local=False,\n                 default=None,\n                 options=None):\n        \"\"\"\n        Get a the value corresponding to the key and converts comma separated values to a list.\n\n        Args:\n            key: the dict key.\n            is_optional: To raise an error if key was not found.\n            is_secret: If the key is a secret.\n            is_local: If the key is a local to this service.\n            default: default value if is_optional is True.\n            options: list/tuple if provided, the value must be one of these values.\n\n        Returns:\n             `str`: value corresponding to the key.\n        \"\"\"\n\n        def parse_list(v):\n            parts = v.split(',')\n            results = []\n            for part in parts:\n                part = part.strip()\n                if part:\n                    results.append(part)\n            return results\n\n        return self._get_typed_value(key=key,\n                                     target_type=list,\n                                     type_convert=parse_list,\n                                     is_optional=is_optional,\n                                     is_secret=is_secret,\n                                     is_local=is_local,\n                                     default=default,\n                                     options=options)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _get_typed_value(self,\n                         key,\n                         target_type,\n                         type_convert,\n                         is_optional=False,\n                         is_secret=False,\n                         is_local=False,\n                         default=None,\n                         options=None):\n        \"\"\"\n        Return the value corresponding to the key converted to the given type.\n\n        Args:\n            key: the dict key.\n            target_type: The type we expect the variable or key to be in.\n            type_convert: A lambda expression that converts the key to the desired type.\n            is_optional: To raise an error if key was not found.\n            is_secret: If the key is a secret.\n            is_local: If the key is a local to this service.\n            default: default value if is_optional is True.\n            options: list/tuple if provided, the value must be one of these values.\n\n        Returns:\n            The corresponding value of the key converted.\n        \"\"\"\n        try:\n            value = self._get(key)\n        except KeyError:\n            if not is_optional:\n                raise RheaError(\n                    'No value was provided for the non optional key `{}`.'.format(key))\n            return default\n\n        if isinstance(value, six.string_types):\n            try:\n                self._add_key(key, is_secret=is_secret, is_local=is_local)\n                self._check_options(key=key, value=value, options=options)\n                return type_convert(value)\n            except ValueError:\n                raise RheaError(\"Cannot convert value `{}` (key: `{}`) \"\n                                \"to `{}`\".format(value, key, target_type))\n\n        if isinstance(value, target_type):\n            self._add_key(key, is_secret=is_secret, is_local=is_local)\n            self._check_options(key=key, value=value, options=options)\n            return value\n        raise RheaError(\"Cannot convert value `{}` (key: `{}`) \"\n                        \"to `{}`\".format(value, key, target_type))", "response": "Internal method that returns the typed value of the key."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the value corresponding to the given key converted first to list then each element to the given type.", "response": "def _get_typed_list_value(self,\n                              key,\n                              target_type,\n                              type_convert,\n                              is_optional=False,\n                              is_secret=False,\n                              is_local=False,\n                              default=None,\n                              options=None):\n        \"\"\"\n        Return the value corresponding to the key converted first to list\n        than each element to the given type.\n\n        Args:\n            key: the dict key.\n            target_type: The type we expect the variable or key to be in.\n            type_convert: A lambda expression that converts the key to the desired type.\n            is_optional: To raise an error if key was not found.\n            is_secret: If the key is a secret.\n            is_local: If the key is a local to this service.\n            default: default value if is_optional is True.\n            options: list/tuple if provided, the value must be one of these values.\n        \"\"\"\n\n        value = self._get_typed_value(key=key,\n                                      target_type=list,\n                                      type_convert=json.loads,\n                                      is_optional=is_optional,\n                                      is_secret=is_secret,\n                                      is_local=is_local,\n                                      default=default,\n                                      options=options)\n\n        if not value:\n            return default\n\n        raise_type = 'dict' if target_type == Mapping else target_type\n\n        if not isinstance(value, list):\n            raise RheaError(\"Cannot convert value `{}` (key: `{}`) \"\n                            \"to `{}`\".format(value, key, raise_type))\n        # If we are here the value must be a list\n        result = []\n        for v in value:\n            if isinstance(v, six.string_types):\n                try:\n                    result.append(type_convert(v))\n                except ValueError:\n                    raise RheaError(\"Cannot convert value `{}` (found in list key: `{}`) \"\n                                    \"to `{}`\".format(v, key, raise_type))\n            elif isinstance(v, target_type):\n                result.append(v)\n\n            else:\n                raise RheaError(\"Cannot convert value `{}` (found in list key: `{}`) \"\n                                \"to `{}`\".format(v, key, raise_type))\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncreates a L{SimpleAuthenticator instance using values read from coilmq configuration.", "response": "def make_simple():\n    \"\"\"\n    Create a L{SimpleAuthenticator} instance using values read from coilmq configuration.\n\n    @return: The configured L{SimpleAuthenticator}\n    @rtype: L{SimpleAuthenticator}\n    @raise ConfigError: If there is a configuration error.\n    \"\"\"\n    authfile = config.get('coilmq', 'auth.simple.file')\n    if not authfile:\n        raise ConfigError('Missing configuration parameter: auth.simple.file')\n    sa = SimpleAuthenticator()\n    sa.from_configfile(authfile)\n    return sa"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ninitialize the authentication store from a config file.", "response": "def from_configfile(self, configfile):\n        \"\"\"\n        Initialize the authentication store from a \"config\"-style file.\n\n        Auth \"config\" file is parsed with C{ConfigParser.RawConfigParser} and must contain\n        an [auth] section which contains the usernames (keys) and passwords (values).\n\n        Example auth file::\n\n            [auth]\n            someuser = somepass\n            anotheruser = anotherpass\n\n        @param configfile: Path to config file or file-like object.\n        @type configfile: C{any}\n        @raise ValueError: If file could not be read or does not contain [auth] section.\n        \"\"\"\n        cfg = ConfigParser()\n        if hasattr(configfile, 'read'):\n            cfg.read_file(configfile)\n        else:\n            filesread = cfg.read(configfile)\n            if not filesread:\n                raise ValueError('Could not parse auth file: %s' % configfile)\n\n        if not cfg.has_section('auth'):\n            raise ValueError('Config file contains no [auth] section.')\n\n        self.store = dict(cfg.items('auth'))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nauthenticating the login and passcode.", "response": "def authenticate(self, login, passcode):\n        \"\"\"\n        Authenticate the login and passcode.\n\n        @return: Whether provided login and password match values in store.\n        @rtype: C{bool}\n        \"\"\"\n        return login in self.store and self.store[login] == passcode"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ndispatch a received frame to the appropriate internal method.", "response": "def process_frame(self, frame):\n        \"\"\"\n        Dispatches a received frame to the appropriate internal method.\n\n        @param frame: The frame that was received.\n        @type frame: C{stompclient.frame.Frame}\n        \"\"\"\n        cmd_method = frame.cmd.lower()\n\n        if not cmd_method in VALID_COMMANDS:\n            raise ProtocolError(\"Invalid STOMP command: {}\".format(frame.cmd))\n\n        method = getattr(self, cmd_method, None)\n\n        if not self.engine.connected and method not in (self.connect, self.stomp):\n            raise ProtocolError(\"Not connected.\")\n\n        try:\n            transaction = frame.headers.get('transaction')\n            if not transaction or method in (self.begin, self.commit, self.abort):\n                method(frame)\n            else:\n                if not transaction in self.engine.transactions:\n                    raise ProtocolError(\n                        \"Invalid transaction specified: %s\" % transaction)\n                self.engine.transactions[transaction].append(frame)\n        except Exception as e:\n            self.engine.log.error(\"Error processing STOMP frame: %s\" % e)\n            self.engine.log.exception(e)\n            try:\n                self.engine.connection.send_frame(ErrorFrame(str(e), str(e)))\n            except Exception as e:  # pragma: no cover\n                self.engine.log.error(\"Could not send error frame: %s\" % e)\n                self.engine.log.exception(e)\n        else:\n            # The protocol is not especially clear here (not sure why I'm surprised)\n            # about the expected behavior WRT receipts and errors.  We will assume that\n            # the RECEIPT frame should not be sent if there is an error frame.\n            # Also we'll assume that a transaction should not preclude sending the receipt\n            # frame.\n            # import pdb; pdb.set_trace()\n            if frame.headers.get('receipt') and method != self.connect:\n                self.engine.connection.send_frame(ReceiptFrame(\n                    receipt=frame.headers.get('receipt')))"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nestablishes a new connection and checks auth.", "response": "def connect(self, frame, response=None):\n        \"\"\"\n        Handle CONNECT command: Establishes a new connection and checks auth (if applicable).\n        \"\"\"\n        self.engine.log.debug(\"CONNECT\")\n\n        if self.engine.authenticator:\n            login = frame.headers.get('login')\n            passcode = frame.headers.get('passcode')\n            if not self.engine.authenticator.authenticate(login, passcode):\n                raise AuthError(\"Authentication failed for %s\" % login)\n\n        self.engine.connected = True\n\n        response = response or Frame(frames.CONNECTED)\n        response.headers['session'] = uuid.uuid4()\n\n        # TODO: Do we want to do anything special to track sessions?\n        # (Actually, I don't think the spec actually does anything with this at all.)\n        self.engine.connection.send_frame(response)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef send(self, frame):\n        dest = frame.headers.get('destination')\n        if not dest:\n            raise ProtocolError('Missing destination for SEND command.')\n\n        if dest.startswith('/queue/'):\n            self.engine.queue_manager.send(frame)\n        else:\n            self.engine.topic_manager.send(frame)", "response": "Handle the SEND command."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef subscribe(self, frame):\n        ack = frame.headers.get('ack')\n        reliable = ack and ack.lower() == 'client'\n\n        self.engine.connection.reliable_subscriber = reliable\n\n        dest = frame.headers.get('destination')\n        if not dest:\n            raise ProtocolError('Missing destination for SUBSCRIBE command.')\n\n        if dest.startswith('/queue/'):\n            self.engine.queue_manager.subscribe(self.engine.connection, dest)\n        else:\n            self.engine.topic_manager.subscribe(self.engine.connection, dest)", "response": "Handle the SUBSCRIBE command. Adds this connection to destination."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nhandles the UNSUBSCRIBE command. Removes this connection from destination.", "response": "def unsubscribe(self, frame):\n        \"\"\"\n        Handle the UNSUBSCRIBE command: Removes this connection from destination.\n        \"\"\"\n        dest = frame.headers.get('destination')\n        if not dest:\n            raise ProtocolError('Missing destination for UNSUBSCRIBE command.')\n\n        if dest.startswith('/queue/'):\n            self.engine.queue_manager.unsubscribe(self.engine.connection, dest)\n        else:\n            self.engine.topic_manager.unsubscribe(self.engine.connection, dest)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nhandles the BEGIN command.", "response": "def begin(self, frame):\n        \"\"\"\n        Handles BEGING command: Starts a new transaction.\n        \"\"\"\n        if not frame.transaction:\n            raise ProtocolError(\"Missing transaction for BEGIN command.\")\n\n        self.engine.transactions[frame.transaction] = []"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef commit(self, frame):\n        if not frame.transaction:\n            raise ProtocolError(\"Missing transaction for COMMIT command.\")\n\n        if not frame.transaction in self.engine.transactions:\n            raise ProtocolError(\"Invalid transaction: %s\" % frame.transaction)\n\n        for tframe in self.engine.transactions[frame.transaction]:\n            del tframe.headers['transaction']\n            self.process_frame(tframe)\n\n        self.engine.queue_manager.clear_transaction_frames(\n            self.engine.connection, frame.transaction)\n        del self.engine.transactions[frame.transaction]", "response": "Handles COMMIT command: Commits specified transaction."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nhandling an ABORT command.", "response": "def abort(self, frame):\n        \"\"\"\n        Handles ABORT command: Rolls back specified transaction.\n        \"\"\"\n        if not frame.transaction:\n            raise ProtocolError(\"Missing transaction for ABORT command.\")\n\n        if not frame.transaction in self.engine.transactions:\n            raise ProtocolError(\"Invalid transaction: %s\" % frame.transaction)\n\n        self.engine.queue_manager.resend_transaction_frames(\n            self.engine.connection, frame.transaction)\n        del self.engine.transactions[frame.transaction]"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef ack(self, frame):\n        if not frame.message_id:\n            raise ProtocolError(\"No message-id specified for ACK command.\")\n        self.engine.queue_manager.ack(self.engine.connection, frame)", "response": "Handles the ACK command."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef disconnect(self, frame):\n        self.engine.log.debug(\"Disconnect\")\n        self.engine.unbind()", "response": "Handles the DISCONNECT command. Unbinds the connection."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef nack(self, frame):\n        if not frame.headers.get('message-id'):\n            raise ProtocolError(\"No message-id specified for NACK command.\")\n        if not frame.headers.get('subscription'):\n            raise ProtocolError(\"No subscription specified for NACK command.\")", "response": "Handles the NACK command."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef init_config(config_file=None):\n    global config\n\n    if config_file and os.path.exists(config_file):\n        read = config.read([config_file])\n        if not read:\n            raise ValueError(\n                \"Could not read configuration from file: %s\" % config_file)", "response": "Initialize the configuration from a config file."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef init_logging(logfile=None, loglevel=logging.INFO, configfile=None):\n    # If a config file was specified, we will use that in place of the\n    # explicitly\n    use_configfile = False\n    if configfile and os.path.exists(configfile):\n        testcfg = ConfigParser()\n        read = testcfg.read(configfile)\n        use_configfile = (read and testcfg.has_section('loggers'))\n\n    if use_configfile:\n        logging.config.fileConfig(configfile)\n        if logfile:\n            msg = \"Config file conflicts with explicitly specified logfile; config file takes precedence.\"\n            logging.warn(msg)\n    else:\n        format = '%(asctime)s [%(threadName)s] %(name)s - %(levelname)s - %(message)s'\n        if logfile:\n            logging.basicConfig(\n                filename=logfile, level=loglevel, format=format)\n        else:\n            logging.basicConfig(level=loglevel, format=format)", "response": "Initializes the logging for the daemons."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nresolve a dotted name to some object.", "response": "def resolve_name(name):\n    \"\"\"\n    Resolve a dotted name to some object (usually class, module, or function).\n\n    Supported naming formats include:\n        1. path.to.module:method\n        2. path.to.module.ClassName\n\n    >>> resolve_name('coilmq.store.memory.MemoryQueue')\n    <class 'coilmq.store.memory.MemoryQueue'>\n    >>> t = resolve_name('coilmq.store.dbm.make_dbm')\n    >>> import inspect\n    >>> inspect.isfunction(t)\n    True\n    >>> t.__name__\n    'make_dbm'\n\n    @param name: The dotted name (e.g. path.to.MyClass)\n    @type name: C{str}\n\n    @return: The resolved object (class, callable, etc.) or None if not found.\n    \"\"\"\n    if ':' in name:\n        # Normalize foo.bar.baz:main to foo.bar.baz.main\n        # (since our logic below will handle that)\n        name = '%s.%s' % tuple(name.split(':'))\n\n    name = name.split('.')\n\n    used = name.pop(0)\n    found = __import__(used)\n    for n in name:\n        used = used + '.' + n\n        try:\n            found = getattr(found, n)\n        except AttributeError:\n            __import__(used)\n            found = getattr(found, n)\n\n    return found"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nhandling a new connection.", "response": "def handle(self):\n        \"\"\"\n        Handle a new socket connection.\n        \"\"\"\n        # self.request is the TCP socket connected to the client\n        try:\n            while not self.server._shutdown_request_event.is_set():\n                try:\n                    data = self.request.recv(8192)\n                    if not data:\n                        break\n                    if self.debug:\n                        self.log.debug(\"RECV: %r\" % data)\n                    self.buffer.append(data)\n\n                    for frame in self.buffer:\n                        self.log.debug(\"Processing frame: %s\" % frame)\n                        self.engine.process_frame(frame)\n                        if not self.engine.connected:\n                            raise ClientDisconnected()\n                except socket.timeout:  # pragma: no cover\n                    pass\n        except ClientDisconnected:\n            self.log.debug(\"Client disconnected, discontinuing read loop.\")\n        except Exception as e:  # pragma: no cover\n            self.log.error(\"Error receiving data (unbinding): %s\" % e)\n            self.engine.unbind()\n            raise"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nsend a frame to connected socket client.", "response": "def send_frame(self, frame):\n        \"\"\" Sends a frame to connected socket client.\n\n        @param frame: The frame to send.\n        @type frame: C{stompclient.frame.Frame}\n        \"\"\"\n        packed = frame.pack()\n        if self.debug:  # pragma: no cover\n            self.log.debug(\"SEND: %r\" % packed)\n        self.request.sendall(packed)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nclosing the socket server and any associated resources.", "response": "def server_close(self):\n        \"\"\"\n        Closes the socket server and any associated resources.\n        \"\"\"\n        self.log.debug(\"Closing the socket server connection.\")\n        TCPServer.server_close(self)\n        self.queue_manager.close()\n        self.topic_manager.close()\n        if hasattr(self.authenticator, 'close'):\n            self.authenticator.close()\n        self.shutdown()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef serve_forever(self, poll_interval=0.5):\n        self._serving_event.set()\n        self._shutdown_request_event.clear()\n        TCPServer.serve_forever(self, poll_interval=poll_interval)", "response": "Handle one request at a time until shutdown."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef create_3d_texture(width, scale):\n\tcoords = range(width)\n\ttexel = (ctypes.c_byte * width**3)()\n\thalf = 0 #width * scale / 2.0 \n\n\tfor z in coords:\n\t\tfor y in coords:\n\t\t\tfor x in coords:\n\t\t\t\tv = snoise3(x * scale - half, y * scale - half, z * scale - half, octaves=4, persistence=0.25)\n\t\t\t\ttexel[x + (y * width) + (z * width**2)] = int(v * 127.0)\n\tglPixelStorei(GL_UNPACK_ALIGNMENT, 1)\n\tglTexImage3D(GL_TEXTURE_3D, 0, GL_LUMINANCE, width, width, width, 0, \n\t\tGL_LUMINANCE, GL_BYTE, ctypes.byref(texel))\n\treturn texel", "response": "Create a grayscale 3d texture map with the specified pixel width on each side and load it into the current texture."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef randomize(self, period=None):\n\t\tif period is not None:\n\t\t\tself.period = period\n\t\tperm = list(range(self.period))\n\t\tperm_right = self.period - 1\n\t\tfor i in list(perm):\n\t\t\tj = self.randint_function(0, perm_right)\n\t\t\tperm[i], perm[j] = perm[j], perm[i]\n\t\tself.permutation = tuple(perm) * 2", "response": "Randomize the permutation table used by the noise functions. This is a utility method that randomly generates noise patterns for the same inputs."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef noise3(self, x, y, z, repeat, base=0.0):\n\t\ti = int(fmod(floor(x), repeat))\n\t\tj = int(fmod(floor(y), repeat))\n\t\tk = int(fmod(floor(z), repeat))\n\t\tii = (i + 1) % repeat\n\t\tjj = (j + 1) % repeat\n\t\tkk = (k + 1) % repeat\n\t\tif base:\n\t\t\ti += base; j += base; k += base\n\t\t\tii += base; jj += base; kk += base\n\n\t\tx -= floor(x); y -= floor(y); z -= floor(z)\n\t\tfx = x**3 * (x * (x * 6 - 15) + 10)\n\t\tfy = y**3 * (y * (y * 6 - 15) + 10)\n\t\tfz = z**3 * (z * (z * 6 - 15) + 10)\n\n\t\tperm = self.permutation\n\t\tA = perm[i]\n\t\tAA = perm[A + j]\n\t\tAB = perm[A + jj]\n\t\tB = perm[ii]\n\t\tBA = perm[B + j]\n\t\tBB = perm[B + jj]\n\t\t\n\t\treturn lerp(fz, lerp(fy, lerp(fx, grad3(perm[AA + k], x, y, z),\n\t\t\t\t\t\t\t\t\t\t  grad3(perm[BA + k], x - 1, y, z)),\n\t\t\t\t\t\t\t\t lerp(fx, grad3(perm[AB + k], x, y - 1, z),\n\t\t\t\t\t\t\t\t\t\t  grad3(perm[BB + k], x - 1, y - 1, z))),\n\t\t\t\t\t\tlerp(fy, lerp(fx, grad3(perm[AA + kk], x, y, z - 1),\n\t\t\t\t\t\t\t\t\t\t  grad3(perm[BA + kk], x - 1, y, z - 1)),\n\t\t\t\t\t\t\t\t lerp(fx, grad3(perm[AB + kk], x, y - 1, z - 1),\n\t\t\t\t\t\t\t\t\t\t  grad3(perm[BB + kk], x - 1, y - 1, z - 1))))", "response": "Tileable 3D noise.\n\t\t\n\t\trepeat specifies the integer interval in each dimension \n\t\twhen the noise pattern repeats.\n\t\t\n\t\tbase allows a different texture to be generated for\n\t\tthe same repeat interval."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef load(self):\n\t\tglTexImage3D(GL_TEXTURE_3D, 0, GL_LUMINANCE16_ALPHA16, \n\t\t\tself.width, self.width, self.width, 0, GL_LUMINANCE_ALPHA, \n\t\t\tGL_UNSIGNED_SHORT, ctypes.byref(self.data))", "response": "Load the noise texture into the current texture unit"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef compute(self, now, x, y, angle):\n\n        # Normalize angle to [-180,180]\n        output = []\n        angle = ((angle + math.pi) % (math.pi * 2)) - math.pi\n\n        for target in self.targets:\n            proposed = target.compute(now, x, y, angle)\n            if proposed:\n                output.append(proposed)\n\n        if not output:\n            output.append((0, now, inf, 0))\n            self.distance = None\n        else:\n            # order by absolute offset\n            output.sort(key=lambda i: abs(i[2]))\n            self.distance = output[-1][3]\n\n        # Only store stuff every once in awhile\n        if now - self.last_compute_time > self.update_period:\n\n            self.last_compute_time = now\n            self.send_queue.appendleft(output)\n\n        # simulate latency by delaying camera output\n        if self.send_queue:\n            output = self.send_queue[-1]\n            if now - output[0][1] > self.data_lag:\n                return self.send_queue.pop()", "response": "Compute the vision of the specified target."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nrunning Friedman s test of fixed - span smoothers from Figure 2b.", "response": "def run_friedman82_super():\n    \"\"\"Run Friedman's test of fixed-span smoothers from Figure 2b.\"\"\"\n    x, y = smoother_friedman82.build_sample_smoother_problem_friedman82()\n    plt.figure()\n    smooth = SuperSmoother()\n    smooth.specify_data_set(x, y, sort_data=True)\n    smooth.compute()\n    plt.plot(x, y, '.', label='Data')\n    plt.plot(smooth.x, smooth.smooth_result, 'o', label='Smooth')\n    plt.grid(color='0.7')\n    plt.legend(loc='upper left')\n    plt.title('Demo of SuperSmoother based on Friedman 82')\n    plt.xlabel('x')\n    plt.ylabel('y')\n    plt.savefig('sample_supersmoother_friedman82.png')\n\n    return smooth"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef main():\n\n    expr_list = [\n        \"max(-_.\u5343\u5e78\u798f\u7684\u7b11\u8138{\u0918\u094b\u0921\u093c\u093e=\u99ac,  \"\n        \"dn2=dv2,\u5343\u5e78\u798f\u7684\u7b11\u8138\u0918=\u5343\u5e78\u798f\u7684\u7b11\u8138\u0918}) gte 100 \"\n        \"times 3 && \"\n        \"(min(\u0ec0\u0eae\u0eb7\u0ead\u0e99{dn3=dv3,\u5bb6=\u0434\u043e\u043c}) < 10 or sum(biz{dn5=dv5}) >99 and \"\n        \"count(fizzle) lt 0or count(baz) > 1)\".decode('utf8'),\n\n        \"max(foo{hostname=mini-mon,\u5343=\u5343}, 120) > 100 and (max(bar)>100 \"\n        \" or max(biz)>100)\".decode('utf8'),\n\n        \"max(foo)>=100\",\n\n        \"test_metric{this=that, that =  this} < 1\",\n\n        \"max  (  3test_metric5  {  this  =  that  })  lt  5 times    3\",\n\n        \"3test_metric5 lt 3\",\n\n        \"ntp.offset > 1 or ntp.offset < -5\",\n\n        \"max(3test_metric5{it's this=that's it}) lt 5 times 3\",\n\n        \"count(log.error{test=1}, deterministic) > 1.0\",\n\n        \"count(log.error{test=1}, deterministic, 120) > 1.0\",\n\n        \"last(test_metric{hold=here}) < 13\",\n\n        \"count(log.error{test=1}, deterministic, 130) > 1.0\",\n\n        \"count(log.error{test=1}, deterministic) > 1.0 times 0\",\n    ]\n\n    for expr in expr_list:\n        print('orig expr: {}'.format(expr.encode('utf8')))\n        sub_exprs = []\n        try:\n            alarm_expr_parser = AlarmExprParser(expr)\n            sub_exprs = alarm_expr_parser.sub_expr_list\n        except Exception as ex:\n            print(\"Parse failed: {}\".format(ex))\n        for sub_expr in sub_exprs:\n            print('sub expr: {}'.format(\n                sub_expr.fmtd_sub_expr_str.encode('utf8')))\n            print('sub_expr dimensions: {}'.format(\n                sub_expr.dimensions_str.encode('utf8')))\n            print('sub_expr deterministic: {}'.format(\n                sub_expr.deterministic))\n            print('sub_expr period: {}'.format(\n                sub_expr.period))\n            print(\"\")\n        print(\"\")", "response": "Used for development and testing."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef fmtd_sub_expr_str(self):\n        result = u\"{}({}\".format(self.normalized_func,\n                                 self._metric_name)\n\n        if self._dimensions is not None:\n            result += \"{\" + self.dimensions_str + \"}\"\n\n        if self._period != _DEFAULT_PERIOD:\n            result += \", {}\".format(self._period)\n\n        result += \")\"\n\n        result += \" {} {}\".format(self._operator,\n                                  self._threshold)\n\n        if self._periods != _DEFAULT_PERIODS:\n            result += \" times {}\".format(self._periods)\n\n        return result", "response": "Get the entire sub expressions as a string with spaces."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef normalized_operator(self):\n        if self._operator.lower() == \"lt\" or self._operator == \"<\":\n            return u\"LT\"\n        elif self._operator.lower() == \"gt\" or self._operator == \">\":\n            return u\"GT\"\n        elif self._operator.lower() == \"lte\" or self._operator == \"<=\":\n            return u\"LTE\"\n        elif self._operator.lower() == \"gte\" or self._operator == \">=\":\n            return u\"GTE\"", "response": "Return the operator as one of LT GT LTE or GTE."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef theory(\n        cls,\n        motor_config: MotorModelConfig,\n        robot_mass: units.Quantity,\n        gearing: float,\n        nmotors: int = 1,\n        x_wheelbase: units.Quantity = _kitbot_wheelbase,\n        robot_width: units.Quantity = _kitbot_width,\n        robot_length: units.Quantity = _kitbot_length,\n        wheel_diameter: units.Quantity = 6 * units.inch,\n        vintercept: units.volts = 1.3 * units.volts,\n        timestep: int = 5 * units.ms,\n    ):\n        r\"\"\"\n            Use this to create the drivetrain model when you haven't measured\n            ``kv`` and ``ka`` for your robot.\n            \n            :param motor_config:    Specifications for your motor\n            :param robot_mass:      Mass of the robot\n            :param gearing:         Gear ratio .. so for a 10.74:1 ratio, you would pass 10.74\n            :param nmotors:         Number of motors per side\n            :param x_wheelbase:     Wheelbase of the robot\n            :param robot_width:     Width of the robot\n            :param robot_length:    Length of the robot\n            :param wheel_diameter:  Diameter of the wheel\n            :param vintercept:      The minimum voltage required to generate enough\n                                    torque to overcome steady-state friction (see the\n                                    paper for more details)\n            :param timestep_ms:     Model computation timestep\n            \n            Computation of ``kv`` and ``ka`` are done as follows:\n            \n            * :math:`\\omega_{free}` is the free speed of the motor\n            * :math:`\\tau_{stall}` is the stall torque of the motor\n            * :math:`n` is the number of drive motors\n            * :math:`m_{robot}` is the mass of the robot\n            * :math:`d_{wheels}` is the diameter of the robot's wheels\n            * :math:`r_{gearing}` is the total gear reduction between the motors and the wheels\n            * :math:`V_{max}` is the nominal max voltage of the motor\n            \n            .. math::\n            \n                velocity_{max} = \\frac{\\omega_{free} \\cdot \\pi \\cdot d_{wheels} }{r_{gearing}}\n                \n                acceleration_{max} = \\frac{2 \\cdot n \\cdot \\tau_{stall} \\cdot r_{gearing} }{d_{wheels} \\cdot m_{robot}}\n                \n                k_{v} = \\frac{V_{max}}{velocity_{max}}\n                \n                k_{a} = \\frac{V_{max}}{acceleration_{max}}\n        \"\"\"\n\n        # Check input units\n        # -> pint doesn't seem to support default args in check()\n        Helpers.ensure_mass(robot_mass)\n        Helpers.ensure_length(x_wheelbase)\n        Helpers.ensure_length(robot_width)\n        Helpers.ensure_length(robot_length)\n        Helpers.ensure_length(wheel_diameter)\n\n        max_velocity = (motor_config.freeSpeed * math.pi * wheel_diameter) / gearing\n        max_acceleration = (2.0 * nmotors * motor_config.stallTorque * gearing) / (\n            wheel_diameter * robot_mass\n        )\n\n        Helpers.ensure_velocity(max_velocity)\n        Helpers.ensure_acceleration(max_acceleration)\n\n        kv = motor_config.nominalVoltage / max_velocity\n        ka = motor_config.nominalVoltage / max_acceleration\n\n        kv = units.tm_kv.from_(kv, name=\"kv\")\n        ka = units.tm_ka.from_(ka, name=\"ka\")\n\n        logger.info(\n            \"Motor config: %d %s motors @ %.2f gearing with %.1f diameter wheels\",\n            nmotors,\n            motor_config.name,\n            gearing,\n            wheel_diameter.m,\n        )\n\n        logger.info(\n            \"- Theoretical: vmax=%.3f ft/s, amax=%.3f ft/s^2, kv=%.3f, ka=%.3f\",\n            max_velocity.m_as(units.foot / units.second),\n            max_acceleration.m_as(units.foot / units.second ** 2),\n            kv.m,\n            ka.m,\n        )\n\n        return cls(\n            motor_config,\n            robot_mass,\n            x_wheelbase,\n            robot_width,\n            robot_length,\n            kv,\n            ka,\n            vintercept,\n            kv,\n            ka,\n            vintercept,\n            timestep,\n        )", "response": "Return a new instance of the base class for the theory of the given base class."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngiving motor values and the amount of time elapsed since this was last called, retrieves the x,y,angle that the robot has moved. Pass these values to :meth:`PhysicsInterface.distance_drive`. To update your encoders, use the ``l_position`` and ``r_position`` attributes of this object. :param l_motor: Left motor value (-1 to 1); -1 is forward :param r_motor: Right motor value (-1 to 1); 1 is forward :param tm_diff: Elapsed time since last call to this function :returns: x travel, y travel, angle turned (radians) .. note:: If you are using more than 2 motors, it is assumed that all motors on each side are set to the same speed. Only pass in one of the values from each side", "response": "def get_distance(\n        self, l_motor: float, r_motor: float, tm_diff: float\n    ) -> typing.Tuple[float, float]:\n        \"\"\"\n            Given motor values and the amount of time elapsed since this was last\n            called, retrieves the x,y,angle that the robot has moved. Pass these\n            values to :meth:`PhysicsInterface.distance_drive`.\n            \n            To update your encoders, use the ``l_position`` and ``r_position``\n            attributes of this object.\n        \n            :param l_motor:    Left motor value (-1 to 1); -1 is forward\n            :param r_motor:    Right motor value (-1 to 1); 1 is forward\n            :param tm_diff:    Elapsed time since last call to this function\n\n            :returns: x travel, y travel, angle turned (radians)\n            \n            .. note:: If you are using more than 2 motors, it is assumed that\n                      all motors on each side are set to the same speed. Only\n                      pass in one of the values from each side\n        \"\"\"\n\n        # This isn't quite right, the right way is to use matrix math. However,\n        # this is Good Enough for now...\n        x = 0\n        y = 0\n        angle = 0\n\n        # split the time difference into timestep_ms steps\n        total_time = int(tm_diff * 100000)\n        steps = total_time // self._timestep\n        remainder = total_time % self._timestep\n        step = self._timestep / 100000.0\n        if remainder:\n            last_step = remainder / 100000.0\n            steps += 1\n        else:\n            last_step = step\n\n        while steps != 0:\n            if steps == 1:\n                tm_diff = last_step\n            else:\n                tm_diff = step\n\n            steps -= 1\n\n            l = self._lmotor.compute(-l_motor, tm_diff)\n            r = self._rmotor.compute(r_motor, tm_diff)\n\n            # Tank drive motion equations\n            velocity = (l + r) * 0.5\n\n            # Thanks to Tyler Veness for fixing the rotation equation, via conservation\n            # of angular momentum equations\n            # -> omega = b * m * (l - r) / J\n            rotation = self._bm * (l - r) / self._inertia\n\n            distance = velocity * tm_diff\n            turn = rotation * tm_diff\n\n            x += distance * math.cos(angle)\n            y += distance * math.sin(angle)\n            angle += turn\n\n        return x, y, angle"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nrun Friedman s test from Figure 2b.", "response": "def validate_basic_smoother():\n    \"\"\"Run Friedman's test from Figure 2b.\"\"\"\n    x, y = sort_data(*smoother_friedman82.build_sample_smoother_problem_friedman82())\n    plt.figure()\n    # plt.plot(x, y, '.', label='Data')\n    for span in smoother.DEFAULT_SPANS:\n        my_smoother = smoother.perform_smooth(x, y, span)\n        friedman_smooth, _resids = run_friedman_smooth(x, y, span)\n        plt.plot(x, my_smoother.smooth_result, '.-', label='pyace span = {0}'.format(span))\n        plt.plot(x, friedman_smooth, '.-', label='Friedman span = {0}'.format(span))\n    finish_plot()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncompare residuals with basic smoother.", "response": "def validate_basic_smoother_resid():\n    \"\"\"Compare residuals.\"\"\"\n    x, y = sort_data(*smoother_friedman82.build_sample_smoother_problem_friedman82())\n    plt.figure()\n    for span in smoother.DEFAULT_SPANS:\n        my_smoother = smoother.perform_smooth(x, y, span)\n        _friedman_smooth, resids = run_friedman_smooth(x, y, span)  # pylint: disable=unused-variable\n        plt.plot(x, my_smoother.cross_validated_residual, '.-',\n                 label='pyace span = {0}'.format(span))\n        plt.plot(x, resids, '.-', label='Friedman span = {0}'.format(span))\n    finish_plot()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nvalidating the supersmoother with extra bass.", "response": "def validate_supersmoother_bass():\n    \"\"\"Validate the supersmoother with extra bass.\"\"\"\n    x, y = smoother_friedman82.build_sample_smoother_problem_friedman82()\n    plt.figure()\n    plt.plot(x, y, '.', label='Data')\n    for bass in range(0, 10, 3):\n        smooth = supersmoother.SuperSmoother()\n        smooth.set_bass_enhancement(bass)\n        smooth.specify_data_set(x, y)\n        smooth.compute()\n        plt.plot(x, smooth.smooth_result, '.', label='Bass = {0}'.format(bass))\n        # pylab.plot(self.x, smoother.smooth_result, label='Bass = {0}'.format(bass))\n    finish_plot()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef validate_average_best_span():\n    N = 200\n    num_trials = 400\n    avg = numpy.zeros(N)\n    for i in range(num_trials):\n        x, y = smoother_friedman82.build_sample_smoother_problem_friedman82(N=N)\n        my_smoother = smoother.perform_smooth(\n            x, y, smoother_cls=supersmoother.SuperSmoother\n        )\n        avg += my_smoother._smoothed_best_spans.smooth_result\n        if not (i + 1) % 20:\n            print(i + 1)\n    avg /= num_trials\n    plt.plot(my_smoother.x, avg, '.', label='Average JCV')\n    finish_plot()", "response": "Figure 2d? from Friedman82."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef validate_known_curve():\n    plt.figure()\n    N = 100\n    x = numpy.linspace(-1, 1, N)\n    y = numpy.sin(4 * x)\n    smoother.DEFAULT_BASIC_SMOOTHER = smoother.BasicFixedSpanSmootherSlowUpdate\n    smooth = smoother.perform_smooth(x, y, smoother_cls=supersmoother.SuperSmoother)\n    plt.plot(x, smooth.smooth_result, label='Slow')\n    smoother.DEFAULT_BASIC_SMOOTHER = smoother.BasicFixedSpanSmoother\n    smooth = smoother.perform_smooth(x, y, smoother_cls=supersmoother.SuperSmoother)\n    plt.plot(x, smooth.smooth_result, label='Fast')\n    plt.plot(x, y, '.', label='data')\n    plt.legend()\n    plt.show()", "response": "Validate on a sin function."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef run_freidman_supsmu(x, y, bass_enhancement=0.0):\n    N = len(x)\n    weight = numpy.ones(N)\n    results = numpy.zeros(N)\n    flags = numpy.zeros((N, 7))\n    mace.supsmu(x, y, weight, 1, 0.0, bass_enhancement, results, flags)\n    return results", "response": "Run the FORTRAN supersmoother."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nrun the FORTRAN smoother.", "response": "def run_friedman_smooth(x, y, span):\n    \"\"\"Run the FORTRAN smoother.\"\"\"\n    N = len(x)\n    weight = numpy.ones(N)\n    results = numpy.zeros(N)\n    residuals = numpy.zeros(N)\n    mace.smooth(x, y, weight, span, 1, 1e-7, results, residuals)\n    return results, residuals"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef run_mace_smothr(x, y, bass_enhancement=0.0):  # pylint: disable=unused-argument\n    N = len(x)\n    weight = numpy.ones(N)\n    results = numpy.zeros(N)\n    flags = numpy.zeros((N, 7))\n    mace.smothr(1, x, y, weight, results, flags)\n    return results", "response": "Run the FORTRAN SMOTHR."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting or create a connection to a broker using host and port", "response": "def _get_conn(self, host, port):\n        \"\"\"Get or create a connection to a broker using host and port\"\"\"\n        host_key = (host, port)\n        if host_key not in self.conns:\n            self.conns[host_key] = KafkaConnection(\n                host,\n                port,\n                timeout=self.timeout\n            )\n\n        return self.conns[host_key]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the coordinator broker for a given consumer group.", "response": "def _get_coordinator_for_group(self, group):\n        \"\"\"\n        Returns the coordinator broker for a consumer group.\n\n        ConsumerCoordinatorNotAvailableCode will be raised if the coordinator\n        does not currently exist for the group.\n\n        OffsetsLoadInProgressCode is raised if the coordinator is available\n        but is still loading offsets from the internal topic\n        \"\"\"\n\n        resp = self.send_consumer_metadata_request(group)\n\n        # If there's a problem with finding the coordinator, raise the\n        # provided error\n        kafka_common.check_error(resp)\n\n        # Otherwise return the BrokerMetadata\n        return BrokerMetadata(resp.nodeId, resp.host, resp.port)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsends a request to one of the available brokers.", "response": "def _send_broker_unaware_request(self, payloads, encoder_fn, decoder_fn):\n        \"\"\"\n        Attempt to send a broker-agnostic request to one of the available\n        brokers. Keep trying until you succeed.\n        \"\"\"\n        for (host, port) in self.hosts:\n            requestId = self._next_id()\n            log.debug('Request %s: %s', requestId, payloads)\n            try:\n                conn = self._get_conn(host, port)\n                request = encoder_fn(client_id=self.client_id,\n                                     correlation_id=requestId,\n                                     payloads=payloads)\n\n                conn.send(requestId, request)\n                response = conn.recv(requestId)\n                decoded = decoder_fn(response)\n                log.debug('Response %s: %s', requestId, decoded)\n                return decoded\n\n            except Exception:\n                log.exception('Error sending request [%s] to server %s:%s, '\n                              'trying next server', requestId, host, port)\n\n        raise KafkaUnavailableError('All servers failed to process request')"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _send_broker_aware_request(self, payloads, encoder_fn, decoder_fn):\n        # encoders / decoders do not maintain ordering currently\n        # so we need to keep this so we can rebuild order before returning\n        original_ordering = [(p.topic, p.partition) for p in payloads]\n\n        # Group the requests by topic+partition\n        brokers_for_payloads = []\n        payloads_by_broker = collections.defaultdict(list)\n\n        responses = {}\n        for payload in payloads:\n            try:\n                leader = self._get_leader_for_partition(payload.topic,\n                                                        payload.partition)\n                payloads_by_broker[leader].append(payload)\n                brokers_for_payloads.append(leader)\n            except KafkaUnavailableError as e:\n                log.warning('KafkaUnavailableError attempting to send request '\n                            'on topic %s partition %d', payload.topic, payload.partition)\n                topic_partition = (payload.topic, payload.partition)\n                responses[topic_partition] = FailedPayloadsError(payload)\n\n        # For each broker, send the list of request payloads\n        # and collect the responses and errors\n        broker_failures = []\n\n        # For each KafkaConnection keep the real socket so that we can use\n        # a select to perform unblocking I/O\n        connections_by_socket = {}\n        for broker, payloads in payloads_by_broker.items():\n            requestId = self._next_id()\n            log.debug('Request %s to %s: %s', requestId, broker, payloads)\n            request = encoder_fn(client_id=self.client_id,\n                                 correlation_id=requestId, payloads=payloads)\n\n            # Send the request, recv the response\n            try:\n                conn = self._get_conn(broker.host.decode('utf-8'), broker.port)\n                conn.send(requestId, request)\n\n            except ConnectionError as e:\n                broker_failures.append(broker)\n                log.warning('ConnectionError attempting to send request %s '\n                            'to server %s: %s', requestId, broker, e)\n\n                for payload in payloads:\n                    topic_partition = (payload.topic, payload.partition)\n                    responses[topic_partition] = FailedPayloadsError(payload)\n\n            # No exception, try to get response\n            else:\n\n                # decoder_fn=None signal that the server is expected to not\n                # send a response.  This probably only applies to\n                # ProduceRequest w/ acks = 0\n                if decoder_fn is None:\n                    log.debug('Request %s does not expect a response '\n                              '(skipping conn.recv)', requestId)\n                    for payload in payloads:\n                        topic_partition = (payload.topic, payload.partition)\n                        responses[topic_partition] = None\n                    continue\n                else:\n                    connections_by_socket[conn.get_connected_socket()] = (conn, broker, requestId)\n\n        conn = None\n        while connections_by_socket:\n            sockets = connections_by_socket.keys()\n            rlist, _, _ = select.select(sockets, [], [], None)\n            conn, broker, requestId = connections_by_socket.pop(rlist[0])\n            try:\n                response = conn.recv(requestId)\n            except ConnectionError as e:\n                broker_failures.append(broker)\n                log.warning('ConnectionError attempting to receive a '\n                            'response to request %s from server %s: %s',\n                            requestId, broker, e)\n\n                for payload in payloads_by_broker[broker]:\n                    topic_partition = (payload.topic, payload.partition)\n                    responses[topic_partition] = FailedPayloadsError(payload)\n\n            else:\n                _resps = []\n                for payload_response in decoder_fn(response):\n                    topic_partition = (payload_response.topic,\n                                       payload_response.partition)\n                    responses[topic_partition] = payload_response\n                    _resps.append(payload_response)\n                log.debug('Response %s: %s', requestId, _resps)\n\n        # Connection errors generally mean stale metadata\n        # although sometimes it means incorrect api request\n        # Unfortunately there is no good way to tell the difference\n        # so we'll just reset metadata on all errors to be safe\n        if broker_failures:\n            self.reset_all_metadata()\n\n        # Return responses in the same order as provided\n        return [responses[tp] for tp in original_ordering]", "response": "Send a list of payloads to the broker for that topic + partition using the supplied encode and decode functions."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsending a list of requests to the consumer coordinator for the specified group and list of payloads.", "response": "def _send_consumer_aware_request(self, group, payloads, encoder_fn, decoder_fn):\n        \"\"\"\n        Send a list of requests to the consumer coordinator for the group\n        specified using the supplied encode/decode functions. As the payloads\n        that use consumer-aware requests do not contain the group (e.g.\n        OffsetFetchRequest), all payloads must be for a single group.\n\n        Arguments:\n\n        group: the name of the consumer group (str) the payloads are for\n        payloads: list of object-like entities with topic (str) and\n            partition (int) attributes; payloads with duplicate\n            topic+partition are not supported.\n\n        encode_fn: a method to encode the list of payloads to a request body,\n            must accept client_id, correlation_id, and payloads as\n            keyword arguments\n\n        decode_fn: a method to decode a response body into response objects.\n            The response objects must be object-like and have topic\n            and partition attributes\n\n        Returns:\n\n        List of response objects in the same order as the supplied payloads\n        \"\"\"\n        # encoders / decoders do not maintain ordering currently\n        # so we need to keep this so we can rebuild order before returning\n        original_ordering = [(p.topic, p.partition) for p in payloads]\n\n        broker = self._get_coordinator_for_group(group)\n\n        # Send the list of request payloads and collect the responses and\n        # errors\n        responses = {}\n        requestId = self._next_id()\n        log.debug('Request %s to %s: %s', requestId, broker, payloads)\n        request = encoder_fn(client_id=self.client_id,\n                             correlation_id=requestId, payloads=payloads)\n\n        # Send the request, recv the response\n        try:\n            conn = self._get_conn(broker.host.decode('utf-8'), broker.port)\n            conn.send(requestId, request)\n\n        except ConnectionError as e:\n            log.warning('ConnectionError attempting to send request %s '\n                        'to server %s: %s', requestId, broker, e)\n\n            for payload in payloads:\n                topic_partition = (payload.topic, payload.partition)\n                responses[topic_partition] = FailedPayloadsError(payload)\n\n        # No exception, try to get response\n        else:\n\n            # decoder_fn=None signal that the server is expected to not\n            # send a response.  This probably only applies to\n            # ProduceRequest w/ acks = 0\n            if decoder_fn is None:\n                log.debug('Request %s does not expect a response '\n                          '(skipping conn.recv)', requestId)\n                for payload in payloads:\n                    topic_partition = (payload.topic, payload.partition)\n                    responses[topic_partition] = None\n                return []\n\n            try:\n                response = conn.recv(requestId)\n            except ConnectionError as e:\n                log.warning('ConnectionError attempting to receive a '\n                            'response to request %s from server %s: %s',\n                            requestId, broker, e)\n\n                for payload in payloads:\n                    topic_partition = (payload.topic, payload.partition)\n                    responses[topic_partition] = FailedPayloadsError(payload)\n\n            else:\n                _resps = []\n                for payload_response in decoder_fn(response):\n                    topic_partition = (payload_response.topic,\n                                       payload_response.partition)\n                    responses[topic_partition] = payload_response\n                    _resps.append(payload_response)\n                log.debug('Response %s: %s', requestId, _resps)\n\n        # Return responses in the same order as provided\n        return [responses[tp] for tp in original_ordering]"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating an inactive copy of the client object suitable for passing to a separate thread.", "response": "def copy(self):\n        \"\"\"\n        Create an inactive copy of the client object, suitable for passing\n        to a separate thread.\n\n        Note that the copied connections are not initialized, so reinit() must\n        be called on the returned copy.\n        \"\"\"\n        c = copy.deepcopy(self)\n        for key in c.conns:\n            c.conns[key] = self.conns[key].copy()\n        return c"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nloading broker and topic - partition metadata for the specified topics.", "response": "def load_metadata_for_topics(self, *topics):\n        \"\"\"\n        Fetch broker and topic-partition metadata from the server,\n        and update internal data:\n        broker list, topic/partition list, and topic/parition -> broker map\n\n        This method should be called after receiving any error\n\n        Arguments:\n            *topics (optional): If a list of topics is provided,\n                the metadata refresh will be limited to the specified topics only.\n\n        Exceptions:\n        ----------\n        If the broker is configured to not auto-create topics,\n        expect UnknownTopicOrPartitionError for topics that don't exist\n\n        If the broker is configured to auto-create topics,\n        expect LeaderNotAvailableError for new topics\n        until partitions have been initialized.\n\n        Exceptions *will not* be raised in a full refresh (i.e. no topic list)\n        In this case, error codes will be logged as errors\n\n        Partition-level errors will also not be raised here\n        (a single partition w/o a leader, for example)\n        \"\"\"\n        topics = [kafka_bytestring(t) for t in topics]\n\n        if topics:\n            for topic in topics:\n                self.reset_topic_metadata(topic)\n        else:\n            self.reset_all_metadata()\n\n        resp = self.send_metadata_request(topics)\n\n        log.debug('Updating broker metadata: %s', resp.brokers)\n        log.debug('Updating topic metadata: %s', resp.topics)\n\n        self.brokers = dict([(broker.nodeId, broker)\n                             for broker in resp.brokers])\n\n        for topic_metadata in resp.topics:\n            topic = topic_metadata.topic\n            partitions = topic_metadata.partitions\n\n            # Errors expected for new topics\n            try:\n                kafka_common.check_error(topic_metadata)\n            except (UnknownTopicOrPartitionError, LeaderNotAvailableError) as e:\n\n                # Raise if the topic was passed in explicitly\n                if topic in topics:\n                    raise\n\n                # Otherwise, just log a warning\n                log.error('Error loading topic metadata for %s: %s', topic, type(e))\n                continue\n\n            self.topic_partitions[topic] = {}\n            for partition_metadata in partitions:\n                partition = partition_metadata.partition\n                leader = partition_metadata.leader\n\n                self.topic_partitions[topic][partition] = partition_metadata\n\n                # Populate topics_to_brokers dict\n                topic_part = TopicAndPartition(topic, partition)\n\n                # Check for partition errors\n                try:\n                    kafka_common.check_error(partition_metadata)\n\n                # If No Leader, topics_to_brokers topic_partition -> None\n                except LeaderNotAvailableError:\n                    log.error('No leader for topic %s partition %d', topic, partition)\n                    self.topics_to_brokers[topic_part] = None\n                    continue\n                # If one of the replicas is unavailable -- ignore\n                # this error code is provided for admin purposes only\n                # we never talk to replicas, only the leader\n                except ReplicaNotAvailableError:\n                    log.debug('Some (non-leader) replicas not available for topic %s partition %d',\n                              topic, partition)\n\n                # If Known Broker, topic_partition -> BrokerMetadata\n                if leader in self.brokers:\n                    self.topics_to_brokers[topic_part] = self.brokers[leader]\n\n                # If Unknown Broker, fake BrokerMetadata so we dont lose the id\n                # (not sure how this could happen. server could be in bad state)\n                else:\n                    self.topics_to_brokers[topic_part] = BrokerMetadata(\n                        leader, None, None\n                    )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _partition(self):\n\n        # KazooClient and SetPartitioner objects need to be instantiated after\n        # the consumer process has forked.  Instantiating prior to forking\n        # gives the appearance that things are working but after forking the\n        # connection to zookeeper is lost and no state changes are visible\n\n        if not self._kazoo_client:\n            self._kazoo_client = KazooClient(hosts=self._zookeeper_url)\n            self._kazoo_client.start()\n\n            state_change_event = threading.Event()\n\n            self._set_partitioner = (\n                SetPartitioner(self._kazoo_client,\n                               path=self._zookeeper_path,\n                               set=self._consumer.fetch_offsets.keys(),\n                               state_change_event=state_change_event,\n                               identifier=str(datetime.datetime.now())))\n\n        try:\n            while 1:\n                if self._set_partitioner.failed:\n                    raise Exception(\"Failed to acquire partition\")\n\n                elif self._set_partitioner.release:\n                    log.info(\"Releasing locks on partition set {} \"\n                             \"for topic {}\".format(self._partitions,\n                                                   self._kafka_topic))\n                    self._set_partitioner.release_set()\n\n                    self._partitions = []\n\n                elif self._set_partitioner.acquired:\n                    if not self._partitions:\n                        self._partitions = [p for p in self._set_partitioner]\n\n                        if not self._partitions:\n                            log.info(\"Not assigned any partitions on topic {},\"\n                                     \" waiting for a Partitioner state change\"\n                                     .format(self._kafka_topic))\n                            state_change_event.wait()\n                            state_change_event.clear()\n                            continue\n\n                        log.info(\"Acquired locks on partition set {} \"\n                                 \"for topic {}\".format(self._partitions, self._kafka_topic))\n\n                        # Reconstruct the kafka consumer object because the\n                        # consumer has no API that allows the set of partitons\n                        # to be updated outside of construction.\n                        self._consumer.stop()\n                        self._consumer = self._create_kafka_consumer(self._partitions)\n                        return\n\n                elif self._set_partitioner.allocating:\n                    log.info(\"Waiting to acquire locks on partition set\")\n                    self._set_partitioner.wait_for_acquire()\n\n        except Exception:\n            log.exception('KafkaConsumer encountered fatal exception '\n                          'processing messages.')\n            raise", "response": "Consume messages from kafka using the Kazoo SetPartitioner and return a list of KafkaConsumer objects."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef drive(self, speed, rotation_speed, tm_diff):\n\n        # if the robot is disabled, don't do anything\n        if not self.robot_enabled:\n            return\n\n        distance = speed * tm_diff\n        angle = rotation_speed * tm_diff\n\n        x = distance * math.cos(angle)\n        y = distance * math.sin(angle)\n\n        self.distance_drive(x, y, angle)", "response": "Drive the robot in the simulation field."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncalls this from your :func:`PhysicsEngine.update_sim` function. Will update the robot's position on the simulation field. This moves the robot using a velocity vector relative to the robot instead of by speed/rotation speed. :param vx: Speed in x direction relative to robot in ft/s :param vy: Speed in y direction relative to robot in ft/s :param vw: Clockwise rotational speed in rad/s :param tm_diff: Amount of time speed was traveled", "response": "def vector_drive(self, vx, vy, vw, tm_diff):\n        \"\"\"Call this from your :func:`PhysicsEngine.update_sim` function.\n           Will update the robot's position on the simulation field.\n           \n           This moves the robot using a velocity vector relative to the robot\n           instead of by speed/rotation speed.\n           \n           :param vx: Speed in x direction relative to robot in ft/s\n           :param vy: Speed in y direction relative to robot in ft/s\n           :param vw: Clockwise rotational speed in rad/s\n           :param tm_diff:         Amount of time speed was traveled\n        \"\"\"\n\n        # if the robot is disabled, don't do anything\n        if not self.robot_enabled:\n            return\n\n        angle = vw * tm_diff\n        vx = vx * tm_diff\n        vy = vy * tm_diff\n\n        x = vx * math.sin(angle) + vy * math.cos(angle)\n        y = vx * math.cos(angle) + vy * math.sin(angle)\n\n        self.distance_drive(x, y, angle)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef distance_drive(self, x, y, angle):\n        with self._lock:\n            self.vx += x\n            self.vy += y\n            self.angle += angle\n\n            c = math.cos(self.angle)\n            s = math.sin(self.angle)\n\n            self.x += x * c - y * s\n            self.y += x * s + y * c\n\n            self._update_gyros(angle)", "response": "This function updates the robot s position and angle based on the distance of the robot."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the current position of the robot.", "response": "def get_position(self):\n        \"\"\"\n            :returns: Robot's current position on the field as `(x,y,angle)`.\n                      `x` and `y` are specified in feet, `angle` is in radians\n        \"\"\"\n        with self._lock:\n            return self.x, self.y, self.angle"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the distance and angle offset of the given x y coordinate.", "response": "def get_offset(self, x, y):\n        \"\"\"\n            Computes how far away and at what angle a coordinate is\n            located.\n            \n            Distance is returned in feet, angle is returned in degrees\n        \n            :returns: distance,angle offset of the given x,y coordinate\n            \n            .. versionadded:: 2018.1.7\n        \"\"\"\n        with self._lock:\n            dx = self.x - x\n            dy = self.y - y\n\n        distance = math.hypot(dx, dy)\n        angle = math.atan2(dy, dx)\n        return distance, math.degrees(angle)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncheck if the robot code called Wait at some point", "response": "def _check_sleep(self, idx):\n        \"\"\"This ensures that the robot code called Wait() at some point\"\"\"\n\n        # TODO: There are some cases where it would be ok to do this...\n        if not self.fake_time.slept[idx]:\n            errstr = (\n                \"%s() function is not calling wpilib.Timer.delay() in its loop!\"\n                % self.mode_map[self.mode]\n            )\n            raise RuntimeError(errstr)\n\n        self.fake_time.slept[idx] = False"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef two_motor_drivetrain(l_motor, r_motor, x_wheelbase=2, speed=5, deadzone=None):\n    return TwoMotorDrivetrain(x_wheelbase, speed, deadzone).get_vector(l_motor, r_motor)", "response": "Return two motors drivetrain."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef four_motor_drivetrain(\n    lr_motor, rr_motor, lf_motor, rf_motor, x_wheelbase=2, speed=5, deadzone=None\n):\n    \"\"\"\n        .. deprecated:: 2018.2.0\n           Use :class:`FourMotorDrivetrain` instead\n    \"\"\"\n    return FourMotorDrivetrain(x_wheelbase, speed, deadzone).get_vector(\n        lr_motor, rr_motor, lf_motor, rf_motor\n    )", "response": "Get a FourMotorDrivetrain vector."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef mecanum_drivetrain(\n    lr_motor,\n    rr_motor,\n    lf_motor,\n    rf_motor,\n    x_wheelbase=2,\n    y_wheelbase=3,\n    speed=5,\n    deadzone=None,\n):\n    \"\"\"\n        .. deprecated:: 2018.2.0\n           Use :class:`MecanumDrivetrain` instead\n    \"\"\"\n    return MecanumDrivetrain(x_wheelbase, y_wheelbase, speed, deadzone).get_vector(\n        lr_motor, rr_motor, lf_motor, rf_motor\n    )", "response": ".. deprecated:: 2018.2.0\n           Use :class:`MecanumDrivetrain` instead"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_vector(self, l_motor: float, r_motor: float) -> typing.Tuple[float, float]:\n        if self.deadzone:\n            l_motor = self.deadzone(l_motor)\n            r_motor = self.deadzone(r_motor)\n\n        l = -l_motor * self.speed\n        r = r_motor * self.speed\n\n        # Motion equations\n        fwd = (l + r) * 0.5\n        rcw = (l - r) / float(self.x_wheelbase)\n\n        self.l_speed = l\n        self.r_speed = r\n        return fwd, rcw", "response": "Gets the vector of distance and speed for your robot."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the vector of the robot in the current state.", "response": "def get_vector(\n        self, lr_motor: float, rr_motor: float, lf_motor: float, rf_motor: float\n    ) -> typing.Tuple[float, float]:\n        \"\"\"\n            :param lr_motor:   Left rear motor value (-1 to 1); -1 is forward\n            :param rr_motor:   Right rear motor value (-1 to 1); 1 is forward\n            :param lf_motor:   Left front motor value (-1 to 1); -1 is forward\n            :param rf_motor:   Right front motor value (-1 to 1); 1 is forward\n            \n            :returns: speed of robot (ft/s), clockwise rotation of robot (radians/s)\n        \"\"\"\n\n        if self.deadzone:\n            lf_motor = self.deadzone(lf_motor)\n            lr_motor = self.deadzone(lr_motor)\n            rf_motor = self.deadzone(rf_motor)\n            rr_motor = self.deadzone(rr_motor)\n\n        l = -(lf_motor + lr_motor) * 0.5 * self.speed\n        r = (rf_motor + rr_motor) * 0.5 * self.speed\n\n        # Motion equations\n        fwd = (l + r) * 0.5\n        rcw = (l - r) / float(self.x_wheelbase)\n\n        self.l_speed = l\n        self.r_speed = r\n        return fwd, rcw"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting the vector of the robot from the given motors.", "response": "def get_vector(\n        self, lr_motor: float, rr_motor: float, lf_motor: float, rf_motor: float\n    ) -> typing.Tuple[float, float, float]:\n        \"\"\"\n            Given motor values, retrieves the vector of (distance, speed) for your robot\n        \n            :param lr_motor:   Left rear motor value (-1 to 1); 1 is forward\n            :param rr_motor:   Right rear motor value (-1 to 1); 1 is forward\n            :param lf_motor:   Left front motor value (-1 to 1); 1 is forward\n            :param rf_motor:   Right front motor value (-1 to 1); 1 is forward\n            \n            :returns: Speed of robot in x (ft/s), Speed of robot in y (ft/s),\n                      clockwise rotation of robot (radians/s)\n        \"\"\"\n        #\n        # From http://www.chiefdelphi.com/media/papers/download/2722 pp7-9\n        # [F] [omega](r) = [V]\n        #\n        # F is\n        # .25  .25  .25 .25\n        # -.25 .25 -.25 .25\n        # -.25k -.25k .25k .25k\n        #\n        # omega is\n        # [lf lr rr rf]\n\n        if self.deadzone:\n            lf_motor = self.deadzone(lf_motor)\n            lr_motor = self.deadzone(lr_motor)\n            rf_motor = self.deadzone(rf_motor)\n            rr_motor = self.deadzone(rr_motor)\n\n        # Calculate speed of each wheel\n        lr = lr_motor * self.speed\n        rr = rr_motor * self.speed\n        lf = lf_motor * self.speed\n        rf = rf_motor * self.speed\n\n        # Calculate K\n        k = abs(self.x_wheelbase / 2.0) + abs(self.y_wheelbase / 2.0)\n\n        # Calculate resulting motion\n        Vy = 0.25 * (lf + lr + rr + rf)\n        Vx = 0.25 * (lf + -lr + rr + -rf)\n        Vw = (0.25 / k) * (lf + lr + -rr + -rf)\n\n        self.lr_speed = lr\n        self.rr_speed = rr\n        self.lf_speed = lf\n        self.rf_speed = rf\n        return Vx, Vy, Vw"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef connect_mysql(host, port, user, password, database):\n    return pymysql.connect(\n        host=host, port=port,\n        user=user, passwd=password,\n        db=database\n    )", "response": "Connect to MySQL with retries."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef main():\n    logger.info('Waiting for database: `%s`', MYSQL_DB)\n\n    connect_mysql(\n        host=MYSQL_HOST, port=MYSQL_PORT,\n        user=MYSQL_USER, password=MYSQL_PASSWORD,\n        database=MYSQL_DB\n    )\n\n    logger.info('Database `%s` found', MYSQL_DB)", "response": "Start main part of the wait script."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ndefine input to ACE.", "response": "def specify_data_set(self, x_input, y_input):\n        \"\"\"\n        Define input to ACE.\n\n        Parameters\n        ----------\n        x_input : list\n            list of iterables, one for each independent variable\n        y_input : array\n            the dependent observations\n        \"\"\"\n        self.x = x_input\n        self.y = y_input"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef solve(self):\n        self._initialize()\n        while self._outer_error_is_decreasing() and self._outer_iters < MAX_OUTERS:\n            print('* Starting outer iteration {0:03d}. Current err = {1:12.5E}'\n                  ''.format(self._outer_iters, self._last_outer_error))\n            self._iterate_to_update_x_transforms()\n            self._update_y_transform()\n            self._outer_iters += 1", "response": "Run the ACE calculational loop."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _initialize(self):\n        self.y_transform = self.y - numpy.mean(self.y)\n        self.y_transform /= numpy.std(self.y_transform)\n        self.x_transforms = [numpy.zeros(len(self.y)) for _xi in self.x]\n        self._compute_sorted_indices()", "response": "Set up and normalize initial data once input data is specified."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _compute_sorted_indices(self):\n        sorted_indices = []\n        for to_sort in [self.y] + self.x:\n            data_w_indices = [(val, i) for (i, val) in enumerate(to_sort)]\n            data_w_indices.sort()\n            sorted_indices.append([i for val, i in data_w_indices])\n        # save in meaningful variable names\n        self._yi_sorted = sorted_indices[0]  # list (like self.y)\n        self._xi_sorted = sorted_indices[1:]", "response": "Compute the sorted indices of the possible smoothers."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _outer_error_is_decreasing(self):\n        is_decreasing, self._last_outer_error = self._error_is_decreasing(self._last_outer_error)\n        return is_decreasing", "response": "True if outer iteration error is decreasing."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _error_is_decreasing(self, last_error):\n        current_error = self._compute_error()\n        is_decreasing = current_error < last_error\n        return is_decreasing, current_error", "response": "True if current error is less than last_error."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nperforms the inner iteration.", "response": "def _iterate_to_update_x_transforms(self):\n        \"\"\"Perform the inner iteration.\"\"\"\n        self._inner_iters = 0\n        self._last_inner_error = float('inf')\n        while self._inner_error_is_decreasing():\n            print('  Starting inner iteration {0:03d}. Current err = {1:12.5E}'\n                  ''.format(self._inner_iters, self._last_inner_error))\n            self._update_x_transforms()\n            self._inner_iters += 1"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nupdating the x - transform functions of the main expession with the new transform functions.", "response": "def _update_x_transforms(self):\n        \"\"\"\n        Compute a new set of x-transform functions phik.\n\n        phik(xk) = theta(y) - sum of phii(xi) over i!=k\n\n        This is the first of the eponymous conditional expectations. The conditional\n        expectations are computed using the SuperSmoother.\n        \"\"\"\n        # start by subtracting all transforms\n        theta_minus_phis = self.y_transform - numpy.sum(self.x_transforms, axis=0)\n\n        # add one transform at a time so as to exclude it from the subtracted sum\n        for xtransform_index in range(len(self.x_transforms)):\n            xtransform = self.x_transforms[xtransform_index]\n            sorted_data_indices = self._xi_sorted[xtransform_index]\n            xk_sorted = sort_vector(self.x[xtransform_index], sorted_data_indices)\n            xtransform_sorted = sort_vector(xtransform, sorted_data_indices)\n            theta_minus_phis_sorted = sort_vector(theta_minus_phis, sorted_data_indices)\n\n            # minimize sums by just adding in the phik where i!=k here.\n            to_smooth = theta_minus_phis_sorted + xtransform_sorted\n\n            smoother = perform_smooth(xk_sorted, to_smooth, smoother_cls=self._smoother_cls)\n            updated_x_transform_smooth = smoother.smooth_result\n            updated_x_transform_smooth -= numpy.mean(updated_x_transform_smooth)\n\n            # store updated transform in the order of the original data\n            unsorted_xt = unsort_vector(updated_x_transform_smooth, sorted_data_indices)\n            self.x_transforms[xtransform_index] = unsorted_xt\n\n            # update main expession with new smooth. This was done in the original FORTRAN\n            tmp_unsorted = unsort_vector(to_smooth, sorted_data_indices)\n            theta_minus_phis = tmp_unsorted - unsorted_xt"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nupdating the y - transform.", "response": "def _update_y_transform(self):\n        \"\"\"\n        Update the y-transform (theta).\n\n        y-transform theta is forced to have mean = 0 and stddev = 1.\n\n        This is the second conditional expectation\n        \"\"\"\n        # sort all phis wrt increasing y.\n        sorted_data_indices = self._yi_sorted\n        sorted_xtransforms = []\n        for xt in self.x_transforms:\n            sorted_xt = sort_vector(xt, sorted_data_indices)\n            sorted_xtransforms.append(sorted_xt)\n\n        sum_of_x_transformations_choppy = numpy.sum(sorted_xtransforms, axis=0)\n        y_sorted = sort_vector(self.y, sorted_data_indices)\n        smooth = perform_smooth(y_sorted, sum_of_x_transformations_choppy,\n                                smoother_cls=self._smoother_cls)\n        sum_of_x_transformations_smooth = smooth.smooth_result\n\n        sum_of_x_transformations_smooth -= numpy.mean(sum_of_x_transformations_smooth)\n        sum_of_x_transformations_smooth /= numpy.std(sum_of_x_transformations_smooth)\n\n        # unsort to save in the original data\n        self.y_transform = unsort_vector(sum_of_x_transformations_smooth, sorted_data_indices)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef write_input_to_file(self, fname='ace_input.txt'):\n        self._write_columns(fname, self.x, self.y)", "response": "Write y and x values used in this run to a space - delimited txt file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef write_transforms_to_file(self, fname='ace_transforms.txt'):\n        self._write_columns(fname, self.x_transforms, self.y_transform)", "response": "Write y and x transforms used in this run to a space - delimited txt file."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsamples problem from supersmoother publication.", "response": "def build_sample_smoother_problem_friedman82(N=200):\n    \"\"\"Sample problem from supersmoother publication.\"\"\"\n    x = numpy.random.uniform(size=N)\n    err = numpy.random.standard_normal(N)\n    y = numpy.sin(2 * math.pi * (1 - x) ** 2) + x * err\n    return x, y"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nruns Friedman s test of fixed - span smoothers from Figure 2b.", "response": "def run_friedman82_basic():\n    \"\"\"Run Friedman's test of fixed-span smoothers from Figure 2b.\"\"\"\n    x, y = build_sample_smoother_problem_friedman82()\n    plt.figure()\n    # plt.plot(x, y, '.', label='Data')\n    for span in smoother.DEFAULT_SPANS:\n        smooth = smoother.BasicFixedSpanSmoother()\n        smooth.specify_data_set(x, y, sort_data=True)\n        smooth.set_span(span)\n        smooth.compute()\n        plt.plot(x, smooth.smooth_result, '.', label='span = {0}'.format(span))\n    plt.legend(loc='upper left')\n    plt.grid(color='0.7')\n    plt.xlabel('x')\n    plt.ylabel('y')\n    plt.title('Demo of fixed-span smoothers from Friedman 82')\n    plt.savefig('sample_friedman82.png')\n\n    return smooth"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding a moving element to the board", "response": "def add_moving_element(self, element):\n        \"\"\"Add elements to the board\"\"\"\n\n        element.initialize(self.canvas)\n        self.elements.append(element)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef on_key_pressed(self, event):\n\n        return\n\n        # TODO\n\n        if event.keysym == \"Up\":\n            self.manager.set_joystick(0.0, -1.0, 0)\n        elif event.keysym == \"Down\":\n            self.manager.set_joystick(0.0, 1.0, 0)\n        elif event.keysym == \"Left\":\n            self.manager.set_joystick(-1.0, 0.0, 0)\n        elif event.keysym == \"Right\":\n            self.manager.set_joystick(1.0, 0.0, 0)\n\n        elif event.char == \" \":\n            mode = self.manager.get_mode()\n            if mode == self.manager.MODE_DISABLED:\n                self.manager.set_mode(self.manager.MODE_OPERATOR_CONTROL)\n            else:\n                self.manager.set_mode(self.manager.MODE_DISABLED)", "response": "Called when a key is pressed on the keyboard."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _load_config(robot_path):\n\n    from . import config\n\n    config_obj = config.config_obj\n\n    sim_path = join(robot_path, \"sim\")\n    config_file = join(sim_path, \"config.json\")\n\n    if exists(config_file):\n        with open(config_file, \"r\") as fp:\n            config_obj.update(json.load(fp))\n    else:\n        logger.warning(\"sim/config.json not found, using default simulation parameters\")\n\n    config_obj[\"simpath\"] = sim_path\n\n    # setup defaults\n    config_obj.setdefault(\"pyfrc\", {})\n\n    config_obj[\"pyfrc\"].setdefault(\"robot\", {})\n    config_obj[\"pyfrc\"][\"robot\"].setdefault(\"w\", 2)\n\n    # switched from 'h' to 'l' in 2018, but keeping it there for legacy reasons\n    l = config_obj[\"pyfrc\"][\"robot\"].get(\"h\", 3)\n    config_obj[\"pyfrc\"][\"robot\"].setdefault(\"l\", l)\n\n    config_obj[\"pyfrc\"][\"robot\"].setdefault(\"starting_x\", 0)\n    config_obj[\"pyfrc\"][\"robot\"].setdefault(\"starting_y\", 0)\n    config_obj[\"pyfrc\"][\"robot\"].setdefault(\"starting_angle\", 0)\n\n    # list of dictionaries of x=, y=, angle=, name=\n    config_obj[\"pyfrc\"][\"robot\"].setdefault(\"start_positions\", [])\n\n    field = config_obj[\"pyfrc\"].setdefault(\"field\", {})\n    force_defaults = False\n\n    # The rules here are complex because of backwards compat\n    # -> if you specify a particular season, then it will override w/h/px\n    # -> if you specify objects then you will get your own stuff\n    # -> if you don't specify anything then it override w/h/px\n    #    -> if you add your own, it will warn you unless you specify an image\n\n    # backwards compat\n    if \"season\" in config_obj[\"pyfrc\"][\"field\"]:\n        season = config_obj[\"pyfrc\"][\"field\"][\"season\"]\n        defaults = _field_defaults.get(str(season), _field_defaults[\"default\"])\n        force_defaults = True\n    elif \"objects\" in config_obj[\"pyfrc\"][\"field\"]:\n        defaults = _field_defaults[\"default\"]\n    else:\n        if \"image\" not in field:\n            force_defaults = True\n        defaults = _field_defaults[_default_year]\n\n    if force_defaults:\n        if \"w\" in field or \"h\" in field or \"px_per_ft\" in field:\n            logger.warning(\"Ignoring field w/h/px_per_ft settings\")\n        field[\"w\"] = defaults[\"w\"]\n        field[\"h\"] = defaults[\"h\"]\n        field[\"px_per_ft\"] = defaults[\"px_per_ft\"]\n\n    config_obj[\"pyfrc\"][\"field\"].setdefault(\"objects\", [])\n    config_obj[\"pyfrc\"][\"field\"].setdefault(\"w\", defaults[\"w\"])\n    config_obj[\"pyfrc\"][\"field\"].setdefault(\"h\", defaults[\"h\"])\n    config_obj[\"pyfrc\"][\"field\"].setdefault(\"px_per_ft\", defaults[\"px_per_ft\"])\n    img = config_obj[\"pyfrc\"][\"field\"].setdefault(\"image\", defaults[\"image\"])\n\n    config_obj[\"pyfrc\"].setdefault(\n        \"game_specific_messages\", defaults.get(\"game_specific_messages\", [])\n    )\n    config_obj[\"pyfrc\"][\"field\"].setdefault(\n        \"auto_joysticks\", defaults.get(\"auto_joysticks\", False)\n    )\n    assert isinstance(config_obj[\"pyfrc\"][\"game_specific_messages\"], (list, type(None)))\n\n    if img and not isabs(config_obj[\"pyfrc\"][\"field\"][\"image\"]):\n        config_obj[\"pyfrc\"][\"field\"][\"image\"] = abspath(join(sim_path, img))\n\n    config_obj[\"pyfrc\"].setdefault(\"analog\", {})\n    config_obj[\"pyfrc\"].setdefault(\"CAN\", {})\n    config_obj[\"pyfrc\"].setdefault(\"dio\", {})\n    config_obj[\"pyfrc\"].setdefault(\"pwm\", {})\n    config_obj[\"pyfrc\"].setdefault(\"relay\", {})\n    config_obj[\"pyfrc\"].setdefault(\"solenoid\", {})\n\n    config_obj[\"pyfrc\"].setdefault(\"joysticks\", {})\n    for i in range(6):\n        config_obj[\"pyfrc\"][\"joysticks\"].setdefault(str(i), {})\n        config_obj[\"pyfrc\"][\"joysticks\"][str(i)].setdefault(\"axes\", {})\n        config_obj[\"pyfrc\"][\"joysticks\"][str(i)].setdefault(\"buttons\", {})\n\n        config_obj[\"pyfrc\"][\"joysticks\"][str(i)][\"buttons\"].setdefault(\"1\", \"Trigger\")\n        config_obj[\"pyfrc\"][\"joysticks\"][str(i)][\"buttons\"].setdefault(\"2\", \"Top\")", "response": "Loads a json file from the simulation and creates a dictionary of the information available to the testing code."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef add_data_point_xy(self, x, y):\n        self.x.append(x)\n        self.y.append(y)", "response": "Add a new data point to the data set to be smoothed."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef specify_data_set(self, x_input, y_input, sort_data=False):\n        if sort_data:\n            xy = sorted(zip(x_input, y_input))\n            x, y = zip(*xy)\n            x_input_list = list(x_input)\n            self._original_index_of_xvalue = [x_input_list.index(xi) for xi in x]\n            if len(set(self._original_index_of_xvalue)) != len(x):\n                raise RuntimeError('There are some non-unique x-values')\n        else:\n            x, y = x_input, y_input\n\n        self.x = x\n        self.y = y", "response": "Fully define data by lists of x values and y values."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nplot the input data and resulting smooth.", "response": "def plot(self, fname=None):\n        \"\"\"\n        Plot the input data and resulting smooth.\n\n        Parameters\n        ----------\n        fname : str, optional\n            name of file to produce. If none, will show interactively.\n        \"\"\"\n        plt.figure()\n        xy = sorted(zip(self.x, self.smooth_result))\n        x, y = zip(*xy)\n        plt.plot(x, y, '-')\n        plt.plot(self.x, self.y, '.')\n        if fname:\n            plt.savefig(fname)\n        else:\n            plt.show()\n        plt.close()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nconvert sorted smooth and residual back to as - input order.", "response": "def _store_unsorted_results(self, smooth, residual):\n        \"\"\"Convert sorted smooth/residual back to as-input order.\"\"\"\n        if self._original_index_of_xvalue:\n            # data was sorted. Unsort it here.\n            self.smooth_result = numpy.zeros(len(self.y))\n            self.cross_validated_residual = numpy.zeros(len(residual))\n            original_x = numpy.zeros(len(self.y))\n            for i, (xval, smooth_val, residual_val) in enumerate(zip(self.x, smooth, residual)):\n                original_index = self._original_index_of_xvalue[i]\n                original_x[original_index] = xval\n                self.smooth_result[original_index] = smooth_val\n                self.cross_validated_residual[original_index] = residual_val\n                self.x = original_x\n        else:\n            # no sorting was done. just apply results\n            self.smooth_result = smooth\n            self.cross_validated_residual = residual"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef compute(self):\n        self._compute_window_size()\n        smooth = []\n        residual = []\n\n        x, y = self.x, self.y\n\n        # step through x and y data with a window window_size wide.\n        self._update_values_in_window()\n        self._update_mean_in_window()\n        self._update_variance_in_window()\n        for i, (xi, yi) in enumerate(zip(x, y)):\n            if ((i - self._neighbors_on_each_side) > 0.0 and\n                    (i + self._neighbors_on_each_side) < len(x)):\n                self._advance_window()\n            smooth_here = self._compute_smooth_during_construction(xi)\n            residual_here = self._compute_cross_validated_residual_here(xi, yi, smooth_here)\n            smooth.append(smooth_here)\n            residual.append(residual_here)\n\n        self._store_unsorted_results(smooth, residual)", "response": "Perform the smoothing operations."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ndetermines characteristics of symmetric neighborhood with J / 2 values on each side.", "response": "def _compute_window_size(self):\n        \"\"\"Determine characteristics of symmetric neighborhood with J/2 values on each side.\"\"\"\n        self._neighbors_on_each_side = int(len(self.x) * self._span) // 2\n        self.window_size = self._neighbors_on_each_side * 2 + 1\n        if self.window_size <= 1:\n            # cannot do averaging with 1 point in window. Force >=2\n            self.window_size = 2"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _update_values_in_window(self):\n        window_bound_upper = self._window_bound_lower + self.window_size\n        self._x_in_window = self.x[self._window_bound_lower:window_bound_upper]\n        self._y_in_window = self.y[self._window_bound_lower:window_bound_upper]", "response": "Update which values are in the current window."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _update_mean_in_window(self):\n        self._mean_x_in_window = numpy.mean(self._x_in_window)\n        self._mean_y_in_window = numpy.mean(self._y_in_window)", "response": "Compute mean in window"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _update_variance_in_window(self):\n        self._covariance_in_window = sum([(xj - self._mean_x_in_window) *\n                                          (yj - self._mean_y_in_window)\n                                          for xj, yj in zip(self._x_in_window, self._y_in_window)])\n\n        self._variance_in_window = sum([(xj - self._mean_x_in_window) ** 2 for xj\n                                        in self._x_in_window])", "response": "Compute variance and covariance in window using all values in window."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _advance_window(self):\n        x_to_remove, y_to_remove = self._x_in_window[0], self._y_in_window[0]\n\n        self._window_bound_lower += 1\n        self._update_values_in_window()\n        x_to_add, y_to_add = self._x_in_window[-1], self._y_in_window[-1]\n\n        self._remove_observation(x_to_remove, y_to_remove)\n        self._add_observation(x_to_add, y_to_add)", "response": "Update values in current window and the current window means and variances."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nremoving observation from window updating means and variance efficiently.", "response": "def _remove_observation(self, x_to_remove, y_to_remove):\n        \"\"\"Remove observation from window, updating means/variance efficiently.\"\"\"\n        self._remove_observation_from_variances(x_to_remove, y_to_remove)\n        self._remove_observation_from_means(x_to_remove, y_to_remove)\n        self.window_size -= 1"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nadding observation to window updating means and variance efficiently.", "response": "def _add_observation(self, x_to_add, y_to_add):\n        \"\"\"Add observation to window, updating means/variance efficiently.\"\"\"\n        self._add_observation_to_means(x_to_add, y_to_add)\n        self._add_observation_to_variances(x_to_add, y_to_add)\n        self.window_size += 1"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _add_observation_to_means(self, xj, yj):\n        self._mean_x_in_window = ((self.window_size * self._mean_x_in_window + xj) /\n                                  (self.window_size + 1.0))\n        self._mean_y_in_window = ((self.window_size * self._mean_y_in_window + yj) /\n                                  (self.window_size + 1.0))", "response": "Update the means without recalculating for the addition of one observation."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _remove_observation_from_means(self, xj, yj):\n        self._mean_x_in_window = ((self.window_size * self._mean_x_in_window - xj) /\n                                  (self.window_size - 1.0))\n        self._mean_y_in_window = ((self.window_size * self._mean_y_in_window - yj) /\n                                  (self.window_size - 1.0))", "response": "Update the means without recalculating for the deletion of one observation."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nadd observation to the variance and co - variance.", "response": "def _add_observation_to_variances(self, xj, yj):\n        \"\"\"\n        Quickly update the variance and co-variance for the addition of one observation.\n\n        See Also\n        --------\n        _update_variance_in_window : compute variance considering full window\n        \"\"\"\n        term1 = (self.window_size + 1.0) / self.window_size * (xj - self._mean_x_in_window)\n        self._covariance_in_window += term1 * (yj - self._mean_y_in_window)\n        self._variance_in_window += term1 * (xj - self._mean_x_in_window)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncompute the value of the smooth at x - value xi.", "response": "def _compute_smooth_during_construction(self, xi):\n        \"\"\"\n        Evaluate value of smooth at x-value xi.\n\n        Parameters\n        ----------\n        xi : float\n            Value of x where smooth value is desired\n\n        Returns\n        -------\n        smooth_here : float\n            Value of smooth s(xi)\n        \"\"\"\n        if self._variance_in_window:\n            beta = self._covariance_in_window / self._variance_in_window\n            alpha = self._mean_y_in_window - beta * self._mean_x_in_window\n            value_of_smooth_here = beta * (xi) + alpha\n        else:\n            value_of_smooth_here = 0.0\n        return value_of_smooth_here"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _compute_cross_validated_residual_here(self, xi, yi, smooth_here):\n        denom = (1.0 - 1.0 / self.window_size -\n                 (xi - self._mean_x_in_window) ** 2 /\n                 self._variance_in_window)\n        if denom == 0.0:\n            # can happen  with small data sets\n            return 1.0\n        return abs((yi - smooth_here) / denom)", "response": "Compute cross validated residual."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsampling problem from Breiman 1985.", "response": "def build_sample_ace_problem_breiman85(N=200):\n    \"\"\"Sample problem from Breiman 1985.\"\"\"\n    x_cubed = numpy.random.standard_normal(N)\n    x = scipy.special.cbrt(x_cubed)\n    noise = numpy.random.standard_normal(N)\n    y = numpy.exp((x ** 3.0) + noise)\n    return [x], y"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nbuilds sample problem y x = 1 y = 2", "response": "def build_sample_ace_problem_breiman2(N=500):\n    \"\"\"Build sample problem y(x) = exp(sin(x)).\"\"\"\n    x = numpy.linspace(0, 1, N)\n    # x = numpy.random.uniform(0, 1, size=N)\n    noise = numpy.random.standard_normal(N)\n    y = numpy.exp(numpy.sin(2 * numpy.pi * x)) + 0.0 * noise\n    return [x], y"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef run_breiman85():\n    x, y = build_sample_ace_problem_breiman85(200)\n    ace_solver = ace.ACESolver()\n    ace_solver.specify_data_set(x, y)\n    ace_solver.solve()\n    try:\n        ace.plot_transforms(ace_solver, 'sample_ace_breiman85.png')\n    except ImportError:\n        pass\n    return ace_solver", "response": "Run Breiman 85 sample."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nrun Breiman s other sample problem.", "response": "def run_breiman2():\n    \"\"\"Run Breiman's other sample problem.\"\"\"\n    x, y = build_sample_ace_problem_breiman2(500)\n    ace_solver = ace.ACESolver()\n    ace_solver.specify_data_set(x, y)\n    ace_solver.solve()\n    try:\n        plt = ace.plot_transforms(ace_solver, None)\n    except ImportError:\n        pass\n\n    plt.subplot(1, 2, 1)\n    phi = numpy.sin(2.0 * numpy.pi * x[0])\n    plt.plot(x[0], phi, label='analytic')\n    plt.legend()\n    plt.subplot(1, 2, 2)\n    y = numpy.exp(phi)\n    plt.plot(y, phi, label='analytic')\n    plt.legend(loc='lower right')\n    # plt.show()\n    plt.savefig('no_noise_linear_x.png')\n\n    return ace_solver"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ntakes messages and puts them on the supplied kafka topic ovaova", "response": "def publish(self, topic, messages, key=None):\n        \"\"\"Takes messages and puts them on the supplied kafka topic\n\n        \"\"\"\n\n        if not isinstance(messages, list):\n            messages = [messages]\n\n        first = True\n        success = False\n        if key is None:\n            key = int(time.time() * 1000)\n\n        messages = [encodeutils.to_utf8(m) for m in messages]\n\n        key = bytes(str(key), 'utf-8') if PY3 else str(key)\n\n        while not success:\n            try:\n                self._producer.send_messages(topic, key, *messages)\n                success = True\n            except Exception:\n                if first:\n                    # This is a warning because of all the other warning and\n                    # error messages that are logged in this case. This way\n                    # someone looking at the log file can see the retry\n                    log.warn(\"Failed send on topic {}, clear metadata and retry\"\n                             .format(topic))\n\n                    # If Kafka is running in Kubernetes, the cached metadata\n                    # contains the IP Address of the Kafka pod. If the Kafka\n                    # pod has restarted, the IP Address will have changed\n                    # which would have caused the first publish to fail. So,\n                    # clear the cached metadata and retry the publish\n                    self._kafka.reset_topic_metadata(topic)\n                    first = False\n                    continue\n                log.exception('Error publishing to {} topic.'.format(topic))\n                raise"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nconstruct a Gzipped Message containing multiple Messages", "response": "def create_gzip_message(payloads, key=None, compresslevel=None):\n    \"\"\"\n    Construct a Gzipped Message containing multiple Messages\n\n    The given payloads will be encoded, compressed, and sent as a single atomic\n    message to Kafka.\n\n    Arguments:\n        payloads: list(bytes), a list of payload to send be sent to Kafka\n        key: bytes, a key used for partition routing (optional)\n\n    \"\"\"\n    message_set = KafkaProtocol._encode_message_set(\n        [create_message(payload, pl_key) for payload, pl_key in payloads])\n\n    gzipped = gzip_encode(message_set, compresslevel=compresslevel)\n    codec = ATTRIBUTE_CODEC_MASK & CODEC_GZIP\n\n    return Message(0, 0x00 | codec, key, gzipped)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nencoding a single message.", "response": "def _encode_message(cls, message):\n        \"\"\"\n        Encode a single message.\n\n        The magic number of a message is a format version number.\n        The only supported magic number right now is zero\n\n        Format\n        ======\n        Message => Crc MagicByte Attributes Key Value\n          Crc => int32\n          MagicByte => int8\n          Attributes => int8\n          Key => bytes\n          Value => bytes\n        \"\"\"\n        if message.magic == 0:\n            msg = b''.join([\n                struct.pack('>BB', message.magic, message.attributes),\n                write_int_string(message.key),\n                write_int_string(message.value)\n            ])\n            crc = crc32(msg)\n            msg = struct.pack('>I%ds' % len(msg), crc, msg)\n        else:\n            raise ProtocolError(\"Unexpected magic number: %d\" % message.magic)\n        return msg"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\niterates over the message set data.", "response": "def _decode_message_set_iter(cls, data):\n        \"\"\"\n        Iteratively decode a MessageSet\n\n        Reads repeated elements of (offset, message), calling decode_message\n        to decode a single message. Since compressed messages contain futher\n        MessageSets, these two methods have been decoupled so that they may\n        recurse easily.\n        \"\"\"\n        cur = 0\n        read_message = False\n        while cur < len(data):\n            try:\n                ((offset, ), cur) = relative_unpack('>q', data, cur)\n                (msg, cur) = read_int_string(data, cur)\n                for (offset, message) in KafkaProtocol._decode_message(msg, offset):\n                    read_message = True\n                    yield OffsetAndMessage(offset, message)\n            except BufferUnderflowError:\n                # NOTE: Not sure this is correct error handling:\n                # Is it possible to get a BUE if the message set is somewhere\n                # in the middle of the fetch response? If so, we probably have\n                # an issue that's not fetch size too small.\n                # Aren't we ignoring errors if we fail to unpack data by\n                # raising StopIteration()?\n                # If _decode_message() raises a ChecksumError, couldn't that\n                # also be due to the fetch size being too small?\n                if read_message is False:\n                    # If we get a partial read of a message, but haven't\n                    # yielded anything there's a problem\n                    raise ConsumerFetchSizeTooSmall()\n                else:\n                    raise StopIteration()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _decode_message(cls, data, offset):\n        ((crc, magic, att), cur) = relative_unpack('>IBB', data, 0)\n        if crc != crc32(data[4:]):\n            raise ChecksumError(\"Message checksum failed\")\n\n        (key, cur) = read_int_string(data, cur)\n        (value, cur) = read_int_string(data, cur)\n\n        codec = att & ATTRIBUTE_CODEC_MASK\n\n        if codec == CODEC_NONE:\n            yield (offset, Message(magic, att, key, value))\n\n        elif codec == CODEC_GZIP:\n            gz = gzip_decode(value)\n            for (offset, msg) in KafkaProtocol._decode_message_set_iter(gz):\n                yield (offset, msg)\n\n        elif codec == CODEC_SNAPPY:\n            snp = snappy_decode(value)\n            for (offset, msg) in KafkaProtocol._decode_message_set_iter(snp):\n                yield (offset, msg)", "response": "Decode a single MessageSet."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nencoding ProduceRequest structs into a string that can be sent to Kafka.", "response": "def encode_produce_request(cls, client_id, correlation_id,\n                               payloads=None, acks=1, timeout=1000):\n        \"\"\"\n        Encode some ProduceRequest structs\n\n        Arguments:\n            client_id: string\n            correlation_id: int\n            payloads: list of ProduceRequest\n            acks: How \"acky\" you want the request to be\n                0: immediate response\n                1: written to disk by the leader\n                2+: waits for this many number of replicas to sync\n                -1: waits for all replicas to be in sync\n            timeout: Maximum time the server will wait for acks from replicas.\n                This is _not_ a socket timeout\n\n        \"\"\"\n        payloads = [] if payloads is None else payloads\n        grouped_payloads = group_by_topic_and_partition(payloads)\n\n        message = []\n        message.append(cls._encode_message_header(client_id, correlation_id,\n                                                  KafkaProtocol.PRODUCE_KEY))\n\n        message.append(struct.pack('>hii', acks, timeout,\n                                   len(grouped_payloads)))\n\n        for topic, topic_payloads in grouped_payloads.items():\n            message.append(struct.pack('>h%dsi' % len(topic), len(topic), topic,\n                                       len(topic_payloads)))\n\n            for partition, payload in topic_payloads.items():\n                msg_set = KafkaProtocol._encode_message_set(payload.messages)\n                message.append(struct.pack('>ii%ds' % len(msg_set), partition,\n                                           len(msg_set), msg_set))\n\n        msg = b''.join(message)\n        return struct.pack('>i%ds' % len(msg), len(msg), msg)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef decode_produce_response(cls, data):\n        ((correlation_id, num_topics), cur) = relative_unpack('>ii', data, 0)\n\n        for _ in range(num_topics):\n            ((strlen,), cur) = relative_unpack('>h', data, cur)\n            topic = data[cur:cur + strlen]\n            cur += strlen\n            ((num_partitions,), cur) = relative_unpack('>i', data, cur)\n            for _ in range(num_partitions):\n                ((partition, error, offset), cur) = relative_unpack('>ihq',\n                                                                    data, cur)\n\n                yield ProduceResponse(topic, partition, error, offset)", "response": "Decodes a bytes to a ProduceResponse object"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef encode_fetch_request(cls, client_id, correlation_id, payloads=None,\n                             max_wait_time=100, min_bytes=4096):\n        \"\"\"\n        Encodes some FetchRequest structs\n\n        Arguments:\n            client_id: string\n            correlation_id: int\n            payloads: list of FetchRequest\n            max_wait_time: int, how long to block waiting on min_bytes of data\n            min_bytes: int, the minimum number of bytes to accumulate before\n                       returning the response\n        \"\"\"\n\n        payloads = [] if payloads is None else payloads\n        grouped_payloads = group_by_topic_and_partition(payloads)\n\n        message = []\n        message.append(cls._encode_message_header(client_id, correlation_id,\n                                                  KafkaProtocol.FETCH_KEY))\n\n        # -1 is the replica id\n        message.append(struct.pack('>iiii', -1, max_wait_time, min_bytes,\n                                   len(grouped_payloads)))\n\n        for topic, topic_payloads in grouped_payloads.items():\n            message.append(write_short_string(topic))\n            message.append(struct.pack('>i', len(topic_payloads)))\n            for partition, payload in topic_payloads.items():\n                message.append(struct.pack('>iqi', partition, payload.offset,\n                                           payload.max_bytes))\n\n        msg = b''.join(message)\n        return struct.pack('>i%ds' % len(msg), len(msg), msg)", "response": "Encodes some FetchRequest structs into a string that can be sent to Kafka."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef decode_fetch_response(cls, data):\n        ((correlation_id, num_topics), cur) = relative_unpack('>ii', data, 0)\n\n        for _ in range(num_topics):\n            (topic, cur) = read_short_string(data, cur)\n            ((num_partitions,), cur) = relative_unpack('>i', data, cur)\n\n            for j in range(num_partitions):\n                ((partition, error, highwater_mark_offset), cur) = \\\n                    relative_unpack('>ihq', data, cur)\n\n                (message_set, cur) = read_int_string(data, cur)\n\n                yield FetchResponse(\n                    topic, partition, error,\n                    highwater_mark_offset,\n                    KafkaProtocol._decode_message_set_iter(message_set))", "response": "Decode bytes to a FetchResponse object"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef decode_offset_response(cls, data):\n        ((correlation_id, num_topics), cur) = relative_unpack('>ii', data, 0)\n\n        for _ in range(num_topics):\n            (topic, cur) = read_short_string(data, cur)\n            ((num_partitions,), cur) = relative_unpack('>i', data, cur)\n\n            for _ in range(num_partitions):\n                ((partition, error, num_offsets,), cur) = \\\n                    relative_unpack('>ihi', data, cur)\n\n                offsets = []\n                for k in range(num_offsets):\n                    ((offset,), cur) = relative_unpack('>q', data, cur)\n                    offsets.append(offset)\n\n                yield OffsetResponse(topic, partition, error, tuple(offsets))", "response": "Decode bytes to an OffsetResponse"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nencoding a MetadataRequest object.", "response": "def encode_metadata_request(cls, client_id, correlation_id, topics=None,\n                                payloads=None):\n        \"\"\"\n        Encode a MetadataRequest\n\n        Arguments:\n            client_id: string\n            correlation_id: int\n            topics: list of strings\n        \"\"\"\n        if payloads is None:\n            topics = [] if topics is None else topics\n        else:\n            topics = payloads\n\n        message = []\n        message.append(cls._encode_message_header(client_id, correlation_id,\n                                                  KafkaProtocol.METADATA_KEY))\n\n        message.append(struct.pack('>i', len(topics)))\n\n        for topic in topics:\n            message.append(struct.pack('>h%ds' % len(topic), len(topic), topic))\n\n        msg = b''.join(message)\n        return write_int_string(msg)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndecode the bytes to a MetadataResponse object.", "response": "def decode_metadata_response(cls, data):\n        \"\"\"\n        Decode bytes to a MetadataResponse\n\n        Arguments:\n            data: bytes to decode\n        \"\"\"\n        ((correlation_id, numbrokers), cur) = relative_unpack('>ii', data, 0)\n\n        # Broker info\n        brokers = []\n        for _ in range(numbrokers):\n            ((nodeId, ), cur) = relative_unpack('>i', data, cur)\n            (host, cur) = read_short_string(data, cur)\n            ((port,), cur) = relative_unpack('>i', data, cur)\n            brokers.append(BrokerMetadata(nodeId, host, port))\n\n        # Topic info\n        ((num_topics,), cur) = relative_unpack('>i', data, cur)\n        topic_metadata = []\n\n        for _ in range(num_topics):\n            ((topic_error,), cur) = relative_unpack('>h', data, cur)\n            (topic_name, cur) = read_short_string(data, cur)\n            ((num_partitions,), cur) = relative_unpack('>i', data, cur)\n            partition_metadata = []\n\n            for _ in range(num_partitions):\n                ((partition_error_code, partition, leader, numReplicas), cur) = \\\n                    relative_unpack('>hiii', data, cur)\n\n                (replicas, cur) = relative_unpack(\n                    '>%di' % numReplicas, data, cur)\n\n                ((num_isr,), cur) = relative_unpack('>i', data, cur)\n                (isr, cur) = relative_unpack('>%di' % num_isr, data, cur)\n\n                partition_metadata.append(\n                    PartitionMetadata(topic_name, partition, leader,\n                                      replicas, isr, partition_error_code)\n                )\n\n            topic_metadata.append(\n                TopicMetadata(topic_name, topic_error, partition_metadata)\n            )\n\n        return MetadataResponse(brokers, topic_metadata)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef encode_offset_commit_request(cls, client_id, correlation_id,\n                                     group, payloads):\n        \"\"\"\n        Encode some OffsetCommitRequest structs\n\n        Arguments:\n            client_id: string\n            correlation_id: int\n            group: string, the consumer group you are committing offsets for\n            payloads: list of OffsetCommitRequest\n        \"\"\"\n        grouped_payloads = group_by_topic_and_partition(payloads)\n\n        message = []\n        message.append(cls._encode_message_header(client_id, correlation_id,\n                                                  KafkaProtocol.OFFSET_COMMIT_KEY))\n        message.append(write_short_string(group))\n        message.append(struct.pack('>i', len(grouped_payloads)))\n\n        for topic, topic_payloads in grouped_payloads.items():\n            message.append(write_short_string(topic))\n            message.append(struct.pack('>i', len(topic_payloads)))\n\n            for partition, payload in topic_payloads.items():\n                message.append(struct.pack('>iq', partition, payload.offset))\n                message.append(write_short_string(payload.metadata))\n\n        msg = b''.join(message)\n        return struct.pack('>i%ds' % len(msg), len(msg), msg)", "response": "Encode some OffsetCommitRequest structs that are used to commit the offsets for a specific consumer group."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef decode_offset_commit_response(cls, data):\n        ((correlation_id,), cur) = relative_unpack('>i', data, 0)\n        ((num_topics,), cur) = relative_unpack('>i', data, cur)\n\n        for _ in xrange(num_topics):\n            (topic, cur) = read_short_string(data, cur)\n            ((num_partitions,), cur) = relative_unpack('>i', data, cur)\n\n            for _ in xrange(num_partitions):\n                ((partition, error), cur) = relative_unpack('>ih', data, cur)\n                yield OffsetCommitResponse(topic, partition, error)", "response": "Decode bytes to an OffsetCommitResponse object"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef encode_offset_fetch_request(cls, client_id, correlation_id,\n                                    group, payloads, from_kafka=False):\n        \"\"\"\n        Encode some OffsetFetchRequest structs. The request is encoded using\n        version 0 if from_kafka is false, indicating a request for Zookeeper\n        offsets. It is encoded using version 1 otherwise, indicating a request\n        for Kafka offsets.\n\n        Arguments:\n            client_id: string\n            correlation_id: int\n            group: string, the consumer group you are fetching offsets for\n            payloads: list of OffsetFetchRequest\n            from_kafka: bool, default False, set True for Kafka-committed offsets\n        \"\"\"\n        grouped_payloads = group_by_topic_and_partition(payloads)\n\n        message = []\n        reqver = 1 if from_kafka else 0\n        message.append(cls._encode_message_header(client_id, correlation_id,\n                                                  KafkaProtocol.OFFSET_FETCH_KEY,\n                                                  version=reqver))\n\n        message.append(write_short_string(group))\n        message.append(struct.pack('>i', len(grouped_payloads)))\n\n        for topic, topic_payloads in grouped_payloads.items():\n            message.append(write_short_string(topic))\n            message.append(struct.pack('>i', len(topic_payloads)))\n\n            for partition, payload in topic_payloads.items():\n                message.append(struct.pack('>i', partition))\n\n        msg = b''.join(message)\n        return struct.pack('>i%ds' % len(msg), len(msg), msg)", "response": "Encode some OffsetFetchRequest structs."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ndecodes bytes to an OffsetFetchResponse object", "response": "def decode_offset_fetch_response(cls, data):\n        \"\"\"\n        Decode bytes to an OffsetFetchResponse\n\n        Arguments:\n            data: bytes to decode\n        \"\"\"\n\n        ((correlation_id,), cur) = relative_unpack('>i', data, 0)\n        ((num_topics,), cur) = relative_unpack('>i', data, cur)\n\n        for _ in range(num_topics):\n            (topic, cur) = read_short_string(data, cur)\n            ((num_partitions,), cur) = relative_unpack('>i', data, cur)\n\n            for _ in range(num_partitions):\n                ((partition, offset), cur) = relative_unpack('>iq', data, cur)\n                (metadata, cur) = read_short_string(data, cur)\n                ((error,), cur) = relative_unpack('>h', data, cur)\n\n                yield OffsetFetchResponse(topic, partition, offset,\n                                          metadata, error)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nimporting a named class module method or function.", "response": "def _get_module(target):\n    \"\"\"Import a named class, module, method or function.\n\n    Accepts these formats:\n        \".../file/path|module_name:Class.method\"\n        \".../file/path|module_name:Class\"\n        \".../file/path|module_name:function\"\n        \"module_name:Class\"\n        \"module_name:function\"\n        \"module_name:Class.function\"\n\n    If a fully qualified directory is specified, it implies the\n    directory is not already on the Python Path, in which case\n    it will be added.\n\n    For example, if I import /home/foo (and\n    /home/foo is not in the python path) as\n    \"/home/foo|mycode:MyClass.mymethod\"\n    then /home/foo will be added to the python path and\n    the module loaded as normal.\n    \"\"\"\n\n    filepath, sep, namespace = target.rpartition('|')\n    if sep and not filepath:\n        raise BadDirectory(\"Path to file not supplied.\")\n\n    module, sep, class_or_function = namespace.rpartition(':')\n    if (sep and not module) or (filepath and not module):\n        raise MissingModule(\"Need a module path for %s (%s)\" %\n                            (namespace, target))\n\n    if filepath and filepath not in sys.path:\n        if not os.path.isdir(filepath):\n            raise BadDirectory(\"No such directory: '%s'\" % filepath)\n        sys.path.append(filepath)\n\n    if not class_or_function:\n        raise MissingMethodOrFunction(\n            \"No Method or Function specified in '%s'\" % target)\n\n    if module:\n        try:\n            __import__(module)\n        except ImportError as e:\n            raise ImportFailed(\"Failed to import '%s'. \"\n                               \"Error: %s\" % (module, e))\n\n    klass, sep, function = class_or_function.rpartition('.')\n    return module, klass, function"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef load(target, source_module=None):\n    module, klass, function = _get_module(target)\n    if not module and source_module:\n        module = source_module\n    if not module:\n        raise MissingModule(\n            \"No module name supplied or source_module provided.\")\n    actual_module = sys.modules[module]\n    if not klass:\n        return getattr(actual_module, function)\n\n    class_object = getattr(actual_module, klass)\n    if function:\n        return getattr(class_object, function)\n    return class_object", "response": "Get the actual implementation of the target."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef process_child(node):\n\n    # Edit descriptions to be nicer\n    if isinstance(node, sphinx.addnodes.desc_addname):\n        if len(node.children) == 1:\n            child = node.children[0]\n            text = child.astext()\n            if text.startswith(\"wpilib.\") and text.endswith(\".\"):\n                # remove the last element\n                text = \".\".join(text.split(\".\")[:-2]) + \".\"\n                node.children[0] = docutils.nodes.Text(text)\n\n    # Edit literals to be nicer\n    elif isinstance(node, docutils.nodes.literal):\n        child = node.children[0]\n        text = child.astext()\n\n        # Remove the imported module name\n        if text.startswith(\"wpilib.\"):\n            stext = text.split(\".\")\n            text = \".\".join(stext[:-2] + [stext[-1]])\n            node.children[0] = docutils.nodes.Text(text)\n\n    for child in node.children:\n        process_child(child)", "response": "This function changes the class references to not have the intermediate module name by hacking at the doctree"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncommits stored offsets to Kafka via OffsetCommitRequest.", "response": "def commit(self, partitions=None):\n        \"\"\"Commit stored offsets to Kafka via OffsetCommitRequest (v0)\n\n        Keyword Arguments:\n            partitions (list): list of partitions to commit, default is to commit\n                all of them\n\n        Returns: True on success, False on failure\n        \"\"\"\n\n        # short circuit if nothing happened. This check is kept outside\n        # to prevent un-necessarily acquiring a lock for checking the state\n        if self.count_since_commit == 0:\n            return\n\n        with self.commit_lock:\n            # Do this check again, just in case the state has changed\n            # during the lock acquiring timeout\n            if self.count_since_commit == 0:\n                return\n\n            reqs = []\n            if partitions is None:  # commit all partitions\n                partitions = list(self.offsets.keys())\n\n            log.debug('Committing new offsets for %s, partitions %s',\n                      self.topic, partitions)\n            for partition in partitions:\n                offset = self.offsets[partition]\n                log.debug('Commit offset %d in SimpleConsumer: '\n                          'group=%s, topic=%s, partition=%s',\n                          offset, self.group, self.topic, partition)\n\n                reqs.append(OffsetCommitRequest(self.topic, partition,\n                                                offset, None))\n\n            try:\n                self.client.send_offset_commit_request(self.group, reqs)\n            except KafkaError as e:\n                log.error('%s saving offsets: %s', e.__class__.__name__, e)\n                return False\n            else:\n                self.count_since_commit = 0\n                return True"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nread data from a simple text file.", "response": "def read_column_data_from_txt(fname):\n    \"\"\"\n    Read data from a simple text file.\n\n    Format should be just numbers.\n    First column is the dependent variable. others are independent.\n    Whitespace delimited.\n\n    Returns\n    -------\n    x_values : list\n        List of x columns\n    y_values : list\n        list of y values\n    \"\"\"\n    datafile = open(fname)\n    datarows = []\n    for line in datafile:\n        datarows.append([float(li) for li in line.split()])\n    datacols = list(zip(*datarows))\n    x_values = datacols[1:]\n    y_values = datacols[0]\n\n    return x_values, y_values"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nbuilding the model based on the data in a txt file.", "response": "def build_model_from_txt(self, fname):\n        \"\"\"\n        Construct the model and perform regressions based on data in a txt file.\n\n        Parameters\n        ----------\n        fname : str\n            The name of the file to load.\n        \"\"\"\n        x_values, y_values = read_column_data_from_txt(fname)\n        self.build_model_from_xy(x_values, y_values)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef build_model_from_xy(self, x_values, y_values):\n        self.init_ace(x_values, y_values)\n        self.run_ace()\n        self.build_interpolators()", "response": "Construct the model and perform regressions based on x and y data."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncomputes 1 - D interpolation functions for all the transforms so they re continuous..", "response": "def build_interpolators(self):\n        \"\"\"Compute 1-D interpolation functions for all the transforms so they're continuous..\"\"\"\n        self.phi_continuous = []\n        for xi, phii in zip(self.ace.x, self.ace.x_transforms):\n            self.phi_continuous.append(interp1d(xi, phii))\n        self.inverse_theta_continuous = interp1d(self.ace.y_transform, self.ace.y)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nevaluates the ACE regression at any combination of independent variable values.", "response": "def eval(self, x_values):\n        \"\"\"\n        Evaluate the ACE regression at any combination of independent variable values.\n\n        Parameters\n        ----------\n        x_values : iterable\n            a float x-value for each independent variable, e.g. (1.5, 2.5)\n        \"\"\"\n        if len(x_values) != len(self.phi_continuous):\n            raise ValueError('x_values must have length equal to the number of independent variables '\n                             '({0}) rather than {1}.'.format(len(self.phi_continuous),\n                                                             len(x_values)))\n\n        sum_phi = sum([phi(xi) for phi, xi in zip(self.phi_continuous, x_values)])\n        return float(self.inverse_theta_continuous(sum_phi))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef yesno(prompt):\n    prompt += \" [y/n]\"\n    a = \"\"\n    while a not in [\"y\", \"n\"]:\n        a = input(prompt).lower()\n\n    return a == \"y\"", "response": "Returns True if user answers y"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nretry a function on exception after a given number of times.", "response": "def retry(retries=KAFKA_WAIT_RETRIES, delay=KAFKA_WAIT_INTERVAL,\n          check_exceptions=()):\n    \"\"\"Retry decorator.\"\"\"\n    def decorator(func):\n        \"\"\"Decorator.\"\"\"\n        def f_retry(*args, **kwargs):\n            \"\"\"Retry running function on exception after delay.\"\"\"\n            for i in range(1, retries + 1):\n                try:\n                    return func(*args, **kwargs)\n                # pylint: disable=W0703\n                # We want to catch all exceptions here to retry.\n                except check_exceptions + (Exception,) as exc:\n                    if i < retries:\n                        logger.info('Connection attempt %d of %d failed',\n                                    i, retries)\n                        if isinstance(exc, check_exceptions):\n                            logger.debug('Caught known exception, retrying...',\n                                         exc_info=True)\n                        else:\n                            logger.warn(\n                                'Caught unknown exception, retrying...',\n                                exc_info=True)\n                    else:\n                        logger.exception('Failed after %d attempts', retries)\n\n                        raise\n\n                # No exception so wait before retrying\n                time.sleep(delay)\n\n        return f_retry\n    return decorator"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef check_topics(client, req_topics):\n    client.update_cluster()\n    logger.debug('Found topics: %r', client.topics.keys())\n\n    for req_topic in req_topics:\n        if req_topic not in client.topics.keys():\n            err_topic_not_found = 'Topic not found: {}'.format(req_topic)\n            logger.warning(err_topic_not_found)\n            raise TopicNotFound(err_topic_not_found)\n\n        topic = client.topics[req_topic]\n        if not topic.partitions:\n            err_topic_no_part = 'Topic has no partitions: {}'.format(req_topic)\n            logger.warning(err_topic_no_part)\n            raise TopicNoPartition(err_topic_no_part)\n\n        logger.info('Topic is ready: %s', req_topic)", "response": "Check if topics exist in Kafka."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef main():\n    logger.info('Checking for available topics: %r', repr(REQUIRED_TOPICS))\n\n    client = connect_kafka(hosts=KAFKA_HOSTS)\n    check_topics(client, REQUIRED_TOPICS)", "response": "Start main part of the wait script."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncollecting a comma - separated set of hosts and optionally randomize the returned list.", "response": "def collect_hosts(hosts, randomize=True):\n    \"\"\"\n    Collects a comma-separated set of hosts (host:port) and optionally\n    randomize the returned list.\n    \"\"\"\n\n    if isinstance(hosts, six.string_types):\n        hosts = hosts.strip().split(',')\n\n    result = []\n    for host_port in hosts:\n\n        res = host_port.split(':')\n        host = res[0]\n        port = int(res[1]) if len(res) > 1 else DEFAULT_KAFKA_PORT\n        result.append((host.strip(), port))\n\n    if randomize:\n        shuffle(result)\n\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsending a request to Kafka", "response": "def send(self, request_id, payload):\n        \"\"\"\n        Send a request to Kafka\n\n        Arguments::\n            request_id (int): can be any int (used only for debug logging...)\n            payload: an encoded kafka packet (see KafkaProtocol)\n        \"\"\"\n\n        log.debug(\"About to send %d bytes to Kafka, request %d\" % (len(payload), request_id))\n\n        # Make sure we have a connection\n        if not self._sock:\n            self.reinit()\n\n        try:\n            self._sock.sendall(payload)\n        except socket.error:\n            log.exception('Unable to send payload to Kafka')\n            self._raise_connection_error()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef recv(self, request_id):\n        log.debug(\"Reading response %d from Kafka\" % request_id)\n\n        # Make sure we have a connection\n        if not self._sock:\n            self.reinit()\n\n        # Read the size off of the header\n        resp = self._read_bytes(4)\n        (size,) = struct.unpack('>i', resp)\n\n        # Read the remainder of the response\n        resp = self._read_bytes(size)\n        return resp", "response": "Read a response packet from the server"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate an inactive copy of the connection object suitable for passing to a background thread.", "response": "def copy(self):\n        \"\"\"\n        Create an inactive copy of the connection object, suitable for\n        passing to a background thread.\n\n        The returned copy is not connected; you must call reinit() before\n        using.\n        \"\"\"\n        c = copy.deepcopy(self)\n        # Python 3 doesn't copy custom attributes of the threadlocal subclass\n        c.host = copy.copy(self.host)\n        c.port = copy.copy(self.port)\n        c.timeout = copy.copy(self.timeout)\n        c._sock = None\n        return c"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef close(self):\n        log.debug(\"Closing socket connection for %s:%d\" % (self.host, self.port))\n        if self._sock:\n            # Call shutdown to be a good TCP client\n            # But expect an error if the socket has already been\n            # closed by the server\n            try:\n                self._sock.shutdown(socket.SHUT_RDWR)\n            except socket.error:\n                pass\n\n            # Closing the socket should always succeed\n            self._sock.close()\n            self._sock = None\n        else:\n            log.debug(\"No socket found to close!\")", "response": "Closes the socket connection and returns None"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nconfigures the consumer instance Configuration settings can be passed to constructor, otherwise defaults will be used: Keyword Arguments: bootstrap_servers (list): List of initial broker nodes the consumer should contact to bootstrap initial cluster metadata. This does not have to be the full node list. It just needs to have at least one broker that will respond to a Metadata API Request. client_id (str): a unique name for this client. Defaults to 'kafka.consumer.kafka'. group_id (str): the name of the consumer group to join, Offsets are fetched / committed to this group name. fetch_message_max_bytes (int, optional): Maximum bytes for each topic/partition fetch request. Defaults to 1024*1024. fetch_min_bytes (int, optional): Minimum amount of data the server should return for a fetch request, otherwise wait up to fetch_wait_max_ms for more data to accumulate. Defaults to 1. fetch_wait_max_ms (int, optional): Maximum time for the server to block waiting for fetch_min_bytes messages to accumulate. Defaults to 100. refresh_leader_backoff_ms (int, optional): Milliseconds to backoff when refreshing metadata on errors (subject to random jitter). Defaults to 200. socket_timeout_ms (int, optional): TCP socket timeout in milliseconds. Defaults to 30*1000. auto_offset_reset (str, optional): A policy for resetting offsets on OffsetOutOfRange errors. 'smallest' will move to the oldest available message, 'largest' will move to the most recent. Any ofther value will raise the exception. Defaults to 'largest'. deserializer_class (callable, optional): Any callable that takes a raw message value and returns a deserialized value. Defaults to lambda msg: msg. auto_commit_enable (bool, optional): Enabling auto-commit will cause the KafkaConsumer to periodically commit offsets without an explicit call to commit(). Defaults to False. auto_commit_interval_ms (int, optional): If auto_commit_enabled, the milliseconds between automatic offset commits. Defaults to 60 * 1000. auto_commit_interval_messages (int, optional): If auto_commit_enabled, a number of messages consumed between automatic offset commits. Defaults to None (disabled). consumer_timeout_ms (int, optional): number of millisecond to throw a timeout exception to the consumer if no message is available for consumption. Defaults to -1 (dont throw exception). Configuration parameters are described in more detail at http://kafka.apache.org/documentation.html#highlevelconsumerapi", "response": "def configure(self, **configs):\n        \"\"\"Configure the consumer instance\n\n        Configuration settings can be passed to constructor,\n        otherwise defaults will be used:\n\n        Keyword Arguments:\n            bootstrap_servers (list): List of initial broker nodes the consumer\n                should contact to bootstrap initial cluster metadata.  This does\n                not have to be the full node list.  It just needs to have at\n                least one broker that will respond to a Metadata API Request.\n            client_id (str): a unique name for this client.  Defaults to\n                'kafka.consumer.kafka'.\n            group_id (str): the name of the consumer group to join,\n                Offsets are fetched / committed to this group name.\n            fetch_message_max_bytes (int, optional): Maximum bytes for each\n                topic/partition fetch request.  Defaults to 1024*1024.\n            fetch_min_bytes (int, optional): Minimum amount of data the server\n                should return for a fetch request, otherwise wait up to\n                fetch_wait_max_ms for more data to accumulate.  Defaults to 1.\n            fetch_wait_max_ms (int, optional): Maximum time for the server to\n                block waiting for fetch_min_bytes messages to accumulate.\n                Defaults to 100.\n            refresh_leader_backoff_ms (int, optional): Milliseconds to backoff\n                when refreshing metadata on errors (subject to random jitter).\n                Defaults to 200.\n            socket_timeout_ms (int, optional): TCP socket timeout in\n                milliseconds.  Defaults to 30*1000.\n            auto_offset_reset (str, optional): A policy for resetting offsets on\n                OffsetOutOfRange errors. 'smallest' will move to the oldest\n                available message, 'largest' will move to the most recent.  Any\n                ofther value will raise the exception.  Defaults to 'largest'.\n            deserializer_class (callable, optional):  Any callable that takes a\n                raw message value and returns a deserialized value.  Defaults to\n                 lambda msg: msg.\n            auto_commit_enable (bool, optional): Enabling auto-commit will cause\n                the KafkaConsumer to periodically commit offsets without an\n                explicit call to commit().  Defaults to False.\n            auto_commit_interval_ms (int, optional):  If auto_commit_enabled,\n                the milliseconds between automatic offset commits.  Defaults to\n                60 * 1000.\n            auto_commit_interval_messages (int, optional): If\n                auto_commit_enabled, a number of messages consumed between\n                automatic offset commits.  Defaults to None (disabled).\n            consumer_timeout_ms (int, optional): number of millisecond to throw\n                a timeout exception to the consumer if no message is available\n                for consumption.  Defaults to -1 (dont throw exception).\n\n        Configuration parameters are described in more detail at\n        http://kafka.apache.org/documentation.html#highlevelconsumerapi\n        \"\"\"\n        configs = self._deprecate_configs(**configs)\n        self._config = {}\n        for key in self.DEFAULT_CONFIG:\n            self._config[key] = configs.pop(key, self.DEFAULT_CONFIG[key])\n\n        if configs:\n            raise KafkaConfigurationError('Unknown configuration key(s): ' +\n                                          str(list(configs.keys())))\n\n        if self._config['auto_commit_enable']:\n            if not self._config['group_id']:\n                raise KafkaConfigurationError(\n                    'KafkaConsumer configured to auto-commit '\n                    'without required consumer group (group_id)'\n                )\n\n        # Check auto-commit configuration\n        if self._config['auto_commit_enable']:\n            logger.info(\"Configuring consumer to auto-commit offsets\")\n            self._reset_auto_commit()\n\n        if not self._config['bootstrap_servers']:\n            raise KafkaConfigurationError(\n                'bootstrap_servers required to configure KafkaConsumer'\n            )\n\n        self._client = KafkaClient(\n            self._config['bootstrap_servers'],\n            client_id=self._config['client_id'],\n            timeout=(self._config['socket_timeout_ms'] / 1000.0)\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef set_topic_partitions(self, *topics):\n        self._topics = []\n        self._client.load_metadata_for_topics()\n\n        # Setup offsets\n        self._offsets = OffsetsStruct(fetch=dict(),\n                                      commit=dict(),\n                                      highwater=dict(),\n                                      task_done=dict())\n\n        # Handle different topic types\n        for arg in topics:\n\n            # Topic name str -- all partitions\n            if isinstance(arg, (six.string_types, six.binary_type)):\n                topic = kafka_bytestring(arg)\n\n                for partition in self._client.get_partition_ids_for_topic(topic):\n                    self._consume_topic_partition(topic, partition)\n\n            # (topic, partition [, offset]) tuple\n            elif isinstance(arg, tuple):\n                topic = kafka_bytestring(arg[0])\n                partition = arg[1]\n                self._consume_topic_partition(topic, partition)\n                if len(arg) == 3:\n                    offset = arg[2]\n                    self._offsets.fetch[(topic, partition)] = offset\n\n            # { topic: partitions, ... } dict\n            elif isinstance(arg, dict):\n                for key, value in six.iteritems(arg):\n\n                    # key can be string (a topic)\n                    if isinstance(key, (six.string_types, six.binary_type)):\n                        topic = kafka_bytestring(key)\n\n                        # topic: partition\n                        if isinstance(value, int):\n                            self._consume_topic_partition(topic, value)\n\n                        # topic: [ partition1, partition2, ... ]\n                        elif isinstance(value, (list, tuple)):\n                            for partition in value:\n                                self._consume_topic_partition(topic, partition)\n                        else:\n                            raise KafkaConfigurationError(\n                                'Unknown topic type '\n                                '(dict key must be int or list/tuple of ints)'\n                            )\n\n                    # (topic, partition): offset\n                    elif isinstance(key, tuple):\n                        topic = kafka_bytestring(key[0])\n                        partition = key[1]\n                        self._consume_topic_partition(topic, partition)\n                        self._offsets.fetch[(topic, partition)] = value\n\n            else:\n                raise KafkaConfigurationError('Unknown topic type (%s)' % type(arg))\n\n        # If we have a consumer group, try to fetch stored offsets\n        if self._config['group_id']:\n            self._get_commit_offsets()\n\n        # Update missing fetch/commit offsets\n        for topic_partition in self._topics:\n\n            # Commit offsets default is None\n            if topic_partition not in self._offsets.commit:\n                self._offsets.commit[topic_partition] = None\n\n            # Skip if we already have a fetch offset from user args\n            if topic_partition not in self._offsets.fetch:\n\n                # Fetch offsets default is (1) commit\n                if self._offsets.commit[topic_partition] is not None:\n                    self._offsets.fetch[topic_partition] = self._offsets.commit[topic_partition]\n\n                # or (2) auto reset\n                else:\n                    self._offsets.fetch[topic_partition] = \\\n                        self._reset_partition_offset(topic_partition)\n\n        # highwater marks (received from server on fetch response)\n        # and task_done (set locally by user)\n        # should always get initialized to None\n        self._reset_highwater_offsets()\n        self._reset_task_done_offsets()\n\n        # Reset message iterator in case we were in the middle of one\n        self._reset_message_iterator()", "response": "Sets the topic and partition lists to consume from the given topics."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef next(self):\n        self._set_consumer_timeout_start()\n        while True:\n\n            try:\n                return six.next(self._get_message_iterator())\n\n            # Handle batch completion\n            except StopIteration:\n                self._reset_message_iterator()\n\n            self._check_consumer_timeout()", "response": "Return the next available KafkaMessage from the message iterator"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsends FetchRequests for all topics and partitions and returns a generator that yields KafkaMessage structs for each of them.", "response": "def fetch_messages(self):\n        \"\"\"Sends FetchRequests for all topic/partitions set for consumption\n\n        Returns:\n            Generator that yields KafkaMessage structs\n            after deserializing with the configured `deserializer_class`\n\n        Note:\n            Refreshes metadata on errors, and resets fetch offset on\n            OffsetOutOfRange, per the configured `auto_offset_reset` policy\n\n        See Also:\n            Key KafkaConsumer configuration parameters:\n            * `fetch_message_max_bytes`\n            * `fetch_max_wait_ms`\n            * `fetch_min_bytes`\n            * `deserializer_class`\n            * `auto_offset_reset`\n\n        \"\"\"\n\n        max_bytes = self._config['fetch_message_max_bytes']\n        max_wait_time = self._config['fetch_wait_max_ms']\n        min_bytes = self._config['fetch_min_bytes']\n\n        if not self._topics:\n            raise KafkaConfigurationError('No topics or partitions configured')\n\n        if not self._offsets.fetch:\n            raise KafkaConfigurationError(\n                'No fetch offsets found when calling fetch_messages'\n            )\n\n        fetches = [FetchRequest(topic, partition,\n                                self._offsets.fetch[(topic, partition)],\n                                max_bytes)\n                   for (topic, partition) in self._topics]\n\n        # send_fetch_request will batch topic/partition requests by leader\n        responses = self._client.send_fetch_request(\n            fetches,\n            max_wait_time=max_wait_time,\n            min_bytes=min_bytes,\n            fail_on_error=False\n        )\n\n        for resp in responses:\n\n            if isinstance(resp, FailedPayloadsError):\n                logger.warning('FailedPayloadsError attempting to fetch data')\n                self._refresh_metadata_on_error()\n                continue\n\n            topic = kafka_bytestring(resp.topic)\n            partition = resp.partition\n            try:\n                check_error(resp)\n            except OffsetOutOfRangeError:\n                logger.warning('OffsetOutOfRange: topic %s, partition %d, '\n                               'offset %d (Highwatermark: %d)',\n                               topic, partition,\n                               self._offsets.fetch[(topic, partition)],\n                               resp.highwaterMark)\n                # Reset offset\n                self._offsets.fetch[(topic, partition)] = (\n                    self._reset_partition_offset((topic, partition))\n                )\n                continue\n\n            except NotLeaderForPartitionError:\n                logger.warning(\"NotLeaderForPartitionError for %s - %d. \"\n                               \"Metadata may be out of date\",\n                               topic, partition)\n                self._refresh_metadata_on_error()\n                continue\n\n            except RequestTimedOutError:\n                logger.warning(\"RequestTimedOutError for %s - %d\",\n                               topic, partition)\n                continue\n\n            # Track server highwater mark\n            self._offsets.highwater[(topic, partition)] = resp.highwaterMark\n\n            # Yield each message\n            # Kafka-python could raise an exception during iteration\n            # we are not catching -- user will need to address\n            for (offset, message) in resp.messages:\n                # deserializer_class could raise an exception here\n                val = self._config['deserializer_class'](message.value)\n                msg = KafkaMessage(topic, partition, offset, message.key, val)\n\n                # in some cases the server will return earlier messages\n                # than we requested. skip them per kafka spec\n                if offset < self._offsets.fetch[(topic, partition)]:\n                    logger.debug('message offset less than fetched offset '\n                                 'skipping: %s', msg)\n                    continue\n                # Only increment fetch offset\n                # if we safely got the message and deserialized\n                self._offsets.fetch[(topic, partition)] = offset + 1\n\n                # Then yield to user\n                yield msg"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nrequest available fetch offsets for a single topic and partition.", "response": "def get_partition_offsets(self, topic, partition, request_time_ms, max_num_offsets):\n        \"\"\"Request available fetch offsets for a single topic/partition\n\n        Keyword Arguments:\n            topic (str): topic for offset request\n            partition (int): partition for offset request\n            request_time_ms (int): Used to ask for all messages before a\n                certain time (ms). There are two special values.\n                Specify -1 to receive the latest offset (i.e. the offset of the\n                next coming message) and -2 to receive the earliest available\n                offset. Note that because offsets are pulled in descending\n                order, asking for the earliest offset will always return you a\n                single element.\n            max_num_offsets (int): Maximum offsets to include in the OffsetResponse\n\n        Returns:\n            a list of offsets in the OffsetResponse submitted for the provided\n            topic / partition. See:\n            https://cwiki.apache.org/confluence/display/KAFKA/A+Guide+To+The+Kafka+Protocol#AGuideToTheKafkaProtocol-OffsetAPI\n        \"\"\"\n        reqs = [OffsetRequest(topic, partition, request_time_ms, max_num_offsets)]\n\n        (resp,) = self._client.send_offset_request(reqs)\n\n        check_error(resp)\n\n        # Just for sanity..\n        # probably unnecessary\n        assert resp.topic == topic\n        assert resp.partition == partition\n\n        return resp.offsets"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget internal consumer offset values.", "response": "def offsets(self, group=None):\n        \"\"\"Get internal consumer offset values\n\n        Keyword Arguments:\n            group: Either \"fetch\", \"commit\", \"task_done\", or \"highwater\".\n                If no group specified, returns all groups.\n\n        Returns:\n            A copy of internal offsets struct\n        \"\"\"\n        if not group:\n            return {\n                'fetch': self.offsets('fetch'),\n                'commit': self.offsets('commit'),\n                'task_done': self.offsets('task_done'),\n                'highwater': self.offsets('highwater')\n            }\n        else:\n            return dict(deepcopy(getattr(self._offsets, group)))"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nmarks a message as consumed and store the offset of the next message to fetch.", "response": "def task_done(self, message):\n        \"\"\"Mark a fetched message as consumed.\n\n        Offsets for messages marked as \"task_done\" will be stored back\n        to the kafka cluster for this consumer group on commit()\n\n        Arguments:\n            message (KafkaMessage): the message to mark as complete\n\n        Returns:\n            True, unless the topic-partition for this message has not\n            been configured for the consumer. In normal operation, this\n            should not happen. But see github issue 364.\n        \"\"\"\n        topic_partition = (message.topic, message.partition)\n        if topic_partition not in self._topics:\n            logger.warning('Unrecognized topic/partition in task_done message: '\n                           '{0}:{1}'.format(*topic_partition))\n            return False\n\n        offset = message.offset\n\n        # Warn on non-contiguous offsets\n        prev_done = self._offsets.task_done[topic_partition]\n        if prev_done is not None and offset != (prev_done + 1):\n            logger.warning('Marking task_done on a non-continuous offset: %d != %d + 1',\n                           offset, prev_done)\n\n        # Warn on smaller offsets than previous commit\n        # \"commit\" offsets are actually the offset of the next message to fetch.\n        prev_commit = self._offsets.commit[topic_partition]\n        if prev_commit is not None and ((offset + 1) <= prev_commit):\n            logger.warning('Marking task_done on a previously committed offset?: %d (+1) <= %d',\n                           offset, prev_commit)\n\n        self._offsets.task_done[topic_partition] = offset\n\n        # Check for auto-commit\n        if self._does_auto_commit_messages():\n            self._incr_auto_commit_message_count()\n\n        if self._should_auto_commit():\n            self.commit()\n\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncommitting consumed message offsets to kafka cluster.", "response": "def commit(self):\n        \"\"\"Store consumed message offsets (marked via task_done())\n        to kafka cluster for this consumer_group.\n\n        Returns:\n            True on success, or False if no offsets were found for commit\n\n        Note:\n            this functionality requires server version >=0.8.1.1\n            https://cwiki.apache.org/confluence/display/KAFKA/A+Guide+To+The+Kafka+Protocol#AGuideToTheKafkaProtocol-OffsetCommit/FetchAPI\n        \"\"\"\n        if not self._config['group_id']:\n            logger.warning('Cannot commit without a group_id!')\n            raise KafkaConfigurationError(\n                'Attempted to commit offsets '\n                'without a configured consumer group (group_id)'\n            )\n\n        # API supports storing metadata with each commit\n        # but for now it is unused\n        metadata = b''\n\n        offsets = self._offsets.task_done\n        commits = []\n        for topic_partition, task_done_offset in six.iteritems(offsets):\n\n            # Skip if None\n            if task_done_offset is None:\n                continue\n\n            # Commit offsets as the next offset to fetch\n            # which is consistent with the Java Client\n            # task_done is marked by messages consumed,\n            # so add one to mark the next message for fetching\n            commit_offset = (task_done_offset + 1)\n\n            # Skip if no change from previous committed\n            if commit_offset == self._offsets.commit[topic_partition]:\n                continue\n\n            commits.append(\n                OffsetCommitRequest(topic_partition[0], topic_partition[1],\n                                    commit_offset, metadata)\n            )\n\n        if commits:\n            logger.info('committing consumer offsets to group %s', self._config['group_id'])\n            resps = self._client.send_offset_commit_request(\n                kafka_bytestring(self._config['group_id']), commits,\n                fail_on_error=False\n            )\n\n            for r in resps:\n                check_error(r)\n                topic_partition = (r.topic, r.partition)\n                task_done = self._offsets.task_done[topic_partition]\n                self._offsets.commit[topic_partition] = (task_done + 1)\n\n            if self._config['auto_commit_enable']:\n                self._reset_auto_commit()\n\n            return True\n\n        else:\n            logger.info('No new offsets found to commit in group %s', self._config['group_id'])\n            return False"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef as_json(data, **kwargs):\n\n    if 'sort_keys' not in kwargs:\n        kwargs['sort_keys'] = False\n    if 'ensure_ascii' not in kwargs:\n        kwargs['ensure_ascii'] = False\n\n    data = json.dumps(data, **kwargs)\n\n    return data", "response": "Writes data as json."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreads HTTP body according to given content type.", "response": "def read_body(payload, content_type=JSON_CONTENT_TYPE):\n    \"\"\"Reads HTTP payload according to given content_type.\n\n    Function is capable of reading from payload stream.\n    Read data is then processed according to content_type.\n\n    Note:\n        Content-Type is validated. It means that if read_body\n        body is not capable of reading data in requested type,\n        it will throw an exception.\n\n    If read data was empty method will return false boolean\n    value to indicate that.\n\n    Note:\n        There is no transformation if content type is equal to\n        'text/plain'. What has been read is returned.\n\n    :param stream payload: payload to read, payload should have read method\n    :param str content_type: payload content type, default to application/json\n    :return: read data, returned type depends on content_type or False\n             if empty\n\n    :exception: :py:class:`.UnreadableBody` - in case of any failure when\n                                              reading data\n\n    \"\"\"\n    if content_type not in _READABLE_CONTENT_TYPES:\n        msg = ('Cannot read %s, not in %s' %\n               (content_type, _READABLE_CONTENT_TYPES))\n        raise exceptions.UnsupportedContentTypeException(msg)\n\n    try:\n        content = payload.read()\n        if not content:\n            return None\n    except Exception as ex:\n        raise exceptions.UnreadableContentError(str(ex))\n\n    return _READABLE_CONTENT_TYPES[content_type](content)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\npoll loop for events from other threads", "response": "def timer_fired(self):\n        \"\"\"Polling loop for events from other threads\"\"\"\n        self.__process_idle_events()\n\n        # grab the simulation lock, gather all of the\n        # wpilib objects, and display them on the screen\n        self.update_widgets()\n\n        # call next timer_fired (or we'll never call timer_fired again!)\n        delay = 100  # milliseconds\n        self.root.after(delay, self.timer_fired)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nencodes the given data with snappy", "response": "def snappy_encode(payload, xerial_compatible=False, xerial_blocksize=32 * 1024):\n    \"\"\"Encodes the given data with snappy if xerial_compatible is set then the\n       stream is encoded in a fashion compatible with the xerial snappy library\n\n       The block size (xerial_blocksize) controls how frequent the blocking\n       occurs 32k is the default in the xerial library.\n\n       The format winds up being\n        +-------------+------------+--------------+------------+--------------+\n        |   Header    | Block1 len | Block1 data  | Blockn len | Blockn data  |\n        |-------------+------------+--------------+------------+--------------|\n        |  16 bytes   |  BE int32  | snappy bytes |  BE int32  | snappy bytes |\n        +-------------+------------+--------------+------------+--------------+\n\n        It is important to not that the blocksize is the amount of uncompressed\n        data presented to snappy at each block, whereas the blocklen is the\n        number of bytes that will be present in the stream, that is the\n        length will always be <= blocksize.\n    \"\"\"\n\n    if not has_snappy():\n        raise NotImplementedError(\"Snappy codec is not available\")\n\n    if xerial_compatible:\n        def _chunker():\n            for i in xrange(0, len(payload), xerial_blocksize):\n                yield payload[i:i + xerial_blocksize]\n\n        out = BytesIO()\n\n        header = b''.join([struct.pack('!' + fmt, dat) for fmt, dat\n                           in zip(_XERIAL_V1_FORMAT, _XERIAL_V1_HEADER)])\n\n        out.write(header)\n        for chunk in _chunker():\n            block = snappy.compress(chunk)\n            block_size = len(block)\n            out.write(struct.pack('!i', block_size))\n            out.write(block)\n\n        out.seek(0)\n        return out.read()\n\n    else:\n        return snappy.compress(payload)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef draw_line(\n        self,\n        line_pts,\n        color=\"#ff0000\",\n        robot_coordinates=False,\n        relative_to_first=False,\n        arrow=True,\n        scale=(1, 1),\n        **kwargs\n    ):\n        \"\"\"\n            :param line_pts: A list of (x,y) pairs to draw. (x,y) are in field units\n                             which are measured in feet\n            :param color: The color of the line, expressed as a 6-digit hex color\n            :param robot_coordinates: If True, the pts will be adjusted such that\n                                      the first point starts at the center\n                                      of the robot and that x and y coordinates\n                                      are rotated according to the robot's\n                                      current heading. If a tuple, then the pts\n                                      are adjusted relative to the robot center\n                                      AND the x,y in the tuple\n            :param relative_to_first: If True, the points will be adjusted such\n                                      that the first point is considered to be\n                                      (0,0)\n            :param arrow: If True, draw the line with an arrow at the end\n            :param scale: Multiply all points by this (x,y) tuple\n            :param kwargs: Keyword options to pass to tkinter.create_line\n        \"\"\"\n\n        def _defer():  # called later because the field might not exist yet\n            px_per_ft = UserRenderer._global_ui.field.px_per_ft\n            if arrow:\n                kwargs[\"arrow\"] = \"last\"\n            sx, sy = scale\n            line = DrawableLine(\n                [(x * px_per_ft * sx, y * px_per_ft * sy) for x, y in line_pts],\n                color,\n                kwargs,\n            )\n\n            # if relative to first, create object, then move relative to the first\n            if relative_to_first:\n                line.move((-line.pts[0][0], -line.pts[0][1]))\n\n            if robot_coordinates:\n                self._do_robot_coordinates(line, robot_coordinates)\n\n            line.update_coordinates()\n            UserRenderer._global_ui.field.add_moving_element(line)\n            self._elements.append(line)\n\n        self._run(_defer)", "response": "Draw a line of the specified number of points from the current field."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndraw the text at the specified point.", "response": "def draw_text(\n        self,\n        text,\n        pt,\n        color=\"#000000\",\n        fontSize=10,\n        robot_coordinates=False,\n        scale=(1, 1),\n        **kwargs\n    ):\n        \"\"\"\n            :param text: Text to render\n            :param pt: A tuple of (x,y) in field units (which are measured in feet)\n            :param color: The color of the text, expressed as a 6-digit hex color\n            :param robot_coordinates: If True, the pt will be adjusted such that\n                                      the point starts at the center of the\n                                      robot and that x and y coordinates are\n                                      rotated according to the robot's current\n                                      heading. If a tuple, then the pt\n                                      is adjusted relative to the robot center\n                                      AND the x,y in the tuple\n            :param arrow: If True, draw the line with an arrow at the end\n            :param scale: Multiply all points by this (x,y) tuple\n            :param kwargs: Keyword options to pass to tkinter.create_text\n        \"\"\"\n        x, y = pt\n\n        def _defer():  # called later because the field might not exist yet\n            px_per_ft = UserRenderer._global_ui.field.px_per_ft\n            sx, sy = scale\n            pt = ((x * px_per_ft * sx), (y * px_per_ft * sy))\n\n            el = TextElement(text, pt, 0, color, fontSize, **kwargs)\n\n            if robot_coordinates:\n                self._do_robot_coordinates(el, robot_coordinates)\n\n            el.update_coordinates()\n            UserRenderer._global_ui.field.add_moving_element(el)\n            self._elements.append(el)\n\n        self._run(_defer)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef murmur2(key):\n\n    # Convert key to bytes or bytearray\n    if isinstance(key, bytearray) or (six.PY3 and isinstance(key, bytes)):\n        data = key\n    else:\n        data = bytearray(str(key).encode())\n\n    length = len(data)\n    seed = 0x9747b28c\n    # 'm' and 'r' are mixing constants generated offline.\n    # They're not really 'magic', they just happen to work well.\n    m = 0x5bd1e995\n    r = 24\n\n    # Initialize the hash to a random value\n    h = seed ^ length\n    length4 = length // 4\n\n    for i in range(length4):\n        i4 = i * 4\n        k = ((data[i4 + 0] & 0xff) +\n             ((data[i4 + 1] & 0xff) << 8) +\n             ((data[i4 + 2] & 0xff) << 16) +\n             ((data[i4 + 3] & 0xff) << 24))\n        k &= 0xffffffff\n        k *= m\n        k &= 0xffffffff\n        k ^= (k % 0x100000000) >> r  # k ^= k >>> r\n        k &= 0xffffffff\n        k *= m\n        k &= 0xffffffff\n\n        h *= m\n        h &= 0xffffffff\n        h ^= k\n        h &= 0xffffffff\n\n    # Handle the last few bytes of the input array\n    extra_bytes = length % 4\n    if extra_bytes >= 3:\n        h ^= (data[(length & ~3) + 2] & 0xff) << 16\n        h &= 0xffffffff\n    if extra_bytes >= 2:\n        h ^= (data[(length & ~3) + 1] & 0xff) << 8\n        h &= 0xffffffff\n    if extra_bytes >= 1:\n        h ^= (data[length & ~3] & 0xff)\n        h &= 0xffffffff\n        h *= m\n        h &= 0xffffffff\n\n    h ^= (h % 0x100000000) >> 13  # h >>> 13;\n    h &= 0xffffffff\n    h *= m\n    h &= 0xffffffff\n    h ^= (h % 0x100000000) >> 15  # h >>> 15;\n    h &= 0xffffffff\n\n    return h", "response": "Pure - python Murmur2 implementation."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ninitialize an Enforcer class.", "response": "def init(policy_file=None, rules=None, default_rule=None, use_conf=True):\n    \"\"\"Init an Enforcer class.\n\n       :param policy_file: Custom policy file to use, if none is specified,\n                           `CONF.policy_file` will be used.\n       :param rules: Default dictionary / Rules to use. It will be\n                     considered just in the first instantiation.\n       :param default_rule: Default rule to use, CONF.default_rule will\n                            be used if none is specified.\n       :param use_conf: Whether to load rules from config file.\n    \"\"\"\n\n    global _ENFORCER\n    global saved_file_rules\n\n    if not _ENFORCER:\n        _ENFORCER = policy.Enforcer(CONF,\n                                    policy_file=policy_file,\n                                    rules=rules,\n                                    default_rule=default_rule,\n                                    use_conf=use_conf\n                                    )\n        register_rules(_ENFORCER)\n        _ENFORCER.load_rules()\n    # Only the rules which are loaded from file may be changed\n    current_file_rules = _ENFORCER.file_rules\n    current_file_rules = _serialize_rules(current_file_rules)\n\n    if saved_file_rules != current_file_rules:\n        _warning_for_deprecated_user_based_rules(current_file_rules)\n        saved_file_rules = copy.deepcopy(current_file_rules)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _serialize_rules(rules):\n    result = [(rule_name, str(rule)) for rule_name, rule in rules.items()]\n    return sorted(result, key=lambda rule: rule[0])", "response": "Serialize all the Rule object as string.\n    New string is used to compare the rules list.\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ndeprecates user based policy enforcement used in the rule but the rule doesn t support it.", "response": "def _warning_for_deprecated_user_based_rules(rules):\n    \"\"\"Warning user based policy enforcement used in the rule but the rule\n    doesn't support it.\n    \"\"\"\n    for rule in rules:\n        # We will skip the warning for the resources which support user based\n        # policy enforcement.\n        if [resource for resource in USER_BASED_RESOURCES\n                if resource in rule[0]]:\n            continue\n        if 'user_id' in KEY_EXPR.findall(rule[1]):\n            LOG.warning(_LW(\"The user_id attribute isn't supported in the \"\n                            \"rule '%s'. All the user_id based policy \"\n                            \"enforcement will be removed in the \"\n                            \"future.\"), rule[0])"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef authorize(context, action, target, do_raise=True):\n    init()\n    credentials = context.to_policy_values()\n    try:\n        result = _ENFORCER.authorize(action, target, credentials,\n                                     do_raise=do_raise, action=action)\n        return result\n    except policy.PolicyNotRegistered:\n        LOG.exception('Policy not registered')\n        raise\n    except Exception:\n        LOG.debug('Policy check for %(action)s failed with credentials '\n                  '%(credentials)s',\n                  {'action': action, 'credentials': credentials})\n        raise", "response": "Verify that the action is valid on the target in this context."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef check_is_admin(context):\n    init()\n    credentials = context.to_policy_values()\n    target = credentials\n    return _ENFORCER.authorize('admin_required', target, credentials)", "response": "Check if roles contains admin role according to policy settings."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set_rules(rules, overwrite=True, use_conf=False):  # pragma: no cover\n    init(use_conf=False)\n    _ENFORCER.set_rules(rules, overwrite, use_conf)", "response": "Set the rules of the current node."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef verify_deprecated_policy(old_policy, new_policy, default_rule, context):\n\n    if _ENFORCER:\n        current_rule = str(_ENFORCER.rules[old_policy])\n    else:\n        current_rule = None\n\n    if current_rule != default_rule:\n        LOG.warning(\"Start using the new action '{0}'. The existing \"\n                    \"action '{1}' is being deprecated and will be \"\n                    \"removed in future release.\".format(new_policy,\n                                                        old_policy))\n        target = {'project_id': context.project_id,\n                  'user_id': context.user_id}\n\n        return authorize(context=context, action=old_policy, target=target)\n    else:\n        return False", "response": "Verify that the old_policy is being deprecated and that the new_policy is being replaced with the new_policy."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nbuilding sample problem from Wang 2004.", "response": "def build_sample_ace_problem_wang04(N=100):\n    \"\"\"Build sample problem from Wang 2004.\"\"\"\n    x = [numpy.random.uniform(-1, 1, size=N)\n         for _i in range(0, 5)]\n    noise = numpy.random.standard_normal(N)\n    y = numpy.log(4.0 + numpy.sin(4 * x[0]) + numpy.abs(x[1]) + x[2] ** 2 +\n                  x[3] ** 3 + x[4] + 0.1 * noise)\n    return x, y"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nruns sample problem with Wang - 04 ACE.", "response": "def run_wang04():\n    \"\"\"Run sample problem.\"\"\"\n    x, y = build_sample_ace_problem_wang04(N=200)\n    ace_solver = ace.ACESolver()\n    ace_solver.specify_data_set(x, y)\n    ace_solver.solve()\n    try:\n        ace.plot_transforms(ace_solver, 'ace_transforms_wang04.png')\n        ace.plot_input(ace_solver, 'ace_input_wang04.png')\n    except ImportError:\n        pass\n\n    return ace_solver"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef add_robot(self, controller):\n\n        # connect to the controller\n        # -> this is to support module robots\n        controller.on_mode_change(self._on_robot_mode_change)\n        self.robots.append(controller)", "response": "Add a robot controller to the list of robots"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef set_joystick(self, x, y, n):\n        self.robots[n].set_joystick(x, y)", "response": "Sets the joystick coordinates of the iCal entry with the coordinates x y."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ndisconnecting from the broker.", "response": "async def disconnect(self):\n        \"\"\"\n            Disconnect coroutine\n        \"\"\"\n\n        async with self._disconnect_lock:\n            if self._state == ConnectionState.DISCONNECTED:\n                return\n\n            self._set_state(ConnectionState.DISCONNECTING)\n\n            logger.info('%s Disconnecting...', self.fingerprint)\n            if self._reconnect_task:\n                self._reconnect_task.cancel()\n                self._reconnect_task = None\n\n            if self._ping_task and not self._ping_task.done():\n                self._ping_task.cancel()\n                self._ping_task = None\n\n            self._db = _DbMock()\n            if self._transport:\n                self._disconnect_waiter = _create_future(self._loop)\n                self._transport.close()\n                self._transport = None\n                self._protocol = None\n\n                await self._disconnect_waiter\n                self._disconnect_waiter = None\n                self._set_state(ConnectionState.DISCONNECTED)\n            else:\n                self._transport = None\n                self._protocol = None\n                self._disconnect_waiter = None\n                self._set_state(ConnectionState.DISCONNECTED)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef close(self):\n\n        if self._state == ConnectionState.DISCONNECTED:\n            return\n\n        self._set_state(ConnectionState.DISCONNECTING)\n        logger.info('%s Disconnecting...', self.fingerprint)\n\n        if self._reconnect_task and not self._reconnect_task.done():\n            self._reconnect_task.cancel()\n            self._reconnect_task = None\n\n        if self._ping_task and not self._ping_task.done():\n            self._ping_task.cancel()\n            self._ping_task = None\n\n        if self._transport:\n            self._transport.close()\n\n        self._transport = None\n        self._protocol = None\n        self._disconnect_waiter = None\n        self._db = _DbMock()\n        self._set_state(ConnectionState.DISCONNECTED)", "response": "Same as disconnect, but not a coroutine, i.e. it does not wait\n            for disconnect to finish."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncalls request coroutine. It is a call with a new behaviour (return result of a Tarantool procedure is not wrapped into an extra tuple). If you're connecting to Tarantool with version < 1.7, then this call method acts like a call16 method Examples: .. code-block:: pycon # tarantool function: # function f(...) # return ... # end >>> await conn.call('f') <Response sync=3 rowcount=0 data=[]> >>> await conn.call('f', [20, 42]) <Response sync=3 rowcount=2 data=[20, 42]> :param func_name: function name to call :param args: arguments to pass to the function (list object) :param timeout: Request timeout :param push_subscribe: Subscribe to push notifications :returns: :class:`asynctnt.Response` instance", "response": "def call(self, func_name, args=None, *,\n             timeout=-1.0, push_subscribe=False) -> _MethodRet:\n        \"\"\"\n            Call request coroutine. It is a call with a new behaviour\n            (return result of a Tarantool procedure is not wrapped into\n            an extra tuple). If you're connecting to Tarantool with\n            version < 1.7, then this call method acts like a call16 method\n\n            Examples:\n\n            .. code-block:: pycon\n\n                # tarantool function:\n                # function f(...)\n                #     return ...\n                # end\n\n                >>> await conn.call('f')\n                <Response sync=3 rowcount=0 data=[]>\n\n                >>> await conn.call('f', [20, 42])\n                <Response sync=3 rowcount=2 data=[20, 42]>\n\n            :param func_name: function name to call\n            :param args: arguments to pass to the function (list object)\n            :param timeout: Request timeout\n            :param push_subscribe: Subscribe to push notifications\n\n            :returns: :class:`asynctnt.Response` instance\n        \"\"\"\n        return self._db.call(func_name, args,\n                             timeout=timeout, push_subscribe=push_subscribe)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nexecuting an expression and return the result.", "response": "def eval(self, expression, args=None, *,\n             timeout=-1.0, push_subscribe=False) -> _MethodRet:\n        \"\"\"\n            Eval request coroutine.\n\n            Examples:\n\n            .. code-block:: pycon\n\n                >>> await conn.eval('return 42')\n                <Response sync=3 rowcount=1 data=[42]>\n\n\n                >>> await conn.eval('return box.info.version')\n                <Response sync=3 rowcount=1 data=['2.1.1-7-gd381a45b6']>\n\n            :param expression: expression to execute\n            :param args: arguments to pass to the function, that will\n                         execute your expression (list object)\n            :param timeout: Request timeout\n            :param push_subscribe: Subscribe to push messages\n\n            :returns: :class:`asynctnt.Response` instance\n        \"\"\"\n        return self._db.eval(expression, args,\n                             timeout=timeout, push_subscribe=push_subscribe)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nselecting an object in a specific space.", "response": "def select(self, space, key=None, **kwargs) -> _MethodRet:\n        \"\"\"\n            Select request coroutine.\n\n            Examples:\n\n            .. code-block:: pycon\n\n                >>> await conn.select('tester')\n                <Response sync=3 rowcount=2 data=[\n                    <TarantoolTuple id=1 name='one'>,\n                    <TarantoolTuple id=2 name='two'>\n                ]>\n\n                >>> res = await conn.select('_space', ['tester'], index='name')\n                >>> res.data\n                [<TarantoolTuple id=512\n                                 owner=1\n                                 name='tester'\n                                 engine='memtx'\n                                 field_count=0\n                                 flags={}\n                                 format=[\n                                    {'name': 'id', 'type': 'unsigned'},\n                                    {'name': 'name', 'type': 'string'}\n                                 ]>]\n\n\n            :param space: space id or space name.\n            :param key: key to select\n            :param offset: offset to use\n            :param limit: limit to use\n            :param index: index id or name\n            :param iterator: one of the following\n\n                        * iterator id (int number),\n                        * :class:`asynctnt.Iterator` object\n                        * string with an iterator name\n\n            :param timeout: Request timeout\n\n            :returns: :class:`asynctnt.Response` instance\n        \"\"\"\n        return self._db.select(space, key, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ninsert a new entry into the database.", "response": "def insert(self, space, t, *, replace=False, timeout=-1) -> _MethodRet:\n        \"\"\"\n            Insert request coroutine.\n\n            Examples:\n\n            .. code-block:: pycon\n\n                # Basic usage\n                >>> await conn.insert('tester', [0, 'hello'])\n                <Response sync=3 rowcount=1 data=[\n                    <TarantoolTuple id=0 name='hello'>\n                ]>\n\n                # Using dict as an argument tuple\n                >>> await conn.insert('tester', {\n                ...                     'id': 0\n                ...                     'text': 'hell0'\n                ...                   })\n                <Response sync=3 rowcount=1 data=[\n                    <TarantoolTuple id=0 name='hello'>\n                ]>\n\n            :param space: space id or space name.\n            :param t: tuple to insert (list object)\n            :param replace: performs replace request instead of insert\n            :param timeout: Request timeout\n\n            :returns: :class:`asynctnt.Response` instance\n        \"\"\"\n        return self._db.insert(space, t,\n                               replace=replace,\n                               timeout=timeout)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef replace(self, space, t, *, timeout=-1.0) -> _MethodRet:\n        return self._db.replace(space, t, timeout=timeout)", "response": "Replace an entry in the cache with a new one."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef delete(self, space, key, **kwargs) -> _MethodRet:\n        return self._db.delete(space, key, **kwargs)", "response": "Delete an object in a specific space."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef update(self, space, key, operations, **kwargs) -> _MethodRet:\n        return self._db.update(space, key, operations, **kwargs)", "response": "Update the object in a specific key in a space."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ninserting or update a tuple in a space.", "response": "def upsert(self, space, t, operations, **kwargs) -> _MethodRet:\n        \"\"\"\n            Update request coroutine. Performs either insert or update\n            (depending of either tuple exists or not)\n\n            Examples:\n\n            .. code-block:: pycon\n\n                # upsert does not return anything\n                >>> await conn.upsert('tester', [0, 'hello'],\n                ...                   [ ['=', 1, 'hi!'] ])\n                <Response sync=3 rowcount=0 data=[]>\n\n            :param space: space id or space name.\n            :param t: tuple to insert if it's not in space\n            :param operations:\n                    Operations list to use for update if tuple is already in\n                    space. It has the same format as in update requets:\n                    [ [op_type, field_no, ...], ... ]. Please refer to\n                    https://tarantool.org/doc/book/box/box_space.html?highlight=update#lua-function.space_object.update\n                    You can use field numbers as well as their names in space\n                    format as a field_no (if only fetch_schema is True).\n                    If field is unknown then TarantoolSchemaError is raised.\n            :param timeout: Request timeout\n\n            :returns: :class:`asynctnt.Response` instance\n        \"\"\"\n        return self._db.upsert(space, t, operations, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef sql(self, query, args=None, *,\n            parse_metadata=True, timeout=-1.0) -> _MethodRet:\n        \"\"\"\n            Executes an SQL statement (only for Tarantool > 2)\n\n            Examples:\n\n            .. code-block:: pycon\n\n                >>> await conn.sql(\"select 1 as a, 2 as b\")\n                <Response sync=3 rowcount=1 data=[<TarantoolTuple A=1 B=2>]>\n\n                >>> await conn.sql(\"select * from sql_space\")\n                <Response sync=3 rowcount=2 data=[\n                    <TarantoolTuple ID=1 NAME='James Bond'>,\n                    <TarantoolTuple ID=2 NAME='Ethan Hunt'>\n                ]>\n\n                >>> await conn.sql(\"select * from sql_space\",\n                ...                parse_metadata=False)\n                <Response sync=3 rowcount=2 data=[\n                    <TarantoolTuple 0=1 1='James Bond'>,\n                    <TarantoolTuple 0=2 1='Ethan Hunt'>\n                ]>\n\n            :param query: SQL query\n            :param args: Query arguments\n            :param parse_metadata: Set to False to disable response's metadata\n                                   parsing for better performance\n            :param timeout: Request timeout\n\n            :returns: :class:`asynctnt.Response` instance\n        \"\"\"\n        return self._db.sql(query, args,\n                            parse_metadata=parse_metadata,\n                            timeout=timeout)", "response": "Executes an SQL query and returns the result."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _compute_primary_smooths(self):\n        for span in DEFAULT_SPANS:\n            smooth = smoother.perform_smooth(self.x, self.y, span)\n            self._primary_smooths.append(smooth)", "response": "Compute fixed - span smooths with all of the default spans."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _smooth_the_residuals(self):\n        for primary_smooth in self._primary_smooths:\n            smooth = smoother.perform_smooth(self.x,\n                                             primary_smooth.cross_validated_residual,\n                                             MID_SPAN)\n            self._residual_smooths.append(smooth.smooth_result)", "response": "Perform the MID_SPAN on the residuals of the primary smooths."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _select_best_smooth_at_each_point(self):\n        for residuals_i in zip(*self._residual_smooths):\n            index_of_best_span = residuals_i.index(min(residuals_i))\n            self._best_span_at_each_point.append(DEFAULT_SPANS[index_of_best_span])", "response": "Select the best smooth for each observation at each point."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _enhance_bass(self):\n        if not self._bass_enhancement:\n            # like in supsmu, skip if alpha=0\n            return\n        bass_span = DEFAULT_SPANS[BASS_INDEX]\n        enhanced_spans = []\n        for i, best_span_here in enumerate(self._best_span_at_each_point):\n            best_smooth_index = DEFAULT_SPANS.index(best_span_here)\n            best_span = DEFAULT_SPANS[best_smooth_index]\n            best_span_residual = self._residual_smooths[best_smooth_index][i]\n            bass_span_residual = self._residual_smooths[BASS_INDEX][i]\n            if 0 < best_span_residual < bass_span_residual:\n                ri = best_span_residual / bass_span_residual\n                bass_factor = ri ** (10.0 - self._bass_enhancement)\n                enhanced_spans.append(best_span + (bass_span - best_span) * bass_factor)\n            else:\n                enhanced_spans.append(best_span)\n        self._best_span_at_each_point = enhanced_spans", "response": "Update the best span choices with bass enhancement as requested by user."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\napplying a MID_SPAN smooth to the best span estimates at each observation.", "response": "def _smooth_best_span_estimates(self):\n        \"\"\"Apply a MID_SPAN smooth to the best span estimates at each observation.\"\"\"\n        self._smoothed_best_spans = smoother.perform_smooth(self.x,\n                                                            self._best_span_at_each_point,\n                                                            MID_SPAN)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\napplying the best spans. Given the best span interpolate to compute the best smoothed value at each observation.", "response": "def _apply_best_spans_to_primaries(self):\n        \"\"\"\n        Apply best spans.\n\n        Given the best span, interpolate to compute the best smoothed value\n        at each observation.\n        \"\"\"\n        self.smooth_result = []\n        for xi, best_span in enumerate(self._smoothed_best_spans.smooth_result):\n            primary_values = [s.smooth_result[xi] for s in self._primary_smooths]\n            # pylint: disable=no-member\n            best_value = numpy.interp(best_span, DEFAULT_SPANS, primary_values)\n            self.smooth_result.append(best_value)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _smooth_interpolated_smooth(self):\n        smoothed_results = smoother.perform_smooth(self.x,\n                                                   self.smooth_result,\n                                                   TWEETER_SPAN)\n        self.smooth_result = smoothed_results.smooth_result", "response": "Smooth interpolated results with tweeter span."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _mp_consume(client, group, topic, queue, size, events, **consumer_options):\n\n    # Initial interval for retries in seconds.\n    interval = 1\n    while not events.exit.is_set():\n        try:\n            # Make the child processes open separate socket connections\n            client.reinit()\n\n            # We will start consumers without auto-commit. Auto-commit will be\n            # done by the master controller process.\n            consumer = SimpleConsumer(client, group, topic,\n                                      auto_commit=False,\n                                      auto_commit_every_n=None,\n                                      auto_commit_every_t=None,\n                                      **consumer_options)\n\n            # Ensure that the consumer provides the partition information\n            consumer.provide_partition_info()\n\n            while True:\n                # Wait till the controller indicates us to start consumption\n                events.start.wait()\n\n                # If we are asked to quit, do so\n                if events.exit.is_set():\n                    break\n\n                # Consume messages and add them to the queue. If the controller\n                # indicates a specific number of messages, follow that advice\n                count = 0\n\n                message = consumer.get_message()\n                if message:\n                    while True:\n                        try:\n                            queue.put(message, timeout=FULL_QUEUE_WAIT_TIME_SECONDS)\n                            break\n                        except queue.Full:\n                            if events.exit.is_set():\n                                break\n\n                    count += 1\n\n                    # We have reached the required size. The controller might have\n                    # more than what he needs. Wait for a while.\n                    # Without this logic, it is possible that we run into a big\n                    # loop consuming all available messages before the controller\n                    # can reset the 'start' event\n                    if count == size.value:\n                        events.pause.wait()\n\n                else:\n                    # In case we did not receive any message, give up the CPU for\n                    # a while before we try again\n                    time.sleep(NO_MESSAGES_WAIT_TIME_SECONDS)\n\n            consumer.stop()\n\n        except KafkaError as e:\n            # Retry with exponential backoff\n            log.error(\n                \"Problem communicating with Kafka (%s), retrying in %d seconds...\" % (e, interval))\n            time.sleep(interval)\n            interval = interval * 2 if interval * 2 < MAX_BACKOFF_SECONDS else MAX_BACKOFF_SECONDS", "response": "This function is a multiprocessing module which processes messages based on the messages in the queue and processes them."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nmoves the object to the new location", "response": "def move(self, v):\n        \"\"\"v is a tuple of x/y coordinates to move object\"\"\"\n\n        # rotate movement vector according to the angle of the object\n        vx, vy = v\n        vx, vy = (\n            vx * math.cos(self.angle) - vy * math.sin(self.angle),\n            vx * math.sin(self.angle) + vy * math.cos(self.angle),\n        )\n\n        def _move(xy):\n            x, y = xy\n            return x + vx, y + vy\n\n        # TODO: detect other objects in the way, stop movement appropriately\n\n        self.pts = [p for p in map(lambda x: _move(x), self.pts)]\n        self.center = _move(self.center)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef rotate(self, angle):\n\n        self.angle = (self.angle + angle) % (math.pi * 2.0)\n\n        # precalculate these parameters\n        c = math.cos(angle)\n        s = math.sin(angle)\n        px, py = self.center\n\n        def _rotate_point(xy):\n\n            x, y = xy\n\n            x = x - px\n            y = y - py\n\n            return (x * c - y * s) + px, (x * s + y * c) + py\n\n        # calculate rotation for each point\n        self.pts = [p for p in map(lambda x: _rotate_point(x), self.pts)]", "response": "This works. Rotates the object about its center."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\npublishing messages to the specified topic.", "response": "def publish(self, topic, messages, key=None, timeout=2):\n        \"\"\"\n        Publish messages to the topic.\n\n        :param str topic: Topic to produce messages to.\n        :param list(str) messages:  List of message payloads.\n        :param str key: Message key.\n        :param float timeout: Maximum time to block in seconds.\n        :returns: Number of messages still in queue.\n        :rtype int\n        \"\"\"\n\n        if not isinstance(messages, list):\n            messages = [messages]\n\n        try:\n            for m in messages:\n                m = encodeutils.safe_encode(m, incoming='utf-8')\n                self._producer.produce(topic, m, key,\n                                       callback=KafkaProducer.delivery_report)\n                self._producer.poll(0)\n\n            return self._producer.flush(timeout)\n\n        except (BufferError, confluent_kafka.KafkaException,\n                NotImplementedError):\n            log.exception(u'Error publishing to {} topic.'.format(topic))\n            raise"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef increment_time_by(self, secs):\n        self.slept = [True] * 3\n\n        was_paused = False\n\n        with self.lock:\n\n            self._increment_tm(secs)\n\n            while self.paused and secs > 0:\n\n                if self.pause_secs is not None:\n                    # if pause_secs is set, this means it was a step operation,\n                    # so we adjust the wait accordingly\n                    if secs > self.pause_secs:\n                        secs -= self.pause_secs\n                    else:\n                        secs = 0\n\n                    self.pause_secs = None\n\n                was_paused = True\n\n                self.lock.wait()\n\n                # if the operator tried to do another step, this will update\n                # the paused flag so we don't escape the loop\n                self._increment_tm(secs)\n\n        if not was_paused:\n            time.sleep(secs)", "response": "This is called when the time is in the middle of the operation."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_cache_key(page):\n    try:\n        site_id = page.node.site_id\n    except AttributeError:\n        site_id = page.site_id\n    return _get_cache_key('page_sitemap', page, 'default', site_id)", "response": "Create the cache key for the current page and language\n   "}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef out_name(stem, timestep=None):\n    if timestep is not None:\n        stem = (stem + INT_FMT).format(timestep)\n    return conf.core.outname + '_' + stem", "response": "Return StagPy out file name."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nsave matplotlib figure. You need to provide :data:`stem` as a positional or keyword argument (see :func:`out_name`). Args: fig (:class:`matplotlib.figure.Figure`): matplotlib figure. close (bool): whether to close the figure. name_args: positional arguments passed on to :func:`out_name`. name_kwargs: keyword arguments passed on to :func:`out_name`.", "response": "def saveplot(fig, *name_args, close=True, **name_kwargs):\n    \"\"\"Save matplotlib figure.\n\n    You need to provide :data:`stem` as a positional or keyword argument (see\n    :func:`out_name`).\n\n    Args:\n        fig (:class:`matplotlib.figure.Figure`): matplotlib figure.\n        close (bool): whether to close the figure.\n        name_args: positional arguments passed on to :func:`out_name`.\n        name_kwargs: keyword arguments passed on to :func:`out_name`.\n    \"\"\"\n    oname = out_name(*name_args, **name_kwargs)\n    fig.savefig('{}.{}'.format(oname, conf.plot.format),\n                format=conf.plot.format, bbox_inches='tight')\n    if close:\n        plt.close(fig)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the first line of the docstring of an object.", "response": "def baredoc(obj):\n    \"\"\"Return the first line of the docstring of an object.\n\n    Trailing periods and spaces as well as leading spaces are removed from the\n    output.\n\n    Args:\n        obj: any Python object.\n    Returns:\n        str: the first line of the docstring of obj.\n    \"\"\"\n    doc = getdoc(obj)\n    if not doc:\n        return ''\n    doc = doc.splitlines()[0]\n    return doc.rstrip(' .').lstrip()"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns LaTeX expression with time in scientific notation.", "response": "def fmttime(tin):\n    \"\"\"Return LaTeX expression with time in scientific notation.\n\n    Args:\n        tin (float): the time.\n    Returns:\n        str: the LaTeX expression.\n    \"\"\"\n    aaa, bbb = '{:.2e}'.format(tin).split('e')\n    bbb = int(bbb)\n    return r'$t={} \\times 10^{{{}}}$'.format(aaa, bbb)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef list_of_vars(arg_plot):\n    lovs = [[[var for var in svars.split(',') if var]\n             for svars in pvars.split('.') if svars]\n            for pvars in arg_plot.split('-') if pvars]\n    lovs = [[slov for slov in lov if slov] for lov in lovs if lov]\n    return [lov for lov in lovs if lov]", "response": "Construct list of variables per plot."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef set_of_vars(lovs):\n    return set(var for pvars in lovs for svars in pvars for var in svars)", "response": "Build set of variables from list of variables."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the radial or vertical positions of boundaries of the current object.", "response": "def get_rbounds(step):\n    \"\"\"Radial or vertical position of boundaries.\n\n    Args:\n        step (:class:`~stagpy.stagyydata._Step`): a step of a StagyyData\n            instance.\n    Returns:\n        tuple of floats: radial or vertical positions of boundaries of the\n        domain.\n    \"\"\"\n    if step.geom is not None:\n        rcmb = step.geom.rcmb\n    else:\n        rcmb = step.sdat.par['geometry']['r_cmb']\n        if step.sdat.par['geometry']['shape'].lower() == 'cartesian':\n            rcmb = 0\n    rcmb = max(rcmb, 0)\n    return rcmb, rcmb + 1"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef fnames(self, names):\n        names = list(names[:len(self._fnames)])\n        self._fnames = names + self._fnames[len(names):]", "response": "Ensure constant size of fnames"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nextracts or compute a time series from a StagyyData instance and a key of the appropriate type.", "response": "def get_time_series(sdat, var, tstart, tend):\n    \"\"\"Extract or compute and rescale a time series.\n\n    Args:\n        sdat (:class:`~stagpy.stagyydata.StagyyData`): a StagyyData instance.\n        var (str): time series name, a key of :data:`stagpy.phyvars.TIME`\n            or :data:`stagpy.phyvars.TIME_EXTRA`.\n        tstart (float): starting time of desired series. Set to None to start\n            at the beginning of available data.\n        tend (float): ending time of desired series. Set to None to stop at the\n            end of available data.\n    Returns:\n        tuple of :class:`numpy.array` and :class:`stagpy.phyvars.Vart`:\n        series, time, meta\n            series is the requested time series, time the time at which it\n            is evaluated (set to None if it is the one of time series output\n            by StagYY), and meta is a :class:`stagpy.phyvars.Vart` instance\n            holding metadata of the requested variable.\n    \"\"\"\n    tseries = sdat.tseries_between(tstart, tend)\n    if var in tseries.columns:\n        series = tseries[var]\n        time = None\n        if var in phyvars.TIME:\n            meta = phyvars.TIME[var]\n        else:\n            meta = phyvars.Vart(var, None, '1')\n    elif var in phyvars.TIME_EXTRA:\n        meta = phyvars.TIME_EXTRA[var]\n        series, time = meta.description(sdat, tstart, tend)\n        meta = phyvars.Vart(misc.baredoc(meta.description),\n                            meta.kind, meta.dim)\n    else:\n        raise UnknownTimeVarError(var)\n\n    series, _ = sdat.scale(series, meta.dim)\n    if time is not None:\n        time, _ = sdat.scale(time, 's')\n    return series, time, meta"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef plot_time_series(sdat, lovs):\n    sovs = misc.set_of_vars(lovs)\n    tseries = {}\n    times = {}\n    metas = {}\n    for tvar in sovs:\n        series, time, meta = get_time_series(\n            sdat, tvar, conf.time.tstart, conf.time.tend)\n        tseries[tvar] = series\n        metas[tvar] = meta\n        if time is not None:\n            times[tvar] = time\n    tseries['t'] = get_time_series(\n        sdat, 't', conf.time.tstart, conf.time.tend)[0]\n\n    _plot_time_list(sdat, lovs, tseries, metas, times)", "response": "Plot requested time series."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef compstat(sdat, tstart=None, tend=None):\n    data = sdat.tseries_between(tstart, tend)\n    time = data['t'].values\n    delta_time = time[-1] - time[0]\n    data = data.iloc[:, 1:].values  # assume t is first column\n\n    mean = np.trapz(data, x=time, axis=0) / delta_time\n    rms = np.sqrt(np.trapz((data - mean)**2, x=time, axis=0) / delta_time)\n\n    with open(misc.out_name('statistics.dat'), 'w') as out_file:\n        mean.tofile(out_file, sep=' ', format=\"%10.5e\")\n        out_file.write('\\n')\n        rms.tofile(out_file, sep=' ', format=\"%10.5e\")\n        out_file.write('\\n')", "response": "Compute statistics from series output by StagYY."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef cmd():\n    sdat = StagyyData(conf.core.path)\n    if sdat.tseries is None:\n        return\n\n    if conf.time.fraction is not None:\n        if not 0 < conf.time.fraction <= 1:\n            raise InvalidTimeFractionError(conf.time.fraction)\n        conf.time.tend = None\n        t_0 = sdat.tseries.iloc[0].loc['t']\n        t_f = sdat.tseries.iloc[-1].loc['t']\n        conf.time.tstart = (t_0 * conf.time.fraction +\n                            t_f * (1 - conf.time.fraction))\n\n    lovs = misc.list_of_vars(conf.time.plot)\n    if lovs:\n        plot_time_series(sdat, lovs)\n\n    if conf.time.compstat:\n        compstat(sdat, conf.time.tstart, conf.time.tend)", "response": "Implementation of time subcommand.\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nprints basic information about the current StagYY run.", "response": "def info_cmd():\n    \"\"\"Print basic information about StagYY run.\"\"\"\n    sdat = stagyydata.StagyyData(conf.core.path)\n    lsnap = sdat.snaps.last\n    lstep = sdat.steps.last\n    print('StagYY run in {}'.format(sdat.path))\n    if lsnap.geom.threed:\n        dimension = '{} x {} x {}'.format(lsnap.geom.nxtot,\n                                          lsnap.geom.nytot,\n                                          lsnap.geom.nztot)\n    elif lsnap.geom.twod_xz:\n        dimension = '{} x {}'.format(lsnap.geom.nxtot,\n                                     lsnap.geom.nztot)\n    else:\n        dimension = '{} x {}'.format(lsnap.geom.nytot,\n                                     lsnap.geom.nztot)\n    if lsnap.geom.cartesian:\n        print('Cartesian', dimension)\n    elif lsnap.geom.cylindrical:\n        print('Cylindrical', dimension)\n    else:\n        print('Spherical', dimension)\n    print('Last timestep:',\n          '  istep: {}'.format(lstep.istep),\n          '  time:  {}'.format(lstep.timeinfo['t']),\n          '  <T>:   {}'.format(lstep.timeinfo['Tmean']),\n          sep='\\n')\n    print('Last snapshot (istep {}):'.format(lsnap.istep),\n          '  isnap: {}'.format(lsnap.isnap),\n          '  time:  {}'.format(lsnap.timeinfo['t']),\n          '  output fields: {}'.format(','.join(lsnap.fields)),\n          sep='\\n')"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nprints a list of key - value pairs in a pretty format.", "response": "def _pretty_print(key_val, sep=': ', min_col_width=39, text_width=None):\n    \"\"\"Print a iterable of key/values\n\n    Args:\n        key_val (list of (str, str)): the pairs of section names and text.\n        sep (str): separator between section names and text.\n        min_col_width (int): minimal acceptable column width\n        text_width (int): text width to use. If set to None, will try to infer\n            the size of the terminal.\n    \"\"\"\n    if text_width is None:\n        text_width = get_terminal_size().columns\n    if text_width < min_col_width:\n        min_col_width = text_width\n    ncols = (text_width + 1) // (min_col_width + 1)\n    colw = (text_width + 1) // ncols - 1\n    ncols = min(ncols, len(key_val))\n\n    wrapper = TextWrapper(width=colw)\n    lines = []\n    for key, val in key_val:\n        if len(key) + len(sep) >= colw // 2:\n            wrapper.subsequent_indent = ' '\n        else:\n            wrapper.subsequent_indent = ' ' * (len(key) + len(sep))\n        lines.extend(wrapper.wrap('{}{}{}'.format(key, sep, val)))\n\n    chunks = []\n    for rem_col in range(ncols, 1, -1):\n        isep = ceil(len(lines) / rem_col)\n        while isep < len(lines) and lines[isep][0] == ' ':\n            isep += 1\n        chunks.append(lines[:isep])\n        lines = lines[isep:]\n    chunks.append(lines)\n    lines = zip_longest(*chunks, fillvalue='')\n\n    fmt = '|'.join(['{{:{}}}'.format(colw)] * (ncols - 1))\n    fmt += '|{}' if ncols > 1 else '{}'\n    print(*(fmt.format(*line) for line in lines), sep='\\n')"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _layout(dict_vars, dict_vars_extra):\n    desc = [(v, m.description) for v, m in dict_vars.items()]\n    desc.extend((v, baredoc(m.description))\n                for v, m in dict_vars_extra.items())\n    _pretty_print(desc, min_col_width=26)", "response": "Print nicely [ var description from phyvars"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef var_cmd():\n    print_all = not any(val for _, val in conf.var.opt_vals_())\n    if print_all or conf.var.field:\n        print('field:')\n        _layout(phyvars.FIELD, phyvars.FIELD_EXTRA)\n        print()\n    if print_all or conf.var.sfield:\n        print('surface field:')\n        _layout(phyvars.SFIELD, {})\n        print()\n    if print_all or conf.var.rprof:\n        print('rprof:')\n        _layout(phyvars.RPROF, phyvars.RPROF_EXTRA)\n        print()\n    if print_all or conf.var.time:\n        print('time:')\n        _layout(phyvars.TIME, phyvars.TIME_EXTRA)\n        print()\n    if print_all or conf.var.plates:\n        print('plates:')\n        _layout(phyvars.PLATES, {})", "response": "Print a list of available variables."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef report_parsing_problems(parsing_out):\n    _, empty, faulty = parsing_out\n    if CONFIG_FILE in empty or CONFIG_FILE in faulty:\n        print('Unable to read global config file', CONFIG_FILE,\n              file=sys.stderr)\n        print('Please run stagpy config --create',\n              sep='\\n', end='\\n\\n', file=sys.stderr)\n    if CONFIG_LOCAL in faulty:\n        print('Unable to read local config file', CONFIG_LOCAL,\n              file=sys.stderr)\n        print('Please run stagpy config --create_local',\n              sep='\\n', end='\\n\\n', file=sys.stderr)", "response": "Output message about potential parsing problems."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef config_cmd():\n    if not (conf.common.config or conf.config.create or\n            conf.config.create_local or conf.config.update or\n            conf.config.edit):\n        config_pp(conf.sections_())\n    loam.tools.config_cmd_handler(conf)", "response": "Configuration handling.\n    Other Parameters :\n        conf. config\n           "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_rprof(step, var):\n    if var in step.rprof.columns:\n        rprof = step.rprof[var]\n        rad = None\n        if var in phyvars.RPROF:\n            meta = phyvars.RPROF[var]\n        else:\n            meta = phyvars.Varr(var, None, '1')\n    elif var in phyvars.RPROF_EXTRA:\n        meta = phyvars.RPROF_EXTRA[var]\n        rprof, rad = meta.description(step)\n        meta = phyvars.Varr(misc.baredoc(meta.description),\n                            meta.kind, meta.dim)\n    else:\n        raise UnknownRprofVarError(var)\n    rprof, _ = step.sdat.scale(rprof, meta.dim)\n    if rad is not None:\n        rad, _ = step.sdat.scale(rad, 'm')\n\n    return rprof, rad, meta", "response": "Extract or compute requested radial profile."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef plot_grid(step):\n    rad = get_rprof(step, 'r')[0]\n    drad = get_rprof(step, 'dr')[0]\n    _, unit = step.sdat.scale(1, 'm')\n    if unit:\n        unit = ' ({})'.format(unit)\n    fig, (ax1, ax2) = plt.subplots(2, sharex=True)\n    ax1.plot(rad, '-ko')\n    ax1.set_ylabel('$r$' + unit)\n    ax2.plot(drad, '-ko')\n    ax2.set_ylabel('$dr$' + unit)\n    ax2.set_xlim([-0.5, len(rad) - 0.5])\n    ax2.set_xlabel('Cell number')\n    misc.saveplot(fig, 'grid', step.istep)", "response": "Plot cell position and thickness of a single object."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef plot_average(sdat, lovs):\n    steps_iter = iter(sdat.walk.filter(rprof=True))\n    try:\n        step = next(steps_iter)\n    except StopIteration:\n        return\n\n    sovs = misc.set_of_vars(lovs)\n\n    istart = step.istep\n    nprofs = 1\n    rprof_averaged = {}\n    rads = {}\n    metas = {}\n\n    # assume constant z spacing for the moment\n    for rvar in sovs:\n        rprof_averaged[rvar], rad, metas[rvar] = get_rprof(step, rvar)\n        if rad is not None:\n            rads[rvar] = rad\n\n    for step in steps_iter:\n        nprofs += 1\n        for rvar in sovs:\n            rprof_averaged[rvar] += get_rprof(step, rvar)[0]\n\n    ilast = step.istep\n    for rvar in sovs:\n        rprof_averaged[rvar] /= nprofs\n    rcmb, rsurf = misc.get_rbounds(step)\n    rprof_averaged['bounds'] = (step.sdat.scale(rcmb, 'm')[0],\n                                step.sdat.scale(rsurf, 'm')[0])\n    rprof_averaged['r'] = get_rprof(step, 'r')[0] + rprof_averaged['bounds'][0]\n\n    stepstr = '{}_{}'.format(istart, ilast)\n\n    _plot_rprof_list(sdat, lovs, rprof_averaged, metas, stepstr, rads)", "response": "Plot time averaged profiles."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef plot_every_step(sdat, lovs):\n    sovs = misc.set_of_vars(lovs)\n\n    for step in sdat.walk.filter(rprof=True):\n        rprofs = {}\n        rads = {}\n        metas = {}\n        for rvar in sovs:\n            rprof, rad, meta = get_rprof(step, rvar)\n            rprofs[rvar] = rprof\n            metas[rvar] = meta\n            if rad is not None:\n                rads[rvar] = rad\n        rprofs['bounds'] = misc.get_rbounds(step)\n        rcmb, rsurf = misc.get_rbounds(step)\n        rprofs['bounds'] = (step.sdat.scale(rcmb, 'm')[0],\n                            step.sdat.scale(rsurf, 'm')[0])\n        rprofs['r'] = get_rprof(step, 'r')[0] + rprofs['bounds'][0]\n        stepstr = str(step.istep)\n\n        _plot_rprof_list(sdat, lovs, rprofs, metas, stepstr, rads)", "response": "Plot profiles at each time step."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef cmd():\n    sdat = StagyyData(conf.core.path)\n    if sdat.rprof is None:\n        return\n\n    if conf.rprof.grid:\n        for step in sdat.walk.filter(rprof=True):\n            plot_grid(step)\n\n    lovs = misc.list_of_vars(conf.rprof.plot)\n    if not lovs:\n        return\n\n    if conf.rprof.average:\n        plot_average(sdat, lovs)\n    else:\n        plot_every_step(sdat, lovs)", "response": "Implementation of rprof\n    Other Parameters"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nenriching a par namelist with the content of a file.", "response": "def _enrich_with_par(par_nml, par_file):\n    \"\"\"Enrich a par namelist with the content of a file.\"\"\"\n    par_new = f90nml.read(str(par_file))\n    for section, content in par_new.items():\n        if section not in par_nml:\n            par_nml[section] = {}\n        for par, value in content.items():\n            try:\n                content[par] = value.strip()\n            except AttributeError:\n                pass\n        par_nml[section].update(content)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreads a new StagYY par file and return a dictionary of names and values.", "response": "def readpar(par_file, root):\n    \"\"\"Read StagYY par file.\n\n    The namelist is populated in chronological order with:\n\n    - :data:`PAR_DEFAULT`, an internal dictionary defining defaults;\n    - :data:`PAR_DFLT_FILE`, the global configuration par file;\n    - ``par_name_defaultparameters`` if it is defined in ``par_file``;\n    - ``par_file`` itself;\n    - ``parameters.dat`` if it can be found in the StagYY output directories.\n\n    Args:\n        par_file (:class:`pathlib.Path`): path of par file.\n        root (:class:`pathlib.Path`): path on which other paths are rooted.\n            This is usually par.parent.\n    Returns:\n        :class:`f90nml.namelist.Namelist`: case insensitive dict of dict of\n        values with first key being the namelist and second key the variables'\n        name.\n    \"\"\"\n    par_nml = deepcopy(PAR_DEFAULT)\n\n    if PAR_DFLT_FILE.is_file():\n        _enrich_with_par(par_nml, PAR_DFLT_FILE)\n    else:\n        PAR_DFLT_FILE.parent.mkdir(exist_ok=True)\n        f90nml.write(par_nml, str(PAR_DFLT_FILE))\n\n    if not par_file.is_file():\n        raise NoParFileError(par_file)\n\n    par_main = f90nml.read(str(par_file))\n    if 'default_parameters_parfile' in par_main:\n        par_dflt = par_main['default_parameters_parfile'].get(\n            'par_name_defaultparameters', 'par_defaults')\n        par_dflt = root / par_dflt\n        if not par_dflt.is_file():\n            raise NoParFileError(par_dflt)\n        _enrich_with_par(par_nml, par_dflt)\n\n    _enrich_with_par(par_nml, par_file)\n\n    par_out = root / par_nml['ioin']['output_file_stem'] / '_parameters.dat'\n    if par_out.is_file():\n        _enrich_with_par(par_nml, par_out)\n    par_out = root / par_nml['ioin']['hdf5_output_folder'] / 'parameters.dat'\n    if par_out.is_file():\n        _enrich_with_par(par_nml, par_out)\n    return par_nml"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_meshes_fld(step, var):\n    fld = step.fields[var]\n    if step.geom.twod_xz:\n        xmesh, ymesh = step.geom.x_mesh[:, 0, :], step.geom.z_mesh[:, 0, :]\n        fld = fld[:, 0, :, 0]\n    elif step.geom.cartesian and step.geom.twod_yz:\n        xmesh, ymesh = step.geom.y_mesh[0, :, :], step.geom.z_mesh[0, :, :]\n        fld = fld[0, :, :, 0]\n    else:  # spherical yz\n        xmesh, ymesh = step.geom.x_mesh[0, :, :], step.geom.y_mesh[0, :, :]\n        fld = fld[0, :, :, 0]\n    return xmesh, ymesh, fld", "response": "Return scalar field along with coordinates meshes."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn vector field components along with coordinates meshes.", "response": "def get_meshes_vec(step, var):\n    \"\"\"Return vector field components along with coordinates meshes.\n\n    Only works properly in 2D geometry.\n\n    Args:\n        step (:class:`~stagpy.stagyydata._Step`): a step of a StagyyData\n            instance.\n        var (str): vector field name.\n    Returns:\n        tuple of :class:`numpy.array`: xmesh, ymesh, fldx, fldy\n            2D arrays containing respectively the x position, y position, x\n            component and y component of the requested vector field.\n    \"\"\"\n    if step.geom.twod_xz:\n        xmesh, ymesh = step.geom.x_mesh[:, 0, :], step.geom.z_mesh[:, 0, :]\n        vec1 = step.fields[var + '1'][:, 0, :, 0]\n        vec2 = step.fields[var + '3'][:, 0, :, 0]\n    elif step.geom.cartesian and step.geom.twod_yz:\n        xmesh, ymesh = step.geom.y_mesh[0, :, :], step.geom.z_mesh[0, :, :]\n        vec1 = step.fields[var + '2'][0, :, :, 0]\n        vec2 = step.fields[var + '3'][0, :, :, 0]\n    else:  # spherical yz\n        xmesh, ymesh = step.geom.x_mesh[0, :, :], step.geom.y_mesh[0, :, :]\n        pmesh = step.geom.p_mesh[0, :, :]\n        vec_phi = step.fields[var + '2'][0, :, :, 0]\n        vec_r = step.fields[var + '3'][0, :, :, 0]\n        vec1 = vec_r * np.cos(pmesh) - vec_phi * np.sin(pmesh)\n        vec2 = vec_phi * np.cos(pmesh) + vec_r * np.sin(pmesh)\n    return xmesh, ymesh, vec1, vec2"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nbuild set of needed field variables.", "response": "def set_of_vars(arg_plot):\n    \"\"\"Build set of needed field variables.\n\n    Each var is a tuple, first component is a scalar field, second component is\n    either:\n\n    - a scalar field, isocontours are added to the plot.\n    - a vector field (e.g. 'v' for the (v1,v2,v3) vector), arrows are added to\n      the plot.\n\n    Args:\n        arg_plot (str): string with variable names separated with\n            ``,`` (figures), and ``+`` (same plot).\n    Returns:\n        set of str: set of needed field variables.\n    \"\"\"\n    sovs = set(tuple((var + '+').split('+')[:2])\n               for var in arg_plot.split(','))\n    sovs.discard(('', ''))\n    return sovs"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef plot_scalar(step, var, field=None, axis=None, set_cbar=True, **extra):\n    if var in phyvars.FIELD:\n        meta = phyvars.FIELD[var]\n    else:\n        meta = phyvars.FIELD_EXTRA[var]\n        meta = phyvars.Varf(misc.baredoc(meta.description), meta.dim)\n    if step.geom.threed:\n        raise NotAvailableError('plot_scalar only implemented for 2D fields')\n\n    xmesh, ymesh, fld = get_meshes_fld(step, var)\n    xmin, xmax = xmesh.min(), xmesh.max()\n    ymin, ymax = ymesh.min(), ymesh.max()\n\n    if field is not None:\n        fld = field\n    if conf.field.perturbation:\n        fld = fld - np.mean(fld, axis=0)\n    if conf.field.shift:\n        fld = np.roll(fld, conf.field.shift, axis=0)\n\n    fld, unit = step.sdat.scale(fld, meta.dim)\n\n    if axis is None:\n        fig, axis = plt.subplots(ncols=1)\n    else:\n        fig = axis.get_figure()\n\n    if step.sdat.par['magma_oceans_in']['magma_oceans_mode']:\n        rcmb = step.sdat.par['geometry']['r_cmb']\n        xmax = rcmb + 1\n        ymax = xmax\n        xmin = -xmax\n        ymin = -ymax\n        rsurf = xmax if step.timeinfo['thick_tmo'] > 0 \\\n            else step.geom.r_mesh[0, 0, -3]\n        cmb = mpat.Circle((0, 0), rcmb, color='dimgray', zorder=0)\n        psurf = mpat.Circle((0, 0), rsurf, color='indianred', zorder=0)\n        axis.add_patch(psurf)\n        axis.add_patch(cmb)\n\n    extra_opts = dict(\n        cmap=conf.field.cmap.get(var),\n        vmin=conf.plot.vmin,\n        vmax=conf.plot.vmax,\n        norm=mpl.colors.LogNorm() if var == 'eta' else None,\n        rasterized=conf.plot.raster,\n        shading='gouraud' if conf.field.interpolate else 'flat',\n    )\n    extra_opts.update(extra)\n    surf = axis.pcolormesh(xmesh, ymesh, fld, **extra_opts)\n\n    cbar = None\n    if set_cbar:\n        cbar = plt.colorbar(surf, shrink=conf.field.shrinkcb)\n        cbar.set_label(meta.description +\n                       (' pert.' if conf.field.perturbation else '') +\n                       (' ({})'.format(unit) if unit else ''))\n    if step.geom.spherical or conf.plot.ratio is None:\n        plt.axis('equal')\n        plt.axis('off')\n    else:\n        axis.set_aspect(conf.plot.ratio / axis.get_data_ratio())\n    axis.set_adjustable('box')\n    axis.set_xlim(xmin, xmax)\n    axis.set_ylim(ymin, ymax)\n    return fig, axis, surf, cbar", "response": "Plot a scalar field."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nplotting isocontours of scalar field.", "response": "def plot_iso(axis, step, var):\n    \"\"\"Plot isocontours of scalar field.\n\n    Args:\n        axis (:class:`matplotlib.axes.Axes`): the axis handler of an\n            existing matplotlib figure where the isocontours should\n            be plotted.\n        step (:class:`~stagpy.stagyydata._Step`): a step of a StagyyData\n            instance.\n        var (str): the scalar field name.\n    \"\"\"\n    xmesh, ymesh, fld = get_meshes_fld(step, var)\n    if conf.field.shift:\n        fld = np.roll(fld, conf.field.shift, axis=0)\n    axis.contour(xmesh, ymesh, fld, linewidths=1)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef plot_vec(axis, step, var):\n    xmesh, ymesh, vec1, vec2 = get_meshes_vec(step, var)\n    dipz = step.geom.nztot // 10\n    if conf.field.shift:\n        vec1 = np.roll(vec1, conf.field.shift, axis=0)\n        vec2 = np.roll(vec2, conf.field.shift, axis=0)\n    if step.geom.spherical or conf.plot.ratio is None:\n        dipx = dipz\n    else:\n        dipx = step.geom.nytot if step.geom.twod_yz else step.geom.nxtot\n        dipx = int(dipx // 10 * conf.plot.ratio) + 1\n    axis.quiver(xmesh[::dipx, ::dipz], ymesh[::dipx, ::dipz],\n                vec1[::dipx, ::dipz], vec2[::dipx, ::dipz],\n                linewidths=1)", "response": "Plot the vector field."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef cmd():\n    sdat = StagyyData(conf.core.path)\n    sovs = set_of_vars(conf.field.plot)\n    minmax = {}\n    if conf.plot.cminmax:\n        conf.plot.vmin = None\n        conf.plot.vmax = None\n        for step in sdat.walk.filter(snap=True):\n            for var, _ in sovs:\n                if var in step.fields:\n                    if var in phyvars.FIELD:\n                        dim = phyvars.FIELD[var].dim\n                    else:\n                        dim = phyvars.FIELD_EXTRA[var].dim\n                    field, _ = sdat.scale(step.fields[var], dim)\n                    if var in minmax:\n                        minmax[var] = (min(minmax[var][0], np.nanmin(field)),\n                                       max(minmax[var][1], np.nanmax(field)))\n                    else:\n                        minmax[var] = np.nanmin(field), np.nanmax(field)\n    for step in sdat.walk.filter(snap=True):\n        for var in sovs:\n            if var[0] not in step.fields:\n                print(\"'{}' field on snap {} not found\".format(var[0],\n                                                               step.isnap))\n                continue\n            opts = {}\n            if var[0] in minmax:\n                opts = dict(vmin=minmax[var[0]][0], vmax=minmax[var[0]][1])\n            fig, axis, _, _ = plot_scalar(step, var[0], **opts)\n            if valid_field_var(var[1]):\n                plot_iso(axis, step, var[1])\n            elif var[1]:\n                plot_vec(axis, step, var[1])\n            oname = '{}_{}'.format(*var) if var[1] else var[0]\n            misc.saveplot(fig, oname, step.isnap)", "response": "Implementation of field subcommand."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _steps_to_slices():\n    if not (conf.core.timesteps or conf.core.snapshots):\n        # default to the last snap\n        conf.core.timesteps = None\n        conf.core.snapshots = slice(-1, None, None)\n        return\n    elif conf.core.snapshots:\n        # snapshots take precedence over timesteps\n        # if both are defined\n        conf.core.timesteps = None\n        steps = conf.core.snapshots\n    else:\n        conf.core.snapshots = None\n        steps = conf.core.timesteps\n    steps = steps.split(':')\n    steps[0] = int(steps[0]) if steps[0] else None\n    if len(steps) == 1:\n        steps.append(steps[0] + 1)\n    steps[1] = int(steps[1]) if steps[1] else None\n    if len(steps) != 3:\n        steps = steps[0:2] + [1]\n    steps[2] = int(steps[2]) if steps[2] else None\n    steps = slice(*steps)\n    if conf.core.snapshots is not None:\n        conf.core.snapshots = steps\n    else:\n        conf.core.timesteps = steps", "response": "parse timesteps and snapshots arguments and return slices"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nparse cmd line arguments.", "response": "def parse_args(arglist=None):\n    \"\"\"Parse cmd line arguments.\n\n    Update :attr:`stagpy.conf` accordingly.\n\n    Args:\n        arglist (list of str): the list of cmd line arguments. If set to\n            None, the arguments are taken from :attr:`sys.argv`.\n\n    Returns:\n        function: the function implementing the sub command to be executed.\n    \"\"\"\n    climan = CLIManager(conf, **SUB_CMDS)\n\n    create_complete_files(climan, CONFIG_DIR, 'stagpy', 'stagpy-git',\n                          zsh_sourceable=True)\n\n    cmd_args, all_subs = climan.parse_args(arglist)\n    sub_cmd = cmd_args.loam_sub_name\n\n    if sub_cmd is None:\n        return cmd_args.func\n\n    if sub_cmd != 'config':\n        commands.report_parsing_problems(PARSING_OUT)\n\n    if conf.common.set:\n        set_conf_str(conf, conf.common.set)\n\n    if conf.common.config:\n        commands.config_pp(all_subs)\n\n    load_mplstyle()\n\n    try:\n        _steps_to_slices()\n    except AttributeError:\n        pass\n    return cmd_args.func"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef detect_plates_vzcheck(step, seuil_memz):\n    v_z = step.fields['v3'][0, :, :, 0]\n    v_x = step.fields['v2'][0, :, :, 0]\n    tcell = step.fields['T'][0, :, :, 0]\n    n_z = step.geom.nztot\n    nphi = step.geom.nptot  # -1? should be OK, ghost not included\n    rcmb = max(0, step.geom.rcmb)\n    radius = step.geom.r_coord + rcmb\n    radiusgrid = step.geom.rgeom[:, 0] + rcmb\n    dphi = 1 / nphi\n\n    # calculing temperature on the grid and vz_mean\n    vz_mean = 0\n    tgrid = np.zeros((nphi, n_z + 1))\n    tgrid[:, 0] = 1\n    for i_z in range(1, n_z):\n        for phi in range(nphi):\n            tgrid[phi, i_z] = (\n                tcell[phi, i_z - 1] *\n                (radiusgrid[i_z] - radius[i_z - 1]) + tcell[phi, i_z] *\n                (-radiusgrid[i_z] + radius[i_z])) / (radius[i_z] -\n                                                     radius[i_z - 1])\n            vz_mean += abs(v_z[phi, i_z]) / (nphi * n_z)\n\n    flux_c = n_z * [0]\n    for i_z in range(1, n_z - 1):\n        for phi in range(nphi):\n            flux_c[i_z] += (tgrid[phi, i_z] - step.timeinfo.loc['Tmean']) * \\\n                v_z[phi, i_z] * radiusgrid[i_z] * dphi\n\n    # checking stagnant lid\n    if all(abs(flux_c[i_z]) <= np.max(flux_c) / 50\n           for i_z in range(n_z - n_z // 20, n_z)):\n        raise error.StagnantLidError(step.sdat)\n    else:\n        # verifying horizontal plate speed and closeness of plates\n        dvphi = nphi * [0]\n        dvx_thres = 16 * step.timeinfo.loc['vrms']\n\n        for phi in range(0, nphi):\n            dvphi[phi] = (v_x[phi, n_z - 1] -\n                          v_x[phi - 1, n_z - 1]) / ((1 + rcmb) * dphi)\n        limits = []\n        for phi in range(0, nphi - nphi // 33):\n            mark = all(abs(dvphi[i]) <= abs(dvphi[phi])\n                       for i in range(phi - nphi // 33, phi + nphi // 33))\n            if mark and abs(dvphi[phi]) >= dvx_thres:\n                limits.append(phi)\n        for phi in range(nphi - nphi // 33 + 1, nphi):\n            mark = all(abs(dvphi[i]) <= abs(dvphi[phi])\n                       for i in range(phi - nphi // 33 - nphi,\n                                      phi + nphi // 33 - nphi))\n            if mark and abs(dvphi[phi]) >= dvx_thres:\n                limits.append(phi)\n\n        # verifying vertical speed\n        k = 0\n        for i in range(len(limits)):\n            vzm = 0\n            phi = limits[i - k]\n            for i_z in range(1 if phi == nphi - 1 else 0, n_z):\n                vzm += (abs(v_z[phi, i_z]) +\n                        abs(v_z[phi - 1, i_z]) +\n                        abs(v_z[(phi + 1) % nphi, i_z])) / (n_z * 3)\n\n            vz_thres = vz_mean * 0.1 + seuil_memz / 2 if seuil_memz else 0\n            if vzm < vz_thres:\n                limits.remove(phi)\n                k += 1\n\n    return limits, nphi, dvphi, vz_thres, v_x[:, n_z - 1]", "response": "detect plates and check with vz and plate size"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef detect_plates(step, vrms_surface, fids, time):\n    vphi = step.fields['v2'][0, :, :, 0]\n    ph_coord = step.geom.p_coord\n\n    if step.sdat.par['boundaries']['air_layer']:\n        dsa = step.sdat.par['boundaries']['air_thickness']\n        # we are a bit below the surface; should check if you are in the\n        # thermal boundary layer\n        indsurf = np.argmin(abs((1 - dsa) - step.geom.r_coord)) - 4\n    else:\n        indsurf = -1\n\n    vph2 = 0.5 * (vphi + np.roll(vphi, 1, 0))  # interpolate to the same phi\n    # velocity derivation\n    dvph2 = (np.diff(vph2[:, indsurf]) / (ph_coord[0] * 2.))\n\n    io_surface(step.isnap, time, fids[6], dvph2)\n    io_surface(step.isnap, time, fids[7], vph2[:-1, indsurf])\n\n    # prepare stuff to find trenches and ridges\n    myorder_trench = 15 if step.sdat.par['boundaries']['air_layer'] else 10\n    myorder_ridge = 20  # threshold\n\n    # finding trenches\n    pom2 = np.copy(dvph2)\n    if step.sdat.par['boundaries']['air_layer']:\n        maskbigdvel = -30 * vrms_surface\n    else:\n        maskbigdvel = -10 * vrms_surface\n    pom2[pom2 > maskbigdvel] = maskbigdvel\n    argless_dv = argrelextrema(\n        pom2, np.less, order=myorder_trench, mode='wrap')[0]\n    trench = ph_coord[argless_dv]\n    velocity_trench = vph2[argless_dv, indsurf]\n    dv_trench = dvph2[argless_dv]\n\n    # finding ridges\n    pom2 = np.copy(dvph2)\n    masksmalldvel = np.amax(dvph2) * 0.2\n    pom2[pom2 < masksmalldvel] = masksmalldvel\n    arggreat_dv = argrelextrema(\n        pom2, np.greater, order=myorder_ridge, mode='wrap')[0]\n    ridge = ph_coord[arggreat_dv]\n\n    # elimination of ridges that are too close to trench\n    argdel = []\n    if trench.any() and ridge.any():\n        for i, ridge_i in enumerate(ridge):\n            mdistance = np.amin(abs(trench - ridge_i))\n            if mdistance < 0.016:\n                argdel.append(i)\n        if argdel:\n            print('deleting from ridge', trench, ridge[argdel])\n            ridge = np.delete(ridge, np.array(argdel))\n            arggreat_dv = np.delete(arggreat_dv, np.array(argdel))\n\n    dv_ridge = dvph2[arggreat_dv]\n    if 'age' in conf.plates:\n        agefld = step.fields['age'][0, :, :, 0]\n        age_surface = np.ma.masked_where(agefld[:, indsurf] < 0.00001,\n                                         agefld[:, indsurf])\n        age_surface_dim = age_surface * vrms_surface *\\\n            conf.scaling.ttransit / conf.scaling.yearins / 1.e6\n        agetrench = age_surface_dim[argless_dv]  # age at the trench\n    else:\n        agetrench = np.zeros(len(argless_dv))\n\n    # writing the output into a file, all time steps are in one file\n    for itrench in np.arange(len(trench)):\n        fids[0].write(\"%7.0f %11.7f %10.6f %9.2f %9.2f \\n\" % (\n            step.isnap,\n            step.geom.ti_ad,\n            trench[itrench],\n            velocity_trench[itrench],\n            agetrench[itrench]\n        ))\n\n    return trench, ridge, agetrench, dv_trench, dv_ridge", "response": "detect plates using derivative of horizontal velocity"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nplot lines designating ridges and trenches", "response": "def plot_plate_limits(axis, ridges, trenches, ymin, ymax):\n    \"\"\"plot lines designating ridges and trenches\"\"\"\n    for trench in trenches:\n        axis.axvline(\n            x=trench, ymin=ymin, ymax=ymax,\n            color='red', ls='dashed', alpha=0.4)\n    for ridge in ridges:\n        axis.axvline(\n            x=ridge, ymin=ymin, ymax=ymax,\n            color='green', ls='dashed', alpha=0.4)\n    axis.set_xlim(0, 2 * np.pi)\n    axis.set_ylim(ymin, ymax)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef plot_plate_limits_field(axis, rcmb, ridges, trenches):\n    for trench in trenches:\n        xxd = (rcmb + 1.02) * np.cos(trench)  # arrow begin\n        yyd = (rcmb + 1.02) * np.sin(trench)  # arrow begin\n        xxt = (rcmb + 1.35) * np.cos(trench)  # arrow end\n        yyt = (rcmb + 1.35) * np.sin(trench)  # arrow end\n        axis.annotate('', xy=(xxd, yyd), xytext=(xxt, yyt),\n                      arrowprops=dict(facecolor='red', shrink=0.05))\n    for ridge in ridges:\n        xxd = (rcmb + 1.02) * np.cos(ridge)\n        yyd = (rcmb + 1.02) * np.sin(ridge)\n        xxt = (rcmb + 1.35) * np.cos(ridge)\n        yyt = (rcmb + 1.35) * np.sin(ridge)\n        axis.annotate('', xy=(xxd, yyd), xytext=(xxt, yyt),\n                      arrowprops=dict(facecolor='green', shrink=0.05))", "response": "plot arrows designating ridges and trenches in 2D field plots"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef io_surface(timestep, time, fid, fld):\n    fid.write(\"{} {}\".format(timestep, time))\n    fid.writelines([\"%10.2e\" % item for item in fld[:]])\n    fid.writelines([\"\\n\"])", "response": "Output for surface files"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncalculate stress in the lithosphere", "response": "def lithospheric_stress(step, trench, ridge, time):\n    \"\"\"calculate stress in the lithosphere\"\"\"\n    timestep = step.isnap\n    base_lith = step.geom.rcmb + 1 - 0.105\n\n    stressfld = step.fields['sII'][0, :, :, 0]\n    stressfld = np.ma.masked_where(step.geom.r_mesh[0] < base_lith, stressfld)\n\n    # stress integration in the lithosphere\n    dzm = (step.geom.r_coord[1:] - step.geom.r_coord[:-1])\n    stress_lith = np.sum((stressfld[:, 1:] * dzm.T), axis=1)\n    ph_coord = step.geom.p_coord  # probably doesn't need alias\n\n    # plot stress in the lithosphere\n    fig, axis, _, _ = field.plot_scalar(step, 'sII', stressfld,\n                                        cmap='plasma_r', vmin=0, vmax=300)\n    # Annotation with time and step\n    axis.text(1., 0.9, str(round(time, 0)) + ' My', transform=axis.transAxes)\n    axis.text(1., 0.1, str(timestep), transform=axis.transAxes)\n    misc.saveplot(fig, 'lith', timestep)\n\n    # velocity\n    vphi = step.fields['v2'][0, :, :, 0]\n    vph2 = 0.5 * (vphi + np.roll(vphi, 1, 0))  # interpolate to the same phi\n\n    # position of continents\n    concfld = step.fields['c'][0, :, :, 0]\n    if step.sdat.par['boundaries']['air_layer']:\n        # we are a bit below the surface; delete \"-some number\"\n        # to be just below\n        dsa = step.sdat.par['boundaries']['air_thickness']\n        # depth to detect the continents\n        indcont = np.argmin(abs((1 - dsa) - step.geom.r_coord)) - 10\n    else:\n        # depth to detect continents\n        indcont = -1\n    if step.sdat.par['boundaries']['air_layer'] and\\\n            not step.sdat.par['continents']['proterozoic_belts']:\n        continents = np.ma.masked_where(\n            np.logical_or(concfld[:-1, indcont] < 3,\n                          concfld[:-1, indcont] > 4),\n            concfld[:-1, indcont])\n    elif step.sdat.par['boundaries']['air_layer'] and\\\n            step.sdat.par['continents']['proterozoic_belts']:\n        continents = np.ma.masked_where(\n            np.logical_or(concfld[:-1, indcont] < 3,\n                          concfld[:-1, indcont] > 5),\n            concfld[:-1, indcont])\n    elif step.sdat.par['tracersin']['tracers_weakcrust']:\n        continents = np.ma.masked_where(\n            concfld[:-1, indcont] < 3, concfld[:-1, indcont])\n    else:\n        continents = np.ma.masked_where(\n            concfld[:-1, indcont] < 2, concfld[:-1, indcont])\n\n    # masked array, only continents are true\n    continentsall = continents / continents\n\n    # plot integrated stress in the lithosphere\n    fig0, (ax1, ax2) = plt.subplots(2, 1, sharex=True, figsize=(12, 8))\n    ax1.plot(ph_coord[:-1], vph2[:-1, -1], label='Vel')\n    ax1.axhline(y=0, xmin=0, xmax=2 * np.pi,\n                color='black', ls='solid', alpha=0.2)\n    ax1.set_ylabel(\"Velocity\")\n    ax1.text(0.95, 1.07, str(round(time, 0)) + ' My',\n             transform=ax1.transAxes)\n    ax1.text(0.01, 1.07, str(round(step.geom.ti_ad, 8)),\n             transform=ax1.transAxes)\n\n    intstr_scale = step.sdat.scales.stress * step.sdat.scales.length / 1.e12\n    ax2.plot(ph_coord, stress_lith * intstr_scale, color='k', label='Stress')\n    ax2.set_ylabel(r\"Integrated stress [$TN\\,m^{-1}$]\")\n\n    plot_plate_limits(ax1, ridge, trench, conf.plates.vmin,\n                      conf.plates.vmax)\n    plot_plate_limits(ax2, ridge, trench, conf.plates.stressmin,\n                      conf.plates.lstressmax)\n    ax1.set_xlim(0, 2 * np.pi)\n    ax1.set_title(timestep)\n\n    ax1.fill_between(\n        ph_coord[:-1], continentsall * conf.plates.vmin,\n        conf.plates.vmax, facecolor='#8b6914', alpha=0.2)\n    ax1.set_ylim(conf.plates.vmin, conf.plates.vmax)\n    ax2.fill_between(\n        ph_coord[:-1], continentsall * conf.plates.stressmin,\n        conf.plates.lstressmax, facecolor='#8b6914', alpha=0.2)\n    ax2.set_ylim(conf.plates.stressmin, conf.plates.lstressmax)\n\n    misc.saveplot(fig0, 'svelslith', timestep)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nbuilding set of needed variables.", "response": "def set_of_vars(arg_plot):\n    \"\"\"Build set of needed variables.\n\n    Args:\n        arg_plot (str): string with variable names separated with ``,``.\n    Returns:\n        set of str: set of variables.\n    \"\"\"\n    return set(var for var in arg_plot.split(',') if var in phyvars.PLATES)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nplot several plates information.", "response": "def main_plates(sdat):\n    \"\"\"Plot several plates information.\"\"\"\n    # calculating averaged horizontal surface velocity\n    # needed for redimensionalisation\n    ilast = sdat.rprof.index.levels[0][-1]\n    rlast = sdat.rprof.loc[ilast]\n    nprof = 0\n    uprof_averaged = rlast.loc[:, 'vhrms'] * 0\n    for step in sdat.walk.filter(rprof=True):\n        uprof_averaged += step.rprof['vhrms']\n        nprof += 1\n    uprof_averaged /= nprof\n    radius = rlast['r'].values\n    if sdat.par['boundaries']['air_layer']:\n        dsa = sdat.par['boundaries']['air_thickness']\n        isurf = np.argmin(abs(radius - radius[-1] + dsa))\n        vrms_surface = uprof_averaged.iloc[isurf]\n        isurf = np.argmin(abs((1 - dsa) - radius))\n        isurf -= 4  # why different isurf for the rest?\n    else:\n        isurf = -1\n        vrms_surface = uprof_averaged.iloc[isurf]\n\n    with misc.InchoateFiles(8, 'plates') as fids:\n        fids.fnames = ['plate_velocity', 'distance_subd', 'continents',\n                       'flux', 'topography', 'age', 'velderiv', 'velocity']\n        fids[0].write('#  it  time  ph_trench vel_trench age_trench\\n')\n        fids[1].write('#  it      time   time [My]   distance     '\n                      'ph_trench     ph_cont  age_trench [My]\\n')\n\n        istart, iend = None, None\n        for step in sdat.walk.filter(fields=['T']):\n            # could check other fields too\n            timestep = step.isnap\n            istart = timestep if istart is None else istart\n            iend = timestep\n            print('Treating snapshot', timestep)\n\n            rcmb = step.geom.rcmb\n            # topography\n            fname = sdat.filename('sc', timestep=timestep, suffix='.dat')\n            topo = np.genfromtxt(str(fname))\n            # rescaling topography!\n            if sdat.par['boundaries']['air_layer']:\n                topo[:, 1] = topo[:, 1] / (1. - dsa)\n\n            time = step.geom.ti_ad * vrms_surface *\\\n                conf.scaling.ttransit / conf.scaling.yearins / 1.e6\n            trenches, ridges, agetrenches, _, _ =\\\n                detect_plates(step, vrms_surface, fids, time)\n            plot_plates(step, time, vrms_surface, trenches, ridges,\n                        agetrenches, topo, fids)\n\n            # prepare for continent plotting\n            concfld = step.fields['c'][0, :, :, 0]\n            continentsfld = np.ma.masked_where(\n                concfld < 3, concfld)  # plotting continents, to-do\n            continentsfld = continentsfld / continentsfld\n\n            temp = step.fields['T'][0, :, :, 0]\n            tgrad = (temp[:, isurf - 1] - temp[:, isurf]) /\\\n                (step.geom.r_coord[isurf] - step.geom.r_coord[isurf - 1])\n\n            io_surface(timestep, time, fids[2], concfld[:-1, isurf])\n            io_surface(timestep, time, fids[3], tgrad)\n            io_surface(timestep, time, fids[4], topo[:, 1])\n            if 'age' in conf.plates.plot:\n                io_surface(timestep, time, fids[5],\n                           step.fields['age'][0, :, isurf, 0])\n\n            # plot viscosity field with position of trenches and ridges\n            etamin, _ = sdat.scale(1e-2, 'Pa')\n            etamax, _ = sdat.scale(sdat.par['viscosity']['eta_max'], 'Pa')\n            fig, axis, _, _ = field.plot_scalar(step, 'eta',\n                                                vmin=etamin, vmax=etamax)\n\n            # plotting continents\n            field.plot_scalar(step, 'c', continentsfld, axis, False,\n                              cmap='cool_r', vmin=0, vmax=0)\n            cmap2 = plt.cm.ocean\n            cmap2.set_over('m')\n\n            # plotting velocity vectors\n            field.plot_vec(axis, step, 'v')\n\n            # Annotation with time and step\n            axis.text(1., 0.9, str(round(time, 0)) + ' My',\n                      transform=axis.transAxes)\n            axis.text(1., 0.1, str(timestep),\n                      transform=axis.transAxes)\n\n            # Put arrow where ridges and trenches are\n            plot_plate_limits_field(axis, rcmb, ridges, trenches)\n\n            misc.saveplot(fig, 'eta', timestep, close=False)\n\n            # Zoom\n            if conf.plates.zoom is not None:\n                if not 0 <= conf.plates.zoom <= 360:\n                    raise error.InvalidZoomError(conf.plates.zoom)\n                if 45 < conf.plates.zoom <= 135:\n                    ladd, radd, uadd, dadd = 0.8, 0.8, 0.05, 0.1\n                elif 135 < conf.plates.zoom <= 225:\n                    ladd, radd, uadd, dadd = 0.05, 0.1, 0.8, 0.8\n                elif 225 < conf.plates.zoom <= 315:\n                    ladd, radd, uadd, dadd = 0.8, 0.8, 0.1, 0.05\n                else:  # >315 or <=45\n                    ladd, radd, uadd, dadd = 0.1, 0.05, 0.8, 0.8\n                xzoom = (rcmb + 1) * np.cos(np.radians(conf.plates.zoom))\n                yzoom = (rcmb + 1) * np.sin(np.radians(conf.plates.zoom))\n                axis.set_xlim(xzoom - ladd, xzoom + radd)\n                axis.set_ylim(yzoom - dadd, yzoom + uadd)\n                misc.saveplot(fig, 'etazoom', timestep, close=False)\n            plt.close(fig)\n\n            # plot stress field with position of trenches and ridges\n            if 'str' in conf.plates.plot:\n                fig, axis, _, _ = field.plot_scalar(step, 'sII',\n                                                    vmin=0, vmax=300)\n\n                # Annotation with time and step\n                axis.text(1., 0.9, str(round(time, 0)) + ' My',\n                          transform=axis.transAxes)\n                axis.text(1., 0.1, str(timestep),\n                          transform=axis.transAxes)\n\n                # Put arrow where ridges and trenches are\n                plot_plate_limits_field(axis, rcmb, ridges, trenches)\n\n                misc.saveplot(fig, 's', timestep, close=False)\n\n                # Zoom\n                if conf.plates.zoom is not None:\n                    axis.set_xlim(xzoom - ladd, xzoom + radd)\n                    axis.set_ylim(yzoom - dadd, yzoom + uadd)\n                    misc.saveplot(fig, 'szoom', timestep, close=False)\n                plt.close(fig)\n\n                # calculate stresses in the lithosphere\n                lithospheric_stress(step, trenches, ridges, time)\n\n            # plotting the principal deviatoric stress field\n            if 'sx' in conf.plates.plot:\n                fig, axis, _, _ = field.plot_scalar(step, 'sII',\n                                                    alpha=0.1)\n\n                # plotting continents\n                field.plot_scalar(step, 'c', continentsfld, axis, False,\n                                  cmap='cool_r', vmin=0, vmax=0)\n                cmap2 = plt.cm.ocean\n                cmap2.set_over('m')\n\n                # plotting principal deviatoric stress\n                field.plot_vec(axis, step, 'sx')\n\n                # Annotation with time and step\n                axis.text(1., 0.9, str(round(time, 0)) + ' My',\n                          transform=axis.transAxes)\n                axis.text(1., 0.1, str(timestep),\n                          transform=axis.transAxes)\n\n                # Put arrow where ridges and trenches are\n                plot_plate_limits_field(axis, rcmb, ridges, trenches)\n\n                misc.saveplot(fig, 'sx', timestep)\n\n        # determine names of files\n        ptn = misc.out_name('{}_{}_{}')\n        stem = ptn.format(fids.fnames[0], istart, iend)\n        idx = 0\n        fmt = '{}.dat'\n        while pathlib.Path(fmt.format(stem, idx)).is_file():\n            fmt = '{}_{}.dat'\n            idx += 1\n        fids.fnames = [fmt.format(ptn.format(fname, istart, iend), idx)\n                       for fname in fids.fnames]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncreate config files as necessary.", "response": "def _check_config():\n    \"\"\"Create config files as necessary.\"\"\"\n    config.CONFIG_DIR.mkdir(parents=True, exist_ok=True)\n    verfile = config.CONFIG_DIR / '.version'\n    uptodate = verfile.is_file() and verfile.read_text() == __version__\n    if not uptodate:\n        verfile.write_text(__version__)\n    if not (uptodate and config.CONFIG_FILE.is_file()):\n        conf.create_config_(update=True)\n    for stfile in ('stagpy-paper.mplstyle',\n                   'stagpy-slides.mplstyle'):\n        stfile_conf = config.CONFIG_DIR / stfile\n        if not (uptodate and stfile_conf.is_file()):\n            stfile_local = pathlib.Path(__file__).parent / stfile\n            shutil.copy(str(stfile_local), str(stfile_conf))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef load_mplstyle():\n    plt = importlib.import_module('matplotlib.pyplot')\n    if conf.plot.mplstyle:\n        for style in conf.plot.mplstyle.split():\n            stfile = config.CONFIG_DIR / (style + '.mplstyle')\n            if stfile.is_file():\n                style = str(stfile)\n            try:\n                plt.style.use(style)\n            except OSError:\n                print('Cannot import style {}.'.format(style),\n                      file=sys.stderr)\n                conf.plot.mplstyle = ''\n    if conf.plot.xkcd:\n        plt.xkcd()", "response": "Try to load conf. plot. mplstyle matplotlib style."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef dtime(sdat, tstart=None, tend=None):\n    tseries = sdat.tseries_between(tstart, tend)\n    time = tseries['t'].values\n    return time[1:] - time[:-1], time[:-1]", "response": "Time increment dt.\n\n    Compute dt as a function of time.\n\n    Args:\n        sdat (:class:`~stagpy.stagyydata.StagyyData`): a StagyyData instance.\n        tstart (float): time at which the computation should start. Use the\n            beginning of the time series data if set to None.\n        tend (float): time at which the computation should end. Use the\n            end of the time series data if set to None.\n    Returns:\n        tuple of :class:`numpy.array`: dt and time arrays."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef dt_dt(sdat, tstart=None, tend=None):\n    tseries = sdat.tseries_between(tstart, tend)\n    time = tseries['t'].values\n    temp = tseries['Tmean'].values\n    dtdt = (temp[1:] - temp[:-1]) / (time[1:] - time[:-1])\n    return dtdt, time[:-1]", "response": "Compute dT and dt as a function of time using an explicit Euler scheme."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncomputing the energy balance of a given time series.", "response": "def ebalance(sdat, tstart=None, tend=None):\n    \"\"\"Energy balance.\n\n    Compute Nu_t - Nu_b + V*dT/dt as a function of time using an explicit\n    Euler scheme. This should be zero if energy is conserved.\n\n    Args:\n        sdat (:class:`~stagpy.stagyydata.StagyyData`): a StagyyData instance.\n        tstart (float): time at which the computation should start. Use the\n            beginning of the time series data if set to None.\n        tend (float): time at which the computation should end. Use the\n            end of the time series data if set to None.\n    Returns:\n        tuple of :class:`numpy.array`: energy balance and time arrays.\n    \"\"\"\n    tseries = sdat.tseries_between(tstart, tend)\n    rbot, rtop = misc.get_rbounds(sdat.steps.last)\n    if rbot != 0:  # spherical\n        coefsurf = (rtop / rbot)**2\n        volume = rbot * ((rtop / rbot)**3 - 1) / 3\n    else:\n        coefsurf = 1.\n        volume = 1.\n    dtdt, time = dt_dt(sdat, tstart, tend)\n    ftop = tseries['ftop'].values * coefsurf\n    fbot = tseries['fbot'].values\n    radio = tseries['H_int'].values\n    ebal = ftop[1:] - fbot[1:] + volume * (dtdt - radio[1:])\n    return ebal, time"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef mobility(sdat, tstart=None, tend=None):\n    tseries = sdat.tseries_between(tstart, tend)\n    steps = sdat.steps[tseries.index[0]:tseries.index[-1]]\n    time = []\n    mob = []\n    for step in steps.filter(rprof=True):\n        time.append(step.timeinfo['t'])\n        mob.append(step.rprof.iloc[-1].loc['vrms'] / step.timeinfo['vrms'])\n    return np.array(mob), np.array(time)", "response": "Plates mobility.\n    Compute the ratio vsurf / vrms.\n    Compute the ratio vsurf / vrms.\n    Compute the ratio vsurf / vrms.\n    Compute the ratio vsurf / vrms.\n    Compute the ratio vsurf / vrms.\n    Compute the ratio vsurf / vrms.\n    Compute the ratio vsurf / vrms.\n    Compute the ratio vsurf to the mobility of the mobility of the mobility."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef r_edges(step):\n    rbot, rtop = misc.get_rbounds(step)\n    centers = step.rprof.loc[:, 'r'].values + rbot\n    # assume walls are mid-way between T-nodes\n    # could be T-nodes at center between walls\n    edges = (centers[:-1] + centers[1:]) / 2\n    edges = np.insert(edges, 0, rbot)\n    edges = np.append(edges, rtop)\n    return edges, edges", "response": "Returns the edges of the bottom and top walls of a cluster."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nscales profile to take sphericity into account", "response": "def _scale_prof(step, rprof, rad=None):\n    \"\"\"Scale profile to take sphericity into account\"\"\"\n    rbot, rtop = misc.get_rbounds(step)\n    if rbot == 0:  # not spherical\n        return rprof\n    if rad is None:\n        rad = step.rprof['r'].values + rbot\n    return rprof * (2 * rad / (rtop + rbot))**2"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nscale diffusion. This computation takes sphericity into account if necessary. This computation takes sphericity into account if necessary.", "response": "def diffs_prof(step):\n    \"\"\"Scaled diffusion.\n\n    This computation takes sphericity into account if necessary.\n\n    Args:\n        step (:class:`~stagpy.stagyydata._Step`): a step of a StagyyData\n            instance.\n    Returns:\n        tuple of :class:`numpy.array`: the diffusion and the radial position\n        at which it is evaluated.\n    \"\"\"\n    diff, rad = diff_prof(step)\n    return _scale_prof(step, diff, rad), rad"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef energy_prof(step):\n    diff, rad = diffs_prof(step)\n    adv, _ = advts_prof(step)\n    return (diff + np.append(adv, 0)), rad", "response": "Energy flux.\n\n    This computation takes sphericity into account if necessary.\n\n    Args:\n        step (:class:`~stagpy.stagyydata._Step`): a step of a StagyyData\n            instance.\n    Returns:\n        tuple of :class:`numpy.array`: the energy flux and the radial position\n        at which it is evaluated."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef advth(step):\n    rbot, rtop = misc.get_rbounds(step)\n    rmean = 0.5 * (rbot + rtop)\n    rad = step.rprof['r'].values + rbot\n    radio = step.timeinfo['H_int']\n    if rbot != 0:  # spherical\n        th_adv = -(rtop**3 - rad**3) / rmean**2 / 3\n    else:\n        th_adv = rad - rtop\n    th_adv *= radio\n    th_adv += step.timeinfo['Nutop']\n    return th_adv, None", "response": "Theoretical advection.\n\n    This compute the theoretical profile of total advection as function of\n    radius.\n\n    Args:\n        step (:class:`~stagpy.stagyydata._Step`): a step of a StagyyData\n            instance.\n    Returns:\n        tuple of :class:`numpy.array` and None: the theoretical advection.\n        The second element of the tuple is None."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef init_c_overturn(step):\n    rbot, rtop = misc.get_rbounds(step)\n    xieut = step.sdat.par['tracersin']['fe_eut']\n    k_fe = step.sdat.par['tracersin']['k_fe']\n    xi0l = step.sdat.par['tracersin']['fe_cont']\n    xi0s = k_fe * xi0l\n    xired = xi0l / xieut\n    rsup = (rtop**3 - xired**(1 / (1 - k_fe)) *\n            (rtop**3 - rbot**3))**(1 / 3)\n\n    def initprof(rpos):\n        \"\"\"Theoretical initial profile.\"\"\"\n        if rpos < rsup:\n            return xi0s * ((rtop**3 - rbot**3) /\n                           (rtop**3 - rpos**3))**(1 - k_fe)\n        return xieut\n\n    rad = np.linspace(rbot, rtop, 500)\n    initprof = np.vectorize(initprof)\n    return initprof(rad), rad", "response": "This function computes the initial concentration of a single object."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nstreams function for the current object.", "response": "def stream_function(step):\n    \"\"\"Stream function.\n\n    Args:\n        step (:class:`~stagpy.stagyydata._Step`): a step of a StagyyData\n            instance.\n    Returns:\n        :class:`numpy.array`: the stream function field, with four dimensions:\n        x-direction, y-direction, z-direction and block.\n    \"\"\"\n    if step.geom.twod_yz:\n        x_coord = step.geom.y_coord\n        v_x = step.fields['v2'][0, :, :, 0]\n        v_z = step.fields['v3'][0, :, :, 0]\n        shape = (1, v_x.shape[0], v_x.shape[1], 1)\n    elif step.geom.twod_xz and step.geom.cartesian:\n        x_coord = step.geom.x_coord\n        v_x = step.fields['v1'][:, 0, :, 0]\n        v_z = step.fields['v3'][:, 0, :, 0]\n        shape = (v_x.shape[0], 1, v_x.shape[1], 1)\n    else:\n        raise NotAvailableError('Stream function only implemented in '\n                                '2D cartesian and spherical annulus')\n    psi = np.zeros_like(v_x)\n    if step.geom.spherical:  # YZ annulus\n        # positions\n        r_nc = step.geom.r_coord + step.geom.rcmb  # numerical centers\n        r_pc = step.geom.r_mesh[0, 0, :]  # physical centers\n        r_nw = r_edges(step)[0][:2]  # numerical walls of first cell\n        # vz at center of bottom cells\n        vz0 = ((r_nw[1] - r_nc[0]) * v_z[:, 0] +\n               (r_nc[0] - r_nw[0]) * v_z[:, 1]) / (r_nw[1] - r_nw[0])\n        psi[1:, 0] = -integrate.cumtrapz(r_pc[0]**2 * vz0, x=x_coord)\n        # vx at center\n        vxc = (v_x + np.roll(v_x, -1, axis=0)) / 2\n        for i_x in range(len(x_coord)):\n            psi[i_x, 1:] = psi[i_x, 0] + \\\n                integrate.cumtrapz(r_pc * vxc[i_x], x=r_nc)\n    else:  # assume cartesian geometry\n        z_nc = step.geom.z_coord\n        z_nw = r_edges(step)[0][:2]\n        vz0 = ((z_nw[1] - z_nc[0]) * v_z[:, 0] +\n               (z_nc[0] - z_nw[0]) * v_z[:, 1]) / (z_nw[1] - z_nw[0])\n        psi[1:, 0] = -integrate.cumtrapz(vz0, x=x_coord)\n        # vx at center\n        vxc = (v_x + np.roll(v_x, -1, axis=0)) / 2\n        for i_x in range(len(x_coord)):\n            psi[i_x, 1:] = psi[i_x, 0] + \\\n                integrate.cumtrapz(vxc[i_x], x=z_nc)\n    if step.geom.twod_xz:\n        psi = - psi\n    psi = np.reshape(psi, shape)\n    return psi"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef last(self):\n        if self._last is UNDETERMINED:\n            # not necessarily the last one...\n            self._last = self.sdat.tseries.index[-1]\n        return self[self._last]", "response": "Return the last available entry in the sequence."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef bind(self, isnap, istep):\n        self._isteps[isnap] = istep\n        self.sdat.steps[istep].isnap = isnap", "response": "Bind the isnap and istep to the object."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _pass(self, step):\n        okf = True\n        okf = okf and (not self._flt['snap'] or step.isnap is not None)\n        okf = okf and (not self._flt['rprof'] or step.rprof is not None)\n        okf = okf and all(f in step.fields for f in self._flt['fields'])\n        okf = okf and bool(self._flt['func'](step))\n        return okf", "response": "Check whether a step passes the filters."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef filter(self, **filters):\n        for flt, val in self._flt.items():\n            self._flt[flt] = filters.pop(flt, val)\n        if filters:\n            raise error.UnknownFiltersError(filters.keys())\n        return self", "response": "Update the relevant filters with provided arguments."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef tseries(self):\n        if self._stagdat['tseries'] is UNDETERMINED:\n            timefile = self.filename('TimeSeries.h5')\n            self._stagdat['tseries'] = stagyyparsers.time_series_h5(\n                timefile, list(phyvars.TIME.keys()))\n            if self._stagdat['tseries'] is not None:\n                return self._stagdat['tseries']\n            timefile = self.filename('time.dat')\n            if self.hdf5 and not timefile.is_file():\n                # check legacy folder as well\n                timefile = self.filename('time.dat', force_legacy=True)\n            self._stagdat['tseries'] = stagyyparsers.time_series(\n                timefile, list(phyvars.TIME.keys()))\n        return self._stagdat['tseries']", "response": "Return the time series data."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef files(self):\n        if self._rundir['ls'] is UNDETERMINED:\n            out_stem = pathlib.Path(self.par['ioin']['output_file_stem'] + '_')\n            out_dir = self.path / out_stem.parent\n            if out_dir.is_dir():\n                self._rundir['ls'] = set(out_dir.iterdir())\n            else:\n                self._rundir['ls'] = set()\n        return self._rundir['ls']", "response": "Set of found binary files output by StagYY."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning view on configured steps slice.", "response": "def walk(self):\n        \"\"\"Return view on configured steps slice.\n\n        Other Parameters:\n            conf.core.snapshots: the slice of snapshots.\n            conf.core.timesteps: the slice of timesteps.\n        \"\"\"\n        if conf.core.snapshots is not None:\n            return self.snaps[conf.core.snapshots]\n        elif conf.core.timesteps is not None:\n            return self.steps[conf.core.timesteps]\n        return self.snaps[-1:]"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nscaling the data array to obtain dimensionful quantity.", "response": "def scale(self, data, unit):\n        \"\"\"Scales quantity to obtain dimensionful quantity.\n\n        Args:\n            data (numpy.array): the quantity that should be scaled.\n            dim (str): the dimension of data as defined in phyvars.\n        Return:\n            (float, str): scaling factor and unit string.\n        Other Parameters:\n            conf.scaling.dimensional: if set to False (default), the factor is\n                always 1.\n        \"\"\"\n        if self.par['switches']['dimensional_units'] or \\\n           not conf.scaling.dimensional or \\\n           unit == '1':\n            return data, ''\n        scaling = phyvars.SCALES[unit](self.scales)\n        factor = conf.scaling.factors.get(unit, ' ')\n        if conf.scaling.time_in_y and unit == 's':\n            scaling /= conf.scaling.yearins\n            unit = 'yr'\n        elif conf.scaling.vel_in_cmpy and unit == 'm/s':\n            scaling *= 100 * conf.scaling.yearins\n            unit = 'cm/y'\n        if factor in phyvars.PREFIXES:\n            scaling *= 10**(-3 * (phyvars.PREFIXES.index(factor) + 1))\n            unit = factor + unit\n        return data * scaling, unit"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef tseries_between(self, tstart=None, tend=None):\n        if self.tseries is None:\n            return None\n\n        ndat = self.tseries.shape[0]\n\n        if tstart is None:\n            istart = 0\n        else:\n            igm = 0\n            igp = ndat - 1\n            while igp - igm > 1:\n                istart = igm + (igp - igm) // 2\n                if self.tseries.iloc[istart]['t'] >= tstart:\n                    igp = istart\n                else:\n                    igm = istart\n            istart = igp\n\n        if tend is None:\n            iend = None\n        else:\n            igm = 0\n            igp = ndat - 1\n            while igp - igm > 1:\n                iend = igm + (igp - igm) // 2\n                if self.tseries.iloc[iend]['t'] > tend:\n                    igp = iend\n                else:\n                    igm = iend\n            iend = igm + 1\n\n        return self.tseries.iloc[istart:iend]", "response": "Return a pandas. DataFrame containing the time series data between the requested times."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef filename(self, fname, timestep=None, suffix='', force_legacy=False):\n        if timestep is not None:\n            fname += '{:05d}'.format(timestep)\n        fname += suffix\n        if not force_legacy and self.hdf5:\n            fpath = self.hdf5 / fname\n        else:\n            fpath = self.par['ioin']['output_file_stem'] + '_' + fname\n            fpath = self.path / fpath\n        return fpath", "response": "Return the name of the StagYY output file."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a set of existing binary files at a given snapshot number.", "response": "def binfiles_set(self, isnap):\n        \"\"\"Set of existing binary files at a given snap.\n\n        Args:\n            isnap (int): snapshot index.\n        Returns:\n            set of pathlib.Path: the set of output files available for this\n            snapshot number.\n        \"\"\"\n        possible_files = set(self.filename(fstem, isnap, force_legacy=True)\n                             for fstem in phyvars.FIELD_FILES)\n        return possible_files & self.files"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ntruncating or extend names so that its len is nnames.", "response": "def _tidy_names(names, nnames, extra_names=None):\n    \"\"\"Truncate or extend names so that its len is nnames.\n\n    The list is modified, this function returns nothing.\n\n    Args:\n        names (list): list of names.\n        nnames (int): desired number of names.\n        extra_names (list of str): list of names to be used to extend the list\n            if needed. If this list isn't provided, a range is used instead.\n    \"\"\"\n    if len(names) < nnames and extra_names is not None:\n        names.extend(extra_names)\n    names.extend(range(nnames - len(names)))\n    del names[nnames:]"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef time_series(timefile, colnames):\n    if not timefile.is_file():\n        return None\n    data = pd.read_csv(timefile, delim_whitespace=True, dtype=str,\n                       header=None, skiprows=1, index_col=0,\n                       engine='c', memory_map=True,\n                       error_bad_lines=False, warn_bad_lines=False)\n    data = data.apply(pd.to_numeric, raw=True, errors='coerce')\n\n    # detect useless lines produced when run is restarted\n    rows_to_del = []\n    irow = len(data) - 1\n    while irow > 0:\n        iprev = irow - 1\n        while iprev >= 0 and data.index[irow] <= data.index[iprev]:\n            rows_to_del.append(iprev)\n            iprev -= 1\n        irow = iprev\n    if rows_to_del:\n        rows_to_keep = set(range(len(data))) - set(rows_to_del)\n        data = data.take(list(rows_to_keep), convert=False)\n\n    ncols = data.shape[1]\n    _tidy_names(colnames, ncols)\n    data.columns = colnames\n\n    return data", "response": "Read temporal series text file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef time_series_h5(timefile, colnames):\n    if not timefile.is_file():\n        return None\n    with h5py.File(timefile, 'r') as h5f:\n        dset = h5f['tseries']\n        _, ncols = dset.shape\n        ncols -= 1  # first is istep\n        h5names = map(bytes.decode, h5f['names'][len(colnames) + 1:])\n        _tidy_names(colnames, ncols, h5names)\n        data = dset[()]\n    return pd.DataFrame(data[:, 1:],\n                        index=np.int_(data[:, 0]), columns=colnames)", "response": "Read temporal series HDF5 file."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _extract_rsnap_isteps(rproffile):\n    step_regex = re.compile(r'^\\*+step:\\s*(\\d+) ; time =\\s*(\\S+)')\n    isteps = []  # list of (istep, time, nz)\n    rows_to_del = set()\n    line = ' '\n    with rproffile.open() as stream:\n        while line[0] != '*':\n            line = stream.readline()\n        match = step_regex.match(line)\n        istep = int(match.group(1))\n        time = float(match.group(2))\n        nlines = 0\n        iline = 0\n        for line in stream:\n            if line[0] == '*':\n                isteps.append((istep, time, nlines))\n                match = step_regex.match(line)\n                istep = int(match.group(1))\n                time = float(match.group(2))\n                nlines = 0\n                # remove useless lines produced when run is restarted\n                nrows_to_del = 0\n                while isteps and istep <= isteps[-1][0]:\n                    nrows_to_del += isteps.pop()[-1]\n                rows_to_del = rows_to_del.union(\n                    range(iline - nrows_to_del, iline))\n            else:\n                nlines += 1\n                iline += 1\n        isteps.append((istep, time, nlines))\n    return isteps, rows_to_del", "response": "Extract istep and compute list of rows to delete"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nextract radial profiles data from a. rprof file.", "response": "def rprof(rproffile, colnames):\n    \"\"\"Extract radial profiles data\n\n    If :data:`colnames` is too long, it will be truncated. If it is too short,\n    additional numeric column names from 0 to N-1 will be attributed to the N\n    extra columns present in :data:`timefile`.\n\n    Args:\n        rproffile (:class:`pathlib.Path`): path of the rprof.dat file.\n        colnames (list of names): names of the variables expected in\n            :data:`rproffile` (may be modified).\n\n    Returns:\n        tuple of :class:`pandas.DataFrame`: (profs, times)\n            :data:`profs` are the radial profiles, with the variables in\n            columns and rows double-indexed with the time step and the radial\n            index of numerical cells.\n\n            :data:`times` is the dimensionless time indexed by time steps.\n    \"\"\"\n    if not rproffile.is_file():\n        return None, None\n    data = pd.read_csv(rproffile, delim_whitespace=True, dtype=str,\n                       header=None, comment='*', skiprows=1,\n                       engine='c', memory_map=True,\n                       error_bad_lines=False, warn_bad_lines=False)\n    data = data.apply(pd.to_numeric, raw=True, errors='coerce')\n\n    isteps, rows_to_del = _extract_rsnap_isteps(rproffile)\n    if rows_to_del:\n        rows_to_keep = set(range(len(data))) - rows_to_del\n        data = data.take(list(rows_to_keep), convert=False)\n\n    id_arr = [[], []]\n    for istep, _, n_z in isteps:\n        id_arr[0].extend(repeat(istep, n_z))\n        id_arr[1].extend(range(n_z))\n\n    data.index = id_arr\n\n    ncols = data.shape[1]\n    _tidy_names(colnames, ncols)\n    data.columns = colnames\n\n    df_times = pd.DataFrame(list(map(itemgetter(1), isteps)),\n                            index=map(itemgetter(0), isteps))\n    return data, df_times"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef rprof_h5(rproffile, colnames):\n    if not rproffile.is_file():\n        return None, None\n    isteps = []\n    with h5py.File(rproffile) as h5f:\n        dnames = sorted(dname for dname in h5f.keys()\n                        if dname.startswith('rprof_'))\n        ncols = h5f['names'].shape[0]\n        h5names = map(bytes.decode, h5f['names'][len(colnames):])\n        _tidy_names(colnames, ncols, h5names)\n        data = np.zeros((0, ncols))\n        for dname in dnames:\n            dset = h5f[dname]\n            data = np.concatenate((data, dset[()]))\n            isteps.append((dset.attrs['istep'], dset.attrs['time'],\n                           dset.shape[0]))\n\n    id_arr = [[], []]\n    for istep, _, n_z in isteps:\n        id_arr[0].extend(repeat(istep, n_z))\n        id_arr[1].extend(range(n_z))\n\n    df_data = pd.DataFrame(data, index=id_arr, columns=colnames)\n    df_times = pd.DataFrame(list(map(itemgetter(1), isteps)),\n                            index=map(itemgetter(0), isteps))\n    return df_data, df_times", "response": "Extract radial profiles data from a hdf5 file."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _readbin(fid, fmt='i', nwords=1, file64=False, unpack=True):\n    if fmt in 'if':\n        fmt += '8' if file64 else '4'\n    elts = np.fromfile(fid, fmt, nwords)\n    if unpack and len(elts) == 1:\n        elts = elts[0]\n    return elts", "response": "Read n words of 4 or 8 bytes with fmt format."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef fields(fieldfile, only_header=False, only_istep=False):\n    # something to skip header?\n    if not fieldfile.is_file():\n        return None\n    header = {}\n    with fieldfile.open('rb') as fid:\n        readbin = partial(_readbin, fid)\n        magic = readbin()\n        if magic > 8000:  # 64 bits\n            magic -= 8000\n            readbin()  # need to read 4 more bytes\n            readbin = partial(readbin, file64=True)\n\n        # check nb components\n        nval = 1\n        if magic > 400:\n            nval = 4\n        elif magic > 300:\n            nval = 3\n\n        magic %= 100\n\n        # extra ghost point in horizontal direction\n        header['xyp'] = int(magic >= 9 and nval == 4)\n\n        # total number of values in relevant space basis\n        # (e1, e2, e3) = (theta, phi, radius) in spherical geometry\n        #              = (x, y, z)            in cartesian geometry\n        header['nts'] = readbin(nwords=3)\n\n        # number of blocks, 2 for yinyang or cubed sphere\n        header['ntb'] = readbin() if magic >= 7 else 1\n\n        # aspect ratio\n        header['aspect'] = readbin('f', 2)\n\n        # number of parallel subdomains\n        header['ncs'] = readbin(nwords=3)  # (e1, e2, e3) space\n        header['ncb'] = readbin() if magic >= 8 else 1  # blocks\n\n        # r - coordinates\n        # rgeom[0:self.nrtot+1, 0] are edge radial position\n        # rgeom[0:self.nrtot, 1] are cell-center radial position\n        if magic >= 2:\n            header['rgeom'] = readbin('f', header['nts'][2] * 2 + 1)\n        else:\n            header['rgeom'] = np.array(range(0, header['nts'][2] * 2 + 1))\\\n                * 0.5 / header['nts'][2]\n        header['rgeom'] = np.resize(header['rgeom'], (header['nts'][2] + 1, 2))\n\n        header['rcmb'] = readbin('f') if magic >= 7 else None\n\n        header['ti_step'] = readbin() if magic >= 3 else 0\n        if only_istep:\n            return header['ti_step']\n        header['ti_ad'] = readbin('f') if magic >= 3 else 0\n        header['erupta_total'] = readbin('f') if magic >= 5 else 0\n        header['bot_temp'] = readbin('f') if magic >= 6 else 1\n\n        if magic >= 4:\n            header['e1_coord'] = readbin('f', header['nts'][0])\n            header['e2_coord'] = readbin('f', header['nts'][1])\n            header['e3_coord'] = readbin('f', header['nts'][2])\n        else:\n            # could construct them from other info\n            raise ParsingError(fieldfile,\n                               'magic >= 4 expected to get grid geometry')\n\n        if only_header:\n            return header\n\n        # READ FIELDS\n        # number of points in (e1, e2, e3) directions PER CPU\n        npc = header['nts'] // header['ncs']\n        # number of blocks per cpu\n        nbk = header['ntb'] // header['ncb']\n        # number of values per 'read' block\n        npi = (npc[0] + header['xyp']) * (npc[1] + header['xyp']) * npc[2] * \\\n            nbk * nval\n\n        header['scalefac'] = readbin('f') if nval > 1 else 1\n\n        flds = np.zeros((nval,\n                         header['nts'][0] + header['xyp'],\n                         header['nts'][1] + header['xyp'],\n                         header['nts'][2],\n                         header['ntb']))\n\n        # loop over parallel subdomains\n        for icpu in product(range(header['ncb']),\n                            range(header['ncs'][2]),\n                            range(header['ncs'][1]),\n                            range(header['ncs'][0])):\n            # read the data for one CPU\n            data_cpu = readbin('f', npi) * header['scalefac']\n\n            # icpu is (icpu block, icpu z, icpu y, icpu x)\n            # data from file is transposed to obtained a field\n            # array indexed with (x, y, z, block), as in StagYY\n            flds[:,\n                 icpu[3] * npc[0]:(icpu[3] + 1) * npc[0] + header['xyp'],  # x\n                 icpu[2] * npc[1]:(icpu[2] + 1) * npc[1] + header['xyp'],  # y\n                 icpu[1] * npc[2]:(icpu[1] + 1) * npc[2],  # z\n                 icpu[0] * nbk:(icpu[0] + 1) * nbk  # block\n                 ] = np.transpose(data_cpu.reshape(\n                     (nbk, npc[2], npc[1] + header['xyp'],\n                      npc[0] + header['xyp'], nval)))\n    return header, flds", "response": "Extract fields data from a binary field file."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nextracting tracers data. Args: tracersfile (:class:`pathlib.Path`): path of the binary tracers file. Returns: dict of list of numpy.array: Tracers data organized by attribute and block.", "response": "def tracers(tracersfile):\n    \"\"\"Extract tracers data.\n\n    Args:\n        tracersfile (:class:`pathlib.Path`): path of the binary tracers file.\n\n    Returns:\n        dict of list of numpy.array:\n            Tracers data organized by attribute and block.\n    \"\"\"\n    if not tracersfile.is_file():\n        return None\n    tra = {}\n    with tracersfile.open('rb') as fid:\n        readbin = partial(_readbin, fid)\n        magic = readbin()\n        if magic > 8000:  # 64 bits\n            magic -= 8000\n            readbin()\n            readbin = partial(readbin, file64=True)\n        if magic < 100:\n            raise ParsingError(tracersfile,\n                               'magic > 100 expected to get tracervar info')\n        nblk = magic % 100\n        readbin('f', 2)  # aspect ratio\n        readbin()  # istep\n        readbin('f')  # time\n        ninfo = readbin()\n        ntra = readbin(nwords=nblk, unpack=False)\n        readbin('f')  # tracer ideal mass\n        curv = readbin()\n        if curv:\n            readbin('f')  # r_cmb\n        infos = []  # list of info names\n        for _ in range(ninfo):\n            infos.append(b''.join(readbin('b', 16)).strip().decode())\n            tra[infos[-1]] = []\n        if magic > 200:\n            ntrace_elt = readbin()\n            if ntrace_elt > 0:\n                readbin('f', ntrace_elt)  # outgassed\n        for ntrab in ntra:  # blocks\n            data = readbin('f', ntrab * ninfo)\n            for idx, info in enumerate(infos):\n                tra[info].append(data[idx::ninfo])\n    return tra"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _read_group_h5(filename, groupname):\n    with h5py.File(filename, 'r') as h5f:\n        data = h5f[groupname][()]\n    return data", "response": "Read the content of a group from a hdf5 file."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nadd a dimension to the field if necessary.", "response": "def _make_3d(field, twod):\n    \"\"\"Add a dimension to field if necessary.\n\n    Args:\n        field (numpy.array): the field that need to be 3d.\n        twod (str): 'XZ', 'YZ' or None depending on what is relevant.\n    Returns:\n        numpy.array: reshaped field.\n    \"\"\"\n    shp = list(field.shape)\n    if twod and 'X' in twod:\n        shp.insert(1, 1)\n    elif twod:\n        shp.insert(0, 1)\n    return field.reshape(shp)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _ncores(meshes, twod):\n    nnpb = len(meshes)  # number of nodes per block\n    nns = [1, 1, 1]  # number of nodes in x, y, z directions\n    if twod is None or 'X' in twod:\n        while (nnpb > 1 and\n               meshes[nns[0]]['X'][0, 0, 0] ==\n               meshes[nns[0] - 1]['X'][-1, 0, 0]):\n            nns[0] += 1\n            nnpb -= 1\n    cpu = lambda icy: icy * nns[0]\n    if twod is None or 'Y' in twod:\n        while (nnpb > 1 and\n               meshes[cpu(nns[1])]['Y'][0, 0, 0] ==\n               meshes[cpu(nns[1] - 1)]['Y'][0, -1, 0]):\n            nns[1] += 1\n            nnpb -= nns[0]\n    cpu = lambda icz: icz * nns[0] * nns[1]\n    while (nnpb > 1 and\n           meshes[cpu(nns[2])]['Z'][0, 0, 0] ==\n           meshes[cpu(nns[2] - 1)]['Z'][0, 0, -1]):\n        nns[2] += 1\n        nnpb -= nns[0] * nns[1]\n    return np.array(nns)", "response": "Compute number of cores in each direction."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nconglomerates meshes from several cores into one.", "response": "def _conglomerate_meshes(meshin, header):\n    \"\"\"Conglomerate meshes from several cores into one.\"\"\"\n    meshout = {}\n    npc = header['nts'] // header['ncs']\n    shp = [val + 1 if val != 1 else 1 for val in header['nts']]\n    x_p = int(shp[0] != 1)\n    y_p = int(shp[1] != 1)\n    for coord in meshin[0]:\n        meshout[coord] = np.zeros(shp)\n    for icore in range(np.prod(header['ncs'])):\n        ifs = [icore // np.prod(header['ncs'][:i]) % header['ncs'][i] * npc[i]\n               for i in range(3)]\n        for coord, mesh in meshin[icore].items():\n            meshout[coord][ifs[0]:ifs[0] + npc[0] + x_p,\n                           ifs[1]:ifs[1] + npc[1] + y_p,\n                           ifs[2]:ifs[2] + npc[2] + 1] = mesh\n    return meshout"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _read_coord_h5(files, shapes, header, twod):\n    meshes = []\n    for h5file, shape in zip(files, shapes):\n        meshes.append({})\n        with h5py.File(h5file, 'r') as h5f:\n            for coord, mesh in h5f.items():\n                # for some reason, the array is transposed!\n                meshes[-1][coord] = mesh[()].reshape(shape).T\n                meshes[-1][coord] = _make_3d(meshes[-1][coord], twod)\n\n    header['ncs'] = _ncores(meshes, twod)\n    header['nts'] = list((meshes[0]['X'].shape[i] - 1) * header['ncs'][i]\n                         for i in range(3))\n    header['nts'] = np.array([max(1, val) for val in header['nts']])\n    # meshes could also be defined in legacy parser, so that these can be used\n    # in geometry setup\n    meshes = _conglomerate_meshes(meshes, header)\n    if np.any(meshes['Z'][:, :, 0] != 0):\n        # spherical\n        header['x_mesh'] = np.copy(meshes['Y'])  # annulus geometry...\n        header['y_mesh'] = np.copy(meshes['Z'])\n        header['z_mesh'] = np.copy(meshes['X'])\n        header['r_mesh'] = np.sqrt(header['x_mesh']**2 + header['y_mesh']**2 +\n                                   header['z_mesh']**2)\n        header['t_mesh'] = np.arccos(header['z_mesh'] / header['r_mesh'])\n        header['p_mesh'] = np.roll(\n            np.arctan2(header['y_mesh'], -header['x_mesh']) + np.pi, -1, 1)\n        header['e1_coord'] = header['t_mesh'][:, 0, 0]\n        header['e2_coord'] = header['p_mesh'][0, :, 0]\n        header['e3_coord'] = header['r_mesh'][0, 0, :]\n    else:\n        header['e1_coord'] = meshes['X'][:, 0, 0]\n        header['e2_coord'] = meshes['Y'][0, :, 0]\n        header['e3_coord'] = meshes['Z'][0, 0, :]\n    header['aspect'] = (header['e1_coord'][-1] - header['e2_coord'][0],\n                        header['e1_coord'][-1] - header['e2_coord'][0])\n    header['rcmb'] = header['e3_coord'][0]\n    if header['rcmb'] == 0:\n        header['rcmb'] = -1\n    else:\n        # could make the difference between r_coord and z_coord\n        header['e3_coord'] = header['e3_coord'] - header['rcmb']\n    if twod is None or 'X' in twod:\n        header['e1_coord'] = header['e1_coord'][:-1]\n    if twod is None or 'Y' in twod:\n        header['e2_coord'] = header['e2_coord'][:-1]\n    header['e3_coord'] = header['e3_coord'][:-1]", "response": "Read all coord hdf5 files of a snapshot."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _get_field(xdmf_file, data_item):\n    shp = _get_dim(data_item)\n    h5file, group = data_item.text.strip().split(':/', 1)\n    icore = int(group.split('_')[-2]) - 1\n    fld = _read_group_h5(xdmf_file.parent / h5file, group).reshape(shp)\n    return icore, fld", "response": "Extract field from data item."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nextracting and convert info if item is present.", "response": "def _maybe_get(elt, item, info, conversion=None):\n    \"\"\"Extract and convert info if item is present.\"\"\"\n    maybe_item = elt.find(item)\n    if maybe_item is not None:\n        maybe_item = maybe_item.get(info)\n        if conversion is not None:\n            maybe_item = conversion(maybe_item)\n    return maybe_item"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef read_geom_h5(xdmf_file, snapshot):\n    header = {}\n    xdmf_root = xmlET.parse(str(xdmf_file)).getroot()\n    if snapshot is None:\n        return None, xdmf_root\n\n    # Domain, Temporal Collection, Snapshot\n    # should check that this is indeed the required snapshot\n    elt_snap = xdmf_root[0][0][snapshot]\n    header['ti_ad'] = float(elt_snap.find('Time').get('Value'))\n    header['mo_lambda'] = _maybe_get(elt_snap, 'mo_lambda', 'Value', float)\n    header['mo_thick_sol'] = _maybe_get(elt_snap, 'mo_thick_sol', 'Value',\n                                        float)\n    header['ntb'] = 1\n    coord_h5 = []  # all the coordinate files\n    coord_shape = []  # shape of meshes\n    twod = None\n    for elt_subdomain in elt_snap.findall('Grid'):\n        if elt_subdomain.get('Name').startswith('meshYang'):\n            header['ntb'] = 2\n            break  # iterate only through meshYin\n        elt_geom = elt_subdomain.find('Geometry')\n        if elt_geom.get('Type') == 'X_Y' and twod is None:\n            twod = ''\n            for data_item in elt_geom.findall('DataItem'):\n                coord = data_item.text.strip()[-1]\n                if coord in 'XYZ':\n                    twod += coord\n        data_item = elt_geom.find('DataItem')\n        coord_shape.append(_get_dim(data_item))\n        coord_h5.append(\n            xdmf_file.parent / data_item.text.strip().split(':/', 1)[0])\n    _read_coord_h5(coord_h5, coord_shape, header, twod)\n    return header, xdmf_root", "response": "Extract geometry information from hdf5 files."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nconverts vector field to spherical.", "response": "def _to_spherical(flds, header):\n    \"\"\"Convert vector field to spherical.\"\"\"\n    cth = np.cos(header['t_mesh'][:, :, :-1])\n    sth = np.sin(header['t_mesh'][:, :, :-1])\n    cph = np.cos(header['p_mesh'][:, :, :-1])\n    sph = np.sin(header['p_mesh'][:, :, :-1])\n    fout = np.copy(flds)\n    fout[0] = cth * cph * flds[0] + cth * sph * flds[1] - sth * flds[2]\n    fout[1] = sph * flds[0] - cph * flds[1]  # need to take the opposite here\n    fout[2] = sth * cph * flds[0] + sth * sph * flds[1] + cth * flds[2]\n    return fout"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _flds_shape(fieldname, header):\n    shp = list(header['nts'])\n    shp.append(header['ntb'])\n    # probably a better way to handle this\n    if fieldname == 'Velocity':\n        shp.insert(0, 3)\n        # extra points\n        header['xp'] = int(header['nts'][0] != 1)\n        shp[1] += header['xp']\n        header['yp'] = int(header['nts'][1] != 1)\n        shp[2] += header['yp']\n        header['zp'] = 1\n        header['xyp'] = 1\n    else:\n        shp.insert(0, 1)\n        header['xp'] = 0\n        header['yp'] = 0\n        header['zp'] = 0\n        header['xyp'] = 0\n    return shp", "response": "Compute shape of flds variable."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nprocess flds to handle sphericity.", "response": "def _post_read_flds(flds, header):\n    \"\"\"Process flds to handle sphericity.\"\"\"\n    if flds.shape[0] >= 3 and header['rcmb'] > 0:\n        # spherical vector\n        header['p_mesh'] = np.roll(\n            np.arctan2(header['y_mesh'], header['x_mesh']), -1, 1)\n        for ibk in range(header['ntb']):\n            flds[..., ibk] = _to_spherical(flds[..., ibk], header)\n        header['p_mesh'] = np.roll(\n            np.arctan2(header['y_mesh'], -header['x_mesh']) + np.pi, -1, 1)\n    return flds"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nextracting field data from hdf5 files.", "response": "def read_field_h5(xdmf_file, fieldname, snapshot, header=None):\n    \"\"\"Extract field data from hdf5 files.\n\n    Args:\n        xdmf_file (:class:`pathlib.Path`): path of the xdmf file.\n        fieldname (str): name of field to extract.\n        snapshot (int): snapshot number.\n        header (dict): geometry information.\n    Returns:\n        (dict, numpy.array): geometry information and field data. None\n            is returned if data is unavailable.\n    \"\"\"\n    if header is None:\n        header, xdmf_root = read_geom_h5(xdmf_file, snapshot)\n    else:\n        xdmf_root = xmlET.parse(str(xdmf_file)).getroot()\n\n    npc = header['nts'] // header['ncs']  # number of grid point per node\n    flds = np.zeros(_flds_shape(fieldname, header))\n    data_found = False\n\n    for elt_subdomain in xdmf_root[0][0][snapshot].findall('Grid'):\n        ibk = int(elt_subdomain.get('Name').startswith('meshYang'))\n        for data_attr in elt_subdomain.findall('Attribute'):\n            if data_attr.get('Name') != fieldname:\n                continue\n            icore, fld = _get_field(xdmf_file, data_attr.find('DataItem'))\n            # for some reason, the field is transposed\n            fld = fld.T\n            shp = fld.shape\n            if shp[-1] == 1 and header['nts'][0] == 1:  # YZ\n                fld = fld.reshape((shp[0], 1, shp[1], shp[2]))\n                if header['rcmb'] < 0:\n                    fld = fld[(2, 0, 1), ...]\n            elif shp[-1] == 1:  # XZ\n                fld = fld.reshape((shp[0], shp[1], 1, shp[2]))\n                if header['rcmb'] < 0:\n                    fld = fld[(0, 2, 1), ...]\n            elif header['nts'][1] == 1:  # cart XZ\n                fld = fld.reshape((1, shp[0], 1, shp[1]))\n            ifs = [icore // np.prod(header['ncs'][:i]) % header['ncs'][i] *\n                   npc[i] for i in range(3)]\n            if header['zp']:  # remove top row\n                fld = fld[:, :, :, :-1]\n            flds[:,\n                 ifs[0]:ifs[0] + npc[0] + header['xp'],\n                 ifs[1]:ifs[1] + npc[1] + header['yp'],\n                 ifs[2]:ifs[2] + npc[2],\n                 ibk] = fld\n            data_found = True\n\n    flds = _post_read_flds(flds, header)\n\n    return (header, flds) if data_found else None"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nextracting tracers data from hdf5 files.", "response": "def read_tracers_h5(xdmf_file, infoname, snapshot, position):\n    \"\"\"Extract tracers data from hdf5 files.\n\n    Args:\n        xdmf_file (:class:`pathlib.Path`): path of the xdmf file.\n        infoname (str): name of information to extract.\n        snapshot (int): snapshot number.\n        position (bool): whether to extract position of tracers.\n    Returns:\n        dict of list of numpy.array:\n            Tracers data organized by attribute and block.\n    \"\"\"\n    xdmf_root = xmlET.parse(str(xdmf_file)).getroot()\n    tra = {}\n    tra[infoname] = [{}, {}]  # two blocks, ordered by cores\n    if position:\n        for axis in 'xyz':\n            tra[axis] = [{}, {}]\n    for elt_subdomain in xdmf_root[0][0][snapshot].findall('Grid'):\n        ibk = int(elt_subdomain.get('Name').startswith('meshYang'))\n        if position:\n            for data_attr in elt_subdomain.findall('Geometry'):\n                for data_item, axis in zip(data_attr.findall('DataItem'),\n                                           'xyz'):\n                    icore, data = _get_field(xdmf_file, data_item)\n                    tra[axis][ibk][icore] = data\n        for data_attr in elt_subdomain.findall('Attribute'):\n            if data_attr.get('Name') != infoname:\n                continue\n            icore, data = _get_field(xdmf_file, data_attr.find('DataItem'))\n            tra[infoname][ibk][icore] = data\n    for info in tra:\n        tra[info] = [trab for trab in tra[info] if trab]  # remove empty blocks\n        for iblk, trab in enumerate(tra[info]):\n            tra[info][iblk] = np.concatenate([trab[icore]\n                                              for icore in range(len(trab))])\n    return tra"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\niterating through the time_botT. h5 files in the directory h5folder.", "response": "def read_time_h5(h5folder):\n    \"\"\"Iterate through (isnap, istep) recorded in h5folder/'time_botT.h5'.\n\n    Args:\n        h5folder (:class:`pathlib.Path`): directory of HDF5 output files.\n    Yields:\n        tuple of int: (isnap, istep).\n    \"\"\"\n    with h5py.File(h5folder / 'time_botT.h5', 'r') as h5f:\n        for name, dset in h5f.items():\n            yield int(name[-5:]), int(dset[2])"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ndetermines shape of geometry", "response": "def _init_shape(self):\n        \"\"\"Determine shape of geometry\"\"\"\n        shape = self._par['geometry']['shape'].lower()\n        aspect = self._header['aspect']\n        if self.rcmb is not None and self.rcmb >= 0:\n            # curvilinear\n            self._shape['cyl'] = self.twod_xz and (shape == 'cylindrical' or\n                                                   aspect[0] >= np.pi)\n            self._shape['sph'] = not self._shape['cyl']\n        elif self.rcmb is None:\n            self._header['rcmb'] = self._par['geometry']['r_cmb']\n            if self.rcmb >= 0:\n                if self.twod_xz and shape == 'cylindrical':\n                    self._shape['cyl'] = True\n                elif shape == 'spherical':\n                    self._shape['sph'] = True\n        self._shape['axi'] = self.cartesian and self.twod_xz and \\\n            shape == 'axisymmetric'"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _get_raw_data(self, name):\n        # try legacy first, then hdf5\n        filestem = ''\n        for filestem, list_fvar in self._files.items():\n            if name in list_fvar:\n                break\n        fieldfile = self.step.sdat.filename(filestem, self.step.isnap,\n                                            force_legacy=True)\n        if not fieldfile.is_file():\n            fieldfile = self.step.sdat.filename(filestem, self.step.isnap)\n        parsed_data = None\n        if fieldfile.is_file():\n            parsed_data = stagyyparsers.fields(fieldfile)\n        elif self.step.sdat.hdf5 and self._filesh5:\n            for filestem, list_fvar in self._filesh5.items():\n                if name in list_fvar:\n                    break\n            parsed_data = stagyyparsers.read_field_h5(\n                self.step.sdat.hdf5 / 'Data.xmf', filestem, self.step.isnap)\n        return list_fvar, parsed_data", "response": "Find file holding data and return its content."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef geom(self):\n        if self._header is UNDETERMINED:\n            binfiles = self.step.sdat.binfiles_set(self.step.isnap)\n            if binfiles:\n                self._header = stagyyparsers.fields(binfiles.pop(),\n                                                    only_header=True)\n            elif self.step.sdat.hdf5:\n                xmf = self.step.sdat.hdf5 / 'Data.xmf'\n                self._header, _ = stagyyparsers.read_geom_h5(xmf,\n                                                             self.step.isnap)\n            else:\n                self._header = None\n        if self._geom is UNDETERMINED:\n            if self._header is None:\n                self._geom = None\n            else:\n                self._geom = _Geometry(self._header, self.step.sdat.par)\n        return self._geom", "response": "Returns the geometry information."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef timeinfo(self):\n        if self.istep not in self.sdat.tseries.index:\n            return None\n        return self.sdat.tseries.loc[self.istep]", "response": "Return the time series data of the time step."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the radial profiles data for this time step.", "response": "def rprof(self):\n        \"\"\"Radial profiles data of the time step.\n\n        Set to None if no radial profiles data is available for this time step.\n        \"\"\"\n        if self.istep not in self.sdat.rprof.index.levels[0]:\n            return None\n        return self.sdat.rprof.loc[self.istep]"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the index of the current snapshot.", "response": "def isnap(self):\n        \"\"\"Snapshot index corresponding to time step.\n\n        It is set to None if no snapshot exists for the time step.\n        \"\"\"\n        if self._isnap is UNDETERMINED:\n            istep = None\n            isnap = -1\n            # could be more efficient if do 0 and -1 then bisection\n            # (but loose intermediate <- would probably use too much\n            # memory for what it's worth if search algo is efficient)\n            while (istep is None or istep < self.istep) and isnap < 99999:\n                isnap += 1\n                istep = self.sdat.snaps[isnap].istep\n                self.sdat.snaps.bind(isnap, istep)\n                # all intermediate istep could have their ._isnap to None\n            if istep != self.istep:\n                self._isnap = None\n        return self._isnap"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nconvert v1 schema dict to v2 schema dict.", "response": "def convert_v1_to_v2(\n        dict  # type: Dict[str, Any]\n    ):\n    # type: (...) -> Dict[str, Any]\n    \"\"\"\n    Convert v1 schema dict to v2 schema dict.\n    :param dict: v1 schema dict\n    :return: v2 schema dict\n    \"\"\"\n    version = dict['version']\n    if version != 1:\n        raise ValueError('Version {} not 1'.format(version))\n\n    clk_config = dict['clkConfig']\n    k = clk_config['k']\n    clk_hash = clk_config['hash']\n\n    def convert_feature(f):\n        if 'ignored' in f:\n            return f\n\n        hashing = f['hashing']\n        weight = hashing.get('weight', 1.0)\n\n        if weight == 0:\n            return {\n                'identifier': f['identifier'],\n                'ignored': True\n            }\n\n        x = deepcopy(f)\n        hashing = x['hashing']\n        if 'weight' in hashing:\n            del hashing['weight']\n\n        hashing['k'] = int(round(weight * k))\n        hashing['hash'] = clk_hash\n        return x\n\n    result = {\n        'version': 2,\n        'clkConfig': {\n            'l': clk_config['l'],\n            'xor_folds': clk_config.get('xor_folds', 0),\n            'kdf': clk_config['kdf']\n        },\n        'features': list(map(convert_feature, dict['features']))\n    }\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating a new schema from a dictionary.", "response": "def from_json_dict(dct, validate=True):\n    # type: (Dict[str, Any], bool) -> Schema\n    \"\"\" Create a Schema for v1 or v2 according to dct\n\n    :param dct: This dictionary must have a `'features'`\n            key specifying the columns of the dataset. It must have\n            a `'version'` key containing the master schema version\n            that this schema conforms to. It must have a `'hash'`\n            key with all the globals.\n    :param validate: (default True) Raise an exception if the\n            schema does not conform to the master schema.\n    :return: the Schema\n    \"\"\"\n    if validate:\n        # This raises iff the schema is invalid.\n        validate_schema_dict(dct)\n\n    version = dct['version']\n    if version == 1:\n        dct = convert_v1_to_v2(dct)\n        if validate:\n            validate_schema_dict(dct)\n    elif version != 2:\n        msg = ('Schema version {} is not supported. '\n               'Consider updating clkhash.').format(version)\n        raise SchemaError(msg)\n\n    clk_config = dct['clkConfig']\n    l = clk_config['l']\n    xor_folds = clk_config.get('xor_folds', 0)\n\n    kdf = clk_config['kdf']\n    kdf_type = kdf['type']\n    kdf_hash = kdf.get('hash', 'SHA256')\n    kdf_info_string = kdf.get('info')\n    kdf_info = (base64.b64decode(kdf_info_string)\n                if kdf_info_string is not None\n                else None)\n    kdf_salt_string = kdf.get('salt')\n    kdf_salt = (base64.b64decode(kdf_salt_string)\n                if kdf_salt_string is not None\n                else None)\n    kdf_key_size = kdf.get('keySize', DEFAULT_KDF_KEY_SIZE)\n\n    fields = list(map(spec_from_json_dict, dct['features']))\n    return Schema(fields, l, xor_folds,\n                  kdf_type, kdf_hash, kdf_info, kdf_salt, kdf_key_size)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nloads a Schema object from a json file containing the master schema.", "response": "def from_json_file(schema_file, validate=True):\n    # type: (TextIO, bool) -> Schema\n    \"\"\" Load a Schema object from a json file.\n        :param schema_file: A JSON file containing the schema.\n        :param validate: (default True) Raise an exception if the\n            schema does not conform to the master schema.\n        :raises SchemaError: When the schema is invalid.\n        :return: the Schema\n    \"\"\"\n    try:\n        schema_dict = json.load(schema_file)\n    except ValueError as e:  # In Python 3 we can be more specific\n        # with json.decoder.JSONDecodeError,\n        # but that doesn't exist in Python 2.\n        msg = 'The schema is not a valid JSON file.'\n        raise_from(SchemaError(msg), e)\n\n    return from_json_dict(schema_dict, validate=validate)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nloading the master schema of given version as bytes.", "response": "def _get_master_schema(version):\n    # type: (Hashable) -> bytes\n    \"\"\" Loads the master schema of given version as bytes.\n\n        :param version: The version of the master schema whose path we\n            wish to retrieve.\n        :raises SchemaError: When the schema version is unknown. This\n            usually means that either (a) clkhash is out of date, or (b)\n            the schema version listed is incorrect.\n        :return: Bytes of the schema.\n    \"\"\"\n    try:\n        file_name = MASTER_SCHEMA_FILE_NAMES[version]\n    except (TypeError, KeyError) as e:\n        msg = ('Schema version {} is not supported. '\n               'Consider updating clkhash.').format(version)\n        raise_from(SchemaError(msg), e)\n\n    try:\n        schema_bytes = pkgutil.get_data('clkhash', 'schemas/{}'.format(file_name))\n    except IOError as e:  # In Python 3 we can be more specific with\n        # FileNotFoundError, but that doesn't exist in\n        # Python 2.\n        msg = ('The master schema could not be found. The schema cannot be '\n               'validated. Please file a bug report.')\n        raise_from(MasterSchemaError(msg), e)\n\n    if schema_bytes is None:\n        msg = ('The master schema could not be loaded. The schema cannot be '\n               'validated. Please file a bug report.')\n        raise MasterSchemaError(msg)\n\n    return schema_bytes"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nvalidates the master schema.", "response": "def validate_schema_dict(schema):\n    # type: (Dict[str, Any]) -> None\n    \"\"\" Validate the schema.\n\n        This raises iff either the schema or the master schema are\n        invalid. If it's successful, it returns nothing.\n\n        :param schema: The schema to validate, as parsed by `json`.\n        :raises SchemaError: When the schema is invalid.\n        :raises MasterSchemaError: When the master schema is invalid.\n    \"\"\"\n    if not isinstance(schema, dict):\n        msg = ('The top level of the schema file is a {}, whereas a dict is '\n               'expected.'.format(type(schema).__name__))\n        raise SchemaError(msg)\n\n    if 'version' in schema:\n        version = schema['version']\n    else:\n        raise SchemaError('A format version is expected in the schema.')\n\n    master_schema_bytes = _get_master_schema(version)\n    try:\n        master_schema = json.loads(master_schema_bytes.decode('utf-8'))\n    except ValueError as e:  # In Python 3 we can be more specific with\n        # json.decoder.JSONDecodeError, but that\n        # doesn't exist in Python 2.\n        msg = ('The master schema is not a valid JSON file. The schema cannot '\n               'be validated. Please file a bug report.')\n        raise_from(MasterSchemaError(msg), e)\n\n    try:\n        jsonschema.validate(schema, master_schema)\n    except jsonschema.exceptions.ValidationError as e:\n        raise_from(SchemaError('The schema is not valid.'), e)\n    except jsonschema.exceptions.SchemaError as e:\n        msg = ('The master schema is not valid. The schema cannot be '\n               'validated. Please file a bug report.')\n        raise_from(MasterSchemaError(msg), e)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef deserialize_bitarray(ser):\n    # type: (str) -> bitarray\n    \"\"\"Deserialize a base 64 encoded string to a bitarray (bloomfilter)\n    \n    \"\"\"\n    ba = bitarray()\n    ba.frombytes(base64.b64decode(ser.encode(encoding='UTF-8', errors='strict')))\n    return ba", "response": "Deserialize a base 64 encoded string to a bitarray"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef analyze_image(image, apis=DEFAULT_APIS, **kwargs):\r\n    cloud = kwargs.pop('cloud', None)\r\n    batch = kwargs.pop('batch', False)\r\n    api_key = kwargs.pop('api_key', None)\r\n\r\n    return multi(\r\n        data=data_preprocess(image, batch=batch),\r\n        datatype=\"image\",\r\n        cloud=cloud,\r\n        batch=batch,\r\n        api_key=api_key,\r\n        apis=apis,\r\n        accepted_apis=IMAGE_APIS,\r\n        **kwargs\r\n    )", "response": "Given input image returns the results of specified image apis."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef hash(pii_csv, keys, schema, clk_json, quiet, no_header, check_header, validate):\n\n    schema_object = clkhash.schema.from_json_file(schema_file=schema)\n    header = True\n    if not check_header:\n        header = 'ignore'\n    if no_header:\n        header = False\n\n    try:\n        clk_data = clk.generate_clk_from_csv(\n            pii_csv, keys, schema_object,\n            validate=validate,\n            header=header,\n            progress_bar=not quiet)\n    except (validate_data.EntryError, validate_data.FormatError) as e:\n        msg, = e.args\n        log(msg)\n        log('Hashing failed.')\n    else:\n        json.dump({'clks': clk_data}, clk_json)\n        if hasattr(clk_json, 'name'):\n            log(\"CLK data written to {}\".format(clk_json.name))", "response": "Create CLKs from PII_CSV and JSON - formatted CLKs."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nconnects to an entity matching server and check the service status.", "response": "def status(server, output, verbose):\n    \"\"\"Connect to an entity matching server and check the service status.\n\n    Use \"-\" to output status to stdout.\n    \"\"\"\n    if verbose:\n        log(\"Connecting to Entity Matching Server: {}\".format(server))\n\n    service_status = server_get_status(server)\n    if verbose:\n        log(\"Status: {}\".format(service_status['status']))\n    print(json.dumps(service_status), file=output)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate a new project on an entity matching server.", "response": "def create_project(type, schema, server, name, output, verbose):\n    \"\"\"Create a new project on an entity matching server.\n\n    See entity matching service documentation for details on mapping type and schema\n    Returns authentication details for the created project.\n    \"\"\"\n    if verbose:\n        log(\"Entity Matching Server: {}\".format(server))\n\n    if schema is not None:\n        schema_json = json.load(schema)\n        # Validate the schema\n        clkhash.schema.validate_schema_dict(schema_json)\n    else:\n        raise ValueError(\"Schema must be provided when creating new linkage project\")\n\n    name = name if name is not None else ''\n\n    # Creating new project\n    try:\n        project_creation_reply = project_create(server, schema_json, type, name)\n    except ServiceError as e:\n        log(\"Unexpected response - {}\".format(e.status_code))\n        log(e.text)\n        raise SystemExit\n    else:\n        log(\"Project created\")\n\n    json.dump(project_creation_reply, output)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef create(server, name, project, apikey, output, threshold, verbose):\n    if verbose:\n        log(\"Entity Matching Server: {}\".format(server))\n\n    if threshold is None:\n        raise ValueError(\"Please provide a threshold\")\n\n    # Create a new run\n    try:\n        response = run_create(server, project, apikey, threshold, name)\n    except ServiceError as e:\n        log(\"Unexpected response with status {}\".format(e.status_code))\n        log(e.text)\n    else:\n        json.dump(response, output)", "response": "Create a new run on an entity matching server."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nuploads CLK data to entity matching server.", "response": "def upload(clk_json, project, apikey, server, output, verbose):\n    \"\"\"Upload CLK data to entity matching server.\n\n    Given a json file containing hashed clk data as CLK_JSON, upload to\n    the entity resolution service.\n\n    Use \"-\" to read from stdin.\n    \"\"\"\n    if verbose:\n        log(\"Uploading CLK data from {}\".format(clk_json.name))\n        log(\"To Entity Matching Server: {}\".format(server))\n        log(\"Project ID: {}\".format(project))\n        log(\"Uploading CLK data to the server\")\n\n    response = project_upload_clks(server, project, apikey, clk_json)\n\n    if verbose:\n        log(response)\n\n    json.dump(response, output)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ndownloads and return the results of a particular run.", "response": "def results(project, apikey, run, watch, server, output):\n    \"\"\"\n    Check to see if results are available for a particular mapping\n    and if so download.\n\n    Authentication is carried out using the --apikey option which\n    must be provided. Depending on the server operating mode this\n    may return a mask, a linkage table, or a permutation. Consult\n    the entity service documentation for details.\n    \"\"\"\n\n    status = run_get_status(server, project, run, apikey)\n    log(format_run_status(status))\n    if watch:\n        for status in watch_run_status(server, project, run, apikey, 24*60*60):\n            log(format_run_status(status))\n\n    if status['state'] == 'completed':\n        log(\"Downloading result\")\n        response = run_get_result_text(server, project, run, apikey)\n        log(\"Received result\")\n        print(response, file=output)\n    elif status['state'] == 'error':\n        log(\"There was an error\")\n        error_result = run_get_result_text(server, project, run, apikey)\n        print(error_result, file=output)\n    else:\n        log(\"No result yet\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngenerates fake PII data for testing", "response": "def generate(size, output, schema):\n    \"\"\"Generate fake PII data for testing\"\"\"\n    pii_data = randomnames.NameList(size)\n\n    if schema is not None:\n        raise NotImplementedError\n\n    randomnames.save_csv(\n        pii_data.names,\n        [f.identifier for f in pii_data.SCHEMA.fields],\n        output)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngenerating default schema for fake PII", "response": "def generate_default_schema(output):\n    \"\"\"Get default schema for fake PII\"\"\"\n    original_path = os.path.join(os.path.dirname(__file__),\n                                 'data',\n                                 'randomnames-schema.json')\n    shutil.copyfile(original_path, output)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ngive a. docx file returns the raw text associated with the given. docx file.", "response": "def docx_extraction(docx, cloud=None, batch=False, api_key=None, version=None, **kwargs):\n    \"\"\"\n    Given a .docx file, returns the raw text associated with the given .docx file.\n    The .docx file may be provided as base64 encoded data or as a filepath.\n\n    Example usage:\n\n    .. code-block:: python\n\n       >>> from indicoio import docx_extraction\n       >>> results = docx_extraction(docx_file)\n\n    :param docx: The docx to be analyzed.\n    :type docx: str or list of strs\n    :rtype: dict or list of dicts\n    \"\"\"\n    docx = docx_preprocess(docx, batch=batch)\n    url_params = {\"batch\": batch, \"api_key\": api_key, \"version\": version}\n    results = api_handler(docx, cloud=cloud, api=\"docxextraction\", url_params=url_params, **kwargs)\n    return results"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef facial_features(image, cloud=None, batch=False, api_key=None, version=None, **kwargs):\r\n    image = data_preprocess(image, batch=batch, size=None if kwargs.get(\"detect\") else (48, 48))\r\n    url_params = {\"batch\": batch, \"api_key\": api_key, \"version\": version}\r\n    return api_handler(image, cloud=cloud, api=\"facialfeatures\", url_params=url_params, **kwargs)", "response": "Returns a list of 48 dimensional feature vectors explaining that face."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef wait_for_run(server, project, run, apikey, timeout=None, update_period=1):\n    for status in watch_run_status(server, project, run, apikey, timeout, update_period):\n        pass\n    return status", "response": "Monitor a linkage run and return the final status updates."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef watch_run_status(server, project, run, apikey, timeout=None, update_period=1):\n    start_time = time.time()\n    status = old_status = run_get_status(server, project, run, apikey)\n    yield status\n\n    def time_not_up():\n        return (\n            (timeout is None) or\n            (time.time() - start_time < timeout)\n        )\n\n    while time_not_up():\n\n        if status['state'] in {'error', 'completed'}:\n            # No point continuing as run has entered a terminal state\n            yield status\n            return\n\n        if old_status != status:\n            yield status\n\n        time.sleep(update_period)\n        old_status = status\n        try:\n            status = run_get_status(server, project, run, apikey)\n        except RateLimitedClient:\n            time.sleep(1)\n    raise TimeoutError(\"Timeout exceeded before run {} terminated\".format(run))", "response": "Monitor a run and yield status updates."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nloads docx files from local filepath if not already b64 encoded Load docx files from local filepath if not already b64 encoded Load docx files from local filepath if not already b64 encoded Load docx files from local filepath if not already b64 encoded", "response": "def docx_preprocess(docx, batch=False):\n    \"\"\"\n    Load docx files from local filepath if not already b64 encoded\n    \"\"\"\n    if batch:\n        return [docx_preprocess(doc, batch=False) for doc in docx]\n\n    if os.path.isfile(docx):\n        # a filepath is provided, read and encode\n        return b64encode(open(docx, 'rb').read())\n    else:\n        # assume doc is already b64 encoded\n        return docx"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngiving input text and a list of query terms / phrases, returns how relevant the query is to the input text. Example usage: .. code-block:: python >>> import indicoio >>> text = 'On Monday, president Barack Obama will be giving his keynote address at...' >>> relevance = indicoio.relevance(text, queries=['president']) >>> print \"Relevance: \" + str(relevance[0]) u'Relevance: [0.44755361996336784]' :param text: The text to be analyzed. :param queries: a list of terms or phrases to measure similarity against :type text: str or unicode :rtype: Dictionary of feature score pairs", "response": "def relevance(data, queries, cloud=None, batch=False, api_key=None, version=None, **kwargs):\n    \"\"\"\n    Given input text and a list of query terms / phrases, returns how relevant the query is\n    to the input text.\n\n    Example usage:\n\n    .. code-block:: python\n\n       >>> import indicoio\n       >>> text = 'On Monday, president Barack Obama will be giving his keynote address at...'\n       >>> relevance = indicoio.relevance(text, queries=['president'])\n       >>> print \"Relevance: \" + str(relevance[0])\n       u'Relevance: [0.44755361996336784]'\n\n    :param text: The text to be analyzed.\n    :param queries: a list of terms or phrases to measure similarity against\n    :type text: str or unicode\n    :rtype: Dictionary of feature score pairs\n    \"\"\"\n    url_params = {\"batch\": batch, \"api_key\": api_key, \"version\": version}\n    kwargs['queries'] = queries\n    kwargs['synonyms'] = False\n    return api_handler(data, cloud=cloud, api=\"relevance\", url_params=url_params, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef ASSIGN(self, node):\n        if not isinstance(self.scope, ModuleScope):\n            return super().ASSIGN(node)\n\n        for target in node.targets:\n            self.handleNode(target, node)\n\n        self.deferHandleNode(node.value, node)", "response": "This is a custom assignment implementation that handles the assignments of type aliases."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nhandle an assignment node.", "response": "def ANNASSIGN(self, node):\n        \"\"\"\n        Annotated assignments don't have annotations evaluated on function\n        scope, hence the custom implementation. Compared to the pyflakes\n        version, we defer evaluation of the annotations (and values on\n        module level).\n        \"\"\"\n        if node.value:\n            # Only bind the *target* if the assignment has value.\n            # Otherwise it's not really ast.Store and shouldn't silence\n            # UndefinedLocal warnings.\n            self.handleNode(node.target, node)\n        if not isinstance(self.scope, FunctionScope):\n            self.deferHandleNode(node.annotation, node)\n        if node.value:\n            # If the assignment has value, handle the *value*...\n            if isinstance(self.scope, ModuleScope):\n                # ...later (if module scope).\n                self.deferHandleNode(node.value, node)\n            else:\n                # ...now.\n                self.handleNode(node.value, node)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef LAMBDA(self, node):\n        self.handleNode, self.deferHandleNode = self.deferHandleNode, self.handleNode\n        super().LAMBDA(node)\n        self.handleNode, self.deferHandleNode = self.deferHandleNode, self.handleNode", "response": "This is a hack to handle the LAMBDA function."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncompute the double hash encoding of the ngrams with the given keys. Using the method from: Schnell, R., Bachteler, T., & Reiher, J. (2011). A Novel Error-Tolerant Anonymous Linking Code. http://grlc.german-microsimulation.de/wp-content/uploads/2017/05/downloadwp-grlc-2011-02.pdf :param ngrams: list of n-grams to be encoded :param keys: hmac secret keys for md5 and sha1 as bytes :param ks: ks[i] is k value to use for ngram[i] :param l: length of the output bitarray :param encoding: the encoding to use when turning the ngrams to bytes :return: bitarray of length l with the bits set which correspond to the encoding of the ngrams", "response": "def double_hash_encode_ngrams(ngrams,   # type: Iterable[str]\n                              keys,     # type: Sequence[bytes]\n                              ks,       # type: Sequence[int]\n                              l,        # type: int\n                              encoding  # type: str\n                              ):\n    # type: (...) -> bitarray\n    \"\"\" Computes the double hash encoding of the ngrams with the given keys.\n\n            Using the method from:\n            Schnell, R., Bachteler, T., & Reiher, J. (2011).\n            A Novel Error-Tolerant Anonymous Linking Code.\n            http://grlc.german-microsimulation.de/wp-content/uploads/2017/05/downloadwp-grlc-2011-02.pdf\n\n        :param ngrams: list of n-grams to be encoded\n        :param keys: hmac secret keys for md5 and sha1 as bytes\n        :param ks: ks[i] is k value to use for ngram[i]\n        :param l: length of the output bitarray\n        :param encoding: the encoding to use when turning the ngrams to bytes\n\n        :return: bitarray of length l with the bits set which correspond to\n                 the encoding of the ngrams\n    \"\"\"\n    key_sha1, key_md5 = keys\n    bf = bitarray(l)\n    bf.setall(False)\n\n    for m, k in zip(ngrams, ks):\n        sha1hm = int(\n            hmac.new(key_sha1, m.encode(encoding=encoding), sha1).hexdigest(),\n            16) % l\n        md5hm = int(\n            hmac.new(key_md5, m.encode(encoding=encoding), md5).hexdigest(),\n            16) % l\n        for i in range(k):\n            gi = (sha1hm + i * md5hm) % l\n            bf[gi] = 1\n    return bf"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef double_hash_encode_ngrams_non_singular(ngrams,   # type: Iterable[str]\n                                           keys,     # type: Sequence[bytes]\n                                           ks,       # type: Sequence[int]\n                                           l,        # type: int\n                                           encoding  # type: str\n                                           ):\n    # type: (...) -> bitarray.bitarray\n    \"\"\" computes the double hash encoding of the n-grams with the given keys.\n\n        The original construction of [Schnell2011]_ displays an abnormality for\n        certain inputs:\n\n            An n-gram can be encoded into just one bit irrespective of the number\n            of k.\n\n        Their construction goes as follows: the :math:`k` different indices\n        :math:`g_i` of the Bloom filter for an n-gram\n        :math:`x` are defined as:\n\n        .. math:: g_{i}(x) = (h_1(x) + i h_2(x)) \\\\mod l\n\n        with :math:`0 \\\\leq i < k` and :math:`l` is the length of the Bloom\n        filter. If the value of the hash of :math:`x` of\n        the second hash function is a multiple of :math:`l`, then\n\n        .. math:: h_2(x) = 0 \\\\mod l\n\n        and thus\n\n        .. math:: g_i(x) = h_1(x) \\\\mod l,\n\n        irrespective of the value :math:`i`. A discussion of this potential flaw\n        can be found\n        `here <https://github.com/data61/clkhash/issues/33>`_.\n\n        :param ngrams: list of n-grams to be encoded\n        :param keys: tuple with (key_sha1, key_md5).\n               That is, (hmac secret keys for sha1 as bytes, hmac secret keys for\n               md5 as bytes)\n        :param ks: ks[i] is k value to use for ngram[i]\n        :param l: length of the output bitarray\n        :param encoding: the encoding to use when turning the ngrams to bytes\n\n        :return: bitarray of length l with the bits set which correspond to the\n                 encoding of the ngrams\n    \"\"\"\n    key_sha1, key_md5 = keys\n    bf = bitarray(l)\n    bf.setall(False)\n    for m, k in zip(ngrams, ks):\n        m_bytes = m.encode(encoding=encoding)\n\n        sha1hm_bytes = hmac.new(key_sha1, m_bytes, sha1).digest()\n        md5hm_bytes = hmac.new(key_md5, m_bytes, md5).digest()\n\n        sha1hm = int_from_bytes(sha1hm_bytes, 'big') % l\n        md5hm = int_from_bytes(md5hm_bytes, 'big') % l\n\n        i = 0\n        while md5hm == 0:\n            md5hm_bytes = hmac.new(\n                key_md5, m_bytes + chr(i).encode(), md5).digest()\n            md5hm = int_from_bytes(md5hm_bytes, 'big') % l\n            i += 1\n\n        for i in range(k):\n            gi = (sha1hm + i * md5hm) % l\n            bf[gi] = True\n    return bf", "response": "This function computes the double hash encoding of the n - grams with the given keys and the given l."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef blake_encode_ngrams(ngrams,   # type: Iterable[str]\n                        keys,     # type: Sequence[bytes]\n                        ks,       # type: Sequence[int]\n                        l,        # type: int\n                        encoding  # type: str\n                        ):\n    # type: (...) -> bitarray.bitarray\n    \"\"\" Computes the encoding of the ngrams using the BLAKE2 hash function.\n\n        We deliberately do not use the double hashing scheme as proposed in [\n        Schnell2011]_, because this\n        would introduce an exploitable structure into the Bloom filter. For more\n        details on the\n        weakness, see [Kroll2015]_.\n\n        In short, the double hashing scheme only allows for :math:`l^2`\n        different encodings for any possible n-gram,\n        whereas the use of :math:`k` different independent hash functions gives\n        you :math:`\\\\sum_{j=1}^{k}{\\\\binom{l}{j}}`\n        combinations.\n\n\n        **Our construction**\n\n        It is advantageous to construct Bloom filters using a family of hash\n        functions with the property of\n        `k-independence <https://en.wikipedia.org/wiki/K-independent_hashing>`_\n        to compute the indices for an entry.\n        This approach minimises the change of collisions.\n\n        An informal definition of *k-independence* of a family of hash functions\n        is, that if selecting a function at random\n        from the family, it guarantees that the hash codes of any designated k\n        keys are independent random variables.\n\n        Our construction utilises the fact that the output bits of a\n        cryptographic hash function are uniformly distributed,\n        independent, binary random variables (well, at least as close to as\n        possible. See [Kaminsky2011]_ for an analysis).\n        Thus, slicing the output of a cryptographic hash function into k\n        different slices gives you k independent random\n        variables.\n\n        We chose Blake2 as the cryptographic hash function mainly for two reasons:\n\n        * it is fast.\n        * in keyed hashing mode, Blake2 provides MACs with just one hash\n          function call instead of the two calls in the HMAC construction used\n          in the double hashing scheme.\n\n\n        .. warning::\n           Please be aware that, although this construction makes the attack of\n           [Kroll2015]_ infeasible, it is most likely\n           not enough to ensure security. Or in their own words:\n\n             | However, we think that using independent hash functions alone\n               will not be sufficient to ensure security,\n               since in this case other approaches (maybe related to or at least\n               inspired through work from the\n               area of Frequent Itemset Mining) are promising to detect at least\n               the most frequent atoms automatically.\n\n        :param ngrams: list of n-grams to be encoded\n        :param keys: secret key for blake2 as bytes\n        :param ks: ks[i] is k value to use for ngram[i]\n        :param l: length of the output bitarray (has to be a power of 2)\n        :param encoding: the encoding to use when turning the ngrams to bytes\n\n        :return: bitarray of length l with the bits set which correspond to the\n                 encoding of the ngrams\n    \"\"\"\n    key, = keys  # Unpack.\n\n    log_l = int(math.log(l, 2))\n    if not 2 ** log_l == l:\n        raise ValueError(\n            'parameter \"l\" has to be a power of two for the BLAKE2 encoding, '\n            'but was: {}'.format(\n                l))\n    bf = bitarray(l)\n    bf.setall(False)\n\n    for m, k in zip(ngrams, ks):\n        random_shorts = []  # type: List[int]\n        num_macs = (k + 31) // 32\n        for i in range(num_macs):\n            hash_bytes = blake2b(m.encode(encoding=encoding), key=key,\n                                 salt=str(i).encode()).digest()\n            random_shorts.extend(struct.unpack('32H',\n                                               hash_bytes))  # interpret\n            # hash bytes as 32 unsigned shorts.\n        for i in range(k):\n            idx = random_shorts[i] % l\n            bf[idx] = 1\n    return bf", "response": "This function encodes the n - grams in the n - grams list using the BLAKE2 hash function."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef hashing_function_from_properties(\n        fhp  # type: FieldHashingProperties\n        ):\n    # type: (...) -> Callable[[Iterable[str], Sequence[bytes], Sequence[int], int, str], bitarray]\n    \"\"\" Get the hashing function for this field\n        :param fhp: hashing properties for this field\n        :return: the hashing function\n    \"\"\"\n    if fhp.hash_type == 'doubleHash':\n        if fhp.prevent_singularity:\n            return double_hash_encode_ngrams_non_singular\n        else:\n            return double_hash_encode_ngrams\n    elif fhp.hash_type == 'blakeHash':\n        return blake_encode_ngrams\n    else:\n        msg = \"Unsupported hash type '{}'\".format(fhp.hash_type)\n        raise ValueError(msg)", "response": "Returns the hashing function for the given field hashing properties."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nperform XOR folding on a Bloom filter.", "response": "def fold_xor(bloomfilter,  # type: bitarray\n             folds         # type: int\n             ):\n    # type: (...) -> bitarray\n    \"\"\" Performs XOR folding on a Bloom filter.\n\n        If the length of the original Bloom filter is n and we perform\n        r folds, then the length of the resulting filter is n / 2 ** r.\n\n        :param bloomfilter: Bloom filter to fold\n        :param folds: number of folds\n\n        :return: folded bloom filter\n    \"\"\"\n\n    if len(bloomfilter) % 2 ** folds != 0:\n        msg = ('The length of the bloom filter is {length}. It is not '\n               'divisible by 2 ** {folds}, so it cannot be folded {folds} '\n               'times.'\n               .format(length=len(bloomfilter), folds=folds))\n        raise ValueError(msg)\n\n    for _ in range(folds):\n        bf1 = bloomfilter[:len(bloomfilter) // 2]\n        bf2 = bloomfilter[len(bloomfilter) // 2:]\n\n        bloomfilter = bf1 ^ bf2\n\n    return bloomfilter"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef crypto_bloom_filter(record,      # type: Sequence[Text]\n                        tokenizers,  # type: List[Callable[[Text, Optional[Text]], Iterable[Text]]]\n                        schema,      # type: Schema\n                        keys         # type: Sequence[Sequence[bytes]]\n                        ):\n    # type: (...) -> Tuple[bitarray, Text, int]\n    \"\"\" Computes the composite Bloom filter encoding of a record.\n\n        Using the method from\n        http://www.record-linkage.de/-download=wp-grlc-2011-02.pdf\n\n        :param record: plaintext record tuple. E.g. (index, name, dob, gender)\n        :param tokenizers: A list of tokenizers. A tokenizer is a function that\n            returns tokens from a string.\n        :param schema: Schema\n        :param keys: Keys for the hash functions as a tuple of lists of bytes.\n\n        :return: 3-tuple:\n                - bloom filter for record as a bitarray\n                - first element of record (usually an index)\n                - number of bits set in the bloomfilter\n    \"\"\"\n    hash_l = schema.l * 2 ** schema.xor_folds\n\n    bloomfilter = bitarray(hash_l)\n    bloomfilter.setall(False)\n\n    for (entry, tokenize, field, key) \\\n            in zip(record, tokenizers, schema.fields, keys):\n        fhp = field.hashing_properties\n        if fhp:\n            ngrams = list(tokenize(field.format_value(entry)))\n            hash_function = hashing_function_from_properties(fhp)\n            bloomfilter |= hash_function(ngrams, key,\n                                         fhp.ks(len(ngrams)),\n                                         hash_l, fhp.encoding)\n\n    c1 = bloomfilter.count()\n    bloomfilter = fold_xor(bloomfilter, schema.xor_folds)\n    c2 = bloomfilter.count()\n    return bloomfilter, record[0], bloomfilter.count()", "response": "Computes the composite Bloom filter encoding of a record."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef stream_bloom_filters(dataset,  # type: Iterable[Sequence[Text]]\n                         keys,     # type: Sequence[Sequence[bytes]]\n                         schema    # type: Schema\n                         ):\n    # type: (...) -> Iterable[Tuple[bitarray, Text, int]]\n    \"\"\" Compute composite Bloom filters (CLKs) for every record in an\n        iterable dataset.\n\n        :param dataset: An iterable of indexable records.\n        :param schema: An instantiated Schema instance\n        :param keys: A tuple of two lists of secret keys used in the HMAC.\n        :return: Generator yielding bloom filters as 3-tuples\n    \"\"\"\n    tokenizers = [tokenizer.get_tokenizer(field.hashing_properties)\n                  for field in schema.fields]\n    return (crypto_bloom_filter(s, tokenizers, schema, keys)\n            for s in dataset)", "response": "Generates composite Bloom filters for every record in an iterable dataset."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef re_compile_full(pattern, flags=0):\n    # type: (AnyStr, int) -> Pattern\n    \"\"\" Create compiled regular expression such that it matches the\n        entire string. Calling re.match on the output of this function\n        is equivalent to calling re.fullmatch on its input.\n\n        This is needed to support Python 2. (On Python 3, we would just\n        call re.fullmatch.)\n        Kudos: https://stackoverflow.com/a/30212799\n\n        :param pattern: The pattern to compile.\n        :param flags: Regular expression flags. Refer to Python\n            documentation.\n\n        :returns: A compiled regular expression.\n    \"\"\"\n    # Don't worry, this short-circuits.\n    assert type(pattern) is str or type(pattern) is unicode  # type: ignore\n\n    return re.compile(r'(?:{})\\Z'.format(pattern), flags=flags)", "response": "Create compiled regular expression such that it matches the entire string of the ISO - 8601 language."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _p2_unicode_reader(unicode_csv_data, dialect=csv.excel, **kwargs):\n    # Encode temporarily as UTF-8:\n    utf8_csv_data = _utf_8_encoder(unicode_csv_data)\n\n    # Now we can parse!\n    csv_reader = csv.reader(utf8_csv_data, dialect=dialect, **kwargs)\n\n    # Decode UTF-8 back to Unicode, cell by cell:\n    return ([unicode(cell, 'utf-8') for cell in row] for row in csv_reader)", "response": "Returns an iterator over the Unicode data in a CSV file."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nchecking if a file exists in the current directory.", "response": "def file_exists(filename):\n    \"\"\"\n    Check if a file exists (and don't error out on unicode inputs)\n    \"\"\"\n    try:\n        return os.path.isfile(filename)\n    except (UnicodeDecodeError, UnicodeEncodeError, ValueError):\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef data_preprocess(data, size=None, min_axis=None, batch=False):\n    if batch:\n        return [data_preprocess(el, size=size, min_axis=min_axis, batch=False) for el in data]\n\n    if isinstance(data, string_types):\n        if file_exists(data):\n            # probably a path to an image\n            preprocessed = Image.open(data)\n        else:\n            # base 64 encoded image data, a url, or raw content\n            # send raw data to the server and let the server infer type\n            b64_or_url = re.sub('^data:image/.+;base64,', '', data)\n            return b64_or_url\n\n    elif isinstance(data, Image.Image):\n        # data is image from PIL\n        preprocessed = data\n\n    elif type(data).__name__ == \"ndarray\":\n        # data is likely image from numpy/scipy\n        if \"float\" in str(data.dtype) and data.min() >= 0 and data.max() <= 1:\n            data *= 255.\n        try:\n            preprocessed = Image.fromarray(data.astype(\"uint8\"))\n        except TypeError:\n            raise IndicoError(\n                \"Please ensure the numpy array is in a format by PIL. \"\n                \"Values must be between 0 and 1 or between 0 and 255 in greyscale, rgb, or rgba format.\"\n            )\n\n    else:\n        # at this point we are unsure of the type -- it could be malformatted text or image data.\n        raise IndicoError(\n            \"Invalid input datatype: `{}`. \"\n            \"Ensure input data is one of the following types: \"\n            \"`str`, `unicode`, `PIL.Image`, `np.ndarray`.\".format(\n                data.__class__.__name__\n            )\n        )\n\n    #\n    if size or min_axis:\n        preprocessed = resize_image(preprocessed, size, min_axis)\n\n    # standardize on b64 encoding for sending image data over the wire\n    temp_output = BytesIO()\n    preprocessed.save(temp_output, format='PNG')\n    temp_output.seek(0)\n    output_s = temp_output.read()\n    return base64.b64encode(output_s).decode('utf-8') if PY3 else base64.b64encode(output_s)", "response": "Takes data and prepares it for sending to the api including resizing and image data and structure standardizing."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ntaking a nested list and returns the size of each dimension followed by the element type in the nested list", "response": "def get_list_dimensions(_list):\n    \"\"\"\n    Takes a nested list and returns the size of each dimension followed\n    by the element type in the list\n    \"\"\"\n    if isinstance(_list, list) or isinstance(_list, tuple):\n        return [len(_list)] + get_list_dimensions(_list[0])\n    return []"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_element_type(_list, dimens):\n    elem = _list\n    for _ in range(len(dimens)):\n        elem = elem[0]\n    return type(elem)", "response": "Given the dimensions of a nested list and the list returns the type of the elements in the inner list."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef image_recognition(image, cloud=None, batch=False, api_key=None, version=None, **kwargs):\n    image = data_preprocess(image, batch=batch, size=144, min_axis=True)\n    url_params = {\"batch\": batch, \"api_key\": api_key, \"version\": version}\n    return api_handler(image, cloud=cloud, api=\"imagerecognition\", url_params=url_params, **kwargs)", "response": "Given an input image returns a dictionary of image classifications with associated scores"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef multi(data, datatype, apis, accepted_apis, batch=False,**kwargs):\r\n    # Client side api name checking - strictly only accept func name api\r\n    invalid_apis = [api for api in apis if api not in accepted_apis or api in MULTIAPI_NOT_SUPPORTED]\r\n    if invalid_apis:\r\n        raise IndicoError(\r\n            \"The following are not valid %s APIs: %s. Please reference the available APIs below:\\n%s\"\r\n            % (datatype, \", \".join(invalid_apis),  \", \".join(accepted_apis.keys()))\r\n        )\r\n\r\n    # Convert client api names to server names before sending request\r\n    cloud = kwargs.pop(\"cloud\", None)\r\n    api_key = kwargs.pop('api_key', None)\r\n\r\n    api_results_executor = {}\r\n    for api in apis:\r\n        api_results_executor[EXECUTOR.submit(accepted_apis[api], data, cloud=cloud, api_key=api_key, batch=batch, **kwargs)] = api\r\n\r\n    api_results = {}\r\n    for future in concurrent.futures.as_completed(api_results_executor):\r\n        api_results[api_results_executor[future]] = future.result()\r\n\r\n    return api_results", "response": "Helper function to make a single request to the server."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef analyze_text(input_text, apis=DEFAULT_APIS, **kwargs):\r\n    cloud = kwargs.pop('cloud', None)\r\n    batch = kwargs.pop('batch', False)\r\n    api_key = kwargs.pop('api_key', None)\r\n\r\n    return multi(\r\n        data=input_text,\r\n        datatype=\"text\",\r\n        cloud=cloud,\r\n        batch=batch,\r\n        api_key=api_key,\r\n        apis=apis,\r\n        accepted_apis=TEXT_APIS,\r\n        **kwargs\r\n    )", "response": "Given input text returns the results of specified text apis."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef fhp_from_json_dict(\n        json_dict  # type: Dict[str, Any]\n    ):\n    # type: (...) -> FieldHashingProperties\n    \"\"\"\n    Make a :class:`FieldHashingProperties` object from a dictionary.\n\n        :param dict json_dict:\n            The dictionary must have have an 'ngram' key\n            and one of k or num_bits. It may have\n            'positional' key; if missing a default is used.\n            The encoding is\n            always set to the default value.\n        :return: A :class:`FieldHashingProperties` instance.\n    \"\"\"\n    h = json_dict.get('hash', {'type': 'blakeHash'})\n    num_bits = json_dict.get('numBits')\n    k = json_dict.get('k')\n    if not num_bits and not k:\n        num_bits = 200 # default for v2 schema\n    return FieldHashingProperties(\n        ngram=json_dict['ngram'],\n        positional=json_dict.get(\n            'positional', FieldHashingProperties._DEFAULT_POSITIONAL),\n        hash_type=h['type'],\n        prevent_singularity=h.get('prevent_singularity'),\n        num_bits=num_bits,\n        k=k,\n        missing_value=MissingValueSpec.from_json_dict(\n            json_dict[\n                'missingValue']) if 'missingValue' in json_dict else None\n    )", "response": "Returns a FieldHashingProperties object from a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef spec_from_json_dict(\n        json_dict  # type: Dict[str, Any]\n):\n    # type: (...) -> FieldSpec\n    \"\"\" Turns a dictionary into the appropriate object.\n\n        :param dict json_dict: A dictionary with properties.\n        :returns: An initialised instance of the appropriate FieldSpec\n            subclass.\n    \"\"\"\n    if 'ignored' in json_dict:\n        return Ignore(json_dict['identifier'])\n    type_str = json_dict['format']['type']\n    spec_type = cast(FieldSpec, FIELD_TYPE_MAP[type_str])\n    return spec_type.from_json_dict(json_dict)", "response": "Turns a dictionary into an instance of the appropriate FieldSpec subclass."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef ks(self, num_ngrams):\n        # type (int) -> [int]\n        \"\"\"\n        Provide a k for each ngram in the field value.\n        :param num_ngrams: number of ngrams in the field value\n        :return: [ k, ... ] a k value for each of num_ngrams such that the sum is exactly num_bits\n        \"\"\"\n        if self.num_bits:\n            k = int(self.num_bits / num_ngrams)\n            residue = self.num_bits % num_ngrams\n            return ([k + 1] * residue) + ([k] * (num_ngrams - residue))\n        else:\n            return [self.k if self.k else 0] * num_ngrams", "response": "provide a k value for each ngram in the field value."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreplace the missingValue value with the value in the missingValue section of the schema.", "response": "def replace_missing_value(self, str_in):\n        # type: (Text) -> Text\n        \"\"\" returns 'str_in' if it is not equals to the 'sentinel' as\n        defined in the missingValue section of\n        the schema. Else it will return the 'replaceWith' value.\n\n        :param str_in:\n        :return: str_in or the missingValue replacement value\n        \"\"\"\n        if self.missing_value is None:\n            return str_in\n        elif self.missing_value.sentinel == str_in:\n            return self.missing_value.replace_with\n        else:\n            return str_in"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nmake a StringSpec object from a dictionary containing its aniso - formatted version of its base - level properties.", "response": "def from_json_dict(cls,\n                       json_dict  # type: Dict[str, Any]\n                       ):\n        # type: (...) -> StringSpec\n        \"\"\" Make a StringSpec object from a dictionary containing its\n            properties.\n\n            :param dict json_dict: This dictionary must contain an\n                `'encoding'` key associated with a Python-conformant\n                encoding. It must also contain a `'hashing'` key, whose\n                contents are passed to :class:`FieldHashingProperties`.\n                Permitted keys also include `'pattern'`, `'case'`,\n                `'minLength'`, and `'maxLength'`.\n            :raises InvalidSchemaError: When a regular expression is\n                provided but is not a valid pattern.\n        \"\"\"\n        # noinspection PyCompatibility\n        result = cast(StringSpec,  # Go away, Mypy.\n                      super().from_json_dict(json_dict))\n\n        format_ = json_dict['format']\n        if 'encoding' in format_ and result.hashing_properties:\n            result.hashing_properties.encoding = format_['encoding']\n\n        if 'pattern' in format_:\n            pattern = format_['pattern']\n            try:\n                result.regex = re_compile_full(pattern)\n            except (SyntaxError, re.error) as e:\n                msg = \"Invalid regular expression '{}.'\".format(pattern)\n                e_new = InvalidSchemaError(msg)\n                raise_from(e_new, e)\n            result.regex_based = True\n\n        else:\n            result.case = format_.get('case', StringSpec._DEFAULT_CASE)\n            result.min_length = format_.get('minLength')\n            result.max_length = format_.get('maxLength')\n            result.regex_based = False\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef validate(self, str_in):\n        # type: (Text) -> None\n        \"\"\" Validates an entry in the field.\n\n            Raises `InvalidEntryError` iff the entry is invalid.\n\n            An entry is invalid iff (1) a pattern is part of the\n            specification of the field and the string does not match\n            it; (2) the string does not match the provided casing,\n            minimum length, or maximum length; or (3) the specified\n            encoding cannot represent the string.\n\n            :param str str_in: String to validate.\n            :raises InvalidEntryError: When entry is invalid.\n            :raises ValueError: When self.case is not one of the\n                permitted values (`'lower'`, `'upper'`, or `'mixed'`).\n        \"\"\"\n        if self.is_missing_value(str_in):\n            return\n        # noinspection PyCompatibility\n        super().validate(str_in)  # Validate encoding.\n\n        if self.regex_based:\n            match = self.regex.match(str_in)\n            if match is None:\n                e = InvalidEntryError(\n                    'Expected entry that conforms to regular expression '\n                    \"'{}'. Read '{}'.\".format(self.regex.pattern, str_in))\n                e.field_spec = self\n                raise e\n\n        else:\n            str_len = len(str_in)\n            if self.min_length is not None and str_len < self.min_length:\n                e = InvalidEntryError(\n                    \"Expected string length of at least {}. Read string '{}' \"\n                    'of length {}.'.format(self.min_length, str_in, str_len))\n                e.field_spec = self\n                raise e\n\n            if self.max_length is not None and str_len > self.max_length:\n                e = InvalidEntryError(\n                    \"Expected string length of at most {}. Read string '{}' \"\n                    'of length {}.'.format(self.max_length, str_in, str_len))\n                e.field_spec = self\n                raise e\n\n            if self.case == 'upper':\n                if str_in.upper() != str_in:\n                    msg = \"Expected upper case string. Read '{}'.\".format(\n                        str_in)\n                    e = InvalidEntryError(msg)\n                    e.field_spec = self\n                    raise e\n            elif self.case == 'lower':\n                if str_in.lower() != str_in:\n                    msg = \"Expected lower case string. Read '{}'.\".format(\n                        str_in)\n                    e = InvalidEntryError(msg)\n                    e.field_spec = self\n                    raise e\n            elif self.case == 'mixed':\n                pass\n            else:\n                raise ValueError(\n                    'Invalid case property {}.'.format(self.case))", "response": "Validates an entry in the field."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nmake a IntegerSpec object from a dictionary containing its properties.", "response": "def from_json_dict(cls,\n                       json_dict  # type: Dict[str, Any]\n                       ):\n        # type: (...) -> IntegerSpec\n        \"\"\" Make a IntegerSpec object from a dictionary containing its\n            properties.\n\n            :param dict json_dict: This dictionary may contain\n                `'minimum'` and `'maximum'` keys. In addition, it must\n                contain a `'hashing'` key, whose contents are passed to\n                :class:`FieldHashingProperties`.\n\n            :param dict json_dict: The properties dictionary.\n        \"\"\"\n        # noinspection PyCompatibility\n        result = cast(IntegerSpec,  # For Mypy.\n                      super().from_json_dict(json_dict))\n\n        format_ = json_dict['format']\n        result.minimum = format_.get('minimum')\n        result.maximum = format_.get('maximum')\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nvalidates an entry in the field.", "response": "def validate(self, str_in):\n        # type: (Text) -> None\n        \"\"\" Validates an entry in the field.\n\n            Raises `InvalidEntryError` iff the entry is invalid.\n\n            An entry is invalid iff (1) the string does not represent a\n            base-10 integer; (2) the integer is not between\n            `self.minimum` and `self.maximum`, if those exist; or (3)\n            the integer is negative.\n\n            :param str str_in: String to validate.\n            :raises InvalidEntryError: When entry is invalid.\n        \"\"\"\n        if self.is_missing_value(str_in):\n            return\n        # noinspection PyCompatibility\n        super().validate(str_in)\n\n        try:\n            value = int(str_in, base=10)\n        except ValueError as e:\n            msg = \"Invalid integer. Read '{}'.\".format(str_in)\n            e_new = InvalidEntryError(msg)\n            e_new.field_spec = self\n            raise_from(e_new, e)\n            return  # to stop PyCharm thinking that value might be undefined\n            #  later\n\n        if self.minimum is not None and value < self.minimum:\n            msg = (\"Expected integer value of at least {}. Read '{}'.\"\n                   .format(self.minimum, value))\n            e_new = InvalidEntryError(msg)\n            e_new.field_spec = self\n            raise e_new\n\n        if self.maximum is not None and value > self.maximum:\n            msg = (\"Expected integer value of at most {}. Read '{}'.\"\n                   .format(self.maximum, value))\n            e_new = InvalidEntryError(msg)\n            e_new.field_spec = self\n            raise e_new"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef from_json_dict(cls,\n                       json_dict  # type: Dict[str, Any]\n    ):\n        # type: (...) -> DateSpec\n        \"\"\" Make a DateSpec object from a dictionary containing its\n            properties.\n\n            :param dict json_dict: This dictionary must contain a\n                `'format'` key. In addition, it must contain a\n                `'hashing'` key, whose contents are passed to\n                :class:`FieldHashingProperties`.\n\n            :param json_dict: The properties dictionary.\n        \"\"\"\n        # noinspection PyCompatibility\n        result = cast(DateSpec,  # For Mypy.\n                      super().from_json_dict(json_dict))\n\n        format_ = json_dict['format']\n        result.format = format_['format']\n\n        return result", "response": "Make a DateSpec object from a dictionary containing its\n            properties."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef validate(self, str_in):\n        # type: (Text) -> None\n        \"\"\" Validates an entry in the field.\n\n            Raises `InvalidEntryError` iff the entry is invalid.\n\n            An entry is invalid iff (1) the string does not represent a\n            date in the correct format; or (2) the date it represents\n            is invalid (such as 30 February).\n\n            :param str str_in: String to validate.\n            :raises InvalidEntryError: Iff entry is invalid.\n            :raises ValueError: When self.format is unrecognised.\n        \"\"\"\n        if self.is_missing_value(str_in):\n            return\n        # noinspection PyCompatibility\n        super().validate(str_in)\n        try:\n            datetime.strptime(str_in, self.format)\n        except ValueError as e:\n            msg = \"Validation error for date type: {}\".format(e)\n            e_new = InvalidEntryError(msg)\n            e_new.field_spec = self\n            raise_from(e_new, e)", "response": "Validates an entry in the field."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nformat regular value of the log entry", "response": "def _format_regular_value(self, str_in):\n        # type: (Text) -> Text\n        \"\"\" we overwrite default behaviour as we want to hash the numbers\n        only, no fillers like '-', or '/'\n\n        :param str str_in: date string\n        :return: str date string with format DateSpec.OUTPUT_FORMAT\n        \"\"\"\n        try:\n            dt = datetime.strptime(str_in, self.format)\n            return strftime(dt, DateSpec.OUTPUT_FORMAT)\n        except ValueError as e:\n            msg = \"Unable to format date value '{}'. Reason: {}\".format(str_in,\n                                                                        e)\n            e_new = InvalidEntryError(msg)\n            e_new.field_spec = self\n            raise_from(e_new, e)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nmaking an EnumSpec object from a dictionary containing its properties.", "response": "def from_json_dict(cls,\n                       json_dict  # type: Dict[str, Any]\n                       ):\n        # type: (...) -> EnumSpec\n        \"\"\" Make a EnumSpec object from a dictionary containing its\n            properties.\n\n            :param dict json_dict: This dictionary must contain an\n                `'enum'` key specifying the permitted values. In\n                addition, it must contain a `'hashing'` key, whose\n                contents are passed to :class:`FieldHashingProperties`.\n        \"\"\"\n        # noinspection PyCompatibility\n        result = cast(EnumSpec,  # Appease the gods of Mypy.\n                      super().from_json_dict(json_dict))\n\n        format_ = json_dict['format']\n        result.values = set(format_['values'])\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef validate(self, str_in):\n        # type: (Text) -> None\n        \"\"\" Validates an entry in the field.\n\n            Raises `InvalidEntryError` iff the entry is invalid.\n\n            An entry is invalid iff it is not one of the permitted\n            values.\n\n            :param str str_in: String to validate.\n            :raises InvalidEntryError: When entry is invalid.\n        \"\"\"\n        if self.is_missing_value(str_in):\n            return\n        # noinspection PyCompatibility\n        super().validate(str_in)\n\n        if str_in not in self.values:\n            msg = (\"Expected enum value to be one of {}. Read '{}'.\"\n                   .format(list(self.values), str_in))\n            e = InvalidEntryError(msg)\n            e.field_spec = self\n            raise e", "response": "Validates an entry in the field."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsplitting an iterable into chunks of size size", "response": "def batched(iterable, size):\n    \"\"\"\n    Split an iterable into constant sized chunks\n    Recipe from http://stackoverflow.com/a/8290514\n    \"\"\"\n    length = len(iterable)\n    for batch_start in range(0, length, size):\n        yield iterable[batch_start:batch_start+size]"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef standardize_input_data(data):\n    if type(data) == bytes:\n        data = data.decode('utf-8')\n    if type(data) == list:\n        data = [\n            el.decode('utf-8') if type(data) == bytes else el\n            for el in data\n        ]\n    return data", "response": "Standardize the input data for the indico API."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef api_handler(input_data, cloud, api, url_params=None, batch_size=None, **kwargs):\n    url_params = url_params or {}\n    input_data = standardize_input_data(input_data)\n\n    cloud = cloud or config.cloud\n    host = \"%s.indico.domains\" % cloud if cloud else config.host\n\n    # LOCAL DEPLOYMENTS\n    if not (host.endswith('indico.domains') or host.endswith('indico.io')):\n        url_protocol = \"http\"\n    else:\n        url_protocol = config.url_protocol\n\n    headers = dict(JSON_HEADERS)\n    headers[\"X-ApiKey\"] = url_params.get(\"api_key\") or config.api_key\n    url = create_url(url_protocol, host, api, dict(kwargs, **url_params))\n    return collect_api_results(input_data, url, headers, api, batch_size, kwargs)", "response": "This function handles the finalization of an indico - internal node - based API request."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef collect_api_results(input_data, url, headers, api, batch_size, kwargs):\n    if batch_size:\n        results = []\n        for batch in batched(input_data, size=batch_size):\n            try:\n                result = send_request(batch, api, url, headers, kwargs)\n                if isinstance(result, list):\n                    results.extend(result)\n                else:\n                    results.append(result)\n            except IndicoError as e:\n                # Log results so far to file\n                timestamp = datetime.datetime.now().strftime('%Y-%m-%d-%H:%M:%S')\n                filename = \"indico-{api}-{timestamp}.json\".format(\n                    api=api,\n                    timestamp=timestamp\n                )\n                if sys.version_info > (3, 0):\n                    json.dump(results, open(filename, mode='w', encoding='utf-8'), cls=NumpyEncoder)\n                else:\n                    json.dump(results, open(filename, mode='w'), cls=NumpyEncoder)\n                raise BatchProcessingError(\n                    \"The following error occurred while processing your data: `{err}` \"\n                    \"Partial results have been saved to {filename}\".format(\n                        err=e,\n                        filename=os.path.abspath(filename)\n                    )\n                )\n        return results\n    else:\n        return send_request(input_data, api, url, headers, kwargs)", "response": "Collect the results from an API call."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nsend a request to the indico servers", "response": "def send_request(input_data, api, url, headers, kwargs):\n    \"\"\"\n    Use the requests library to send of an HTTP call to the indico servers\n    \"\"\"\n    data = {}\n    if input_data != None:\n        data['data'] = input_data\n\n    # request that the API respond with a msgpack encoded result\n    serializer = kwargs.pop(\"serializer\", config.serializer)\n    data['serializer'] = serializer\n\n    data.update(**kwargs)\n\n    json_data = json.dumps(data)\n\n    response = requests.post(url, data=json_data, headers=headers)\n\n    warning = response.headers.get('x-warning')\n    if warning:\n        warnings.warn(warning)\n\n    cloud = urlparse(url).hostname\n    if response.status_code == 503 and not cloud.endswith('.indico.io'):\n        raise APIDoesNotExist(\"Private cloud '%s' does not include api '%s'\" % (cloud, api))\n\n    try:\n        if serializer == 'msgpack':\n            json_results = msgpack.unpackb(response.content)\n        else:\n            json_results = response.json()\n    except (msgpack.exceptions.UnpackException, msgpack.exceptions.ExtraData):\n        try:\n            json_results = response.json()\n        except:\n            json_results = {\"error\": response.text}\n\n\n    if config.PY3:\n        json_results = convert(json_results)\n\n    results = json_results.get('results', False)\n    if results is False:\n        error = json_results.get('error')\n        raise convert_to_py_error(error)\n    return results"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ngenerate the proper url for sending off data for analysis", "response": "def create_url(url_protocol, host, api, url_params):\n    \"\"\"\n    Generate the proper url for sending off data for analysis\n    \"\"\"\n    is_batch = url_params.pop(\"batch\", None)\n    apis = url_params.pop(\"apis\", None)\n    version = url_params.pop(\"version\", None) or url_params.pop(\"v\", None)\n    method = url_params.pop('method', None)\n\n    host_url_seg = url_protocol + \"://%s\" % host\n    api_url_seg = \"/%s\" % api\n    batch_url_seg = \"/batch\" if is_batch else \"\"\n    method_url_seg = \"/%s\" % method if method else \"\"\n\n    params = {}\n    if apis:\n        params[\"apis\"] = \",\".join(apis)\n    if version:\n        params[\"version\"] = version\n\n    url = host_url_seg + api_url_seg + batch_url_seg + method_url_seg\n    if params:\n        url += \"?\" + urlencode(params)\n\n    return url"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ngive input text returns series of keywords and associated scores", "response": "def keywords(text, cloud=None, batch=False, api_key=None, version=2, batch_size=None, **kwargs):\n    \"\"\"\n    Given input text, returns series of keywords and associated scores\n\n    Example usage:\n\n    .. code-block:: python\n\n       >>> import indicoio\n       >>> import numpy as np\n       >>> text = 'Monday: Delightful with mostly sunny skies. Highs in the low 70s.'\n       >>> keywords = indicoio.keywords(text, top_n=3)\n       >>> print \"The keywords are: \"+str(keywords.keys())\n       u'The keywords are ['delightful', 'highs', 'skies']\n\n    :param text: The text to be analyzed.\n    :type text: str or unicode\n    :rtype: Dictionary of feature score pairs\n    \"\"\"\n    if kwargs.get(\"language\", \"english\") != \"english\":\n        version = 1\n    url_params = {\"batch\": batch, \"api_key\": api_key, \"version\": version}\n    return api_handler(text, cloud=cloud, api=\"keywords\", url_params=url_params, batch_size=batch_size, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef personas(text, cloud=None, batch=False, api_key=None, version=None, **kwargs):\n    url_params = {\"batch\": batch, \"api_key\": api_key, \"version\": version}\n    kwargs['persona'] = True\n    return api_handler(text, cloud=cloud, api=\"personality\", url_params=url_params, **kwargs)", "response": "Returns the authors likelihood of being 16 different personality objects in a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ngive a pdf returns the text and metadata associated with the given pdf.", "response": "def pdf_extraction(pdf, cloud=None, batch=False, api_key=None, version=None, **kwargs):\n    \"\"\"\n    Given a pdf, returns the text and metadata associated with the given pdf.\n    PDFs may be provided as base64 encoded data or as a filepath.\n    Base64 image data and formatted table is optionally returned by setting\n    `images=True` or `tables=True`.\n\n    Example usage:\n\n    .. code-block:: python\n\n       >>> from indicoio import pdf_extraction\n       >>> results = pdf_extraction(pdf_file)\n       >>> results.keys()\n       ['text', 'metadata']\n\n    :param pdf: The pdf to be analyzed.\n    :type pdf: str or list of strs\n    :rtype: dict or list of dicts\n    \"\"\"\n    pdf = pdf_preprocess(pdf, batch=batch)\n    url_params = {\"batch\": batch, \"api_key\": api_key, \"version\": version}\n    results = api_handler(pdf, cloud=cloud, api=\"pdfextraction\", url_params=url_params, **kwargs)\n\n    if batch:\n        for result in results:\n            result[\"images\"] = postprocess_images(result.get(\"images\", []))\n    else:\n        results['images'] = postprocess_images(results.get(\"images\", []))\n    return results"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a tokenizer function that returns a list of n - grams for the given word and optional field_formats. FieldHashingProperties object.", "response": "def get_tokenizer(fhp  # type: Optional[field_formats.FieldHashingProperties]\n                  ):\n    # type: (...) -> Callable[[Text, Optional[Text]], Iterable[Text]]\n    \"\"\" Get tokeniser function from the hash settings.\n\n        This function takes a FieldHashingProperties object. It returns a\n        function that takes a string and tokenises based on those properties.\n    \"\"\"\n\n    def dummy(word, ignore=None):\n        # type: (Text, Optional[Text]) -> Iterable[Text]\n        \"\"\"\n        Null tokenizer returns empty Iterable.\n        FieldSpec Ignore has hashing_properties = None\n        and get_tokenizer has to return something for this case,\n        even though it's never called. An alternative would be to\n        use an Optional[Callable]].\n        :param word: not used\n        :param ignore: not used\n        :return: empty Iterable\n        \"\"\"\n        return ('' for i in range(0))\n\n    if not fhp:\n        return dummy\n\n    n = fhp.ngram\n    if n < 0:\n        raise ValueError('`n` in `n`-gram must be non-negative.')\n\n    positional = fhp.positional\n\n    def tok(word, ignore=None):\n        # type: (Text, Optional[Text]) -> Iterable[Text]\n        \"\"\" Produce `n`-grams of `word`.\n\n            :param word: The string to tokenize.\n            :param ignore: The substring whose occurrences we remove from\n                `word` before tokenization.\n            :return: Tuple of n-gram strings.\n        \"\"\"\n        if ignore is not None:\n            word = word.replace(ignore, '')\n\n        if n > 1:\n            word = ' {} '.format(word)\n\n        if positional:\n            # These are 1-indexed.\n            return ('{} {}'.format(i + 1, word[i:i + n])\n                    for i in range(len(word) - n + 1))\n        else:\n            return (word[i:i + n] for i in range(len(word) - n + 1))\n\n    return tok"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef pdf_preprocess(pdf, batch=False):\n    if batch:\n        return [pdf_preprocess(doc, batch=False) for doc in pdf]\n\n    if os.path.isfile(pdf):\n        # a filepath is provided, read and encode\n        return b64encode(open(pdf, 'rb').read())\n    else:\n        # assume pdf is already b64 encoded\n        return pdf", "response": "Load pdfs from local filepath if not already b64 encoded\n    Load pdfs from local filepath if not already b64 encoded\n   "}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef people(text, cloud=None, batch=None, api_key=None, version=2, **kwargs):\r\n    url_params = {\"batch\": batch, \"api_key\": api_key, \"version\": version}\r\n    return api_handler(text, cloud=cloud, api=\"people\", url_params=url_params, **kwargs)", "response": "Returns a list of persons that are linked to the given text."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef update(self,\n               x  # type: Sequence[Union[int, float]]\n               ):\n        # type: (...) -> None\n        \"\"\"\n        updates the statistics with the given list of numbers\n\n        It uses an online algorithm which uses compensated summation to reduce numerical errors.\n        See https://angelacorasaniti.wordpress.com/2015/05/06/hw2-mean-and-variance-of-data-stream/ for details.\n\n        :param x: list of numbers\n        :return: nothing\n        \"\"\"\n        if any(math.isnan(float(i)) or math.isinf(float(i)) for i in x):\n            raise ValueError('input contains non-finite numbers like \"nan\" or \"+/- inf\"')\n        t = sum(x)\n        m = float(len(x))\n        norm_t = t / m\n        S = sum((xi - norm_t) ** 2 for xi in x)\n        if self.n == 0:\n            self.S = self.S + S\n        else:\n            self.S = self.S + S + self.n / (m * (m + self.n)) * (m / self.n * self.t - t) ** 2\n        self.t = self.t + t\n        self.n = self.n + len(x)", "response": "Updates the statistics with the given list of numbers\n              ."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngenerating Bloom filters (ie hash) from chunks of PII then serialize the generated Bloom filters. It also computes and outputs the Hamming weight (or popcount) -- the number of bits set to one -- of the generated Bloom filters. :param chunk_pii_data: An iterable of indexable records. :param keys: A tuple of two lists of secret keys used in the HMAC. :param Schema schema: Schema specifying the entry formats and hashing settings. :return: A list of serialized Bloom filters and a list of corresponding popcounts", "response": "def hash_and_serialize_chunk(chunk_pii_data,  # type: Sequence[Sequence[str]]\n                             keys,  # type: Sequence[Sequence[bytes]]\n                             schema  # type: Schema\n                             ):\n    # type: (...) -> Tuple[List[str], Sequence[int]]\n    \"\"\"\n    Generate Bloom filters (ie hash) from chunks of PII then serialize\n    the generated Bloom filters. It also computes and outputs the Hamming weight (or popcount) -- the number of bits\n    set to one -- of the generated Bloom filters.\n\n    :param chunk_pii_data: An iterable of indexable records.\n    :param keys: A tuple of two lists of secret keys used in the HMAC.\n    :param Schema schema: Schema specifying the entry formats and\n            hashing settings.\n    :return: A list of serialized Bloom filters and a list of corresponding popcounts\n    \"\"\"\n    clk_data = []\n    clk_popcounts = []\n    for clk in stream_bloom_filters(chunk_pii_data, keys, schema):\n        clk_data.append(serialize_bitarray(clk[0]).strip())\n        clk_popcounts.append(clk[2])\n    return clk_data, clk_popcounts"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef generate_clk_from_csv(input_f,  # type: TextIO\n                          keys,  # type: Tuple[AnyStr, AnyStr]\n                          schema,  # type: Schema\n                          validate=True,  # type: bool\n                          header=True,  # type: Union[bool, AnyStr]\n                          progress_bar=True  # type: bool\n                          ):\n    # type: (...) -> List[str]\n    \"\"\" Generate Bloom filters from CSV file, then serialise them.\n\n        This function also computes and outputs the Hamming weight\n        (a.k.a popcount -- the number of bits set to high) of the\n        generated Bloom filters.\n\n        :param input_f: A file-like object of csv data to hash.\n        :param keys: A tuple of two lists of secret keys.\n        :param schema: Schema specifying the record formats and\n            hashing settings.\n        :param validate: Set to `False` to disable validation of\n            data against the schema. Note that this will silence\n            warnings whose aim is to keep the hashes consistent between\n            data sources; this may affect linkage accuracy.\n        :param header: Set to `False` if the CSV file does not have\n            a header. Set to `'ignore'` if the CSV file does have a\n            header but it should not be checked against the schema.\n        :param bool progress_bar: Set to `False` to disable the progress\n            bar.\n        :return: A list of serialized Bloom filters and a list of\n            corresponding popcounts.\n    \"\"\"\n    if header not in {False, True, 'ignore'}:\n        raise ValueError(\"header must be False, True or 'ignore' but is {}.\"\n                         .format(header))\n\n    log.info(\"Hashing data\")\n\n    # Read from CSV file\n    reader = unicode_reader(input_f)\n\n    if header:\n        column_names = next(reader)\n        if header != 'ignore':\n            validate_header(schema.fields, column_names)\n\n    start_time = time.time()\n\n    # Read the lines in CSV file and add it to PII\n    pii_data = []\n    for line in reader:\n        pii_data.append(tuple(element.strip() for element in line))\n\n    validate_row_lengths(schema.fields, pii_data)\n\n    if progress_bar:\n        stats = OnlineMeanVariance()\n        with tqdm(desc=\"generating CLKs\", total=len(pii_data), unit='clk', unit_scale=True,\n                  postfix={'mean': stats.mean(), 'std': stats.std()}) as pbar:\n            def callback(tics, clk_stats):\n                stats.update(clk_stats)\n                pbar.set_postfix(mean=stats.mean(), std=stats.std(), refresh=False)\n                pbar.update(tics)\n\n            results = generate_clks(pii_data,\n                                    schema,\n                                    keys,\n                                    validate=validate,\n                                    callback=callback)\n    else:\n        results = generate_clks(pii_data,\n                                schema,\n                                keys,\n                                validate=validate)\n\n    log.info(\"Hashing took {:.2f} seconds\".format(time.time() - start_time))\n    return results", "response": "Generates a list of secret keys from a CSV file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef chunks(seq, chunk_size):\n    # type: (Sequence[T], int) -> Iterable[Sequence[T]]\n    \"\"\" Split seq into chunk_size-sized chunks.\n\n        :param seq: A sequence to chunk.\n        :param chunk_size: The size of chunk.\n    \"\"\"\n    return (seq[i:i + chunk_size] for i in range(0, len(seq), chunk_size))", "response": "Splits a sequence into chunks of size chunk_size."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef load_csv_data(resource_name):\n    # type: (str) -> List[str]\n    \"\"\" Loads first column of specified CSV file from package data.\n    \"\"\"\n    data_bytes = pkgutil.get_data('clkhash', 'data/{}'.format(resource_name))\n    if data_bytes is None:\n        raise ValueError(\"No data resource found with name {}\".format(resource_name))\n    else:\n        data = data_bytes.decode('utf8')\n        reader = csv.reader(data.splitlines())\n        next(reader, None)  # skip the headers\n        return [row[0] for row in reader]", "response": "Loads first column of specified CSV file from package data."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsaving data to file as CSV with header.", "response": "def save_csv(data,  # type: Iterable[Tuple[Union[str, int], ...]]\n             headers,  # type: Iterable[str]\n             file  # type: TextIO\n             ):\n    # type: (...) -> None\n    \"\"\"\n    Output generated data to file as CSV with header.\n\n    :param data: An iterable of tuples containing raw data.\n    :param headers: Iterable of feature names\n    :param file: A writeable stream in which to write the CSV\n    \"\"\"\n\n    print(','.join(headers), file=file)\n    writer = csv.writer(file)\n    writer.writerows(data)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngenerating a random datetime between two datetime objects.", "response": "def random_date(start, end):\n    # type: (datetime, datetime) -> datetime\n    \"\"\" Generate a random datetime between two datetime objects.\n\n    :param start: datetime of start\n    :param end: datetime of end\n    :return: random datetime between start and end\n    \"\"\"\n    delta = end - start\n    int_delta = (delta.days * 24 * 60 * 60) + delta.seconds\n    random_second = random.randrange(int_delta)\n    return start + timedelta(seconds=random_second)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngenerating n random person names and birthdates.", "response": "def generate_random_person(self, n):\n        # type: (int) -> Iterable[Tuple[str, str, str, str]]\n        \"\"\"\n        Generator that yields details on a person with plausible name, sex and age.\n\n        :yields: Generated data for one person\n            tuple - (id: int, name: str('First Last'), birthdate: str('DD/MM/YYYY'), sex: str('M' | 'F') )\n        \"\"\"\n        assert self.all_male_first_names is not None\n        assert self.all_female_first_names is not None\n        assert self.all_last_names is not None\n        for i in range(n):\n            sex = 'M' if random.random() > 0.5 else 'F'\n            dob = random_date(self.earliest_birthday, self.latest_birthday).strftime(\"%Y/%m/%d\")\n            first_name = random.choice(self.all_male_first_names) if sex == 'M' else random.choice(\n                self.all_female_first_names)\n            last_name = random.choice(self.all_last_names)\n\n            yield (\n                str(i),\n                first_name + ' ' + last_name,\n                dob,\n                sex\n            )"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef load_names(self):\n        # type: () -> None\n        \"\"\" Loads a name database from package data\n\n        Uses data files sourced from\n        http://www.quietaffiliate.com/free-first-name-and-last-name-databases-csv-and-sql/\n        \"\"\"\n\n        self.all_male_first_names = load_csv_data('male-first-names.csv')\n        self.all_female_first_names = load_csv_data('female-first-names.csv')\n        self.all_last_names = load_csv_data('CSV_Database_of_Last_Names.csv')", "response": "Loads a name database from CSV files sourced from\n        http://www. quietaffiliate. com / free - first - name - and - last - name - databases - csv - and - sql."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ngenerate random subsets with nonempty intersection.", "response": "def generate_subsets(self, sz, overlap=0.8, subsets=2):\n        # type: (int, float, int) -> Tuple[List, ...]\n        \"\"\" Return random subsets with nonempty intersection.\n\n            The random subsets are of specified size. If an element is\n            common to two subsets, then it is common to all subsets.\n            This overlap is controlled by a parameter.\n\n            :param sz: size of subsets to generate\n            :param overlap: size of the intersection, as fraction of the\n                subset length\n            :param subsets: number of subsets to generate\n\n            :raises ValueError: if there aren't sufficiently many names\n                in the list to satisfy the request; more precisely,\n                raises if (1 - subsets) * floor(overlap * sz)\n                              + subsets * sz > len(self.names).\n\n            :return: tuple of subsets\n        \"\"\"\n        overlap_sz = int(math.floor(overlap * sz))\n        unique_sz = sz - overlap_sz  # Unique names per subset\n        total_unique_sz = unique_sz * subsets  # Uniques in all subsets\n        total_sz = overlap_sz + total_unique_sz\n\n        if total_sz > len(self.names):\n            msg = 'insufficient names for requested size and overlap'\n            raise ValueError(msg)\n\n        sset = random.sample(self.names, total_sz)\n\n        # Overlapping subset, pool of unique names\n        sset_overlap, sset_unique = sset[:overlap_sz], sset[overlap_sz:]\n        assert len(sset_unique) == subsets * unique_sz\n\n        # Split pool of unique names into `subsets` chunks\n        uniques = (sset_unique[p * unique_sz: (p + 1) * unique_sz]\n                   for p in range(subsets))\n\n        return tuple(sset_overlap + u for u in uniques)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _unpack_list(example):\n    try:\n        x = example[0]\n        y = example[1]\n        meta = None\n        return x, y, meta\n    except IndexError:\n        raise IndicoError(\n            \"Invalid input data.  Please ensure input data is \"\n            \"formatted as a list of `[data, target]` pairs.\"\n        )", "response": "Unpacks the data from the list of data and target pairs into two lists."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nunpacking the data and target keys from the given example dictionary into two lists.", "response": "def _unpack_dict(example):\n    \"\"\"\n    Input data format standardization\n    \"\"\"\n    try:\n        x = example['data']\n        y = example['target']\n        meta = example.get('metadata', {})\n        return x, y, meta\n    except KeyError:\n        raise IndicoError(\n            \"Invalid input data.  Please ensure input data is \"\n            \"formatted as a list of dicts with `data` and `target` keys. \"\n            \"A `metadata` key may optionally be included.\"\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _unpack_data(data):\n    xs = [None] * len(data)\n    ys = [None] * len(data)\n    metadata = [None] * len(data)\n    for idx, example in enumerate(data):\n        if isinstance(example, (list, tuple)):\n            xs[idx], ys[idx], metadata[idx] = _unpack_list(example)\n        if isinstance(example, dict):\n            xs[idx], ys[idx], metadata[idx] = _unpack_dict(example)\n\n    return xs, ys, metadata", "response": "Break Xs Ys and metadata out into separate lists for basic data preprocessing."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _pack_data(X, Y, metadata):\n    if not any(metadata):\n        # legacy list of list format is acceptable\n        return list(zip(X, Y))\n\n    else:\n        # newer dictionary-based format is required in order to save metadata\n            return [\n                {\n                    'data': x,\n                    'target': y,\n                    'metadata': meta\n                }\n                for x, y, meta in zip(X, Y, metadata)\n            ]", "response": "Packs data into a list of dicts."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef visualize_explanation(explanation, label=None):\n    if not sys.version_info[:2] >= (3, 5):\n      raise IndicoError(\"Python >= 3.5+ is required for explanation visualization\")\n\n    try:\n      from colr import Colr as C\n    except ImportError:\n      raise IndicoError(\"Package colr >= 0.8.1 is required for explanation visualization.\")\n\n    cursor = 0\n    text = explanation['text']\n    for token in explanation.get('token_predictions'):\n        try:\n            class_confidence = token.get('prediction')[label]\n        except KeyError:\n            raise IndicoError(\"Invalid label: {}\".format(label))\n\n        if class_confidence > 0.5:\n            fg_color = (255, 255, 255)\n        else:\n            fg_color = (0, 0, 0)\n        rg_value = 255 - int(class_confidence * 255)\n        token_end = token.get('token').get('end')\n        token_text = text[cursor:token_end]\n        cursor = token_end\n        sys.stdout.write(\n          str(C().b_rgb(\n            rg_value, rg_value, 255\n          ).rgb(\n            fg_color[0], fg_color[1], fg_color[2], token_text\n          ))\n        )\n    sys.stdout.write(\"\\n\")\n    sys.stdout.flush()", "response": "Plots the output of the explain endpoint over a sequence of C objects that can be visualized over a terminal visual."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef vectorize(data, cloud=None, api_key=None, version=None, **kwargs):\n    batch = detect_batch(data)\n    data = data_preprocess(data, batch=batch)\n    url_params = {\"batch\": batch, \"api_key\": api_key, \"version\": version, \"method\": \"vectorize\"}\n    return api_handler(data, cloud=cloud, api=\"custom\", url_params=url_params, **kwargs)", "response": "Vectorize a single sequence of data."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _api_handler(self, *args, **kwargs):\n        keyword_arguments = {}\n        keyword_arguments.update(self.keywords)\n        keyword_arguments.update(kwargs)\n        return api_handler(*args, **keyword_arguments)", "response": "Wrapper around api_handler from indicoio. utils. api to add in stored keyword argument to the JSON body"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef add_data(self, data, cloud=None, batch=False, api_key=None, version=None, **kwargs):\n        if not len(data):\n          raise IndicoError(\"No input data provided.\")\n        batch = isinstance(data[0], (list, tuple, dict))\n\n        # standarize format for preprocessing batch of examples\n        if not batch:\n          data = [data]\n\n        X, Y, metadata = _unpack_data(data)\n        X = data_preprocess(X, batch=True)\n        data = _pack_data(X, Y, metadata)\n\n        # if a single example was passed in, unpack\n        if not batch:\n          data = data[0]\n\n        url_params = {\"batch\": batch, \"api_key\": api_key, \"version\": version, 'method': \"add_data\"}\n        return self._api_handler(data, cloud=cloud, api=\"custom\", url_params=url_params, **kwargs)", "response": "This method is used to add data to the training model."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the current state of the model associated with a given collection.", "response": "def info(self, cloud=None, api_key=None, version=None, **kwargs):\n        \"\"\"\n        Return the current state of the model associated with a given collection\n        \"\"\"\n        url_params = {\"batch\": False, \"api_key\": api_key, \"version\": version, \"method\": \"info\"}\n        return self._api_handler(None, cloud=cloud, api=\"custom\", url_params=url_params, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nblock until the collection s model is completed training", "response": "def wait(self, interval=1, **kwargs):\n        \"\"\"\n        Block until the collection's model is completed training\n        \"\"\"\n        while True:\n            status = self.info(**kwargs).get('status')\n            if status == \"ready\":\n                break\n            if status != \"training\":\n                raise IndicoError(\"Collection status failed with: {0}\".format(status))\n            time.sleep(interval)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef register(self, make_public=False, cloud=None, api_key=None, version=None, **kwargs):\n        kwargs['make_public'] = make_public\n        url_params = {\"batch\": False, \"api_key\": api_key, \"version\": version, \"method\": \"register\"}\n        return self._api_handler(None, cloud=cloud, api=\"custom\", url_params=url_params, **kwargs)", "response": "This method registers a new resource in the collection."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef authorize(self, email, permission_type='read', cloud=None, api_key=None, version=None, **kwargs):\n        kwargs['permission_type'] = permission_type\n        kwargs['email'] = email\n        url_params = {\"batch\": False, \"api_key\": api_key, \"version\": version, \"method\": \"authorize\"}\n        return self._api_handler(None, cloud=cloud, api=\"custom\", url_params=url_params, **kwargs)", "response": "This method allows you to authorize another user to access your model in a read or write capacity."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef deauthorize(self, email, cloud=None, api_key=None, version=None, **kwargs):\n        kwargs['email'] = email\n        url_params = {\"batch\": False, \"api_key\": api_key, \"version\": version, \"method\": \"deauthorize\"}\n        return self._api_handler(None, cloud=cloud, api=\"custom\", url_params=url_params, **kwargs)", "response": "This method allows you to remove another user s access to your collection."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nconvert an error message to a Python error.", "response": "def convert_to_py_error(error_message):\n    \"\"\"\n    Raise specific exceptions for ease of error handling\n    \"\"\"\n    message = error_message.lower()\n    for err_msg, err_type in ERR_MSGS:\n        if err_msg in message:\n            return err_type(error_message)\n    else:\n        return IndicoError(error_message)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ngive an image returns a list of faces found within the image.", "response": "def facial_localization(image, cloud=None, batch=False, api_key=None, version=None, **kwargs):\n    \"\"\"\n    Given an image, returns a list of faces found within the image.\n    For each face, we return a dictionary containing the upper left corner and lower right corner.\n    If crop is True, the cropped face is included in the dictionary.\n    Input should be in a numpy ndarray or a filename.\n\n    Example usage:\n\n    .. code-block:: python\n\n       >>> from indicoio import facial_localization\n       >>> import numpy as np\n       >>> img = np.zeros([image of a face])\n       >>> faces = facial_localization(img)\n       >>> len(faces)\n       1\n\n    :param image: The image to be analyzed.\n    :type image: filepath or ndarray\n    :rtype: List of faces (dict) found.\n    \"\"\"\n    image = data_preprocess(image, batch=batch)\n    url_params = {\"batch\": batch, \"api_key\": api_key, \"version\": version}\n    return api_handler(image, cloud=cloud, api=\"faciallocalization\", url_params=url_params, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef summarization(text, cloud=None, batch=False, api_key=None, version=1, **kwargs):\r\n    url_params = {\"batch\": batch, \"api_key\": api_key, \"version\": version}\r\n    return api_handler(text, cloud=cloud, api=\"summarization\", url_params=url_params, **kwargs)", "response": "Returns a summary of the top N words of a given text."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngenerating a key derivation function from the master_secret and returns the key derivation function and the key material.", "response": "def hkdf(master_secret,  # type: bytes\n         num_keys,  # type: int\n         hash_algo='SHA256',  # type: str\n         salt=None,  # type: Optional[bytes]\n         info=None,  # type: Optional[bytes]\n         key_size=DEFAULT_KEY_SIZE  # type: int\n         ):\n    # type: (...) -> Tuple[bytes, ...]\n    \"\"\"\n    Executes the HKDF key derivation function as described in rfc5869 to\n    derive `num_keys` keys of size `key_size` from the master_secret.\n\n    :param master_secret: input keying material\n    :param num_keys: the number of keys the kdf should produce\n    :param hash_algo: The hash function used by HKDF for the internal\n        HMAC calls. The choice of hash function defines the maximum\n        length of the output key material. Output bytes <= 255 * hash\n        digest size (in bytes).\n    :param salt: HKDF is defined to operate with and without random\n        salt. This is done to accommodate applications where a salt\n        value is not available. We stress, however, that the use of salt\n        adds significantly to themstrength of HKDF, ensuring\n        independence between different uses of the hash function,\n        supporting \"source-independent\" extraction, and strengthening\n        the analytical results that back the HKDF design.\n            Random salt differs fundamentally from the initial keying\n        material in two ways: it is non-secret and can be re-used.\n            Ideally, the salt value is a random (or pseudorandom) string\n        of the length HashLen.  Yet, even a salt value of less quality\n        (shorter in size or with limited entropy) may still make a\n        significant contribution to the security of the output keying\n        material.\n    :param info: While the 'info' value is optional in the definition of\n        HKDF, it is often of great importance in applications. Its main\n        objective is to bind the derived key material to application-\n        and context-specific information. For example, 'info' may\n        contain a protocol number, algorithm identifiers, user\n        identities, etc.  In particular, it may prevent the derivation\n        of the same keying material for different contexts (when the\n        same input key material (IKM) is used in such different\n        contexts).  It may also accommodate additional inputs to the key\n        expansion part, if so desired (e.g., an application may want to\n        bind the key material to its length L, thus making L part of the\n        'info' field).  There is one technical requirement from 'info':\n        it should be independent of the input key material value IKM.\n    :param key_size: the size of the produced keys\n    :return: Derived keys\n    \"\"\"\n    try:\n        hash_function = _HASH_FUNCTIONS[hash_algo]\n    except KeyError:\n        msg = \"unsupported hash function '{}'\".format(hash_algo)\n        raise_from(ValueError(msg), None)\n\n    hkdf = HKDF(algorithm=hash_function(),\n                length=num_keys * key_size,\n                salt=salt,\n                info=info,\n                backend=default_backend())\n    # hkdf.derive returns a block of num_keys * key_size bytes which we\n    # divide up into num_keys chunks, each of size key_size\n    keybytes = hkdf.derive(master_secret)\n    keys = tuple(keybytes[i * key_size:(i + 1) * key_size] for i in range(num_keys))\n    return keys"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngenerates a list of derived key lists for each master secret.", "response": "def generate_key_lists(master_secrets,  # type: Sequence[Union[bytes, str]]\n                       num_identifier,  # type: int\n                       key_size=DEFAULT_KEY_SIZE,  # type: int\n                       salt=None,  # type: Optional[bytes]\n                       info=None,  # type: Optional[bytes]\n                       kdf='HKDF',  # type: str\n                       hash_algo='SHA256'  # type: str\n                       ):\n    # type: (...) -> Tuple[Tuple[bytes, ...], ...]\n    \"\"\"\n    Generates a derived key for each identifier for each master secret using a key derivation function (KDF).\n\n    The only supported key derivation function for now is 'HKDF'.\n\n    The previous key usage can be reproduced by setting kdf to 'legacy'.\n    This is highly discouraged, as this strategy will map the same n-grams in different identifier\n    to the same bits in the Bloom filter and thus does not lead to good results.\n\n    :param master_secrets: a list of master secrets (either as bytes or strings)\n    :param num_identifier: the number of identifiers\n    :param key_size: the size of the derived keys\n    :param salt: salt for the KDF as bytes\n    :param info: optional context and application specific information as bytes\n    :param kdf: the key derivation function algorithm to use\n    :param hash_algo: the hashing algorithm to use (ignored if `kdf` is not 'HKDF')\n    :return: The derived keys.\n             First dimension is of size num_identifier, second dimension is the same as master_secrets.\n             A key is represented as bytes.\n    \"\"\"\n    keys = []\n    try:\n        for key in master_secrets:\n            if isinstance(key, bytes):\n                keys.append(key)\n            else:\n                keys.append(key.encode('UTF-8'))\n    except AttributeError:\n        raise TypeError(\"provided 'master_secrets' have to be either of type bytes or strings.\")\n    if kdf == 'HKDF':\n        key_lists = [hkdf(key, num_identifier,\n                          hash_algo=hash_algo, salt=salt,\n                          info=info, key_size=key_size)\n                     for key in keys]\n        # regroup such that we get a tuple of keys for each identifier\n        return tuple(zip(*key_lists))\n    if kdf == 'legacy':\n        return tuple(tuple(keys) for _ in range(num_identifier))\n    raise ValueError('kdf: \"{}\" is not supported.'.format(kdf))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nvalidate the data row lengths according to the specification in fields.", "response": "def validate_row_lengths(fields,  # type: Sequence[FieldSpec]\n                         data  # type: Sequence[Sequence[str]]\n                         ):\n    # type: (...) -> None\n    \"\"\" Validate the `data` row lengths according to the specification\n        in `fields`.\n\n        :param fields: The `FieldSpec` objects forming the\n            specification.\n        :param data: The rows to check.\n        :raises FormatError: When the number of entries in a row does\n            not match expectation.\n    \"\"\"\n    for i, row in enumerate(data):\n        if len(fields) != len(row):\n            msg = 'Row {} has {} entries when {} are expected.'.format(\n                i, len(row), len(fields))\n            raise FormatError(msg)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nvalidates the data entries according to the specification in .", "response": "def validate_entries(fields,  # type: Sequence[FieldSpec]\n                     data  # type: Sequence[Sequence[str]]\n                     ):\n    # type: (...) -> None\n    \"\"\" Validate the `data` entries according to the specification in\n        `fields`.\n\n        :param fields: The `FieldSpec` objects forming the\n            specification.\n        :param data: The data to validate.\n        :raises EntryError: When an entry is not valid according to its\n            :class:`FieldSpec`.\n    \"\"\"\n    validators = [f.validate for f in fields]\n\n    for i, row in enumerate(data):\n        for entry, v in zip(row, validators):\n            try:\n                v(entry)\n            except InvalidEntryError as e:\n                msg = (\n                    'Invalid entry in row {row_index}, column '\n                    \"'{column_name}'. {original_message}\"\n                ).format(\n                    row_index=i,\n                    column_name=cast(FieldSpec, e.field_spec).identifier,\n                    original_message=e.args[0])\n                e_invalid_entry = EntryError(msg)\n                e_invalid_entry.field_spec = e.field_spec\n                e_invalid_entry.row_index = i\n                raise_from(e_invalid_entry, e)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nvalidate the header of the given fields according to the specification in .", "response": "def validate_header(fields,  # type: Sequence[FieldSpec]\n                    column_names  # type: Sequence[str]\n                    ):\n    # type: (...) -> None\n    \"\"\" Validate the `column_names` according to the specification in\n        `fields`.\n\n        :param fields: The `FieldSpec` objects forming the\n            specification.\n        :param column_names: A sequence of column identifier.\n        :raises FormatError: When the number of columns or the column\n            identifiers don't match the specification.\n    \"\"\"\n    if len(fields) != len(column_names):\n        msg = 'Header has {} columns when {} are expected.'.format(\n            len(column_names), len(fields))\n        raise FormatError(msg)\n\n    for f, column in zip(fields, column_names):\n        if f.identifier != column:\n            msg = \"Column has identifier '{}' when '{}' is expected.\".format(\n                column, f.identifier)\n            raise FormatError(msg)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a dictionary with EMAIL_* settings from EMAIL_URL.", "response": "def config(env=DEFAULT_ENV, default=None):\n    \"\"\"Returns a dictionary with EMAIL_* settings from EMAIL_URL.\"\"\"\n\n    conf = {}\n\n    s = os.environ.get(env, default)\n\n    if s:\n        conf = parse(s)\n\n    return conf"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nparses an email URL and returns a dictionary of configuration variables.", "response": "def parse(url):\n    \"\"\"Parses an email URL.\"\"\"\n\n    conf = {}\n\n    url = urlparse.urlparse(url)\n    qs = urlparse.parse_qs(url.query)\n\n    # Remove query strings\n    path = url.path[1:]\n    path = path.split('?', 2)[0]\n\n    # Update with environment configuration\n    conf.update({\n        'EMAIL_FILE_PATH': path,\n        'EMAIL_HOST_USER': unquote(url.username),\n        'EMAIL_HOST_PASSWORD': unquote(url.password),\n        'EMAIL_HOST': url.hostname,\n        'EMAIL_PORT': url.port,\n        'EMAIL_USE_SSL': False,\n        'EMAIL_USE_TLS': False,\n    })\n\n    if url.scheme in SCHEMES:\n        conf['EMAIL_BACKEND'] = SCHEMES[url.scheme]\n\n    # Set defaults for `smtp`\n    if url.scheme == 'smtp':\n        if not conf['EMAIL_HOST']:\n            conf['EMAIL_HOST'] = 'localhost'\n        if not conf['EMAIL_PORT']:\n            conf['EMAIL_PORT'] = 25\n\n    # Set defaults for `smtps`\n    if url.scheme == 'smtps':\n        warnings.warn(\n            \"`smpts` scheme will be deprecated in a future version,\"\n            \" use `submission` instead\",\n            UserWarning,\n        )\n        conf['EMAIL_USE_TLS'] = True\n\n    # Set defaults for `submission`/`submit`\n    if url.scheme in ('submission', 'submit'):\n        conf['EMAIL_USE_TLS'] = True\n        if not conf['EMAIL_PORT']:\n            conf['EMAIL_PORT'] = 587\n\n    # Query args overwrite defaults\n    if 'ssl' in qs and qs['ssl']:\n        if qs['ssl'][0] in TRUTHY:\n            conf['EMAIL_USE_SSL'] = True\n            conf['EMAIL_USE_TLS'] = False\n    elif 'tls' in qs and qs['tls']:\n        if qs['tls'][0] in TRUTHY:\n            conf['EMAIL_USE_SSL'] = False\n            conf['EMAIL_USE_TLS'] = True\n\n    # From addresses\n    if '_server_email' in qs:\n        conf['SERVER_EMAIL'] = qs['_server_email'][0]\n    if '_default_from_email' in qs:\n        conf['DEFAULT_FROM_EMAIL'] = qs['_default_from_email'][0]\n\n    return conf"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nconverts an expression matrix to a numpy matrix representing the predictor matrix for the regressions.", "response": "def to_tf_matrix(expression_matrix,\n                 gene_names,\n                 tf_names):\n    \"\"\"\n    :param expression_matrix: numpy matrix. Rows are observations and columns are genes.\n    :param gene_names: a list of gene names. Each entry corresponds to the expression_matrix column with same index.\n    :param tf_names: a list of transcription factor names. Should be a subset of gene_names.\n    :return: tuple of:\n             0: A numpy matrix representing the predictor matrix for the regressions.\n             1: The gene names corresponding to the columns in the predictor matrix.\n    \"\"\"\n\n    tuples = [(index, gene) for index, gene in enumerate(gene_names) if gene in tf_names]\n\n    tf_indices = [t[0] for t in tuples]\n    tf_matrix_names = [t[1] for t in tuples]\n\n    return expression_matrix[:, tf_indices], tf_matrix_names"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef fit_model(regressor_type,\n              regressor_kwargs,\n              tf_matrix,\n              target_gene_expression,\n              early_stop_window_length=EARLY_STOP_WINDOW_LENGTH,\n              seed=DEMON_SEED):\n    \"\"\"\n    :param regressor_type: string. Case insensitive.\n    :param regressor_kwargs: a dictionary of key-value pairs that configures the regressor.\n    :param tf_matrix: the predictor matrix (transcription factor matrix) as a numpy array.\n    :param target_gene_expression: the target (y) gene expression to predict in function of the tf_matrix (X).\n    :param early_stop_window_length: window length of the early stopping monitor.\n    :param seed: (optional) random seed for the regressors.\n    :return: a trained regression model.\n    \"\"\"\n    regressor_type = regressor_type.upper()\n\n    assert tf_matrix.shape[0] == len(target_gene_expression)\n\n    def do_sklearn_regression():\n        regressor = SKLEARN_REGRESSOR_FACTORY[regressor_type](random_state=seed, **regressor_kwargs)\n\n        with_early_stopping = is_oob_heuristic_supported(regressor_type, regressor_kwargs)\n\n        if with_early_stopping:\n            regressor.fit(tf_matrix, target_gene_expression, monitor=EarlyStopMonitor(early_stop_window_length))\n        else:\n            regressor.fit(tf_matrix, target_gene_expression)\n\n        return regressor\n\n    if is_sklearn_regressor(regressor_type):\n        return do_sklearn_regression()\n    # elif is_xgboost_regressor(regressor_type):\n    #     raise ValueError('XGB regressor not yet supported')\n    else:\n        raise ValueError('Unsupported regressor type: {0}'.format(regressor_type))", "response": "Fits a single model to the given target gene expression."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef to_feature_importances(regressor_type,\n                           regressor_kwargs,\n                           trained_regressor):\n    \"\"\"\n    Motivation: when the out-of-bag improvement heuristic is used, we cancel the effect of normalization by dividing\n    by the number of trees in the regression ensemble by multiplying again by the number of trees used.\n\n    This enables prioritizing links that were inferred in a regression where lots of\n\n    :param regressor_type: string. Case insensitive.\n    :param regressor_kwargs: a dictionary of key-value pairs that configures the regressor.\n    :param trained_regressor: the trained model from which to extract the feature importances.\n    :return: the feature importances inferred from the trained model.\n    \"\"\"\n\n    if is_oob_heuristic_supported(regressor_type, regressor_kwargs):\n        n_estimators = len(trained_regressor.estimators_)\n\n        denormalized_importances = trained_regressor.feature_importances_ * n_estimators\n\n        return denormalized_importances\n    else:\n        return trained_regressor.feature_importances_", "response": "This function takes the feature importances inferred from the trained model and returns the feature importances inferred from the trained model."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef to_meta_df(trained_regressor,\n               target_gene_name):\n    \"\"\"\n    :param trained_regressor: the trained model from which to extract the meta information.\n    :param target_gene_name: the name of the target gene.\n    :return: a Pandas DataFrame containing side information about the regression.\n    \"\"\"\n    n_estimators = len(trained_regressor.estimators_)\n\n    return pd.DataFrame({'target': [target_gene_name], 'n_estimators': [n_estimators]})", "response": "Returns a Pandas DataFrame containing the meta information about the regression."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a Pandas DataFrame representing inferred regulatory links and their respective cluster names.", "response": "def to_links_df(regressor_type,\n                regressor_kwargs,\n                trained_regressor,\n                tf_matrix_gene_names,\n                target_gene_name):\n    \"\"\"\n    :param regressor_type: string. Case insensitive.\n    :param regressor_kwargs: dict of key-value pairs that configures the regressor.\n    :param trained_regressor: the trained model from which to extract the feature importances.\n    :param tf_matrix_gene_names: the list of names corresponding to the columns of the tf_matrix used to train the model.\n    :param target_gene_name: the name of the target gene.\n    :return: a Pandas DataFrame['TF', 'target', 'importance'] representing inferred regulatory links and their\n             connection strength.\n    \"\"\"\n\n    def pythonic():\n        # feature_importances = trained_regressor.feature_importances_\n        feature_importances = to_feature_importances(regressor_type, regressor_kwargs, trained_regressor)\n\n        links_df = pd.DataFrame({'TF': tf_matrix_gene_names, 'importance': feature_importances})\n        links_df['target'] = target_gene_name\n\n        clean_links_df = links_df[links_df.importance > 0].sort_values(by='importance', ascending=False)\n\n        return clean_links_df[['TF', 'target', 'importance']]\n\n    if is_sklearn_regressor(regressor_type):\n        return pythonic()\n    elif is_xgboost_regressor(regressor_type):\n        raise ValueError('XGB regressor not yet supported')\n    else:\n        raise ValueError('Unsupported regressor type: ' + regressor_type)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef retry(fn, max_retries=10, warning_msg=None, fallback_result=None):\n    nr_retries = 0\n\n    result = fallback_result\n\n    for attempt in range(max_retries):\n        try:\n            result = fn()\n        except Exception as cause:\n            nr_retries += 1\n\n            msg_head = '' if warning_msg is None else repr(warning_msg) + ' '\n            msg_tail = \"Retry ({1}/{2}). Failure caused by {0}.\".format(repr(cause), nr_retries, max_retries)\n\n            logger.warning(msg_head + msg_tail)\n        else:\n            break\n\n    return result", "response": "Retry a function on a node in a node s tree."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef infer_partial_network(regressor_type,\n                          regressor_kwargs,\n                          tf_matrix,\n                          tf_matrix_gene_names,\n                          target_gene_name,\n                          target_gene_expression,\n                          include_meta=False,\n                          early_stop_window_length=EARLY_STOP_WINDOW_LENGTH,\n                          seed=DEMON_SEED):\n    \"\"\"\n    Ties together regressor model training with regulatory links and meta data extraction.\n\n    :param regressor_type: string. Case insensitive.\n    :param regressor_kwargs: dict of key-value pairs that configures the regressor.\n    :param tf_matrix: numpy matrix. The feature matrix X to use for the regression.\n    :param tf_matrix_gene_names: list of transcription factor names corresponding to the columns of the tf_matrix used to\n                                 train the regression model.\n    :param target_gene_name: the name of the target gene to infer the regulatory links for.\n    :param target_gene_expression: the expression profile of the target gene. Numpy array.\n    :param include_meta: whether to also return the meta information DataFrame.\n    :param early_stop_window_length: window length of the early stopping monitor.\n    :param seed: (optional) random seed for the regressors.\n    :return: if include_meta == True, return links_df, meta_df\n\n             link_df: a Pandas DataFrame['TF', 'target', 'importance'] containing inferred regulatory links and their\n             connection strength.\n\n             meta_df: a Pandas DataFrame['target', 'meta', 'value'] containing meta information regarding the trained\n             regression model.\n    \"\"\"\n    def fn():\n        (clean_tf_matrix, clean_tf_matrix_gene_names) = clean(tf_matrix, tf_matrix_gene_names, target_gene_name)\n\n        try:\n            trained_regressor = fit_model(regressor_type, regressor_kwargs, clean_tf_matrix, target_gene_expression,\n                                          early_stop_window_length, seed)\n        except ValueError as e:\n            raise ValueError(\"Regression for target gene {0} failed. Cause {1}.\".format(target_gene_name, repr(e)))\n\n        links_df = to_links_df(regressor_type, regressor_kwargs, trained_regressor, clean_tf_matrix_gene_names,\n                               target_gene_name)\n\n        if include_meta:\n            meta_df = to_meta_df(trained_regressor, target_gene_name)\n\n            return links_df, meta_df\n        else:\n            return links_df\n\n    fallback_result = (None, None) if include_meta else None\n\n    return retry(fn,\n                 fallback_result=fallback_result,\n                 warning_msg='infer_data failed for target {0}'.format(target_gene_name))", "response": "Infer partial network for a set of transcription factors."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the column indices of the target genes in the expression_matrix.", "response": "def target_gene_indices(gene_names,\n                        target_genes):\n    \"\"\"\n    :param gene_names: list of gene names.\n    :param target_genes: either int (the top n), 'all', or a collection (subset of gene_names).\n    :return: the (column) indices of the target genes in the expression_matrix.\n    \"\"\"\n\n    if isinstance(target_genes, list) and len(target_genes) == 0:\n        return []\n\n    if isinstance(target_genes, str) and target_genes.upper() == 'ALL':\n        return list(range(len(gene_names)))\n\n    elif isinstance(target_genes, int):\n        top_n = target_genes\n        assert top_n > 0\n\n        return list(range(min(top_n, len(gene_names))))\n\n    elif isinstance(target_genes, list):\n        if not target_genes:  # target_genes is empty\n            return target_genes\n        elif all(isinstance(target_gene, str) for target_gene in target_genes):\n            return [index for index, gene in enumerate(gene_names) if gene in target_genes]\n        elif all(isinstance(target_gene, int) for target_gene in target_genes):\n            return target_genes\n        else:\n            raise ValueError(\"Mixed types in target genes.\")\n\n    else:\n        raise ValueError(\"Unable to interpret target_genes.\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef create_graph(expression_matrix,\n                 gene_names,\n                 tf_names,\n                 regressor_type,\n                 regressor_kwargs,\n                 client,\n                 target_genes='all',\n                 limit=None,\n                 include_meta=False,\n                 early_stop_window_length=EARLY_STOP_WINDOW_LENGTH,\n                 repartition_multiplier=1,\n                 seed=DEMON_SEED):\n    \"\"\"\n    Main API function. Create a Dask computation graph.\n\n    Note: fixing the GC problems was fixed by 2 changes: [1] and [2] !!!\n\n    :param expression_matrix: numpy matrix. Rows are observations and columns are genes.\n    :param gene_names: list of gene names. Each entry corresponds to the expression_matrix column with same index.\n    :param tf_names: list of transcription factor names. Should have a non-empty intersection with gene_names.\n    :param regressor_type: regressor type. Case insensitive.\n    :param regressor_kwargs: dict of key-value pairs that configures the regressor.\n    :param client: a dask.distributed client instance.\n                   * Used to scatter-broadcast the tf matrix to the workers instead of simply wrapping in a delayed().\n    :param target_genes: either int, 'all' or a collection that is a subset of gene_names.\n    :param limit: optional number of top regulatory links to return. Default None.\n    :param include_meta: Also return the meta DataFrame. Default False.\n    :param early_stop_window_length: window length of the early stopping monitor.\n    :param repartition_multiplier: multiplier\n    :param seed: (optional) random seed for the regressors. Default 666.\n    :return: if include_meta is False, returns a Dask graph that computes the links DataFrame.\n             If include_meta is True, returns a tuple: the links DataFrame and the meta DataFrame.\n    \"\"\"\n\n    assert expression_matrix.shape[1] == len(gene_names)\n    assert client, \"client is required\"\n\n    tf_matrix, tf_matrix_gene_names = to_tf_matrix(expression_matrix, gene_names, tf_names)\n\n    future_tf_matrix = client.scatter(tf_matrix, broadcast=True)\n    # [1] wrap in a list of 1 -> unsure why but Matt. Rocklin does this often...\n    [future_tf_matrix_gene_names] = client.scatter([tf_matrix_gene_names], broadcast=True)\n\n    delayed_link_dfs = []  # collection of delayed link DataFrames\n    delayed_meta_dfs = []  # collection of delayed meta DataFrame\n\n    for target_gene_index in target_gene_indices(gene_names, target_genes):\n        target_gene_name = delayed(gene_names[target_gene_index], pure=True)\n        target_gene_expression = delayed(expression_matrix[:, target_gene_index], pure=True)\n\n        if include_meta:\n            delayed_link_df, delayed_meta_df = delayed(infer_partial_network, pure=True, nout=2)(\n                regressor_type, regressor_kwargs,\n                future_tf_matrix, future_tf_matrix_gene_names,\n                target_gene_name, target_gene_expression, include_meta, early_stop_window_length, seed)\n\n            if delayed_link_df is not None:\n                delayed_link_dfs.append(delayed_link_df)\n                delayed_meta_dfs.append(delayed_meta_df)\n        else:\n            delayed_link_df = delayed(infer_partial_network, pure=True)(\n                regressor_type, regressor_kwargs,\n                future_tf_matrix, future_tf_matrix_gene_names,\n                target_gene_name, target_gene_expression, include_meta, early_stop_window_length, seed)\n\n            if delayed_link_df is not None:\n                delayed_link_dfs.append(delayed_link_df)\n\n    # gather the DataFrames into one distributed DataFrame\n    all_links_df = from_delayed(delayed_link_dfs, meta=_GRN_SCHEMA)\n    all_meta_df = from_delayed(delayed_meta_dfs, meta=_META_SCHEMA)\n\n    # optionally limit the number of resulting regulatory links, descending by top importance\n    if limit:\n        maybe_limited_links_df = all_links_df.nlargest(limit, columns=['importance'])\n    else:\n        maybe_limited_links_df = all_links_df\n\n    # [2] repartition to nr of workers -> important to avoid GC problems!\n    # see: http://dask.pydata.org/en/latest/dataframe-performance.html#repartition-to-reduce-overhead\n    n_parts = len(client.ncores()) * repartition_multiplier\n\n    if include_meta:\n        return maybe_limited_links_df.repartition(npartitions=n_parts), \\\n               all_meta_df.repartition(npartitions=n_parts)\n    else:\n        return maybe_limited_links_df.repartition(npartitions=n_parts)", "response": "This function creates a Dask computation graph for a set of regulatory links."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the low and high boundaries of the estimators window to consider.", "response": "def window_boundaries(self, current_round):\n        \"\"\"\n        :param current_round:\n        :return: the low and high boundaries of the estimators window to consider.\n        \"\"\"\n\n        lo = max(0, current_round - self.window_length + 1)\n        hi = current_round + 1\n\n        return lo, hi"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef generate(self, **options):\n        '''Generates an encrypted URL with the specified options'''\n\n        if options.get('unsafe', False):\n            return unsafe_url(**options)\n        else:\n            return self.generate_new(options)", "response": "Generates an encrypted URL with the specified options"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef checkOnline(self, userId):\n\n        desc = {\n            \"name\": \"CheckOnlineReslut\",\n            \"desc\": \"checkOnlineUser\u8fd4\u56de\u7ed3\u679c\",\n            \"fields\": [{\n                \"name\": \"code\",\n                \"type\": \"Integer\",\n                \"desc\": \"\u8fd4\u56de\u7801\uff0c200 \u4e3a\u6b63\u5e38\u3002\"\n            }, {\n                \"name\": \"status\",\n                \"type\": \"String\",\n                \"desc\": \"\u5728\u7ebf\u72b6\u6001\uff0c1\u4e3a\u5728\u7ebf\uff0c0\u4e3a\u4e0d\u5728\u7ebf\u3002\"\n            }, {\n                \"name\": \"errorMessage\",\n                \"type\": \"String\",\n                \"desc\": \"\u9519\u8bef\u4fe1\u606f\u3002\"\n            }]\n        }\n        r = self.call_api(\n            method=('API', 'POST', 'application/x-www-form-urlencoded'),\n            action='/user/checkOnline.json',\n            params={\"userId\": userId})\n        return Response(r, desc)", "response": "CheckOnline - Check online User"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef addBlacklist(self, userId, blackUserId):\n\n        desc = {\n            \"name\": \"CodeSuccessReslut\",\n            \"desc\": \" http \u6210\u529f\u8fd4\u56de\u7ed3\u679c\",\n            \"fields\": [{\n                \"name\": \"code\",\n                \"type\": \"Integer\",\n                \"desc\": \"\u8fd4\u56de\u7801\uff0c200 \u4e3a\u6b63\u5e38\u3002\"\n            }, {\n                \"name\": \"errorMessage\",\n                \"type\": \"String\",\n                \"desc\": \"\u9519\u8bef\u4fe1\u606f\u3002\"\n            }]\n        }\n        r = self.call_api(\n            method=('API', 'POST', 'application/x-www-form-urlencoded'),\n            action='/user/blacklist/add.json',\n            params={\"userId\": userId,\n                    \"blackUserId\": blackUserId})\n        return Response(r, desc)", "response": "Add a blacklist to a user."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef publishTemplate(self, templateMessage):\n\n        desc = {\n            \"name\": \"CodeSuccessReslut\",\n            \"desc\": \" http \u6210\u529f\u8fd4\u56de\u7ed3\u679c\",\n            \"fields\": [{\n                \"name\": \"code\",\n                \"type\": \"Integer\",\n                \"desc\": \"\u8fd4\u56de\u7801\uff0c200 \u4e3a\u6b63\u5e38\u3002\"\n            }, {\n                \"name\": \"errorMessage\",\n                \"type\": \"String\",\n                \"desc\": \"\u9519\u8bef\u4fe1\u606f\u3002\"\n            }]\n        }\n        r = self.call_api(\n            method=('API', 'POST', 'application/json'),\n            action='/message/private/publish_template.json',\n            params=templateMessage)\n        return Response(r, desc)", "response": "\u53d1\u9001\u5355\u804a\u6a21\u677f\u6d88\u606f\u65b9\u6cd5\uff08\u4e00\u4e2a\u7528\u6237\u5411\u591a\u4e2a\u7528\u6237\u53d1\u9001\u4e0d\u540c\u6d88\u606f\u5185\u5bb9\uff0c\u5355\u6761\u6d88\u606f\u6700\u5927 128k\u3002\u6bcf\u5206\u949f\u6700\u591a\u53d1\u9001 6000 \u6761\u4fe1\u606f\uff0c\u6bcf\u6b21\u53d1\u9001\u7528\u6237\u4e0a\u9650\u4e3a 1000 \u4eba\u3002\uff09 \u65b9\u6cd5\n        @param  templateMessage:\u5355\u804a\u6a21\u7248\u6d88\u606f\u3002\n\t \n        @return code:\u8fd4\u56de\u7801\uff0c200 \u4e3a\u6b63\u5e38\u3002\n        @return errorMessage:\u9519\u8bef\u4fe1\u606f\u3002"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef publishGroup(self,\n                     fromUserId,\n                     toGroupId,\n                     objectName,\n                     content,\n                     pushContent=None,\n                     pushData=None,\n                     isPersisted=None,\n                     isCounted=None,\n                     isIncludeSender=None):\n        \"\"\"\n        \u53d1\u9001\u7fa4\u7ec4\u6d88\u606f\u65b9\u6cd5\uff08\u4ee5\u4e00\u4e2a\u7528\u6237\u8eab\u4efd\u5411\u7fa4\u7ec4\u53d1\u9001\u6d88\u606f\uff0c\u5355\u6761\u6d88\u606f\u6700\u5927 128k.\u6bcf\u79d2\u949f\u6700\u591a\u53d1\u9001 20 \u6761\u6d88\u606f\uff0c\u6bcf\u6b21\u6700\u591a\u5411 3 \u4e2a\u7fa4\u7ec4\u53d1\u9001\uff0c\u5982\uff1a\u4e00\u6b21\u5411 3 \u4e2a\u7fa4\u7ec4\u53d1\u9001\u6d88\u606f\uff0c\u793a\u4e3a 3 \u6761\u6d88\u606f\u3002\uff09 \u65b9\u6cd5\n        @param  fromUserId:\u53d1\u9001\u4eba\u7528\u6237 Id \u3002\uff08\u5fc5\u4f20\uff09\n        @param  toGroupId:\u63a5\u6536\u7fa4Id\uff0c\u63d0\u4f9b\u591a\u4e2a\u672c\u53c2\u6570\u53ef\u4ee5\u5b9e\u73b0\u5411\u591a\u7fa4\u53d1\u9001\u6d88\u606f\uff0c\u6700\u591a\u4e0d\u8d85\u8fc7 3 \u4e2a\u7fa4\u7ec4\u3002\uff08\u5fc5\u4f20\uff09\n        @param  txtMessage:\u53d1\u9001\u6d88\u606f\u5185\u5bb9\uff08\u5fc5\u4f20\uff09\n        @param  pushContent:\u5b9a\u4e49\u663e\u793a\u7684 Push \u5185\u5bb9\uff0c\u5982\u679c objectName \u4e3a\u878d\u4e91\u5185\u7f6e\u6d88\u606f\u7c7b\u578b\u65f6\uff0c\u5219\u53d1\u9001\u540e\u7528\u6237\u4e00\u5b9a\u4f1a\u6536\u5230 Push \u4fe1\u606f. \u5982\u679c\u4e3a\u81ea\u5b9a\u4e49\u6d88\u606f\uff0c\u5219 pushContent \u4e3a\u81ea\u5b9a\u4e49\u6d88\u606f\u663e\u793a\u7684 Push \u5185\u5bb9\uff0c\u5982\u679c\u4e0d\u4f20\u5219\u7528\u6237\u4e0d\u4f1a\u6536\u5230 Push \u901a\u77e5\u3002\uff08\u53ef\u9009\uff09\n        @param  pushData:\u9488\u5bf9 iOS \u5e73\u53f0\u4e3a Push \u901a\u77e5\u65f6\u9644\u52a0\u5230 payload \u4e2d\uff0cAndroid \u5ba2\u6237\u7aef\u6536\u5230\u63a8\u9001\u6d88\u606f\u65f6\u5bf9\u5e94\u5b57\u6bb5\u540d\u4e3a pushData\u3002\uff08\u53ef\u9009\uff09\n        @param  isPersisted:\u5f53\u524d\u7248\u672c\u6709\u65b0\u7684\u81ea\u5b9a\u4e49\u6d88\u606f\uff0c\u800c\u8001\u7248\u672c\u6ca1\u6709\u8be5\u81ea\u5b9a\u4e49\u6d88\u606f\u65f6\uff0c\u8001\u7248\u672c\u5ba2\u6237\u7aef\u6536\u5230\u6d88\u606f\u540e\u662f\u5426\u8fdb\u884c\u5b58\u50a8\uff0c0 \u8868\u793a\u4e3a\u4e0d\u5b58\u50a8\u3001 1 \u8868\u793a\u4e3a\u5b58\u50a8\uff0c\u9ed8\u8ba4\u4e3a 1 \u5b58\u50a8\u6d88\u606f\u3002\uff08\u53ef\u9009\uff09\n        @param  isCounted:\u5f53\u524d\u7248\u672c\u6709\u65b0\u7684\u81ea\u5b9a\u4e49\u6d88\u606f\uff0c\u800c\u8001\u7248\u672c\u6ca1\u6709\u8be5\u81ea\u5b9a\u4e49\u6d88\u606f\u65f6\uff0c\u8001\u7248\u672c\u5ba2\u6237\u7aef\u6536\u5230\u6d88\u606f\u540e\u662f\u5426\u8fdb\u884c\u672a\u8bfb\u6d88\u606f\u8ba1\u6570\uff0c0 \u8868\u793a\u4e3a\u4e0d\u8ba1\u6570\u3001 1 \u8868\u793a\u4e3a\u8ba1\u6570\uff0c\u9ed8\u8ba4\u4e3a 1 \u8ba1\u6570\uff0c\u672a\u8bfb\u6d88\u606f\u6570\u589e\u52a0 1\u3002\uff08\u53ef\u9009\uff09\n        @param  isIncludeSender:\u53d1\u9001\u7528\u6237\u81ea\u5df2\u662f\u5426\u63a5\u6536\u6d88\u606f\uff0c0 \u8868\u793a\u4e3a\u4e0d\u63a5\u6536\uff0c1 \u8868\u793a\u4e3a\u63a5\u6536\uff0c\u9ed8\u8ba4\u4e3a 0 \u4e0d\u63a5\u6536\u3002\uff08\u53ef\u9009\uff09\n\t \n        @return code:\u8fd4\u56de\u7801\uff0c200 \u4e3a\u6b63\u5e38\u3002\n        @return errorMessage:\u9519\u8bef\u4fe1\u606f\u3002\n\t    \"\"\"\n\n        desc = {\n            \"name\": \"CodeSuccessReslut\",\n            \"desc\": \" http \u6210\u529f\u8fd4\u56de\u7ed3\u679c\",\n            \"fields\": [{\n                \"name\": \"code\",\n                \"type\": \"Integer\",\n                \"desc\": \"\u8fd4\u56de\u7801\uff0c200 \u4e3a\u6b63\u5e38\u3002\"\n            }, {\n                \"name\": \"errorMessage\",\n                \"type\": \"String\",\n                \"desc\": \"\u9519\u8bef\u4fe1\u606f\u3002\"\n            }]\n        }\n        r = self.call_api(\n            method=('API', 'POST', 'application/x-www-form-urlencoded'),\n            action='/message/group/publish.json',\n            params={\n                \"fromUserId\": fromUserId,\n                \"toGroupId\": toGroupId,\n                \"objectName\": objectName,\n                \"content\": content,\n                \"pushContent\": pushContent,\n                \"pushData\": pushData,\n                \"isPersisted\": isPersisted,\n                \"isCounted\": isCounted,\n                \"isIncludeSender\": isIncludeSender\n            })\n        return Response(r, desc)", "response": "publishGroup - Publishes a group"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef publishChatroom(self, fromUserId, toChatroomId, objectName, content):\n\n        desc = {\n            \"name\": \"CodeSuccessReslut\",\n            \"desc\": \" http \u6210\u529f\u8fd4\u56de\u7ed3\u679c\",\n            \"fields\": [{\n                \"name\": \"code\",\n                \"type\": \"Integer\",\n                \"desc\": \"\u8fd4\u56de\u7801\uff0c200 \u4e3a\u6b63\u5e38\u3002\"\n            }, {\n                \"name\": \"errorMessage\",\n                \"type\": \"String\",\n                \"desc\": \"\u9519\u8bef\u4fe1\u606f\u3002\"\n            }]\n        }\n        r = self.call_api(\n            method=('API', 'POST', 'application/x-www-form-urlencoded'),\n            action='/message/chatroom/publish.json',\n            params={\n                \"fromUserId\": fromUserId,\n                \"toChatroomId\": toChatroomId,\n                \"objectName\": objectName,\n                \"content\": content\n            })\n        return Response(r, desc)", "response": "\u53d1\u9001\u804a\u5929\u5ba4\u6d88\u606f\u65b9\u6cd5\uff08\u4e00\u4e2a\u7528\u6237\u5411\u804a\u5929\u5ba4\u53d1\u9001\u6d88\u606f\uff0c\u5355\u6761\u6d88\u606f\u6700\u5927 128k\u3002\u6bcf\u79d2\u949f\u9650 100 \u6b21\u3002\uff09 \u65b9\u6cd5\n        @param  fromUserId:\u53d1\u9001\u4eba\u7528\u6237 Id\u3002\uff08\u5fc5\u4f20\uff09\n        @param  toChatroomId:\u63a5\u6536\u804a\u5929\u5ba4Id\uff0c\u63d0\u4f9b\u591a\u4e2a\u672c\u53c2\u6570\u53ef\u4ee5\u5b9e\u73b0\u5411\u591a\u4e2a\u804a\u5929\u5ba4\u53d1\u9001\u6d88\u606f\u3002\uff08\u5fc5\u4f20\uff09\n        @param  txtMessage:\u53d1\u9001\u6d88\u606f\u5185\u5bb9\uff08\u5fc5\u4f20\uff09\n\t \n        @return code:\u8fd4\u56de\u7801\uff0c200 \u4e3a\u6b63\u5e38\u3002\n        @return errorMessage:\u9519\u8bef\u4fe1\u606f\u3002"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef broadcast(self,\n                  fromUserId,\n                  objectName,\n                  content,\n                  pushContent=None,\n                  pushData=None,\n                  os=None):\n        \"\"\"\n        \u53d1\u9001\u5e7f\u64ad\u6d88\u606f\u65b9\u6cd5\uff08\u53d1\u9001\u6d88\u606f\u7ed9\u4e00\u4e2a\u5e94\u7528\u4e0b\u7684\u6240\u6709\u6ce8\u518c\u7528\u6237\uff0c\u5982\u7528\u6237\u672a\u5728\u7ebf\u4f1a\u5bf9\u6ee1\u8db3\u6761\u4ef6\uff08\u7ed1\u5b9a\u624b\u673a\u7ec8\u7aef\uff09\u7684\u7528\u6237\u53d1\u9001 Push \u4fe1\u606f\uff0c\u5355\u6761\u6d88\u606f\u6700\u5927 128k\uff0c\u4f1a\u8bdd\u7c7b\u578b\u4e3a SYSTEM\u3002\u6bcf\u5c0f\u65f6\u53ea\u80fd\u53d1\u9001 1 \u6b21\uff0c\u6bcf\u5929\u6700\u591a\u53d1\u9001 3 \u6b21\u3002\uff09 \u65b9\u6cd5\n        @param  fromUserId:\u53d1\u9001\u4eba\u7528\u6237 Id\u3002\uff08\u5fc5\u4f20\uff09\n        @param  txtMessage:\u6587\u672c\u6d88\u606f\u3002\n        @param  pushContent:\u5b9a\u4e49\u663e\u793a\u7684 Push \u5185\u5bb9\uff0c\u5982\u679c objectName \u4e3a\u878d\u4e91\u5185\u7f6e\u6d88\u606f\u7c7b\u578b\u65f6\uff0c\u5219\u53d1\u9001\u540e\u7528\u6237\u4e00\u5b9a\u4f1a\u6536\u5230 Push \u4fe1\u606f. \u5982\u679c\u4e3a\u81ea\u5b9a\u4e49\u6d88\u606f\uff0c\u5219 pushContent \u4e3a\u81ea\u5b9a\u4e49\u6d88\u606f\u663e\u793a\u7684 Push \u5185\u5bb9\uff0c\u5982\u679c\u4e0d\u4f20\u5219\u7528\u6237\u4e0d\u4f1a\u6536\u5230 Push \u901a\u77e5.\uff08\u53ef\u9009\uff09\n        @param  pushData:\u9488\u5bf9 iOS \u5e73\u53f0\u4e3a Push \u901a\u77e5\u65f6\u9644\u52a0\u5230 payload \u4e2d\uff0cAndroid \u5ba2\u6237\u7aef\u6536\u5230\u63a8\u9001\u6d88\u606f\u65f6\u5bf9\u5e94\u5b57\u6bb5\u540d\u4e3a pushData\u3002\uff08\u53ef\u9009\uff09\n        @param  os:\u9488\u5bf9\u64cd\u4f5c\u7cfb\u7edf\u53d1\u9001 Push\uff0c\u503c\u4e3a iOS \u8868\u793a\u5bf9 iOS \u624b\u673a\u7528\u6237\u53d1\u9001 Push ,\u4e3a Android \u65f6\u8868\u793a\u5bf9 Android \u624b\u673a\u7528\u6237\u53d1\u9001 Push \uff0c\u5982\u5bf9\u6240\u6709\u7528\u6237\u53d1\u9001 Push \u4fe1\u606f\uff0c\u5219\u4e0d\u9700\u8981\u4f20 os \u53c2\u6570\u3002\uff08\u53ef\u9009\uff09\n\t \n        @return code:\u8fd4\u56de\u7801\uff0c200 \u4e3a\u6b63\u5e38\u3002\n        @return errorMessage:\u9519\u8bef\u4fe1\u606f\u3002\n\t    \"\"\"\n\n        desc = {\n            \"name\": \"CodeSuccessReslut\",\n            \"desc\": \" http \u6210\u529f\u8fd4\u56de\u7ed3\u679c\",\n            \"fields\": [{\n                \"name\": \"code\",\n                \"type\": \"Integer\",\n                \"desc\": \"\u8fd4\u56de\u7801\uff0c200 \u4e3a\u6b63\u5e38\u3002\"\n            }, {\n                \"name\": \"errorMessage\",\n                \"type\": \"String\",\n                \"desc\": \"\u9519\u8bef\u4fe1\u606f\u3002\"\n            }]\n        }\n        r = self.call_api(\n            method=('API', 'POST', 'application/x-www-form-urlencoded'),\n            action='/message/broadcast.json',\n            params={\n                \"fromUserId\": fromUserId,\n                \"objectName\": objectName,\n                \"content\": content,\n                \"pushContent\": pushContent,\n                \"pushData\": pushData,\n                \"os\": os\n            })\n        return Response(r, desc)", "response": "broadcasts a message to the push server"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef deleteMessage(self, date):\n\n        desc = {\n            \"name\": \"CodeSuccessReslut\",\n            \"desc\": \" http \u6210\u529f\u8fd4\u56de\u7ed3\u679c\",\n            \"fields\": [{\n                \"name\": \"code\",\n                \"type\": \"Integer\",\n                \"desc\": \"\u8fd4\u56de\u7801\uff0c200 \u4e3a\u6b63\u5e38\u3002\"\n            }, {\n                \"name\": \"errorMessage\",\n                \"type\": \"String\",\n                \"desc\": \"\u9519\u8bef\u4fe1\u606f\u3002\"\n            }]\n        }\n        r = self.call_api(\n            method=('API', 'POST', 'application/x-www-form-urlencoded'),\n            action='/message/history/delete.json',\n            params={\"date\": date})\n        return Response(r, desc)", "response": "Delete a message from the database."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef to_utf8(x):\n    if isinstance(x, basestring): \n        return x.encode('utf-8') if isinstance(x, unicode) else x\n    try:\n        l = iter(x)\n    except TypeError:\n        return x\n    return [to_utf8(i) for i in l]", "response": "Tries to utf - 8 encode x when possible \n\n    returns a list of strings."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nturns a query_string into a Python dictionary with unquoted values", "response": "def _split_url_string(query_string):\n        \"\"\"\n        Turns a `query_string` into a Python dictionary with unquoted values\n        \"\"\"\n        parameters = parse_qs(to_utf8(query_string), keep_blank_values=True)\n        for k, v in parameters.iteritems():\n            parameters[k] = urllib.unquote(v[0])\n        return parameters"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a string that contains the parameters that must be signed.", "response": "def get_normalized_parameters(request):\n        \"\"\"\n        Returns a string that contains the parameters that must be signed.\n        This function is called by SignatureMethod subclass CustomSignatureMethod_HMAC_SHA1\n        \"\"\"\n        # See issues #10 and #12\n        if ('Content-Type' not in request.headers or \\\n            request.headers.get('Content-Type').startswith('application/x-www-form-urlencoded')) \\\n            and not isinstance(request.data, basestring):\n            data_and_params = dict(request.data.items() + request.params.items())\n\n            for key,value in data_and_params.items():\n                request.data_and_params[to_utf8(key)] = to_utf8(value)\n\n        if request.data_and_params.has_key('oauth_signature'):\n            del request.data_and_params['oauth_signature']\n\n        items = []\n        for key, value in request.data_and_params.iteritems():\n            # 1.0a/9.1.1 states that kvp must be sorted by key, then by value,\n            # so we unpack sequence values into multiple items for sorting.\n            if isinstance(value, basestring):\n                items.append((key, value))\n            else:\n                try:\n                    value = list(value)\n                except TypeError, e:\n                    assert 'is not iterable' in str(e)\n                    items.append((key, value))\n                else:\n                    items.extend((key, item) for item in value)\n\n        # Include any query string parameters included in the url\n        query_string = urlparse(request.url)[4]\n        items.extend([(to_utf8(k), to_utf8(v)) for k, v in OAuthHook._split_url_string(query_string).items()])\n        items.sort()\n\n        return urllib.urlencode(items).replace('+', '%20').replace('%7E', '~')"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_normalized_url(url):\n        scheme, netloc, path, params, query, fragment = urlparse(url)\n\n        # Exclude default port numbers.\n        if scheme == 'http' and netloc[-3:] == ':80':\n            netloc = netloc[:-3]\n        elif scheme == 'https' and netloc[-4:] == ':443':\n            netloc = netloc[:-4]\n        if scheme not in ('http', 'https'):\n            raise ValueError(\"Unsupported URL %s (%s).\" % (url, scheme))\n\n        # Normalized URL excludes params, query, and fragment.\n        return urlunparse((scheme, netloc, path, None, None, None))", "response": "Returns a normalized url without params"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef to_url(request):\n        scheme, netloc, path, query, fragment = urlsplit(to_utf8(request.url))\n        query = parse_qs(query)\n\n        for key, value in request.data_and_params.iteritems():\n            query.setdefault(key, []).append(value)\n\n        query = urllib.urlencode(query, True)\n        return urlunsplit((scheme, netloc, path, query, fragment))", "response": "Serialize as a URL for a GET request."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nlaunches arboreto with GRNBoost2.", "response": "def grnboost2(expression_data,\n              gene_names=None,\n              tf_names='all',\n              client_or_address='local',\n              early_stop_window_length=EARLY_STOP_WINDOW_LENGTH,\n              limit=None,\n              seed=None,\n              verbose=False):\n    \"\"\"\n    Launch arboreto with [GRNBoost2] profile.\n\n    :param expression_data: one of:\n           * a pandas DataFrame (rows=observations, columns=genes)\n           * a dense 2D numpy.ndarray\n           * a sparse scipy.sparse.csc_matrix\n    :param gene_names: optional list of gene names (strings). Required when a (dense or sparse) matrix is passed as\n                       'expression_data' instead of a DataFrame.\n    :param tf_names: optional list of transcription factors. If None or 'all', the list of gene_names will be used.\n    :param client_or_address: one of:\n           * None or 'local': a new Client(LocalCluster()) will be used to perform the computation.\n           * string address: a new Client(address) will be used to perform the computation.\n           * a Client instance: the specified Client instance will be used to perform the computation.\n    :param early_stop_window_length: early stop window length. Default 25.\n    :param limit: optional number (int) of top regulatory links to return. Default None.\n    :param seed: optional random seed for the regressors. Default None.\n    :param verbose: print info.\n    :return: a pandas DataFrame['TF', 'target', 'importance'] representing the inferred gene regulatory links.\n    \"\"\"\n\n    return diy(expression_data=expression_data, regressor_type='GBM', regressor_kwargs=SGBM_KWARGS,\n               gene_names=gene_names, tf_names=tf_names, client_or_address=client_or_address,\n               early_stop_window_length=early_stop_window_length, limit=limit, seed=seed, verbose=verbose)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef genie3(expression_data,\n           gene_names=None,\n           tf_names='all',\n           client_or_address='local',\n           limit=None,\n           seed=None,\n           verbose=False):\n    \"\"\"\n    Launch arboreto with [GENIE3] profile.\n\n    :param expression_data: one of:\n           * a pandas DataFrame (rows=observations, columns=genes)\n           * a dense 2D numpy.ndarray\n           * a sparse scipy.sparse.csc_matrix\n    :param gene_names: optional list of gene names (strings). Required when a (dense or sparse) matrix is passed as\n                       'expression_data' instead of a DataFrame.\n    :param tf_names: optional list of transcription factors. If None or 'all', the list of gene_names will be used.\n    :param client_or_address: one of:\n           * None or 'local': a new Client(LocalCluster()) will be used to perform the computation.\n           * string address: a new Client(address) will be used to perform the computation.\n           * a Client instance: the specified Client instance will be used to perform the computation.\n    :param limit: optional number (int) of top regulatory links to return. Default None.\n    :param seed: optional random seed for the regressors. Default None.\n    :param verbose: print info.\n    :return: a pandas DataFrame['TF', 'target', 'importance'] representing the inferred gene regulatory links.\n    \"\"\"\n\n    return diy(expression_data=expression_data, regressor_type='RF', regressor_kwargs=RF_KWARGS,\n               gene_names=gene_names, tf_names=tf_names, client_or_address=client_or_address,\n               limit=limit, seed=seed, verbose=verbose)", "response": "Generate a Gene - E3 regressor for a set of genes."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef diy(expression_data,\n        regressor_type,\n        regressor_kwargs,\n        gene_names=None,\n        tf_names='all',\n        client_or_address='local',\n        early_stop_window_length=EARLY_STOP_WINDOW_LENGTH,\n        limit=None,\n        seed=None,\n        verbose=False):\n    \"\"\"\n    :param expression_data: one of:\n           * a pandas DataFrame (rows=observations, columns=genes)\n           * a dense 2D numpy.ndarray\n           * a sparse scipy.sparse.csc_matrix\n    :param regressor_type: string. One of: 'RF', 'GBM', 'ET'. Case insensitive.\n    :param regressor_kwargs: a dictionary of key-value pairs that configures the regressor.\n    :param gene_names: optional list of gene names (strings). Required when a (dense or sparse) matrix is passed as\n                       'expression_data' instead of a DataFrame.\n    :param tf_names: optional list of transcription factors. If None or 'all', the list of gene_names will be used.\n    :param early_stop_window_length: early stopping window length.\n    :param client_or_address: one of:\n           * None or 'local': a new Client(LocalCluster()) will be used to perform the computation.\n           * string address: a new Client(address) will be used to perform the computation.\n           * a Client instance: the specified Client instance will be used to perform the computation.\n    :param limit: optional number (int) of top regulatory links to return. Default None.\n    :param seed: optional random seed for the regressors. Default 666. Use None for random seed.\n    :param verbose: print info.\n    :return: a pandas DataFrame['TF', 'target', 'importance'] representing the inferred gene regulatory links.\n    \"\"\"\n    if verbose:\n        print('preparing dask client')\n\n    client, shutdown_callback = _prepare_client(client_or_address)\n\n    try:\n        if verbose:\n            print('parsing input')\n\n        expression_matrix, gene_names, tf_names = _prepare_input(expression_data, gene_names, tf_names)\n\n        if verbose:\n            print('creating dask graph')\n\n        graph = create_graph(expression_matrix,\n                             gene_names,\n                             tf_names,\n                             client=client,\n                             regressor_type=regressor_type,\n                             regressor_kwargs=regressor_kwargs,\n                             early_stop_window_length=early_stop_window_length,\n                             limit=limit,\n                             seed=seed)\n\n        if verbose:\n            print('{} partitions'.format(graph.npartitions))\n            print('computing dask graph')\n\n        return client \\\n            .compute(graph, sync=True) \\\n            .sort_values(by='importance', ascending=False)\n\n    finally:\n        shutdown_callback(verbose)\n\n        if verbose:\n            print('finished')", "response": "This function computes the regulatory links for a set of regulatory links in a single cluster."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nprepare a client instance.", "response": "def _prepare_client(client_or_address):\n    \"\"\"\n    :param client_or_address: one of:\n           * None\n           * verbatim: 'local'\n           * string address\n           * a Client instance\n    :return: a tuple: (Client instance, shutdown callback function).\n    :raises: ValueError if no valid client input was provided.\n    \"\"\"\n\n    if client_or_address is None or str(client_or_address).lower() == 'local':\n        local_cluster = LocalCluster(diagnostics_port=None)\n        client = Client(local_cluster)\n\n        def close_client_and_local_cluster(verbose=False):\n            if verbose:\n                print('shutting down client and local cluster')\n\n            client.close()\n            local_cluster.close()\n\n        return client, close_client_and_local_cluster\n\n    elif isinstance(client_or_address, str) and client_or_address.lower() != 'local':\n        client = Client(client_or_address)\n\n        def close_client(verbose=False):\n            if verbose:\n                print('shutting down client')\n\n            client.close()\n\n        return client, close_client\n\n    elif isinstance(client_or_address, Client):\n\n        def close_dummy(verbose=False):\n            if verbose:\n                print('not shutting down client, client was created externally')\n\n            return None\n\n        return client_or_address, close_dummy\n\n    else:\n        raise ValueError(\"Invalid client specified {}\".format(str(client_or_address)))"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nprepares the input for the next iteration of the sequence.", "response": "def _prepare_input(expression_data,\n                   gene_names,\n                   tf_names):\n    \"\"\"\n    Wrangle the inputs into the correct formats.\n\n    :param expression_data: one of:\n                            * a pandas DataFrame (rows=observations, columns=genes)\n                            * a dense 2D numpy.ndarray\n                            * a sparse scipy.sparse.csc_matrix\n    :param gene_names: optional list of gene names (strings).\n                       Required when a (dense or sparse) matrix is passed as 'expression_data' instead of a DataFrame.\n    :param tf_names: optional list of transcription factors. If None or 'all', the list of gene_names will be used.\n    :return: a triple of:\n             1. a np.ndarray or scipy.sparse.csc_matrix\n             2. a list of gene name strings\n             3. a list of transcription factor name strings.\n    \"\"\"\n\n    if isinstance(expression_data, pd.DataFrame):\n        expression_matrix = expression_data.as_matrix()\n        gene_names = list(expression_data.columns)\n    else:\n        expression_matrix = expression_data\n        assert expression_matrix.shape[1] == len(gene_names)\n\n    if tf_names is None:\n        tf_names = gene_names\n    elif tf_names == 'all':\n        tf_names = gene_names\n    else:\n        if len(tf_names) == 0:\n            raise ValueError('Specified tf_names is empty')\n\n        if not set(gene_names).intersection(set(tf_names)):\n            raise ValueError('Intersection of gene_names and tf_names is empty.')\n\n    return expression_matrix, gene_names, tf_names"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nmaking common signature for the current application key.", "response": "def _make_common_signature(self):\n        \"\"\"\u751f\u6210\u901a\u7528\u7b7e\u540d, \u4e00\u822c\u60c5\u51b5\u4e0b\uff0c\u60a8\u4e0d\u9700\u8981\u8c03\u7528\u8be5\u65b9\u6cd5 \u6587\u6863\u8be6\u89c1 http://docs.rongcloud.cn/server.html#_API_\u8c03\u7528\u7b7e\u540d\u89c4\u5219\n        :return: {'app-key':'xxx','nonce':'xxx','timestamp':'xxx','signature':'xxx'}\n        \"\"\"\n        nonce = str(random.random())\n        timestamp = str(int(time.time()) * 1000)\n        signature = hashlib.sha1((self._app_secret + nonce + timestamp).encode(\n            'utf-8')).hexdigest()\n\n        return {\n            \"rc-app-key\": self._app_key,\n            \"rc-nonce\": nonce,\n            \"rc-timestamp\": timestamp,\n            \"rc-signature\": signature\n        }"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _http_call(self, url, method, **kwargs):\n        logging.debug(\"Request[{0}]: {1}\".format(method, url))\n        start_time = datetime.datetime.now()\n\n        logging.debug(\"Header: {0}\".format(kwargs['headers']))\n        logging.debug(\"Params: {0}\".format(kwargs['data']))\n        response = requests.request(method, url, verify=False, **kwargs)\n\n        duration = datetime.datetime.now() - start_time\n        logging.debug(\"Response[{0:d}]: {1}, Duration: {2}.{3}s.\".format(\n            response.status_code, response.reason, duration.seconds,\n            duration.microseconds))\n        return response", "response": "Makes a http call. Logs response information."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef call_api(self,\n                 action,\n                 params=None,\n                 method=('API', 'POST', 'application/x-www-form-urlencoded'),\n                 **kwargs):\n        \"\"\"\n        :param method: methodName\n        :param action: MethodUrl\uff0c\n        :param params: Dictionary,form params for api.\n        :param timeout: (optional) Float describing the timeout of the request.\n        :return:\n        \"\"\"\n        urltype, methodname, content_type = method\n        if urltype == 'SMS':\n            url = self.sms_host\n        else:\n            url = self.api_host\n        if content_type == 'application/json':\n            data = json.dumps(params)\n        else:\n            data = self._filter_params(params)\n        return self._http_call(\n            url=url + action,\n            method=methodname,\n            data=data,\n            headers=self._headers(content_type),\n            **kwargs)", "response": ":param method: methodName\n        :param action: MethodUrl\uff0c\n        :param params: Dictionary,form params for api.\n        :param timeout: (optional) Float describing the timeout of the request.\n        :return:"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncalculates the width and height of a node in url_parts.", "response": "def calculate_width_and_height(url_parts, options):\n    '''Appends width and height information to url'''\n    width = options.get('width', 0)\n    has_width = width\n    height = options.get('height', 0)\n    has_height = height\n\n    flip = options.get('flip', False)\n    flop = options.get('flop', False)\n\n    if flip:\n        width = width * -1\n    if flop:\n        height = height * -1\n\n    if not has_width and not has_height:\n        if flip:\n            width = \"-0\"\n        if flop:\n            height = \"-0\"\n\n    if width or height:\n        url_parts.append('%sx%s' % (width, height))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef url_for(**options):\n    '''Returns the url for the specified options'''\n\n    url_parts = get_url_parts(**options)\n    image_hash = hashlib.md5(b(options['image_url'])).hexdigest()\n    url_parts.append(image_hash)\n\n    return \"/\".join(url_parts)", "response": "Returns the url for the specified options"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsingling notification function in one line. Has only one required parameter kwargs will be passed to GrowlNotifier. notifier. mini", "response": "def mini(description, **kwargs):\n\t\"\"\"Single notification function\n\n\tSimple notification function in one line. Has only one required parameter\n\tand attempts to use reasonable defaults for everything else\n\t:param string description: Notification message\n\t\"\"\"\n\tkwargs['notifierFactory'] = GrowlNotifier\n\tgntp.notifier.mini(description, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef queryUser(self, chatroomId, count, order):\n\n        desc = {\n            \"name\": \"ChatroomUserQueryReslut\",\n            \"desc\": \" chatroomUserQuery \u8fd4\u56de\u7ed3\u679c\",\n            \"fields\": [{\n                \"name\": \"code\",\n                \"type\": \"Integer\",\n                \"desc\": \"\u8fd4\u56de\u7801\uff0c200 \u4e3a\u6b63\u5e38\u3002\"\n            }, {\n                \"name\": \"total\",\n                \"type\": \"Integer\",\n                \"desc\": \"\u804a\u5929\u5ba4\u4e2d\u7528\u6237\u6570\u3002\"\n            }, {\n                \"name\": \"users\",\n                \"type\": \"List<ChatRoomUser>\",\n                \"desc\": \"\u804a\u5929\u5ba4\u6210\u5458\u5217\u8868\u3002\"\n            }, {\n                \"name\": \"errorMessage\",\n                \"type\": \"String\",\n                \"desc\": \"\u9519\u8bef\u4fe1\u606f\u3002\"\n            }]\n        }\n        r = self.call_api(\n            method=('API', 'POST', 'application/x-www-form-urlencoded'),\n            action='/chatroom/user/query.json',\n            params={\"chatroomId\": chatroomId,\n                    \"count\": count,\n                    \"order\": order})\n        return Response(r, desc)", "response": "Query the chatroom for a user."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding a new gag user to the chatroom.", "response": "def addGagUser(self, userId, chatroomId, minute):\n        \"\"\"\n        \u6dfb\u52a0\u7981\u8a00\u804a\u5929\u5ba4\u6210\u5458\u65b9\u6cd5\uff08\u5728 App \u4e2d\u5982\u679c\u4e0d\u60f3\u8ba9\u67d0\u4e00\u7528\u6237\u5728\u804a\u5929\u5ba4\u4e2d\u53d1\u8a00\u65f6\uff0c\u53ef\u5c06\u6b64\u7528\u6237\u5728\u804a\u5929\u5ba4\u4e2d\u7981\u8a00\uff0c\u88ab\u7981\u8a00\u7528\u6237\u53ef\u4ee5\u63a5\u6536\u67e5\u770b\u804a\u5929\u5ba4\u4e2d\u7528\u6237\u804a\u5929\u4fe1\u606f\uff0c\u4f46\u4e0d\u80fd\u53d1\u9001\u6d88\u606f.\uff09 \u65b9\u6cd5\n        @param  userId:\u7528\u6237 Id\u3002\uff08\u5fc5\u4f20\uff09\n        @param  chatroomId:\u804a\u5929\u5ba4 Id\u3002\uff08\u5fc5\u4f20\uff09\n        @param  minute:\u7981\u8a00\u65f6\u957f\uff0c\u4ee5\u5206\u949f\u4e3a\u5355\u4f4d\uff0c\u6700\u5927\u503c\u4e3a43200\u5206\u949f\u3002\uff08\u5fc5\u4f20\uff09\n\t \n        @return code:\u8fd4\u56de\u7801\uff0c200 \u4e3a\u6b63\u5e38\u3002\n        @return errorMessage:\u9519\u8bef\u4fe1\u606f\u3002\n\t    \"\"\"\n\n        desc = {\n            \"name\": \"CodeSuccessReslut\",\n            \"desc\": \" http \u6210\u529f\u8fd4\u56de\u7ed3\u679c\",\n            \"fields\": [{\n                \"name\": \"code\",\n                \"type\": \"Integer\",\n                \"desc\": \"\u8fd4\u56de\u7801\uff0c200 \u4e3a\u6b63\u5e38\u3002\"\n            }, {\n                \"name\": \"errorMessage\",\n                \"type\": \"String\",\n                \"desc\": \"\u9519\u8bef\u4fe1\u606f\u3002\"\n            }]\n        }\n        r = self.call_api(\n            method=('API', 'POST', 'application/x-www-form-urlencoded'),\n            action='/chatroom/user/gag/add.json',\n            params={\n                \"userId\": userId,\n                \"chatroomId\": chatroomId,\n                \"minute\": minute\n            })\n        return Response(r, desc)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef rollbackBlockUser(self, userId, chatroomId):\n\n        desc = {\n            \"name\": \"CodeSuccessReslut\",\n            \"desc\": \" http \u6210\u529f\u8fd4\u56de\u7ed3\u679c\",\n            \"fields\": [{\n                \"name\": \"code\",\n                \"type\": \"Integer\",\n                \"desc\": \"\u8fd4\u56de\u7801\uff0c200 \u4e3a\u6b63\u5e38\u3002\"\n            }, {\n                \"name\": \"errorMessage\",\n                \"type\": \"String\",\n                \"desc\": \"\u9519\u8bef\u4fe1\u606f\u3002\"\n            }]\n        }\n        r = self.call_api(\n            method=('API', 'POST', 'application/x-www-form-urlencoded'),\n            action='/chatroom/user/block/rollback.json',\n            params={\"userId\": userId,\n                    \"chatroomId\": chatroomId})\n        return Response(r, desc)", "response": "This method rollbacks a user from a chatroom to a specific user."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef addPriority(self, objectName):\n\n        desc = {\n            \"name\": \"CodeSuccessReslut\",\n            \"desc\": \" http \u6210\u529f\u8fd4\u56de\u7ed3\u679c\",\n            \"fields\": [{\n                \"name\": \"code\",\n                \"type\": \"Integer\",\n                \"desc\": \"\u8fd4\u56de\u7801\uff0c200 \u4e3a\u6b63\u5e38\u3002\"\n            }, {\n                \"name\": \"errorMessage\",\n                \"type\": \"String\",\n                \"desc\": \"\u9519\u8bef\u4fe1\u606f\u3002\"\n            }]\n        }\n        r = self.call_api(\n            method=('API', 'POST', 'application/x-www-form-urlencoded'),\n            action='/chatroom/message/priority/add.json',\n            params={\"objectName\": objectName})\n        return Response(r, desc)", "response": "add priority to a message"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef setUserPushTag(self, userTag):\n\n        desc = {\n            \"name\": \"CodeSuccessReslut\",\n            \"desc\": \" http \u6210\u529f\u8fd4\u56de\u7ed3\u679c\",\n            \"fields\": [{\n                \"name\": \"code\",\n                \"type\": \"Integer\",\n                \"desc\": \"\u8fd4\u56de\u7801\uff0c200 \u4e3a\u6b63\u5e38\u3002\"\n            }, {\n                \"name\": \"errorMessage\",\n                \"type\": \"String\",\n                \"desc\": \"\u9519\u8bef\u4fe1\u606f\u3002\"\n            }]\n        }\n        r = self.call_api(\n            method=('API', 'POST', 'application/json'),\n            action='/user/tag/set.json',\n            params=userTag)\n        return Response(r, desc)", "response": "Set a push tag."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nbroadcast a push message to the user.", "response": "def broadcastPush(self, pushMessage):\n        \"\"\"\n        \u5e7f\u64ad\u6d88\u606f\u65b9\u6cd5\uff08fromuserid \u548c message\u4e3anull\u5373\u4e3a\u4e0d\u843d\u5730\u7684push\uff09 \u65b9\u6cd5\n        @param  pushMessage:json\u6570\u636e\n\t \n        @return code:\u8fd4\u56de\u7801\uff0c200 \u4e3a\u6b63\u5e38\u3002\n        @return errorMessage:\u9519\u8bef\u4fe1\u606f\u3002\n\t    \"\"\"\n\n        desc = {\n            \"name\": \"CodeSuccessReslut\",\n            \"desc\": \" http \u6210\u529f\u8fd4\u56de\u7ed3\u679c\",\n            \"fields\": [{\n                \"name\": \"code\",\n                \"type\": \"Integer\",\n                \"desc\": \"\u8fd4\u56de\u7801\uff0c200 \u4e3a\u6b63\u5e38\u3002\"\n            }, {\n                \"name\": \"errorMessage\",\n                \"type\": \"String\",\n                \"desc\": \"\u9519\u8bef\u4fe1\u606f\u3002\"\n            }]\n        }\n        r = self.call_api(\n            method=('API', 'POST', 'application/json'),\n            action='/push.json',\n            params=pushMessage)\n        return Response(r, desc)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nloading the transcription factor names from a file.", "response": "def load_tf_names(path):\n    \"\"\"\n    :param path: the path of the transcription factor list file.\n    :return: a list of transcription factor names read from the file.\n    \"\"\"\n\n    with open(path) as file:\n        tfs_in_file = [line.strip() for line in file.readlines()]\n\n    return tfs_in_file"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef refresh(self, groupId, groupName):\n\n        desc = {\n            \"name\": \"CodeSuccessReslut\",\n            \"desc\": \" http \u6210\u529f\u8fd4\u56de\u7ed3\u679c\",\n            \"fields\": [{\n                \"name\": \"code\",\n                \"type\": \"Integer\",\n                \"desc\": \"\u8fd4\u56de\u7801\uff0c200 \u4e3a\u6b63\u5e38\u3002\"\n            }, {\n                \"name\": \"errorMessage\",\n                \"type\": \"String\",\n                \"desc\": \"\u9519\u8bef\u4fe1\u606f\u3002\"\n            }]\n        }\n        r = self.call_api(\n            method=('API', 'POST', 'application/x-www-form-urlencoded'),\n            action='/group/refresh.json',\n            params={\"groupId\": groupId,\n                    \"groupName\": groupName})\n        return Response(r, desc)", "response": "Refreshes the cache for a group."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\njoins a user with another user.", "response": "def join(self, userId, groupId, groupName):\n        \"\"\"\n        \u5c06\u7528\u6237\u52a0\u5165\u6307\u5b9a\u7fa4\u7ec4\uff0c\u7528\u6237\u5c06\u53ef\u4ee5\u6536\u5230\u8be5\u7fa4\u7684\u6d88\u606f\uff0c\u540c\u4e00\u7528\u6237\u6700\u591a\u53ef\u52a0\u5165 500 \u4e2a\u7fa4\uff0c\u6bcf\u4e2a\u7fa4\u6700\u5927\u81f3 3000 \u4eba\u3002 \u65b9\u6cd5\n        @param  userId:\u8981\u52a0\u5165\u7fa4\u7684\u7528\u6237 Id\uff0c\u53ef\u63d0\u4ea4\u591a\u4e2a\uff0c\u6700\u591a\u4e0d\u8d85\u8fc7 1000 \u4e2a\u3002\uff08\u5fc5\u4f20\uff09\n        @param  groupId:\u8981\u52a0\u5165\u7684\u7fa4 Id\u3002\uff08\u5fc5\u4f20\uff09\n        @param  groupName:\u8981\u52a0\u5165\u7684\u7fa4 Id \u5bf9\u5e94\u7684\u540d\u79f0\u3002\uff08\u5fc5\u4f20\uff09\n\t \n        @return code:\u8fd4\u56de\u7801\uff0c200 \u4e3a\u6b63\u5e38\u3002\n        @return errorMessage:\u9519\u8bef\u4fe1\u606f\u3002\n\t    \"\"\"\n\n        desc = {\n            \"name\": \"CodeSuccessReslut\",\n            \"desc\": \" http \u6210\u529f\u8fd4\u56de\u7ed3\u679c\",\n            \"fields\": [{\n                \"name\": \"code\",\n                \"type\": \"Integer\",\n                \"desc\": \"\u8fd4\u56de\u7801\uff0c200 \u4e3a\u6b63\u5e38\u3002\"\n            }, {\n                \"name\": \"errorMessage\",\n                \"type\": \"String\",\n                \"desc\": \"\u9519\u8bef\u4fe1\u606f\u3002\"\n            }]\n        }\n        r = self.call_api(\n            method=('API', 'POST', 'application/x-www-form-urlencoded'),\n            action='/group/join.json',\n            params={\n                \"userId\": userId,\n                \"groupId\": groupId,\n                \"groupName\": groupName\n            })\n        return Response(r, desc)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nquerying the group user.", "response": "def queryUser(self, groupId):\n        \"\"\"\n        \u67e5\u8be2\u7fa4\u6210\u5458\u65b9\u6cd5 \u65b9\u6cd5\n        @param  groupId:\u7fa4\u7ec4Id\u3002\uff08\u5fc5\u4f20\uff09\n\t \n        @return code:\u8fd4\u56de\u7801\uff0c200 \u4e3a\u6b63\u5e38\u3002\n        @return id:\u7fa4\u6210\u5458\u7528\u6237Id\u3002\n        @return users:\u7fa4\u6210\u5458\u5217\u8868\u3002\n\t    \"\"\"\n\n        desc = {\n            \"name\": \"GroupUserQueryReslut\",\n            \"desc\": \"groupUserQuery\u8fd4\u56de\u7ed3\u679c\",\n            \"fields\": [{\n                \"name\": \"code\",\n                \"type\": \"Integer\",\n                \"desc\": \"\u8fd4\u56de\u7801\uff0c200 \u4e3a\u6b63\u5e38\u3002\"\n            }, {\n                \"name\": \"id\",\n                \"type\": \"String\",\n                \"desc\": \"\u7fa4\u6210\u5458\u7528\u6237Id\u3002\"\n            }, {\n                \"name\": \"users\",\n                \"type\": \"List<GroupUser>\",\n                \"desc\": \"\u7fa4\u6210\u5458\u5217\u8868\u3002\"\n            }]\n        }\n        r = self.call_api(\n            method=('API', 'POST', 'application/x-www-form-urlencoded'),\n            action='/group/user/query.json',\n            params={\"groupId\": groupId})\n        return Response(r, desc)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ndismissing a user from a group.", "response": "def dismiss(self, userId, groupId):\n        \"\"\"\n        \u89e3\u6563\u7fa4\u7ec4\u65b9\u6cd5\u3002\uff08\u5c06\u8be5\u7fa4\u89e3\u6563\uff0c\u6240\u6709\u7528\u6237\u90fd\u65e0\u6cd5\u518d\u63a5\u6536\u8be5\u7fa4\u7684\u6d88\u606f\u3002\uff09 \u65b9\u6cd5\n        @param  userId:\u64cd\u4f5c\u89e3\u6563\u7fa4\u7684\u7528\u6237 Id\u3002\uff08\u5fc5\u4f20\uff09\n        @param  groupId:\u8981\u89e3\u6563\u7684\u7fa4 Id\u3002\uff08\u5fc5\u4f20\uff09\n\t \n        @return code:\u8fd4\u56de\u7801\uff0c200 \u4e3a\u6b63\u5e38\u3002\n        @return errorMessage:\u9519\u8bef\u4fe1\u606f\u3002\n\t    \"\"\"\n\n        desc = {\n            \"name\": \"CodeSuccessReslut\",\n            \"desc\": \" http \u6210\u529f\u8fd4\u56de\u7ed3\u679c\",\n            \"fields\": [{\n                \"name\": \"code\",\n                \"type\": \"Integer\",\n                \"desc\": \"\u8fd4\u56de\u7801\uff0c200 \u4e3a\u6b63\u5e38\u3002\"\n            }, {\n                \"name\": \"errorMessage\",\n                \"type\": \"String\",\n                \"desc\": \"\u9519\u8bef\u4fe1\u606f\u3002\"\n            }]\n        }\n        r = self.call_api(\n            method=('API', 'POST', 'application/x-www-form-urlencoded'),\n            action='/group/dismiss.json',\n            params={\"userId\": userId,\n                    \"groupId\": groupId})\n        return Response(r, desc)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nattempts to parse a message as a GNTP message", "response": "def parse_gntp(data, password=None):\n\t\"\"\"Attempt to parse a message as a GNTP message\n\n\t:param string data: Message to be parsed\n\t:param string password: Optional password to be used to verify the message\n\t\"\"\"\n\tdata = gntp.shim.u(data)\n\tmatch = GNTP_INFO_LINE_SHORT.match(data)\n\tif not match:\n\t\traise errors.ParseError('INVALID_GNTP_INFO')\n\tinfo = match.groupdict()\n\tif info['messagetype'] == 'REGISTER':\n\t\treturn GNTPRegister(data, password=password)\n\telif info['messagetype'] == 'NOTIFY':\n\t\treturn GNTPNotice(data, password=password)\n\telif info['messagetype'] == 'SUBSCRIBE':\n\t\treturn GNTPSubscribe(data, password=password)\n\telif info['messagetype'] == '-OK':\n\t\treturn GNTPOK(data)\n\telif info['messagetype'] == '-ERROR':\n\t\treturn GNTPError(data)\n\traise errors.ParseError('INVALID_GNTP_MESSAGE')"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nparse the first line of a GNTP message to get security and other info values", "response": "def _parse_info(self, data):\n\t\t\"\"\"Parse the first line of a GNTP message to get security and other info values\n\n\t\t:param string data: GNTP Message\n\t\t:return dict: Parsed GNTP Info line\n\t\t\"\"\"\n\n\t\tmatch = GNTP_INFO_LINE.match(data)\n\n\t\tif not match:\n\t\t\traise errors.ParseError('ERROR_PARSING_INFO_LINE')\n\n\t\tinfo = match.groupdict()\n\t\tif info['encryptionAlgorithmID'] == 'NONE':\n\t\t\tinfo['encryptionAlgorithmID'] = None\n\n\t\treturn info"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef set_password(self, password, encryptAlgo='MD5'):\n\t\tif not password:\n\t\t\tself.info['encryptionAlgorithmID'] = None\n\t\t\tself.info['keyHashAlgorithm'] = None\n\t\t\treturn\n\n\t\tself.password = gntp.shim.b(password)\n\t\tself.encryptAlgo = encryptAlgo.upper()\n\n\t\tif not self.encryptAlgo in self.hash_algo:\n\t\t\traise errors.UnsupportedError('INVALID HASH \"%s\"' % self.encryptAlgo)\n\n\t\thashfunction = self.hash_algo.get(self.encryptAlgo)\n\n\t\tpassword = password.encode('utf8')\n\t\tseed = time.ctime().encode('utf8')\n\t\tsalt = hashfunction(seed).hexdigest()\n\t\tsaltHash = hashfunction(seed).digest()\n\t\tkeyBasis = password + saltHash\n\t\tkey = hashfunction(keyBasis).digest()\n\t\tkeyHash = hashfunction(key).hexdigest()\n\n\t\tself.info['keyHashAlgorithmID'] = self.encryptAlgo\n\t\tself.info['keyHash'] = keyHash.upper()\n\t\tself.info['salt'] = salt.upper()", "response": "Set a password for a GNTP Message"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _decode_hex(self, value):\n\t\tresult = ''\n\t\tfor i in range(0, len(value), 2):\n\t\t\ttmp = int(value[i:i + 2], 16)\n\t\t\tresult += chr(tmp)\n\t\treturn result", "response": "Helper function to decode hex string to proper hex string"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nvalidates GNTP Message against stored password", "response": "def _validate_password(self, password):\n\t\t\"\"\"Validate GNTP Message against stored password\"\"\"\n\t\tself.password = password\n\t\tif password is None:\n\t\t\traise errors.AuthError('Missing password')\n\t\tkeyHash = self.info.get('keyHash', None)\n\t\tif keyHash is None and self.password is None:\n\t\t\treturn True\n\t\tif keyHash is None:\n\t\t\traise errors.AuthError('Invalid keyHash')\n\t\tif self.password is None:\n\t\t\traise errors.AuthError('Missing password')\n\n\t\tkeyHashAlgorithmID = self.info.get('keyHashAlgorithmID','MD5')\n\n\t\tpassword = self.password.encode('utf8')\n\t\tsaltHash = self._decode_hex(self.info['salt'])\n\n\t\tkeyBasis = password + saltHash\n\t\tself.key = self.hash_algo[keyHashAlgorithmID](keyBasis).digest()\n\t\tkeyHash = self.hash_algo[keyHashAlgorithmID](self.key).hexdigest()\n\n\t\tif not keyHash.upper() == self.info['keyHash'].upper():\n\t\t\traise errors.AuthError('Invalid Hash')\n\t\treturn True"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _format_info(self):\n\t\tinfo = 'GNTP/%s %s' % (\n\t\t\tself.info.get('version'),\n\t\t\tself.info.get('messagetype'),\n\t\t)\n\t\tif self.info.get('encryptionAlgorithmID', None):\n\t\t\tinfo += ' %s:%s' % (\n\t\t\t\tself.info.get('encryptionAlgorithmID'),\n\t\t\t\tself.info.get('ivValue'),\n\t\t\t)\n\t\telse:\n\t\t\tinfo += ' NONE'\n\n\t\tif self.info.get('keyHashAlgorithmID', None):\n\t\t\tinfo += ' %s:%s.%s' % (\n\t\t\t\tself.info.get('keyHashAlgorithmID'),\n\t\t\t\tself.info.get('keyHash'),\n\t\t\t\tself.info.get('salt')\n\t\t\t)\n\n\t\treturn info", "response": "Generate info line for GNTP Message\n\t"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _parse_dict(self, data):\n\t\td = {}\n\t\tfor line in data.split('\\r\\n'):\n\t\t\tmatch = GNTP_HEADER.match(line)\n\t\t\tif not match:\n\t\t\t\tcontinue\n\n\t\t\tkey = match.group(1).strip()\n\t\t\tval = match.group(2).strip()\n\t\t\td[key] = val\n\t\treturn d", "response": "Helper function to parse GNTP headers into a dictionary"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef add_resource(self, data):\n\t\tdata = gntp.shim.b(data)\n\t\tidentifier = hashlib.md5(data).hexdigest()\n\t\tself.resources[identifier] = data\n\t\treturn 'x-growl-resource://%s' % identifier", "response": "Add binary resource to the list of resources"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef decode(self, data, password=None):\n\t\tself.password = password\n\t\tself.raw = gntp.shim.u(data)\n\t\tparts = self.raw.split('\\r\\n\\r\\n')\n\t\tself.info = self._parse_info(self.raw)\n\t\tself.headers = self._parse_dict(parts[0])", "response": "Decode GNTP Message\n\n\t\t:param string data:"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef validate(self):\n\t\t'''Validate required headers and validate notification headers'''\n\t\tfor header in self._requiredHeaders:\n\t\t\tif not self.headers.get(header, False):\n\t\t\t\traise errors.ParseError('Missing Registration Header: ' + header)\n\t\tfor notice in self.notifications:\n\t\t\tfor header in self._requiredNotificationHeaders:\n\t\t\t\tif not notice.get(header, False):\n\t\t\t\t\traise errors.ParseError('Missing Notification Header: ' + header)", "response": "Validate required headers and validate notification headers"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ndecode existing GNTP Registration message", "response": "def decode(self, data, password):\n\t\t\"\"\"Decode existing GNTP Registration message\n\n\t\t:param string data: Message to decode\n\t\t\"\"\"\n\t\tself.raw = gntp.shim.u(data)\n\t\tparts = self.raw.split('\\r\\n\\r\\n')\n\t\tself.info = self._parse_info(self.raw)\n\t\tself._validate_password(password)\n\t\tself.headers = self._parse_dict(parts[0])\n\n\t\tfor i, part in enumerate(parts):\n\t\t\tif i == 0:\n\t\t\t\tcontinue  # Skip Header\n\t\t\tif part.strip() == '':\n\t\t\t\tcontinue\n\t\t\tnotice = self._parse_dict(part)\n\t\t\tif notice.get('Notification-Name', False):\n\t\t\t\tself.notifications.append(notice)\n\t\t\telif notice.get('Identifier', False):\n\t\t\t\tnotice['Data'] = self._decode_binary(part, notice)\n\t\t\t\t#open('register.png','wblol').write(notice['Data'])\n\t\t\t\tself.resources[notice.get('Identifier')] = notice"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nadding new Notification to Registration message self", "response": "def add_notification(self, name, enabled=True):\n\t\t\"\"\"Add new Notification to Registration message\n\n\t\t:param string name: Notification Name\n\t\t:param boolean enabled: Enable this notification by default\n\t\t\"\"\"\n\t\tnotice = {}\n\t\tnotice['Notification-Name'] = name\n\t\tnotice['Notification-Enabled'] = enabled\n\n\t\tself.notifications.append(notice)\n\t\tself.add_header('Notifications-Count', len(self.notifications))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef encode(self):\n\n\t\tbuff = _GNTPBuffer()\n\n\t\tbuff.writeln(self._format_info())\n\n\t\t#Headers\n\t\tfor k, v in self.headers.items():\n\t\t\tbuff.writeheader(k, v)\n\t\tbuff.writeln()\n\n\t\t#Notifications\n\t\tif len(self.notifications) > 0:\n\t\t\tfor notice in self.notifications:\n\t\t\t\tfor k, v in notice.items():\n\t\t\t\t\tbuff.writeheader(k, v)\n\t\t\t\tbuff.writeln()\n\n\t\t#Resources\n\t\tfor resource, data in self.resources.items():\n\t\t\tbuff.writeheader('Identifier', resource)\n\t\t\tbuff.writeheader('Length', len(data))\n\t\t\tbuff.writeln()\n\t\t\tbuff.write(data)\n\t\t\tbuff.writeln()\n\t\t\tbuff.writeln()\n\n\t\treturn buff.getvalue()", "response": "Encode a GNTP Registration Message. Returned as a byte string\n\t"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef getImageCode(self, appKey):\n\n        desc = {\n            \"name\": \"SMSImageCodeReslut\",\n            \"desc\": \" getImageCode \u6210\u529f\u8fd4\u56de\u7ed3\u679c\",\n            \"fields\": [{\n                \"name\": \"code\",\n                \"type\": \"Integer\",\n                \"desc\": \"\u8fd4\u56de\u7801\uff0c200 \u4e3a\u6b63\u5e38\u3002\"\n            }, {\n                \"name\": \"url\",\n                \"type\": \"String\",\n                \"desc\": \"\u8fd4\u56de\u7684\u56fe\u7247\u9a8c\u8bc1\u7801 URL \u5730\u5740\u3002\"\n            }, {\n                \"name\": \"verifyId\",\n                \"type\": \"String\",\n                \"desc\": \"\u8fd4\u56de\u56fe\u7247\u9a8c\u8bc1\u6807\u8bc6 Id\u3002\"\n            }, {\n                \"name\": \"errorMessage\",\n                \"type\": \"String\",\n                \"desc\": \"\u9519\u8bef\u4fe1\u606f\u3002\"\n            }]\n        }\n        r = self.call_api(\n            method=('SMS', 'GET', ''),\n            action='/getImgCode.json',\n            params={\"appKey\": appKey})\n        return Response(r, desc)", "response": "This method returns the SMS Image Code for a given appKey."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef sendCode(self,\n                 mobile,\n                 templateId,\n                 region,\n                 verifyId=None,\n                 verifyCode=None):\n        \"\"\"\n        \u53d1\u9001\u77ed\u4fe1\u9a8c\u8bc1\u7801\u65b9\u6cd5\u3002 \u65b9\u6cd5\n        @param  mobile:\u63a5\u6536\u77ed\u4fe1\u9a8c\u8bc1\u7801\u7684\u76ee\u6807\u624b\u673a\u53f7\uff0c\u6bcf\u5206\u949f\u540c\u4e00\u624b\u673a\u53f7\u53ea\u80fd\u53d1\u9001\u4e00\u6b21\u77ed\u4fe1\u9a8c\u8bc1\u7801\uff0c\u540c\u4e00\u624b\u673a\u53f7 1 \u5c0f\u65f6\u5185\u6700\u591a\u53d1\u9001 3 \u6b21\u3002\uff08\u5fc5\u4f20\uff09\n        @param  templateId:\u77ed\u4fe1\u6a21\u677f Id\uff0c\u5728\u5f00\u53d1\u8005\u540e\u53f0->\u77ed\u4fe1\u670d\u52a1->\u670d\u52a1\u8bbe\u7f6e->\u77ed\u4fe1\u6a21\u7248\u4e2d\u83b7\u53d6\u3002\uff08\u5fc5\u4f20\uff09\n        @param  region:\u624b\u673a\u53f7\u7801\u6240\u5c5e\u56fd\u5bb6\u533a\u53f7\uff0c\u76ee\u524d\u53ea\u652f\u6301\u4e2d\u56fe\u533a\u53f7 86\uff09\n        @param  verifyId:\u56fe\u7247\u9a8c\u8bc1\u6807\u8bc6 Id \uff0c\u5f00\u542f\u56fe\u7247\u9a8c\u8bc1\u529f\u80fd\u540e\u6b64\u53c2\u6570\u5fc5\u4f20\uff0c\u5426\u5219\u53ef\u4ee5\u4e0d\u4f20\u3002\u5728\u83b7\u53d6\u56fe\u7247\u9a8c\u8bc1\u7801\u65b9\u6cd5\u8fd4\u56de\u503c\u4e2d\u83b7\u53d6\u3002\n        @param  verifyCode:\u56fe\u7247\u9a8c\u8bc1\u7801\uff0c\u5f00\u542f\u56fe\u7247\u9a8c\u8bc1\u529f\u80fd\u540e\u6b64\u53c2\u6570\u5fc5\u4f20\uff0c\u5426\u5219\u53ef\u4ee5\u4e0d\u4f20\u3002\n\t \n        @return code:\u8fd4\u56de\u7801\uff0c200 \u4e3a\u6b63\u5e38\u3002\n        @return sessionId:\u77ed\u4fe1\u9a8c\u8bc1\u7801\u552f\u4e00\u6807\u8bc6\u3002\n        @return errorMessage:\u9519\u8bef\u4fe1\u606f\u3002\n\t    \"\"\"\n\n        desc = {\n            \"name\": \"SMSSendCodeReslut\",\n            \"desc\": \" SMSSendCodeReslut \u6210\u529f\u8fd4\u56de\u7ed3\u679c\",\n            \"fields\": [{\n                \"name\": \"code\",\n                \"type\": \"Integer\",\n                \"desc\": \"\u8fd4\u56de\u7801\uff0c200 \u4e3a\u6b63\u5e38\u3002\"\n            }, {\n                \"name\": \"sessionId\",\n                \"type\": \"String\",\n                \"desc\": \"\u77ed\u4fe1\u9a8c\u8bc1\u7801\u552f\u4e00\u6807\u8bc6\u3002\"\n            }, {\n                \"name\": \"errorMessage\",\n                \"type\": \"String\",\n                \"desc\": \"\u9519\u8bef\u4fe1\u606f\u3002\"\n            }]\n        }\n        r = self.call_api(\n            method=('SMS', 'POST', 'application/x-www-form-urlencoded'),\n            action='/sendCode.json',\n            params={\n                \"mobile\": mobile,\n                \"templateId\": templateId,\n                \"region\": region,\n                \"verifyId\": verifyId,\n                \"verifyCode\": verifyCode\n            })\n        return Response(r, desc)", "response": "sendCode - Sends code to a mobile user."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef verifyCode(self, sessionId, code):\n\n        desc = {\n            \"name\": \"SMSVerifyCodeResult\",\n            \"desc\": \" VerifyCode \u8fd4\u56de\u7ed3\u679c\",\n            \"fields\": [{\n                \"name\": \"code\",\n                \"type\": \"Integer\",\n                \"desc\": \"\u8fd4\u56de\u7801\uff0c200 \u4e3a\u6b63\u5e38\u3002\"\n            }, {\n                \"name\": \"success\",\n                \"type\": \"Boolean\",\n                \"desc\": \"true \u9a8c\u8bc1\u6210\u529f\uff0cfalse \u9a8c\u8bc1\u5931\u8d25\u3002\"\n            }, {\n                \"name\": \"errorMessage\",\n                \"type\": \"String\",\n                \"desc\": \"\u9519\u8bef\u4fe1\u606f\u3002\"\n            }]\n        }\n        r = self.call_api(\n            method=('SMS', 'POST', 'application/x-www-form-urlencoded'),\n            action='/verifyCode.json',\n            params={\"sessionId\": sessionId,\n                    \"code\": code})\n        return Response(r, desc)", "response": "This method verify the code of a given session."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nsingle notification function Simple notification function in one line. Has only one required parameter and attempts to use reasonable defaults for everything else :param string description: Notification message .. warning:: For now, only URL callbacks are supported. In the future, the callback argument will also support a function", "response": "def mini(description, applicationName='PythonMini', noteType=\"Message\",\n\t\t\ttitle=\"Mini Message\", applicationIcon=None, hostname='localhost',\n\t\t\tpassword=None, port=23053, sticky=False, priority=None,\n\t\t\tcallback=None, notificationIcon=None, identifier=None,\n\t\t\tnotifierFactory=GrowlNotifier):\n\t\"\"\"Single notification function\n\n\tSimple notification function in one line. Has only one required parameter\n\tand attempts to use reasonable defaults for everything else\n\t:param string description: Notification message\n\n\t.. warning::\n\t\t\tFor now, only URL callbacks are supported. In the future, the\n\t\t\tcallback argument will also support a function\n\t\"\"\"\n\ttry:\n\t\tgrowl = notifierFactory(\n\t\t\tapplicationName=applicationName,\n\t\t\tnotifications=[noteType],\n\t\t\tdefaultNotifications=[noteType],\n\t\t\tapplicationIcon=applicationIcon,\n\t\t\thostname=hostname,\n\t\t\tpassword=password,\n\t\t\tport=port,\n\t\t)\n\t\tresult = growl.register()\n\t\tif result is not True:\n\t\t\treturn result\n\n\t\treturn growl.notify(\n\t\t\tnoteType=noteType,\n\t\t\ttitle=title,\n\t\t\tdescription=description,\n\t\t\ticon=notificationIcon,\n\t\t\tsticky=sticky,\n\t\t\tpriority=priority,\n\t\t\tcallback=callback,\n\t\t\tidentifier=identifier,\n\t\t)\n\texcept Exception:\n\t\t# We want the \"mini\" function to be simple and swallow Exceptions\n\t\t# in order to be less invasive\n\t\tlogger.exception(\"Growl error\")"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef register(self):\n\t\tlogger.info('Sending registration to %s:%s', self.hostname, self.port)\n\t\tregister = gntp.core.GNTPRegister()\n\t\tregister.add_header('Application-Name', self.applicationName)\n\t\tfor notification in self.notifications:\n\t\t\tenabled = notification in self.defaultNotifications\n\t\t\tregister.add_notification(notification, enabled)\n\t\tif self.applicationIcon:\n\t\t\tif self._checkIcon(self.applicationIcon):\n\t\t\t\tregister.add_header('Application-Icon', self.applicationIcon)\n\t\t\telse:\n\t\t\t\tresource = register.add_resource(self.applicationIcon)\n\t\t\t\tregister.add_header('Application-Icon', resource)\n\t\tif self.password:\n\t\t\tregister.set_password(self.password, self.passwordHash)\n\t\tself.add_origin_info(register)\n\t\tself.register_hook(register)\n\t\treturn self._send('register', register)", "response": "Send GNTP Registration to Growl"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef notify(self, noteType, title, description, icon=None, sticky=False,\n\t\t\tpriority=None, callback=None, identifier=None, custom={}):\n\t\t\"\"\"Send a GNTP notifications\n\n\t\t.. warning::\n\t\t\tMust have registered with growl beforehand or messages will be ignored\n\n\t\t:param string noteType: One of the notification names registered earlier\n\t\t:param string title: Notification title (usually displayed on the notification)\n\t\t:param string description: The main content of the notification\n\t\t:param string icon: Icon URL path\n\t\t:param boolean sticky: Sticky notification\n\t\t:param integer priority: Message priority level from -2 to 2\n\t\t:param string callback:  URL callback\n\t\t:param dict custom: Custom attributes. Key names should be prefixed with X-\n\t\t\taccording to the spec but this is not enforced by this class\n\n\t\t.. warning::\n\t\t\tFor now, only URL callbacks are supported. In the future, the\n\t\t\tcallback argument will also support a function\n\t\t\"\"\"\n\t\tlogger.info('Sending notification [%s] to %s:%s', noteType, self.hostname, self.port)\n\t\tassert noteType in self.notifications\n\t\tnotice = gntp.core.GNTPNotice()\n\t\tnotice.add_header('Application-Name', self.applicationName)\n\t\tnotice.add_header('Notification-Name', noteType)\n\t\tnotice.add_header('Notification-Title', title)\n\t\tif self.password:\n\t\t\tnotice.set_password(self.password, self.passwordHash)\n\t\tif sticky:\n\t\t\tnotice.add_header('Notification-Sticky', sticky)\n\t\tif priority:\n\t\t\tnotice.add_header('Notification-Priority', priority)\n\t\tif icon:\n\t\t\tif self._checkIcon(icon):\n\t\t\t\tnotice.add_header('Notification-Icon', icon)\n\t\t\telse:\n\t\t\t\tresource = notice.add_resource(icon)\n\t\t\t\tnotice.add_header('Notification-Icon', resource)\n\n\t\tif description:\n\t\t\tnotice.add_header('Notification-Text', description)\n\t\tif callback:\n\t\t\tnotice.add_header('Notification-Callback-Target', callback)\n\t\tif identifier:\n\t\t\tnotice.add_header('Notification-Coalescing-ID', identifier)\n\n\t\tfor key in custom:\n\t\t\tnotice.add_header(key, custom[key])\n\n\t\tself.add_origin_info(notice)\n\t\tself.notify_hook(notice)\n\n\t\treturn self._send('notify', notice)", "response": "Send a GNTP notification to the GNTP server."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nsend a Subscribe request to a remote machine", "response": "def subscribe(self, id, name, port):\n\t\t\"\"\"Send a Subscribe request to a remote machine\"\"\"\n\t\tsub = gntp.core.GNTPSubscribe()\n\t\tsub.add_header('Subscriber-ID', id)\n\t\tsub.add_header('Subscriber-Name', name)\n\t\tsub.add_header('Subscriber-Port', port)\n\t\tif self.password:\n\t\t\tsub.set_password(self.password, self.passwordHash)\n\n\t\tself.add_origin_info(sub)\n\t\tself.subscribe_hook(sub)\n\n\t\treturn self._send('subscribe', sub)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nadds optional Origin headers to message", "response": "def add_origin_info(self, packet):\n\t\t\"\"\"Add optional Origin headers to message\"\"\"\n\t\tpacket.add_header('Origin-Machine-Name', platform.node())\n\t\tpacket.add_header('Origin-Software-Name', 'gntp.py')\n\t\tpacket.add_header('Origin-Software-Version', __version__)\n\t\tpacket.add_header('Origin-Platform-Name', platform.system())\n\t\tpacket.add_header('Origin-Platform-Version', platform.platform())"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsends the GNTP Packet", "response": "def _send(self, messagetype, packet):\n\t\t\"\"\"Send the GNTP Packet\"\"\"\n\n\t\tpacket.validate()\n\t\tdata = packet.encode()\n\n\t\tlogger.debug('To : %s:%s <%s>\\n%s', self.hostname, self.port, packet.__class__, data)\n\n\t\ts = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\t\ts.settimeout(self.socketTimeout)\n\t\ttry:\n\t\t\ts.connect((self.hostname, self.port))\n\t\t\ts.send(data)\n\t\t\trecv_data = s.recv(1024)\n\t\t\twhile not recv_data.endswith(gntp.shim.b(\"\\r\\n\\r\\n\")):\n\t\t\t\trecv_data += s.recv(1024)\n\t\texcept socket.error:\n\t\t\t# Python2.5 and Python3 compatibile exception\n\t\t\texc = sys.exc_info()[1]\n\t\t\traise errors.NetworkError(exc)\n\n\t\tresponse = gntp.core.parse_gntp(recv_data)\n\t\ts.close()\n\n\t\tlogger.debug('From : %s:%s <%s>\\n%s', self.hostname, self.port, response.__class__, response)\n\n\t\tif type(response) == gntp.core.GNTPOK:\n\t\t\treturn True\n\t\tlogger.error('Invalid response: %s', response.error())\n\t\treturn response.error()"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef add(self, word):\n\n        desc = {\n            \"name\": \"CodeSuccessReslut\",\n            \"desc\": \" http \u6210\u529f\u8fd4\u56de\u7ed3\u679c\",\n            \"fields\": [{\n                \"name\": \"code\",\n                \"type\": \"Integer\",\n                \"desc\": \"\u8fd4\u56de\u7801\uff0c200 \u4e3a\u6b63\u5e38\u3002\"\n            }, {\n                \"name\": \"errorMessage\",\n                \"type\": \"String\",\n                \"desc\": \"\u9519\u8bef\u4fe1\u606f\u3002\"\n            }]\n        }\n        r = self.call_api(\n            method=('API', 'POST', 'application/x-www-form-urlencoded'),\n            action='/wordfilter/add.json',\n            params={\"word\": word})\n        return Response(r, desc)", "response": "Add a new word to the list of words."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef getList(self):\n\n        desc = {\n            \"name\": \"ListWordfilterReslut\",\n            \"desc\": \"listWordfilter\u8fd4\u56de\u7ed3\u679c\",\n            \"fields\": [{\n                \"name\": \"code\",\n                \"type\": \"Integer\",\n                \"desc\": \"\u8fd4\u56de\u7801\uff0c200 \u4e3a\u6b63\u5e38\u3002\"\n            }, {\n                \"name\": \"word\",\n                \"type\": \"String\",\n                \"desc\": \"\u654f\u611f\u8bcd\u5185\u5bb9\u3002\"\n            }, {\n                \"name\": \"errorMessage\",\n                \"type\": \"String\",\n                \"desc\": \"\u9519\u8bef\u4fe1\u606f\u3002\"\n            }]\n        }\n        r = self.call_api(\n            method=('API', 'POST', 'application/x-www-form-urlencoded'),\n            action='/wordfilter/list.json',\n            params={})\n        return Response(r, desc)", "response": "Get list of words."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef local_path(force_download=False):\n    return cache.fetch(\n        filename=ALLELE_XML_FILENAME,\n        url=ALLELE_XML_URL,\n        decompress=ALLELE_XML_DECOMPRESS,\n        force=force_download)", "response": "Downloads allele database from IEDB returns local path to XML file."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef delete():\n    path = cache.local_path(\n        filename=ALLELE_XML_FILENAME,\n        url=ALLELE_XML_URL,\n        decompress=ALLELE_XML_DECOMPRESS)\n    os.remove(path)", "response": "Deletes the local XML file"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef load_alleles():\n    result = []\n    path = local_path()\n    etree = xml.etree.ElementTree.parse(path)\n    for allele in etree.iterfind(\"MhcAlleleName\"):\n        name_element = allele.find(\"DisplayedRestriction\")\n        mhc_class_element = allele.find(\"Class\")\n        # need at least a name and an HLA class\n        if name_element is None or mhc_class_element is None:\n            continue\n        name = name_element.text\n\n        synonyms = set([])\n        for synonym_element in allele.iterfind(\"Synonyms\"):\n            for synonym in synonym_element.text.split(\",\"):\n                synonyms.add(synonym.strip())\n        mhc_class = mhc_class_element.text\n        organism_element = allele.find(\"Organsim\")\n        if organism_element is None:\n            organism = None\n        else:\n            organism = organism_element.text\n\n        locus_element = allele.find(\"Locus\")\n\n        if locus_element is None:\n            locus = None\n        else:\n            locus = locus_element.text\n\n        allele_object = Allele(\n            name=name,\n            mhc_class=mhc_class,\n            locus=locus,\n            organism=organism,\n            synonyms=synonyms)\n        result.append(allele_object)\n    return result", "response": "Parses the IEDB MhcAlleleName XML file and returns a list of Allele objects containing information about that each allele s HLA\n    class and source organism."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef load_alleles_dict():\n    alleles = load_alleles()\n    result = {}\n    for allele in alleles:\n        for name in {allele.name}.union(allele.synonyms):\n            result[name] = allele\n    return result", "response": "Create a dictionary mapping each unique allele name to a namedtuple\n    containing information about that alleles class locus species and &c.\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreads the PMBEC coefficient matrix from a file.", "response": "def read_pmbec_coefficients(\n        key_type='row',\n        verbose=True,\n        filename=join(MATRIX_DIR, 'pmbec.mat')):\n    \"\"\"\n    Parameters\n    ------------\n\n    filename : str\n        Location of PMBEC coefficient matrix\n\n    key_type : str\n        'row' : every key is a single amino acid,\n           which maps to a dictionary for that row\n        'pair' : every key is a tuple of amino acids\n        'pair_string' : every key is a string of two amino acid characters\n\n    verbose : bool\n        Print rows of matrix as we read them\n    \"\"\"\n    d = {}\n    if key_type == 'row':\n        def add_pair(row_letter, col_letter, value):\n            if row_letter not in d:\n                d[row_letter] = {}\n            d[row_letter][col_letter] = value\n    elif key_type == 'pair':\n        def add_pair(row_letter, col_letter, value):\n            d[(row_letter, col_letter)] = value\n\n    else:\n        assert key_type == 'pair_string', \\\n            \"Invalid dictionary key type: %s\" % key_type\n\n        def add_pair(row_letter, col_letter, value):\n            d[\"%s%s\" % (row_letter, col_letter)] = value\n\n    with open(filename, 'r') as f:\n        lines = [line for line in f.read().split('\\n') if len(line) > 0]\n        header = lines[0]\n        if verbose:\n            print(header)\n        residues = [\n            x for x in header.split()\n            if len(x) == 1 and x != ' ' and x != '\\t'\n        ]\n        assert len(residues) == 20\n        if verbose:\n            print(residues)\n        for line in lines[1:]:\n            cols = [\n                x\n                for x in line.split(' ')\n                if len(x) > 0 and x != ' ' and x != '\\t'\n            ]\n            assert len(cols) == 21, \"Expected 20 values + letter, got %s\" % cols\n            row_letter = cols[0]\n            for i, col in enumerate(cols[1:]):\n                col_letter = residues[i]\n                assert col_letter != ' ' and col_letter != '\\t'\n                value = float(col)\n                add_pair(row_letter, col_letter, value)\n    return d"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\nasync def async_run_command(self, command, retry=False):\n        if not self.is_connected:\n            await self.async_connect()\n        try:\n            result = await asyncio.wait_for(self._client.run(\n                \"%s && %s\" % (_PATH_EXPORT_COMMAND, command)), 9)\n        except asyncssh.misc.ChannelOpenError:\n            if not retry:\n                await self.async_connect()\n                return self.async_run_command(command, retry=True)\n            else:\n                self._connected = False\n                _LOGGER.error(\"No connection to host\")\n                return []\n        except TimeoutError:\n            del self._client\n            self._connected = False\n            _LOGGER.error(\"Host timeout.\")\n            return []\n\n        self._connected = True\n        return result.stdout.split('\\n')", "response": "Run commands through an SSH connection."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\nasync def async_connect(self):\n\n        kwargs = {\n            'username': self._username if self._username else None,\n            'client_keys': [self._ssh_key] if self._ssh_key else None,\n            'port': self._port,\n            'password': self._password if self._password else None,\n            'known_hosts': None\n        }\n\n        self._client = await asyncssh.connect(self._host, **kwargs)\n        self._connected = True", "response": "Fetches the client or creates a new one."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\nasync def async_run_command(self, command, first_try=True):\n        await self.async_connect()\n        try:\n            with (await self._io_lock):\n                self._writer.write('{}\\n'.format(\n                    \"%s && %s\" % (\n                        _PATH_EXPORT_COMMAND, command)).encode('ascii'))\n                data = ((await asyncio.wait_for(self._reader.readuntil(\n                    self._prompt_string), 9)).split(b'\\n')[1:-1])\n\n        except (BrokenPipeError, LimitOverrunError):\n            if first_try:\n                return await self.async_run_command(command, False)\n            else:\n                _LOGGER.warning(\"connection is lost to host.\")\n                return[]\n        except TimeoutError:\n            _LOGGER.error(\"Host timeout.\")\n            return []\n        finally:\n            self._writer.close()\n\n        return [line.decode('utf-8') for line in data]", "response": "Run a command through a Telnet connection."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\nasync def async_connect(self):\n        self._reader, self._writer = await asyncio.open_connection(\n            self._host, self._port)\n\n        with (await self._io_lock):\n            try:\n                await asyncio.wait_for(self._reader.readuntil(b'login: '), 9)\n            except asyncio.streams.IncompleteReadError:\n                _LOGGER.error(\n                    \"Unable to read from router on %s:%s\" % (\n                        self._host, self._port))\n                return\n            except TimeoutError:\n                _LOGGER.error(\"Host timeout.\")\n            self._writer.write((self._username + '\\n').encode('ascii'))\n            await self._reader.readuntil(b'Password: ')\n\n            self._writer.write((self._password + '\\n').encode('ascii'))\n\n            self._prompt_string = (await self._reader.readuntil(\n                b'#')).split(b'\\n')[-1]\n        self._connected = True", "response": "Connect to the ASUS - WDT Telnet server."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nparse the lines using the given regular expression.", "response": "async def _parse_lines(lines, regex):\n    \"\"\"Parse the lines using the given regular expression.\n\n    If a line can't be parsed it is logged and skipped in the output.\n    \"\"\"\n    results = []\n    if inspect.iscoroutinefunction(lines):\n        lines = await lines\n    for line in lines:\n        if line:\n            match = regex.search(line)\n            if not match:\n                _LOGGER.debug(\"Could not parse row: %s\", line)\n                continue\n            results.append(match.groupdict())\n    return results"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nretrieves data from ASUSWRT.", "response": "async def async_get_connected_devices(self):\n        \"\"\"Retrieve data from ASUSWRT.\n\n        Calls various commands on the router and returns the superset of all\n        responses. Some commands will not work on some routers.\n        \"\"\"\n        devices = {}\n        dev = await self.async_get_wl()\n        devices.update(dev)\n        dev = await self.async_get_arp()\n        devices.update(dev)\n        dev = await self.async_get_neigh(devices)\n        devices.update(dev)\n        if not self.mode == 'ap':\n            dev = await self.async_get_leases(devices)\n            devices.update(dev)\n\n        ret_devices = {}\n        for key in devices:\n            if not self.require_ip or devices[key].ip is not None:\n                ret_devices[key] = devices[key]\n        return ret_devices"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nretrieve total bytes from ASUSWRT.", "response": "async def async_get_bytes_total(self, use_cache=True):\n        \"\"\"Retrieve total bytes (rx an tx) from ASUSWRT.\"\"\"\n        now = datetime.utcnow()\n        if use_cache and self._trans_cache_timer and self._cache_time > \\\n                (now - self._trans_cache_timer).total_seconds():\n            return self._transfer_rates_cache\n\n        rx = await self.async_get_rx()\n        tx = await self.async_get_tx()\n        return rx, tx"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\nasync def async_get_current_transfer_rates(self, use_cache=True):\n        now = datetime.utcnow()\n        data = await self.async_get_bytes_total(use_cache)\n        if self._rx_latest is None or self._tx_latest is None:\n            self._latest_transfer_check = now\n            self._rx_latest = data[0]\n            self._tx_latest = data[1]\n            return self._latest_transfer_data\n\n        time_diff = now - self._latest_transfer_check\n        if time_diff.total_seconds() < 30:\n            return self._latest_transfer_data\n\n        if data[0] < self._rx_latest:\n            rx = data[0]\n        else:\n            rx = data[0] - self._rx_latest\n        if data[1] < self._tx_latest:\n            tx = data[1]\n        else:\n            tx = data[1] - self._tx_latest\n        self._latest_transfer_check = now\n\n        self._rx_latest = data[0]\n        self._tx_latest = data[1]\n\n        self._latest_transfer_data = (\n            math.ceil(rx / time_diff.total_seconds()) if rx > 0 else 0,\n            math.ceil(tx / time_diff.total_seconds()) if tx > 0 else 0)\n        return self._latest_transfer_data", "response": "Gets current transfer rates calculated in per second in bytes."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\nasync def async_current_transfer_human_readable(\n            self, use_cache=True):\n        \"\"\"Gets current transfer rates in a human readable format.\"\"\"\n        rx, tx = await self.async_get_current_transfer_rates(use_cache)\n\n        return \"%s/s\" % convert_size(rx), \"%s/s\" % convert_size(tx)", "response": "Gets current transfer rates in a human readable format."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef load_dataframe(\n        mhc_class=None,  # 1, 2, or None for neither\n        hla=None,\n        exclude_hla=None,\n        human_only=False,\n        peptide_length=None,\n        assay_method=None,\n        assay_group=None,\n        only_standard_amino_acids=True,\n        reduced_alphabet=None,  # 20 letter AA strings -> simpler alphabet\n        nrows=None):\n    \"\"\"\n    Load IEDB T-cell data without aggregating multiple entries for same epitope\n\n    Parameters\n    ----------\n    mhc_class: {None, 1, 2}\n        Restrict to MHC Class I or Class II (or None for neither)\n\n    hla: regex pattern, optional\n        Restrict results to specific HLA type used in assay\n\n    exclude_hla: regex pattern, optional\n        Exclude certain HLA types\n\n    human_only: bool\n        Restrict to human samples (default False)\n\n    peptide_length: int, optional\n        Restrict epitopes to amino acid strings of given length\n\n    assay_method string, optional\n        Only collect results with assay methods containing the given string\n\n    assay_group: string, optional\n        Only collect results with assay groups containing the given string\n\n    only_standard_amino_acids : bool, optional\n        Drop sequences which use non-standard amino acids, anything outside\n        the core 20, such as X or U (default = True)\n\n    reduced_alphabet: dictionary, optional\n        Remap amino acid letters to some other alphabet\n\n    nrows: int, optional\n        Don't load the full IEDB dataset but instead read only the first nrows\n    \"\"\"\n    path = local_path()\n    df = pd.read_csv(\n            path,\n            header=[0, 1],\n            skipinitialspace=True,\n            nrows=nrows,\n            low_memory=False,\n            error_bad_lines=False,\n            encoding=\"latin-1\")\n\n    print(df.head())\n\n    # Sometimes the IEDB seems to put in an extra comma in the\n    # header line, which creates an unnamed column of NaNs.\n    # To deal with this, drop any columns which are all NaN\n    df = df.dropna(axis=1, how=\"all\")\n\n    n = len(df)\n    epitope_column_key = (\"Epitope\", \"Description\")\n    mhc_allele_column_key = (\"MHC\", \"Allele Name\")\n    assay_group_column_key = (\"Assay\", \"Assay Group\")\n    assay_method_column_key = (\"Assay\", \"Method/Technique\")\n\n    epitopes = df[epitope_column_key].str.upper()\n\n    null_epitope_seq = epitopes.isnull()\n    n_null = null_epitope_seq.sum()\n\n    if n_null > 0:\n        logging.info(\"Dropping %d null sequences\", n_null)\n\n    mask = ~null_epitope_seq\n\n    if only_standard_amino_acids:\n        # if have rare or unknown amino acids, drop the sequence\n        bad_epitope_seq = \\\n            epitopes.str.contains(bad_amino_acids, na=False).astype(\"bool\")\n        n_bad = bad_epitope_seq.sum()\n        if n_bad > 0:\n            logging.info(\"Dropping %d bad sequences\", n_bad)\n\n        mask &= ~bad_epitope_seq\n\n    if human_only:\n        organism = df['Host Organism Name']\n        mask &= organism.str.startswith('Homo sapiens', na=False).astype('bool')\n\n    # Match known alleles such as \"HLA-A*02:01\",\n    # broader groupings such as \"HLA-A2\"\n    # and unknown alleles of the MHC-1 listed either as\n    #  \"HLA-Class I,allele undetermined\"\n    #  or\n    #  \"Class I,allele undetermined\"\n    mhc = df[mhc_allele_column_key]\n\n    if mhc_class is not None:\n        # since MHC classes can be specified as either strings (\"I\") or integers\n        # standard them to be strings\n        if mhc_class == 1:\n            mhc_class = \"I\"\n        elif mhc_class == 2:\n            mhc_class = \"II\"\n        if mhc_class not in {\"I\", \"II\"}:\n            raise ValueError(\"Invalid MHC class: %s\" % mhc_class)\n        allele_dict = load_alleles_dict()\n        mhc_class_mask = [False] * len(df)\n        for i, allele_name in enumerate(mhc):\n            allele_object = allele_dict.get(allele_name)\n            if allele_object and allele_object.mhc_class == mhc_class:\n                mhc_class_mask[i] = True\n        mask &= np.array(mhc_class_mask)\n\n    if hla:\n        mask &= df[mhc_allele_column_key].str.contains(hla, na=False)\n\n    if exclude_hla:\n        mask &= ~(df[mhc_allele_column_key].str.contains(exclude_hla, na=False))\n\n    if assay_group:\n        mask &= df[assay_group_column_key].str.contains(assay_group)\n\n    if assay_method:\n        mask &= df[assay_method_column_key].str.contains(assay_method)\n\n    if peptide_length:\n        assert peptide_length > 0\n        mask &= df[epitope_column_key].str.len() == peptide_length\n\n    df = df[mask]\n\n    logging.info(\"Returning %d / %d entries after filtering\", len(df), n)\n    return df", "response": "Load IEDB T - cell data from a local file."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nparses a BLOSUM table of amino acid coefficients.", "response": "def parse_blosum_table(table, coeff_type=int, key_type='row'):\n    \"\"\"\n    Parse a table of pairwise amino acid coefficient (e.g. BLOSUM50)\n    \"\"\"\n\n    lines = table.split(\"\\n\")\n    # drop comments\n    lines = [line for line in lines if not line.startswith(\"#\")]\n    # drop CR endline characters\n    lines = [line.replace(\"\\r\", \"\") for line in lines]\n    # skip empty lines\n    lines = [line for line in lines if line]\n\n    labels = lines[0].split()\n\n    if len(labels) < 20:\n        raise ValueError(\n            \"Expected 20+ amino acids but first line '%s' has %d fields\" % (\n                lines[0],\n                len(labels)))\n    coeffs = {}\n    for line in lines[1:]:\n\n        fields = line.split()\n        assert len(fields) >= 21, \\\n            \"Expected AA and 20+ coefficients but '%s' has %d fields\" % (\n                line, len(fields))\n        x = fields[0]\n        for i, coeff_str in enumerate(fields[1:]):\n            y = labels[i]\n            coeff = coeff_type(coeff_str)\n            if key_type == 'pair':\n                coeffs[(x, y)] = coeff\n            elif key_type == 'pair_string':\n                coeffs[x + y] = coeff\n            else:\n                assert key_type == 'row', \"Unknown key type: %s\" % key_type\n                if x not in coeffs:\n                    coeffs[x] = {}\n                coeffs[x][y] = coeff\n    return coeffs"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _prepare_memoization_key(args, kwargs):\n    key_list = []\n    for arg in args:\n        try:\n            hash(arg)\n            key_list.append(arg)\n        except:\n            key_list.append(repr(arg))\n    for (k, v) in kwargs.items():\n        try:\n            hash(k)\n            hash(v)\n            key_list.append((k, v))\n        except:\n            key_list.append((repr(k), repr(v)))\n    return tuple(key_list)", "response": "Prepare a key for a memoization function."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef load_dataframe(\n        mhc_class=None,  # 1, 2, or None for neither\n        hla=None,\n        exclude_hla=None,\n        human_only=False,\n        peptide_length=None,\n        assay_method=None,\n        assay_group=None,\n        only_standard_amino_acids=True,\n        reduced_alphabet=None,  # 20 letter AA strings -> simpler alphabet\n        warn_bad_lines=True,\n        nrows=None):\n    \"\"\"\n    Load IEDB MHC data without aggregating multiple entries for the same epitope\n\n    Parameters\n    ----------\n    mhc_class : {None, 1, 2}\n        Restrict to MHC Class I or Class II (or None for neither)\n\n    hla : regex pattern, optional\n        Restrict results to specific HLA type used in assay\n\n    exclude_hla : regex pattern, optional\n        Exclude certain HLA types\n\n    human_only : bool\n        Restrict to human samples (default False)\n\n    peptide_length: int, optional\n        Restrict epitopes to amino acid strings of given length\n\n    assay_method : string, optional\n        Limit to assay methods which contain the given string\n\n    assay_group : string, optional\n        Limit to assay groups which contain the given string\n\n    only_standard_amino_acids : bool, optional\n        Drop sequences which use non-standard amino acids, anything outside\n        the core 20, such as X or U (default = True)\n\n    reduced_alphabet : dictionary, optional\n        Remap amino acid letters to some other alphabet\n\n    warn_bad_lines : bool, optional\n        The full MHC ligand dataset seems to contain several dozen lines with\n        too many fields. This currently results in a lot of warning messages\n        from Pandas, which you can turn off with this option (default = True)\n\n    nrows : int, optional\n        Don't load the full IEDB dataset but instead read only the first nrows\n    \"\"\"\n    df = pd.read_csv(\n            local_path(),\n            header=[0, 1],\n            skipinitialspace=True,\n            nrows=nrows,\n            low_memory=False,\n            error_bad_lines=False,\n            encoding=\"latin-1\",\n            warn_bad_lines=warn_bad_lines)\n\n    # Sometimes the IEDB seems to put in an extra comma in the\n    # header line, which creates an unnamed column of NaNs.\n    # To deal with this, drop any columns which are all NaN\n    df = df.dropna(axis=1, how=\"all\")\n\n    n = len(df)\n\n    epitope_column_key = (\"Epitope\", \"Description\")\n    mhc_allele_column_key = (\"MHC\", \"Allele Name\")\n\n    epitopes = df[epitope_column_key] = df[epitope_column_key].str.upper()\n\n    null_epitope_seq = epitopes.isnull()\n    n_null = null_epitope_seq.sum()\n    if n_null > 0:\n        logging.info(\"Dropping %d null sequences\", n_null)\n\n    mask = ~null_epitope_seq\n\n    if only_standard_amino_acids:\n        # if have rare or unknown amino acids, drop the sequence\n        bad_epitope_seq = \\\n            epitopes.str.contains(bad_amino_acids, na=False).astype(\"bool\")\n        n_bad = bad_epitope_seq.sum()\n        if n_bad > 0:\n            logging.info(\"Dropping %d bad sequences\", n_bad)\n\n        mask &= ~bad_epitope_seq\n\n    if human_only:\n        mask &= df[mhc_allele_column_key].str.startswith(\"HLA\").astype(\"bool\")\n\n    if mhc_class == 1:\n        mask &= df[\"MHC\"][\"MHC allele class\"] == \"I\"\n    elif mhc_class == 2:\n        mask &= df[\"MHC\"][\"MHC allele class\"] == \"II\"\n\n    if hla:\n        mask &= df[mhc_allele_column_key].str.contains(hla, na=False)\n\n    if exclude_hla:\n        mask &= ~(df[mhc_allele_column_key].str.contains(exclude_hla, na=False))\n\n    if assay_group:\n        mask &= df[\"Assay\"][\"Assay Group\"].str.contains(assay_group)\n\n    if assay_method:\n        mask &= df[\"Assay\"][\"Method/Technique\"].str.contains(assay_method)\n\n    if peptide_length:\n        assert peptide_length > 0\n        mask &= df[epitope_column_key].str.len() == peptide_length\n\n    df = df[mask].copy()\n\n    logging.info(\"Returning %d / %d entries after filtering\", len(df), n)\n\n    return df", "response": "Load the MHC data from a local file and return a Pandas DataFrame."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a tuple of fieldsets for the current object.", "response": "def get_fieldsets(self, request, obj=None):\n        \"\"\"\n        Add ownership info fields in fieldset with proper separation.\n\n        Author: Himanshu Shankar (https://himanshus.com)\n        \"\"\"\n        fieldsets = list(super(CreateUpdateAdmin, self).get_fieldsets(\n            request=request, obj=obj))\n\n        # Create sets for future use\n        fields = set()\n        to_add = set()\n\n        # Prepare a set of existing fields in fieldset\n        for fs in fieldsets:\n            fields = fields.union(fs[1]['fields'])\n\n        # Loop over ownership info fields\n        for k, v in self.ownership_info['fields'].items():\n\n            # Check if current model has k attribute\n            # and field k is not already in fieldset\n            # and field k has not been excluded\n            if (hasattr(self.model, k)\n                    and k not in fields\n                    and (not self.exclude\n                         or (self.exclude and k not in self.exclude))):\n\n                # Now, let's hide fields in add form, it will be empty\n                # Check if readonly property is not True\n                # or this is an edit form\n                if ('readonly' in v and not v['readonly']) or obj:\n                    to_add.add(k)\n\n        # If to_add set is not empty, add ownership info to fieldset\n        if len(to_add) > 0:\n            fieldsets.append((self.ownership_info['label'],\n                              {'fields': tuple(to_add)}))\n        return tuple(fieldsets)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a tuple of the read only fields for the current object.", "response": "def get_readonly_fields(self, request, obj=None):\n        \"\"\"\n        Makes `created_by`, `create_date` & `update_date` readonly when\n        editing.\n\n        Author: Himanshu Shankar (https://himanshus.com)\n        \"\"\"\n\n        # Get read only fields from super\n        fields = list(super(CreateUpdateAdmin, self).get_readonly_fields(\n            request=request, obj=obj))\n\n        # Loop over ownership info field\n        for k, v in self.ownership_info['fields'].items():\n\n            # Check if model has k attribute\n            # and field k is readonly\n            # and k is not already in fields\n            # and k is not in excluded field\n            # (if not checked, form.Meta.exclude has same field twice)\n            if (hasattr(self.model, k)\n                    and ('readonly' in v and v['readonly'])\n                    and k not in fields\n                    and (not self.exclude\n                         or (self.exclude and k not in self.exclude))):\n                fields.append(k)\n        return tuple(fields)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_authorization(self, request):\n        from django.utils.six import text_type\n        from rest_framework import HTTP_HEADER_ENCODING\n\n        auth = request.data.get(self.key, b'') or request.META.get(\n            self.header_key, b'')\n\n        if isinstance(auth, text_type):\n            # Work around django test client oddness\n            auth = auth.encode(HTTP_HEADER_ENCODING)\n        return auth", "response": "This function extracts the authorization string from the request body or the header part of the request."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncall the CLI interface and wait for the result.", "response": "def main(args=None):\n    \"\"\"Call the CLI interface and wait for the result.\"\"\"\n    retcode = 0\n    try:\n        ci = CliInterface()\n        args = ci.parser.parse_args()\n        result = args.func(args)\n        if result is not None:\n            print(result)\n        retcode = 0\n    except Exception:\n        retcode = 1\n        traceback.print_exc()\n    sys.exit(retcode)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef write_toc(self, args):\n        # FIXME: Can this logic be moved into the create_parser function?\n        ordered = False\n        if args.ordered_list_marker is not None:\n            list_marker = args.ordered_list_marker\n            ordered = True\n        elif args.unordered_list_marker is not None:\n            list_marker = args.unordered_list_marker\n        else:\n            list_marker = md_parser[\n                args.parser]['list']['unordered']['default_marker']\n\n        toc_struct = build_multiple_tocs(\n            filenames=args.filename,\n            ordered=ordered,\n            no_links=args.no_links,\n            no_indentation=args.no_indentation,\n            no_list_coherence=args.no_list_coherence,\n            keep_header_levels=int(args.header_levels),\n            parser=args.parser,\n            list_marker=list_marker)\n        if args.in_place:\n            write_strings_on_files_between_markers(\n                filenames=args.filename,\n                strings=toc_struct,\n                marker=args.toc_marker)\n        else:\n            for toc in toc_struct:\n                print(toc, end='')", "response": "Write the table of contents."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef create_parser(self):\n        parser = argparse.ArgumentParser(\n            description=PROGRAM_DESCRIPTION,\n            formatter_class=argparse.RawDescriptionHelpFormatter,\n            epilog=textwrap.dedent(PROGRAM_EPILOG))\n\n        parser.add_argument(\n            'filename',\n            metavar='FILE_NAME',\n            nargs='*',\n            help='the I/O file name')\n\n        subparsers = parser.add_subparsers(\n            dest='parser', title='markdown parser')\n        subparsers.required = True\n\n        # github + cmark + gitlab + commonmarker.\n        github = subparsers.add_parser(\n            'github',\n            aliases=['cmark', 'gitlab', 'commonmarker'],\n            description='Use Commonmark rules to generate an output. If no \\\n                         option is selected, the default output will be an \\\n                         unordered list with the respective default values \\\n                         as listed below')\n        megroup = github.add_mutually_exclusive_group()\n        megroup.add_argument(\n            '-u',\n            '--unordered-list-marker',\n            choices=md_parser['github']['list']['unordered']['bullet_markers'],\n            nargs='?',\n            const=md_parser['github']['list']['unordered']['default_marker'],\n            help='set the marker and enables unordered list. Defaults to ' +\n            md_parser['github']['list']['unordered']['default_marker'])\n        megroup.add_argument(\n            '-o',\n            '--ordered-list-marker',\n            choices=md_parser['github']['list']['ordered']['closing_markers'],\n            nargs='?',\n            const=md_parser['github']['list']['ordered']\n            ['default_closing_marker'],\n            help='set the marker and enables ordered lists. Defaults to ' +\n            md_parser['github']['list']['ordered']['default_closing_marker'])\n        github.add_argument(\n            '-l',\n            '--header-levels',\n            choices=[\n                str(i)\n                for i in range(1, md_parser['github']['header']['max_levels'] +\n                               1)\n            ],\n            nargs='?',\n            const=str(md_parser['github']['header']['default_keep_levels']),\n            help='set the maximum level of headers to be considered as part \\\n                  of the TOC. Defaults to ' + str(\n                md_parser['github']['header']['default_keep_levels']))\n        github.set_defaults(\n            header_levels=md_parser['github']['header']['default_keep_levels'])\n\n        # Redcarpet.\n        redcarpet = subparsers.add_parser(\n            'redcarpet',\n            description='Use Redcarpet rules to generate an output. If no \\\n                         option is selected, the default output will be an \\\n                         unordered list with the respective default values \\\n                         as listed below. Gitlab rules are the same as \\\n                         Redcarpet except that conflicts are avoided with \\\n                         duplicate headers.')\n\n        megroup = redcarpet.add_mutually_exclusive_group()\n        megroup.add_argument(\n            '-u',\n            '--unordered-list-marker',\n            choices=md_parser['redcarpet']['list']['unordered']\n            ['bullet_markers'],\n            nargs='?',\n            const=md_parser['redcarpet']['list']['unordered']\n            ['default_marker'],\n            help='set the marker and enables unordered list. Defaults to ' +\n            md_parser['redcarpet']['list']['unordered']['default_marker'])\n        megroup.add_argument(\n            '-o',\n            '--ordered-list-marker',\n            choices=md_parser['redcarpet']['list']['ordered']\n            ['closing_markers'],\n            nargs='?',\n            const=md_parser['redcarpet']['list']['ordered']\n            ['default_closing_marker'],\n            help='set the marker and enables ordered lists. Defaults to ' +\n            md_parser['redcarpet']['list']['ordered']['default_closing_marker']\n        )\n        redcarpet.add_argument(\n            '-l',\n            '--header-levels',\n            choices=[\n                str(i) for i in range(\n                    1, md_parser['redcarpet']['header']['max_levels'] + 1)\n            ],\n            nargs='?',\n            const=str(md_parser['redcarpet']['header']['default_keep_levels']),\n            help='set the maximum level of headers to be considered as part \\\n                  of the TOC. Defaults to ' + str(\n                md_parser['redcarpet']['header']['default_keep_levels']))\n        redcarpet.set_defaults(header_levels=md_parser['redcarpet']['header']\n                               ['default_keep_levels'])\n\n        c_or_i = parser.add_mutually_exclusive_group()\n        c_or_i.add_argument(\n            '-c',\n            '--no-list-coherence',\n            action='store_true',\n            help='avoids checking for TOC list coherence')\n        c_or_i.add_argument(\n            '-i',\n            '--no-indentation',\n            action='store_true',\n            help='avoids adding indentations to the TOC')\n\n        parser.add_argument(\n            '-l',\n            '--no-links',\n            action='store_true',\n            help='avoids adding links to the TOC')\n        parser.add_argument(\n            '-m',\n            '--toc-marker',\n            metavar='TOC_MARKER',\n            help='set the string to be used as the marker for positioning the \\\n                  table of contents. Defaults to ' +\n            common_defaults['toc_marker'])\n        parser.add_argument(\n            '-p',\n            '--in-place',\n            action='store_true',\n            help='overwrite the input file')\n        parser.add_argument(\n            '-v',\n            '--version',\n            action='version',\n            version=VERSION_NAME + ' ' + VERSION_NUMBER)\n\n        parser.set_defaults(toc_marker=common_defaults['toc_marker'])\n        parser.set_defaults(func=CliToApi().write_toc)\n\n        return parser", "response": "Create the CLI parser."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef patch(func=None, obj=None, name=None, avoid_doublewrap=True):\n    if obj is None:\n        if isinstance(func, (type, ModuleType)):\n            obj = func\n            func = None\n        elif isinstance(func, (list, tuple)) and all([isinstance(i, (ModuleType, type)) for i in func]):\n            obj = func\n            func = None\n\n    if func is None:\n        return functools.partial(patch, obj=obj, name=name, avoid_doublewrap=avoid_doublewrap)\n\n    if name is None:\n        name = func.__name__\n\n    if isinstance(obj, (list, tuple)) and all([isinstance(i, (ModuleType, type)) for i in obj]):\n        return [patch(func=func, obj=o, name=name, avoid_doublewrap=avoid_doublewrap) for o in obj]\n\n    if not isinstance(obj, (ModuleType, type)):\n        raise ValueError(\n            \"Argument passed to @patch decorator must be a \"\n            \"class or module, or a list of classes and modules\")\n\n    try:\n        call = getattr(obj, name)\n    except AttributeError:\n        raise TypeError(\"%(func_repr)s does not exist\" % {\n            'func_repr': '.'.join(\n                filter(None, [\n                    getattr(obj, '__module__', None),\n                    obj.__name__,\n                    func.__name__],\n                )),\n        })\n\n    # optionally avoid multiple identical wrappings\n    if avoid_doublewrap and getattr(call, 'wrapper', None) is func:\n        return\n\n    # get underlying function (if it's an unbound method)\n    try:\n        original_callable = six.get_method_function(call)\n    except AttributeError:\n        original_callable = call\n\n    @six.wraps(func)\n    def wrapper(*args, **kwargs):\n        return func(original_callable, *args, **kwargs)\n\n    # set attributes, for future unwrapping and to avoid double-wrapping\n    wrapper.original = call\n    wrapper.wrapper = func\n\n    if six.PY2 and inspect.isclass(obj):\n        # rewrap staticmethod and classmethod specifically (iff obj is a class)\n        if hasattr(call, 'im_self'):\n            if call.im_self:\n                wrapper = classmethod(wrapper)\n        else:\n            wrapper = staticmethod(wrapper)\n\n    # finally, install the func closure as requested\n    setattr(obj, name, wrapper)\n    return getattr(obj, name)", "response": "Decorator for monkeypatching functions on modules and classes."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nundoes the effects of patch(func, obj, name)", "response": "def unpatch(obj, name):\n    \"\"\"\n    Undo the effects of patch(func, obj, name)\n    \"\"\"\n    setattr(obj, name, getattr(obj, name).original)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef validate_email(email):\n    from django.core.validators import validate_email\n    from django.core.exceptions import ValidationError\n    try:\n        validate_email(email)\n        return True\n    except ValidationError:\n        return False", "response": "Validates an email address and returns a boolean indicating if the email is valid."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a mobile number after removing blanks", "response": "def get_mobile_number(mobile):\n    \"\"\"\n    Returns a mobile number after removing blanks\n\n    Author: Himanshu Shankar (https://himanshus.com)\n    Parameters\n    ----------\n    mobile: str\n\n    Returns\n    -------\n    str\n    \"\"\"\n    blanks = [' ', '.', ',', '(', ')', '-']\n\n    for b in blanks:\n        mobile = mobile.replace(b, '')\n\n    return mobile"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\npaginate the searched_data as per the request_data", "response": "def paginate_data(searched_data, request_data):\n    \"\"\"\n    Paginates the searched_data as per the request_data\n    Source: Himanshu Shankar (https://github.com/iamhssingh)\n    Parameters\n    ----------\n    searched_data: Serializer.data\n                    It is the data received from queryset. It uses\n                    show_serializer\n    request_data: Serializer.data\n                    It is the request data. It uses serializer_class.\n\n    Returns\n    -------\n    data: dict\n    \"\"\"\n    from django.core.paginator import Paginator, EmptyPage, PageNotAnInteger\n\n    if int(request_data.data['paginator']) > 0:\n        paginator = Paginator(searched_data.data,\n                              request_data.data['paginator'])\n        try:\n            curr = paginator.page(request_data.data['page'])\n        except PageNotAnInteger:\n            curr = paginator.page(1)\n        except EmptyPage:\n            curr = paginator.page(paginator.num_pages)\n\n        data = {'total_pages': paginator.num_pages, 'current': curr.number,\n                'total_objects': len(searched_data.data)}\n        if curr.has_next():\n            data['next'] = curr.next_page_number()\n        else:\n            data['next'] = -1\n\n        if curr.number > 1:\n            data['previous'] = curr.previous_page_number()\n        else:\n            data['previous'] = -1\n        data['objects'] = curr.object_list\n    else:\n        data = {'objects': searched_data.data, 'previous': -1, 'next': -1,\n                'total_pages': 1, 'current': 1,\n                'total_objects': len(searched_data.data)}\n    return data"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsends a message to specified value.", "response": "def send_message(message: str, subject: str, recip: list, recip_email: list,\n                 html_message: str = None):\n    \"\"\"\n    Sends message to specified value.\n    Source: Himanshu Shankar (https://github.com/iamhssingh)\n    Parameters\n    ----------\n    message: str\n        Message that is to be sent to user.\n    subject: str\n        Subject that is to be sent to user, in case prop is an email.\n    recip: list\n        Recipient to whom message is being sent.\n    recip_email: list\n        Recipient to whom EMail is being sent. This will be deprecated once\n        SMS feature is brought in.\n    html_message: str\n        HTML variant of message, if any.\n\n    Returns\n    -------\n    sent: dict\n    \"\"\"\n\n    import smtplib\n\n    from django.conf import settings\n    from django.core.mail import send_mail\n\n    from sendsms import api\n\n    sent = {'success': False, 'message': None}\n\n    if not getattr(settings, 'EMAIL_HOST', None):\n        raise ValueError('EMAIL_HOST must be defined in django '\n                         'setting for sending mail.')\n    if not getattr(settings, 'EMAIL_FROM', None):\n        raise ValueError('EMAIL_FROM must be defined in django setting '\n                         'for sending mail. Who is sending email?')\n    if not getattr(settings, 'EMAIL_FROM', None):\n        raise ValueError('EMAIL_FROM must be defined in django setting '\n                         'for sending mail. Who is sending email?')\n\n    # Check if there is any recipient\n    if not len(recip) > 0:\n        raise ValueError('No recipient to send message.')\n    # Check if the value of recipient is valid (min length: a@b.c)\n    elif len(recip[0]) < 5:\n        raise ValueError('Invalid recipient.')\n\n    # Check if all recipient in list are of same type\n    is_email = validate_email(recip[0])\n    for ind in range(len(recip)):\n        if validate_email(recip[ind]) is not is_email:\n            raise ValueError('All recipient should be of same type.')\n        elif not is_email:\n            recip[ind] = get_mobile_number(recip[ind])\n\n    # Check if fallback email is indeed an email\n    for rcp in recip_email:\n        if not validate_email(rcp):\n            raise ValueError('Invalid email provided: {}'.format(rcp))\n\n    if isinstance(recip, str):\n        # For backsupport\n        recip = [recip]\n    if isinstance(recip_email, str):\n        # For backsupport\n        recip_email = [recip_email]\n\n    if is_email:\n        try:\n            send_mail(subject=subject, message=message,\n                      html_message=html_message,\n                      from_email=settings.EMAIL_FROM, recipient_list=recip)\n        except smtplib.SMTPException as ex:\n            sent['message'] = 'Message sending failed!' + str(ex.args)\n            sent['success'] = False\n        else:\n            sent['message'] = 'Message sent successfully!'\n            sent['success'] = True\n\n    else:\n        try:\n            api.send_sms(body=message, to=recip, from_phone=None)\n\n            # Django SendSMS doesn't provide an output of success/failure.\n            # Send mail either ways, just to ensure delivery.\n            send_message(message=message, subject=subject, recip=recip_email,\n                         recip_email=recip_email,\n                         html_message=html_message)\n        except Exception as ex:\n            sent['message'] = 'Message sending Failed!' + str(ex.args)\n            sent['success'] = False\n            send_message(message=message, subject=subject,\n                         recip=recip_email,\n                         recip_email=recip_email,\n                         html_message=html_message)\n        else:\n            sent['message'] = 'Message sent successfully!'\n            sent['success'] = True\n\n    return sent"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef has_object_permission(self, request, view, obj):\n        return (\n            request.user.is_superuser or\n            super(IAWPOrSuperuser, self).has_object_permission(\n                request=request, view=view, obj=obj\n            )\n        )", "response": "Checks if user is superuser or object has permission over object"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef write_string_on_file_between_markers(filename: str, string: str,\n                                         marker: str):\n    r\"\"\"Write the table of contents on a single file.\n\n    :parameter filename: the file that needs to be read or modified.\n    :parameter string: the string that will be written on the file.\n    :parameter marker: a marker that will identify the start\n         and the end of the string.\n    :type filenames: str\n    :type string: str\n    :type marker: str\n    :returns: None\n    :rtype: None\n    :raises: StdinIsNotAFileToBeWritten or an fpyutils exception\n         or a built-in exception.\n    \"\"\"\n    if filename == '-':\n        raise StdinIsNotAFileToBeWritten\n\n    final_string = marker + '\\n\\n' + string.rstrip() + '\\n\\n' + marker + '\\n'\n    marker_line_positions = fpyutils.get_line_matches(\n        filename, marker, 2, loose_matching=True)\n\n    if 1 in marker_line_positions:\n        if 2 in marker_line_positions:\n            fpyutils.remove_line_interval(filename, marker_line_positions[1],\n                                          marker_line_positions[2], filename)\n        else:\n            fpyutils.remove_line_interval(filename, marker_line_positions[1],\n                                          marker_line_positions[1], filename)\n        fpyutils.insert_string_at_line(\n            filename,\n            final_string,\n            marker_line_positions[1],\n            filename,\n            append=False)", "response": "r Write the string on a single file between a marker and a marker."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef build_toc(filename: str,\n              ordered: bool = False,\n              no_links: bool = False,\n              no_indentation: bool = False,\n              no_list_coherence: bool = False,\n              keep_header_levels: int = 3,\n              parser: str = 'github',\n              list_marker: str = '-') -> str:\n    r\"\"\"Build the table of contents of a single file.\n\n    :parameter filename: the file that needs to be read.\n    :parameter ordered: decides whether to build an ordered list or not.\n         Defaults to ``False``.\n    :parameter no_links: disables the use of links.\n         Defaults to ``False``.\n    :parameter no_indentation: disables indentation in the list.\n         Defaults to ``False``.\n    :parameter keep_header_levels: the maximum level of headers to be\n         considered as such when building the table of contents.\n         Defaults to ``3``.\n    :parameter parser: decides rules on how to generate anchor links.\n         Defaults to ``github``.\n    :type filename: str\n    :type ordered: bool\n    :type no_links: bool\n    :type no_indentation: bool\n    :type keep_header_levels: int\n    :type parser: str\n    :returns: toc, the corresponding table of contents of the file.\n    :rtype: str\n    :raises: a built-in exception.\n    \"\"\"\n    toc = str()\n    header_type_counter = dict()\n    header_type_curr = 0\n    header_type_prev = 0\n    header_duplicate_counter = dict()\n    no_of_indentation_spaces_prev = 0\n    if ordered:\n        list_marker_log = build_list_marker_log(parser, list_marker)\n    if filename == '-':\n        f = sys.stdin\n    else:\n        f = open(filename, 'r')\n    line = f.readline()\n    if ordered:\n        list_marker_log = build_list_marker_log(parser, list_marker)\n    else:\n        list_marker_log = list()\n    is_within_code_fence = False\n    code_fence = None\n    is_document_end = False\n    if not no_indentation and not no_list_coherence:\n        # if indentation and list coherence.\n        indentation_list = build_indentation_list(parser)\n    while line:\n        # Document ending detection.\n        #\n        # This changes the state of is_within_code_fence if the\n        # file has no closing fence markers. This serves no practial\n        # purpose since the code would run correctly anyway. It is\n        # however more sematically correct.\n        #\n        # See the unit tests (examples 95 and 96 of the github parser)\n        # and the is_closing_code_fence function.\n        if filename != '-':\n            # stdin is not seekable.\n            file_pointer_pos = f.tell()\n            if f.readline() == str():\n                is_document_end = True\n            f.seek(file_pointer_pos)\n\n        # Code fence detection.\n        if is_within_code_fence:\n            is_within_code_fence = not is_closing_code_fence(\n                line, code_fence, is_document_end, parser)\n            line = f.readline()\n        else:\n            code_fence = is_opening_code_fence(line, parser)\n            if code_fence is not None:\n                # Update the status of the next line.\n                is_within_code_fence = True\n                line = f.readline()\n\n        if not is_within_code_fence or code_fence is None:\n\n            # Header detection and gathering.\n            header = get_md_header(line, header_duplicate_counter,\n                                   keep_header_levels, parser, no_links)\n            if header is not None:\n                header_type_curr = header['type']\n\n                # Take care of the ordered TOC.\n                if ordered:\n                    increase_index_ordered_list(header_type_counter,\n                                                header_type_prev,\n                                                header_type_curr, parser)\n                    index = header_type_counter[header_type_curr]\n                else:\n                    index = 1\n\n                # Take care of list indentations.\n                if no_indentation:\n                    no_of_indentation_spaces_curr = 0\n                    # TOC list coherence checks are not necessary\n                    # without indentation.\n                else:\n                    if not no_list_coherence:\n                        if not toc_renders_as_coherent_list(\n                                header_type_curr, indentation_list, parser):\n                            raise TocDoesNotRenderAsCoherentList\n                    no_of_indentation_spaces_curr = compute_toc_line_indentation_spaces(\n                        header_type_curr, header_type_prev,\n                        no_of_indentation_spaces_prev, parser, ordered,\n                        list_marker, list_marker_log, index)\n\n                # Build a single TOC line.\n                toc_line_no_indent = build_toc_line_without_indentation(\n                    header, ordered, no_links, index, parser, list_marker)\n\n                # Save the TOC line with the indentation.\n                toc += build_toc_line(toc_line_no_indent,\n                                      no_of_indentation_spaces_curr) + '\\n'\n\n                header_type_prev = header_type_curr\n                no_of_indentation_spaces_prev = no_of_indentation_spaces_curr\n\n            # endif\n\n        # endif\n\n        line = f.readline()\n\n    # endwhile\n\n    f.close()\n\n    return toc", "response": "r Builds a table of contents of a single file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef increase_index_ordered_list(header_type_count: dict,\n                                header_type_prev: int,\n                                header_type_curr: int,\n                                parser: str = 'github'):\n    r\"\"\"Compute the current index for ordered list table of contents.\n\n    :parameter header_type_count: the count of each header type.\n    :parameter header_type_prev: the previous type of header (h[1-Inf]).\n    :parameter header_type_curr: the current type of header (h[1-Inf]).\n    :parameter parser: decides rules on how to generate ordered list markers.\n         Defaults to ``github``.\n    :type header_type_count: dict\n    :type header_type_prev: int\n    :type header_type_curr: int\n    :type parser: str\n    :returns: None\n    :rtype: None\n    :raises: GithubOverflowOrderedListMarker or a built-in exception.\n    \"\"\"\n    # header_type_prev might be 0 while header_type_curr can't.\n    assert header_type_prev >= 0\n    assert header_type_curr >= 1\n\n    # Base cases for a new table of contents or a new index type.\n    if header_type_prev == 0:\n        header_type_prev = header_type_curr\n    if (header_type_curr not in header_type_count\n            or header_type_prev < header_type_curr):\n        header_type_count[header_type_curr] = 0\n\n    header_type_count[header_type_curr] += 1\n\n    if (parser == 'github' or parser == 'cmark' or parser == 'gitlab'\n            or parser == 'commonmarker'):\n        if header_type_count[header_type_curr] > md_parser['github']['list'][\n                'ordered']['max_marker_number']:\n            raise GithubOverflowOrderedListMarker", "response": "r Increase the current index for ordered list table of contents."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef build_list_marker_log(parser: str = 'github',\n                          list_marker: str = '.') -> list:\n    r\"\"\"Create a data structure that holds list marker information.\n\n    :parameter parser: decides rules on how compute indentations.\n         Defaults to ``github``.\n    :parameter list_marker: a string that contains some of the first\n         characters of the list element. Defaults to ``-``.\n    :type parser: str\n    :type list_marker: str\n    :returns: list_marker_log, the data structure.\n    :rtype: list\n    :raises: a built-in exception.\n\n    .. note::\n         This function makes sense for ordered lists only.\n    \"\"\"\n    if (parser == 'github' or parser == 'cmark' or parser == 'gitlab'\n            or parser == 'commonmarker' or parser == 'redcarpet'):\n        assert list_marker in md_parser[parser]['list']['ordered'][\n            'closing_markers']\n\n    list_marker_log = list()\n\n    if (parser == 'github' or parser == 'cmark' or parser == 'gitlab'\n            or parser == 'commonmarker'):\n        list_marker_log = [\n            str(md_parser['github']['list']['ordered']['min_marker_number']) +\n            list_marker\n            for i in range(0, md_parser['github']['header']['max_levels'])\n        ]\n\n    elif parser == 'redcarpet':\n        pass\n\n    return list_marker_log", "response": "r Builds a list marker log."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef compute_toc_line_indentation_spaces(\n        header_type_curr: int = 1,\n        header_type_prev: int = 0,\n        no_of_indentation_spaces_prev: int = 0,\n        parser: str = 'github',\n        ordered: bool = False,\n        list_marker: str = '-',\n        list_marker_log: list = build_list_marker_log('github', '.'),\n        index: int = 1) -> int:\n    r\"\"\"Compute the number of indentation spaces for the TOC list element.\n\n    :parameter header_type_curr: the current type of header (h[1-Inf]).\n         Defaults to ``1``.\n    :parameter header_type_prev: the previous type of header (h[1-Inf]).\n         Defaults to ``0``.\n    :parameter no_of_indentation_spaces_prev: the number of previous indentation spaces.\n         Defaults to ``0``.\n    :parameter parser: decides rules on how compute indentations.\n         Defaults to ``github``.\n    :parameter ordered: if set to ``True``, numbers will be used\n         as list ids or otherwise a dash character, otherwise.\n         Defaults to ``False``.\n    :parameter list_marker: a string that contains some of the first\n         characters of the list element.\n         Defaults to ``-``.\n    :parameter list_marker_log: a data structure that holds list marker\n         information for ordered lists.\n         Defaults to ``build_list_marker_log('github', '.')``.\n    :parameter index: a number that will be used as list id in case of an\n         ordered table of contents. Defaults to ``1``.\n    :type header_type_curr: int\n    :type header_type_prev: int\n    :type no_of_indentation_spaces_prev: int\n    :type parser: str\n    :type ordered: bool\n    :type list_marker: str\n    :type list_marker_log: list\n    :type index: int\n    :returns: no_of_indentation_spaces_curr, the number of indentation spaces\n         for the list element.\n    :rtype: int\n    :raises: a built-in exception.\n\n    .. note::\n         Please note that this function\n         assumes that no_of_indentation_spaces_prev contains the correct\n         number of spaces.\n    \"\"\"\n    assert header_type_curr >= 1\n    assert header_type_prev >= 0\n    assert no_of_indentation_spaces_prev >= 0\n    if (parser == 'github' or parser == 'cmark' or parser == 'gitlab'\n            or parser == 'commonmarker' or parser == 'redcarpet'):\n        if ordered:\n            assert list_marker in md_parser[parser]['list']['ordered'][\n                'closing_markers']\n        else:\n            assert list_marker in md_parser[parser]['list']['unordered'][\n                'bullet_markers']\n    if (parser == 'github' or parser == 'cmark' or parser == 'gitlab'\n            or parser == 'commonmarker'):\n        if ordered:\n            assert len(\n                list_marker_log) == md_parser['github']['header']['max_levels']\n            for e in list_marker_log:\n                assert isinstance(e, str)\n    assert index >= 1\n\n    if (parser == 'github' or parser == 'cmark' or parser == 'gitlab'\n            or parser == 'commonmarker'):\n        if header_type_prev == 0:\n            # Base case for the first toc line.\n            no_of_indentation_spaces_curr = 0\n        elif header_type_curr == header_type_prev:\n            # Base case for same indentation.\n            no_of_indentation_spaces_curr = no_of_indentation_spaces_prev\n        else:\n            if ordered:\n                list_marker_prev = str(list_marker_log[header_type_curr - 1])\n            else:\n                # list_marker for unordered lists will always be 1 character.\n                list_marker_prev = list_marker\n\n            # Generic cases.\n            if header_type_curr > header_type_prev:\n                # More indentation.\n                no_of_indentation_spaces_curr = (\n                    no_of_indentation_spaces_prev + len(list_marker_prev) +\n                    len(' '))\n            elif header_type_curr < header_type_prev:\n                # Less indentation.\n                no_of_indentation_spaces_curr = (\n                    no_of_indentation_spaces_prev -\n                    (len(list_marker_prev) + len(' ')))\n\n            # Reset older nested list indices. If this is not performed then\n            # future nested ordered lists will rely on incorrect data to\n            # compute indentations.\n            if ordered:\n                for i in range((header_type_curr - 1) + 1,\n                               md_parser['github']['header']['max_levels']):\n                    list_marker_log[i] = str(\n                        md_parser['github']['list']['ordered']\n                        ['min_marker_number']) + list_marker\n\n        # Update the data structure.\n        if ordered:\n            list_marker_log[header_type_curr - 1] = str(index) + list_marker\n\n    elif parser == 'redcarpet':\n        no_of_indentation_spaces_curr = 4 * (header_type_curr - 1)\n\n    return no_of_indentation_spaces_curr", "response": "r Compute the number of indentation spaces for the TOC list element."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef build_toc_line_without_indentation(header: dict,\n                                       ordered: bool = False,\n                                       no_links: bool = False,\n                                       index: int = 1,\n                                       parser: str = 'github',\n                                       list_marker: str = '-') -> str:\n    r\"\"\"Return a list element of the table of contents.\n\n    :parameter header: a data structure that contains the original\n         text, the trimmed text and the type of header.\n    :parameter ordered: if set to ``True``, numbers will be used\n         as list ids, otherwise a dash character. Defaults\n         to ``False``.\n    :parameter no_links: disables the use of links. Defaults to ``False``.\n    :parameter index: a number that will be used as list id in case of an\n         ordered table of contents. Defaults to ``1``.\n    :parameter parser: decides rules on how compute indentations.\n         Defaults to ``github``.\n    :parameter list_marker: a string that contains some of the first\n         characters of the list element. Defaults to ``-``.\n    :type header: dict\n    :type ordered: bool\n    :type no_links: bool\n    :type index: int\n    :type parser: str\n    :type list_marker: str\n    :returns: toc_line_no_indent, a single line of the table of contents\n         without indentation.\n    :rtype: str\n    :raises: a built-in exception.\n    \"\"\"\n    assert 'type' in header\n    assert 'text_original' in header\n    assert 'text_anchor_link' in header\n    assert isinstance(header['type'], int)\n    assert isinstance(header['text_original'], str)\n    assert isinstance(header['text_anchor_link'], str)\n    assert header['type'] >= 1\n    assert index >= 1\n    if (parser == 'github' or parser == 'cmark' or parser == 'gitlab'\n            or parser == 'commonmarker' or parser == 'redcarpet'):\n        if ordered:\n            assert list_marker in md_parser[parser]['list']['ordered'][\n                'closing_markers']\n        else:\n            assert list_marker in md_parser[parser]['list']['unordered'][\n                'bullet_markers']\n\n    toc_line_no_indent = str()\n\n    if (parser == 'github' or parser == 'cmark' or parser == 'gitlab'\n            or parser == 'commonmarker' or parser == 'redcarpet'):\n        if ordered:\n            list_marker = str(index) + list_marker\n\n        # FIXME: is this always correct?\n        if no_links:\n            line = header['text_original']\n        else:\n            line = '[' + header['text_original'] + ']' + '(#' + header[\n                'text_anchor_link'] + ')'\n        toc_line_no_indent = list_marker + ' ' + line\n\n    return toc_line_no_indent", "response": "r Builds a single line of the table of contents without indentation."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_md_header(header_text_line: str,\n                  header_duplicate_counter: dict,\n                  keep_header_levels: int = 3,\n                  parser: str = 'github',\n                  no_links: bool = False) -> dict:\n    r\"\"\"Build a data structure with the elements needed to create a TOC line.\n\n    :parameter header_text_line: a single markdown line that needs to be\n         transformed into a TOC line.\n    :parameter header_duplicate_counter: a data structure that contains the\n         number of occurrencies of each header anchor link. This is used to\n         avoid duplicate anchor links and it is meaningful only for certain\n         values of parser.\n    :parameter keep_header_levels: the maximum level of headers to be\n         considered as such when building the table of contents.\n         Defaults to ``3``.\n    :parameter parser: decides rules on how to generate anchor links.\n         Defaults to ``github``.\n    :type header_text_line: str\n    :type header_duplicate_counter: dict\n    :type keep_header_levels: int\n    :type parser: str\n    :returns: None if the input line does not correspond to one of the\n         designated cases or a data structure containing the necessary\n         components to create a table of contents line, otherwise.\n    :rtype: dict\n    :raises: a built-in exception.\n\n    .. note::\n         This works like a wrapper to other functions.\n    \"\"\"\n    result = get_atx_heading(header_text_line, keep_header_levels, parser,\n                             no_links)\n    if result is None:\n        return result\n    else:\n        header_type, header_text_trimmed = result\n        header = {\n            'type':\n            header_type,\n            'text_original':\n            header_text_trimmed,\n            'text_anchor_link':\n            build_anchor_link(header_text_trimmed, header_duplicate_counter,\n                              parser)\n        }\n        return header", "response": "r Returns a dictionary containing the elements needed to create a TOC line."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef is_opening_code_fence(line: str, parser: str = 'github'):\n    if (parser == 'github' or parser == 'cmark' or parser == 'gitlab'\n            or parser == 'commonmarker'):\n        markers = md_parser['github']['code fence']['marker']\n        marker_min_length = md_parser['github']['code fence'][\n            'min_marker_characters']\n\n        if not is_valid_code_fence_indent(line):\n            return None\n\n        line = line.lstrip(' ').rstrip('\\n')\n        if not line.startswith(\n            (markers[0] * marker_min_length, markers[1] * marker_min_length)):\n            return None\n\n        if line == len(line) * line[0]:\n            info_string = str()\n        else:\n            info_string = line.lstrip(line[0])\n        # Backticks or tildes in info string are explicitly forbidden.\n        if markers[0] in info_string or markers[1] in info_string:\n            return None\n        # Solves example 107. See:\n        # https://github.github.com/gfm/#example-107\n        if line.rstrip(markers[0]) != line and line.rstrip(markers[1]) != line:\n            return None\n\n        return line.rstrip(info_string)\n    elif parser == 'redcarpet':\n        # TODO.\n        return None", "response": "r Determine if the given line is possibly the opening of a fenced code block."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef build_indentation_list(parser: str = 'github'):\n    indentation_list = list()\n\n    if (parser == 'github' or parser == 'cmark' or parser == 'gitlab'\n            or parser == 'commonmarker' or parser == 'redcarpet'):\n        for i in range(0, md_parser[parser]['header']['max_levels']):\n            indentation_list.append(False)\n\n    return indentation_list", "response": "r Creates a list that contains the state of indentations given a header type."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nchecking if user is the owner of object", "response": "def is_owner(self, user):\n        \"\"\"\n        Checks if user is the owner of object\n\n        Parameters\n        ----------\n        user: get_user_model() instance\n\n        Returns\n        -------\n        bool\n\n        Author\n        ------\n        Himanshu Shankar (https://himanshus.com)\n        \"\"\"\n        if user.is_authenticated:\n            return self.created_by.id == user.id\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nuse UnitTH to generate a test history report of", "response": "def run(xml_report_dir, xml_report_filter='TEST-', html_report_path='.', \n        generate_exec_time_graphs=True, html_report_dir='report.th',\n        initial_java_heap_size=None, maximum_java_heap_size=None):\n        \"\"\" Use UnitTH to generate a test history report\n\n        Args:\n            xml_report_dir (:obj:`str`): Parent directory of XML reports of individual builds to generate a history report of \n            xml_report_filter (:obj:`str`, optional): Starts-with filter for individual reports with `xml_report_dir` that should \n                be included in the history report. Set `xml_report_filter` to '' to include all files/subdirectories in the history\n                report.\n            html_report_path (:obj:`str`, optional): Directory of HTML reports of individual builds (relative to XML directories of \n                individual builds)\n            generate_exec_time_graphs (:obj:`bool`, optional): Whether execution time graphs shall be generated\n            html_report_dir (:obj:`str`, optional): directory to store generated HTML history report\n            initial_java_heap_size (:obj:`str`, optional): initial Java heap size\n            maximum_java_heap_size (:obj:`str`, optional): maximum Java heap size\n        \"\"\"\n\n        cmd = []\n        cmd.append('java')\n\n        if initial_java_heap_size:\n            cmd.append('-Xms{}'.format(initial_java_heap_size))\n        if maximum_java_heap_size:\n            cmd.append('-Xmx{}'.format(maximum_java_heap_size))\n\n        cmd.append('-Dunitth.xml.report.filter={}'.format(xml_report_filter))\n        cmd.append('-Dunitth.html.report.path={}'.format(html_report_path))\n        cmd.append('-Dunitth.generate.exectimegraphs={}'.format('{}'.format(generate_exec_time_graphs).lower()))\n        cmd.append('-Dunitth.report.dir={}'.format(html_report_dir))\n        cmd.append('-jar')\n        cmd.append('\"{}\"'.format(resource_filename('unitth', 'lib/unitth/unitth.jar')))\n        cmd.append(xml_report_dir)\n\n        subprocess.check_call(' '.join(cmd), shell=True)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_counter(data, base):\n\n    b0 = data[base]\n    b1 = data[base + 1]\n    b2 = data[base + 2]\n    b3 = data[base + 3]\n\n    counter = b3\n    position = (b1 << 8) + b2\n\n    return counter, position", "response": "Get the counter from the data."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_delete(url, id, method, key=None):\n        return Util(\n            url=url + id + \"/\",\n            method=method,\n            key=key,\n        ).json_result()", "response": "Get or delete a resource from a resource."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_user(self, login):\n        return youtrack.User(self._get(\"/admin/user/\" + urlquote(login.encode('utf8'))), self)", "response": "Get a user by login."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nimporting users returns import result", "response": "def import_users(self, users):\n        \"\"\" Import users, returns import result (http://confluence.jetbrains.net/display/YTD2/Import+Users)\n            Example: importUsers([{'login':'vadim', 'fullName':'vadim', 'email':'eee@ss.com', 'jabber':'fff@fff.com'},\n                                  {'login':'maxim', 'fullName':'maxim', 'email':'aaa@ss.com', 'jabber':'www@fff.com'}])\n        \"\"\"\n        if len(users) <= 0:\n            return\n\n        known_attrs = ('login', 'fullName', 'email', 'jabber')\n\n        xml = '<list>\\n'\n        for u in users:\n            xml += '  <user ' + \"\".join(k + '=' + quoteattr(u[k]) + ' ' for k in u if k in known_attrs) + '/>\\n'\n        xml += '</list>'\n        # TODO: convert response xml into python objects\n        if isinstance(xml, str):\n            xml = xml.encode('utf-8')\n        return self._req_xml('PUT', '/import/users', xml, 400).toxml()"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nimports links returns import result", "response": "def import_links(self, links):\n        \"\"\" Import links, returns import result (http://confluence.jetbrains.net/display/YTD2/Import+Links)\n            Accepts result of getLinks()\n            Example: importLinks([{'login':'vadim', 'fullName':'vadim', 'email':'eee@ss.com', 'jabber':'fff@fff.com'},\n                                  {'login':'maxim', 'fullName':'maxim', 'email':'aaa@ss.com', 'jabber':'www@fff.com'}])\n        \"\"\"\n        xml = '<list>\\n'\n        for l in links:\n            # ignore typeOutward and typeInward returned by getLinks()\n            xml += '  <link ' + \"\".join(attr + '=' + quoteattr(l[attr]) +\n                                        ' ' for attr in l if attr not in ['typeInward', 'typeOutward']) + '/>\\n'\n        xml += '</list>'\n        # TODO: convert response xml into python objects\n        res = self._req_xml('PUT', '/import/links', xml, 400)\n        return res.toxml() if hasattr(res, \"toxml\") else res"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef import_issues(self, project_id, assignee_group, issues):\n        if len(issues) <= 0:\n            return\n\n        bad_fields = ['id', 'projectShortName', 'votes', 'commentsCount',\n                      'historyUpdated', 'updatedByFullName', 'updaterFullName',\n                      'reporterFullName', 'links', 'attachments', 'jiraId',\n                      'entityId', 'tags', 'sprint']\n\n        tt_settings = self.get_project_time_tracking_settings(project_id)\n        if tt_settings and tt_settings['Enabled'] and tt_settings['TimeSpentField']:\n            bad_fields.append(tt_settings['TimeSpentField'])\n\n        xml = '<issues>\\n'\n        issue_records = dict([])\n\n        for issue in issues:\n            record = \"\"\n            record += '  <issue>\\n'\n\n            comments = None\n            if getattr(issue, \"getComments\", None):\n                comments = issue.get_comments()\n\n            for issue_attr in issue:\n                attr_value = issue[issue_attr]\n                if attr_value is None:\n                    continue\n                if isinstance(attr_value, str):\n                    attr_value = attr_value.encode('utf-8')\n                if isinstance(issue_attr, str):\n                    issue_attr = issue_attr.encode('utf-8')\n                if issue_attr == 'comments':\n                    comments = attr_value\n                else:\n                    # ignore bad fields from getIssue()\n                    if issue_attr not in bad_fields:\n                        record += '    <field name=\"' + issue_attr + '\">\\n'\n                        if isinstance(attr_value, list) or getattr(attr_value, '__iter__', False):\n                            for v in attr_value:\n                                if isinstance(v, str):\n                                    v = v.encode('utf-8')\n                                record += '      <value>' + escape(v.strip()) + '</value>\\n'\n                        else:\n                            record += '      <value>' + escape(attr_value.strip()) + '</value>\\n'\n                        record += '    </field>\\n'\n\n            if comments:\n                for comment in comments:\n                    record += '    <comment'\n                    for ca in comment:\n                        val = comment[ca]\n                        if isinstance(ca, str):\n                            ca = ca.encode('utf-8')\n                        if isinstance(val, str):\n                            val = val.encode('utf-8')\n                        record += ' ' + ca + '=' + quoteattr(val)\n                    record += '/>\\n'\n\n            record += '  </issue>\\n'\n            xml += record\n            issue_records[issue.numberInProject] = record\n\n        xml += '</issues>'\n\n        # print xml\n        # TODO: convert response xml into python objects\n\n        if isinstance(xml, str):\n            xml = xml.encode('utf-8')\n\n        if isinstance(assignee_group, str):\n            assignee_group = assignee_group.encode('utf-8')\n\n        url = '/import/' + urlquote(project_id) + '/issues?' + urllib.parse.urlencode({'assigneeGroup': assignee_group})\n        if isinstance(url, str):\n            url = url.encode('utf-8')\n        result = self._req_xml('PUT', url, xml, 400)\n        if (result == \"\") and (len(issues) > 1):\n            for issue in issues:\n                self.import_issues(project_id, assignee_group, [issue])\n        response = \"\"\n        try:\n            response = result.toxml().encode('utf-8')\n        except youtrack.YouTrackBroadException:\n            sys.stderr.write(\"can't parse response\")\n            sys.stderr.write(\"request was\")\n            sys.stderr.write(xml)\n            return response\n        item_elements = minidom.parseString(response).getElementsByTagName(\"item\")\n        if len(item_elements) != len(issues):\n            sys.stderr.write(response)\n        else:\n            for item in item_elements:\n                _id = item.attributes[\"id\"].value\n                imported = item.attributes[\"imported\"].value.lower()\n                if imported == \"true\":\n                    print(\"Issue [ %s-%s ] imported successfully\" % (project_id, _id))\n                else:\n                    sys.stderr.write(\"\")\n                    sys.stderr.write(\"Failed to import issue [ %s-%s ].\" % (project_id, _id))\n                    sys.stderr.write(\"Reason : \")\n                    sys.stderr.write(item.toxml())\n                    sys.stderr.write(\"Request was :\")\n                    if isinstance(issue_records[_id], str):\n                        sys.stderr.write(issue_records[_id].encode('utf-8'))\n                    else:\n                        sys.stderr.write(issue_records[_id])\n                print(\"\")\n        return response", "response": "Imports issues into a JIRA file."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets a project by ID", "response": "def get_project(self, project_id):\n        \"\"\" http://confluence.jetbrains.net/display/YTD2/GET+project\n        \"\"\"\n        return youtrack.Project(self._get(\"/admin/project/\" + urlquote(project_id)), self)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate a new subsystem for the given project.", "response": "def create_subsystems(self, project_id, subsystems):\n        \"\"\" Accepts result of getSubsystems()\n        \"\"\"\n\n        for s in subsystems:\n            self.create_subsystem(project_id, s)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef create_versions(self, project_id, versions):\n\n        for v in versions:\n            self.create_version(project_id, v)", "response": "Creates the versions of the items in the list of versions."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nrunning a command and echo it first", "response": "def run_cmd(call, cmd, *, echo=True, **kwargs):\n    \"\"\"Run a command and echo it first\"\"\"\n    if echo:\n        print('$> ' + ' '.join(map(pipes.quote, cmd)))\n    return call(cmd, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the URL for remote git repository.", "response": "def git_remote(git_repo):\n    \"\"\"Return the URL for remote git repository.\n\n    Depending on the system setup it returns ssh or https remote.\n    \"\"\"\n    github_token = os.getenv(GITHUB_TOKEN_KEY)\n    if github_token:\n        return 'https://{0}@github.com/{1}'.format(\n            github_token, git_repo)\n    return 'git@github.com:{0}'.format(git_repo)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef render_build_args(options, ns):\n    build_args = options.get('buildArgs', {})\n    for key, value in build_args.items():\n        build_args[key] = value.format(**ns)\n    return build_args", "response": "Get docker build args dict rendering any templated args."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef build_image(image_path, image_name, build_args=None, dockerfile_path=None):\n    cmd = ['docker', 'build', '-t', image_name, image_path]\n    if dockerfile_path:\n        cmd.extend(['-f', dockerfile_path])\n\n    for k, v in (build_args or {}).items():\n        cmd += ['--build-arg', '{}={}'.format(k, v)]\n    check_call(cmd)", "response": "Build an image in the cluster"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef image_needs_pushing(image):\n    d = docker_client()\n    try:\n        d.images.get_registry_data(image)\n    except docker.errors.APIError:\n        # image not found on registry, needs pushing\n        return True\n    else:\n        return False", "response": "Returns whether an image needs pushing on the registry"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef image_needs_building(image):\n    d = docker_client()\n\n    # first, check for locally built image\n    try:\n        d.images.get(image)\n    except docker.errors.ImageNotFound:\n        # image not found, check registry\n        pass\n    else:\n        # it exists locally, no need to check remote\n        return False\n\n    # image may need building if it's not on the registry\n    return image_needs_pushing(image)", "response": "Returns whether an image needs building"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nbuild a collection of docker images with the given prefix.", "response": "def build_images(prefix, images, tag=None, commit_range=None, push=False, chart_version=None):\n    \"\"\"Build a collection of docker images\n\n    Args:\n    prefix (str): the prefix to add to images\n    images (dict): dict of image-specs from chartpress.yml\n    tag (str):\n        Specific tag to use instead of the last modified commit.\n        If unspecified the tag for each image will be the hash of the last commit\n        to modify the image's files.\n    commit_range (str):\n        The range of commits to consider, e.g. for building in CI.\n        If an image hasn't changed in the given range,\n        it will not be rebuilt.\n    push (bool):\n        Whether to push the resulting images (default: False).\n    chart_version (str):\n        The chart version, included as a prefix on image tags\n        if `tag` is not specified.\n    \"\"\"\n    value_modifications = {}\n    for name, options in images.items():\n        image_path = options.get('contextPath', os.path.join('images', name))\n        image_tag = tag\n        # include chartpress.yaml itself as it can contain build args and\n        # similar that influence the image that would be built\n        paths = list(options.get('paths', [])) + [image_path, 'chartpress.yaml']\n        last_commit = last_modified_commit(*paths)\n        if tag is None:\n            if chart_version:\n                image_tag = \"{}-{}\".format(chart_version, last_commit)\n            else:\n                image_tag = last_commit\n        image_name = prefix + name\n        image_spec = '{}:{}'.format(image_name, image_tag)\n\n        value_modifications[options['valuesPath']] = {\n            'repository': image_name,\n            'tag': SingleQuotedScalarString(image_tag),\n        }\n\n        template_namespace = {\n            'LAST_COMMIT': last_commit,\n            'TAG': image_tag,\n        }\n\n        if tag or image_needs_building(image_spec):\n            build_args = render_build_args(options, template_namespace)\n            build_image(image_path, image_spec, build_args, options.get('dockerfilePath'))\n        else:\n            print(f\"Skipping build for {image_spec}, it already exists\")\n\n        if push:\n            if tag or image_needs_pushing(image_spec):\n                check_call([\n                    'docker', 'push', image_spec\n                ])\n            else:\n                print(f\"Skipping push for {image_spec}, already on registry\")\n    return value_modifications"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef build_values(name, values_mods):\n    values_file = os.path.join(name, 'values.yaml')\n\n    with open(values_file) as f:\n        values = yaml.load(f)\n\n    for key, value in values_mods.items():\n        parts = key.split('.')\n        mod_obj = values\n        for p in parts:\n            mod_obj = mod_obj[p]\n        print(f\"Updating {values_file}: {key}: {value}\")\n\n        if isinstance(mod_obj, MutableMapping):\n            keys = IMAGE_REPOSITORY_KEYS & mod_obj.keys()\n            if keys:\n                for key in keys:\n                    mod_obj[key] = value['repository']\n            else:\n                possible_keys = ' or '.join(IMAGE_REPOSITORY_KEYS)\n                raise KeyError(\n                    f'Could not find {possible_keys} in {values_file}:{key}'\n                )\n\n            mod_obj['tag'] = value['tag']\n        else:\n            raise TypeError(\n                f'The key {key} in {values_file} must be a mapping.'\n            )\n\n\n    with open(values_file, 'w') as f:\n        yaml.dump(values, f)", "response": "Build the values. yaml file for the given name and modifications."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef build_chart(name, version=None, paths=None):\n    chart_file = os.path.join(name, 'Chart.yaml')\n    with open(chart_file) as f:\n        chart = yaml.load(f)\n\n    if version is None:\n        if paths is None:\n            paths = ['.']\n        commit = last_modified_commit(*paths)\n        version = chart['version'].split('-')[0] + '-' + commit\n\n    chart['version'] = version\n\n    with open(chart_file, 'w') as f:\n        yaml.dump(chart, f)\n\n    return version", "response": "Build a new chart with specified version or last - modified commit in path list."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef publish_pages(name, paths, git_repo, published_repo, extra_message=''):\n    version = last_modified_commit(*paths)\n    checkout_dir = '{}-{}'.format(name, version)\n    check_call([\n        'git', 'clone', '--no-checkout',\n        git_remote(git_repo), checkout_dir],\n        echo=False,\n    )\n    check_call(['git', 'checkout', 'gh-pages'], cwd=checkout_dir)\n\n    # package the latest version into a temporary directory\n    # and run helm repo index with --merge to update index.yaml\n    # without refreshing all of the timestamps\n    with TemporaryDirectory() as td:\n        check_call([\n            'helm', 'package', name,\n            '--destination', td + '/',\n        ])\n\n        check_call([\n            'helm', 'repo', 'index', td,\n            '--url', published_repo,\n            '--merge', os.path.join(checkout_dir, 'index.yaml'),\n        ])\n\n        # equivalent to `cp td/* checkout/`\n        # copies new helm chart and updated index.yaml\n        for f in os.listdir(td):\n            shutil.copy2(\n                os.path.join(td, f),\n                os.path.join(checkout_dir, f)\n            )\n    check_call(['git', 'add', '.'], cwd=checkout_dir)\n    if extra_message:\n        extra_message = '\\n\\n%s' % extra_message\n    else:\n        extra_message = ''\n    check_call([\n        'git',\n        'commit',\n        '-m', '[{}] Automatic update for commit {}{}'.format(name, version, extra_message)\n    ], cwd=checkout_dir)\n    check_call(\n        ['git', 'push', 'origin', 'gh-pages'],\n        cwd=checkout_dir,\n    )", "response": "Publish the given list of paths to github pages"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef main():\n    argparser = argparse.ArgumentParser(description=__doc__)\n\n    argparser.add_argument('--commit-range',\n        help='Range of commits to consider when building images')\n    argparser.add_argument('--push', action='store_true',\n        help='push built images to docker hub')\n    argparser.add_argument('--publish-chart', action='store_true',\n        help='publish updated chart to gh-pages')\n    argparser.add_argument('--tag', default=None,\n        help='Use this tag for images & charts')\n    argparser.add_argument('--extra-message', default='',\n        help='extra message to add to the commit message when publishing charts')\n    argparser.add_argument('--image-prefix', default=None,\n        help='override image prefix with this value')\n\n    args = argparser.parse_args()\n\n    with open('chartpress.yaml') as f:\n        config = yaml.load(f)\n\n    for chart in config['charts']:\n        chart_paths = ['.'] + list(chart.get('paths', []))\n\n        version = args.tag\n        if version:\n            # version of the chart shouldn't have leading 'v' prefix\n            # if tag is of the form 'v1.2.3'\n            version = version.lstrip('v')\n        chart_version = build_chart(chart['name'], paths=chart_paths, version=version)\n\n        if 'images' in chart:\n            image_prefix = args.image_prefix if args.image_prefix is not None else chart['imagePrefix']\n            value_mods = build_images(\n                prefix=image_prefix,\n                images=chart['images'],\n                tag=args.tag,\n                commit_range=args.commit_range,\n                push=args.push,\n                # exclude `-<hash>` from chart_version prefix for images\n                chart_version=chart_version.split('-', 1)[0],\n            )\n            build_values(chart['name'], value_mods)\n\n        if args.publish_chart:\n            publish_pages(chart['name'],\n                paths=chart_paths,\n                git_repo=chart['repo']['git'],\n                published_repo=chart['repo']['published'],\n                extra_message=args.extra_message,\n            )", "response": "Main function for the chartpress script"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef create_custom_field(connection, cf_type, cf_name, auto_attached, value_names=None, bundle_policy=\"0\"):\n    if (value_names is None) and (not auto_attached or \"[\" not in cf_type):\n        _create_custom_field_prototype(connection, cf_type, cf_name, auto_attached)\n        return\n    if value_names is None:\n        value_names = set([])\n    else:\n        value_names = set(value_names)\n    field = _get_custom_field(connection, cf_name)\n    if field is not None:\n        if hasattr(field, \"defaultBundle\"):\n            bundle = connection.get_bundle(field.type, field.defaultBundle)\n        elif field.autoAttached:\n            return\n        else:\n            bundle = create_bundle_safe(connection, cf_name + \"_bundle\", cf_type)\n    else:\n        bundle = create_bundle_safe(connection, cf_name + \"_bundle\", cf_type)\n        _create_custom_field_prototype(connection, cf_type, cf_name, auto_attached,\n                                       {\"defaultBundle\": bundle.name,\n                                        \"attachBundlePolicy\": bundle_policy})\n    for value_name in value_names:\n        try:\n            connection.add_value_to_bundle(bundle, value_name)\n        except YouTrackException:\n            pass", "response": "Creates a custom field prototype and sets default values bundle if needed."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nprocesses a custom field.", "response": "def process_custom_field(connection, project_id, cf_type, cf_name, value_names=None):\n    \"\"\"\n    Creates custom field and attaches it to the project. If custom field already exists and has type\n    cf_type it is attached to the project. If it has another type, LogicException is raised. If project field already\n    exists, uses it and bundle from it. If not, creates project field and bundle with name\n    <cf_name>_bundle_<project_id> for it.\n    Adds value_names to bundle.\n    Args:\n        connection: An opened Connection instance.\n        project_id: Id of the project to attach CF to.\n        cf_type: Type of cf to be created.\n        cf_name: Name of cf that should be created (if not exists) and attached to the project (if not yet attached)\n        value_names: Values, that cf must have. If None, does not create any bundle for the field. If empty list,\n                     creates bundle, but does not create any value_names in it. If bundle already contains\n                     some value_names, only value_names that do not already exist are added.\n\n    Raises:\n        LogicException: If custom field already exists, but has wrong type.\n        YouTrackException: If something is wrong with queries.\n    \"\"\"\n\n    _create_custom_field_prototype(connection, cf_type, cf_name)\n    if cf_type[0:-3] not in connection.bundle_types:\n        value_names = None\n    elif value_names is None:\n        value_names = []\n\n    existing_project_fields = [item for item in connection.getProjectCustomFields(project_id) if\n                               utf8encode(item.name) == cf_name]\n    if len(existing_project_fields):\n        if value_names is None:\n            return\n        bundle = connection.getBundle(cf_type, existing_project_fields[0].bundle)\n        values_to_add = calculate_missing_value_names(bundle, value_names)\n    else:\n        if value_names is None:\n            connection.createProjectCustomFieldDetailed(project_id, cf_name, \"No \" + cf_name)\n            return\n        bundle = create_bundle_safe(connection, cf_name + \"_bundle_\" + project_id, cf_type)\n        values_to_add = calculate_missing_value_names(bundle, value_names)\n        connection.createProjectCustomFieldDetailed(project_id, cf_name, \"No \" + cf_name,\n                                                    params={\"bundle\": bundle.name})\n    for name in values_to_add:\n        connection.addValueToBundle(bundle, bundle.createElement(name))"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nadds values to specified bundle.", "response": "def add_values_to_bundle_safe(connection, bundle, values):\n    \"\"\"\n    Adds values to specified bundle. Checks, whether each value already contains in bundle. If yes, it is not added.\n\n    Args:\n        connection: An opened Connection instance.\n        bundle: Bundle instance to add values in.\n        values: Values, that should be added in bundle.\n\n    Raises:\n        YouTrackException: if something is wrong with queries.\n    \"\"\"\n    for value in values:\n        try:\n            connection.addValueToBundle(bundle, value)\n        except YouTrackException as e:\n            if e.response.status == 409:\n                print(\"Value with name [ %s ] already exists in bundle [ %s ]\" %\n                      (utf8encode(value.name), utf8encode(bundle.name)))\n            else:\n                raise e"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef parse(self, stream, media_type=None, parser_context=None):\n        assert yaml, 'YAMLParser requires pyyaml to be installed'\n\n        parser_context = parser_context or {}\n        encoding = parser_context.get('encoding', settings.DEFAULT_CHARSET)\n\n        try:\n            data = stream.read().decode(encoding)\n            return yaml.safe_load(data)\n        except (ValueError, yaml.parser.ParserError) as exc:\n            raise ParseError('YAML parse error - %s' % six.text_type(exc))", "response": "Parses the incoming bytestream as YAML and returns the resulting data."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nrendering data into serialized YAML.", "response": "def render(self, data, accepted_media_type=None, renderer_context=None):\n        \"\"\"\n        Renders `data` into serialized YAML.\n        \"\"\"\n        assert yaml, 'YAMLRenderer requires pyyaml to be installed'\n\n        if data is None:\n            return ''\n\n        return yaml.dump(\n            data,\n            stream=None,\n            encoding=self.charset,\n            Dumper=self.encoder,\n            allow_unicode=not self.ensure_ascii,\n            default_flow_style=self.default_flow_style\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef create_closure_model(cls):\n    meta_vals = {\n        'unique_together':  ((\"parent\", \"child\"),)\n    }\n    if getattr(cls._meta, 'db_table', None):\n        meta_vals['db_table'] = '%sclosure' % getattr(cls._meta, 'db_table')\n    model = type('%sClosure' % cls.__name__, (models.Model,), {\n        'parent': models.ForeignKey(\n            cls.__name__,\n            related_name=cls.closure_parentref()\n        ),\n        'child': models.ForeignKey(\n            cls.__name__,\n            related_name=cls.closure_childref()\n        ),\n        'depth': models.IntegerField(),\n        '__module__':   cls.__module__,\n        '__unicode__': _closure_model_unicode,\n        'Meta': type('Meta', (object,), meta_vals),\n    })\n    setattr(cls, \"_closure_model\", model)\n    return model", "response": "Creates a <Model >Closure model in the same module as the model."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _toplevel(cls):\n        superclasses = (\n            list(set(ClosureModel.__subclasses__()) &\n                 set(cls._meta.get_parent_list()))\n        )\n        return next(iter(superclasses)) if superclasses else cls", "response": "Find the top level of the chain we re in."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nregenerate the entire closuretree.", "response": "def rebuildtable(cls):\n        \"\"\"Regenerate the entire closuretree.\"\"\"\n        cls._closure_model.objects.all().delete()\n        cls._closure_model.objects.bulk_create([cls._closure_model(\n            parent_id=x['pk'],\n            child_id=x['pk'],\n            depth=0\n        ) for x in cls.objects.values(\"pk\")])\n        for node in cls.objects.all():\n            node._closure_createlink()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nremoving incorrect links from the closure tree.", "response": "def _closure_deletelink(self, oldparentpk):\n        \"\"\"Remove incorrect links from the closure tree.\"\"\"\n        self._closure_model.objects.filter(\n            **{\n                \"parent__%s__child\" % self._closure_parentref(): oldparentpk,\n                \"child__%s__parent\" % self._closure_childref(): self.pk\n            }\n        ).delete()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating a link in the closure tree.", "response": "def _closure_createlink(self):\n        \"\"\"Create a link in the closure tree.\"\"\"\n        linkparents = self._closure_model.objects.filter(\n            child__pk=self._closure_parent_pk\n        ).values(\"parent\", \"depth\")\n        linkchildren = self._closure_model.objects.filter(\n            parent__pk=self.pk\n        ).values(\"child\", \"depth\")\n        newlinks = [self._closure_model(\n            parent_id=p['parent'],\n            child_id=c['child'],\n            depth=p['depth']+c['depth']+1\n        ) for p in linkparents for c in linkchildren]\n        self._closure_model.objects.bulk_create(newlinks)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning all the ancestors of this object.", "response": "def get_ancestors(self, include_self=False, depth=None):\n        \"\"\"Return all the ancestors of this object.\"\"\"\n        if self.is_root_node():\n            if not include_self:\n                return self._toplevel().objects.none()\n            else:\n                # Filter on pk for efficiency.\n                return self._toplevel().objects.filter(pk=self.pk)\n\n        params = {\"%s__child\" % self._closure_parentref():self.pk}\n        if depth is not None:\n            params[\"%s__depth__lte\" % self._closure_parentref()] = depth\n        ancestors = self._toplevel().objects.filter(**params)\n        if not include_self:\n            ancestors = ancestors.exclude(pk=self.pk)\n        return ancestors.order_by(\"%s__depth\" % self._closure_parentref())"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn all the descendants of this object.", "response": "def get_descendants(self, include_self=False, depth=None):\n        \"\"\"Return all the descendants of this object.\"\"\"\n        params = {\"%s__parent\" % self._closure_childref():self.pk}\n        if depth is not None:\n            params[\"%s__depth__lte\" % self._closure_childref()] = depth\n        descendants = self._toplevel().objects.filter(**params)\n        if not include_self:\n            descendants = descendants.exclude(pk=self.pk)\n        return descendants.order_by(\"%s__depth\" % self._closure_childref())"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn all the children of this object.", "response": "def get_children(self):\n        \"\"\"Return all the children of this object.\"\"\"\n        if hasattr(self, '_cached_children'):\n            children = self._toplevel().objects.filter(\n                pk__in=[n.pk for n in self._cached_children]\n            )\n            children._result_cache = self._cached_children\n            return children\n        else:\n            return self.get_descendants(include_self=False, depth=1)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the furthest ancestor of this node.", "response": "def get_root(self):\n        \"\"\"Return the furthest ancestor of this node.\"\"\"\n        if self.is_root_node():\n            return self\n\n        return self.get_ancestors().order_by(\n            \"-%s__depth\" % self._closure_parentref()\n        )[0]"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nis this node a descendant of other?", "response": "def is_descendant_of(self, other, include_self=False):\n        \"\"\"Is this node a descendant of `other`?\"\"\"\n        if other.pk == self.pk:\n            return include_self\n\n        return self._closure_model.objects.filter(\n            parent=other,\n            child=self\n        ).exclude(pk=self.pk).exists()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef is_ancestor_of(self, other, include_self=False):\n        return other.is_descendant_of(self, include_self=include_self)", "response": "Is this node an ancestor of other?"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef quantize(number, digits=0, q=builtins.round):\n    base, fraction = split(digits)\n\n    # quantization beyond an order of magnitude results in a variable amount\n    # of decimal digits depending on the lowest common multiple,\n    # e.g. floor(1.2341234, 1.25) = 1.225 but floor(1.2341234, 1.5) = 1.20\n    if fraction * 10 % 1 > 0:\n        digits = base + 2\n    else:\n        digits = base + 1\n\n    multiplier = 10 ** base * invert(fraction, default=1)\n    quantized = q(number * multiplier) / multiplier\n\n    # additional rounding step to get rid of floating point math wonkiness\n    return builtins.round(quantized, digits)", "response": "Quantize a number to a number of digits."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef vectorize(fn):\n\n    @functools.wraps(fn)\n    def vectorized_function(values, *vargs, **kwargs):\n        return [fn(value, *vargs, **kwargs) for value in values]\n\n    return vectorized_function", "response": "A method that accepts a list argument but internally deal only\n    with a single item of that list."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nconverting a number to engineering notation.", "response": "def engineering(value, precision=3, prefix=False, prefixes=SI):\n    \"\"\" Convert a number to engineering notation. \"\"\"\n\n    display = decimal.Context(prec=precision)\n    value = decimal.Decimal(value).normalize(context=display)\n    string = value.to_eng_string()\n\n    if prefix:\n        prefixes = {e(exponent): prefix for exponent, prefix in prefixes.items()}\n        return replace(string, prefixes)\n    else:\n        return string"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nconverting a list of numbers to the business notation appropriate to the reference point.", "response": "def business(values, precision=3, prefix=True, prefixes=SI, statistic=median, default=''):\n    \"\"\"\n    Convert a list of numbers to the engineering notation appropriate to a\n    reference point like the minimum, the median or the mean --\n    think of it as \"business notation\".\n\n    Any number will have at most the amount of significant digits of the\n    reference point, that is, the function will round beyond the\n    decimal point.\n\n    For example, if the reference is `233K`, this function will turn\n    1,175,125 into `1180K` and 11,234 into `11K` (instead of 1175K and\n    11.2K respectively.) This can help enormously with readability.\n\n    If the reference point is equal to or larger than E15 or\n    equal to or smaller than E-15, E12 and E-12 become the\n    reference point instead. (Petas and femtos are too\n    unfamiliar to people to be easily comprehended.)\n    \"\"\"\n\n    reference = statistic(values)\n\n    if not reference:\n        return upcast([''] * len(values), values)\n\n    exponent = order(reference)\n    e = bound(exponent - exponent % 3, -12, 12)\n    # the amount of decimals is the precision minus the amount of digits\n    # before the decimal point, which is one more than the relative order\n    # of magnitude (for example, 10^5 can be represented as 100K, with\n    # those three digits representing place values of 10^3, 10^4 and 10^5)\n    d = precision - (1 + exponent - e)\n\n    prefix = prefixes[e]\n\n    strings = []\n    for value in values:\n        if isnan(value):\n            strings.append('')\n        else:\n            normalized = value / 10.0 ** e\n            # use `round` for rounding (beyond the decimal point if necessary)\n            # use string formatting for padding to the right amount of decimals\n            # and to hide decimals when necessary (by default, floats are always\n            # displayed with a single decimal place, to distinguish them from\n            # integers)\n            relative_order = order(value) - exponent\n            places = min(d - relative_order, d)\n            normalized = round(normalized, places)\n            strings.append('{0:,.{1}f}'.format(normalized, d) + prefix)\n\n    return upcast(strings, values)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nyielding items from iterator in chunks of size chunksize.", "response": "def chunked(iterator, chunksize):\n    \"\"\"\n    Yields items from 'iterator' in chunks of size 'chunksize'.\n\n    >>> list(chunked([1, 2, 3, 4, 5], chunksize=2))\n    [(1, 2), (3, 4), (5,)]\n    \"\"\"\n    chunk = []\n    for idx, item in enumerate(iterator, 1):\n        chunk.append(item)\n        if idx % chunksize == 0:\n            yield chunk\n            chunk = []\n    if chunk:\n        yield chunk"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef pre_start_check(self):\n        try:\n            sock = socket.socket()\n            sock.connect((self.host, self.port))\n            return True\n        except (socket.error, socket.timeout):\n            return False\n        finally:\n            # close socket manually for sake of PyPy\n            sock.close()", "response": "Check if process can accept TCP connections."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef after_start_check(self):\n        try:\n            conn = HTTPConnection(self.host, self.port)\n\n            conn.request('HEAD', self.url.path)\n            status = str(conn.getresponse().status)\n\n            if status == self.status or self.status_re.match(status):\n                conn.close()\n                return True\n\n        except (HTTPException, socket.timeout, socket.error):\n            return False", "response": "Check if defined URL returns expected status to a HEAD request."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nstart the output process.", "response": "def start(self):\n        \"\"\"\n        Start process.\n\n        :returns: itself\n        :rtype: OutputExecutor\n\n        .. note::\n\n            Process will be considered started, when defined banner will appear\n            in process output.\n        \"\"\"\n        super(OutputExecutor, self).start()\n\n        # get a polling object\n        self.poll_obj = select.poll()\n\n        # register a file descriptor\n        # POLLIN because we will wait for data to read\n        self.poll_obj.register(self.output(), select.POLLIN)\n\n        try:\n            self.wait_for(self._wait_for_output)\n\n            # unregister the file descriptor and delete the polling object\n            self.poll_obj.unregister(self.output())\n        finally:\n            del self.poll_obj\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nchecks if output matches banner.", "response": "def _wait_for_output(self):\n        \"\"\"\n        Check if output matches banner.\n\n        .. warning::\n            Waiting for I/O completion. It does not work on Windows. Sorry.\n        \"\"\"\n        # Here we should get an empty list or list with a tuple [(fd, event)]\n        # When we get list with a tuple we can use readline method on\n        # the file descriptor.\n        poll_result = self.poll_obj.poll(0)\n\n        if poll_result:\n            line = self.output().readline()\n            if self._banner.match(line):\n                return True\n\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nconstructs a new email object", "response": "def construct_mail(recipients=None, context=None, template_base='emailit/email', subject=None, message=None, site=None,\n                   subject_templates=None, body_templates=None, html_templates=None, from_email=None, language=None,\n                   **kwargs):\n    \"\"\"\n    usage:\n    construct_mail(['my@email.com'], {'my_obj': obj}, template_base='myapp/emails/my_obj_notification').send()\n    :param recipients: recipient or list of recipients\n    :param context: context for template rendering\n    :param template_base: the base template. '.subject.txt', '.body.txt' and '.body.html' will be added\n    :param subject: optional subject instead of rendering it through a template\n    :param message: optional message (will be inserted into the base email template)\n    :param site: the site this is on. uses current site by default\n    :param subject_templates: override the subject template\n    :param body_templates: override the body template\n    :param html_templates: override the html body template\n    :param from_email: defaults to settings.DEFAULT_FROM_EMAIL\n    :param language: the language that should be active for this email. defaults to currently active lang\n    :param kwargs: kwargs to pass into the Email class\n    :return:\n    \"\"\"\n    language = language or translation.get_language()\n    with force_language(language):\n        recipients = recipients or []\n        if isinstance(recipients, basestring):\n            recipients = [recipients]\n        from_email = from_email or settings.DEFAULT_FROM_EMAIL\n        subject_templates = subject_templates or get_template_names(language, template_base, 'subject', 'txt')\n        body_templates = body_templates or get_template_names(language, template_base, 'body', 'txt')\n        html_templates = html_templates or get_template_names(language, template_base, 'body', 'html')\n\n        if not context:\n            context = {}\n\n        site = site or Site.objects.get_current()\n        context['site'] = site\n        context['site_name'] = site.name\n        protocol = 'http'  # TODO: this should come from settings\n        base_url = \"%s://%s\" % (protocol, site.domain)\n        if message:\n            context['message'] = message\n\n        subject = subject or render_to_string(subject_templates, context)\n        subject = subject.replace('\\n', '').replace('\\r', '').strip()\n        context['subject'] = subject\n        try:\n            html = render_to_string(html_templates, context)\n        except TemplateDoesNotExist:\n            html = ''\n        else:\n            html = premailer.transform(html, base_url=base_url)\n        try:\n            body = render_to_string(body_templates, context)\n        except TemplateDoesNotExist:\n            body = ''\n\n        mail = EmailMultiAlternatives(subject, body, from_email, recipients, **kwargs)\n\n        if not (body or html):\n            # this is so a meaningful exception can be raised\n            render_to_string([html_templates], context)\n            render_to_string([body_templates], context)\n\n        if html:\n            mail.attach_alternative(html, 'text/html')\n    return mail"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef cleanup_subprocesses():\n    # pylint: disable=redefined-outer-name, reimported\n    # atexit functions tends to loose global imports sometimes so reimport\n    # everything what is needed again here:\n    import os\n    import errno\n    from mirakuru.base_env import processes_with_env\n    from mirakuru.compat import SIGKILL\n\n    pids = processes_with_env(ENV_UUID, str(os.getpid()))\n    for pid in pids:\n        try:\n            os.kill(pid, SIGKILL)\n        except OSError as err:\n            if err.errno != errno.ESRCH:\n                print(\"Can not kill the\", pid, \"leaked process\", err)", "response": "On python exit kill all processes that are running."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nstarting the countdown process.", "response": "def start(self):\n        \"\"\"\n        Start defined process.\n\n        After process gets started, timeout countdown begins as well.\n\n        :returns: itself\n        :rtype: SimpleExecutor\n\n        .. note::\n            We want to open ``stdin``, ``stdout`` and ``stderr`` as text\n            streams in universal newlines mode, so we have to set\n            ``universal_newlines`` to ``True``.\n        \"\"\"\n        if self.process is None:\n            command = self.command\n            if not self._shell:\n                command = self.command_parts\n\n            env = os.environ.copy()\n            # Trick with marking subprocesses with an environment variable.\n            #\n            # There is no easy way to recognize all subprocesses that were\n            # spawned during lifetime of a certain subprocess so mirakuru does\n            # this hack in order to mark who was the original parent. Even if\n            # some subprocess got daemonized or changed original process group\n            # mirakuru will be able to find it by this environment variable.\n            #\n            # There may be a situation when some subprocess will abandon\n            # original envs from parents and then it won't be later found.\n            env[ENV_UUID] = self._uuid\n            popen_kwargs = {\n                'shell': self._shell,\n                'stdin': subprocess.PIPE,\n                'stdout': subprocess.PIPE,\n                'universal_newlines': True,\n                'env': env,\n            }\n            if platform.system() != 'Windows':\n                popen_kwargs['preexec_fn'] = os.setsid\n            self.process = subprocess.Popen(\n                command,\n                **popen_kwargs\n            )\n\n        self._set_timeout()\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nclear the process object.", "response": "def _clear_process(self):\n        \"\"\"\n        Close stdin/stdout of subprocess.\n\n        It is required because of ResourceWarning in Python 3.\n        \"\"\"\n        if self.process:\n            if self.process.stdin:\n                self.process.stdin.close()\n            if self.process.stdout:\n                self.process.stdout.close()\n\n            self.process = None\n\n        self._endtime = None"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _kill_all_kids(self, sig):\n        pids = processes_with_env(ENV_UUID, self._uuid)\n        for pid in pids:\n            log.debug(\"Killing process %d ...\", pid)\n            try:\n                os.kill(pid, sig)\n            except OSError as err:\n                if err.errno in IGNORED_ERROR_CODES:\n                    # the process has died before we tried to kill it.\n                    pass\n                else:\n                    raise\n            log.debug(\"Killed process %d.\", pid)\n        return pids", "response": "Kill all processes that have started and have left."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef kill(self, wait=True, sig=None):\n        if sig is None:\n            sig = self._sig_kill\n        if self.running():\n            os.killpg(self.process.pid, sig)\n            if wait:\n                self.process.wait()\n\n        self._kill_all_kids(sig)\n        self._clear_process()\n        return self", "response": "Kill the process if running."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nwaits for a callback to return True.", "response": "def wait_for(self, wait_for):\n        \"\"\"\n        Wait for callback to return True.\n\n        Simply returns if wait_for condition has been met,\n        raises TimeoutExpired otherwise and kills the process.\n\n        :param callback wait_for: callback to call\n        :raises: mirakuru.exceptions.TimeoutExpired\n        :returns: itself\n        :rtype: SimpleExecutor\n        \"\"\"\n        while self.check_timeout():\n            if wait_for():\n                return self\n            time.sleep(self._sleep)\n\n        self.kill()\n        raise TimeoutExpired(self, timeout=self._timeout)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef start(self):\n        if self.pre_start_check():\n            # Some other executor (or process) is running with same config:\n            raise AlreadyRunning(self)\n\n        super(Executor, self).start()\n\n        self.wait_for(self.check_subprocess)\n        return self", "response": "Start executor with additional checks."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nchecking the status of the main process and run the checks.", "response": "def check_subprocess(self):\n        \"\"\"\n        Make sure the process didn't exit with an error and run the checks.\n\n        :rtype: bool\n        :return: the actual check status\n        :raise ProcessExitedWithError: when the main process exits with\n            an error\n        \"\"\"\n        exit_code = self.process.poll()\n        if exit_code is not None and exit_code != 0:\n            # The main process exited with an error. Clean up the children\n            # if any.\n            self._kill_all_kids(self._sig_kill)\n            self._clear_process()\n            raise ProcessExitedWithError(self, exit_code)\n\n        return self.after_start_check()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nfind processes with environment variable matching given one.", "response": "def processes_with_env_psutil(env_name, env_value):\n    \"\"\"\n    Find PIDs of processes having environment variable matching given one.\n\n    Internally it uses `psutil` library.\n\n    :param str env_name: name of environment variable to be found\n    :param str env_value: environment variable value prefix\n    :return: process identifiers (PIDs) of processes that have certain\n             environment variable equal certain value\n    :rtype: set\n    \"\"\"\n    pids = set()\n\n    for proc in psutil.process_iter():\n        try:\n            pinfo = proc.as_dict(attrs=['pid', 'environ'])\n        except (psutil.NoSuchProcess, IOError):\n            # can't do much if psutil is not able to get this process details\n            pass\n        else:\n            penv = pinfo.get('environ')\n            if penv and env_value in penv.get(env_name, ''):\n                pids.add(pinfo['pid'])\n\n    return pids"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nfinding processes with environment variable matching given one.", "response": "def processes_with_env_ps(env_name, env_value):\n    \"\"\"\n    Find PIDs of processes having environment variable matching given one.\n\n    It uses `$ ps xe -o pid,cmd` command so it works only on systems\n    having such command available (Linux, MacOS). If not available function\n    will just log error.\n\n    :param str env_name: name of environment variable to be found\n    :param str env_value: environment variable value prefix\n    :return: process identifiers (PIDs) of processes that have certain\n             environment variable equal certain value\n    :rtype: set\n    \"\"\"\n    pids = set()\n    ps_xe = ''\n    try:\n        cmd = 'ps', 'xe', '-o', 'pid,cmd'\n        ps_xe = subprocess.check_output(cmd).splitlines()\n    except OSError as err:\n        if err.errno == errno.ENOENT:\n            log.error(\"`$ ps xe -o pid,cmd` command was called but it is not \"\n                      \"available on this operating system. Mirakuru will not \"\n                      \"be able to list the process tree and find if there are \"\n                      \"any leftovers of the Executor.\")\n            return pids\n    except subprocess.CalledProcessError:\n        log.error(\"`$ ps xe -o pid,cmd` command exited with non-zero code.\")\n\n    env = '{0}={1}'.format(env_name, env_value)\n\n    for line in ps_xe:\n        line = str(line)\n        if env in line:\n            pids.add(int(PS_XE_PID_MATCH.match(line).group(1)))\n    return pids"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncomputes the NCC of a 2D array.", "response": "def _ncc_c(x, y):\n    \"\"\"\n    >>> _ncc_c([1,2,3,4], [1,2,3,4])\n    array([ 0.13333333,  0.36666667,  0.66666667,  1.        ,  0.66666667,\n            0.36666667,  0.13333333])\n    >>> _ncc_c([1,1,1], [1,1,1])\n    array([ 0.33333333,  0.66666667,  1.        ,  0.66666667,  0.33333333])\n    >>> _ncc_c([1,2,3], [-1,-1,-1])\n    array([-0.15430335, -0.46291005, -0.9258201 , -0.77151675, -0.46291005])\n    \"\"\"\n    den = np.array(norm(x) * norm(y))\n    den[den == 0] = np.Inf\n\n    x_len = len(x)\n    fft_size = 1 << (2*x_len-1).bit_length()\n    cc = ifft(fft(x, fft_size) * np.conj(fft(y, fft_size)))\n    cc = np.concatenate((cc[-(x_len-1):], cc[:x_len]))\n    return np.real(cc) / den"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _ncc_c_2dim(x, y):\n    den = np.array(norm(x, axis=1) * norm(y))\n    den[den == 0] = np.Inf\n    x_len = x.shape[-1]\n    fft_size = 1 << (2*x_len-1).bit_length()\n    cc = ifft(fft(x, fft_size) * np.conj(fft(y, fft_size)))\n    cc = np.concatenate((cc[:,-(x_len-1):], cc[:,:x_len]), axis=1)\n    return np.real(cc) / den[:, np.newaxis]", "response": "Variant of NCCc that operates with 2 dimensional X arrays and 1 dimensional\n    y vector\n    Returns a 2 dimensional array of normalized fourier transforms"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _ncc_c_3dim(x, y):\n    den = norm(x, axis=1)[:, None] * norm(y, axis=1)\n    den[den == 0] = np.Inf\n    x_len = x.shape[-1]\n    fft_size = 1 << (2*x_len-1).bit_length()\n    cc = ifft(fft(x, fft_size) * np.conj(fft(y, fft_size))[:, None])\n    cc = np.concatenate((cc[:,:,-(x_len-1):], cc[:,:,:x_len]), axis=2)\n    return np.real(cc) / den.T[:, :, None]", "response": "Variant of NCCc that operates with 2 dimensional X arrays and 2 dimensional y vector\n    Returns a 3 dimensional array of normalized fourier transforms"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _sbd(x, y):\n    ncc = _ncc_c(x, y)\n    idx = ncc.argmax()\n    dist = 1 - ncc[idx]\n    yshift = roll_zeropad(y, (idx + 1) - max(len(x), len(y)))\n\n    return dist, yshift", "response": "Compute the SVD distance and yshift for a single node."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _extract_shape(idx, x, j, cur_center):\n    _a = []\n    for i in range(len(idx)):\n        if idx[i] == j:\n            if cur_center.sum() == 0:\n                opt_x = x[i]\n            else:\n                _, opt_x = _sbd(cur_center, x[i])\n            _a.append(opt_x)\n    a = np.array(_a)\n\n    if len(a) == 0:\n        return np.zeros((1, x.shape[1]))\n    columns = a.shape[1]\n    y = zscore(a, axis=1, ddof=1)\n    s = np.dot(y.transpose(), y)\n\n    p = np.empty((columns, columns))\n    p.fill(1.0/columns)\n    p = np.eye(columns) - p\n\n    m = np.dot(np.dot(p, s), p)\n    _, vec = eigh(m)\n    centroid = vec[:, -1]\n    finddistance1 = math.sqrt(((a[0] - centroid) ** 2).sum())\n    finddistance2 = math.sqrt(((a[0] + centroid) ** 2).sum())\n\n    if finddistance1 >= finddistance2:\n        centroid *= -1\n\n    return zscore(centroid, ddof=1)", "response": "Returns the shape of the array of the array of the array at the given index."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _kshape(x, k):\n    m = x.shape[0]\n    idx = randint(0, k, size=m)\n    centroids = np.zeros((k, x.shape[1]))\n    distances = np.empty((m, k))\n\n    for _ in range(100):\n        old_idx = idx\n        for j in range(k):\n            centroids[j] = _extract_shape(idx, x, j, centroids[j])\n\n        distances = (1 - _ncc_c_3dim(x, centroids).max(axis=2)).T\n\n        idx = distances.argmin(1)\n        if np.array_equal(old_idx, idx):\n            break\n\n    return idx, centroids", "response": "Returns k - size of the randomized k - array"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget the internal version ID be the version.", "response": "def get_version_by_version_id(version_id):\n    \"\"\"\n    Get the internal version ID be the version.\n\n    :param Tuple version_id: Major and minor version number\n    :return: Internal version ID\n    :rtype: Integer|None\n    \"\"\"\n    for ver in registry.version_info:\n        if ver.version_id == version_id:\n            return ver.id\n\n    return None"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the name of a protocol version by the internal version ID.", "response": "def get_version_name(version_id):\n    \"\"\"\n    Get the name of a protocol version by the internal version ID.\n\n    :param Integer version_id: Internal protocol version ID\n    :return: Name of the version\n    :rtype: String\n    \"\"\"\n    ver = registry.version_info.get(version_id)\n    if ver:\n        return ver.name\n\n    return 'unknown'"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget a tuple with major and minor protocol version number.", "response": "def get_version_id(protocol_version):\n    \"\"\"\n    Get a tuple with major and minor version number\n\n    :param Integer protocol_version: Internal version ID\n    :return: Tuple of major and minor protocol version\n    :rtype: Tuple\n    \"\"\"\n    ver = registry.version_info.get(protocol_version)\n    if ver:\n        return ver.version_id"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef update(self, b):  # pylint: disable=method-hidden,invalid-name\n        with self.__lock:\n            output = compress_update(self.__ctx, b)\n            if self.__write:\n                self.__write(self.__header)\n                self.__header = None\n                self.__write(output)\n                self.update = self.__updateNextWrite\n            else:\n                header = self.__header\n                self.__header = None\n                self.update = self.__updateNextReturn\n                return header + output", "response": "Compress data given in b returning compressed result either from this function or writing to fp."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef end(self):\n        with self.__lock:\n            if self.__write:\n                self.__write(compress_end(self.__ctx))\n            else:\n                return compress_end(self.__ctx)", "response": "Finalise lz4 frame by writing any remaining as return from this function."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_value_name(self, pretty=False):\n        if pretty:\n            return \"%s (%x)\" % (\n                self.enums.get(self._value, \"n/a\"),\n                self._value\n            )\n\n        return self.enums.get(self._value, \"n/a\")", "response": "Get the name of the value of the n - A A"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef set_value(self, value, force=False):\n        if force:\n            self._value = value\n            return\n\n        if value is None:\n            self._value = value\n            return\n\n        if isinstance(value, six.integer_types):\n            self._value = value\n            return\n\n        if isinstance(value, six.string_types):\n            for v, n in self.enums.items():\n                if n == value:\n                    self._value = v\n                    return\n            raise ValueError(\"Unable to find value name in enum list\")\n\n        raise TypeError(\n            \"Value for '%s' must by of type String or Integer not '%s'\" % (\n                self.name,\n                type(value)\n            )\n        )", "response": "Set the value of the attribute."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef dissect(self, data):\n\n        size = struct.calcsize(\"B\")\n        if len(data) < size:\n            raise NotEnoughData(\n                \"Not enough data to decode field '%s' value\" % self.name\n            )\n\n        curve_type = struct.unpack(\"B\", data[:size])[0]\n        if curve_type == 0x03:\n            self._value = ECParametersNamedCurveField(\"none\")\n            data = self._value.dissect(data)\n        else:\n            raise NotImplementedError(\n                \"Decoding of KeyExchange message for curve 0x%.2X not implemented\" % curve_type\n            )\n        return data", "response": "Dissect the field value from the given bytes."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef compute_wcs(key, challenge):\n    key = key.encode('utf8')\n    challenge = challenge.encode('utf8')\n    sig = hmac.new(key, challenge, hashlib.sha256).digest()\n    return binascii.b2a_base64(sig).strip()", "response": "Compute an WAMP - CRA authentication signature from an authentication\n    challenge and a derived key."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nregister a procedure on a Client over the Router.", "response": "def _register_procedure(self, procedure_name, invocation_policy=\"single\"):\n        \"\"\" Register a \"procedure\" on a Client as callable over the Router.\n        \"\"\"\n        options = {\"invoke\": invocation_policy}\n        message = Register(procedure=procedure_name, options=options)\n        request_id = message.request_id\n\n        try:\n            self.send_message(message)\n        except ValueError:\n            raise WampProtocolError(\n                \"failed to register callee: %s\", procedure_name\n            )\n\n        self.request_ids[request_id] = procedure_name"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef start(self):\n        if self.started is True:\n            raise WampyError(\"Router already started\")\n\n        # will attempt to connect or start up the CrossBar\n        crossbar_config_path = self.config_path\n        cbdir = self.crossbar_directory\n\n        # starts the process from the root of the test namespace\n        cmd = [\n            'crossbar', 'start',\n            '--cbdir', cbdir,\n            '--config', crossbar_config_path,\n        ]\n\n        self.proc = subprocess.Popen(cmd, preexec_fn=os.setsid)\n\n        self._wait_until_ready()\n        logger.info(\n            \"Crosbar.io is ready for connections on %s (IPV%s)\",\n            self.url, self.ipv\n        )\n\n        self.started = True", "response": "Start the Crossbar. io process."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _get_handshake_headers(self, upgrade):\n        headers = []\n        # https://tools.ietf.org/html/rfc6455\n        headers.append(\"GET {} HTTP/1.1\".format(self.websocket_location))\n        headers.append(\"Host: {}:{}\".format(self.host, self.port))\n        headers.append(\"Upgrade: websocket\")\n        headers.append(\"Connection: Upgrade\")\n        # Sec-WebSocket-Key header containing base64-encoded random bytes,\n        # and the server replies with a hash of the key in the\n        # Sec-WebSocket-Accept header. This is intended to prevent a caching\n        # proxy from re-sending a previous WebSocket conversation and does not\n        # provide any authentication, privacy or integrity\n        headers.append(\"Sec-WebSocket-Key: {}\".format(self.key))\n        headers.append(\"Origin: ws://{}:{}\".format(self.host, self.port))\n        headers.append(\"Sec-WebSocket-Version: {}\".format(WEBSOCKET_VERSION))\n\n        if upgrade:\n            headers.append(\"Sec-WebSocket-Protocol: {}\".format(\n                WEBSOCKET_SUBPROTOCOLS)\n            )\n\n        logger.debug(\"connection headers: %s\", headers)\n\n        return headers", "response": "Return the HTTP upgrade handshake headers."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nparse a URL into a set of attributes.", "response": "def parse_url(self):\n        \"\"\" Parses a URL of the form:\n\n        - ws://host[:port][path]\n        - wss://host[:port][path]\n        - ws+unix:///path/to/my.socket\n\n        \"\"\"\n        self.scheme = None\n        self.resource = None\n        self.host = None\n        self.port = None\n\n        if self.url is None:\n            return\n\n        scheme, url = self.url.split(\":\", 1)\n        parsed = urlsplit(url, scheme=\"http\")\n        if parsed.hostname:\n            self.host = parsed.hostname\n        elif '+unix' in scheme:\n            self.host = 'localhost'\n        else:\n            raise ValueError(\"Invalid hostname from: %s\", self.url)\n\n        if parsed.port:\n            self.port = parsed.port\n\n        if scheme == \"ws\":\n            if not self.port:\n                self.port = 8080\n        elif scheme == \"wss\":\n            if not self.port:\n                self.port = 443\n        elif scheme in ('ws+unix', 'wss+unix'):\n            pass\n        else:\n            raise ValueError(\"Invalid scheme: %s\" % scheme)\n\n        if parsed.path:\n            resource = parsed.path\n        else:\n            resource = \"/\"\n\n        if '+unix' in scheme:\n            self.unix_socket_path = resource\n            resource = '/'\n\n        if parsed.query:\n            resource += \"?\" + parsed.query\n\n        self.scheme = scheme\n        self.resource = resource"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ngenerate a mask for the given key and data.", "response": "def generate_mask(cls, mask_key, data):\n        \"\"\" Mask data.\n\n        :Parameters:\n            mask_key: byte string\n                4 byte string(byte), e.g. '\\x10\\xc6\\xc4\\x16'\n            data: str\n                data to mask\n\n        \"\"\"\n        # Masking of WebSocket traffic from client to server is required\n        # because of the unlikely chance that malicious code could cause\n        # some broken proxies to do the wrong thing and use this as an\n        # attack of some kind. Nobody has proved that this could actually\n        # happen, but since the fact that it could happen was reason enough\n        # for browser vendors to get twitchy, masking was added to remove\n        # the possibility of it being used as an attack.\n        if data is None:\n            data = \"\"\n\n        data = bytearray(data, 'utf-8')\n\n        _m = array.array(\"B\", mask_key)\n        _d = array.array(\"B\", data)\n\n        for i in range(len(_d)):\n            _d[i] ^= _m[i % 4]\n\n        return _d.tostring()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef generate_bytes(cls, payload, fin_bit, opcode, mask_payload):\n        # the first byte contains the FIN bit, the 3 RSV bits and the\n        # 4 opcode bits and for a client will *always* be 1000 0001 (or 129).\n        # so we want the first byte to look like...\n        #\n        #  1 0 0 0 0 0 0 1   (1 is a text frame)\n        # +-+-+-+-+-------+\n        # |F|R|R|R| opcode|\n        # |I|S|S|S|       |\n        # |N|V|V|V|       |\n        # | |1|2|3|       |\n        # +-+-+-+-+-------+\n        # note that because all RSV bits are zero, we can ignore them\n\n        # this shifts each bit into position and bitwise ORs them together,\n        # using the struct module to pack them as incoming network bytes\n        frame = pack(\n            '!B', (\n                (fin_bit << 7) | opcode\n            )\n        )\n\n        # the second byte - and maybe the 7 after this, we'll use to tell\n        # the server how long our payload is.\n\n        #                 +-+-------------+-------------------------------+\n        #                 |M| Payload len |    Extended payload length    |\n        #                 |A|     (7)     |             (16/63)           |\n        #                 |S|             |   (if payload len==126/127)   |\n        #                 |K|             |                               |\n        # +-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +\n        # |     Extended payload length continued, if payload len == 127  |\n        # + - - - - - - - - - - - - - - - +-------------------------------+\n\n        # the mask is always included with client -> server, so the first bit\n        # of the second byte is always 1 which flags that the data is masked,\n        # i.e. encoded\n        if mask_payload:\n            mask_bit = 1 << 7\n        else:\n            mask_bit = 0 << 7\n        # next we have to | this bit with the payload length.\n        # note that we ensure that the payload is utf-8 encoded before we take\n        # the length because unicode characters can be >1 bytes in length and\n        # lead to bugs if we just do ``len(payload)``.\n        length = len(payload.encode('utf-8'))\n\n        if length >= Frame.MAX_LENGTH:\n            raise WebsocktProtocolError(\"data is too long\")\n\n        # the second byte contains the payload length and mask\n        if length < Frame.LENGTH_7:\n            # we can simply represent payload length with first 7 bits\n            frame += pack('!B', (mask_bit | length))\n        elif length < Frame.LENGTH_16:\n            frame += pack('!B', (mask_bit | 126)) + pack('!H', length)\n        else:\n            frame += pack('!B', (mask_bit | 127)) + pack('!Q', length)\n\n        if mask_payload:\n            # we always mask frames from the client to server\n            # use a string of n random buffered_bytes for the mask\n            mask_key = os.urandom(4)\n            mask_data = cls.generate_mask(mask_key=mask_key, data=payload)\n            mask = mask_key + mask_data\n            frame += mask\n        else:\n            frame += bytearray(payload, 'utf-8')\n\n        return bytearray(frame)", "response": "Generate the bytes for the current state of the entry in the cache."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nadd an edge to the internal set.", "response": "def add_edge(self, edge):\n        \"\"\"\n        Add edge (u, v) to the graph. Raises InvariantError if adding the edge\n        would form a cycle.\n        \"\"\"\n        u, v = edge\n\n        both_exist = u in self.vertices and v in self.vertices\n        # Using `is` because if they belong to the same component, they MUST\n        # share the same set object!\n        if both_exist and self.components[u] is self.components[v]:\n            # Both vertices are part of the same connected component.\n            raise InvariantError('Adding %r would form a cycle' % (edge,))\n        if u == v:\n            raise InvariantError('Cannot add loop: %r' % (edge,))\n\n        # Ensure the vertices exist in the graph.\n        self.add_vertex(u)\n        self.add_vertex(v)\n\n        # Add the edges to each other.\n        self._vertices[u].add(v)\n        self._vertices[v].add(u)\n\n        # Add all of the smaller components to the bigger one.\n        smaller_component, bigger_component = self.sort_components(u, v)\n        for vertex in smaller_component:\n            bigger_component.add(vertex)\n            # And with this assignment, say bye-bye to the smaller component.\n            self.components[vertex] = bigger_component"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef edges(self):\n        canonical_edges = set()\n        for v1, neighbours in self._vertices.items():\n            for v2 in neighbours:\n                edge = self.canonical_order((v1, v2))\n                canonical_edges.add(edge)\n        return canonical_edges", "response": "Returns a set of edges in canonical order."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef ordered_deduplicate(sequence):\n\n    seen = set()\n    # Micro optimization: each call to seen_add saves an extra attribute\n    # lookup in most iterations of the loop.\n    seen_add = seen.add\n\n    return tuple(x for x in sequence if not (x in seen or seen_add(x)))", "response": "Returns the sequence with the duplicates removed preserving input order."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef hash_parameters(words, minimize_indices=False):\n    # Ensure that we have an indexable sequence.\n    words = tuple(words)\n\n    # Delegate to the hash builder.\n    return CzechHashBuilder(words).hash_info", "response": "Returns a CzechHashBuilder object that can be used to generate the hash parameters for the given set of words."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating a pickable hash function for the given sequence of words.", "response": "def make_pickable_hash(words, *args, **kwargs):\n    \"\"\"\n    Creates an ordered, minimal perfect hash function for the given sequence\n    of words.\n\n    >>> hf = make_pickable_hash(['sun', 'mon', 'tue', 'wed', 'thu',\n    ...                          'fri', 'sat'])\n    >>> hf('fri')\n    5\n    >>> hf('sun')\n    0\n    \"\"\"\n    return PickableHash(CzechHashBuilder(words, *args, **kwargs)).czech_hash"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef make_dict(name, words, *args, **kwargs):\n\n    info = CzechHashBuilder(words, *args, **kwargs)\n\n    # Create a docstring that at least describes where the class came from...\n    doc = \"\"\"\n        Dictionary-like object that uses minimal perfect hashing, perserving\n        original order. This class was generated by `%s.%s(%r, ...)`.\n        \"\"\" % (__name__, make_dict.__name__, name)\n\n    # Delegate to create_dict.\n    return create_dict_subclass(name, info.hash_function, info.words, doc)", "response": "Create a dictionary from a sequence of words."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the hash function proper for the given object.", "response": "def hash_function(self):\n        \"\"\"\n        Returns the hash function proper. Ensures that `self` is not bound to\n        the returned closure.\n        \"\"\"\n        assert hasattr(self, 'f1') and hasattr(self, 'f2')\n\n        # These are not just convenient aliases for the given\n        # attributes; if `self` would creep into the returned closure,\n        # that would ensure that a reference to this big, fat object\n        # would be kept alive; hence, any hash function would carry\n        # around all of the auxiliary state that was created during the\n        # generation of the hash parameters.  Omitting `self` ensures\n        # this object has a chance to be garbage collected.\n        f1, f2, g = self.f1, self.f2, self.g\n\n        def czech_hash(word):\n            v1 = f1(word)\n            v2 = f2(word)\n            return g[v1] + g[v2]\n\n        return czech_hash"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ngenerate an acyclic graph for the given words.", "response": "def generate_acyclic_graph(self):\n        \"\"\"\n        Generates an acyclic graph for the given words.\n        Adds the graph, and a list of edge-word associations to the object.\n        \"\"\"\n\n        # Maximum length of each table, respectively.\n        # Hardcoded n = cm, where c = 3\n        # There might be a good way to choose an appropriate C,\n        # but [1] suggests the average amount of iterations needed\n        # to generate an acyclic graph is sqrt(3).\n        self.n = 3 * len(self.words)\n\n        max_tries = len(self.words) ** 2\n        for trial in range(max_tries):\n            try:\n                self.generate_or_fail()\n            except forest.InvariantError:\n                continue\n            else:\n                # Generated successfully!\n                self.trials_taken = trial + 1\n                return\n\n        raise RuntimeError(\"Could not generate graph in \"\n                           \"{} tries\".format(max_tries))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ngenerate random tables for given word lists.", "response": "def generate_random_table(self):\n        \"\"\"\n        Generates random tables for given word lists.\n        \"\"\"\n        table = list(range(0, self.n))\n        random.shuffle(table)\n        return table"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef generate_func(self, table):\n\n        # Ensure that `self` isn't suddenly in the closure...\n        n = self.n\n\n        def func(word):\n            return sum(x * ord(c) for x, c in zip(table, word)) % n\n\n        return func", "response": "Generates a random mini - hashing function."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate a dict subclass with the given name and hash_function and the given slots and documentation.", "response": "def create_dict_subclass(name, hash_func, slots, doc):\n    \"\"\"\n    Creates a dict subclass named name, using the hash_function to index\n    hash_length items. Doc should be any additional documentation added to the\n    class.\n    \"\"\"\n\n    hash_length = len(slots)\n\n    # Returns array index -- raises a KeyError if the key does not match\n    # its slot value.\n    def index_or_key_error(key):\n        index = hash_func(key)\n        # Make sure the key is **exactly** the same.\n        if key != slots[index]:\n            raise KeyError(key)\n        return index\n\n    def init(self, *args, **kwargs):\n        self._arr = [None] * hash_length\n        self._len = 0\n\n        # Delegate initialization to update provided by MutableMapping:\n        self.update(*args, **kwargs)\n\n    def getitem(self, key):\n        index = index_or_key_error(key)\n        if self._arr[index] is None:\n            raise KeyError(key)\n        return self._arr[index][1]\n\n    def setitem(self, key, value):\n        index = index_or_key_error(key)\n        self._arr[index] = (key, value)\n\n    def delitem(self, key):\n        index = index_or_key_error(key)\n        if self._arr[index] is None:\n            raise KeyError(key)\n        self._arr[index] = None\n\n    def dict_iter(self):\n        return (pair[0] for pair in self._arr if pair is not None)\n\n    def dict_len(self):\n        # TODO: Make this O(1) using auxiliary state?\n        return sum(1 for _ in self)\n\n    def dict_repr(self):\n        arr_repr = (repr(pair) for pair in self._arr if pair is not None)\n        return ''.join((name, '([', ', '.join(arr_repr), '])'))\n\n    # Inheriting from MutableMapping gives us a whole whackload of methods for\n    # free.\n    bases = (collections.MutableMapping,)\n\n    return type(name, bases, {\n        '__init__': init,\n        '__doc__': doc,\n\n        '__getitem__': getitem,\n        '__setitem__': setitem,\n        '__delitem__': delitem,\n        '__iter__': dict_iter,\n        '__len__': dict_len,\n\n        '__repr__': dict_repr,\n    })"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nchecking that the geojson data is a feature collection and that all features are valid.", "response": "def validate(data, skiperrors=False, fixerrors=True):\n    \"\"\"Checks that the geojson data is a feature collection, that it\n    contains a proper \"features\" attribute, and that all features are valid too.\n    Returns True if all goes well.\n\n    - skiperrors will throw away any features that fail to validate.\n    - fixerrors will attempt to auto fix any minor errors without raising exceptions.\n    \"\"\"\n\n    if not \"type\" in data:\n        if fixerrors:\n            data[\"type\"] = \"FeatureCollection\"\n        else:\n            raise ValueError(\"The geojson data needs to have a type key\")\n    if not data[\"type\"] == \"FeatureCollection\":\n        if fixerrors:\n            data[\"type\"] = \"FeatureCollection\"\n        else:\n            raise ValueError(\"The geojson data needs to be a feature collection\")\n    if \"features\" in data:\n        if not isinstance(data[\"features\"], list):\n            raise ValueError(\"The features property needs to be a list\")\n    else: raise ValueError(\"The FeatureCollection needs to contain a 'features' property\")\n\n    if skiperrors:\n        for featuredict in data[\"features\"]:\n            feat = Feature(featuredict)\n            try: feat.validate(fixerrors)\n            except: data[\"features\"].remove(featuredict)\n\n    else:\n        for featuredict in data[\"features\"]:\n            feat = Feature(featuredict)\n            feat.validate(fixerrors) \n\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef validate(self, fixerrors=True):\n\n        # validate nullgeometry or has type and coordinates keys\n        if not self._data:\n            # null geometry, no further checking needed\n            return True\n        elif \"type\" not in self._data or \"coordinates\" not in self._data:\n            raise Exception(\"A geometry dictionary or instance must have the type and coordinates entries\")\n        \n        # first validate geometry type\n        if not self.type in (\"Point\",\"MultiPoint\",\"LineString\",\"MultiLineString\",\"Polygon\",\"MultiPolygon\"):\n            if fixerrors:\n                coretype = self.type.lower().replace(\"multi\",\"\")\n                if coretype == \"point\":\n                    newtype = \"Point\"\n                elif coretype == \"linestring\":\n                    newtype = \"LineString\"\n                elif coretype == \"polygon\":\n                    newtype = \"Polygon\"\n                else:\n                    raise Exception('Invalid geometry type. Must be one of: \"Point\",\"MultiPoint\",\"LineString\",\"MultiLineString\",\"Polygon\",\"MultiPolygon\"')\n                \n                if self.type.lower().startswith(\"multi\"):\n                    newtype = \"Multi\" + newtype\n                    \n                self.type = newtype\n            else:\n                raise Exception('Invalid geometry type. Must be one of: \"Point\",\"MultiPoint\",\"LineString\",\"MultiLineString\",\"Polygon\",\"MultiPolygon\"')\n\n        # then validate coordinate data type\n        coords = self._data[\"coordinates\"]\n        if not isinstance(coords, (list,tuple)): raise Exception(\"Coordinates must be a list or tuple type\")\n\n        # then validate coordinate structures\n        if self.type == \"Point\":\n            if not len(coords) == 2: raise Exception(\"Point must be one coordinate pair\")\n        elif self.type in (\"MultiPoint\",\"LineString\"):\n            if not len(coords) > 1: raise Exception(\"MultiPoint and LineString must have more than one coordinates\")\n        elif self.type == \"MultiLineString\":\n            for line in coords:\n                if not len(line) > 1: raise Exception(\"All LineStrings in a MultiLineString must have more than one coordinate\")\n        elif self.type == \"Polygon\":\n            for exterior_or_holes in coords:\n                if not len(exterior_or_holes) >= 3: raise Exception(\"The exterior and all holes in a Polygon must have at least 3 coordinates\")\n        elif self.type == \"MultiPolygon\":\n            for eachmulti in coords:\n                for exterior_or_holes in eachmulti:\n                    if not len(exterior_or_holes) >= 3: raise Exception(\"The exterior and all holes in all Polygons of a MultiPolygon must have at least 3 coordinates\")\n\n        # validation successful\n        return True", "response": "Validates that the geometry is correctly formatted according to the geometry type and coordinates."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef validate(self, fixerrors=True):\n        if not \"type\" in self._data or self._data[\"type\"] != \"Feature\":\n            if fixerrors:\n                self._data[\"type\"] = \"Feature\"\n            else:\n                raise Exception(\"A geojson feature dictionary must contain a type key and it must be named 'Feature'.\")\n        if not \"geometry\" in self._data:\n            if fixerrors:\n                self.geometry = Geometry() # nullgeometry\n            else:\n                raise Exception(\"A geojson feature dictionary must contain a geometry key.\")\n        if not \"properties\" in self._data or not isinstance(self.properties,dict):\n            if fixerrors:\n                self._data[\"properties\"] = dict()\n            else:\n                raise Exception(\"A geojson feature dictionary must contain a properties key and it must be a dictionary type.\")\n        self.geometry.validate(fixerrors)\n        return True", "response": "Validates that the feature is correctly formatted."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncollect and return a list of all attributes and properties used in any of the features.", "response": "def all_attributes(self):\n        \"\"\"\n        Collect and return a list of all attributes/properties/fields used in any of the features.\n        \"\"\"\n        features = self._data[\"features\"]\n        if not features: return []\n        elif len(features) == 1: return features[0][\"properties\"].keys()\n        else:\n            fields = set(features[0][\"properties\"].keys())\n            for feature in features[1:]:\n                fields.update(feature[\"properties\"].keys())\n            return list(fields)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef common_attributes(self):\n        features = self._data[\"features\"]\n        if not features: return []\n        elif len(features) == 1: return features[0][\"properties\"].keys()\n        else:\n            fields = set(features[0][\"properties\"].keys())\n            for feature in features[1:]:\n                fields.intersection_update(feature[\"properties\"].keys())\n            return list(fields)", "response": "Collect and return a list of attributes and properties common to all features."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef add_feature(self, obj=None, geometry=None, properties=None):\n        properties = properties or {}\n        if isinstance(obj, Feature):\n            # instead of creating copy, the original feat should reference the same one that was added here\n            feat = obj._data\n        elif isinstance(obj, dict):\n            feat = obj.copy()\n        else:\n            feat = Feature(geometry=geometry, properties=properties).__geo_interface__\n        self._data[\"features\"].append(feat)", "response": "Adds a given feature to the internal data structure."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef define_crs(self, type, name=None, link=None, link_type=None):\n        if not type in (\"name\",\"link\"): raise Exception(\"type must be either 'name' or 'link'\")\n        crs = self._data[\"crs\"] = {\"type\":type, \"properties\":{} }\n        if type == \"name\":\n            if not name: raise Exception(\"name argument must be given\")\n            crs[\"properties\"][\"name\"] = name\n        elif type == \"link\":\n            if not link: raise Exception(\"link argument must be given\")\n            crs[\"properties\"][\"href\"] = link\n            if link_type:\n                crs[\"properties\"][\"type\"] = link_type", "response": "Define the coordinate reference system for the geojson file."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef update_bbox(self):\n\n        xmins, ymins, xmaxs, ymaxs = zip(*(feat.geometry.bbox for feat in self if feat.geometry.type != \"Null\"))\n        bbox = [min(xmins), min(ymins), max(xmaxs), max(ymaxs)] \n        self._data[\"bbox\"] = bbox", "response": "Recalculates the bbox region attribute for the entire file."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef add_unique_id(self):\n        \n        uid = 0\n        for feature in self._data[\"features\"]:\n            if feature[\"properties\"].get(\"id\"):\n                raise Exception(\"one of the features already had an id field\")\n            feature[\"properties\"][\"id\"] = uid\n            uid += 1", "response": "Adds a unique id property to each feature."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncalculating and adds a bbox attribute to the geojson entry of all features in the archive.", "response": "def add_all_bboxes(self):\n        \"\"\"\n        Calculates and adds a bbox attribute to the geojson entry of all feature geometries, updating any existing ones.\n        \"\"\"\n        for feature in self:\n            if feature.geometry.type != \"Null\":\n                feature.geometry._data[\"bbox\"] = Feature(feature).geometry.bbox"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsaving the object to a file.", "response": "def save(self, savepath, **kwargs):\n        \"\"\"\n        Saves the geojson instance to file. To save with a different text encoding use the 'encoding' argument.\n\n        Parameters:\n\n        - **savepath**: Filepath to save the file. \n        \"\"\"\n        \n        self.update_bbox()\n        tempfile = open(savepath,\"w\")\n        json.dump(self._data, tempfile, **kwargs)\n        tempfile.close()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _loadfilepath(self, filepath, **kwargs):\n        with open(filepath, \"r\") as f:\n            data = json.load(f, **kwargs)\n        return data", "response": "This loads a geojson file into a python dict using the json module."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _prepdata(self):\n        \n        # if missing, compute and add bbox\n        if not self._data.get(\"bbox\"):\n            self.update_bbox()\n\n        # if missing, set crs to default crs (WGS84), see http://geojson.org/geojson-spec.html\n        if not self._data.get(\"crs\"):\n            self._data[\"crs\"] = {\"type\":\"name\",\n                               \"properties\":{\"name\":\"urn:ogc:def:crs:OGC:2:84\"}}", "response": "Adds potentially missing items to the geojson dictionary"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef hash_parameters(keys, minimize=True, to_int=None):\n\n    # If to_int is not assigned, simply use the identity function.\n    if to_int is None:\n        to_int = __identity\n\n    key_to_original = {to_int(original): original for original in keys}\n\n    # Create a set of all items to be hashed.\n    items = list(key_to_original.keys())\n\n    if minimize:\n        offset = 0 - min(items)\n        items = frozenset(x + offset for x in items)\n    else:\n        offset = 0\n\n    # 1. Start with a square array (not stored) that is t units on each side.\n    # Choose a t such that t * t >= max(S)\n    t = choose_best_t(items)\n    assert t * t > max(items) and t * t >= len(items)\n\n    # 2. Place each key K in the square at location (x,y), where\n    # x = K mod t, y = K / t.\n    row_queue = place_items_in_square(items, t)\n\n    # 3. Arrange rows so that they'll fit into one row and generate a\n    # displacement vector.\n    final_row, displacement_vector = arrange_rows(row_queue, t)\n\n    # Translate the internal keys to their original items.\n    slots = tuple(key_to_original[item - offset] if item is not None else None\n                  for item in final_row)\n\n    # Return the parameters\n    return HashInfo(\n        t=t,\n        slots=slots,\n        r=displacement_vector,\n        offset=offset,\n        to_int=to_int if to_int is not __identity else None\n    )", "response": "Calculates the parameters for a perfect hash."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef place_items_in_square(items, t):\n\n    # A minheap (because that's all that heapq supports :/)\n    # of the length of each row. Why this is important is because\n    # we'll be popping the largest rows when figuring out row displacements.\n    # Each item is a tuple of (t - |row|, y, [(xpos_1, item_1), ...]).\n    # Until the call to heapq.heapify(), the rows are ordered in\n    # increasing row number (y).\n    rows = [(t, y, []) for y in range(t)]\n\n    for item in items:\n        # Calculate the cell the item should fall in.\n        x = item % t\n        y = item // t\n\n        # Push the item to its corresponding row...\n        inverse_length, _, row_contents = rows[y]\n        heapq.heappush(row_contents, (x, item))\n\n        # Ensure the heap key is kept intact.\n        rows[y] = inverse_length - 1, y, row_contents\n\n    assert all(inv_len == t - len(rows) for inv_len, _, rows in rows)\n\n    heapq.heapify(rows)\n\n    # Return only rows that are populated.\n    return [row for row in rows if row[2]]", "response": "Place items in a square of a tree."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\narranges the items from its conceptual square to one list.", "response": "def arrange_rows(row_queue, t):\n    \"\"\"\n    Takes a priority queue as generated by place_items_in_square().\n    Arranges the items from its conceptual square to one list.  Returns\n    both the resultant vector, plus the displacement vector, to be used\n    in the final output hash function.\n\n    >>> rows = [(2, 1, [(0, 1), (1, 5)]), (3, 3, [(1, 7)])]\n    >>> result, displacements = arrange_rows(rows, 4)\n    >>> result\n    (1, 5, 7)\n    >>> displacements\n    (None, 0, None, 1)\n\n    >>> rows = [(1, 1, [(0, 1), (2, 7)]), (2, 2, [(1, 5)])]\n    >>> result, displacements = arrange_rows(rows, 3)\n    >>> result\n    (1, 5, 7)\n    >>> displacements\n    (None, 0, 0)\n    \"\"\"\n\n    # Create a set of all of the unoccupied columns.\n    max_columns = t ** 2\n    cols = ((x, True) for x in range(max_columns))\n    unoccupied_columns = collections.OrderedDict(cols)\n\n    # Create the resultant and displacement vectors.\n    result = [None] * max_columns\n    displacements = [None] * t\n\n    while row_queue:\n        # Get the next row to place.\n        _inverse_length, y, row = heapq.heappop(row_queue)\n\n        offset = find_first_fit(unoccupied_columns, row, max_columns)\n        # Calculate the offset of the first item.\n        first_item_x = row[0][0]\n\n        displacements[y] = offset\n        for x, item in row:\n            actual_x = x + offset\n            result[actual_x] = item\n            del unoccupied_columns[actual_x]\n\n    return tuple(trim_nones_from_right(result)), tuple(displacements)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef find_first_fit(unoccupied_columns, row, row_length):\n    for free_col in unoccupied_columns:\n        # The offset is that such that the first item goes in the free column.\n        first_item_x = row[0][0]\n        offset = free_col - first_item_x\n        if check_columns_fit(unoccupied_columns, row, offset, row_length):\n            return offset\n\n    raise ValueError(\"Row cannot bossily fit in %r: %r\"\n                     % (list(unoccupied_columns.keys()), row))", "response": "Find the first index that the row can fit in."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef check_columns_fit(unoccupied_columns, row, offset, row_length):\n    for index, item in row:\n        adjusted_index = (index + offset) % row_length\n\n        # Check if the index is in the appropriate place.\n        if adjusted_index not in unoccupied_columns:\n            return False\n\n    return True", "response": "Checks if all the occupied columns in the row fit in the indices\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef print_square(row_queue, t):\n    occupied_rows = {y: row for _, y, row in row_queue}\n\n    empty_row = ', '.join('...' for _ in range(t))\n    for y in range(t):\n        print('|', end=' ')\n        if y not in occupied_rows:\n            print(empty_row, end=' ')\n        else:\n            row = dict(occupied_rows[y])\n            all_cols = ('%3d' % row[x] if x in row else '...'\n                        for x in range(t))\n            print(', '.join(all_cols), end=' ')\n\n        print(\"|\")", "response": "Prints a row queue as its conceptual square array."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the list with all the Nones at the right end.", "response": "def trim_nones_from_right(xs):\n    \"\"\"\n    Returns the list without all the Nones at the right end.\n\n    >>> trim_nones_from_right([1, 2, None, 4, None, 5, None, None])\n    [1, 2, None, 4, None, 5]\n\n    \"\"\"\n    # Find the first element that does not contain none.\n    for i, item in enumerate(reversed(xs)):\n        if item is not None:\n            break\n\n    return xs[:-i]"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef make_hash(keys, **kwargs):\n    params = hash_parameters(keys, **kwargs)\n\n    t = params.t\n    r = params.r\n    offset = params.offset\n    to_int = params.to_int if params.to_int else __identity\n\n    def perfect_hash(x):\n        val = to_int(x) + offset\n        x = val % t\n        y = val // t\n        return x + r[y]\n\n    # Undocumented properties, but used in make_dict()...\n    perfect_hash.length = len(params.slots)\n    perfect_hash.slots = params.slots\n    return perfect_hash", "response": "Creates a hash function from the given keys."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating a dictionary - like mapping class that uses perfect hashing.", "response": "def make_dict(name, keys, **kwargs):\n    \"\"\"\n    Creates a dictionary-like mapping class that uses perfect hashing.\n    ``name`` is the proper class name of the returned class. See\n    ``hash_parameters()`` for documentation on all arguments after\n    ``name``.\n\n    >>> MyDict = make_dict('MyDict', '+-<>[],.', to_int=ord)\n    >>> d = MyDict([('+', 1), ('-', 2)])\n    >>> d[','] = 3\n    >>> d\n    MyDict([('+', 1), (',', 3), ('-', 2)])\n    >>> del d['+']\n    >>> del d['.']\n    Traceback (most recent call last):\n    ...\n    KeyError: '.'\n    >>> len(d)\n    2\n    \"\"\"\n    hash_func = make_hash(keys, **kwargs)\n    slots = hash_func.slots\n\n    # Create a docstring that at least describes where the class came from...\n    doc = \"\"\"\n        Dictionary-like object that uses perfect hashing. This class was\n        generated by `%s.%s(%r, ...)`.\n        \"\"\" % (__name__, make_dict.__name__, name)\n\n    return create_dict_subclass(name, hash_func, slots, doc)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting the timestamp from the timestamp file.", "response": "def _get_timestamp(dirname_full, remove):\n    \"\"\"\n    Get the timestamp from the timestamp file.\n\n    Optionally mark it for removal if we're going to write another one.\n    \"\"\"\n    record_filename = os.path.join(dirname_full, RECORD_FILENAME)\n\n    if not os.path.exists(record_filename):\n        return None\n\n    mtime = os.stat(record_filename).st_mtime\n    mtime_str = datetime.fromtimestamp(mtime)\n    print('Found timestamp {}:{}'.format(dirname_full, mtime_str))\n    if Settings.record_timestamp and remove:\n        OLD_TIMESTAMPS.add(record_filename)\n    return mtime"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget the timestamp of a node in the cache or fill it if it doesn t exist", "response": "def _get_timestamp_cached(dirname_full, remove):\n    \"\"\"\n    Get the timestamp from the cache or fill the cache\n    Much quicker than reading the same files over and over\n    \"\"\"\n    if dirname_full not in TIMESTAMP_CACHE:\n        mtime = _get_timestamp(dirname_full, remove)\n        TIMESTAMP_CACHE[dirname_full] = mtime\n    return TIMESTAMP_CACHE[dirname_full]"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncompare a timestamp file to one passed in. Get the max.", "response": "def _max_timestamps(dirname_full, remove, compare_tstamp):\n    \"\"\"Compare a timestamp file to one passed in. Get the max.\"\"\"\n    tstamp = _get_timestamp_cached(dirname_full, remove)\n    return max_none((tstamp, compare_tstamp))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _get_parent_timestamp(dirname, mtime):\n    parent_pathname = os.path.dirname(dirname)\n\n    # max between the parent timestamp the one passed in\n    mtime = _max_timestamps(parent_pathname, False, mtime)\n\n    if dirname != os.path.dirname(parent_pathname):\n        # this is only called if we're not at the root\n        mtime = _get_parent_timestamp(parent_pathname, mtime)\n\n    return mtime", "response": "Get the parent timestamp of the passed in directory tree."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_walk_after(filename, optimize_after=None):\n    if Settings.optimize_after is not None:\n        return Settings.optimize_after\n\n    dirname = os.path.dirname(filename)\n    if optimize_after is None:\n        optimize_after = _get_parent_timestamp(dirname, optimize_after)\n    return _max_timestamps(dirname, True, optimize_after)", "response": "Get the mtime of the file after the given file."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef record_timestamp(pathname_full):\n    if Settings.test or Settings.list_only or not Settings.record_timestamp:\n        return\n    if not Settings.follow_symlinks and os.path.islink(pathname_full):\n        if Settings.verbose:\n            print('Not setting timestamp because not following symlinks')\n        return\n    if not os.path.isdir(pathname_full):\n        if Settings.verbose:\n            print('Not setting timestamp for a non-directory')\n        return\n\n    record_filename_full = os.path.join(pathname_full, RECORD_FILENAME)\n    try:\n        with open(record_filename_full, 'w'):\n            os.utime(record_filename_full, None)\n        if Settings.verbose:\n            print(\"Set timestamp: {}\".format(record_filename_full))\n        for fname in OLD_TIMESTAMPS:\n            if fname.startswith(pathname_full) and \\\n               fname != record_filename_full:\n                # only remove timestamps below the curent path\n                # but don't remove the timestamp we just set!\n                os.remove(fname)\n                if Settings.verbose:\n                    print('Removed old timestamp: {}'.format(fname))\n    except IOError:\n        print(\"Could not set timestamp in {}\".format(pathname_full))", "response": "Record the timestamp of running in a dotfile."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\noptimize a comic archive.", "response": "def walk_comic_archive(filename_full, image_format, optimize_after):\n    \"\"\"\n    Optimize a comic archive.\n\n    This is done mostly inline to use the master processes process pool\n    for workers. And to avoid calling back up into walk from a dedicated\n    module or format processor. It does mean that we block on uncompress\n    and on waiting for the contents subprocesses to compress.\n    \"\"\"\n    # uncompress archive\n    tmp_dir, report_stats = comic.comic_archive_uncompress(filename_full,\n                                                           image_format)\n    if tmp_dir is None and report_stats:\n        return Settings.pool.apply_async(_comic_archive_skip,\n                                         args=report_stats)\n\n    # optimize contents of archive\n    archive_mtime = os.stat(filename_full).st_mtime\n    result_set = walk_dir(tmp_dir, optimize_after, True, archive_mtime)\n\n    # wait for archive contents to optimize before recompressing\n    nag_about_gifs = False\n    for result in result_set:\n        res = result.get()\n        nag_about_gifs = nag_about_gifs or res.nag_about_gifs\n\n    # recompress archive\n    args = (filename_full, image_format, Settings, nag_about_gifs)\n    return Settings.pool.apply_async(comic.comic_archive_compress,\n                                     args=(args,))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nhandling things that are not optimizable files.", "response": "def _is_skippable(filename_full):\n    \"\"\"Handle things that are not optimizable files.\"\"\"\n\n    # File types\n    if not Settings.follow_symlinks and os.path.islink(filename_full):\n        return True\n    if os.path.basename(filename_full) == timestamp.RECORD_FILENAME:\n        return True\n    if not os.path.exists(filename_full):\n        if Settings.verbose:\n            print(filename_full, 'was not found.')\n        return True\n\n    return False"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef walk_file(filename, walk_after, recurse=None, archive_mtime=None):\n    filename = os.path.normpath(filename)\n\n    result_set = set()\n\n    if _is_skippable(filename):\n        return result_set\n\n    walk_after = timestamp.get_walk_after(filename, walk_after)\n\n    # File is a directory\n    if os.path.isdir(filename):\n        return walk_dir(filename, walk_after, recurse, archive_mtime)\n\n    if _is_older_than_timestamp(filename, walk_after, archive_mtime):\n        return result_set\n\n    # Check image format\n    try:\n        image_format = detect_format.detect_file(filename)\n    except Exception:\n        res = Settings.pool.apply_async(stats.ReportStats,\n                                        (filename,),\n                                        {'error': \"Detect Format\"})\n        result_set.add(res)\n        image_format = False\n\n    if not image_format:\n        return result_set\n\n    if Settings.list_only:\n        # list only\n        print(\"{}: {}\".format(filename, image_format))\n        return result_set\n\n    if detect_format.is_format_selected(image_format, comic.FORMATS,\n                                        comic.PROGRAMS):\n        # comic archive\n        result = walk_comic_archive(filename, image_format, walk_after)\n    else:\n        # regular image\n        args = [filename, image_format, Settings]\n        result = Settings.pool.apply_async(optimize.optimize_image,\n                                           args=(args,))\n    result_set.add(result)\n    return result_set", "response": "Optimize an individual file."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef walk_dir(dir_path, walk_after, recurse=None, archive_mtime=None):\n    if recurse is None:\n        recurse = Settings.recurse\n\n    result_set = set()\n    if not recurse:\n        return result_set\n\n    for root, _, filenames in os.walk(dir_path):\n        for filename in filenames:\n            filename_full = os.path.join(root, filename)\n            try:\n                results = walk_file(filename_full, walk_after, recurse,\n                                    archive_mtime)\n                result_set = result_set.union(results)\n            except Exception:\n                print(\"Error with file: {}\".format(filename_full))\n                raise\n\n    return result_set", "response": "Recursively optimize a directory."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _walk_all_files():\n    # Init records\n    record_dirs = set()\n    result_set = set()\n\n    for filename in Settings.paths:\n        # Record dirs to put timestamps in later\n        filename_full = os.path.abspath(filename)\n        if Settings.recurse and os.path.isdir(filename_full):\n            record_dirs.add(filename_full)\n\n        walk_after = timestamp.get_walk_after(filename_full)\n        results = walk_file(filename_full, walk_after, Settings.recurse)\n        result_set = result_set.union(results)\n\n    bytes_in = 0\n    bytes_out = 0\n    nag_about_gifs = False\n    errors = []\n    for result in result_set:\n        res = result.get()\n        if res.error:\n            errors += [(res.final_filename, res.error)]\n            continue\n        bytes_in += res.bytes_in\n        bytes_out += res.bytes_out\n        nag_about_gifs = nag_about_gifs or res.nag_about_gifs\n\n    return record_dirs, bytes_in, bytes_out, nag_about_gifs, errors", "response": "Walks all files in the current directory tree and returns a set of records."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef run():\n    # Setup Multiprocessing\n    # manager = multiprocessing.Manager()\n    Settings.pool = multiprocessing.Pool(Settings.jobs)\n\n    # Optimize Files\n    record_dirs, bytes_in, bytes_out, nag_about_gifs, errors = \\\n        _walk_all_files()\n\n    # Shut down multiprocessing\n    Settings.pool.close()\n    Settings.pool.join()\n\n    # Write timestamps\n    for filename in record_dirs:\n        timestamp.record_timestamp(filename)\n\n    # Finish by reporting totals\n    stats.report_totals(bytes_in, bytes_out, nag_about_gifs, errors)", "response": "Use preconfigured settings to optimize files."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef replace_ext(filename, new_ext):\n    filename_base = os.path.splitext(filename)[0]\n    new_filename = '{}.{}'.format(filename_base, new_ext)\n    return new_filename", "response": "Replace the file extention."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _cleanup_after_optimize_aux(filename, new_filename, old_format,\n                                new_format):\n    \"\"\"\n    Replace old file with better one or discard new wasteful file.\n    \"\"\"\n    bytes_in = 0\n    bytes_out = 0\n    final_filename = filename\n    try:\n        bytes_in = os.stat(filename).st_size\n        bytes_out = os.stat(new_filename).st_size\n        if (bytes_out > 0) and ((bytes_out < bytes_in) or Settings.bigger):\n            if old_format != new_format:\n                final_filename = replace_ext(filename,\n                                             new_format.lower())\n            rem_filename = filename + REMOVE_EXT\n            if not Settings.test:\n                os.rename(filename, rem_filename)\n                os.rename(new_filename, final_filename)\n                os.remove(rem_filename)\n            else:\n                os.remove(new_filename)\n\n        else:\n            os.remove(new_filename)\n            bytes_out = bytes_in\n    except OSError as ex:\n        print(ex)\n\n    return final_filename, bytes_in, bytes_out", "response": "Remove old file with better one or discard new wasteful file."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef cleanup_after_optimize(filename, new_filename, old_format, new_format):\n    final_filename, bytes_in, bytes_out = _cleanup_after_optimize_aux(\n        filename, new_filename, old_format, new_format)\n    return stats.ReportStats(final_filename, bytes_count=(bytes_in, bytes_out))", "response": "Clean up the file after optimisation."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nparse setup requirements from a requirements. txt file.", "response": "def parse_reqs(filename):\n    \"\"\"Parse setup requirements from a requirements.txt file.\"\"\"\n    install_reqs = parse_requirements(filename, session=False)\n    return [str(ir.req) for ir in install_reqs]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_req_list():\n    req_list = parse_reqs(REQUIREMENTS['prod'])\n    if len(sys.argv) > 2 and sys.argv[2] == ('develop'):\n        req_list += parse_reqs(REQUIREMENTS['dev'])\n    return req_list", "response": "Get the requirements by weather we re building develop or not."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_comic_format(filename):\n    image_format = None\n    filename_ext = os.path.splitext(filename)[-1].lower()\n    if filename_ext in _COMIC_EXTS:\n        if zipfile.is_zipfile(filename):\n            image_format = _CBZ_FORMAT\n        elif rarfile.is_rarfile(filename):\n            image_format = _CBR_FORMAT\n    return image_format", "response": "Return the comic format if it is a comic archive."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _get_archive_tmp_dir(filename):\n    head, tail = os.path.split(filename)\n    return os.path.join(head, _ARCHIVE_TMP_DIR_TEMPLATE.format(tail))", "response": "Get the name of the working dir to use for this filename."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef comic_archive_uncompress(filename, image_format):\n    if not Settings.comics:\n        report = ['Skipping archive file: {}'.format(filename)]\n        return None, ReportStats(filename, report=report)\n\n    if Settings.verbose:\n        truncated_filename = stats.truncate_cwd(filename)\n        print(\"Extracting {}...\".format(truncated_filename), end='')\n\n    # create the tmpdir\n    tmp_dir = _get_archive_tmp_dir(filename)\n    if os.path.isdir(tmp_dir):\n        shutil.rmtree(tmp_dir)\n    os.mkdir(tmp_dir)\n\n    # extract archvie into the tmpdir\n    if image_format == _CBZ_FORMAT:\n        with zipfile.ZipFile(filename, 'r') as zfile:\n            zfile.extractall(tmp_dir)\n    elif image_format == _CBR_FORMAT:\n        with rarfile.RarFile(filename, 'r') as rfile:\n            rfile.extractall(tmp_dir)\n    else:\n        report = '{} {} is not a good format'.format(filename, image_format)\n        return None, ReportStats(filename, report=report)\n\n    if Settings.verbose:\n        print('done')\n\n    return tmp_dir, None", "response": "Uncompress a comic archive into a temporary directory."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nzipping up the files in the tempdir into the new filename.", "response": "def _comic_archive_write_zipfile(new_filename, tmp_dir):\n    \"\"\"Zip up the files in the tempdir into the new filename.\"\"\"\n    if Settings.verbose:\n        print('Rezipping archive', end='')\n    with zipfile.ZipFile(new_filename, 'w',\n                         compression=zipfile.ZIP_DEFLATED) as new_zf:\n        root_len = len(os.path.abspath(tmp_dir))\n        for r_d_f in os.walk(tmp_dir):\n            root = r_d_f[0]\n            filenames = r_d_f[2]\n            archive_root = os.path.abspath(root)[root_len:]\n            for fname in filenames:\n                fullpath = os.path.join(root, fname)\n                archive_name = os.path.join(archive_root, fname)\n                if Settings.verbose:\n                    print('.', end='')\n                new_zf.write(fullpath, archive_name, zipfile.ZIP_DEFLATED)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncalling back by every optimization inside a comic archive. When they're all done it creates the new archive and cleans up.", "response": "def comic_archive_compress(args):\n    \"\"\"\n    Called back by every optimization inside a comic archive.\n\n    When they're all done it creates the new archive and cleans up.\n    \"\"\"\n    try:\n        filename, old_format, settings, nag_about_gifs = args\n        Settings.update(settings)\n        tmp_dir = _get_archive_tmp_dir(filename)\n\n        # archive into new filename\n        new_filename = files.replace_ext(filename, _NEW_ARCHIVE_SUFFIX)\n\n        _comic_archive_write_zipfile(new_filename, tmp_dir)\n\n        # Cleanup tmpdir\n        if os.path.isdir(tmp_dir):\n            if Settings.verbose:\n                print('.', end='')\n            shutil.rmtree(tmp_dir)\n        if Settings.verbose:\n            print('done.')\n\n        report_stats = files.cleanup_after_optimize(\n            filename, new_filename, old_format, _CBZ_FORMAT)\n        report_stats.nag_about_gifs = nag_about_gifs\n        stats.report_saved(report_stats)\n        return report_stats\n    except Exception as exc:\n        print(exc)\n        traceback.print_exc(exc)\n        raise exc"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef mozjpeg(ext_args):\n    args = copy.copy(_MOZJPEG_ARGS)\n    if Settings.destroy_metadata:\n        args += [\"-copy\", \"none\"]\n    else:\n        args += [\"-copy\", \"all\"]\n    args += ['-outfile']\n    args += [ext_args.new_filename, ext_args.old_filename]\n    extern.run_ext(args)\n    return _JPEG_FORMAT", "response": "Create argument list for mozjpeg."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef jpegtran(ext_args):\n    args = copy.copy(_JPEGTRAN_ARGS)\n    if Settings.destroy_metadata:\n        args += [\"-copy\", \"none\"]\n    else:\n        args += [\"-copy\", \"all\"]\n    if Settings.jpegtran_prog:\n        args += [\"-progressive\"]\n    args += ['-outfile']\n    args += [ext_args.new_filename, ext_args.old_filename]\n    extern.run_ext(args)\n    return _JPEG_FORMAT", "response": "Create argument list for jpegtran."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nrun the EXTERNAL program jpegrescan.", "response": "def jpegrescan(ext_args):\n    \"\"\"Run the EXTERNAL program jpegrescan.\"\"\"\n    args = copy.copy(_JPEGRESCAN_ARGS)\n    if Settings.jpegrescan_multithread:\n        args += ['-t']\n    if Settings.destroy_metadata:\n        args += ['-s']\n    args += [ext_args.old_filename, ext_args.new_filename]\n    extern.run_ext(args)\n    return _JPEG_FORMAT"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nparse the command line arguments.", "response": "def get_arguments(args):\n    \"\"\"Parse the command line.\"\"\"\n    usage = \"%(prog)s [arguments] [image files]\"\n    programs_str = ', '.join([prog.__name__ for prog in PROGRAMS])\n    description = \"Uses \"+programs_str+\" if they are on the path.\"\n    parser = argparse.ArgumentParser(usage=usage, description=description)\n    parser.add_argument(\"-r\", \"--recurse\", action=\"store_true\",\n                        dest=\"recurse\", default=0,\n                        help=\"Recurse down through directories ignoring the\"\n                        \"image file arguments on the command line\")\n    parser.add_argument(\"-v\", \"--verbose\", action=\"count\",\n                        dest=\"verbose\", default=0,\n                        help=\"Display more output. -v (default) and -vv \"\n                        \"(noisy)\")\n    parser.add_argument(\"-Q\", \"--quiet\", action=\"store_const\",\n                        dest=\"verbose\", const=-1,\n                        help=\"Display little to no output\")\n    parser.add_argument(\"-a\", \"--enable_advpng\", action=\"store_true\",\n                        dest=\"advpng\", default=0,\n                        help=\"Optimize with advpng (disabled by default)\")\n    parser.add_argument(\"-c\", \"--comics\", action=\"store_true\",\n                        dest=\"comics\", default=0,\n                        help=\"Also optimize comic book archives (cbz & cbr)\")\n    parser.add_argument(\"-f\", \"--formats\", action=\"store\", dest=\"formats\",\n                        default=DEFAULT_FORMATS,\n                        help=\"Only optimize images of the specifed '{}' \"\n                        \"delimited formats from: {}\".format(\n                            FORMAT_DELIMETER,\n                            ', '.join(sorted(ALL_FORMATS))))\n    parser.add_argument(\"-O\", \"--disable_optipng\", action=\"store_false\",\n                        dest=\"optipng\", default=1,\n                        help=\"Do not optimize with optipng\")\n    parser.add_argument(\"-P\", \"--disable_pngout\", action=\"store_false\",\n                        dest=\"pngout\", default=1,\n                        help=\"Do not optimize with pngout\")\n    parser.add_argument(\"-J\", \"--disable_jpegrescan\", action=\"store_false\",\n                        dest=\"jpegrescan\", default=1,\n                        help=\"Do not optimize with jpegrescan\")\n    parser.add_argument(\"-E\", \"--disable_progressive\", action=\"store_false\",\n                        dest=\"jpegtran_prog\", default=1,\n                        help=\"Don't try to reduce size by making \"\n                        \"progressive JPEGs with jpegtran\")\n    parser.add_argument(\"-Z\", \"--disable_mozjpeg\", action=\"store_false\",\n                        dest=\"mozjpeg\", default=1,\n                        help=\"Do not optimize with mozjpeg\")\n    parser.add_argument(\"-T\", \"--disable_jpegtran\", action=\"store_false\",\n                        dest=\"jpegtran\", default=1,\n                        help=\"Do not optimize with jpegtran\")\n    parser.add_argument(\"-G\", \"--disable_gifsicle\", action=\"store_false\",\n                        dest=\"gifsicle\", default=1,\n                        help=\"disable optimizing animated GIFs\")\n    parser.add_argument(\"-Y\", \"--disable_convert_type\", action=\"store_const\",\n                        dest=\"to_png_formats\",\n                        const=png.FORMATS,\n                        default=png.CONVERTABLE_FORMATS,\n                        help=\"Do not convert other lossless formats like \"\n                        \" {} to PNG when optimizing. By default, {}\"\n                        \" does convert these formats to PNG\".format(\n                            ', '.join(png.LOSSLESS_FORMATS),\n                            PROGRAM_NAME))\n    parser.add_argument(\"-S\", \"--disable_follow_symlinks\",\n                        action=\"store_false\",\n                        dest=\"follow_symlinks\", default=1,\n                        help=\"disable following symlinks for files and \"\n                        \"directories\")\n    parser.add_argument(\"-b\", \"--bigger\", action=\"store_true\",\n                        dest=\"bigger\", default=0,\n                        help=\"Save optimized files that are larger than \"\n                        \"the originals\")\n    parser.add_argument(\"-t\", \"--record_timestamp\", action=\"store_true\",\n                        dest=\"record_timestamp\", default=0,\n                        help=\"Store the time of the optimization of full \"\n                        \"directories in directory local dotfiles.\")\n    parser.add_argument(\"-D\", \"--optimize_after\", action=\"store\",\n                        dest=\"optimize_after\", default=None,\n                        help=\"only optimize files after the specified \"\n                        \"timestamp. Supercedes -t\")\n    parser.add_argument(\"-N\", \"--noop\", action=\"store_true\",\n                        dest=\"test\", default=0,\n                        help=\"Do not replace files with optimized versions\")\n    parser.add_argument(\"-l\", \"--list\", action=\"store_true\",\n                        dest=\"list_only\", default=0,\n                        help=\"Only list files that would be optimized\")\n    parser.add_argument(\"-V\", \"--version\", action=\"version\",\n                        version=__version__,\n                        help=\"display the version number\")\n    parser.add_argument(\"-M\", \"--destroy_metadata\", action=\"store_true\",\n                        dest=\"destroy_metadata\", default=0,\n                        help=\"*Destroy* metadata like EXIF and JFIF\")\n    parser.add_argument(\"paths\", metavar=\"path\", type=str, nargs=\"+\",\n                        help=\"File or directory paths to optimize\")\n    parser.add_argument(\"-j\", \"--jobs\", type=int, action=\"store\",\n                        dest=\"jobs\", default=multiprocessing.cpu_count(),\n                        help=\"Number of parallel jobs to run simultaneously.\")\n\n    return parser.parse_args(args)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nprocessing command line arguments and walk inputs.", "response": "def run(args):\n    \"\"\"Process command line arguments and walk inputs.\"\"\"\n    raw_arguments = get_arguments(args[1:])\n    process_arguments(raw_arguments)\n    walk.run()\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ntest to see if the external programs can be run.", "response": "def does_external_program_run(prog, verbose):\n    \"\"\"Test to see if the external programs can be run.\"\"\"\n    try:\n        with open('/dev/null') as null:\n            subprocess.call([prog, '-h'], stdout=null, stderr=null)\n        result = True\n    except OSError:\n        if verbose > 1:\n            print(\"couldn't run {}\".format(prog))\n        result = False\n\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _humanize_bytes(num_bytes, precision=1):\n    if num_bytes == 0:\n        return 'no bytes'\n    if num_bytes == 1:\n        return '1 byte'\n\n    factored_bytes = 0\n    factor_suffix = 'bytes'\n    for factor, suffix in ABBREVS:\n        if num_bytes >= factor:\n            factored_bytes = num_bytes / factor\n            factor_suffix = suffix\n            break\n\n    if factored_bytes == 1:\n        precision = 0\n\n    return '{:.{prec}f} {}'.format(factored_bytes, factor_suffix,\n                                   prec=precision)", "response": "Return a humanized string representation of a number of num_bytes."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nspitting out how much space the optimization saved.", "response": "def new_percent_saved(report_stats):\n    \"\"\"Spit out how much space the optimization saved.\"\"\"\n    size_in = report_stats.bytes_in\n    if size_in > 0:\n        size_out = report_stats.bytes_out\n        ratio = size_out / size_in\n        kb_saved = _humanize_bytes(size_in - size_out)\n    else:\n        ratio = 0\n        kb_saved = 0\n    percent_saved = (1 - ratio) * 100\n\n    result = '{:.{prec}f}% ({})'.format(percent_saved, kb_saved, prec=2)\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef truncate_cwd(full_filename):\n    if full_filename.startswith(os.getcwd()):\n        truncated_filename = full_filename.split(os.getcwd(), 1)[1]\n        truncated_filename = truncated_filename.split(os.sep, 1)[1]\n    else:\n        truncated_filename = full_filename\n    return truncated_filename", "response": "Remove the cwd from the full filename."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nrecording the percent saved & print it.", "response": "def report_saved(report_stats):\n    \"\"\"Record the percent saved & print it.\"\"\"\n    if Settings.verbose:\n        report = ''\n        truncated_filename = truncate_cwd(report_stats.final_filename)\n\n        report += '{}: '.format(truncated_filename)\n        total = new_percent_saved(report_stats)\n        if total:\n            report += total\n        else:\n            report += '0%'\n        if Settings.test:\n            report += ' could be saved.'\n        if Settings.verbose > 1:\n            tools_report = ', '.join(report_stats.report_list)\n            if tools_report:\n                report += '\\n\\t' + tools_report\n        print(report)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreports the total number and percent of bytes saved.", "response": "def report_totals(bytes_in, bytes_out, nag_about_gifs, errors):\n    \"\"\"Report the total number and percent of bytes saved.\"\"\"\n    if bytes_in:\n        bytes_saved = bytes_in - bytes_out\n        percent_bytes_saved = bytes_saved / bytes_in * 100\n        msg = ''\n        if Settings.test:\n            if percent_bytes_saved > 0:\n                msg += \"Could save\"\n            elif percent_bytes_saved == 0:\n                msg += \"Could even out for\"\n            else:\n                msg += \"Could lose\"\n        else:\n            if percent_bytes_saved > 0:\n                msg += \"Saved\"\n            elif percent_bytes_saved == 0:\n                msg += \"Evened out\"\n            else:\n                msg = \"Lost\"\n        msg += \" a total of {} or {:.{prec}f}%\".format(\n            _humanize_bytes(bytes_saved), percent_bytes_saved, prec=2)\n        if Settings.verbose:\n            print(msg)\n            if Settings.test:\n                print(\"Test run did not change any files.\")\n\n    else:\n        if Settings.verbose:\n            print(\"Didn't optimize any files.\")\n\n    if nag_about_gifs and Settings.verbose:\n        print(\"Most animated GIFS would be better off converted to\"\n              \" HTML5 video\")\n\n    if not errors:\n        return\n\n    print(\"Errors with the following files:\")\n    for error in errors:\n        print(\"{}: {}\".format(error[0], error[1]))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nproviding reporting statistics for a skipped file.", "response": "def skip(type_name, filename):\n    \"\"\"Provide reporting statistics for a skipped file.\"\"\"\n    report = ['Skipping {} file: {}'.format(type_name, filename)]\n    report_stats = ReportStats(filename, report=report)\n    return report_stats"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef gifsicle(ext_args):\n    args = _GIFSICLE_ARGS + [ext_args.new_filename]\n    extern.run_ext(args)\n    return _GIF_FORMAT", "response": "Run the EXTERNAL program gifsicle."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\noptimize the file with the external function.", "response": "def _optimize_image_external(filename, func, image_format, new_ext):\n    \"\"\"Optimize the file with the external function.\"\"\"\n    new_filename = filename + TMP_SUFFIX + new_ext\n    new_filename = os.path.normpath(new_filename)\n    shutil.copy2(filename, new_filename)\n\n    ext_args = ExtArgs(filename, new_filename)\n    new_image_format = func(ext_args)\n\n    report_stats = files.cleanup_after_optimize(filename, new_filename,\n                                                image_format,\n                                                new_image_format)\n    percent = stats.new_percent_saved(report_stats)\n    if percent != 0:\n        report = '{}: {}'.format(func.__name__, percent)\n    else:\n        report = ''\n    report_stats.report_list.append(report)\n\n    return report_stats"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\noptimizes the image with the correct optimizing functions in sequence.", "response": "def _optimize_with_progs(format_module, filename, image_format):\n    \"\"\"\n    Use the correct optimizing functions in sequence.\n\n    And report back statistics.\n    \"\"\"\n    filesize_in = os.stat(filename).st_size\n    report_stats = None\n\n    for func in format_module.PROGRAMS:\n        if not getattr(Settings, func.__name__):\n            continue\n        report_stats = _optimize_image_external(\n            filename, func, image_format, format_module.OUT_EXT)\n        filename = report_stats.final_filename\n        if format_module.BEST_ONLY:\n            break\n\n    if report_stats is not None:\n        report_stats.bytes_in = filesize_in\n    else:\n        report_stats = stats.skip(image_format, filename)\n\n    return report_stats"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets the format module to use for optimizing the image.", "response": "def _get_format_module(image_format):\n    \"\"\"Get the format module to use for optimizing the image.\"\"\"\n    format_module = None\n    nag_about_gifs = False\n\n    if detect_format.is_format_selected(image_format,\n                                        Settings.to_png_formats,\n                                        png.PROGRAMS):\n        format_module = png\n    elif detect_format.is_format_selected(image_format, jpeg.FORMATS,\n                                          jpeg.PROGRAMS):\n        format_module = jpeg\n    elif detect_format.is_format_selected(image_format, gif.FORMATS,\n                                          gif.PROGRAMS):\n        # this captures still GIFs too if not caught above\n        format_module = gif\n        nag_about_gifs = True\n\n    return format_module, nag_about_gifs"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef optimize_image(arg):\n    try:\n        filename, image_format, settings = arg\n\n        Settings.update(settings)\n\n        format_module, nag_about_gifs = _get_format_module(image_format)\n\n        if format_module is None:\n            if Settings.verbose > 1:\n                print(filename, image_format)  # image.mode)\n                print(\"\\tFile format not selected.\")\n            return None\n\n        report_stats = _optimize_with_progs(format_module, filename,\n                                            image_format)\n        report_stats.nag_about_gifs = nag_about_gifs\n        stats.report_saved(report_stats)\n        return report_stats\n    except Exception as exc:\n        print(exc)\n        traceback.print_exc()\n        return stats.ReportStats(filename, error=\"Optimizing Image\")", "response": "Optimize a given image from a filename."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _is_program_selected(progs):\n    mode = False\n    for prog in progs:\n        if getattr(Settings, prog.__name__):\n            mode = True\n            break\n    return mode", "response": "Determine if the program is enabled in the settings."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ndetermining if the image format is selected by command line arguments.", "response": "def is_format_selected(image_format, formats, progs):\n    \"\"\"Determine if the image format is selected by command line arguments.\"\"\"\n    intersection = formats & Settings.formats\n    mode = _is_program_selected(progs)\n    result = (image_format in intersection) and mode\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _is_image_sequenced(image):\n    try:\n        image.seek(1)\n        image.seek(0)\n        result = True\n    except EOFError:\n        result = False\n\n    return result", "response": "Determine if the image is a sequenced image."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the image format.", "response": "def get_image_format(filename):\n    \"\"\"Get the image format.\"\"\"\n    image = None\n    bad_image = 1\n    image_format = NONE_FORMAT\n    sequenced = False\n    try:\n        bad_image = Image.open(filename).verify()\n        image = Image.open(filename)\n        image_format = image.format\n        sequenced = _is_image_sequenced(image)\n    except (OSError, IOError, AttributeError):\n        pass\n\n    if sequenced:\n        image_format = gif.SEQUENCED_TEMPLATE.format(image_format)\n    elif image is None or bad_image or image_format == NONE_FORMAT:\n        image_format = ERROR_FORMAT\n        comic_format = comic.get_comic_format(filename)\n        if comic_format:\n            image_format = comic_format\n        if (Settings.verbose > 1) and image_format == ERROR_FORMAT and \\\n                (not Settings.list_only):\n            print(filename, \"doesn't look like an image or comic archive.\")\n    return image_format"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef detect_file(filename):\n    image_format = get_image_format(filename)\n\n    if image_format in Settings.formats:\n        return image_format\n\n    if image_format in (NONE_FORMAT, ERROR_FORMAT):\n        return None\n\n    if Settings.verbose > 1 and not Settings.list_only:\n        print(filename, image_format, 'is not a enabled image or '\n              'comic archive type.')\n    return None", "response": "Detect the image format and return the appropriate comic archive type."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nupdate the settings with a dict.", "response": "def update(cls, settings):\n        \"\"\"Update settings with a dict.\"\"\"\n        for key, val in settings.__dict__.items():\n            if key.startswith('_'):\n                continue\n            setattr(cls, key, val)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _set_program_defaults(cls, programs):\n        for program in programs:\n            val = getattr(cls, program.__name__) \\\n                and extern.does_external_program_run(program.__name__,\n                                                     Settings.verbose)\n            setattr(cls, program.__name__, val)", "response": "Run the external program tester on the required binaries."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nruns the program tester and determine if we can do anything.", "response": "def config_program_reqs(cls, programs):\n        \"\"\"Run the program tester and determine if we can do anything.\"\"\"\n        cls._set_program_defaults(programs)\n\n        do_png = cls.optipng or cls.pngout or cls.advpng\n        do_jpeg = cls.mozjpeg or cls.jpegrescan or cls.jpegtran\n\n        do_comics = cls.comics\n\n        if not do_png and not do_jpeg and not do_comics:\n            print(\"All optimizers are not available or disabled.\")\n            exit(1)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef optipng(ext_args):\n    args = _OPTIPNG_ARGS + [ext_args.new_filename]\n    extern.run_ext(args)\n    return _PNG_FORMAT", "response": "Run the external program optipng on the file."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef advpng(ext_args):\n    args = _ADVPNG_ARGS + [ext_args.new_filename]\n    extern.run_ext(args)\n    return _PNG_FORMAT", "response": "Run the external program advpng on the file."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nruns the external program pngout on the file.", "response": "def pngout(ext_args):\n    \"\"\"Run the external program pngout on the file.\"\"\"\n    args = _PNGOUT_ARGS + [ext_args.old_filename, ext_args.new_filename]\n    extern.run_ext(args)\n    return _PNG_FORMAT"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate a function chain starting with the specified SCT ( f ) and its arguments.", "response": "def _from_func(cls, f, *args, _attr_scts=None, **kwargs):\n        \"\"\"Creates a function chain starting with the specified SCT (f), and its arguments.\"\"\"\n        func_chain = cls(attr_scts=_attr_scts)\n        func_chain._stack.append([f, args, kwargs])\n        return func_chain"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ntests whether a file exists and make its contents the student code.", "response": "def check_file(\n    state,\n    fname,\n    missing_msg=\"Did you create a file named `{}`?\",\n    is_dir_msg=\"Want to check a file named `{}`, but found a directory.\",\n    parse=True,\n    use_fs=True,\n    use_solution=False,\n):\n    \"\"\"Test whether file exists, and make its contents the student code.\n\n    Note: this SCT fails if the file is a directory.\n    \"\"\"\n\n    if use_fs:\n        p = Path(fname)\n        if not p.exists():\n            state.report(Feedback(missing_msg.format(fname)))  # test file exists\n        if p.is_dir():\n            state.report(Feedback(is_dir_msg.format(fname)))  # test its not a dir\n\n        code = p.read_text()\n    else:\n        code = _get_fname(state, \"student_code\", fname)\n\n        if code is None:\n            state.report(Feedback(missing_msg.format(fname)))  # test file exists\n\n    sol_kwargs = {\"solution_code\": None, \"solution_ast\": None}\n    if use_solution:\n        sol_code = _get_fname(state, \"solution_code\", fname)\n        if sol_code is None:\n            raise Exception(\"Solution code does not have file named: %s\" % fname)\n        sol_kwargs[\"solution_code\"] = sol_code\n        sol_kwargs[\"solution_ast\"] = (\n            state.parse(sol_code, test=False) if parse else None\n        )\n\n    return state.to_child(\n        student_code=code,\n        student_ast=state.parse(code) if parse else None,\n        fname=fname,\n        **sol_kwargs\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ntests whether a directory exists.", "response": "def has_dir(state, fname, incorrect_msg=\"Did you create a directory named `{}`?\"):\n    \"\"\"Test whether a directory exists.\"\"\"\n    if not Path(fname).is_dir():\n        state.report(Feedback(incorrect_msg.format(fname)))\n\n    return state"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nexecuting task. :param task_path: task path :type task_path: str|Callable :param data: task's data :type data: Any :return:", "response": "def exec_task(task_path, data):\n    \"\"\"Execute task.\n\n    :param task_path: task path\n    :type task_path: str|Callable\n    :param data: task's data\n    :type data: Any\n    :return:\n    \"\"\"\n    if not data:\n        data = {'data': None, 'path': task_path}\n\n    elif not isinstance(data, (str, bytes)):\n        data = {'data': json.dumps(data, cls=RequestJSONEncoder),\n                'path': task_path}\n\n    else:\n        # Open the data from file, if necessary.\n        if data is not None and data.startswith(\"file://\"):\n            with open(data[len(\"file://\"):]) as f:\n                data = f.read()\n\n        data = {'data': data, 'path': task_path}\n\n    # Prepare the task.\n    job = Job(data)\n    (task, task_callable) = create_task(task_path)\n\n    with delegating_job_context(job, task, task_callable) as jc:\n        return jc.task_callable(jc.task_data)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nconverts a node tree to a simple nested dict", "response": "def dump(node, config):\n    \"\"\"\n    Convert a node tree to a simple nested dict\n\n    All steps in this conversion are configurable using DumpConfig\n\n    dump dictionary node: {\"type\": str, \"data\": dict}\n    \"\"\"\n    if config.is_node(node):\n        fields = OrderedDict()\n        for name in config.fields_iter(node):\n            attr = config.field_val(node, name)\n            if attr is not None:\n                fields[name] = dump(attr, config)\n        return {\"type\": config.node_type(node), \"data\": fields}\n    elif config.is_list(node):\n        return [dump(x, config) for x in config.list_iter(node)]\n    else:\n        return config.leaf_val(node)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\napply the pagination to the query so that a given page is returned.", "response": "def apply_pagination(self, q):\n        \"\"\"\n        Filters the query so that a given page is returned. The record count\n        must be set in advance.\n        :param q: Query to be paged.\n        :return: Paged query.\n        \"\"\"\n        # type: (Query)->Query\n        assert self.record_count >= 0, \"Record count must be set.\"\n        return q.limit(self.page_size).offset(self.offset)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef paginate(self, q):\n        self.record_count = q.count()\n        return self.apply_pagination(q).all()", "response": "Filters the query so that a given page is returned."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef cluster(seqs, threshold=0.975, out_file=None, temp_dir=None, make_db=True,\n            quiet=False, threads=0, return_just_seq_ids=False, max_memory=800, debug=False):\n    '''\n    Perform sequence clustering with CD-HIT.\n\n    Args:\n\n        seqs (list): An iterable of sequences, in any format that `abutils.utils.sequence.Sequence()`\n            can handle\n\n        threshold (float): Clustering identity threshold. Default is `0.975`.\n\n        out_file (str): Path to the clustering output file. Default is to use\n            `tempfile.NamedTemporaryFile` to generate an output file name.\n\n        temp_dir (str): Path to the temporary directory. If not provided, `'/tmp'` is used.\n\n        make_db (bool): Whether to build a SQlite database of sequence information. Required\n            if you want to calculate consensus/centroid sequences for the resulting\n            clusters or if you need to access the clustered sequences (not just sequence IDs)\n            Default is `True`.\n        \n        quiet (bool): If `True`, surpresses printing of output/progress info. Default is `False`.\n\n        threads (int): Number of threads (CPU cores) to be used for clustering. Default is `0`,\n            which results in all available cores being used.\n        \n        return_just_seq_ids (bool): If `True`, will return a 2D list of sequence IDs\n            (a list containing a list of sequence IDs for each cluster) rather than returning a\n            list of `Cluster` objects.\n\n        max_memory (int): Max memory (in MB) for CD-HIT. Will be passed directly to CD-HIT through\n            the `-M` runtime option. Default is `800`.\n\n        debug (bool): If `True`, print standard output and standard error from CD-HIT. Default is `False`.\n\n    Returns:\n\n        list: A list of `Cluster` objects (or a 2D list of sequence IDs, if `return_just_seq_ids` is `True`).\n    '''\n    if make_db:\n        ofile, cfile, seq_db, db_path = cdhit(seqs, out_file=out_file, temp_dir=temp_dir,\n                                              threshold=threshold, make_db=True, quiet=quiet,\n                                              threads=threads, max_memory=max_memory, debug=debug)            \n        return parse_clusters(ofile, cfile, seq_db=seq_db, db_path=db_path, return_just_seq_ids=return_just_seq_ids)\n    else:\n        seqs = [Sequence(s) for s in seqs]\n        seq_dict = {s.id: s for s in seqs}\n        ofile, cfile, = cdhit(seqs, out_file=out_file, temp_dir=temp_dir, threads=threads,\n                              threshold=threshold, make_db=False, quiet=quiet,\n                              max_memory=max_memory, debug=debug)\n        return parse_clusters(ofile, cfile, seq_dict=seq_dict, return_just_seq_ids=return_just_seq_ids)", "response": "Perform sequence clustering with CD - HIT."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef cdhit(seqs, out_file=None, temp_dir=None, threshold=0.975, make_db=True, quiet=False, threads=0, max_memory=800, retries=5, debug=False):\n    '''\n    Run CD-HIT.\n\n    Args:\n\n        seqs (list): An iterable of sequences, in any format that `abutils.utils.sequence.Sequence()`\n            can handle\n\n        threshold (float): Clustering identity threshold. Default is `0.975`.\n\n        out_file (str): Path to the clustering output file. Default is to use\n            `tempfile.NamedTemporaryFile` to generate an output file name.\n\n        temp_dir (str): Path to the temporary directory. If not provided, `'/tmp'` is used.\n\n        make_db (bool): Whether to build a SQlite database of sequence information. Required\n            if you want to calculate consensus/centroid sequences for the resulting\n            clusters or if you need to access the clustered sequences (not just sequence IDs)\n            Default is `True`.\n        \n        quiet (bool): If `True`, surpresses printing of output/progress info. Default is `False`.\n\n        threads (int): Number of threads (CPU cores) to be used for clustering. Default is `0`,\n            which results in all available cores being used.\n\n        max_memory (int): Max memory (in MB) for CD-HIT. Will be passed directly to CD-HIT through\n            the `-M` runtime option. Default is `800`.\n\n        debug (bool): If `True`, print standard output and standard error from CD-HIT. Default is `False`.\n\n    Returns:\n\n        If `make_db` is `True`, returns the CD-HIT output file path, the CD-HIT cluster file path,\n            a `sqlite3` database connection object, and the database path. If `make_db` is `False`, only the\n            CD-HIT output file path and CD-HIT cluster file path are returned.\n    '''\n    start_time = time.time()\n    seqs = [Sequence(s) for s in seqs]\n    if not quiet:\n        print('CD-HIT: clustering {} seqeunces'.format(len(seqs)))\n    if out_file is None:\n        out_file = tempfile.NamedTemporaryFile(dir=temp_dir, delete=False)\n        out_file.close()\n        ofile = out_file.name\n    else:\n        ofile = os.path.expanduser(out_file)\n    cfile = ofile + '.clstr'\n    with open(ofile, 'w') as f: f.write('')\n    with open(cfile, 'w') as f: f.write('')\n    ifile = _make_cdhit_input(seqs, temp_dir)\n    cdhit_cmd = 'cdhit -i {} -o {} -c {} -n 5 -d 0 -T {} -M {}'.format(ifile,\n                                                                       ofile,\n                                                                       threshold,\n                                                                       threads,\n                                                                       max_memory)\n    while not all([os.path.getsize(cfile), os.path.getsize(cfile)]):\n        cluster = sp.Popen(cdhit_cmd,\n                        shell=True,\n                        stdout=sp.PIPE,\n                        stderr=sp.PIPE)\n        stdout, stderr = cluster.communicate()\n        if not retries:\n            break\n        retries -= 1\n    end_time = time.time()\n    if debug:\n        print(stdout)\n        print(stderr)\n    else:\n        os.unlink(ifile)\n    if not quiet:\n        print('CD-HIT: clustering took {:.2f} seconds'.format(end_time - start_time))\n    if make_db:\n        if not quiet:\n            print('CD-HIT: building a SQLite3 database')\n        seq_db, db_path = _build_seq_db(seqs, direc=temp_dir)\n        return ofile, cfile, seq_db, db_path\n    return ofile, cfile", "response": "Run CD - HIT on a list of sequences."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nparse the CD - HIT output file and returns a list of cluster objects.", "response": "def parse_clusters(out_file, clust_file, seq_db=None, db_path=None, seq_dict=None, return_just_seq_ids=False):\n    '''\n    Parses CD-HIT output.\n\n    Args:\n\n        out_file (str): Path to the CD-HIT output file. Required.\n\n        clust_file (str): Path to the CD-HIT cluster file. Required.\n\n        seq_db (sqlite.Connection): SQLite3 `Connection` object. Default is `None`. If not provided and\n            `return_just_seq_ids` is False, the returned `Cluster` objects will not contain any sequence\n            information beyond the sequence ID.\n\n        db_path (str): Path to a SQLite3 database file. Default is `None`. Must be provided if\n            `seq_db` is also provided.\n\n        seq_dict (dict): A `dict` mapping sequence IDs to `abutils.core.sequence.Sequence` objects. Default\n            is `None`. Typically used when a relatively small number of sequences are being clustered and\n            creating a `sqlite3` database would be overkill.\n\n        temp_dir (str): Path to the temporary directory. If not provided, `'/tmp'` is used.\n\n        make_db (bool): Whether to build a SQlite database of sequence information. Required\n            if you want to calculate consensus/centroid sequences for the resulting\n            clusters or if you need to access the clustered sequences (not just sequence IDs)\n            Default is `True`.\n        \n        quiet (bool): If `True`, surpresses printing of output/progress info. Default is `False`.\n\n        threads (int): Number of threads (CPU cores) to be used for clustering. Default is `0`,\n            which results in all available cores being used.\n        \n        return_just_seq_ids (bool): If `True`, will return a 2D list of sequence IDs\n            (a list containing a list of sequence IDs for each cluster) rather than returning a\n            list of `Cluster` objects.\n\n        max_memory (int): Max memory (in MB) for CD-HIT. Will be passed directly to CD-HIT through\n            the `-M` runtime option. Default is `800`.\n\n        debug (bool): If `True`, print standard output and standard error from CD-HIT. Default is `False`.\n\n    Returns:\n\n        A CDHITResult object, or a 2D list of sequence IDs, if `return_just_seq_ids` is `True`.\n    '''\n    raw_clusters = [c.split('\\n') for c in open(clust_file, 'r').read().split('\\n>')]\n    if return_just_seq_ids:\n        ids = []\n        for rc in raw_clusters:\n            _ids = []\n            for c in rc[1:]:\n                if c:\n                    _ids.append(c.split()[2][1:-3])\n            ids.append(_ids)\n        os.unlink(out_file)\n        os.unlink(clust_file)\n        return ids\n    os.unlink(out_file)\n    os.unlink(clust_file)\n    clusters = [Cluster(rc, seq_db, db_path, seq_dict) for rc in raw_clusters]\n    return CDHITResult(clusters, seq_db=seq_db, db_path=db_path, seq_dict=seq_dict)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef log_output(f):\n\n    @wraps(f)\n    def wrapper_fn(*args, **kwargs):\n        res = f(*args, **kwargs)\n        logging.debug(\"Logging result %s.\", res)\n        return res\n\n    return wrapper_fn", "response": "A decorator that logs the output of a function."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef save_to_file(destination_filename, append=False):\n\n    def decorator_fn(f):\n        @wraps(f)\n        def wrapper_fn(*args, **kwargs):\n            res = f(*args, **kwargs)\n\n            makedirs(os.path.dirname(destination_filename))\n            mode = \"a\" if append else \"w\"\n            with open(destination_filename, mode) as text_file:\n                text_file.write(res)\n\n            return res\n\n        return wrapper_fn\n\n    return decorator_fn", "response": "Decorator to save the output value to file."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nexpecting task input data in json format and parse this data.", "response": "def json_input(f):\n    \"\"\"\n    Expects task input data in json format and parse this data.\n    \"\"\"\n\n    @wraps(f)\n    def json_input_decorator(*args, **kwargs):\n        # If the data is already transformed, we do not transform it any\n        # further.\n        task_data = _get_data_from_args(args)\n\n        if task_data is None:\n            logging.error(\"Task data is empty during JSON decoding.\")\n\n        if task_data.payload:\n            try:\n                is_transformed = request.get_json()\n\n                # We transform the data only in the case of plain POST requests.\n                if not is_transformed:\n                    task_data.transform_payload(json.loads)\n            except (ValueError, RuntimeError):\n                logging.error(\n                    \"Exception while processing JSON input decorator.\")\n                task_data.transform_payload(json.loads)\n        else:\n            task_data.transform_payload(lambda _: {})\n\n        return f(*args, **kwargs)\n\n    return json_input_decorator"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef json_output(f):\n\n    @wraps(f)\n    def json_output_decorator(*args, **kwargs):\n        @inject(config=Config)\n        def get_config(config):\n            return config\n\n        config = get_config()\n\n        rv = f(*args, **kwargs)\n        indent = None\n        if config.get('DEBUG', False):\n            logging.getLogger(__name__).debug(\"Formatting JSON nicely.\")\n            indent = 2\n        rv = json.dumps(rv, cls=AppModelJSONEncoder, indent=indent)\n        _set_json_response_content_type()\n        return rv\n\n    return json_output_decorator", "response": "Decorator to format response to json and in case of web - request set response content type to application / json."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nformats response to jsonp and add a callback to JSON data - a jsonp request", "response": "def jsonp_wrap(callback_key='callback'):\n    \"\"\"\n    Format response to jsonp and add a callback to JSON data - a jsonp request\n    \"\"\"\n\n    def decorator_fn(f):\n\n        @wraps(f)\n        def jsonp_output_decorator(*args, **kwargs):\n            task_data = _get_data_from_args(args)\n            data = task_data.get_data()\n\n            if callback_key not in data:\n                raise KeyError(\n                    'Missing required parameter \"{0}\" for task.'.format(\n                        callback_key))\n\n            callback = data[callback_key]\n            jsonp = f(*args, **kwargs)\n            if isinstance(JobContext.get_current_context(), WebJobContext):\n                JobContext.get_current_context().add_responder(\n                    MimeSetterWebTaskResponder('application/javascript'))\n            jsonp = \"{callback}({data})\".format(callback=callback, data=jsonp)\n\n            return jsonp\n\n        return jsonp_output_decorator\n\n    return decorator_fn"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nformat task result to json output in jsend specification format. See: https://github.com/omniti-labs. Task return value must be dict or None. @param fail_exception_classes: exceptions which will produce 'fail' response status.", "response": "def jsend_output(fail_exception_classes=None):\n    \"\"\"\n    Format task result to json output in jsend specification format. See:\n    https://github.com/omniti-labs. Task return value must be dict or None.\n\n    @param fail_exception_classes: exceptions which will produce 'fail' response\n    status.\n    \"\"\"\n\n    fail_exception_classes = fail_exception_classes if fail_exception_classes \\\n        else ()\n\n    def decorator_fn(f):\n\n        @wraps(f)\n        @json_output\n        def jsend_output_decorator(*args, **kwargs):\n            try:\n                rv = f(*args, **kwargs)\n            except fail_exception_classes as e:\n                return {'status': 'fail', 'data': {'message': str(e)}}\n            except Exception as e:\n                logging.error(str(e) + \"\\n\" + traceback.format_exc())\n                return {'status': 'error', 'message': 'Server error.'}\n\n            if not isinstance(rv, dict) and rv is not None:\n                msg = 'jsend_output decorator error: task must return dict ' \\\n                      'or None.\\nTask return value: {0}.'\n                logging.error(msg.format(rv))\n                return {'status': 'error', 'message': 'Server error.'}\n\n            return {'status': 'success', 'data': rv}\n\n        return jsend_output_decorator\n\n    return decorator_fn"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef web_error_and_result(f):\n\n    @wraps(f)\n    def web_error_and_result_decorator(*args, **kwargs):\n        return error_and_result_decorator_inner_fn(f, True, *args, **kwargs)\n\n    return web_error_and_result_decorator", "response": "Decorator for web error_and_result"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nformatting task result into json dictionary `{'data': task return value}` if no exception was raised during the task execution. If there was raised an exception during task execution, formats task result into dictionary `{'error': exception message with traceback}`.", "response": "def error_and_result(f):\n    \"\"\"\n    Format task result into json dictionary `{'data': task return value}` if no\n    exception was raised during the task execution. If there was raised an\n    exception during task execution, formats task result into dictionary\n    `{'error': exception message with traceback}`.\n    \"\"\"\n\n    @wraps(f)\n    def error_and_result_decorator(*args, **kwargs):\n        return error_and_result_decorator_inner_fn(f, False, *args, **kwargs)\n\n    return error_and_result_decorator"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ntasking decorator which checks if the given variables (indices) are stored inside the task data.", "response": "def required_data(*data):\n    \"\"\"\n    Task decorator which checks if the given variables (indices) are stored\n    inside the task data.\n    \"\"\"\n\n    def decorator_fn(f):\n\n        @wraps(f)\n        def required_data_decorator(*args, **kwargs):\n            task_data = _get_data_from_args(args).get_data()\n            for i in data:\n                if i not in task_data:\n                    raise KeyError(\n                        'Missing required parameter \"{0}\" for task.'.format(i))\n\n            return f(*args, **kwargs)\n\n        return required_data_decorator\n\n    return decorator_fn"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef append_get_parameters(accept_only_web=True):\n    # type: (bool) -> Callable\n    \"\"\"\n    Task decorator which appends the GET data to the task data.\n\n    :param accept_only_web: Parameter which limits using this task only\n                            with web requests.\n    \"\"\"\n\n    def wrapper(f):\n\n        @wraps(f)\n        def append_get_parameters_wrapper_fn(*args, **kwargs):\n            jc = JobContext.get_current_context()\n\n            if isinstance(jc, WebJobContext):\n                # Update the data with GET parameters\n                web_request = jc.get_web_request()\n                task_data = _get_data_from_args(args)\n                data = task_data.get_data()\n                data.update(web_request.args.to_dict(flat=True))\n            elif accept_only_web:\n                # Raise exception on non web usage if necessary\n                raise Exception(\"append_get_parameters decorator may be used \"\n                                \"with GET requests only.\")\n\n            return f(*args, **kwargs)\n\n        return append_get_parameters_wrapper_fn\n\n    return wrapper", "response": "Decorator which appends GET parameters to the task data."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef web_task(f):\n\n    @wraps(f)\n    def web_task_decorator(*args, **kwargs):\n        jc = JobContext.get_current_context()\n        if not isinstance(jc, WebJobContext):\n            raise Exception(\n                \"The WebTask is not called through the web interface.\")\n        data = f(*args, **kwargs)\n        jc.add_responder(WebTaskResponder(data))\n        return data['data'] if 'data' in data else \"\"\n\n    return web_task_decorator", "response": "Decorator for web tasks."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef secured_task(f):\n\n    @wraps(f)\n    def secured_task_decorator(*args, **kwargs):\n        task_data = _get_data_from_args(args)\n        assert isinstance(task_data, TaskData)\n        if not verify_security_data(task_data.get_data()['security']):\n            raise SecurityException(\n                task_data.get_data()['security']['hashed_token'])\n\n        task_data.transform_payload(lambda x: x['data'])\n        return f(*args, **kwargs)\n\n    return secured_task_decorator", "response": "A decorator that returns a task that checks that the task data is valid and then passes it to the task decorator."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef xml_output(f):\n\n    @wraps(f)\n    def xml_output_inner_fn(*args, **kwargs):\n        ret_val = f(*args, **kwargs)\n\n        if isinstance(JobContext.get_current_context(), WebJobContext):\n            JobContext.get_current_context().add_responder(\n                MimeSetterWebTaskResponder('text/xml'))\n        return ret_val\n\n    return xml_output_inner_fn", "response": "Decorator for handling XML output."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns list of `werkzeug.datastructures.FileStorage` objects - files to be uploaded", "response": "def file_upload(f):\n    \"\"\"\n    Return list of `werkzeug.datastructures.FileStorage` objects - files to be\n    uploaded\n    \"\"\"\n\n    @wraps(f)\n    def file_upload_decorator(*args, **kwargs):\n        # If the data is already transformed, we do not transform it any\n        # further.\n        task_data = _get_data_from_args(args)\n\n        if task_data is None:\n            logging.error(\"Task data is empty during FilesUploadDecorator.\")\n\n        task_data.transform_payload(lambda _: request.files.getlist('file'))\n        return f(*args, **kwargs)\n\n    return file_upload_decorator"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef forbid_web_access(f):\n\n    @wraps(f)\n    def wrapper_fn(*args, **kwargs):\n        if isinstance(JobContext.get_current_context(), WebJobContext):\n            raise ForbiddenError('Access forbidden from web.')\n\n        return f(*args, **kwargs)\n\n    return wrapper_fn", "response": "Decorator for forbid running task using http request."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nparse filter URL argument arg and apply to query.", "response": "def filter_from_url_arg(model_cls, query, arg, query_operator=and_,\n                        arg_types=None):\n    \"\"\"\n    Parse filter URL argument ``arg`` and apply to ``query``\n\n    Example: 'column1<=value,column2==value' -> query.filter(Model.column1 <= value, Model.column2 == value)\n    \"\"\"\n\n    fields = arg.split(',')\n    mapper = class_mapper(model_cls)\n\n    if not arg_types:\n        arg_types = {}\n\n    exprs = []\n    joins = set()\n    for expr in fields:\n        if expr == \"\":\n            continue\n\n        e_mapper = mapper\n        e_model_cls = model_cls\n\n        operator = None\n        method = None\n        for op in operator_order:\n            if op in expr:\n                operator = op\n                method = operator_to_method[op]\n                break\n\n        if operator is None:\n            raise Exception('No operator in expression \"{0}\".'.format(expr))\n\n        (column_names, value) = expr.split(operator)\n\n        column_names = column_names.split('__')\n        value = value.strip()\n\n        for column_name in column_names:\n            if column_name in arg_types:\n                typed_value = arg_types[column_name](value)\n            else:\n                typed_value = value\n\n            if column_name in e_mapper.relationships:\n                joins.add(column_name)\n                e_model_cls = e_mapper.attrs[column_name].mapper.class_\n                e_mapper = class_mapper(e_model_cls)\n\n        if hasattr(e_model_cls, column_name):\n            column = getattr(e_model_cls, column_name)\n            exprs.append(getattr(column, method)(typed_value))\n        else:\n            raise Exception('Invalid property {0} in class {1}.'.format(column_name, e_model_cls))\n\n    return query.join(*joins).filter(query_operator(*exprs))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncreate a simple tree of model s properties and its related models.", "response": "def model_tree(name, model_cls, visited=None):\n    \"\"\"Create a simple tree of model's properties and its related models.\n\n    It traverse trough relations, but ignore any loops.\n\n    :param name: name of the model\n    :type name: str\n    :param model_cls: model class\n    :param visited: set of visited models\n    :type visited: list or None\n    :return: a dictionary where values are lists of string or other \\\n    dictionaries\n    \"\"\"\n    if not visited:\n        visited = set()\n\n    visited.add(model_cls)\n\n    mapper = class_mapper(model_cls)\n    columns = [column.key for column in mapper.column_attrs]\n    related = [model_tree(rel.key, rel.mapper.entity, visited)\n               for rel in mapper.relationships if rel.mapper.entity not in visited]\n\n    return {name: columns + related}"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef flat_model(tree):\n    names = []\n    for columns in viewvalues(tree):\n        for col in columns:\n            if isinstance(col, dict):\n                col_name = list(col)[0]\n                names += [col_name + '__' + c for c in flat_model(col)]\n            else:\n                names.append(col)\n\n    return names", "response": "Flatten the tree into a list of properties adding parents as prefixes."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef execute_job(job, app=Injected, task_router=Injected):\n    # type: (Job, Zsl, TaskRouter) -> dict\n    \"\"\"Execute a job.\n\n    :param job: job to execute\n    :type job: Job\n    :param app: service application instance, injected\n    :type app: ServiceApplication\n    :param task_router: task router instance, injected\n    :type task_router: TaskRouter\n    :return: task result\n    :rtype: dict\n    \"\"\"\n\n    app.logger.info(\"Job fetched, preparing the task '{0}'.\".format(job.path))\n\n    task, task_callable = task_router.route(job.path)\n    jc = JobContext(job, task, task_callable)\n\n    app.logger.info(\"Executing task.\")\n    result = jc.task_callable(jc.task_data)\n\n    app.logger.info(\"Task {0} executed successfully.\".format(job.path))\n\n    return {'task_name': job.path, 'data': result}", "response": "Execute a job.\n\n    :param job: job to execute\n    :type job: Job\n    :param app: service application instance, injected\n    :type app: ServiceApplication\n    :param task_router: task router instance, injected\n    :type task_router: TaskRouter\n    :return: task result\n    :rtype: dict"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef handle_exception(self, e, task_path):\n        # type: (Exception, str) -> dict\n        \"\"\"Handle exception raised during task execution.\n\n        :param e: exception\n        :type e: Exception\n        :param task_path: task path\n        :type task_path: str\n        :return: exception as task result\n        :rtype: dict\n        \"\"\"\n\n        self._app.logger.error(str(e) + \"\\n\" + traceback.format_exc())\n        return {'task_name': task_path, 'data': None, 'error': str(e)}", "response": "Handle exception raised during task execution."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef execute_job(self, job):\n        # type: (Job) -> dict\n        \"\"\"Execute job given by the task queue.\n\n        :param job: job\n        :type job: Job\n        :return: task result\n        :rtype: dict\n        \"\"\"\n        try:\n            return execute_job(job)\n\n        except KillWorkerException:\n            self._app.logger.info(\"Stopping Gearman worker on demand flag set.\")\n            self.stop_worker()\n\n        except Exception as e:\n            return self.handle_exception(e, job.path)", "response": "Execute the job given by the task queue."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef legacy_signature(**kwargs_mapping):\n\n    def signature_decorator(f):\n        @wraps(f)\n        def wrapper(*args, **kwargs):\n            redirected_kwargs = {\n                kwargs_mapping[k] if k in kwargs_mapping else k: v\n                for k, v in kwargs.items()\n            }\n            return f(*args, **redirected_kwargs)\n\n        return wrapper\n\n    return signature_decorator", "response": "A decorator that makes it possible to call a function using old argument names\n    when they are passed as keyword arguments."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _bind_service(package_name, cls_name, binder=Injected):\n        module = importlib.import_module(package_name)\n        cls = getattr(module, cls_name)\n\n        binder.bind(\n            cls,\n            to=binder.injector.create_object(cls),\n            scope=singleton\n        )\n        logging.debug(\"Created {0} binding.\".format(cls))", "response": "Bind a service to application injector."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef initialize(config):\n        service_injection_config = config.get('SERVICE_INJECTION', ())\n\n        if not isinstance(service_injection_config, (tuple, list)):\n            service_injection_config = (service_injection_config,)\n\n        for si_conf in service_injection_config:\n            if isinstance(si_conf, str):\n                package_name, cls_name = si_conf.rsplit('.', 1)\n                ServiceInitializer._bind_service(package_name, cls_name)\n            elif isinstance(si_conf, dict):\n                services = si_conf['list']\n                service_package = si_conf['package']\n\n                for cls_name in services:\n                    module_name = camelcase_to_underscore(cls_name)\n                    package_name = \"{0}.{1}\".format(service_package, module_name)\n                    ServiceInitializer._bind_service(package_name, cls_name)", "response": "Initialize method.\n\n        :param config: current application config, injected\n        :type config: Config"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ndecorates an object method as a background task (called with help of gearman). You have to create a task which will handle the gearman call. The method arguments will be encoded as JSON. :param task: name of the task :type task: str :return: decorated function", "response": "def background_task_method(task):\n    \"\"\"Decorate an object method as a background task (called with help of\n    gearman).\n\n    You have to create a task which will handle the gearman call. The\n    method arguments will be encoded as JSON.\n\n    :param task: name of the task\n    :type task: str\n    :return: decorated function\n    \"\"\"\n\n    # TODO ako vysledok vrat nejaky JOB ID, aby sa dalo checkovat na pozadi\n    # TODO vytvorit este vseobecny background_task nielen pre metody\n\n    def decorator_fn(fn):\n\n        gearman = None\n\n        @inject(config=Config)\n        def gearman_connect(config):\n            # type: (Config) -> GearmanService\n            if 'GEARMAN' not in config or 'host' not in config['GEARMAN'] or 'GEARMAN_TASK_NAME' not in config:\n                raise Exception(\"Missing gearman settings (trying to use backgorund task)\")\n\n            gearman_host = (config['GEARMAN']['host'], config['GEARMAN']['port']) if config['GEARMAN']['port'] \\\n                else config['GEARMAN']['host']\n            gearman_service = GearmanService({'HOST': [gearman_host], 'TASK_NAME': config['GEARMAN_TASK_NAME']})\n            gearman_service.set_blocking(False)\n\n            return gearman_service\n\n        def get_gearman_client():\n            # type: () -> GearmanService\n            global gearman\n\n            if not gearman:\n                gearman = gearman_connect()\n\n            return gearman\n\n        @wraps(fn)\n        def background_task_decorator(*args, **kwargs):\n            # The first of the args is self.\n            t = RawTask(task, dict(method=fn.__name__, args=args[1:], kwargs=kwargs))\n            t_result = get_gearman_client().call(t, [JsonTask])\n            return t_result.result\n\n        background_task_decorator._background_fn = fn\n        return background_task_decorator\n\n    return decorator_fn"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _get_link_pages(page, per_page, count, page_url):\n    # type: (int, int, int, str) -> Dict[str, str]\n    \"\"\"Create link header for page metadata.\n\n    :param page: current page\n    :param per_page: page limit\n    :param count: count of all resources\n    :param page_url: url for resources\n    :return: dictionary with name of the link as key and its url as value\n    \"\"\"\n    current_page = _page_arg(page)\n    links = {}\n    end = page * per_page\n\n    if page > 1:\n        links['prev'] = page_url.replace(current_page, _page_arg(page - 1))\n\n    if end < count:\n        links['next'] = page_url.replace(current_page, _page_arg(page + 1))\n\n    if per_page < count:\n        links['first'] = page_url.replace(current_page, _page_arg(1))\n        links['last'] = page_url.replace(current_page, _page_arg((count + per_page - 1) // per_page))\n\n    return links", "response": "Create a dictionary of links to all resources in a resource page."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nconverting the url arg to a filter.", "response": "def to_filter(self, query, arg):\n        \"\"\"Json-server filter using the _or_ operator.\"\"\"\n        return filter_from_url_arg(self.model_cls, query, arg, query_operator=or_)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nadd created http status response and location link.", "response": "def create(self, *args, **kwargs):\n        \"\"\"Adds created http status response and location link.\"\"\"\n        resource = super(JsonServerResource, self).create(*args, **kwargs)\n\n        return ResourceResult(\n            body=resource,\n            status=get_http_status_code_value(http.client.CREATED),\n            location=\"{}/{}\".format(request.url, resource.get_id())\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _create_filter_by(self):\n        filter_by = []\n\n        for name, values in request.args.copy().lists():  # copy.lists works in py2 and py3\n            if name not in _SKIPPED_ARGUMENTS:\n                column = _re_column_name.search(name).group(1)\n\n                if column not in self._model_columns:\n                    continue\n\n                for value in values:\n                    if name.endswith('_ne'):\n                        filter_by.append(name[:-3] + '!=' + value)\n                    elif name.endswith('_lte'):\n                        filter_by.append(name[:-4] + '<=' + value)\n                    elif name.endswith('_gte'):\n                        filter_by.append(name[:-4] + '>=' + value)\n                    elif name.endswith('_like'):\n                        filter_by.append(name[:-5] + '::like::%' + value + '%')\n                    else:\n                        filter_by.append(name.replace('__', '.') + '==' + value)\n\n        filter_by += self._create_fulltext_query()\n\n        return ','.join(filter_by)", "response": "Transform the json - server filter arguments to model - resource ones."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _create_related(args):\n        # type: (Dict) -> None\n        \"\"\"Create related field from `_embed` arguments.\"\"\"\n        if '_embed' in request.args:\n            embeds = request.args.getlist('_embed')\n\n            args['related'] = ','.join(embeds)\n\n            del args['_embed']", "response": "Create related field from _embed arguments."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _create_fulltext_query(self):\n        filter_by = []\n\n        if 'q' in request.args:\n            columns = flat_model(model_tree(self.__class__.__name__, self.model_cls))\n            for q in request.args.getlist('q'):\n                filter_by += ['{col}::like::%{q}%'.format(col=col, q=q) for col in columns]\n\n        return filter_by", "response": "Support the json - server fulltext search with a broad LIKE filter."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ntransforms all list arguments from json - server to model - resource ones.", "response": "def _transform_list_args(self, args):\n        # type: (dict) -> None\n        \"\"\"Transforms all list arguments from json-server to model-resource ones.\n\n        This modifies the given arguments.\n        \"\"\"\n\n        if '_limit' in args:\n            args['limit'] = int(args['_limit'])\n            del args['_limit']\n\n        if '_page' in args:\n            page = int(args['_page'])\n            if page < 0:\n                page = 1\n\n            args['page'] = page\n            del args['_page']\n\n            if 'limit' not in args:\n                args['limit'] = 10\n\n        if '_end' in args:\n            end = int(args['_end'])\n            args['limit'] = end - int(args.get('_start', 0))\n\n        if '_start' in args:\n            args['offset'] = args['_start']\n            del args['_start']\n\n        if '_sort' in args:\n            args['order_by'] = args['_sort'].replace('__', '.')\n            del args['_sort']\n\n            if args.get('_order', 'ASC') == 'DESC':\n                args['order_by'] = '-' + args['order_by']\n\n        if '_order' in args:\n            del args['_order']\n\n        filter_by = self._create_filter_by()\n        if filter_by:\n            args['filter_by'] = filter_by"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nmodifying the parameters and adds metadata for read results.", "response": "def read(self, params, args, data):\n        \"\"\"Modifies the parameters and adds metadata for read results.\"\"\"\n        result_count = None\n        result_links = None\n\n        if params is None:\n            params = []\n        if args:\n            args = args.copy()\n        else:\n            args = {}\n\n        ctx = self._create_context(params, args, data)\n        row_id = ctx.get_row_id()\n\n        if not row_id:\n            self._transform_list_args(args)\n\n            if 'page' in args or 'limit' in args:\n                ctx = self._create_context(params, args, data)\n\n                result_count = self._get_collection_count(ctx)\n\n            if 'page' in args:\n                result_links = _get_link_pages(\n                    page=args['page'],\n                    per_page=int(args['limit']),\n                    count=result_count,\n                    page_url=request.url\n                )\n\n            if 'limit' not in args:\n                args['limit'] = 'unlimited'\n\n        self._create_related(args)\n\n        try:\n            return ResourceResult(\n                body=super(JsonServerResource, self).read(params, args, data),\n                count=result_count,\n                links=result_links\n            )\n        except NoResultFound:\n            return NOT_FOUND"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef update(self, *args, **kwargs):\n        if request.method == 'PUT':\n            logging.warning(\"Called not implemented resource method PUT\")\n\n        resource = super(JsonServerResource, self).update(*args, **kwargs)\n\n        if resource:\n            return resource\n        else:\n            return NOT_FOUND", "response": "Modifies the parameters and adds metadata for update results."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef delete(self, params, args, data):\n        ctx = self._create_context(params, args, data)\n        row_id = ctx.get_row_id()\n\n        if row_id:\n            deleted = self._delete_one(row_id, ctx)\n\n            if deleted:\n                return ResourceResult(body={})\n            else:\n                return NOT_FOUND\n        else:\n            return NOT_FOUND", "response": "Supports only singular delete and adds proper http status."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef run_task(task_cls, task_data):\n    task = instantiate(task_cls)\n    task_callable = get_callable(task)\n    return task_callable(TaskData(task_data))", "response": "Instantiate and run the perform method od given task data."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef run_task_json(task_cls, task_data):\n    # TODO what does set_skipping_json do?\n    task = instantiate(task_cls)\n    task_callable = get_callable(task)\n    td = TaskData(task_data)\n    td.set_skipping_json(True)\n    return task_callable(td)", "response": "Instantiate and run the perform method od given task data."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\naggregate the data into a single list of counts.", "response": "def _aggregate(data, norm=True, sort_by='value', keys=None):\n    '''\n    Counts the number of occurances of each item in 'data'.\n\n    Inputs\n    data: a list of values.\n    norm: normalize the resulting counts (as percent)\n    sort_by: how to sort the retured data. Options are 'value' and 'count'.\n\n    Output\n    a non-redundant list of values (from 'data') and a list of counts.\n    '''\n    if keys:\n        vdict = {k: 0 for k in keys}\n        for d in data:\n            if d in keys:\n                vdict[d] += 1\n    else:\n        vdict = {}\n        for d in data:\n            vdict[d] = vdict[d] + 1 if d in vdict else 1\n    vals = [(k, v) for k, v in vdict.items()]\n    if sort_by == 'value':\n        vals.sort(key=lambda x: x[0])\n    else:\n        vals.sort(key=lambda x: x[1])\n    xs = [v[0] for v in vals]\n    if norm:\n        raw_y = [v[1] for v in vals]\n        total_y = sum(raw_y)\n        ys = [100. * y / total_y for y in raw_y]\n    else:\n        ys = [v[1] for v in vals]\n    return xs, ys"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef generate_apiary_doc(task_router):\n    generator = ApiaryDoc()\n\n    for m in task_router.get_task_packages() + get_method_packages():\n        m = importlib.import_module(m)\n        generator.docmodule(m)\n\n    return generator", "response": "Generate apiary documentation.\n\n    Create a Apiary generator and add application packages to it.\n\n    :param task_router: task router, injected\n    :type task_router: TaskRouter\n    :return: apiary generator\n    :rtype: ApiaryDoc"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef setup_logging(logfile, print_log_location=True, debug=False):\n    '''\n    Set up logging using the built-in ``logging`` package.\n\n    A stream handler is added to all logs, so that logs at or above\n    ``logging.INFO`` level are printed to screen as well as written\n    to the log file.\n\n    Arguments:\n\n        logfile (str): Path to the log file. If the parent directory\n            does not exist, it will be created. Required.\n\n        print_log_location (bool): If ``True``, the log path will be\n            written to the log upon initialization. Default is ``True``.\n\n        debug (bool): If true, the log level will be set to ``logging.DEBUG``.\n            If ``False``, the log level will be set to ``logging.INFO``.\n            Default is ``False``.\n    '''\n    log_dir = os.path.dirname(logfile)\n    make_dir(log_dir)\n    fmt = '[%(levelname)s] %(name)s %(asctime)s %(message)s'\n    if debug:\n        logging.basicConfig(filename=logfile,\n                            filemode='w',\n                            format=fmt,\n                            level=logging.DEBUG)\n    else:\n        logging.basicConfig(filename=logfile,\n                            filemode='w',\n                            format=fmt,\n                            level=logging.INFO)\n    logger = logging.getLogger('log')\n    logger = add_stream_handler(logger)\n    if print_log_location:\n        logger.info('LOG LOCATION: {}'.format(logfile))", "response": "Setup logging using the built - in logging package."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_logger(name=None):\n    '''\n    Get a logging handle.\n\n    As with ``setup_logging``, a stream handler is added to the\n    log handle.\n\n    Arguments:\n\n        name (str): Name of the log handle. Default is ``None``.\n    '''\n    logger = logging.getLogger(name)\n    if len(logger.handlers) == 0:\n        logger = add_stream_handler(logger)\n    return logger", "response": "Get a logging handle."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ngenerate a lineage phylogeny figure.", "response": "def phylogeny(sequences=None, project_dir=None, name=None, aln_file=None, tree_file=None,\n        seq_field=None, name_field=None, aa=False, species='human', unrooted=False, ladderize=True,\n        root=None, root_name=None, show_root_name=False, color_dict=None, color_function=None,\n        order_dict=None, order_function=None, color_node_labels=False, label_colors=None,\n        scale=None, branch_vert_margin=None, fontsize=12, show_names=True, show_scale=False,\n        mirror=False, min_order_fraction=0.1, figname_prefix=None, figname_suffix=None,\n        # linked_alignment=None, alignment_fontsize=11, alignment_height=50, alignment_width=50, \n        compact_alignment=False, scale_factor=1, rename_function=None, linewidth=1.0,\n        delete_nodes=None, quiet=True):\n    '''\n    Generates a lineage phylogeny figure.\n\n    Args:\n\n        sequences (list(Sequence)): A list of ``Sequence`` objects from which a phylogeny\n            will be calculated. Strictly speaking, they do not need to be ``Sequence`` objects,\n            rather, any object that contains the sequence name as the ``id`` attribute (or\n            by dictionary-style lookup using the provided ``name_field``) and contains the\n            sequence as the ``sequence`` attribute (or by dictionary-stype lookup using the\n            provided ``seq_field``).\n\n        project_dir (str): directory into which all phylogeny files will be deposited,\n            including alignment, tree and figure files.\n\n        name (str): Name to be used for naming alignment, tree, and phylogeny files. If not\n            provided, a random name will be generated.\n\n        aln_file (str): if a multiple sequence alignment has already been calculated,\n            passing the path to the alignment file (in FASTA format) will force Lineage.phylogeny()\n            to use the supplied msa instead of computing a new one.\n\n        tree_file (str): if a tree file has already been calculated, passing the path\n            to the pre-computed tree file will force ``phylogeny()`` to use\n            the supplied tree file instead of computing a new one. It is important to note that\n            only sequence names will be parsed from the tree_file, so if ``order_function`` or\n            ``color_function`` is also provided, ensure that these functions only require the\n            sequence ID rather than the entire sequence.\n\n        aa (bool): if True, use amino acid sequences to compute the phylogeny.\n            Default is False.\n\n        root (Sequence, str: The root can be provided either as a ``Sequence`` object (if ``sequences``\n            are being provided) or as the name of a sequence that can be found either in\n            ``sequences`` or in the provided ``aln_file`` or ``tree_file``. Note that if\n            either ``aln_file`` or ``tree_file`` are provided, the root must be provided\n            as the sequence name, not as a ``Sequence`` object (as the root sequence must\n            already be included in either ``aln_file`` or ``tree_file``. If the root is not\n            provided, the germline V-gene sequence of the\n\n        color_dict (dict): Dictionary with sequence IDs as keys and colors (hex format) as values. If any\n            sequence IDs are not found in the dict, they will be colored black. If neither ``color_dict`` nor\n            ``color_function`` is provided, all leaves will be colored black.\n\n        color_function (func): Function that that accepts a ``Sequence`` object and returns the color\n            (as a hex code). If ``color_dict`` is also provided, ``color_function`` is ignored. Additionally,\n            ``color_function`` will only be used if ``sequences`` are provided. If ``sequences`` are not provided\n            (instead using ``aln_file` or ``tree_file``), ``color_dict`` must be used instead of ``color_function``.\n\n        orders: a dictionary with sequence IDs as keys and orders (integers) as values.\n            If not provided, only the leaf branches will be colored (if <colors> or\n            <color_function> is provided).\n\n        chain: build a phylogeny using the given chain ('heavy' or 'light').\n            Default is 'heavy'.\n\n        filter_function: function used to filter sequences (identity-based clustering, for\n            example). The function should accept a list of Sequence objects and return\n            a list of Sequence objects.\n\n        just_pairs: if True, compute the phylogeny using only paired sequences.\n            Default (False) will use all sequences of the appropriate chain, paired or not.\n\n        scale (float): passed to ete3.TreeStyle() to set the scale of the tree figure. Increased\n            scale results in a wider tree.\n\n        branch_vert_margin (int): passed to ete3.TreeStyle() to set the branch_vertical_margin of\n            the tree figure. Increased branch_vert_margin results in a taller tree.\n\n        fontsize: size of the leaf labels. Default is 12.\n\n        show_names: show names of leaf nodes. Options are True (show labels for all leaf nodes),\n            False (don't show labels for any leaf nodes) or a list of sequence IDs for which\n            labels should be shown. Default is True.\n\n        mirror: flip the orientation of the tree. Default is to draw the tree from left to right.\n            Setting mirror to True results in the tree being drawn from right to left.\n\n        min_order_fraction: minimum fraction of downstream leaves requried to color a branch.\n            When coloring non-leaf nodes, the earliest 'order' with at least <min_order_fraction>\n            leaf nodes is used. Default is 0.1 (which corresponds to 10%).\n\n        figname_prefix: by default, figures will be named <lineage_id>.pdf. If prefix='prefix_' and\n            the lineage ID is 'ABC123', the figure file will be named 'prefix_ABC123.pdf'.\n\n        figname_suffix: by default, figures will be named <lineage_id>.pdf. If suffix='_suffix' and\n            the lineage ID is 'ABC123', the figure file will be named 'ABC123_suffix.pdf'.\n    '''\n\n    if project_dir is None:\n        print('\\nERROR: project_dir is required\\n')\n        sys.exit(1)\n    else:\n        project_dir = os.path.abspath(project_dir)\n\n    # make a name if one isn't provided\n    if name is None:\n        name = ''.join(random.choice(string.ascii_uppercase + string.digits) for _ in range(8))\n\n    # if sequences are provided, need to process them\n    if sequences is not None and all([arg is None for arg in [aln_file, tree_file]]):\n        sequences = deepcopy(sequences)\n        root = copy(root)\n\n        # if custom seq_field is specified, copy to the .sequence attribute\n        if seq_field is not None:\n            if not all([seq_field in list(s.annotations.keys()) for s in sequences]):\n                print('\\nERROR: {} is not present in all of the supplied sequences.\\n'.format(seq_field))\n                sys.exit(1)\n            for s in sequences:\n                s.alignment_sequence = s[seq_field]\n        else:\n            for s in sequences:\n                s.alignment_sequence = s.sequence\n\n        # if custom name_field is specified, copy to the .id attribute\n        if name_field is not None:\n            if not all([name_field in list(s.annotations.keys()) for s in sequences]):\n                print('\\nERROR: {} is not present in all of the supplied sequences.\\n'.format(name_field))\n                sys.exit(1)\n            for s in sequences:\n                s.alignment_id = s[name_field]\n        else:\n            for s in sequences:\n                s.alignment_id = s.id\n\n        # parse the root sequence\n        if unrooted:\n            root = None\n            root_name = None\n        elif root is None:\n            if not quiet:\n                print('\\nRoot sequence was was not provided. Using the germline V-gene.')\n            if not all(['v_gene' in list(s.annotations.keys()) for s in sequences]):\n                print('\\nInput sequences to not appear to be AbStar annotated. Annotating now...')\n                sequences = abstar.run(*[(s.id, s.sequence) for s in sequences])\n                print('Done.')\n            if not all(['full' in list(s['v_gene'].keys()) for s in sequences]):\n                print('\\nInput sequences to not appear to be AbStar annotated. Annotating now...')\n                sequences = abstar.run(*[(s.id, s.sequence) for s in sequences])\n                print('Done.')\n            top_vgene = sorted(list(Counter([s['v_gene']['full'] for s in sequences]).items()),\n                               key=lambda x: x[1],\n                               reverse=True)[0][0]\n            vgene = get_imgt_germlines(species, 'V', gene=top_vgene)\n            if aa:\n                root = Sequence(vgene.ungapped_aa_sequence, id=top_vgene)\n            else:\n                root = Sequence(vgene.ungapped_nt_sequence, id=top_vgene)\n            root.alignment_id = root.id\n            root.alignment_sequence = root.sequence\n            if not quiet:\n                print('Top V-gene: {}'.format(root.alignment_id))\n                print(root.alignment_sequence)\n        elif type(root) in STR_TYPES:\n            root = [s for s in sequences if s.alignment_id == root][0]\n            if not root:\n                print('\\nERROR: The name of the root sequence ({}) was not found in the list of input sequences.'.format(root))\n                print('\\n')\n                sys.exit(1)\n            sequences = [s for s in sequences if s.alignment_id != root.alignment_id]\n        elif type(root) == Sequence:\n            if seq_field is not None:\n                if seq_field not in list(root.anotations.keys()):\n                    print('\\nERROR: {} is not present in the supplied root sequence.\\n'.format(seq_field))\n                    sys.exit(1)\n                root.alignment_sequence = root[seq_field]\n            if name_field is not None:\n                if name_field not in list(root.anotations.keys()):\n                    print('\\nERROR: {} is not present in the supplied root sequence.\\n'.format(name_field))\n                    sys.exit(1)\n                root.alignment_id = root[name_field]\n            sequences = [s for s in sequences if s.alignment_id != root.alignment_id]\n        else:\n            print('\\nERROR: If root is provided, it must be the name of a sequence \\\n            found in the supplied list of sequences or it must be a Sequence object.')\n            print('\\n')\n            sys.exit(1)\n        if not unrooted:\n            if root_name is not None:\n                root.alignment_id = root_name\n            else:\n                root_name = root.alignment_id\n            sequences.append(root)\n\n    # parse sequences from aln_file, if provided\n    elif aln_file is not None:\n        if not unrooted and type(root) not in STR_TYPES:\n            print('\\nERROR: If providing an aln_file, the name of the root sequence must \\\n            be provided (as a string) using the root keyword argument')\n            print('\\n')\n            sys.exit(1)\n        _sequences = []\n        _root = None\n        for rec in AlignIO.read(open(aln_file), 'fasta'):\n            s = str(rec.seq).replace('-', '')\n            if rec.id == root:\n                _root = Sequence(s, rec.id)\n                _root.alignment_id = _root.id\n            else:\n                _s = Sequence(s, id=rec.id)\n                _s.alignment_id = rec.id\n                _sequences.append(_s)\n        if sequences is None:\n            sequences = _sequences\n        else:\n            sequence_ids = [s.id for s in sequences]\n            if any([_s.alignment_id not in sequence_ids for _s in _sequences]):\n                print('\\nWARNING: Sequences were found in the alignment file that were not included \\\n                      in the input sequence list. This may cause problems.')\n            for s in sequences:\n                s.alignment_id = s.id\n                s.alignment_sequence = s.sequence\n        if unrooted:\n            root = None\n            root_name = None\n        else:\n            if _root is None:\n                print('\\nERROR: The specified root ({}) was not found in the provided alignment file.'.format(root))\n                print('\\n')\n                sys.exit(1)\n            root = _root\n            if root_name is not None:\n                root.alignment_id = root_name\n            else:\n                root_name = root.alignment_id\n            sequences = [s for s in sequences if all([s.alignment_id != name for name in [root.id, root.alignment_id]])]\n            sequences.append(root)\n\n    # parse sequences from tree_file, if provided\n    elif tree_file is not None:\n        if not unrooted and type(root) not in STR_TYPES:\n            print('\\nERROR: If providing a tree_file, the name of the root sequence must \\\n            be provided (as a string) using the root keyword argument')\n            print('\\n')\n            sys.exit(1)\n        _sequences = []\n        _root = None\n        tree = Phylo.read(open(tree_file), 'newick')\n        for leaf in tree.get_terminals():\n            s = ''\n            if leaf.name == root:\n                _root = Sequence(s, leaf.name)\n                _root.alignment_id = _root.id\n            else:\n                _s = Sequence(s, id=leaf.name)\n                _s.alignment_id = leaf.name\n                _sequences.append(_s)\n        if sequences is None:\n            sequences = _sequences\n        else:\n            sequence_ids = [s.id for s in sequences]\n            if any([_s.alignment_id not in sequence_ids for _s in _sequences]):\n                print('\\nWARNING: Sequences were found in the alignment file that were not included \\\n                      in the input sequence list. This may cause problems.')\n            for s in sequences:\n                s.alignment_id = s.id\n                s.alignment_sequence = s.sequence\n        if unrooted:\n            root = None\n            root_name = None\n        elif _root is None:\n            print('\\nERROR: The specified root ({}) was not found in the provided tree file.'.format(root))\n            print('\\n')\n            sys.exit(1)\n        else:\n            root = _root\n            if root_name is not None:\n                root.alignment_id = root_name\n            else:\n                root_name = root.alignment_id\n            sequences = [s for s in sequences if all([s.alignment_id != name for name in [root.id, root.alignment_id]])]\n            sequences.append(root)\n\n    # set up colors and color ordering\n    if order_dict is None:\n        if order_function is not None:\n            order_dict = {seq.alignment_id: order_function(seq) for seq in sequences}\n    if color_dict is None:\n        if color_function is not None:\n            color_dict = {seq.alignment_id: color_function(seq) for seq in sequences}\n    if color_dict is None:\n        color_dict = {}\n\n    # make msa (if necessary)\n    if all([aln_file is None, tree_file is None]):\n        aln_file = os.path.abspath(os.path.join(project_dir, '{}.aln'.format(name)))\n        # muscle(seqs, aln_file, as_file=True)\n        do_print = False if quiet else True\n        if do_print:\n            print('\\n')\n        seqs = [(s.alignment_id, s.alignment_sequence) for s in sequences]\n        mafft(seqs, aln_file, as_file=True, print_stdout=do_print, print_stderr=do_print)\n\n    # make treefile (if necessary)\n    if tree_file is None:\n        tree_file = os.path.abspath(os.path.join(project_dir, '{}.nw'.format(name)))\n        fasttree(aln_file, tree_file, is_aa=aa, quiet=quiet)\n\n    # make phylogeny\n    prefix = '' if figname_prefix is None else figname_prefix\n    suffix = '' if figname_suffix is None else figname_suffix\n    fig_file = os.path.join(project_dir, '{}{}{}.pdf'.format(prefix, name, suffix))\n    _make_tree_figure(tree_file,\n                      fig_file,\n                      color_dict,\n                      order_dict,\n                      None if root is None else root.alignment_id,\n                      rename_function=rename_function,\n                      show_names=show_names,\n                      name_field=name_field,\n                      branch_vert_margin=branch_vert_margin,\n                      scale=scale,\n                      color_node_labels=color_node_labels,\n                      label_colors=label_colors,\n                      show_root_name=show_root_name,\n                      tree_orientation=1 if mirror else 0,\n                      fontsize=fontsize,\n                      min_order_fraction=min_order_fraction,\n                    #   linked_alignment=linked_alignment,\n                    #   alignment_fontsize=alignment_fontsize,\n                    #   alignment_height=alignment_height,\n                    #   alignment_width=alignment_width,\n                      show_scale=show_scale,\n                      compact_alignment=compact_alignment,\n                      scale_factor=scale_factor,\n                      linewidth=linewidth,\n                      ladderize=ladderize,\n                      delete_nodes=delete_nodes)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncomputes a phylogenetic tree using IgPhyML. .. note:: IgPhyML must be installed. It can be downloaded from https://github.com/kbhoehn/IgPhyML. Args: input_file (str): Path to a Phylip-formatted multiple sequence alignment. Required. tree_file (str): Path to the output tree file. root (str): Name of the root sequence. Required. verbose (bool): If `True`, prints the standard output and standard error for each IgPhyML run. Default is `False`.", "response": "def igphyml(input_file=None, tree_file=None, root=None, verbose=False):\n    '''\n    Computes a phylogenetic tree using IgPhyML.\n\n    .. note::\n        \n        IgPhyML must be installed. It can be downloaded from https://github.com/kbhoehn/IgPhyML.\n\n    Args:\n\n        input_file (str): Path to a Phylip-formatted multiple sequence alignment. Required.\n\n        tree_file (str): Path to the output tree file.\n\n        root (str): Name of the root sequence. Required.\n\n        verbose (bool): If `True`, prints the standard output and standard error for each IgPhyML run. \n            Default is `False`.\n    '''\n\n    if shutil.which('igphyml') is None:\n        raise RuntimeError('It appears that IgPhyML is not installed.\\nPlease install and try again.')\n    \n    # first, tree topology is estimated with the M0/GY94 model\n    igphyml_cmd1 = 'igphyml -i {} -m GY -w M0 -t e --run_id gy94'.format(aln_file)\n    p1 = sp.Popen(igphyml_cmd1, stdout=sp.PIPE, stderr=sp.PIPE)\n    stdout1, stderr1 = p1.communicate()\n    if verbose:\n        print(stdout1 + '\\n')\n        print(stderr1 + '\\n\\n')\n    intermediate = input_file + '_igphyml_tree.txt_gy94'\n\n    # now  we fit the HLP17 model once the tree topology is fixed\n    igphyml_cmd2 = 'igphyml -i {0} -m HLP17 --root {1} -o lr -u {}_igphyml_tree.txt_gy94 -o {}'.format(input_file,\n                                                                                                       root,\n                                                                                                       tree_file)\n    p2 = sp.Popen(igphyml_cmd2, stdout=sp.PIPE, stderr=sp.PIPE)\n    stdout2, stderr2 = p2.communicate()\n    if verbose:\n        print(stdout2 + '\\n')\n        print(stderr2 + '\\n')\n    return tree_file + '_igphyml_tree.txt'"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nappends all the web headers: * ZSL version and information, * default CORS if not already set up, * cache. :param f: The decorated function. :return: The function which appends the web headers.", "response": "def append_headers(f):\n    \"\"\"\n    Appends all the web headers:\n      * ZSL version and information,\n      * default CORS if not already set up,\n      * cache.\n\n    :param f: The decorated function.\n    :return: The function which appends the web headers.\n    \"\"\"\n    @wraps(f)\n    def _response_decorator(*args, **kwargs):\n        r = f(*args, **kwargs)\n        response = r if isinstance(r, Response) else make_response(r)\n        append_all(response)\n        return response\n\n    return _response_decorator"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef integrate_to_file(what, filename, start_line, end_line):\n\n    try:\n        with open(filename) as f:\n            lines = f.readlines()\n    except IOError:\n        lines = []\n\n    tmp_file = tempfile.NamedTemporaryFile(delete=False)\n\n    lines.reverse()\n\n    # first copy before start line\n    while lines:\n        line = lines.pop()\n\n        if line == start_line:\n            break\n\n        tmp_file.write(line)\n\n    # insert content\n    tmp_file.write(start_line)\n    tmp_file.write(what)\n    tmp_file.write(end_line)\n\n    # skip until end line\n    while lines:\n        line = lines.pop()\n\n        if line == end_line:\n            break\n\n    # copy rest\n    tmp_file.writelines(lines)\n    tmp_file.close()\n\n    os.rename(tmp_file.name, filename)", "response": "Integrate content into a file with line marks"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef update_model(raw_model, app_model, forbidden_keys=None, inverse=False):\n    if forbidden_keys is None:\n        forbidden_keys = []\n\n    if type(app_model) != dict:\n        app_model = app_model.__dict__\n\n    if inverse:\n        for k in app_model:\n            logging.debug(\"Considering property {0}.\".format(k))\n            if (hasattr(raw_model, k)) and (k not in forbidden_keys):\n                logging.debug(\"Setting property {0} to value '{1}'.\".format(k, app_model[k]))\n                setattr(raw_model, k, app_model[k])\n    else:\n        for k in raw_model.__dict__:\n            logging.debug(\"Considering property {0}.\".format(k))\n            if (k in app_model) and (k not in forbidden_keys):\n                logging.debug(\"Setting property {0} to value '{1}'.\".format(k, app_model[k]))\n                setattr(raw_model, k, app_model[k])", "response": "Updates the raw_model according to the values in the app_model."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef progress_bar(finished, total, start_time=None, extra_info=None,\n                 autocomplete=True, completion_string='/n'):\n    '''\n    Prints an ASCII progress bar.\n\n    Each call to ``progress_bar`` will update the progress bar. An example\n    of tracking the progress of a list of items would look like::\n\n        job_list = [job1, job2, job3, ... jobN]\n        total_jobs = len(job_list)\n\n        #initialize the progress bar\n        progress_bar(0, total_jobs)\n\n        # do the jobs\n        for i, job in enumerate(job_list):\n            do_job(job)\n            progress_bar(i + 1, total_jobs)\n\n    Args:\n\n        finished (int): Number of finished jobs.\n\n        total (int): Total number of jobs.\n\n        start_time (datetime): Start time, as a ``datetime.datetime`` object.\n            Only required if you want to display execution time alongside\n            the progress bar. If not provided, execution time is not shown.\n        \n        extra_info (str): A string containing extra information to be displayed\n            at the end of the progbar string. Examples include the number of failed\n            jobs, the name of the job batch currently being processed, etc.\n\n        complete (bool): If `True`, will append `completion_string` to the end\n            of the progbar string.\n\n        completion_string (str): Will be appended to the progbar string if\n            `complete` is `True`. Default is `'\\n\\n'`.\n\n    '''\n    pct = int(100. * finished / total)\n    ticks = int(pct / 2)\n    spaces = int(50 - ticks)\n    if start_time is not None:\n        elapsed = (datetime.now() - start_time).seconds\n        minutes = int(elapsed / 60)\n        seconds = int(elapsed % 60)\n        minute_str = '0' * (2 - len(str(minutes))) + str(minutes)\n        second_str = '0' * (2 - len(str(seconds))) + str(seconds)\n        prog_bar = '\\r({}/{}) |{}{}|  {}%  ({}:{})  '.format(finished, total,\n            '|' * ticks, ' ' * spaces, pct, minute_str, second_str)\n    else:\n        prog_bar = '\\r({}/{}) |{}{}|  {}%  '.format(finished, total,\n            '|' * ticks, ' ' * spaces, pct)\n    if extra_info is not None:\n        prog_bar += str(extra_info)\n    if autocomplete and finished == total:\n        prog_bar += completion_string\n    sys.stdout.write(prog_bar)\n    sys.stdout.flush()", "response": "Prints a progress bar for the given number of finished jobs and total number of failed jobs."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _ite(test: str, in1: str, in0: str, output: str = None):\n    r\"test -> in1 /\\ ~test -> in0\"\n    assert len({test, in0, in1}) == 3\n\n    true_out = bit_flipper([test]) >> or_gate([test, in1], 'true_out')\n    false_out = or_gate([test, in0], 'false_out')\n    return (true_out | false_out) >> and_gate(['true_out', 'false_out'],\n                                              output)", "response": "r test -> in1 | in0"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef update(self, app_model, forbidden_keys=None, inverse=False):\n        if forbidden_keys is None:\n            forbidden_keys = []\n\n        update_model(self, app_model, forbidden_keys, inverse)", "response": "Updates the raw model. Consult zsl. utils. model_helper. update_model."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nconvert XML element tree to JSON", "response": "def xml_to_json(element, definition, required=False):\n    # TODO document tuple - it looks little too complex\n    \"\"\"Convert XML (ElementTree) to dictionary from a definition schema.\n\n    Definition schema can be a simple string - XPath or @attribute for\n    direct extraction or a complex one described by\n\n    * dictionary ``{key: 'xpath or @attribute', second: 'complex definition'}`` \\\n      required parameters can be marked with * at the end\n    * list ``[xpath, [definition]]`` - create a list of all elements found by \\\n      xpath, parse the parts with given definition if provided as second \\\n      argument\n    * Callable - parse the element by given function, can be handy as a part \\\n      of complex definition\n\n    :param element: ElementTree element\n    :type element: ElementTree.Element\n    :param definition: schema for the json\n    :type definition: Union[str, tuple, dict, list, Callable]\n    :param required: parsed value should be not None\n    :type required: bool\n    :return: parsed xml\n    :rtype: Union[dict, str, list]\n    \"\"\"\n    # handle simple definition\n    if isinstance(definition, str) and len(definition) > 0:\n        if definition[0] == '@':  # test for attribute\n            return element.get(definition[1:])\n\n        # get tag text\n        else:\n            sub_element = element.find(definition)\n\n            if sub_element is None:\n                if required:\n                    raise NotCompleteXmlException('Expecting {0} in element {1}'.format(definition, element.tag))\n                return None\n\n            return sub_element.text.strip() if sub_element.text else None\n\n            # handle tuple\n    elif isinstance(definition, tuple):\n        return _parse_tuple(element, definition, required)\n\n    # handle dict\n    elif isinstance(definition, dict):\n        return _parse_dict(element, definition)\n\n    # handle list\n    elif isinstance(definition, list):\n        return _parse_list(element, definition)\n\n    elif hasattr(definition, '__call__'):\n        return definition(element)\n\n    # default\n    else:\n        return element.text.strip() if element.text else None"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _parse_dict(element, definition):\n    sub_dict = {}\n\n    for name, subdef in viewitems(definition):\n        (name, required) = _parse_name(name)\n\n        sub_dict[name] = xml_to_json(element, subdef, required)\n\n    return sub_dict", "response": "Parse xml element by a definition given in dict format."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _parse_tuple(element, definition, required):\n    # TODO needs to be documented properly.\n    d_len = len(definition)\n\n    if d_len == 0:\n        return None\n    if d_len == 1:\n        return xml_to_json(element, definition[0], required)\n\n    first = definition[0]\n\n    if hasattr(first, '__call__'):\n        # TODO I think it could be done without creating the array\n        # first(xml_to_json(element, d) for d in definition[1:]) test it\n        return first(*[xml_to_json(element, d) for d in definition[1:]])\n\n    if not isinstance(first, str):\n        raise XmlToJsonException('Tuple definition must start with function or string')\n\n    if first[0] == '@':\n        raise XmlToJsonException('Tuple definition must not start with attribute')\n\n    sub_elem = element.find(first)\n\n    if sub_elem is None:\n        if required:\n            raise NotCompleteXmlException('Expecting {0} in element {1}'.format(first, element.tag))\n\n        return None\n\n    return xml_to_json(sub_elem, definition[1], required)", "response": "Parse xml element by a definition given in tuple format."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _parse_list(element, definition):\n    if len(definition) == 0:\n        raise XmlToJsonException('List definition needs some definition')\n\n    tag = definition[0]\n    tag_def = definition[1] if len(definition) > 1 else None\n\n    sub_list = []\n\n    for el in element.findall(tag):\n        sub_list.append(xml_to_json(el, tag_def))\n\n    return sub_list", "response": "Parse xml element by definition given by list."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nparsing name in complex dict definition.", "response": "def _parse_name(name):\n    \"\"\"Parse name in complex dict definition.\n\n    In complex definition required params can be marked with `*`.\n\n    :param name:\n    :return: name and required flag\n    :rtype: tuple\n    \"\"\"\n    required = False\n\n    if name[-1] == '*':\n        name = name[0:-1]\n        required = True\n\n    return name, required"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_host_port(spec, default_port):\n    \"parse 'hostname:22' into a host and port, with the port optional\"\n    args = (spec.split(':', 1) + [default_port])[:2]\n    args[1] = int(args[1])\n    return args[0], args[1]", "response": "parse hostname : 22 into a host and port with the port optional"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef name(self):\n        '''\n        Returns the lineage name, or None if the name cannot be found.\n        '''\n        clonify_ids = [p.heavy['clonify']['id'] for p in self.heavies if 'clonify' in p.heavy]\n        if len(clonify_ids) > 0:\n            return clonify_ids[0]\n        return None", "response": "Returns the lineage name or None if the name cannot be found."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef verified_pairs(self):\n        '''\n        Returns all lineage Pair objects that contain verified pairings.\n        '''\n        if not hasattr(self.just_pairs[0], 'verified'):\n            self.verify_light_chains()\n        return [p for p in self.just_pairs if p.verified]", "response": "Returns all lineage Pair objects that contain verified pairings."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef size(self, pairs_only=False):\n        '''\n        Calculate the size of the lineage.\n\n        Inputs (optional)\n        -----------------\n        pairs_only: count only paired sequences\n\n        Returns\n        -------\n        Lineage size (int)\n        '''\n        if pairs_only:\n            return len(self.just_pairs)\n        else:\n            return len(self.heavies)", "response": "Calculate the size of the lineage."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nverify that the light chains are correctly paired.", "response": "def verify_light_chains(self, threshold=0.9):\n        '''\n        Clusters the light chains to identify potentially spurious (non-lineage)\n        pairings. Following clustering, all pairs in the largest light chain\n        cluster are assumed to be correctly paired. For each of those pairs,\n        the <verified> attribute is set to True. For pairs not in the largest\n        light chain cluster, the <verified> attribute is set to False.\n\n        Inputs (optional)\n        -----------------\n        threshold: CD-HIT clustering threshold. Default is 0.9.\n        '''\n        lseqs = [l.light for l in self.lights]\n        clusters = cluster(lseqs, threshold=threshold)\n        clusters.sort(key=lambda x: x.size, reverse=True)\n        verified_ids = clusters[0].ids\n        for p in self.lights:\n            p.verified = True if p.name in verified_ids else False"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef dot_alignment(self, seq_field='vdj_nt', name_field='seq_id', uca=None,\n            chain='heavy', uca_name='UCA', as_fasta=False, just_alignment=False):\n        '''\n        Returns a multiple sequence alignment of all lineage sequence with the UCA\n        where matches to the UCA are shown as dots and mismatches are shown as the\n        mismatched residue.\n\n        Inputs (optional)\n        -----------------\n        seq_field: the sequence field to be used for alignment. Default is 'vdj_nt'.\n        name_field: field used for the sequence name. Default is 'seq_id'.\n        chain: either 'heavy' or 'light'. Default is 'heavy'.\n\n        Returns\n        -------\n        The dot alignment (string)\n        '''\n        if uca is None:\n            uca = self.uca.heavy if chain == 'heavy' else self.uca.light\n        uca.id = 'UCA'\n        if chain == 'heavy':\n            sequences = [p.heavy for p in self.heavies if seq_field in p.heavy]\n            if name_field != 'seq_id':\n                uca[name_field] = uca['seq_id']\n            sequences.append(uca)\n            seqs = [(s[name_field], s[seq_field]) for s in sequences]\n        else:\n            sequences = [p.light for p in self.lights if seq_field in p.light]\n            if name_field != 'seq_id':\n                uca[name_field] = uca['seq_id']\n            sequences.append(uca)\n            seqs = [(s[name_field], s[seq_field]) for s in sequences]\n        aln = muscle(seqs)\n        g_aln = [a for a in aln if a.id == 'UCA'][0]\n        dots = [(uca_name, str(g_aln.seq)), ]\n        for seq in [a for a in aln if a.id != 'UCA']:\n            s_aln = ''\n            for g, q in zip(str(g_aln.seq), str(seq.seq)):\n                if g == q == '-':\n                    s_aln += '-'\n                elif g == q:\n                    s_aln += '.'\n                else:\n                    s_aln += q\n            dots.append((seq.id, s_aln))\n        if just_alignment:\n                return [d[1] for d in dots]\n        name_len = max([len(d[0]) for d in dots]) + 2\n        dot_aln = []\n        for d in dots:\n            if as_fasta:\n                dot_aln.append('>{}\\n{}'.format(d[0], d[1]))\n            else:\n                spaces = name_len - len(d[0])\n                dot_aln.append(d[0] + ' ' * spaces + d[1])\n        return '\\n'.join(dot_aln)", "response": "Returns a single alignment of all lineage sequences with the UCA as a single line."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef to_child(self, append_message=\"\", **kwargs):\n\n        bad_pars = set(kwargs) - set(self._child_params)\n        if bad_pars:\n            raise KeyError(\"Invalid init params for State: %s\" % \", \".join(bad_pars))\n\n        child = copy(self)\n        for k, v in kwargs.items():\n            setattr(child, k, v)\n        child.parent = self\n\n        # append messages\n        if not isinstance(append_message, dict):\n            append_message = {\"msg\": append_message, \"kwargs\": {}}\n        child.messages = [*self.messages, append_message]\n\n        return child", "response": "Basic implementation of returning a child state"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef complex_el_from_dict(parent, data, key):\n    el = ET.SubElement(parent, key)\n    value = data[key]\n\n    if isinstance(value, dict):\n        if '_attr' in value:\n            for a_name, a_value in viewitems(value['_attr']):\n                el.set(a_name, a_value)\n\n        if '_text' in value:\n            el.text = value['_text']\n\n    else:\n        el.text = value\n\n    return el", "response": "Create element from a dict definition and add it to parent element."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate element from dict data.", "response": "def element_from_dict(parent, data, element):\n    \"\"\"Create ``element`` to ``parent`` and sets its value to data[element], which\n    will be removed from the ``data``.\n\n    :param parent: parent element\n    :type parent: Element\n    :param data: dictionary where data[element] is desired value\n    :type data: dict(str, str)\n    :param element: name of the new element\n    :type element: str\n    :return: created element\n    \"\"\"\n    el = ET.SubElement(parent, element)\n    el.text = data.pop(element)\n\n    return el"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate RSS xml feed.", "response": "def rss_create(channel, articles):\n    \"\"\"Create RSS xml feed.\n\n    :param channel: channel info [title, link, description, language]\n    :type channel: dict(str, str)\n    :param articles: list of articles, an article is a dictionary with some \\\n    required fields [title, description, link] and any optional, which will \\\n    result to `<dict_key>dict_value</dict_key>`\n    :type articles: list(dict(str,str))\n    :return: root element\n    :rtype: ElementTree.Element\n    \"\"\"\n    channel = channel.copy()\n\n    # TODO use deepcopy\n    # list will not clone the dictionaries in the list and `elemen_from_dict`\n    # pops items from them\n    articles = list(articles)\n\n    rss = ET.Element('rss')\n    rss.set('version', '2.0')\n\n    channel_node = ET.SubElement(rss, 'channel')\n\n    element_from_dict(channel_node, channel, 'title')\n    element_from_dict(channel_node, channel, 'link')\n    element_from_dict(channel_node, channel, 'description')\n    element_from_dict(channel_node, channel, 'language')\n\n    for article in articles:\n        item = ET.SubElement(channel_node, 'item')\n\n        element_from_dict(item, article, 'title')\n        element_from_dict(item, article, 'description')\n        element_from_dict(item, article, 'link')\n\n        for key in article:\n            complex_el_from_dict(item, article, key)\n\n    return ET.ElementTree(rss)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncompute a hash of the given token with a preconfigured secret.", "response": "def compute_token(random_token, config):\n    \"\"\"Compute a hash of the given token with a preconfigured secret.\n\n    :param random_token: random token\n    :type random_token: str\n    :return: hashed token\n    :rtype: str\n    \"\"\"\n    secure_token = config[TOKEN_SERVICE_SECURITY_CONFIG]\n    sha1hash = hashlib.sha1()\n    sha1hash.update(random_token + secure_token)\n    return sha1hash.hexdigest().upper()"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nverifies an untrusted security token.", "response": "def verify_security_data(security):\n    \"\"\"Verify an untrusted security token.\n\n    :param security: security token\n    :type security: dict\n    :return: True if valid\n    :rtype: bool\n    \"\"\"\n    random_token = security[TOKEN_RANDOM]\n    hashed_token = security[TOKEN_HASHED]\n    return str(hashed_token) == str(compute_token(random_token))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef initialize(log_file, project_dir=None, debug=False):\n    '''\n    Initializes an AbTools pipeline.\n\n    Initialization includes printing the AbTools splash, setting up logging,\n    creating the project directory, and logging both the project directory\n    and the log location.\n\n    Args:\n\n        log_file (str): Path to the log file. Required.\n\n        project_dir (str): Path to the project directory. If not provided,\n            the project directory won't be created and the location won't be logged.\n\n        debug (bool): If ``True``, the logging level will be set to ``logging.DEBUG``.\n            Default is ``FALSE``, which logs at ``logging.INFO``.\n\n    Returns:\n\n        logger\n    '''\n    print_splash()\n    log.setup_logging(log_file, print_log_location=False, debug=debug)\n    logger = log.get_logger('pipeline')\n    if project_dir is not None:\n        make_dir(os.path.normpath(project_dir))\n        logger.info('PROJECT DIRECTORY: {}'.format(project_dir))\n        logger.info('')\n    logger.info('LOG LOCATION: {}'.format(log_file))\n    print('')\n    return logger", "response": "Initializes an AbTools pipeline."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef list_files(d, extension=None):\n    '''\n    Lists files in a given directory.\n\n    Args:\n\n        d (str): Path to a directory.\n\n        extension (str): If supplied, only files that contain the\n            specificied extension will be returned. Default is ``False``,\n            which returns all files in ``d``.\n\n    Returns:\n\n        list: A sorted list of file paths.\n    '''\n    if os.path.isdir(d):\n        expanded_dir = os.path.expanduser(d)\n        files = sorted(glob.glob(expanded_dir + '/*'))\n    else:\n        files = [d, ]\n    if extension is not None:\n        if type(extension) in STR_TYPES:\n            extension = [extension, ]\n        files = [f for f in files if any([f.split('.')[-1] in extension,\n                                          f.split('.')[-1].upper() in extension,\n                                          f.split('.')[-1].lower() in extension])]\n    return files", "response": "Lists files in a given directory."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nclicking callback for option to show current ZSL version.", "response": "def _get_version(ctx, _, value):\n    \"\"\"Click callback for option to show current ZSL version.\"\"\"\n\n    if not value or ctx.resilient_parsing:\n        return\n    message = 'Zsl %(version)s\\nPython %(python_version)s'\n    click.echo(message % {\n        'version': version,\n        'python_version': sys.version,\n    }, color=ctx.color)\n    ctx.exit()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncreate a model resource from a dict with resource descriptions.", "response": "def create_model_resource(resource_map, name, app=Injected):\n    \"\"\"Create a model resource from a dict ``resource_map``\n    {'resource name': ('model package', 'model class')}\n\n    :param resource_map: dict with resource descriptions\n    :type resource_map: dict(str, tuple(str))\n    :param name: name of the concrete resource\n    :param app: current application, injected\n    :type app: Zsl\n    :return: instantiated model resource\n    \"\"\"\n    try:\n        resource_description = resource_map[name]\n        if len(resource_description) == 2:\n            module_name, model_name = resource_map[name]\n            resource_class = ModelResource\n        elif len(resource_description) == 3:\n            module_name, model_name, resource_class = resource_map[name]\n        else:\n            raise ImportError(\"Invalid resource description for resource '{0}'\".format(name))\n    except KeyError:\n        raise ImportError(\"Missing resource description for resource '{0}'\".format(name))\n\n    module = importlib.import_module(module_name)\n    model_cls = getattr(module, model_name)\n\n    return app.injector.create_object(resource_class, {'model_cls': model_cls})"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef dict_pick(dictionary, allowed_keys):\n    return {key: value for key, value in viewitems(dictionary) if key in allowed_keys}", "response": "Return a dictionary only with keys found in allowed_keys"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ntransform page per_page from params to limit and offset.", "response": "def page_to_offset(params):\n    \"\"\"\n    Transforms `page`/`per_page` from `params` to `limit`/`offset` suitable for SQL.\n\n    :param dict params: The dictionary containing `page` and `per_page` values will be added\n                        the values `limit` and `offset`.\n    \"\"\"\n\n    if 'page' not in params:\n        return\n\n    page = params['page']\n    del params['page']\n\n    # 'per_page' je len alias za 'limit'\n    if 'per_page' in params:\n        per_page = params.get('per_page')\n        del params['per_page']\n    else:\n        per_page = params.get('limit', 10)\n\n    params['offset'] = int(per_page) * (int(page) - 1)\n    params['limit'] = per_page"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\npost / resource / model_cls / data Create new resource", "response": "def create(self, params, args, data):\n        # type: (str, dict, dict) -> AppModel\n        \"\"\"\n        POST /resource/model_cls/\n        data\n\n        Create new resource\n        \"\"\"\n        ctx = self._create_context(params, args, data)\n        model = self._create_one(ctx)\n        self._save_one(model, ctx)\n        return self._return_saved_one(model, ctx)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget all AppModels for a specific resource.", "response": "def read(self, params=None, args=None, data=None):\n        # type: (str, dict, dict) -> Union[List[AppModel], AppModel]\n        \"\"\"\n        GET /resource/model_cls/[params:id]?[args:{limit,offset,page,per_page,filter_by,order_by,related,fields}]\n\n        Get resource/s\n\n        :param params\n        :type params list\n        :param args\n        :type args dict\n        :param data\n        :type data: dict\n        \"\"\"\n        if params is None:\n            params = []\n        if args is None:\n            args = {}\n\n        ctx = self._create_context(params, args, data)\n        row_id = ctx.get_row_id()\n\n        if row_id:\n            return self._get_one(row_id, ctx)\n\n        elif 'count' in args:\n            return self._get_collection_count(ctx)\n\n        elif 'desc' in args:\n            return self._get_collection_desc(ctx)\n\n        else:\n            if 'page' in ctx.args:\n                page_to_offset(ctx.args)\n\n            return self._get_collection(ctx)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef update(self, params, args, data):\n        # type: (str, dict, dict) -> Union[List[AppModel], AppModel]\n        \"\"\"\n        PUT /resource/model_cls/[params:id]\n        data\n\n        Update resource/s\n        \"\"\"\n        ctx = self._create_context(params, args, data)\n        row_id = ctx.get_row_id()\n\n        if row_id is not None:\n            model = self._update_one(ctx)\n            return None if model is None else model.get_app_model()\n        else:\n            return app_models(self._update_collection(ctx))", "response": "Update the resource s related resources."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating an instance of the model class based on the given context.", "response": "def _create_one(self, ctx):\n        \"\"\"\n        Creates an instance to be saved when a model is created.\n        \"\"\"\n        assert isinstance(ctx, ResourceQueryContext)\n\n        fields = dict_pick(ctx.data, self._model_columns)\n        model = self.model_cls(**fields)\n        return model"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _save_one(self, model, ctx):\n        assert isinstance(ctx, ResourceQueryContext)\n\n        self._orm.add(model)\n        self._orm.flush()", "response": "Saves the created instance."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nupdating one entry in the cache", "response": "def _update_one(self, ctx):\n        \"\"\"\n        Update row\n        \"\"\"\n        assert isinstance(ctx, ResourceQueryContext)\n        fields = ctx.data\n        row_id = ctx.get_row_id()\n        return self._update_one_simple(row_id, fields, ctx)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nbulking update a collection of all the items in the context.", "response": "def _update_collection(self, ctx):\n        \"\"\"\n        Bulk update\n        \"\"\"\n        assert isinstance(ctx, ResourceQueryContext)\n        models = []\n\n        for row in ctx.data:\n            models.append(self._update_one_simple(row.pop('id'), row, ctx))\n\n        return models"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _create_delete_one_query(self, row_id, ctx):\n\n        assert isinstance(ctx, ResourceQueryContext)\n        return self._orm.query(self.model_cls).filter(self._model_pk == row_id)", "response": "Create a delete query for the record with the given id."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _delete_collection(self, ctx):\n        assert isinstance(ctx, ResourceQueryContext)\n\n        filter_by = ctx.get_filter_by()\n        q = self._orm.query(self.model_cls)\n\n        if filter_by is not None:\n            q = self.to_filter(q, filter_by)\n\n        return q.delete()", "response": "Delete a collection from DB optionally filtered by filter_by"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nsend an email. :param sender: Sender as string or None for default got from config. :param receivers: String or array of recipients. :param subject: Subject. :param text: Plain text message. :param html: Html message. :param charset: Charset. :param config: Current configuration", "response": "def send_email(sender, receivers, subject, text=None, html=None, charset='utf-8', config=Injected):\n    \"\"\"Sends an email.\n\n    :param sender: Sender as string or None for default got from config.\n    :param receivers: String or array of recipients.\n    :param subject: Subject.\n    :param text: Plain text message.\n    :param html: Html message.\n    :param charset: Charset.\n    :param config: Current configuration\n    \"\"\"\n    smtp_config = config['SMTP']\n\n    # Receivers must be an array.\n    if not isinstance(receivers, list) and not isinstance(receivers, tuple):\n        receivers = [receivers]\n\n    # Create the messages\n    msgs = []\n    if text is not None:\n        msgs.append(MIMEText(text, 'plain', charset))\n\n    if html is not None:\n        msgs.append(MIMEText(html, 'html', charset))\n\n    if len(msgs) == 0:\n        raise Exception(\"No message is given.\")\n\n    if len(msgs) == 1:\n        msg = msgs[0]\n    else:\n        msg = MIMEMultipart()\n        for m in msgs:\n            msg.attach(m)\n\n    # Default sender.\n    if sender is None:\n        sender = smtp_config['SENDER']\n\n    # Fill the info.\n    msg['Subject'] = subject\n    msg['From'] = sender\n    msg['To'] = \", \".join(receivers)\n\n    # Send.\n    smtp_server = smtplib.SMTP(**(smtp_config['SERVER']))\n    smtp_server.sendmail(sender, receivers, msg.as_string())\n    smtp_server.quit()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef add_packages(self, packages):\n        # type: (List[str])->TaskNamespace\n        assert isinstance(packages, list), \"Packages must be list of strings.\"\n        self._task_packages += packages\n        return self", "response": "Adds an automatic resolution of urls into tasks."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef route(self, path):\n        # type: (str)->Tuple[Any, Callable]\n        \"\"\"\n        Returns the task handling the given request path.\n        \"\"\"\n        logging.getLogger(__name__).debug(\"Routing path '%s'.\", path)\n\n        cls = None\n        for strategy in self._strategies:\n            if strategy.can_route(path):\n                cls = strategy.route(path)\n                break\n\n        if cls is None:\n            raise RoutingError(path)\n\n        return self._create_result(cls)", "response": "Returns the task handling the given request path."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _create_result(self, cls):\n        # type:(Callable)->Tuple[Any, Callable]\n        \"\"\"\n        Create the task using the injector initialization.\n        :param cls:\n        :return:\n        \"\"\"\n        task = instantiate(cls)\n        logging.getLogger(__name__).debug(\"Task object {0} created [{1}].\".format(cls.__name__, task))\n        return task, get_callable(task)", "response": "Create the task using the injector initialization."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nconverts ABI or AB1 files to FASTA format.", "response": "def abi_to_fasta(input, output):\n    '''\n    Converts ABI or AB1 files to FASTA format.\n\n    Args:\n\n         input (str): Path to a file or directory containing abi/ab1 files or\n            zip archives of abi/ab1 files\n\n        output (str): Path to a directory for the output FASTA files\n    '''\n    direcs = [input, ]\n    # unzip any zip archives\n    zip_files = list_files(input, ['zip'])\n    if zip_files:\n        direcs.extend(_process_zip_files(zip_files))\n    # convert files\n    for d in direcs:\n        files = list_files(d, ['ab1', 'abi'])\n        seqs = [SeqIO.read(open(f, 'rb'), 'abi') for f in files]\n        # seqs = list(chain.from_iterable(seqs))\n        fastas = ['>{}\\n{}'.format(s.id, str(s.seq)) for s in seqs]\n        ofile = os.path.basename(os.path.normpath(d)) + '.fasta'\n        opath = os.path.join(output, ofile)\n        open(opath, 'w').write('\\n'.join(fastas))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef extend(instance, new_class):\n    instance.__class__ = type(\n        '%s_extended_with_%s' % (instance.__class__.__name__, new_class.__name__),\n        (new_class, instance.__class__,),\n        {}\n    )", "response": "Extends an instance with new_class."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef generate_js_models(module, models, collection_prefix, model_prefix,\n                       model_fn, collection_fn, marker, integrate, js_file):\n    # type: (str, str, str, str, str, str, str, bool, str) -> Union[str, None]\n    \"\"\"Generate models for Backbone Javascript applications.\n\n    :param module: module from which models are imported\n    :param models: model name, can be a tuple WineCountry/WineCountries as singular/plural\n    :param model_prefix: namespace prefix for models (app.models.)\n    :param collection_prefix: namespace prefix for collection (App.collections.)\n    :param model_fn: name of model constructor (MyApp.bb.Model)\n    :param collection_fn: name of collection constructor (MyApp.bb.Collection)\n    :param marker: marker to indicate the auto generated code\n    :param integrate: integrate to file\n    :param js_file: file to integrate\n    :return: generated models or nothing if writing into a file\n    \"\"\"\n\n    options = {\n        'model_prefix': model_prefix,\n        'collection_prefix': collection_prefix,\n        'model_fn': model_fn,\n        'collection_fn': collection_fn\n    }\n\n    generator = ModelGenerator(module,\n                               **{o: options[o] for o in options if options[o] is not None})\n\n    models = generator.generate_models(parse_model_arg(models))\n\n    if integrate:\n        sys.stderr.write(\"Integrate is really experimental\")\n\n        if not marker:\n            marker = hashlib.md5(\"{0}{1}\".format(module, models)).hexdigest()\n\n        start = \"// * -- START AUTOGENERATED %s -- * //\\n\" % marker\n        end = \"// * -- END AUTOGENERATED %s -- * //\\n\" % marker\n\n        return integrate_to_file(\"\\n\".join(models), js_file, start, end)\n\n    else:\n        return \"\\n\".join(models)", "response": "Generates a list of models for Backbone Javascript applications."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nmapping the model names to the corresponding table name.", "response": "def _map_table_name(self, model_names):\n        \"\"\"\n        Pre foregin_keys potrbejeme pre z nazvu tabulky zistit class,\n        tak si to namapujme\n        \"\"\"\n\n        for model in model_names:\n            if isinstance(model, tuple):\n                model = model[0]\n\n            try:\n                model_cls = getattr(self.models, model)\n                self.table_to_class[class_mapper(model_cls).tables[0].name] = model\n            except AttributeError:\n                pass"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef push_msg(self, channel_id, msg):\n\n        if type(msg) is not str:\n            msg = urlencode(msg)\n\n        return self.push(channel_id, msg)", "response": "Push a message to the cache."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef push_object(self, channel_id, obj):\n\n        return self.push(channel_id, json.dumps(obj).replace('\"', '\\\\\"'))", "response": "Push an object to the cache."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\npushing a message with POST data for channel_id", "response": "def push(self, channel_id, data):\n        \"\"\"Push message with POST ``data`` for ``channel_id``\n        \"\"\"\n\n        channel_path = self.channel_path(channel_id)\n        response = requests.post(channel_path, data)\n\n        return response.json()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ndeleting a channel from the cache", "response": "def delete_channel(self, channel_id):\n        \"\"\"Deletes channel\n        \"\"\"\n        req = requests.delete(self.channel_path(channel_id))\n        return req"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nnormalizes string converts to lowercase removes non - alpha characters removes non - alpha characters removes spaces to hyphens.", "response": "def slugify(value, allow_unicode=False):\n    \"\"\"Normalizes string, converts to lowercase, removes non-alpha characters,\n    and converts spaces to hyphens.\n\n    :param value: string\n    :param allow_unicode: allow utf8 characters\n    :type allow_unicode: bool\n    :return: slugified string\n    :rtype: str\n\n    :Example:\n        >>> slugify('pekn\u00e1 l\u00ed\u0161\u010di\u010dka')\n        'pekna-liscicka'\n    \"\"\"\n    value = str(value)\n\n    if allow_unicode:\n        value = unicodedata.normalize('NFKC', value)\n        value = re.sub(r'[^\\w\\s-]', '', value, flags=re.U).strip().lower()\n        return re.sub(r'[-\\s]+', '-', value, flags=re.U)\n    else:\n        value = unicodedata.normalize('NFKD', value).encode('ascii', 'ignore').decode('ascii')\n        value = re.sub(r'[^\\w\\s-]', '', value).strip().lower()\n        return re.sub('[-\\s]+', '-', value)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef urlencode(query):\n    if hasattr(urllib, 'parse'):\n        return urllib.parse.urlencode(query)\n    else:\n        return urllib.urlencode(query)", "response": "Encode string to be used in urls ( percent encoding."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef initialize():\n        from zsl.interface.web.performers.default import create_not_found_mapping\n        from zsl.interface.web.performers.resource import create_resource_mapping\n\n        create_not_found_mapping()\n        create_resource_mapping()", "response": "Initializes the application objects for the given base application level."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef run_web(self, flask, host='127.0.0.1', port=5000, **options):\n        # type: (Zsl, str, int, **Any)->None\n        \"\"\"Alias for Flask.run\"\"\"\n        return flask.run(\n            host=flask.config.get('FLASK_HOST', host),\n            port=flask.config.get('FLASK_PORT', port),\n            debug=flask.config.get('DEBUG', False),\n            **options\n        )", "response": "Alias for Flask. run"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef execute_command(self, command, args=None):\n\n        if args is None:\n            args = {}\n\n        command_fn = self.commands[command]\n\n        return command_fn(**args)", "response": "Execute a command in the cache."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef bound(self, instance):\n\n        bounded_dispatcher = CommandDispatcher()\n        bounded_dispatcher.commands = self.commands.copy()\n\n        for name in self.commands:\n            method = getattr(instance, name, None)\n\n            if method and inspect.ismethod(method) and method.__self__ == instance:\n                bounded_dispatcher.commands[name] = method\n\n        return bounded_dispatcher", "response": "Returns a new dispatcher which will switch all command functions\n        with bounded methods of given instance."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncompress data and uploads to S3.", "response": "def compress_and_upload(data, compressed_file, s3_path, multipart_chunk_size_mb=500,\n    method='gz', delete=False, access_key=None, secret_key=None):\n    '''\n    Compresses data and uploads to S3.\n\n    S3 upload uses ``s3cmd``, so you must either:\n\n        1) Manually configure ``s3cmd`` prior to use (typically using ``s3cmd --configure``).\n\n        2) Configure ``s3cmd`` using ``s3.configure()``.\n\n        3) Pass your access key and secret key to ``compress_and_upload``, which will automatically configure s3cmd.\n\n    .. note:\n\n        ``s3cmd`` configuration only needs to be done once per computer,\n        which means that relaunching a cloud instance or Docker image will\n        require re-configuration of ``s3cmd``.\n\n    Args:\n\n        data: Can be one of three things:\n\n            1) Path to a single file\n\n            2) Path to a directory\n\n            3) A list of one or more paths to files or directories\n\n        compressed_file (str): Path to the compressed file. Required.\n\n        s3_path (str): The S3 path, with the filename omitted. The S3 filename\n          will be the basename of the ``compressed_file``. For example::\n\n            compress_and_upload(data='/path/to/data',\n                                compressed_file='/path/to/compressed.tar.gz',\n                                s3_path='s3://my_bucket/path/to/')\n\n          will result in an uploaded S3 path of ``s3://my_bucket/path/to/compressed.tar.gz``\n\n        method (str): Compression method. Options are ``'gz'`` (gzip) or ``'bz2'`` (bzip2).\n            Default is ``'gz'``.\n\n        delete (bool): If ``True``, the ``compressed_file`` will be deleted after upload\n            to S3. Default is ``False``.\n\n        access_key (str): AWS access key.\n\n        secret_key (str): AWS secret key.\n    '''\n    logger = log.get_logger('s3')\n    if all([access_key, secret_key]):\n        configure(access_key=access_key, secret_key=secret_key, logger=logger)\n    compress(data, compressed_file, fmt=method, logger=logger)\n    put(compressed_file, s3_path, multipart_chunk_size_mb=multipart_chunk_size_mb, logger=logger)\n    if delete:\n        os.unlink(compressed_file)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nupload a single file to S3 using s3cmd.", "response": "def put(f, s3_path, multipart_chunk_size_mb=500, logger=None):\n    '''\n    Uploads a single file to S3, using s3cmd.\n\n    Args:\n\n        f (str): Path to a single file.\n\n        s3_path (str): The S3 path, with the filename omitted. The S3 filename\n            will be the basename of the ``f``. For example::\n\n                put(f='/path/to/myfile.tar.gz', s3_path='s3://my_bucket/path/to/')\n\n            will result in an uploaded S3 path of ``s3://my_bucket/path/to/myfile.tar.gz``\n    '''\n    if not logger:\n        logger = log.get_logger('s3')\n    fname = os.path.basename(f)\n    target = os.path.join(s3_path, fname)\n    s3cmd_cline = 's3cmd put {} {} --multipart-chunk-size-mb {}'.format(f,\n                                                                        target,\n                                                                        multipart_chunk_size_mb)\n    print_put_info(fname, target, logger)\n    s3cmd = sp.Popen(s3cmd_cline,\n                     stdout=sp.PIPE,\n                     stderr=sp.PIPE,\n                     shell=True)\n    stdout, stderr = s3cmd.communicate()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncompress a set of files or directories.", "response": "def compress(d, output, fmt='gz', logger=None):\n    '''\n    Creates a compressed/uncompressed tar file.\n\n    Args:\n\n        d: Can be one of three things:\n\n            1. the path to a single file, as a string\n\n            2. the path to a single directory, as a string\n\n            3. an iterable of file or directory paths\n\n        output (str): Output file path.\n\n        fmt: Compression method. Options are ``'gz'`` (gzip),\n            ``'bz2'`` (bzip2) and ``'none'`` (uncompressed). Default is ``'gz'``.\n    '''\n    if not logger:\n        logger = log.get_logger('s3')\n    if type(d) not in [list, tuple]:\n        d = [d, ]\n    d = [os.path.expanduser(_d) for _d in d]\n    print_compress_info(d, output, compress, logger)\n    if fmt.lower() == 'none':\n        fmt = ''\n    elif fmt.lower() not in ['gz', 'bz2']:\n        logger.info('Compression option (\"{}\") is invalid.\\nFalling back to uncompressed.'.format(fmt))\n        fmt = ''\n    output = os.path.expanduser(output)\n    tar = tarfile.open(output, 'w:{}'.format(fmt))\n    for obj in d:\n        tar.add(obj)\n    tar.close()\n    return output"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef configure(access_key=None, secret_key=None, logger=None):\n    '''\n    Configures s3cmd prior to first use.\n\n    If no arguments are provided, you will be prompted to enter\n    the access key and secret key interactively.\n\n    Args:\n\n        access_key (str): AWS access key\n\n        secret_key (str): AWS secret key\n    '''\n    if not logger:\n        logger = log.get_logger('s3')\n    if not all([access_key, secret_key]):\n        logger.info('')\n        access_key = input('AWS Access Key: ')\n        secret_key = input('AWS Secret Key: ')\n    _write_config(access_key, secret_key)\n    logger.info('')\n    logger.info('Completed writing S3 config file.')\n    logger.info('')", "response": "Configure s3cmd prior to first use."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nchecking if given parameters are in the given dict raises RequestException if not", "response": "def required_params(data, *r_params):\n    \"\"\"Check if given parameters are in the given dict, if not raise an\n    exception.\n\n    :param data: data to check\n    :type data: dict\n    :param r_params: required parameters\n    :raises RequestException: if params not in data\n    \"\"\"\n\n    if not reduce(lambda still_valid, param: still_valid and param in data,\n                  r_params, True):\n        raise RequestException(msg_err_missing_params(*r_params))"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nchecks if args as a dictionary has the required parameters of fn and filter any waste parameters so fn can be safely called with them.", "response": "def safe_args(fn, args):\n    \"\"\"Check if ``args`` as a dictionary has the required parameters of ``fn``\n    function and filter any waste parameters so ``fn`` can be safely called\n    with them.\n\n    :param fn: function object\n    :type fn: Callable\n    :param args: dictionary of parameters\n    :type args: dict\n    :return: dictionary to be used as named params for the ``fn``\n    :rtype: dict\n    \"\"\"\n    fn_args = inspect.getargspec(fn)\n\n    if fn_args.defaults:\n        required_params(args, fn_args.args[:-len(fn_args.defaults)])\n    else:\n        required_params(args, fn_args)\n\n    if not fn_args.keywords:\n        return {key: value for key, value in viewitems(args) if key in fn_args.args}\n    else:\n        return args"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_db(db, ip='localhost', port=27017, user=None, password=None):\n    '''\n    Returns a pymongo Database object.\n\n    .. note:\n\n        Both ``user`` and ``password`` are required when connecting to a MongoDB\n        database that has authentication enabled.\n\n    Arguments:\n\n        db (str): Name of the MongoDB database. Required.\n\n        ip (str): IP address of the MongoDB server. Default is ``localhost``.\n\n        port (int): Port of the MongoDB server. Default is ``27017``.\n\n        user (str): Username, if authentication is enabled on the MongoDB database.\n            Default is ``None``, which results in requesting the connection\n            without authentication.\n\n        password (str): Password, if authentication is enabled on the MongoDB database.\n            Default is ``None``, which results in requesting the connection\n            without authentication.\n    '''\n    if platform.system().lower() == 'darwin':\n        connect = False\n    else:\n        connect = True\n    if user and password:\n        import urllib\n        pwd = urllib.quote_plus(password)\n        uri = 'mongodb://{}:{}@{}:{}'.format(user, pwd, ip, port)\n        conn = MongoClient(uri, connect=connect)\n    else:\n        conn = MongoClient(ip, port, connect=connect)\n    return conn[db]", "response": "Returns a pymongo Database object."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a sorted list of collection names found in a MongoDB database.", "response": "def get_collections(db, collection=None, prefix=None, suffix=None):\n    '''\n    Returns a sorted list of collection names found in ``db``.\n\n    Arguments:\n\n        db (Database): A pymongo Database object. Can be obtained\n            with ``get_db``.\n\n        collection (str): Name of a collection. If the collection is\n            present in the MongoDB database, a single-element list will\n            be returned with the collecion name. If not, an empty list\n            will be returned. This option is primarly included to allow\n            for quick checking to see if a collection name is present.\n            Default is None, which results in this option being ignored.\n\n        prefix (str): If supplied, only collections that begin with\n            ``prefix`` will be returned.\n\n        suffix (str): If supplied, only collections that end with\n            ``suffix`` will be returned.\n\n    Returns:\n\n        list: A sorted list of collection names.\n    '''\n    if collection is not None:\n        return [collection, ]\n    collections = db.collection_names(include_system_collections=False)\n    if prefix is not None:\n        collections = [c for c in collections if c.startswith(prefix)]\n    if suffix is not None:\n        collections = [c for c in collections if c.endswith(suffix)]\n    return sorted(collections)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nrename a MongoDB collection.", "response": "def rename_collection(db, collection, new_name):\n    '''\n    Renames a MongoDB collection.\n\n    Arguments:\n\n        db (Database): A pymongo Database object. Can be obtained\n            with ``get_db``.\n\n        collection (str): Name of the collection to be renamed.\n\n        new_name (str, func): ``new_name`` can be one of two things::\n\n            1. The new collection name, as a string.\n            2. A function which, when passed the current collection name,\n                returns the new collection name. If the function\n                returns an empty string, the collection will not be\n                renamed.\n    '''\n    if hasattr(new_name, '__call__'):\n        _new = new_name(collection)\n        if _new == '':\n            return\n    else:\n        _new = new_name\n    c = db[collection]\n    c.rename(_new)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nupdate the value of the field in the specified collection with the given value.", "response": "def update(field, value, db, collection, match=None):\n    '''\n    Updates MongoDB documents.\n\n    Sets ``field`` equal to ``value`` for all documents that\n    meet ``match`` criteria.\n\n    Arguments:\n\n        field (str): Field to update.\n\n        value (str): Update value.\n\n        db (Database): A pymongo Database object.\n\n        collection (str): Collection name.\n\n        match (dict): A dictionary containing the match criteria, for example::\n\n            {'seq_id': {'$in': ['a', 'b', 'c']}, 'cdr3_len': {'$gte': 18}}\n    '''\n    c = db[collection]\n    match = match if match is not None else {}\n    # check MongoDB version to use appropriate update command\n    if db.client.server_info()['version'].startswith('2'):\n        c.update(match, {'$set': {field: value}}, multi=True)\n    else:\n        c.update_many(match, {'$set': {field: value}})"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nperform mongoimport on one or more json files. Args: json: Can be one of several things: - path to a single JSON file - an iterable (list or tuple) of one or more JSON file paths - path to a directory containing one or more JSON files database (str): Name of the database into which the JSON files will be imported ip (str): IP address of the MongoDB server. Default is ``localhost``. port (int): Port of the MongoDB database. Default is ``27017``. user (str): Username for the MongoDB database, if authentication is enabled. Default is ``None``, which results in attempting connection without authentication. password (str): Password for the MongoDB database, if authentication is enabled. Default is ``None``, which results in attempting connection without authentication. delim (str): Delimiter, when generating collection names using a single delimiter. Default is ``_`` delim_occurance (int): Occurance at which to split filename when using a single delimiter. Default is ``1`` delim1 (str): Left delimiter when splitting with two delimiters. Default is None. delim1_occurance (int): Occurance of ``delim1`` at which to split filename. Default is ``1`` delim2 (str): Right delimiter when splitting with two delimiters. Default is None. delim2_occurance (int): Occurance of ``delim2`` at which to split filename. Default is ``1``", "response": "def mongoimport(json, database,\n                ip='localhost', port=27017,\n                user=None, password=None,\n                delim='_', delim1=None, delim2=None,\n                delim_occurance=1, delim1_occurance=1, delim2_occurance=1):\n    '''\n    Performs mongoimport on one or more json files.\n\n    Args:\n\n        json: Can be one of several things:\n\n            - path to a single JSON file\n            - an iterable (list or tuple) of one or more JSON file paths\n            - path to a directory containing one or more JSON files\n\n        database (str): Name of the database into which the JSON files\n            will be imported\n\n        ip (str): IP address of the MongoDB server. Default is ``localhost``.\n\n        port (int): Port of the MongoDB database. Default is ``27017``.\n\n        user (str): Username for the MongoDB database, if authentication is enabled.\n            Default is ``None``, which results in attempting connection without\n            authentication.\n\n        password (str): Password for the MongoDB database, if authentication is enabled.\n            Default is ``None``, which results in attempting connection without\n            authentication.\n\n        delim (str): Delimiter, when generating collection names using a single delimiter.\n            Default is ``_``\n\n        delim_occurance (int): Occurance at which to split filename when using a\n            single delimiter. Default is ``1``\n\n        delim1 (str): Left delimiter when splitting with two delimiters. Default is None.\n\n        delim1_occurance (int): Occurance of ``delim1`` at which to split filename.\n            Default is ``1``\n\n        delim2 (str): Right delimiter when splitting with two delimiters. Default is None.\n\n        delim2_occurance (int): Occurance of ``delim2`` at which to split filename.\n            Default is ``1``\n    '''\n    logger = log.get_logger('mongodb')\n    _print_mongoimport_info(logger)\n    if type(json) in (list, tuple):\n        pass\n    elif os.path.isdir(json):\n        from abtools.utils.pipeline import list_files\n        json = list_files(json)\n    else:\n        json = [json, ]\n    jsons = sorted([os.path.expanduser(j) for j in json if j.endswith('.json')])\n    collections = _get_import_collections(jsons, delim, delim_occurance,\n                                          delim1, delim1_occurance,\n                                          delim2, delim2_occurance)\n    logger.info('Found {} files to import'.format(len(jsons)))\n    logger.info('')\n    for i, (json_file, collection) in enumerate(zip(jsons, collections)):\n        logger.info('[ {} ] {} --> {}'.format(i + 1, os.path.basename(json_file), collection))\n        # logger.info(\"Performing mongoimport on {}.\".format(os.path.basename(json_file)))\n        # logger.info(\"Importing the file into collection {}.\".format(collection))\n        if all([user, password]):\n            host = '--host {} --port {} -username {} -password {}'.format(ip, port, user, password)\n        else:\n            host = '--host {} --port {}'.format(ip, port)\n        mongo_cmd = \"mongoimport {} --db {} --collection {} --file {}\".format(\n            host, database, collection, json_file)\n        mongo = sp.Popen(mongo_cmd, shell=True, stdout=sp.PIPE, stderr=sp.PIPE)\n        stdout, stderr = mongo.communicate()"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nbuilds a simple or complex index on a single collection.", "response": "def index(db, collection, fields, directions=None, desc=False, background=False):\n    '''\n    Builds a simple (single field) or complex (multiple fields) index\n    on a single collection in a MongoDB database.\n\n    Args:\n\n        db (Database): A pymongo Database object.\n\n        collection (str): Collection name.\n\n        fields: Can be one of two things:\n\n            - the name of a single field, as a string\n            - an iterable (list/tuple) of one or more field names\n\n        desc (bool): If ``True``, all indexes will be created in descending order.\n            Default is ``False``.\n\n        directions (list): For complex indexes for which you'd like to have\n            different indexing directions (ascending for some fields, descending\n            for others), you can pass a list of pymongo direction objects (\n            pymongo.ASCENDING and pymongo.DESCENDING), in the same order as the\n            list of fields to be indexed. Must be the same length as the list\n            of index fields. Default is ``None``.\n\n        background (bool): If ``True``, the indexing operation will be processed\n            in the background. When performing background indexes, the MongoDB\n            database will not be locked.\n    '''\n    import pymongo\n    if type(fields) in STR_TYPES:\n        fields = [fields, ]\n    if directions is None:\n        _dir = pymongo.DESCENDING if desc else pymongo.ASCENDING\n        directions = [_dir] * len(fields)\n    field_tuples = list(zip(fields, directions))\n    coll = db[collection]\n    coll.create_index(field_tuples, background=background)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_settings_from_profile(profile, profile_dir=None):\n    # type: (str, Any)->str\n    \"\"\"\"Returns the  configuration file path for the given profile.\n\n    :param profile: Profile name to be used.\n    :param profile_dir: The directory where the profile configuration file should reside. It\n                        may be also a module, and then the directory of the module is used.\n    :return: Configuration file path.\n    \"\"\"\n    if profile_dir is None:\n        import settings\n        profile_dir = settings\n\n    if hasattr(profile_dir, '__file__'):\n        profile_dir = os.path.dirname(profile_dir.__file__)\n\n    return os.path.join(profile_dir, '{0}.cfg'.format(profile))", "response": "Returns the  configuration file path for the given profile."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nread the configuration from config files.", "response": "def _configure(self, config_object=None):\n        # type: (Any) -> None\n        \"\"\"Read the configuration from config files.\n        Loads the default settings and the profile settings if available.\n        Check :func:`.set_profile`.\n\n        :param config_object:\n            This parameter is the configuration decscription may be a dict or\n            string describing the module from which the configuration is used.\n            Default is settings.default_settings.\n        \"\"\"\n\n        if config_object:\n            self.config.from_mapping(config_object)\n        else:\n            self.config.from_object(self._default_settings_module)\n\n        zsl_settings = os.environ.get(SETTINGS_ENV_VAR_NAME)\n        if zsl_settings is not None:\n            self.config.from_envvar(SETTINGS_ENV_VAR_NAME)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a function which binds the current app and configuration.", "response": "def _get_app_module(self):\n        # type: () -> Callable\n        \"\"\"Returns a module which binds the current app and configuration.\n\n        :return: configuration callback\n        :rtype: Callable\n        \"\"\"\n\n        def configure(binder):\n            # type: (Binder) -> Callable\n            binder.bind(ServiceApplication, to=self, scope=singleton)\n            binder.bind(Config, to=self.config, scope=singleton)\n\n        return configure"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating the injector and install the modules.", "response": "def _configure_injector(self, modules):\n        \"\"\"Create the injector and install the modules.\n\n        There is a necessary order of calls. First we have to bind `Config` and\n        `Zsl`, then we need to register the app into the global stack and then\n        we can install all other modules, which can use `Zsl` and `Config`\n        injection.\n\n        :param modules: list of injection modules\n        :type modules: list\n        \"\"\"\n        self._register()\n        self._create_injector()\n        self._bind_core()\n        self._bind_modules(modules)\n        self.logger.debug(\"Injector configuration with modules {0}.\".format(modules))\n        self._dependencies_initialized = True"}
